     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 10/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15 (2.11)
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  ; ----------------------------------------------------------------------------
    43                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    44                                  
    45                                  ;============================================================================
    46                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    47                                  ;============================================================================
    48                                  ; 21/09/2018 - Retro DOS v3.0
    49                                  
    50                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    51                                  ;BREAK <system call definitions>
    52                                  
    53                                  ;
    54                                  ;	Microsoft Confidential
    55                                  ;	Copyright (C) Microsoft Corporation 1991
    56                                  ;	All Rights Reserved.
    57                                  ;
    58                                  
    59                                  ;SUBTTL	system call definitions
    60                                  ;PAGE
    61                                  
    62                                  Abort				EQU 0	;  0	  0
    63                                  STD_CON_INPUT			EQU 1	;  1	  1
    64                                  Std_Con_Output			EQU 2	;  2	  2
    65                                  Std_Aux_Input			EQU 3	;  3	  3
    66                                  Std_Aux_Output			EQU 4	;  4	  4
    67                                  Std_Printer_Output		EQU 5	;  5	  5
    68                                  Raw_Con_IO			EQU 6	;  6	  6
    69                                  RAW_CON_INPUT			EQU 7	;  7	  7
    70                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    71                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    72                                  Std_Con_String_Input		EQU 10	; 10	  A
    73                                  Std_Con_Input_Status		EQU 11	; 11	  B
    74                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    75                                  DISK_RESET			EQU 13	; 13	  D
    76                                  Set_Default_Drive		EQU 14	; 14	  E
    77                                  FCB_Open			EQU 15	; 15	  F
    78                                  FCB_Close			EQU 16	; 16	 10
    79                                  Dir_Search_First		EQU 17	; 17	 11
    80                                  Dir_Search_Next 		EQU 18	; 18	 12
    81                                  FCB_Delete			EQU 19	; 19	 13
    82                                  FCB_Seq_Read			EQU 20	; 20	 14
    83                                  FCB_Seq_Write			EQU 21	; 21	 15
    84                                  FCB_Create			EQU 22	; 22	 16
    85                                  FCB_Rename			EQU 23	; 23	 17
    86                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    87                                  Set_DMA 			EQU 26	; 26	 1A
    88                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    89                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    90                                  ;									   ;
    91                                  Get_Default_DPB 		EQU 31	; 31	 1F
    92                                  ;									   ;
    93                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    94                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    95                                  FCB_Random_Read 		EQU 33	; 33	 21
    96                                  FCB_Random_Write		EQU 34	; 34	 22
    97                                  Get_FCB_File_Length		EQU 35	; 35	 23
    98                                  Get_FCB_Position		EQU 36	; 36	 24
    99                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   100                                  Create_Process_Data_Block	EQU 38	; 38	 26
   101                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   102                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   103                                  Parse_File_Descriptor		EQU 41	; 41	 29
   104                                  Get_Date			EQU 42	; 42	 2A
   105                                  Set_Date			EQU 43	; 43	 2B
   106                                  Get_Time			EQU 44	; 44	 2C
   107                                  Set_Time			EQU 45	; 45	 2D
   108                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   109                                  ; Extended functionality group
   110                                  Get_DMA 			EQU 47	; 47	 2F
   111                                  GET_VERSION			EQU 48	; 48	 30
   112                                  Keep_Process			EQU 49	; 49	 31
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   115                                  ;									   ;
   116                                  Get_DPB 			EQU 50	; 50	 32
   117                                  ;									   ;
   118                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   119                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   120                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   121                                  Get_InDOS_Flag			EQU 52	; 52	 34
   122                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   123                                  Get_Drive_Freespace		EQU 54	; 54	 36
   124                                  CHAR_OPER			EQU 55	; 55	 37
   125                                  International			EQU 56	; 56	 38
   126                                  ;   Directory Group
   127                                  MKDir				EQU 57	; 57	 39
   128                                  RMDir				EQU 58	; 58	 3A
   129                                  CHDir				EQU 59	; 59	 3B
   130                                  ;   File Group
   131                                  Creat				EQU 60	; 60	 3C
   132                                  OPEN				EQU 61	; 61	 3D
   133                                  CLOSE				EQU 62	; 62	 3E
   134                                  READ				EQU 63	; 63	 3F
   135                                  Write				EQU 64	; 64	 40
   136                                  Unlink				EQU 65	; 65	 41
   137                                  LSEEK				EQU 66	; 66	 42
   138                                  CHMod				EQU 67	; 67	 43
   139                                  IOCTL				EQU 68	; 68	 44
   140                                  XDUP				EQU 69	; 69	 45
   141                                  XDup2				EQU 70	; 70	 46
   142                                  Current_Dir			EQU 71	; 71	 47
   143                                  ;    Memory Group
   144                                  ALLOC				EQU 72	; 72	 48
   145                                  DEALLOC				EQU 73	; 73	 49
   146                                  SETBLOCK			EQU 74	; 74	 4A
   147                                  ;    Process Group
   148                                  Exec				EQU 75	; 75	 4B
   149                                  EXIT				EQU 76	; 76	 4C
   150                                  WAITPROCESS			EQU 77	; 77	 4D
   151                                  Find_First			EQU 78	; 78	 4E
   152                                  ;   Special Group
   153                                  Find_Next			EQU 79	; 79	 4F
   154                                  ; SPECIAL SYSTEM GROUP
   155                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   156                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   157                                  ;									   ;
   158                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   159                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   160                                  Get_In_Vars			EQU 82	; 82	 52
   161                                  SetDPB				EQU 83	; 83	 53
   162                                  ;									   ;
   163                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  Get_Verify_On_Write		EQU 84	; 84	 54
   166                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   167                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   168                                  ;									   ;
   169                                  Dup_PDB 			EQU 85	; 85	 55
   170                                  ;									   ;
   171                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   172                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   173                                  Rename				EQU 86	; 86	 56
   174                                  File_Times			EQU 87	; 87	 57
   175                                  AllocOper			EQU 88	; 88	 58
   176                                  ; Network extention system calls
   177                                  GetExtendedError		EQU 89	; 89	 59
   178                                  CreateTempFile			EQU 90	; 90	 5A
   179                                  CreateNewFile			EQU 91	; 91	 5B
   180                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   181                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;									   ;
   184                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   185                                  					;	    CloseByName, CloseUser,
   186                                  					;	    CloseUserProcess,
   187                                  					;	    GetOpenFileList
   188                                  ;									   ;
   189                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   190                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   191                                  UserOper			EQU 94	; 94	 5E Get and Set
   192                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   193                                  xNameTrans			EQU 96	; 96	 60
   194                                  PathParse			EQU 97	; 97	 61
   195                                  GetCurrentPSP			EQU 98	; 98	 62
   196                                  Hongeul 			EQU 99	; 99	 63
   197                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   198                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   199                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   200                                  ;									   ;
   201                                  Set_Printer_Flag		EQU 100 ; 100	 64
   202                                  ;									   ;
   203                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   204                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   205                                  GetExtCntry			EQU 101 ; 101	 65
   206                                  GetSetCdPg			EQU 102 ; 102	 66
   207                                  ExtHandle			EQU 103 ; 103	 67
   208                                  Commit				EQU 104 ; 104	 68
   209                                  GetSetMediaID			EQU 105 ; 105	 69
   210                                  IFS_IOCTL			EQU 107 ; 107	 6B
   211                                  ExtOpen 			EQU 108 ; 108	 6C
   212                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   213                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   214                                  ;                                                                          ;
   215                                  ;ifdef ROMEXEC
   216                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   217                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   218                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   219                                  ;endif
   220                                  ;                                                                          ;
   221                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   222                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   223                                  ;
   224                                  ;
   225                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   226                                  OEM_C1				EQU 249 ; 249	 F9
   227                                  OEM_C2				EQU 250 ; 250	 FA
   228                                  OEM_C3				EQU 251 ; 251	 FB
   229                                  OEM_C4				EQU 252 ; 252	 FC
   230                                  OEM_C5				EQU 253 ; 253	 FD
   231                                  OEM_C6				EQU 254 ; 254	 FE
   232                                  OEM_C7				EQU 255 ; 255	 FF
   233                                  
   234                                  ;============================================================================
   235                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   236                                  ;============================================================================
   237                                  ; 21/09/2018 - Retro DOS v3.0
   238                                  
   239                                  ;BREAK <Control character definitions>
   240                                  
   241                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   242                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   243                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   244                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   245                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   246                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   247                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   248                                  c_HT	    EQU     09h 	; ^I ASCII tab
   249                                  
   250                                  ;============================================================================
   251                                  ; DIRENT.INC, MSDOS 6.0, 1991
   252                                  ;============================================================================
   253                                  ; 21/09/2018 - Retro DOS v3.0
   254                                  
   255                                  ;Break <Directory entry>
   256                                  
   257                                  ;	NOTE:  These offsets are also used in the DTA for
   258                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   259                                  ;	with the FCB filename field, and the rest of the
   260                                  ;	DIR_ENTRY fields follow. -DavidOls
   261                                  
   262                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   263                                  ;
   264                                  ;	+---------------------------+
   265                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   266                                  ;	+---------------------------+
   267                                  ;	|     (BYTE) attributes     |	    11	    B
   268                                  ;	+---------------------------+
   269                                  ;	|    (10 BYTE) reserved     |	    12	    C
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) time of last write |	    22	    16
   272                                  ;	+---------------------------+
   273                                  ;	| (WORD) date of last write |	    24	    18
   274                                  ;	+---------------------------+
   275                                  ;	|   (WORD) First cluster    |	    26	    1A
   276                                  ;	+---------------------------+
   277                                  ;	|     (DWORD) file size     |	    28	    1C
   278                                  ;	+---------------------------+
   279                                  ;
   280                                  ;   First byte of filename  = E5 -> free directory entry
   281                                  ;			    = 00 -> end of allocated directory
   282                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   283                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   284                                  ;
   285                                  
   286                                  STRUC DIR_ENTRY
   287 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   288 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   289 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   290 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   291 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   292 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   293 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   294 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   295 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   296 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   297 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   298                                  .size:
   299                                  
   300                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   301                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   302                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   303                                  ;	    this field is zero for subdirectory files.
   304                                  
   305                                  ENDSTRUC
   306                                  
   307                                  ATTR_READ_ONLY	equ	 1h
   308                                  ATTR_HIDDEN	equ	 2h
   309                                  ATTR_SYSTEM	equ	 4h
   310                                  ATTR_VOLUME_ID	equ	 8h
   311                                  ATTR_DIRECTORY	equ	10h
   312                                  ATTR_ARCHIVE	equ	20h
   313                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   314                                  				;   NO directory entry on a disk EVER
   315                                  				;   has this bit set. It is set non-zero
   316                                  				;   when a device is found by GETPATH
   317                                  
   318                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   319                                  				; OR of hard attributes for FINDENTRY
   320                                  
   321                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   322                                  				; ignore this(ese) attribute(s) during
   323                                  				; search first/next
   324                                  
   325                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   326                                  				; changeable via CHMOD
   327                                  
   328                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   329                                  
   330                                  ;============================================================================
   331                                  ; ERROR.INC, MSDOS 6.0, 1991
   332                                  ;============================================================================
   333                                  ; 21/09/2018 - Retro DOS v3.0
   334                                  
   335                                  ;**	ERROR.INC - DOS Error Codes
   336                                  ;
   337                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   338                                  ;    return error codes through AX.	If an error occurred then
   339                                  ;    the carry bit will be set and the error code is in AX.	If no error
   340                                  ;    occurred then the carry bit is reset and AX contains returned info.
   341                                  ;
   342                                  ;    Since the set of error codes is being extended as we extend the operating
   343                                  ;    system, we have provided a means for applications to ask the system for a
   344                                  ;    recommended course of action when they receive an error.
   345                                  ;
   346                                  ;    The GetExtendedError system call returns a universal error, an error
   347                                  ;    location and a recommended course of action.	The universal error code is
   348                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   349                                  ;    is issued.
   350                                  
   351                                  
   352                                  ;	2.0 error codes
   353                                  
   354                                  error_invalid_function		EQU	1
   355                                  ERROR_FILE_NOT_FOUND		EQU	2
   356                                  ERROR_PATH_NOT_FOUND		EQU	3
   357                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   358                                  ERROR_ACCESS_DENIED		EQU	5
   359                                  error_invalid_handle		EQU	6
   360                                  error_arena_trashed		EQU	7
   361                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   362                                  error_invalid_block		EQU	9
   363                                  error_bad_environment		EQU	10
   364                                  ERROR_BAD_FORMAT		EQU	11
   365                                  error_invalid_access		EQU	12
   366                                  ERROR_INVALID_DATA		EQU	13
   367                                  ;**** reserved			EQU	14	; *****
   368                                  error_invalid_drive		EQU	15
   369                                  error_current_directory 	EQU	16
   370                                  error_not_same_device		EQU	17
   371                                  ERROR_NO_MORE_FILES		EQU	18
   372                                  
   373                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   374                                  
   375                                  ERROR_WRITE_PROTECT		EQU	19
   376                                  error_bad_unit			EQU	20
   377                                  error_not_ready 		EQU	21
   378                                  error_bad_command		EQU	22
   379                                  error_CRC			EQU	23
   380                                  error_bad_length		EQU	24
   381                                  error_Seek			EQU	25
   382                                  error_not_DOS_disk		EQU	26
   383                                  error_sector_not_found		EQU	27
   384                                  error_out_of_paper		EQU	28
   385                                  error_write_fault		EQU	29
   386                                  error_read_fault		EQU	30
   387                                  ERROR_GEN_FAILURE		EQU	31
   388                                  
   389                                  ;	the new 3.0 error codes reported through INT 24
   390                                  
   391                                  error_sharing_violation 	EQU	32
   392                                  error_lock_violation		EQU	33
   393                                  error_wrong_disk		EQU	34
   394                                  ERROR_FCB_UNAVAILABLE		EQU	35
   395                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   396                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   397                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   398                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   399                                  
   400                                  ;	New OEM network-related errors are 50-79
   401                                  
   402                                  error_not_supported		EQU	50
   403                                  
   404                                  error_net_access_denied		EQU	65	;M028
   405                                  
   406                                  ;	End of INT 24 reportable errors
   407                                  
   408                                  error_file_exists		EQU	80
   409                                  error_DUP_FCB			EQU	81	; *****
   410                                  error_cannot_make		EQU	82
   411                                  error_FAIL_I24			EQU	83
   412                                  
   413                                  ;	New 3.0 network related error codes
   414                                  
   415                                  error_out_of_structures 	EQU	84
   416                                  error_Already_assigned		EQU	85
   417                                  error_invalid_password		EQU	86
   418                                  error_invalid_parameter 	EQU	87
   419                                  error_NET_write_fault		EQU	88
   420                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   421                                  
   422                                  ;============================================================================
   423                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   424                                  ;============================================================================
   425                                  ; 22/09/2018 - Retro DOS v3.0
   426                                  
   427                                  ;**	DevSym.inc - Device Symbols
   428                                  
   429                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   430                                  
   431                                  STRUC SYSDEV
   432 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   433 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   434 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   435 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   436 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   437                                  .size:
   438                                  ENDSTRUC
   439                                  
   440                                  ; 24/09/2018
   441                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   442                                  
   443                                  ;============================================================================
   444                                  ; CURDIR.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 21/09/2018 - Retro DOS v3.0
   447                                  
   448                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   449                                  
   450                                  ;============================================================================
   451                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   452                                  ;============================================================================
   453                                  ; 21/09/2018 - Retro DOS v3.0
   454                                  
   455                                  ;/*
   456                                  ; *                      Microsoft Confidential
   457                                  ; *                      Copyright (C) Microsoft Corporation 1991
   458                                  ; *                      All Rights Reserved.
   459                                  ; */
   460                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;*************************************
   463                                  ; COMMAND EQUs which are not switch dependant
   464                                  
   465                                  ;		include	curdir.inc	; to get DIRSTRLEN
   466                                  ;		Note dossym.inc must already have been included!
   467                                  
   468                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   469                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   470                                  
   471                                  SYM		EQU	">"
   472                                  
   473                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   474                                  
   475                                  NORMPERLIN	EQU	1
   476                                  WIDEPERLIN	EQU	5
   477                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   478                                  BatLen		EQU	32		; buffer for batch files
   479                                  YES_ECHO	EQU	1		; echo line
   480                                  NO_ECHO 	EQU	0		; don't echo line
   481                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   482                                  call_in_progress EQU	1		; indicate we're in the CALL command
   483                                  length_call	EQU	4		; length of CALL
   484                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   485                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   486                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   487                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   488                                  nullcommand	EQU     1		; no command on command line
   489                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   490                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   491                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   492                                  result_number	EQU	1		;AN000; number returned from parser
   493                                  result_string	EQU	3		;AN000; string returned from parser
   494                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   495                                  result_drive	EQU	6		;AN000; drive returned from parser
   496                                  result_date	EQU	7		;AN000; date returned from parser
   497                                  result_time	EQU	8		;AN000; time returned from parser
   498                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   499                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   500                                  util_msg_class	EQU	-1		;AN000; message class for utility
   501                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   502                                  parse_msg_class EQU	2		;AN000; message class for parse error
   503                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   504                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   505                                  colon_char	EQU	":"             ;AN000; colon character
   506                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   507                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   508                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   509                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   510                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   511                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   512                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   513                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   514                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   515                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   516                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   517                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   518                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   519                                  parm_block_size equ	11		;AN000; size of message subst block
   520                                  blank		equ	" "             ;AN000; blank character
   521                                  no_subst	equ	0		;AN000; no substitutions for messages
   522                                  one_subst	equ	1		;AN000; one substitution for messages
   523                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   524                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   525                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   526                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   527                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   528                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   529                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   530                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   531                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   532                                  capital_A	equ	'A'             ;AC000;
   533                                  vbar		equ	'|'             ;AC000;
   534                                  labracket	equ	'<'             ;AC000;
   535                                  rabracket	equ	'>'             ;AC000;
   536                                  dollar		equ	'$'             ;AC000;
   537                                  lparen		equ	'('             ;AC000;
   538                                  rparen		equ	')'             ;AC000;
   539                                  nullrparen	equ	29h		;AC000;
   540                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   541                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   542                                  star		equ	'*'             ;AC000;
   543                                  plus_chr	equ	'+'             ;AC000;
   544                                  small_a 	equ	'a'             ;AC000;
   545                                  small_z 	equ	'z'             ;AC000;
   546                                  dot_chr 	equ	'.'             ;AC000;
   547                                  tab_chr 	equ	9		;AN032;
   548                                  equal_chr	equ	'='             ;AN032;
   549                                  semicolon	equ	';'             ;AN049;
   550                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   551                                  dot_colon	equ	2e3ah		;AC000; '.:'
   552                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   553                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   554                                  AppendInstall	equ	0B700H		;AN020; append install check
   555                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   556                                  AppendGetState	equ	0B706H		;AN020; append get current state
   557                                  AppendSetState	equ	0B707H		;AN020; append set current state
   558                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   559                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   560                                  
   561                                  ;*************************************
   562                                  ;* PARSE ERROR MESSAGES
   563                                  ;*************************************
   564                                  
   565                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   566                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   567                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   568                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   569                                  
   570                                  ;*************************************
   571                                  ;* EQUATES FOR MESSAGE RETRIEVER
   572                                  ;*************************************
   573                                  
   574                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   575                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   576                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   577                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   578                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   579                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   580                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   581                                  
   582                                  ;*********************************
   583                                  ;* EQUATES FOR INT 10H
   584                                  ;*********************************
   585                                  
   586                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   587                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   588                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   589                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   590                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   591                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   592                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   593                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   594                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   595                                  
   596                                  AltPipeChr	equ	"|"             ; alternate pipe character
   597                                  
   598                                  FCB		equ	5Ch
   599                                  
   600                                  STRUC VARSTRUC
   601 00000000 ??                      .ISDIR:		RESB	1
   602 00000001 ??                      .SIZ:		RESB	1
   603 00000002 ????                    .TTAIL:		RESW	1
   604 00000004 ??                      .INFO:		RESB	1
   605 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   606                                  .size:
   607                                  ENDSTRUC
   608                                  ;
   609                                  ; Flags for internal command parsing
   610                                  ;
   611                                  fCheckDrive	equ	00000001b	; validate drive letter
   612                                  fSwitchAllowed	equ	00000010b	; switches allowed
   613                                  fLimitHelp	equ	00000100b	; /? must appear alone
   614                                  
   615                                  ;
   616                                  ; Test switches
   617                                  ;
   618                                  fParse		EQU	0001h		; display results of parseline
   619                                  
   620                                  ;
   621                                  ; Batch segment structure
   622                                  ;
   623                                  ;   BYTE    type of segment
   624                                  ;   BYTE    echo state of parent on entry to batch file
   625                                  ;   WORD    segment of last batch file
   626                                  ;   WORD    segment for FOR command
   627                                  ;   BYTE    FOR flag state on entry to batch file
   628                                  ;   DWORD   offset for next line
   629                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   630                                  ;   ASCIZ   file name (with . and ..)
   631                                  ;   BYTES   CR-terminated parameters
   632                                  ;   BYTE    0 flag to indicate end of parameters
   633                                  ;
   634                                  
   635                                  BATCHTYPE   equ 0
   636                                  
   637                                  STRUC BATCHSEGMENT
   638 00000000 ??                      .BatType:	RESB	1		; signature
   639 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   640                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   641 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   642 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   643 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   644 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   645 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   646 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   647 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   648                                  .SIZE:
   649                                  ENDSTRUC
   650                                  
   651                                  ANULL		equ	0		; terminates an argv string
   652                                  ARGMAX		equ	64		; max args on a command line
   653                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   654                                  tplen		equ	64		; max size of one argument
   655                                  arg_cnt_error	equ	1		; number of args > MAXARG
   656                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   657                                  
   658                                  STRUC ARGV_ELE				; elements in the argv array
   659 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   660 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   661 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   662 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   663 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   664 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   665                                  .SIZE:
   666                                  ENDSTRUC
   667                                  
   668                                  STRUC ARG_UNIT
   669 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   670 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   671 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   672 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   673 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   674                                  .SIZE:
   675                                  ENDSTRUC
   676                                  
   677                                  ; Equates for initialization
   678                                  ;
   679                                  INITINIT	equ	01h		; initialization in progress
   680                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   681                                  INITCTRLC	equ	04h		; already in ^C handler
   682                                  
   683                                  ;============================================================================
   684                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   685                                  ;============================================================================
   686                                  ; 16/04/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   687                                  
   688                                  ; Current structure of the data returned by the international call
   689                                  
   690                                  struc INTERNAT_BLOCK
   691 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   692 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   693 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   694 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   695 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   696 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   697 0000000F ??                      .bit_field:	resb 1			; Bit values
   698                                  					;   Bit 0 = 0 if currency symbol first
   699                                  					;	  = 1 if currency symbol last
   700                                  					;   Bit 1 = 0 if No space after currency symbol
   701                                  					;	  = 1 if space after currency symbol
   702                                  .currency_cents:
   703 00000010 ??                      		resb 1			; Number of places after currency dec point
   704 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   705 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   706                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   707                                  					;  in pieces.
   708 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   709 00000017 ??                      		resb 1
   710                                  endstruc
   711                                  
   712                                  ; Max size of the block returned by the INTERNATIONAL call
   713                                  
   714                                  internat_block_max equ 32
   715                                  
   716                                  ;============================================================================
   717                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   718                                  ;============================================================================
   719                                  ; 13/10/2018 - Retro DOS v3.0
   720                                  ; 16/02/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   721                                  
   722                                  ;Break	<find first/next buffer>
   723                                  
   724                                  	; MSDOS 3.3 & MSDOS 6.0
   725                                  
   726                                  struc FIND_BUF
   727 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   728 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   729 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   730 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   731 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   732 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   733 00000015 ??                      .ATTR:	    resb 1	; attribute found
   734 00000016 ????                    .TIMR:	    resw 1	; time
   735 00000018 ????                    .DATE:	    resw 1	; date
   736 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   737 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   738 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   739                                  .size:
   740                                  endstruc
   741                                  
   742                                  ;=============================================================================
   743                                  ; PDB.INC, MSDOS 6.0, 1991
   744                                  ;=============================================================================
   745                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   746                                  
   747                                  ;**	Process data block (otherwise known as program header)
   748                                  
   749                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   750                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   751                                  ;	for use.
   752                                  
   753                                  FILPERPROC	EQU     20
   754                                  
   755                                  struc PDB	; Process_data_block
   756 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   757 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   758 00000004 ??                                      resb 1
   759 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   760 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   761 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   762 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   763 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   764 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   765 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   766 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   767 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   768 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   769 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   770 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   771 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   772 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   773 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   774 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   775 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   776 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   777                                  				;  an extended FCB
   778                                  ;endstruc 	; MSDOS 3.3
   779                                  	  	; MSDOS 6.0
   780 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   781 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   782 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   783 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   784                                  endstruc
   785                                  
   786                                  ;=============================================================================
   787                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   788                                  ;=============================================================================
   789                                  ; 24/09/2018 - Retro DOS v3.0
   790                                  
   791                                  ;major_version	equ 6		; Major DOS version
   792                                  ;minor_version	equ 0		; Minor DOS Version
   793                                  
   794                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   795                                  
   796                                  ; MSDOS 3.3 COMMAND.COM
   797                                  ;MAJOR_VERSION	EQU 3
   798                                  ;MINOR_VERSION	EQU 30
   799                                  
   800                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   801                                  MAJOR_VERSION	EQU 5		; Major DOS version
   802                                  MINOR_VERSION	EQU 0		; Minor DOS version
   803                                  
   804                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   805                                  
   806                                  ;-----------------------------------------------------------------------------
   807                                  ; 21/09/2018
   808                                  ;-----------------------------------------------------------------------------
   809                                  ; Retro DOS v3.0 NOTE:  
   810                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   811                                  ;	with minor modifications which are done by me (Erdogan Tan).
   812                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   813                                  ;	source code files (written by using MASM syntax).
   814                                  ;-----------------------------------------------------------------------------
   815                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   816                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   817                                  ;----------------------------------------------------------------------------- 	
   818                                  
   819                                  ;=============================================================================
   820                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   821                                  ;=============================================================================
   822                                  ; 21/09/2018 - Retro DOS v3.0
   823                                  
   824                                  ;	page ,132
   825                                  ;	title	COMMAND - resident code for COMMAND.COM
   826                                  ;	name	COMMAND
   827                                  
   828                                  ;/*
   829                                  ; *                      Microsoft Confidential
   830                                  ; *                      Copyright (C) Microsoft Corporation 1991
   831                                  ; *                      All Rights Reserved.
   832                                  ; */
   833                                  
   834                                  ;*****************************************************************************
   835                                  ;
   836                                  ; MODULE:	       COMMAND.COM
   837                                  ;
   838                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   839                                  ;
   840                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   841                                  ;		       parts.  First is the resident portion, which includes
   842                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   843                                  ;		       error), and 2EH (command line execute); it also has
   844                                  ;		       code to test and, if necessary, reload the transient
   845                                  ;		       portion. Following the resident is the init code, which
   846                                  ;		       is overwritten after use.  Then comes the transient
   847                                  ;		       portion, which includes all command processing (whether
   848                                  ;		       internal or external).  The transient portion loads at
   849                                  ;		       the end of physical memory, and it may be overlayed by
   850                                  ;		       programs that need as much memory as possible. When the
   851                                  ;		       resident portion of command regains control from a user
   852                                  ;		       program, a check sum is performed on the transient
   853                                  ;		       portion to see if it must be reloaded.  Thus programs
   854                                  ;		       which do not need maximum memory will save the time
   855                                  ;		       required to reload COMMAND when they terminate.
   856                                  ;
   857                                  ; ENTRY POINT:	       PROGSTART
   858                                  ;
   859                                  ; INPUT:	       command line at offset 81H
   860                                  ;
   861                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   862                                  ;		       from a secondary command processor via the EXIT
   863                                  ;		       internal command.
   864                                  ;
   865                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   866                                  ;		       hang the system.
   867                                  ;
   868                                  ; INTERNAL REFERENCES:
   869                                  ;
   870                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   871                                  ;		       (COMMAND.DOC)
   872                                  ;
   873                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ; EXTERNAL REFERENCES:
   877                                  ;
   878                                  ;      ROUTINES:       none
   879                                  ;
   880                                  ;      DATA AREAS:     none
   881                                  ;
   882                                  ;*****************************************************************************
   883                                  ;
   884                                  ;			      REVISION HISTORY
   885                                  ;			      ----------------
   886                                  ;
   887                                  ; DOS 1.00 to DOS 3.30
   888                                  ; --------------------------
   889                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   890                                  ;
   891                                  ; REV 1.17
   892                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   893                                  ;	       resident since the EXELOAD may have overwritten the transient.
   894                                  ;
   895                                  ; REV 1.18
   896                                  ;    05/21/82  IBM version always looks on drive A
   897                                  ;	       MSVER always looks on default drive
   898                                  ;
   899                                  ; REV 1.19
   900                                  ;    06/03/82  Drive spec now entered in command line
   901                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   902                                  ;	       (print volume label)
   903                                  ;
   904                                  ; REV 1.20
   905                                  ;    06/09/82  Prints "directory" after directories
   906                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   907                                  ;
   908                                  ; REV 1.50
   909                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   910                                  ;	       do it right.
   911                                  ;
   912                                  ; REV 1.70
   913                                  ;	       EXEC used to fork off new processes
   914                                  ;
   915                                  ; REV 1.80
   916                                  ;	       C switch for single command execution
   917                                  ;
   918                                  ; REV 1.90
   919                                  ;	       Batch uses XENIX
   920                                  ;
   921                                  ; Rev 2.00
   922                                  ;	       Lots of neato stuff
   923                                  ;	       IBM 2.00 level
   924                                  ;
   925                                  ; Rev 2.01
   926                                  ;	       'D' switch for date time suppression
   927                                  ;
   928                                  ; Rev 2.02
   929                                  ;	       Default userpath is NUL rather than BIN
   930                                  ;		       same as IBM
   931                                  ;	       COMMAND split into pieces
   932                                  ;
   933                                  ; Rev 2.10
   934                                  ;	       INTERNATIONAL SUPPORT
   935                                  ;
   936                                  ; Rev 2.50
   937                                  ;	       all the 2.x new stuff -MU
   938                                  ;
   939                                  ; Rev 3.30     (Ellen G)
   940                                  ;	       CALL internal command (TBATCH2.ASM)
   941                                  ;	       CHCP internal command (TCMD2B.ASM)
   942                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   943                                  ;	       @ sign suppression of batch file line
   944                                  ;	       Replaceable environment value support in batch files
   945                                  ;	       INT 2FH calls for APPEND
   946                                  ;	       Lots of PTR fixes!
   947                                  ;
   948                                  ; Beyond 3.30 to forever  (Ellen G)
   949                                  ; ----------------------
   950                                  ;
   951                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   952                                  ;			Use Message Retriever services
   953                                  ;			/MSG switch for resident extended error msg
   954                                  ;			Convert to new capitalization support
   955                                  ;			Better error recovery on CHCP command
   956                                  ;			Code page file tag support
   957                                  ;			TRUENAME internal command
   958                                  ;			Extended screen line support
   959                                  ;			/P switch on DEL/ERASE command
   960                                  ;			Improved file redirection error recovery
   961                                  ;	(removed)	Improved batch file performance
   962                                  ;			Unconditional DBCS support
   963                                  ;			Volume serial number support
   964                                  ;	(removed)	COMMENT=?? support
   965                                  ;
   966                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   967                                  ;
   968                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   969                                  ;			require delimiters.
   970                                  ;
   971                                  ; A003	PTM P5,P9,P111	Included in A000 development
   972                                  ;
   973                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   974                                  ;			executing
   975                                  ;
   976                                  ; A005	DCR D17 	If user specifies an extension on the command
   977                                  ;			line search for that extension only.
   978                                  ;
   979                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   980                                  ;			exists"
   981                                  ;
   982                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   983                                  ;
   984                                  ; A008	PTM P182	Change COPY to set default if invalid function
   985                                  ;			returned from code page call.
   986                                  ;
   987                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   988                                  ;
   989                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   990                                  ;			transient COMMAND.
   991                                  ;
   992                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   993                                  ;			before appending to a file.
   994                                  ;
   995                                  ; A012	PTM P189	Fix redirection error recovery.
   996                                  ;
   997                                  ; A013	PTM P330	Change date format
   998                                  ;
   999                                  ; A014	PTM P455	Fix echo parsing
  1000                                  ;
  1001                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1002                                  ;
  1003                                  ; A016	PTM P354	Fix extended error message addressing
  1004                                  ;
  1005                                  ; A017	PTM P448	Fix appending to 0 length files
  1006                                  ;
  1007                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1008                                  ;			the parser fails on. Fail on duplicate switches.
  1009                                  ;
  1010                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1011                                  ;			critical error
  1012                                  ;
  1013                                  ; A020	DCR D43 	Set append state off while in DIR
  1014                                  ;
  1015                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1016                                  ;
  1017                                  ; A022	DCR D209	Enhanced error recovery
  1018                                  ;
  1019                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1020                                  ;
  1021                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1022                                  ;
  1023                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1024                                  ;
  1025                                  ; A026	DCR D191	Change redirection error recovery support.
  1026                                  ;
  1027                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1028                                  ;			with a carriage return.
  1029                                  ;
  1030                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1031                                  ;			date and invalid time messages.
  1032                                  ;
  1033                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1034                                  ;			and TIME.
  1035                                  ;
  1036                                  ; A030	DCR D201	New extended attribute format.
  1037                                  ;
  1038                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1039                                  ;
  1040                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1041                                  ;
  1042                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1043                                  ;
  1044                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1045                                  ;
  1046                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1047                                  ;			do a read to determine eof.
  1048                                  ;
  1049                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1050                                  ;			so that ASSIGN works correctly.
  1051                                  ;
  1052                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1053                                  ;
  1054                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1055                                  ;
  1056                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1057                                  ;
  1058                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1059                                  ;			specified.
  1060                                  ;
  1061                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1062                                  ;			executes.
  1063                                  ;
  1064                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1065                                  ;			files causing loss of batch file.
  1066                                  ;
  1067                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1068                                  ;			CALL'ed batch files.
  1069                                  ;
  1070                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1071                                  ;			as an end of line character
  1072                                  ;
  1073                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1074                                  ;			and extended message pointers when we EXIT if
  1075                                  ;			COMMAND /P is the top level process.
  1076                                  ;
  1077                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1078                                  ;			"File not found - fn"
  1079                                  ;
  1080                                  ; A047	PTM P2819	Fix transient reload prompt message
  1081                                  ;
  1082                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1083                                  ;			when DBCS code was added.
  1084                                  ;
  1085                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1086                                  ;			on line.
  1087                                  ;
  1088                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1089                                  ;
  1090                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1091                                  ;
  1092                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1093                                  ;
  1094                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1095                                  ;
  1096                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1097                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1098                                  ;
  1099                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1100                                  ;			problems with breaking out of INT 24h
  1101                                  ;
  1102                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1103                                  ;
  1104                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1105                                  ;			before the "string".  EX: COMMAND /CDIR
  1106                                  ;
  1107                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1108                                  ;			DBCS switch.
  1109                                  ;
  1110                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1111                                  ;			the time.
  1112                                  ;
  1113                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1114                                  ;			messages to be disk based.  Only keep them if /MSG
  1115                                  ;			is used.
  1116                                  ;
  1117                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1118                                  ;			out of internal commands, due to substitution blocks
  1119                                  ;			not being reset.
  1120                                  ;
  1121                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1122                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1123                                  ;			secondary copy of environment.	Change default slash in
  1124                                  ;			default comspec string to backslash.
  1125                                  ;
  1126                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1127                                  ;			text for critical error messages.
  1128                                  ;
  1129                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1130                                  ;	5/20/88 	with Microsoft product already shipped.
  1131                                  ;
  1132                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1133                                  ;	 5/20/88	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1136                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1137                                  ;			header and space remaining.
  1138                                  ;
  1139                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1140                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1141                                  ;			environment was putting a "Z block" marker in the old
  1142                                  ;			environment.  The fix is to move to the old environment
  1143                                  ;			to the new environment before doing the SETBLOCK.
  1144                                  ;
  1145                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1146                                  ;        09/19/88       because the check for APPEND needed to be performed
  1147                                  ;                       before the DIR's findfirst.
  1148                                  ;
  1149                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1150                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1151                                  ;                       loading trans w/new comspec with no user change comspec.
  1152                                  ;
  1153                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1154                                  ;        11/05/88       Expansion of environment variables into batch line of
  1155                                  ;                       128 chars was not being counted and "%" which should be
  1156                                  ;                       ignored were being counted.
  1157                                  ;
  1158                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1159                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1160                                  ;                       ing included in checksum and was being overwritten by
  1161                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1162                                  ;                       Also removed fix A069 (because flag now protected).
  1163                                  ;
  1164                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1165                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1166                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1167                                  ;
  1168                                  ;***********************************************************************************
  1169                                  
  1170                                  ;
  1171                                  ;	Revision History
  1172                                  ;	================
  1173                                  ;
  1174                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1175                                  ;					at init time (date/time prompt)
  1176                                  ;
  1177                                  
  1178                                  ;
  1179                                  ;.xcref
  1180                                  ;.xlist
  1181                                  ;	include dossym.inc		; basic DOS symbol set
  1182                                  ;	include syscall.inc		; DOS function names
  1183                                  ;	include comsw.asm		; build version info
  1184                                  ;	include comequ.asm		; common command.com symbols
  1185                                  ;	include resmsg.equ		; resident message names
  1186                                  ;
  1187                                  ;	include comseg.asm		;segment ordering
  1188                                  ;.list
  1189                                  ;.cref
  1190                                  
  1191                                  ;CODERES segment public byte
  1192                                  ;CODERES ends
  1193                                  ;
  1194                                  ;DATARES 	segment public byte
  1195                                  ;		extrn	AccDen:byte
  1196                                  ;		extrn	Batch:word
  1197                                  ;		extrn	EchoFlag:byte
  1198                                  ;		extrn	ExeBad:byte
  1199                                  ;		extrn	ExecEMes:byte
  1200                                  ;		extrn	ExecErrSubst:byte
  1201                                  ;		extrn	ExtCom:byte
  1202                                  ;		extrn	ForFlag:byte
  1203                                  ;		extrn	IfFlag:byte
  1204                                  ;		extrn	InitFlag:BYTE
  1205                                  ;		extrn	Nest:word
  1206                                  ;		extrn	PipeFlag:byte
  1207                                  ;		extrn	RBadNam:byte
  1208                                  ;		extrn	RetCode:word
  1209                                  ;		extrn	SingleCom:word
  1210                                  ;		extrn	TooBig:byte
  1211                                  ;
  1212                                  ;		extrn	OldDS:word
  1213                                  ;
  1214                                  ;DATARES 	ends
  1215                                  ;
  1216                                  ;
  1217                                  ;INIT		segment public para
  1218                                  ;		extrn	ConProc:near
  1219                                  ;		extrn	Init_Contc_SpecialCase:near
  1220                                  ;INIT		ends
  1221                                  
  1222                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1223                                  ; --------------------------------------
  1224                                  ; 'command5.s' source code reference(s):
  1225                                  
  1226                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1227                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1228                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1229                                  ; ----------------------------------------------------------------------				 	 	
  1230                                  
  1231                                  ; ----------------------------------------------------------------------------
  1232                                  ; START OF RESIDENT PORTION
  1233                                  ; ----------------------------------------------------------------------------
  1234                                  ; SEGMENT - DATARES
  1235                                  ; ----------------------------------------------------------------------------
  1236                                  
  1237                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1238                                  
  1239                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1240                                  
  1241                                  ; ----------------------------------------------------------------------------
  1242                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1243                                  ; ----------------------------------------------------------------------------
  1244                                  
  1245                                  ;This file contains the low memory stub for command.com which hooks all the
  1246                                  ;entry points into the resident command.com and directs the calls to the
  1247                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1248                                  ;
  1249                                  ;The stub has been made part of the resident data and will always
  1250                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1251                                  ;that actually hook the interrupt vectors belong to either the first 
  1252                                  ;command.com or to any other command.com executed with the /p switch. 
  1253                                  ;
  1254                                  ;The stub also keeps track of the current active data segment. The 
  1255                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1256                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1257                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1258                                  ;the exit code picks up the previous data segment pointer from the current
  1259                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1260                                  ;
  1261                                  ;Right now the stub does not bother about A20 switching. We assume
  1262                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1263                                  ;value of the current data segment in one of the registers. A20 toggle 
  1264                                  ;support maybe added as a future enhancement, if the need is felt.
  1265                                  
  1266                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1267                                  
  1268                                  	[ORG 100H]
  1269                                  
  1270                                  	; 21/09/2018 - Retro DOS v3.0
  1271                                  StartCode:
  1272 00000000 E91D14                  	jmp	ConProc	; 10/01/2023 
  1273                                  
  1274                                  	; 09/01/2023
  1275                                  
  1276                                  ; Make following table word-aligned, and at the same time, provide a
  1277                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1278                                  
  1279                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1280 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1281                                  
  1282                                  ;All the entry points declared below are patched in at INIT time with the
  1283                                  ;proper segment and offset values after the resident code segment has been
  1284                                  ;moved to its final location
  1285                                  
  1286                                  ;!!!WARNING!!!
  1287                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1288                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1289                                  ;in the correct segments and offsets
  1290                                  
  1291                                  Int2f_Entry:
  1292 00000004 [3213]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1293 00000006 0000                    	dw	0
  1294                                  Int2e_Entry:
  1295 00000008 [850D]                  	dw	Int_2e			; Address of int 2eh handler
  1296 0000000A 0000                    	dw	0
  1297                                  Ctrlc_Entry:
  1298 0000000C [430C]                  	dw	ContC			; Address of Ctrl-C handler
  1299 0000000E 0000                    	dw	0
  1300                                  CritErr_Entry:
  1301 00000010 [4610]                  	dw	DSKERR			; Address of critical error handler
  1302 00000012 0000                    	dw	0
  1303                                  
  1304                                  Exec_Entry:
  1305 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1306                                  RemCheck_Entry:
  1307 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1308                                  TrnLodCom1_Entry:
  1309 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1310                                  LodCom_Entry:
  1311 00000020 00000000                	dd	0			; Entry after exit from command.com
  1312                                  MsgRetrv_Entry:
  1313 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1314                                  HeadFix_Entry:
  1315 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1316                                  UMBOff_Entry:
  1317 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1318                                  XMMCallAddr:
  1319 00000030 00000000                	dd	0			; Call address for XMM functions
  1320                                  ComInHMA:
  1321 00000034 00                      	db	0			; Flags if command.com in HMA
  1322                                  
  1323                                  Int2f_Trap:
  1324                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1325 00000035 E86400                  	call	CheckA20
  1326 00000038 1E                      	push	ds			; push current ds value
  1327 00000039 0E                      	push	cs			; push resident data segment value
  1328                                  	;jmp	cs:Int2f_Entry
  1329 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1330                                  
  1331                                  Int2e_Trap:
  1332 0000003F FB                      	sti
  1333 00000040 E85900                  	call	CheckA20
  1334 00000043 1E                      	push	ds			; push current ds value
  1335 00000044 0E                      	push	cs			; push resident data segment value
  1336                                  	;jmp	cs:Int2e_Entry
  1337 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1338                                  
  1339                                  Ctrlc_Trap:
  1340 0000004A FB                      	sti
  1341 0000004B E84E00                  	call	CheckA20
  1342 0000004E 1E                      	push	ds			; push current ds value
  1343 0000004F 0E                      	push	cs			; push resident data segment value
  1344                                  	;jmp	cs:Ctrlc_Entry
  1345 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1346                                  
  1347                                  CritErr_Trap:
  1348 00000055 FB                      	sti
  1349 00000056 E84300                  	call	CheckA20
  1350 00000059 1E                      	push	ds			; push current ds value
  1351 0000005A 0E                      	push	cs			; push resident data segment value
  1352                                  	;jmp	cs:CritErr_Entry
  1353 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1354                                  
  1355                                  Exec_Trap:
  1356 00000060 E83900                  	call	CheckA20
  1357 00000063 1E                      	push	ds			; push current ds value
  1358 00000064 0E                      	push	cs			; push resident data segment value
  1359                                  	;jmp	cs:Exec_Entry
  1360 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1361                                  
  1362                                  RemCheck_Trap:
  1363 0000006A E82F00                  	call	CheckA20
  1364 0000006D 1E                      	push	ds			; push current ds value
  1365 0000006E 0E                      	push	cs			; push resident data segment value
  1366                                  	;jmp	cs:RemCheck_Entry
  1367 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1368                                  
  1369                                  TrnLodCom1_Trap:
  1370 00000074 E82500                  	call	CheckA20
  1371 00000077 1E                      	push	ds			; push current ds value
  1372 00000078 0E                      	push	cs			; push resident data segment value
  1373                                  	;jmp	cs:TrnLodCom1_Entry
  1374 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1375                                  
  1376                                  LodCom_Trap:
  1377 0000007E E81B00                  	call	CheckA20
  1378 00000081 1E                      	push	ds			; push current ds value
  1379 00000082 0E                      	push	cs			; push resident data segment value
  1380                                  	;jmp	cs:LodCom_Entry
  1381 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1382                                  
  1383                                  MsgRetrv_Trap:
  1384 00000088 E81100                  	call	CheckA20
  1385 0000008B 1E                      	push	ds			; push current ds value
  1386 0000008C 0E                      	push	cs			; push resident data segment value
  1387                                  	;jmp	cs:MsgRetrv_Entry
  1388 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1389                                  
  1390                                  HeadFix_Trap:
  1391 00000092 E80700                  	call	CheckA20
  1392 00000095 1E                      	push	ds			; push current ds value
  1393 00000096 0E                      	push	cs			; push resident data segment value
  1394                                  	;jmp	cs:HeadFix_Entry
  1395 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1396                                  
  1397                                  ; ----------------------------------------------------------------------------
  1398                                  
  1399                                  	; 09/01/2023
  1400                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1401                                  
  1402                                  CheckA20:
  1403 0000009C 9C                      	pushf				; save current flags
  1404 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1405 000000A3 7408                    	jz	short A20_on		; no, jump to resident
  1406                                  
  1407 000000A5 E80C00                  	call	QueryA20
  1408 000000A8 7303                    	jnc	short A20_on		; A20 is on, jump to resident
  1409                                  
  1410 000000AA E81800                  	call	EnableA20		; turn A20 on
  1411                                  A20_on:
  1412 000000AD 9D                      	popf				; flags have to be unchanged
  1413 000000AE C3                      	retn
  1414                                  
  1415                                  ; ----------------------------------------------------------------------------
  1416                                  
  1417                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1418                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1419                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1420                                  ; M005; pointers because our cs is going to be different. The segment to
  1421                                  ; M005; jump to is patched in at init time. (in init.asm)
  1422                                  
  1423                                  Carousel_i2f_Hook:			; M005
  1424 000000AF EA                      	db	0EAh			; far jump opcode; M005
  1425 000000B0 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1426 000000B2 0000                    	dw	0			; int 2fh segment; M005
  1427                                  
  1428                                  ; ----------------------------------------------------------------------------
  1429                                  
  1430                                  XMM_QUERY_A20 equ 7 ; 09/01/2023
  1431                                  
  1432                                  QueryA20:
  1433 000000B4 53                      	push	bx
  1434 000000B5 50                      	push	ax
  1435                                  	;mov	ah,7
  1436 000000B6 B407                    	mov	ah,XMM_QUERY_A20
  1437                                  	;call	cs:XMMCallAddr
  1438 000000B8 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1439 000000BD 09C0                    	or	ax,ax
  1440 000000BF 58                      	pop	ax
  1441 000000C0 5B                      	pop	bx
  1442                                  	; 16/04/2023
  1443 000000C1 7501                    	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1444                                  
  1445 000000C3 F9                      	stc					; OFF
  1446                                  	;retn
  1447                                  QA20_ON:
  1448                                  	;clc					; ON
  1449 000000C4 C3                      	retn
  1450                                  
  1451                                  ; ----------------------------------------------------------------------------
  1452                                  
  1453                                  XMM_LOCAL_ENABLE_A20 equ 5
  1454                                  
  1455                                  EnableA20:
  1456 000000C5 53                      	push	bx
  1457 000000C6 50                      	push	ax
  1458                                  	;mov	ah,5
  1459 000000C7 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20
  1460                                  	;call	cs:XMMCallAddr
  1461 000000C9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1462 000000CE 09C0                    	or	ax,ax
  1463 000000D0 7403                    	jz	short XMMerror			; AX = 0 fatal error
  1464 000000D2 58                      	pop	ax
  1465 000000D3 5B                      	pop	bx
  1466 000000D4 C3                      	retn
  1467                                  
  1468                                  ;If we get an error, we just loop forever
  1469                                  
  1470                                  XMMerror:
  1471 000000D5 EBFE                    	jmp	short XMMerror
  1472                                  
  1473                                  ; -----------------------------------------------------------------------------
  1474                                  
  1475                                  HV_Extern   equ	1
  1476                                  HV_LoadHigh equ	1
  1477                                  HV_Stub	    equ	1
  1478                                  
  1479                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1480                                  
  1481                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1482                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1483                                  ;returns with all registers preserved and so all our segment registers are
  1484                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1485                                  ;comes back here. In this case the segment registers and the stack are
  1486                                  ;not set up and random things can happen. The only way to setup all the 
  1487                                  ;registers is to use the cs value and this can only be done when we are in
  1488                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1489                                  ;the code segment to the data segment.
  1490                                  
  1491                                  Issue_Exec_Call:
  1492 000000D7 CD21                    	int 	21h
  1493                                  
  1494                                  ;We disable interrupts while changing the stack because there is a bug in 
  1495                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1496                                  ;are being changed.
  1497                                  
  1498 000000D9 FA                      	cli
  1499 000000DA 0E                      	push	cs
  1500 000000DB 17                      	pop	ss
  1501                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1502                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1503 000000DC BC[3804]                	mov	sp,RStack		; stack is set up
  1504                                  	
  1505                                  	; 20/04/2023
  1506                                  	;sti
  1507                                  	;push	cs
  1508                                  	;pop	ds			; ds = DATARES
  1509                                  
  1510                                  ; M009; Restore UMB state to that before Exec
  1511                                  
  1512                                  	;pushf				;    This call frees HIDDEN umb's,
  1513                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1514                                  	;popf				;    strategy and link state, as app.
  1515                                  
  1516                                  	; 09/01/2023 - Retro DOS v4.0
  1517                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1518                                  	; ----------------------
  1519 000000DF FB                      	sti
  1520                                  	
  1521 000000E0 0E                      	push    cs
  1522 000000E1 1F                      	pop     ds
  1523 000000E2 9C                      	pushf
  1524                                  	;mov	al,[cs:fInHigh]
  1525                                  	; 18/04/2023
  1526 000000E3 A0[3A04]                	mov	al,[fInHigh]
  1527 000000E6 A880                    	test	al,80h
  1528 000000E8 7406                    	jz      short uhu10
  1529 000000EA 247F                    	and     al,7Fh
  1530                                  	;;call	cs:UMBOff_Entry
  1531                                  	;call	far [cs:UMBOff_Entry]
  1532 000000EC FF1E[2C00]              	call	far [UMBOff_Entry]
  1533                                  uhu10:
  1534                                  	;and	byte [cs:fInHigh],7Fh
  1535                                  	; 18/04/2023
  1536 000000F0 8026[3A04]7F            	and	byte [fInHigh],7Fh
  1537 000000F5 9D                      	popf
  1538                                  	; ----------------------
  1539                                  
  1540                                  ;We now jump to the stub trap which returns us to the resident code. All
  1541                                  ;flags are preserved by the stub code.
  1542                                  
  1543 000000F6 E967FF                  	jmp	Exec_Trap
  1544                                  
  1545                                  ; ----------------------------------------------------------------------------
  1546                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1547                                  ; ----------------------------------------------------------------------------
  1548                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1549                                  
  1550                                  ;***	Message substitution blocks
  1551                                  
  1552                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1553                                  
  1554                                  ;BlkDevErrSubst	label	byte
  1555                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1556                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1557                                  
  1558 000000F9 02                      BlkDevErrSubst: db	2
  1559 000000FA 0000                    BlkDevErrRw:	dw	0
  1560 000000FC 01                      		db	1
  1561 000000FD [FF00]                  		dw	DrvLet
  1562                                  
  1563 000000FF 41                      DrvLet:		db	'A'			; drive letter
  1564                                  
  1565                                  
  1566                                  ;CharDevErrSubst label	byte
  1567                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1568                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1569                                  
  1570 00000100 02                      CharDevErrSubst: db	2
  1571 00000101 0000                    CharDevErrRw:	dw	0
  1572 00000103 02                      		db	2
  1573 00000104 [0601]                  		dw	DevName
  1574                                  
  1575 00000106 00<rep 8h>              DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1576 0000010E 00                      		db	0
  1577                                  
  1578                                  ;NeedVolSubst	label	byte
  1579                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1580                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1581                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1582                                  
  1583 0000010F 02                      NeedVolSubst:	db	2
  1584 00000110 [1801]                  		dw	VolName
  1585 00000112 03                      		db	3
  1586 00000113 [2601]                  		dw	VolSer+2
  1587 00000115 03                      		db	3
  1588 00000116 [2401]                  		dw	VolSer
  1589                                  
  1590                                  	; NOTE:	VolName and VolSer must be adjacent
  1591 00000118 00<rep Bh>              VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1592 00000123 00                      		db	0
  1593 00000124 00000000                VolSer:		dd	0			; volume serial #
  1594                                  
  1595 00000128 00                      CDevAt:		db	0
  1596                                  
  1597                                  ;BadFatSubst	label	byte
  1598                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1599                                  
  1600 00000129 01                      BadFatSubst:	db	1
  1601 0000012A [FF00]                  		dw	DrvLet
  1602                                  
  1603                                  ;PutBackSubst	label	byte
  1604                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1605                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1606                                  
  1607 0000012C 02                      PutBackSubst:	db	2
  1608 0000012D 0000                    PutBackComSpec:	dw	0
  1609 0000012F 01                      		db	1
  1610 00000130 [3201]                  		dw	PutBackDrv
  1611                                  
  1612 00000132 20                      PutBackDrv:	db	' '			; drive letter
  1613                                  
  1614                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1615                                  
  1616 00000133 02                      ExecErrSubst:	db	2
  1617 00000134 [6303]                  		dw	SafePathBuffer
  1618                                  
  1619 00000136 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1620 0000013A 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1621                                  
  1622 0000013B 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1623 0000013F 0000                    Save_Pdb:	dw	0
  1624 00000141 0000                    Parent:		dw	0
  1625 00000143 00000000                OldTerm:	dd	0
  1626 00000147 0000                    ErrCd_24:	dw	0
  1627 00000149 0000                    Handle01:	dw	0
  1628 0000014B 00                      Loading:	db	0
  1629 0000014C 0000                    Batch:		dw	0	; assume no batch mode initially
  1630                                  
  1631                                  ;;;;SR;
  1632                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1633                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1634                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1635                                  ;;;;
  1636                                  ;;;BatchEOF:	db	0
  1637                                  
  1638                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1639                                  	; What's this comspec_end about?
  1640 0000014E 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1641 0000018E 0000                    ComSpec_End:	dw	0
  1642                                  
  1643                                  ;Trans		label	dword
  1644                                  ;		dw	TRANGROUP:Command
  1645                                  
  1646                                  Trans:		;dw	12Ch
  1647                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1648 00000190 [2C01]                  		dw	COMMAND ; 16/04/2023
  1649 00000192 0000                    TrnSeg:		dw	0
  1650                                  
  1651 00000194 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1652                                  
  1653 00000195 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1654 00000196 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1655                                  
  1656 00000197 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1657 00000198 0000                    MemSiz:		dw	0
  1658 0000019A 0000                    Sum:		dw	0
  1659 0000019C 01                      ExtCom:		db	1	; for init, pretend just did an external
  1660 0000019D 0000                    RetCode: 	dw	0
  1661 0000019F 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1662                                  
  1663                                  
  1664                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1665                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1666                                  
  1667 000001A0 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1668 000001A1 01                      Suppress:	db	1	; used for echo, 1=echo line
  1669 000001A2 0000                    Io_Save: 	dw	0
  1670 000001A4 00                      RestDir: 	db	0
  1671 000001A5 00                      PermCom: 	db	0	; true => permanent command
  1672                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1673                                  				; true => semi-permanent command (/K)
  1674 000001A6 0000                    SingleCom:	dw	0	; true => single command version
  1675 000001A8 FFFF                    VerVal:		dw	-1
  1676 000001AA 00                      fFail:		db	0	; true => fail all int 24s
  1677 000001AB 00                      IfFlag:		db	0	; true => IF statement in progress
  1678                                  
  1679 000001AC 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1680 000001AD 0000                    ForPtr:		dw	0
  1681                                  
  1682 000001AF 0000                    Nest:		dw	0	; nested batch file counter
  1683 000001B1 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1684 000001B2 00                      Call_Batch_Flag: db	0
  1685 000001B3 0000                    Next_Batch:	dw	0	; address of next batch segment
  1686 000001B5 00                      NullFlag:	db	0	; flag if no command on command line
  1687 000001B6 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1688                                  				; buffer for file ucase address
  1689                                  ; Bugbug: don't need crit_msg_ anymore?
  1690                                  
  1691 000001BB 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1692 000001BD 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1693 000001BF 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1694 000001C1 0000                    		 dw	0	; DBCS vector segment
  1695 000001C3 0000                    Append_State:	dw	0	; current state of append
  1696                                  				;  (if Append_Flag is set)
  1697 000001C5 00                      Append_Flag:	db	0	; set if append state is valid
  1698 000001C6 00                      Re_Out_App:	db	0
  1699 000001C7 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1700                                  
  1701                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1702                                  ; various times. Here is the breakdown:
  1703                                  ;
  1704                                  ;   INITINIT	We are in the init code.
  1705                                  ;   INITSPECIAL We are in the date/time prompt
  1706                                  ;   INITCTRLC	We are handling a ^C already.
  1707                                  ;
  1708                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1709                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1710                                  ;
  1711                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1712                                  ; input buffer with a CR to pretend an empty response.
  1713                                  ;
  1714                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1715                                  ; (ourselves). We can then detect the carry set and properly retry the
  1716                                  ; operation.
  1717                                  
  1718                                  InitFlag:	;db	1
  1719 00000217 01                      		db	INITINIT
  1720                                  
  1721                                  ; Note: these two bytes are referenced as a word
  1722 00000218 00                      PipeFlag:	db	0
  1723 00000219 00                      PipeFiles:	db	0
  1724                                  
  1725                                  ; (rdata.asm, msdos 6.0, 1992)
  1726                                  ; ----------------------------------------------------------------------------
  1727                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1728                                  
  1729                                  
  1730                                  ;;SR
  1731                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1732                                  ;;
  1733                                  ;
  1734                                  ;; Bugbug: can we find any way around maintaining these
  1735                                  ;; large buffers?
  1736                                  ;
  1737                                  ;Pipe1		db	67+12 dup (?)
  1738                                  ;Pipe2		db	67+12 dup (?)
  1739                                  ;
  1740                                  ;PipePtr 	dw	?
  1741                                  ;
  1742                                  ;PipeStr 	db	129 dup (?)
  1743                                  ;
  1744                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1745                                  ;
  1746                                  ;;SR;
  1747                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1748                                  ;;automatically be discarded after init.
  1749                                  ;;
  1750                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1751                                  ;; M004; the origin.
  1752                                  ;;
  1753                                  ;	ORG	Pipe1	; M004
  1754                                  ;
  1755                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1756                                  ;; what it expects, what it does.
  1757                                  ;
  1758                                  
  1759                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1760                                  
  1761                                  Pipe1	equ	EndInit
  1762                                  Pipe2	equ	Pipe1+67+12
  1763                                  PipePtr	equ	Pipe2+67+12
  1764                                  PipeStr	equ	PipePtr+2
  1765                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1766                                  
  1767                                  ; Bugbug: really need a procedure header for EndInit, describing
  1768                                  ; what it expects, what it does.
  1769                                  
  1770                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1771                                  
  1772                                  EndInit:
  1773 0000021A 1E                      	push	ds
  1774 0000021B 06                      	push	es		; save segments
  1775 0000021C 0E                      	push	cs
  1776 0000021D 1F                      	pop	ds		
  1777                                  	;assume	ds:RESGROUP
  1778                                  
  1779                                  ; M004; Save size of transient here before INIT segment is deallocated
  1780                                  
  1781 0000021E 8B16[AD1C]              	mov	dx,[TrnSize]		; M004
  1782                                  ;M027
  1783                                  ; These variables are also defined in the INIT segment and need to be saved
  1784                                  ;before we resize
  1785                                  ;
  1786 00000222 A1[A11C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1787 00000225 8B1E[9D1C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1788 00000229 8B0E[A31C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1789 0000022D 50                      	push	ax		; Save all these values ;M027
  1790 0000022E 53                      	push	bx		; M027
  1791 0000022F 51                      	push	cx		; M027
  1792                                  
  1793                                  
  1794                                  ; Bugbug: push ds, pop es here.
  1795                                  	;mov	bx,ds
  1796                                  	;mov	es,bx		; es = RESGROUP
  1797                                  	; 09/01/2023
  1798 00000230 1E                      	push	ds
  1799 00000231 07                      	pop	es
  1800                                  
  1801                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1802                                  ; code + data for low COMMAND
  1803                                  
  1804 00000232 8B1E[B903]              	mov	bx,[ResSize]	; Total size of resident
  1805 00000236 B44A                    	mov	ah,4Ah
  1806                                  	;mov	ah,SETBLOCK
  1807 00000238 CD21                    	int	21h		; Set block to resident size
  1808                                  
  1809                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1810                                  		; ES = segment address of block to change
  1811                                  		; BX = new size in paragraphs
  1812                                  
  1813                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1814                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1815                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1816                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1817                                  ;
  1818                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1819                                  	
  1820 0000023A 803E[A501]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1821 0000023F 7530                    	jne	short adjust_env ; no, do not free batchseg
  1822                                  
  1823 00000241 833E[4C01]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1824 00000246 7429                    	je	short adjust_env ; no, dont juggle
  1825                                  
  1826                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ; batchseg size
  1827                                  	; 21/01/2023
  1828 00000248 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1829                                  	;mov	bx,4	; 09/01/2023
  1830                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1831 0000024B B448                    	mov	ah,48h
  1832                                  	;mov	ah,ALLOC
  1833 0000024D CD21                    	int	21h
  1834                                  
  1835                                  		; DOS - 2+ - ALLOCATE MEMORY
  1836                                  		; BX = number of 16-byte paragraphs desired
  1837                                  
  1838                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1839                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1840                                  ; could be making it worse! We're second-guessing where memory
  1841                                  ; allocations go, which might not be such a great idea. Is there
  1842                                  ; a strategy, short of doing something even worse like diddling
  1843                                  ; arena headers, where we can minimize the possibility of fragmentation
  1844                                  ; under all cases? Hmm..
  1845                                  	
  1846 0000024F 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1847                                  
  1848 00000251 8EC0                    	mov	es,ax		 ; es = New batch segment
  1849 00000253 31FF                    	xor	di,di
  1850 00000255 31F6                    	xor	si,si
  1851                                  
  1852 00000257 1E                      	push	ds
  1853 00000258 8E1E[4C01]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1854                                  	;assume	ds:nothing
  1855                                  	;mov	cx,SIZE BatchSegment
  1856                                  	; 23/01/2023
  1857                                  	;mov	cx,BATCHSEGMENT.SIZE
  1858                                  	;;mov	cx,33	; 09/01/2023
  1859                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1860                                  	;
  1861                                  	;add	cx,16		 ; for the filename
  1862                                  	; 20/04/2023
  1863 0000025C B93100                  	mov	cx,BATCHSEGMENT.SIZE+16 
  1864                                  
  1865                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1866                                  	; It's sure be bad if we copied more bytes than the batch segment
  1867                                  	; holds!
  1868                                  	
  1869 0000025F FC                      	cld
  1870 00000260 F3A4                    	rep	movsb
  1871 00000262 1F                      	pop	ds
  1872                                  	;assume	ds:RESGROUP
  1873                                  
  1874 00000263 8CC1                    	mov	cx,es		; save new batch segment 
  1875 00000265 8E06[4C01]              	mov	es,[Batch]
  1876 00000269 B449                    	mov	ah,49h
  1877                                  	;mov	ah,DEALLOC
  1878 0000026B CD21                    	int	21h		; free the old batch segment
  1879                                  
  1880                                  	; Bugbug: should we check for error?
  1881                                  
  1882 0000026D 890E[4C01]              	mov	[Batch],cx	; store new batch segment address
  1883                                  
  1884                                  adjust_env:
  1885 00000271 59                      	pop	cx		; cx = size of old env ;M027
  1886 00000272 5B                      	pop	bx		; bx = size of new env needed ;M027
  1887 00000273 5D                      	pop	bp		; bp = old env seg ;M027
  1888                                  
  1889                                  ;Allocate the correct size for the environment
  1890                                  
  1891 00000274 B448                    	mov	ah,48h
  1892                                  	;mov	ah,ALLOC
  1893 00000276 CD21                    	int	21h		; get memory
  1894 00000278 7264                    	jc	short nomem_err	; out of memory,signal error
  1895                                  	
  1896                                  	; Bugbug: why not continue, leaving environment where it is?
  1897                                  
  1898 0000027A A3[3F03]                	mov	[EnvirSeg],ax	; Store new environment segment
  1899                                  	;;mov	[ds:2Ch],ax
  1900                                  	;mov	[2Ch],ax
  1901                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1902 0000027D A32C00                  	mov	[PDB.ENVIRON],ax
  1903 00000280 8EC0                    	mov	es,ax		; es = address of allocated memory
  1904                                  	;assume	es:nothing
  1905                                  
  1906                                  ;Copy the environment to the newly allocated segment
  1907                                  
  1908 00000282 1E                      	push	ds
  1909 00000283 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1910                                  	;assume	ds:nothing
  1911                                  
  1912 00000285 31F6                    	xor	si,si
  1913 00000287 89F7                    	mov	di,si		; Start transfer from 0
  1914                                  
  1915 00000289 FC                      	cld
  1916 0000028A F3A4                    	rep	movsb		; Do the copy
  1917                                  
  1918 0000028C 1F                      	pop	ds		; ds = RESGROUP
  1919                                  	;assume	ds:RESGROUP
  1920                                  
  1921                                  ; We have to free the old environment block if it was allocated by INIT
  1922                                  
  1923                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1924                                  ; or does it also apply to passed environments?
  1925                                  
  1926                                  ;M036
  1927                                  ; Free up old env segment always because this is a copy passed by Exec and
  1928                                  ; takes up memory that is never used
  1929                                  
  1930                                  ;M044
  1931                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1932                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1933                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1934                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1935                                  ; in
  1936                                  
  1937                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1938                                          ;je	short no_free	    ; no, do not free it
  1939                                  	; 21/01/2023
  1940                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1941 0000028D 803E[811C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment	
  1942 00000292 7506                    	jne	short no_free 
  1943                                  
  1944 00000294 8EC5                    	mov	es,bp
  1945 00000296 B449                    	mov	ah,49h
  1946                                  	;mov	ah,DEALLOC	
  1947 00000298 CD21                    	int	21h		    ; Free it
  1948                                  no_free:
  1949                                  
  1950                                  ; M004; Start of changes 
  1951                                  
  1952                                  ; Move the transient now. We will allocate the biggest block available
  1953                                  ; now and move the transient to the top of the block. We will then
  1954                                  ; deallocate this block. When the resident starts executing, it will
  1955                                  ; hopefully allocate this block again and find the transient intact.
  1956                                  
  1957 0000029A C606[9401]01            	mov	byte [TrnMvFlg],1   ; Indicate that transient has been moved
  1958 0000029F 06                      	push	es
  1959                                  	;;mov	si,offset ResGroup:TranStart
  1960                                  	; 09/01/2023
  1961                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  1962 000002A0 BE3022                  	mov	si,TRANSTART	    ; (End of the resident portion)
  1963                                  	;mov	di,0
  1964 000002A3 31FF                    	xor	di,di ; 0
  1965                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  1966                                  	;mov	cx,98C5h
  1967 000002A5 B90F96                  	mov	cx,TRANSPACEEND
  1968                                  	
  1969                                  ; Find the largest block available
  1970                                  
  1971 000002A8 BBFFFF                  	mov	bx,0FFFFh
  1972 000002AB B448                    	mov	ah,48h
  1973                                  	;mov	ah,ALLOC
  1974 000002AD CD21                    	int	21h
  1975                                  
  1976                                  ; dx = size of transient saved previously 
  1977                                  
  1978 000002AF 39D3                    	cmp	bx,dx		; enough memory?
  1979 000002B1 722B                    	jb	short nomem_err	; not enough memory for transient
  1980                                  
  1981 000002B3 B448                    	mov	ah,48h
  1982                                  	;mov	ah,ALLOC
  1983 000002B5 CD21                    	int	21h		; get the largest block
  1984 000002B7 7225                    	jc	short nomem_err	; something is really screwed up
  1985                                  
  1986 000002B9 50                      	push	ax		; save memory address
  1987 000002BA 01D8                    	add	ax,bx		; ax = top of my memory block
  1988 000002BC 29D0                    	sub	ax,dx		; less size of transient
  1989 000002BE A3[9201]                	mov	[TrnSeg],ax	; save transient segment
  1990 000002C1 8EC0                    	mov	es,ax		;
  1991 000002C3 58                      	pop	ax		; restore our seg addr
  1992                                  
  1993                                  ; Everything is set for a move. We need to move in the reverse direction to
  1994                                  ; make sure we dont overwrite ourselves while copying
  1995                                  
  1996 000002C4 01CE                    	add	si,cx
  1997 000002C6 4E                      	dec	si
  1998 000002C7 01CF                    	add	di,cx
  1999 000002C9 4F                      	dec	di
  2000 000002CA FD                      	std
  2001 000002CB F3A4                    	rep	movsb
  2002 000002CD FC                      	cld
  2003                                  
  2004                                  ; Now we have to free up this block so that resident can get hold of it
  2005                                  
  2006 000002CE 8EC0                    	mov	es,ax
  2007 000002D0 B449                    	mov	ah,49h
  2008                                  	;mov	ah,DEALLOC
  2009 000002D2 CD21                    	int	21h		; release the memory block
  2010                                  
  2011                                  ; M004; End of changes
  2012                                  
  2013                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2014                                  	; 09/01/2023
  2015 000002D4 C606[1702]00            	mov	byte [InitFlag],0	
  2016                                  
  2017 000002D9 07                      	pop	es
  2018 000002DA 1F                      	pop	ds
  2019                                  	;assume	ds:nothing
  2020                                  	
  2021                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2022                                  	
  2023 000002DB E9A0FD                  	jmp	LodCom_Trap	; allocate transient
  2024                                  
  2025                                  nomem_err:
  2026                                  
  2027                                  ;We call the error routine which will never return. It will either exit
  2028                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2029                                  ;message ( if first COMMAND )
  2030                                  
  2031 000002DE E90C19                  	jmp	Alloc_error
  2032                                  
  2033                                  ;EndCodeInit:	; label	byte		; M004
  2034                                  
  2035                                  	; 16/04/2023
  2036                                  	EndCodeInit equ $
  2037                                  
  2038                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2039                                  ;; M004; If not, we signal an assembly error
  2040                                  ;
  2041                                  ;IF2
  2042                                  ;	IF ($ GT EndPipe)
  2043                                  ;		.err
  2044                                  ;		%out	"ENDINIT CODE TOO BIG"
  2045                                  ;	ENDIF
  2046                                  ;ENDIF
  2047                                  
  2048                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2049                                  ;;
  2050                                  ;		ORG	EndPipe		; M004
  2051                                  
  2052                                  ; 09/01/2023
  2053                                  
  2054                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2055                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2056                                  
  2057                                  ; 16/04/2023
  2058                                  	FillBytes equ EndPipe - EndCodeInit			
  2059                                  
  2060                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2061                                  ; 16/04/2023
  2062                                  %if FillBytes>0
  2063                                  	;times EndPipe - EndCodeInit db 0
  2064 000002E1 00<rep 5Ah>             	times FillBytes db 0   
  2065                                  %endif
  2066                                  
  2067                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2068                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289 
  2069                                  
  2070                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h 
  2071                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2072                                  
  2073 0000033B [1A02]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2074 0000033D [6902]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2075                                  
  2076                                  Exec_Block:	; label	byte	; the data block for exec calls
  2077 0000033F 0000                    EnvirSeg:	dw	0
  2078                                  Com_Ptr:	; label	dword
  2079 00000341 8000                    		dw	80h	; point at unformatted parameters
  2080 00000343 0000                    		dw	0
  2081                                  Com_Fcb1:	; label	dword
  2082 00000345 5C00                    		dw	5Ch
  2083 00000347 0000                    		dw	0
  2084                                  Com_Fcb2:	; label	dword
  2085 00000349 6C00                    		dw	6Ch
  2086 0000034B 0000                    		dw	0
  2087                                  
  2088                                  ; variables passed to transient
  2089                                  TranVars:	; label	byte			
  2090                                  		;dw	offset DATARES:HeadFix_Trap
  2091 0000034D [9200]                  		dw	HeadFix_Trap
  2092 0000034F 0000                    MySeg:		dw	0	; put our own segment here
  2093 00000351 0000                    LTpa:		dw	0	; will store tpa segment here
  2094 00000353 2F                      RSwitChar:	db	"/"
  2095 00000354 5C                      RDirChar:	db	"\"
  2096                                  		;dw	offset DATARES:Issue_Exec_Call
  2097 00000355 [D700]                  		dw	Issue_Exec_Call
  2098 00000357 0000                    MySeg1:		dw	0
  2099                                  		;dw	offset DATARES:RemCheck_Trap
  2100 00000359 [6A00]                  		dw	RemCheck_Trap
  2101 0000035B 0000                    MySeg2:		dw	0
  2102 0000035D 0000                    ResTest: 	dw	0
  2103 0000035F 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2104                                  TranVarEnd:	; label	byte
  2105                                  
  2106 00000361 0000                    OldErrNo:	dw	0
  2107                                  
  2108                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2109                                  ;  MsgBuffer is only used while a command is being executed.
  2110                                  ;  SafePathBuffer is no longer needed, since it is used for
  2111                                  ;  unsuccessful program launches.
  2112                                  
  2113                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2114                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2115                                  	;Bugbug: Why so big a buffer?
  2116                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2117 00000363 00<rep 50h>             		times	64+3+13 db 0		
  2118                                  
  2119                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2120                                  
  2121 000003B3 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2122 000003B7 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2123                                  
  2124                                  ;SR;
  2125                                  ; The three vars below have been added for a pure COMMAND.COM
  2126                                  
  2127 000003B9 0000                    ResSize:	dw	0
  2128                                  
  2129                                  ;SR;
  2130                                  ; Moved the stack here from the code segment
  2131                                  ;
  2132                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2133                                  	
  2134                                  		;db	(80h - 3) dup (?)
  2135 000003BB 90                      align 2
  2136 000003BC 00<rep 7Ch>             		times	124 db 0		
  2137                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2138                                  RStack:		; label	word
  2139 00000438 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2140                                  				; resident code segments
  2141                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2142                                  
  2143                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2144                                  ; -------------------------------
  2145                                  
  2146                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2147                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2148                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2149                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2150                                  ;            given a command-line like "/L:3,500;4"
  2151                                  ; UmbUsed  - An array of characters, each of which is 1 iff the UMB
  2152                                  ;            matching its index number was specified on the command-line;
  2153                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2154                                  ;            will be set to 1.  All others will be set to 0.
  2155                                  ; UmbSize  - An array of words, each of which is interpereted as a size
  2156                                  ;            specified by the user for a UMB (in the above example, all
  2157                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2158                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2159                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2160                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2161                                  ;            for details).
  2162                                  
  2163                                  ; - MSDOS 6.0 COMMAND.COM -
  2164                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2165                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2166                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2167                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2168                                  ;; space problem (it's just such a nice round number, eh?).
  2169                                  
  2170                                  ;MAXUMB	equ	16
  2171                                  
  2172                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2173                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2174                                  
  2175 0000043A 00                      fInHigh:	db	0
  2176                                  
  2177                                  ; MSDOS 6.0 COMMAND.COM
  2178                                  ;fUmbTiny:	db	0
  2179                                  ;SegLoad:	dw	0
  2180                                  ;UmbLoad:	db	0
  2181                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2182                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2183                                  ;fm_umb:	db	0
  2184                                  ;fm_strat:	db	0
  2185                                  ;fm_argc:	db	0
  2186                                  
  2187                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2188                                  ; UmbLoad is set to the UMB number given.
  2189                                  
  2190                                  ;*** MESSAGES
  2191                                  ;    and other translatable text
  2192                                  
  2193                                  ; include comrmsg.inc	; M00
  2194                                  ; ------------------------------
  2195                                  
  2196                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2197                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2198                                  
  2199 0000043B 41                      ABORT_CHAR:	db 'A'
  2200 0000043C 52                      RETRY_CHAR:	db 'R'
  2201 0000043D 49                      IGNORE_CHAR:	db 'I'
  2202 0000043E 46                      FAIL_CHAR:	db 'F'
  2203 0000043F 59                      YES_CHAR:	db 'Y'
  2204 00000440 4E                      NO_CHAR:	db 'N'
  2205 00000441 05                      REQ_ABORT:	db 5
  2206 00000442 41626F7274              		db 'Abort'
  2207 00000447 07                      REQ_RETRY:	db 7
  2208 00000448 2C205265747279          		db ', Retry'
  2209 0000044F 08                      REQ_IGNORE:	db 8
  2210 00000450 2C2049676E6F7265        		db ', Ignore'
  2211 00000458 06                      REQ_FAIL:	db 6
  2212 00000459 2C204661696C            		db ', Fail'
  2213 0000045F 01                      REQ_END:	db 1
  2214 00000460 3F                      		db '?'
  2215 00000461 08                      MREAD:		db 8
  2216 00000462 72656164696E6700        		db 'reading', 0
  2217 0000046A 08                      MWRITE:		db 8
  2218 0000046B 77726974696E6700        		db 'writing', 0
  2219 00000473 0E                      MDRIVE:		db 14
  2220 00000474 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2220 0000047D 2025320D0A         
  2221 00000482 0F                      MDEVICE:	db 15
  2222 00000483 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2222 0000048C 652025320D0A       
  2223 00000492 26                      MVOLSERIAL:	db 38
  2224 00000493 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2224 0000049C 7365727420766F6C75-
  2224 000004A5 6D6520253120736572-
  2224 000004AE 69616C2025322D2533-
  2224 000004B7 0D0A               
  2225 000004B9 25                      BADFATMSG:	db 37
  2226 000004BA 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2226 000004C3 636174696F6E207461-
  2226 000004CC 626C65206261642C20-
  2226 000004D5 64726976652025310D-
  2226 000004DE 0A                 
  2227 000004DF 15                      COMBAD:		db 21
  2228 000004E0 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2228 000004E9 4F4D4D414E442E434F-
  2228 000004F2 4D0D0A             
  2229 000004F5 21                      PUTBACKMSG:	db 33
  2230 000004F6 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2230 000004FF 736B20776974682025-
  2230 00000508 3120696E2064726976-
  2230 00000511 652025320D0A       
  2231 00000517 21                      PROMPT:		db 33
  2232 00000518 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2232 00000521 206B657920746F2063-
  2232 0000052A 6F6E74696E7565202E-
  2232 00000533 202E202E0D0A       
  2233 00000539 1C                      ENDBATMES:	db 28
  2234 0000053A 0D0A                    		db 0Dh,0Ah
  2235 0000053C 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2235 00000545 206261746368206A6F-
  2235 0000054E 622028592F4E293F   
  2236 00000556 13                      EXECEMES:	db 19
  2237 00000557 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2237 00000560 65637574652025310D-
  2237 00000569 0A                 
  2238 0000056A 13                      EXEBAD:		db 19
  2239 0000056B 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2239 00000574 4558452066696C650D-
  2239 0000057D 0A                 
  2240 0000057E 22                      TOOBIG:		db 34
  2241 0000057F 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2241 00000588 6F6F2062696720746F-
  2241 00000591 2066697420696E206D-
  2241 0000059A 656D6F72790D0A     
  2242 000005A1 16                      NOHANDMES:	db 22
  2243 000005A2 0D0A                    		db 0Dh,0Ah
  2244 000005A4 4E6F20667265652066-     		db 'No free file handles'
  2244 000005AD 696C652068616E646C-
  2244 000005B6 6573               
  2245 000005B8 1A                      RBADNAM:	db 26
  2246 000005B9 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2246 000005C2 6E64206F722066696C-
  2246 000005CB 65206E616D650D0A   
  2247                                  ACCDENIED:	; 14/01/2023
  2248                                  		; 10/01/2023
  2249 000005D3 0E                      ACCDEN:		db 14
  2250 000005D4 416363657373206465-     		db 'Access denied '
  2250 000005DD 6E69656420         
  2251 000005E2 19                      BMEMMES:	db 25
  2252 000005E3 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2252 000005EC 616C6C6F636174696F-
  2252 000005F5 6E206572726F72     
  2253 000005FC 26                      HALTMES:	db 38
  2254 000005FD 0D0A                    		db 0Dh,0Ah
  2255 000005FF 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2255 00000608 616420434F4D4D414E-
  2255 00000611 442C2073797374656D-
  2255 0000061A 2068616C7465640D0A 
  2256 00000623 21                      FRETMES:	db 33
  2257 00000624 0D0A                    		db 0Dh,0Ah,
  2258 00000626 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2258 0000062F 61727420434F4D4D41-
  2258 00000638 4E442C206578697469-
  2258 00000641 6E670D0A           
  2259 00000645 2E                      PATRICIDE:	db 46
  2260 00000646 0D0A                    		db 0Dh,0Ah
  2261 00000648 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2261 00000651 2070726F6365737320-
  2261 0000065A 61626F727465642C20-
  2261 00000663 63616E6E6F7420636F-
  2261 0000066C 6E74696E7565       
  2262 00000672 0D0A                    		db 0Dh,0Ah
  2263 00000674 02                      NEWLINE:	db 2
  2264 00000675 0D0A                    		db 0Dh, 0Ah
  2265                                  
  2266                                  ; 10/01/2023
  2267                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2268                                  
  2269 00000677 [5B0B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2270 00000679 0100                    		dw 1
  2271 0000067B [1609]                  		dw PARSMSGPTRS		; parse	error messages
  2272 0000067D 0100                    		dw 1
  2273 0000067F [5B0B]                  		dw EXTMSGPTRS		; critical error messages
  2274 00000681 0100                    		dw 1
  2275 00000683 0000                    		dw 0			; File system error messages
  2276 00000685 0000                    		dw 0			; are not supported.
  2277 00000687 [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2278 00000689 0000                    MySeg3:		dw 0			; segment of retriever routine
  2279                                  
  2280                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2281                                  
  2282 0000068B 13                      CRMSG0:		db 19
  2283 0000068C 57726974652070726F-     		db 'Write protect error'
  2283 00000695 74656374206572726F-
  2283 0000069E 72                 
  2284 0000069F 0C                      CRMSG1:		db 12
  2285 000006A0 496E76616C69642075-     		db 'Invalid unit'
  2285 000006A9 6E6974             
  2286 000006AC 09                      CRMSG2:		db 9
  2287 000006AD 4E6F74207265616479      		db 'Not ready'
  2288 000006B6 16                      CRMSG3:		db 22
  2289 000006B7 496E76616C69642064-     		db 'Invalid device request'
  2289 000006C0 657669636520726571-
  2289 000006C9 75657374           
  2290 000006CD 0A                      CRMSG4:		db 10
  2291 000006CE 44617461206572726F-     		db 'Data error'
  2291 000006D7 72                 
  2292 000006D8 21                      CRMSG5:		db 33
  2293 000006D9 496E76616C69642064-     		db 'Invalid device request parameters'
  2293 000006E2 657669636520726571-
  2293 000006EB 756573742070617261-
  2293 000006F4 6D6574657273       
  2294 000006FA 0A                      CRMSG6:		db 10
  2295 000006FB 5365656B206572726F-     		db 'Seek error'
  2295 00000704 72                 
  2296 00000705 12                      CRMSG7:		db 18
  2297 00000706 496E76616C6964206D-     		db 'Invalid media type'
  2297 0000070F 656469612074797065 
  2298 00000718 10                      CRMSG8:		db 16
  2299 00000719 536563746F72206E6F-     		db 'Sector not found'
  2299 00000722 7420666F756E64     
  2300 00000729 1A                      CRMSG9:		db 26
  2301 0000072A 5072696E746572206F-     		db 'Printer out of paper error'
  2301 00000733 7574206F6620706170-
  2301 0000073C 6572206572726F72   
  2302 00000744 11                      CRMSG10:	db 17
  2303 00000745 577269746520666175-     		db 'Write fault error'
  2303 0000074E 6C74206572726F72   
  2304 00000756 10                      CRMSG11:	db 16
  2305 00000757 52656164206661756C-     		db 'Read fault error'
  2305 00000760 74206572726F72     
  2306 00000767 0F                      CRMSG12:	db 15
  2307 00000768 47656E6572616C2066-     		db 'General failure'
  2307 00000771 61696C757265       
  2308 00000777 11                      CRMSG13:	db 17
  2309 00000778 53686172696E672076-     		db 'Sharing violation'
  2309 00000781 696F6C6174696F6E   
  2310 00000789 0E                      CRMSG14:	db 14
  2311 0000078A 4C6F636B2076696F6C-     		db 'Lock violation'
  2311 00000793 6174696F6E         
  2312 00000798 13                      CRMSG15:	db 19
  2313 00000799 496E76616C69642064-     		db 'Invalid disk change'
  2313 000007A2 69736B206368616E67-
  2313 000007AB 65                 
  2314 000007AC 0F                      CRMSG16:	db 15
  2315 000007AD 46434220756E617661-     		db 'FCB unavailable'
  2315 000007B6 696C61626C65       
  2316 000007BC 19                      CRMSG17:	db 25
  2317 000007BD 53797374656D207265-     		db 'System resource exhausted'
  2317 000007C6 736F75726365206578-
  2317 000007CF 68617573746564     
  2318 000007D6 12                      CRMSG18:	db 18
  2319 000007D7 436F64652070616765-     		db 'Code page mismatch'
  2319 000007E0 206D69736D61746368 
  2320 000007E9 0C                      CRMSG19:	db 12
  2321 000007EA 4F7574206F6620696E-     		db 'Out of input'
  2321 000007F3 707574             
  2322 000007F6 17                      CRMSG20:	db 23
  2323 000007F7 496E73756666696369-     		db 'Insufficient disk space'
  2323 00000800 656E74206469736B20-
  2323 00000809 7370616365         
  2324                                  
  2325                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2326                                  
  2327 0000080E [8B06]                  CRITMSGPTRS:	dw CRMSG0
  2328 00000810 [9F06]                  		dw CRMSG1
  2329 00000812 [AC06]                  		dw CRMSG2
  2330 00000814 [B606]                  		dw CRMSG3
  2331 00000816 [CD06]                  		dw CRMSG4
  2332 00000818 [D806]                  		dw CRMSG5
  2333 0000081A [FA06]                  		dw CRMSG6
  2334 0000081C [0507]                  		dw CRMSG7
  2335 0000081E [1807]                  		dw CRMSG8
  2336 00000820 [2907]                  		dw CRMSG9
  2337 00000822 [4407]                  		dw CRMSG10
  2338 00000824 [5607]                  		dw CRMSG11
  2339 00000826 [6707]                  		dw CRMSG12
  2340 00000828 [7707]                  		dw CRMSG13
  2341 0000082A [8907]                  		dw CRMSG14
  2342 0000082C [9807]                  		dw CRMSG15
  2343 0000082E [AC07]                  		dw CRMSG16
  2344 00000830 [BC07]                  		dw CRMSG17
  2345 00000832 [D607]                  		dw CRMSG18
  2346 00000834 [E907]                  		dw CRMSG19
  2347 00000836 [F607]                  		dw CRMSG20
  2348                                  
  2349                                  		; 14/01/2023
  2350                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2351                                  
  2352 00000838 13                      PAERRMSG0:	db 19
  2353 00000839 546F6F206D616E7920-     		db 'Too many parameters'
  2353 00000842 706172616D65746572-
  2353 0000084B 73                 
  2354 0000084C 1A                      PAERRMSG1:	db 26
  2355 0000084D 526571756972656420-     		db 'Required parameter missing'
  2355 00000856 706172616D65746572-
  2355 0000085F 206D697373696E67   
  2356 00000867 0E                      PAERRMSG2:	db 14
  2357 00000868 496E76616C69642073-     		db 'Invalid switch'
  2357 00000871 7769746368         
  2358 00000876 0F                      PAERRMSG3:	db 15
  2359 00000877 496E76616C6964206B-     		db 'Invalid keyword'
  2359 00000880 6579776F7264       
  2360 00000886 01                      PAERRMSG4:	db 1
  2361 00000887 20                      		db 20h
  2362 00000888 24                      PAERRMSG5:	db 36
  2363 00000889 506172616D65746572-     		db 'Parameter value not in allowed range'
  2363 00000892 2076616C7565206E6F-
  2363 0000089B 7420696E20616C6C6F-
  2363 000008A4 7765642072616E6765 
  2364                                  PAERRMSG6:	; 10/01/2023
  2365 000008AD 1B                      PAERRMSG7:	db 27
  2366 000008AE 506172616D65746572-     		db 'Parameter value not allowed'
  2366 000008B7 2076616C7565206E6F-
  2366 000008C0 7420616C6C6F776564 
  2367                                  ;PAERRMSG7:	db 27
  2368                                  ;		db 'Parameter value not allowed'
  2369 000008C9 1C                      PAERRMSG8:	db 28
  2370 000008CA 506172616D65746572-     		db 'Parameter format not correct'
  2370 000008D3 20666F726D6174206E-
  2370 000008DC 6F7420636F72726563-
  2370 000008E5 74                 
  2371 000008E6 11                      PAERRMSG9:	db 17
  2372 000008E7 496E76616C69642070-     		db 'Invalid parameter'
  2372 000008F0 6172616D65746572   
  2373 000008F8 1D                      PAERRMSG10:	db 29
  2374 000008F9 496E76616C69642070-     		db 'Invalid parameter combination'
  2374 00000902 6172616D6574657220-
  2374 0000090B 636F6D62696E617469-
  2374 00000914 6F6E               
  2375                                  
  2376                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2377                                  
  2378 00000916 [3808]                  PARSMSGPTRS:	dw PAERRMSG0
  2379 00000918 [4C08]                  		dw PAERRMSG1
  2380 0000091A [6708]                  		dw PAERRMSG2
  2381 0000091C [7608]                  		dw PAERRMSG3
  2382 0000091E [8608]                  		dw PAERRMSG4
  2383 00000920 [8808]                  		dw PAERRMSG5
  2384 00000922 [AD08]                  		dw PAERRMSG6
  2385 00000924 [AD08]                  		dw PAERRMSG7
  2386 00000926 [C908]                  		dw PAERRMSG8
  2387 00000928 [E608]                  		dw PAERRMSG9
  2388 0000092A [F808]                  		dw PAERRMSG10
  2389                                  ; 21/04/2023
  2390                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2391                                  
  2392 0000092C 10                      INVLFUNCT:	db 16
  2393 0000092D 496E76616C69642066-     		db 'Invalid function'
  2393 00000936 756E6374696F6E     
  2394 0000093D 0E                      FNOTFOUND:	db 14
  2395 0000093E 46696C65206E6F7420-     		db 'File not found'
  2395 00000947 666F756E64         
  2396 0000094C 0E                      PNOTFOUND:	db 14
  2397 0000094D 50617468206E6F7420-     		db 'Path not found'
  2397 00000956 666F756E64         
  2398 0000095B 13                      TOOMANYOF:	db 19
  2399 0000095C 546F6F206D616E7920-     		db 'Too many open files'
  2399 00000965 6F70656E2066696C65-
  2399 0000096E 73                 
  2400                                  ; 14/01/2023
  2401                                  ;ACCDEN:	; 10/01/2023
  2402                                  ;ACCDENIED:	db 14
  2403                                  ;		db 'Access denied '
  2404 0000096F 0E                      INVHANDLE:	db 14
  2405 00000970 496E76616C69642068-     		db 'Invalid handle'
  2405 00000979 616E646C65         
  2406 0000097E 1F                      MEMCBDEST:	db 31
  2407 0000097F 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2407 00000988 6E74726F6C20626C6F-
  2407 00000991 636B73206465737472-
  2407 0000099A 6F796564           
  2408 0000099E 13                      INSUFFMEM:	db 19
  2409 0000099F 496E73756666696369-     		db 'Insufficient memory'
  2409 000009A8 656E74206D656D6F72-
  2409 000009B1 79                 
  2410 000009B2 1C                      INVMEMBLA:	db 28
  2411 000009B3 496E76616C6964206D-     		db 'Invalid memory block address'
  2411 000009BC 656D6F727920626C6F-
  2411 000009C5 636B20616464726573-
  2411 000009CE 73                 
  2412 000009CF 13                      INVENVIRO:	db 19
  2413 000009D0 496E76616C69642045-     		db 'Invalid Environment'
  2413 000009D9 6E7669726F6E6D656E-
  2413 000009E2 74                 
  2414 000009E3 0E                      INVFORMAT:	db 14
  2415 000009E4 496E76616C69642066-     		db 'Invalid format'
  2415 000009ED 6F726D6174         
  2416 000009F2 1A                      INVFNPARM:	db 26
  2417 000009F3 496E76616C69642066-     		db 'Invalid function parameter'
  2417 000009FC 756E6374696F6E2070-
  2417 00000A05 6172616D65746572   
  2418 00000A0D 0C                      INVLDDATA:	db 12
  2419 00000A0E 496E76616C69642064-     		db 'Invalid data'
  2419 00000A17 617461             
  2420 00000A1A 1B                      INVDRVSPC:	db 27
  2421 00000A1B 496E76616C69642064-     		db 'Invalid drive specification'
  2421 00000A24 726976652073706563-
  2421 00000A2D 696669636174696F6E 
  2422 00000A36 23                      ATRCURDIR:	db 35
  2423 00000A37 417474656D70742074-     		db 'Attempt to remove current directory'
  2423 00000A40 6F2072656D6F766520-
  2423 00000A49 63757272656E742064-
  2423 00000A52 69726563746F7279   
  2424 00000A5A 0F                      NOTSAMDEV:	db 15
  2425 00000A5B 4E6F742073616D6520-     		db 'Not same device'
  2425 00000A64 646576696365       
  2426 00000A6A 0D                      NOMOREFIL:	db 13
  2427 00000A6B 4E6F206D6F72652066-     		db 'No more files'
  2427 00000A74 696C6573           
  2428 00000A78 0B                      FILEXISTS:	db 11
  2429 00000A79 46696C652065786973-     		db 'File exists'
  2429 00000A82 7473               
  2430 00000A84 1B                      CANTMKDIR:	db 27
  2431 00000A85 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2431 00000A8E 6B6520646972656374-
  2431 00000A97 6F727920656E747279 
  2432 00000AA0 0E                      FAILINT24:	db 14
  2433 00000AA1 4661696C206F6E2049-     		db 'Fail on INT 24'
  2433 00000AAA 4E54203234         
  2434 00000AAF 15                      TOOMANYRD:	db 21
  2435 00000AB0 546F6F206D616E7920-     		db 'Too many redirections'
  2435 00000AB9 726564697265637469-
  2435 00000AC2 6F6E73             
  2436 00000AC5 15                      DUPLREDIR:	db 21
  2437 00000AC6 4475706C6963617465-     		db 'Duplicate redirection'
  2437 00000ACF 207265646972656374-
  2437 00000AD8 696F6E             
  2438 00000ADB 10                      INVPASSWD:	db 16
  2439 00000ADC 496E76616C69642070-     		db 'Invalid password'
  2439 00000AE5 617373776F7264     
  2440 00000AEC 11                      INVLDPARM:	db 17
  2441 00000AED 496E76616C69642070-     		db 'Invalid parameter'
  2441 00000AF6 6172616D65746572   
  2442 00000AFE 12                      NETDATFAU:	db 18
  2443 00000AFF 4E6574776F726B2064-     		db 'Network data fault'
  2443 00000B08 617461206661756C74 
  2444 00000B11 21                      FNOSUPNET:	db 33
  2445 00000B12 46756E6374696F6E20-     		db 'Function not supported by network'
  2445 00000B1B 6E6F7420737570706F-
  2445 00000B24 72746564206279206E-
  2445 00000B2D 6574776F726B       
  2446 00000B33 27                      RSCNOTINS:	db 39
  2447 00000B34 526571756972656420-     		db 'Required system component not installed'
  2447 00000B3D 73797374656D20636F-
  2447 00000B46 6D706F6E656E74206E-
  2447 00000B4F 6F7420696E7374616C-
  2447 00000B58 6C6564             
  2448                                  
  2449                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2450                                  
  2451 00000B5B [2C09]                  EXTMSGPTRS:	dw INVLFUNCT
  2452 00000B5D [3D09]                  		dw FNOTFOUND
  2453 00000B5F [4C09]                  		dw PNOTFOUND
  2454 00000B61 [5B09]                  		dw TOOMANYOF
  2455 00000B63 [D305]                  		dw ACCDENIED
  2456 00000B65 [6F09]                  		dw INVHANDLE
  2457 00000B67 [7E09]                  		dw MEMCBDEST
  2458 00000B69 [9E09]                  		dw INSUFFMEM
  2459 00000B6B [B209]                  		dw INVMEMBLA
  2460 00000B6D [CF09]                  		dw INVENVIRO
  2461 00000B6F [E309]                  		dw INVFORMAT
  2462 00000B71 [F209]                  		dw INVFNPARM
  2463 00000B73 [0D0A]                  		dw INVLDDATA
  2464 00000B75 0000                    		dw 0
  2465 00000B77 [1A0A]                  		dw INVDRVSPC
  2466 00000B79 [360A]                  		dw ATRCURDIR
  2467 00000B7B [5A0A]                  		dw NOTSAMDEV
  2468 00000B7D [6A0A]                  		dw NOMOREFIL
  2469 00000B7F [8B06]                  		dw CRMSG0
  2470 00000B81 [9F06]                  		dw CRMSG1
  2471 00000B83 [AC06]                  		dw CRMSG2
  2472 00000B85 [B606]                  		dw CRMSG3
  2473 00000B87 [CD06]                  		dw CRMSG4
  2474 00000B89 [D806]                  		dw CRMSG5
  2475 00000B8B [FA06]                  		dw CRMSG6
  2476 00000B8D [0507]                  		dw CRMSG7
  2477 00000B8F [1807]                  		dw CRMSG8
  2478 00000B91 [2907]                  		dw CRMSG9
  2479 00000B93 [4407]                  		dw CRMSG10
  2480 00000B95 [5607]                  		dw CRMSG11
  2481 00000B97 [6707]                  		dw CRMSG12
  2482 00000B99 [7707]                  		dw CRMSG13
  2483 00000B9B [8907]                  		dw CRMSG14
  2484 00000B9D [9807]                  		dw CRMSG15
  2485 00000B9F [AC07]                  		dw CRMSG16
  2486 00000BA1 [BC07]                  		dw CRMSG17
  2487 00000BA3 [D607]                  		dw CRMSG18
  2488 00000BA5 [E907]                  		dw CRMSG19
  2489 00000BA7 [F607]                  		dw CRMSG20
  2490 00000BA9 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2491 00000BF9 [780A]                  		dw FILEXISTS
  2492 00000BFB 0000                    		dw 0
  2493 00000BFD [840A]                  		dw CANTMKDIR
  2494 00000BFF [A00A]                  		dw FAILINT24
  2495 00000C01 [AF0A]                  		dw TOOMANYRD
  2496 00000C03 [C50A]                  		dw DUPLREDIR
  2497 00000C05 [DB0A]                  		dw INVPASSWD
  2498 00000C07 [EC0A]                  		dw INVLDPARM
  2499 00000C09 [FE0A]                  		dw NETDATFAU
  2500 00000C0B [110B]                  		dw FNOSUPNET
  2501 00000C0D [330B]                  		dw RSCNOTINS
  2502                                  ; ----------------------------------------------------------------------------
  2503                                  	; 17/04/2023
  2504                                  ExtMsgEnd:
  2505                                  
  2506                                  ; 21/04/2023
  2507                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2508                                  
  2509                                  ; ----------------------------------------------------------------------------
  2510                                  
  2511                                  ; 20/04/2023
  2512                                  
  2513 00000C0F 90                      align 16
  2514                                  
  2515                                  ; ----------------------------------------------------------------------------
  2516                                  
  2517                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2518                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2519                                  
  2520                                  ; ----------------------------------------------------------------------------
  2521                                  ; SEGMENT - CODERES
  2522                                  ; ----------------------------------------------------------------------------
  2523                                  
  2524                                  ; 11/01/2023
  2525                                  RCODE_START:	
  2526                                  
  2527                                  ; ----------------------------------------------------------------------------
  2528                                  ;***	EXEC error handling
  2529                                  ;
  2530                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2531                                  ;	We examine the error code and select an appropriate message.
  2532                                  ; --------------------------
  2533                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2534                                  ;	Condense the error scan?
  2535                                  ;	RBADNAM is checked by transient, no need here?
  2536                                  ;	Move below Ext_Exec.
  2537                                  ; ----------------------------------------------------------------------------
  2538                                  
  2539                                  Exec_Err:
  2540                                  ;SR;
  2541                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2542                                  ; in order here
  2543                                  
  2544                                  ;	Bugbug:	can we use byte compares here?
  2545                                  ;	Might be able to use byte msg#s, too.
  2546                                  
  2547                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2548                                  ;	Speed not high priority here.
  2549                                  
  2550                                  ;	Move this to transient.
  2551                                  
  2552                                  	; 10/01/2023
  2553                                  
  2554                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2555 00000C10 BA[B805]                	mov	dx,RBADNAM
  2556 00000C13 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2557 00000C15 741B                    	je	short GotExecEMes		; bad command
  2558                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2559 00000C17 BA[7E05]                	mov	dx,TOOBIG
  2560 00000C1A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2561 00000C1C 7414                    	je	short GotExecEMes		; file not found
  2562                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2563 00000C1E BA[6A05]                	mov	dx,EXEBAD
  2564 00000C21 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2565 00000C23 740D                    	je	short GotExecEMes		; bad exe file
  2566                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2567 00000C25 BA[D305]                	mov	dx,ACCDEN
  2568 00000C28 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2569 00000C2A 7406                    	je	short GotExecEMes		; access denied
  2570                                  
  2571                                  Default_Message:
  2572                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2573 00000C2C BA[5605]                	mov	dx,EXECEMES
  2574                                  						; default message
  2575 00000C2F BE[3301]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2576                                  						; get address of subst block
  2577                                  GotExecEMes:
  2578                                  	;mov	dx,bx				; DX = ptr to msg
  2579 00000C32 E85B06                  	call	RPrint ; invoke	RPrint
  2580 00000C35 EB09                    	jmp	short NoExec
  2581                                  
  2582                                  ; ----------------------------------------------------------------------------
  2583                                  ;***	EXEC call
  2584                                  ;
  2585                                  ;	The transient has set up everything for an EXEC system call.
  2586                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2587                                  ;	so that we may be able to recover cleanly upon success.
  2588                                  ;
  2589                                  ;	CS,DS,ES,SS = DATARES seg addr
  2590                                  ; ----------------------------------------------------------------------------
  2591                                  
  2592                                  Ext_Exec:
  2593                                  ;SR;
  2594                                  ; The words put on the stack by the stub will be popped off when we finally
  2595                                  ;jump to LodCom (by LodCom).
  2596                                  
  2597                                  	; 10/01/2023
  2598                                  	;int	21h			; do the exec
  2599                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2600                                  Exec_Ret:
  2601 00000C37 72D7                    	jc	short Exec_Err		; exec failed
  2602                                  
  2603                                  ;	The exec has completed. Retrieve the exit code.
  2604                                  
  2605                                  Exec_Wait:
  2606 00000C39 B44D                    	mov	ah,4Dh
  2607                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2608 00000C3B CD21                    	int	21h			; get the return code
  2609                                  	;mov	[cs:RetCode],ax
  2610                                  	; 11/01/2023
  2611 00000C3D A3[9D01]                	mov	[RetCode],ax
  2612                                  
  2613                                  ;	See if we can reload the transient. The external command
  2614                                  ;	may have overwritten part of the transient.
  2615                                  
  2616                                  NoExec:
  2617                                  ;SR;
  2618                                  ; ds = es = ss = DATARES when we jump to LodCom
  2619                                  ;
  2620 00000C40 E97901                  	jmp	LodCom
  2621                                  
  2622                                  ; ----------------------------------------------------------------------------
  2623                                  ;***	Int 23 (ctrl-c) handler
  2624                                  ;
  2625                                  ;	This is the default system INT 23 handler. All processes
  2626                                  ;	(including COMMAND) get it by default. There are some
  2627                                  ;	games that are played: We ignore ^C during most of the
  2628                                  ;	INIT code. This is because we may perform an ALLOC and
  2629                                  ;	diddle the header! Also, if we are prompting for date/time
  2630                                  ;	in the init code, we are to treat ^C as empty responses.
  2631                                  ; ---------------------------
  2632                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2633                                  ; ----------------------------------------------------------------------------
  2634                                  
  2635                                  ;SR;
  2636                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2637                                  ;both these values off the stack now
  2638                                  ;
  2639                                  ;ContC	proc	far
  2640                                  
  2641                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2642                                  
  2643                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2644                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2645                                  ContC:
  2646 00000C43 1F                      	pop	ds			; ds = DATARES
  2647                                  ;	assume	ds:DATARES
  2648                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2649                                  
  2650 00000C44 F606[1702]01            	test	byte [InitFlag],INITINIT ; 1
  2651                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2652 00000C49 740D                    	jz	short NotAtInit		; no
  2653 00000C4B F606[1702]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2654                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2655 00000C50 7404                    	jz	short CmdIret		; no, ignore ^C
  2656 00000C52 1F                      	pop	ds			; restore before jumping; M021
  2657                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2658 00000C53 E9020E                  	jmp	init_contc_specialcase
  2659                                  CmdIret:
  2660                                  ;SR;
  2661                                  ; Restore ds to its previous value
  2662                                  ;
  2663                                  
  2664                                  ;;	mov	ds,[OLdDS]		;
  2665 00000C56 1F                      	pop	ds
  2666 00000C57 CF                      	iret				; yes, ignore the ^C
  2667                                  
  2668                                  NotAtInit:
  2669 00000C58 F606[1702]04            	test	byte [InitFlag],INITCTRLC ; 4
  2670                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2671 00000C5D 7412                    	jz	short NotInit 		; nope too.
  2672                                  
  2673                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2674                                  ;	to set carry and return to the user sans flags only if the
  2675                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2676                                  
  2677 00000C5F 80FC01                  	cmp	ah,1
  2678 00000C62 72F2                    	jb	short CmdIret
  2679 00000C64 80FC0C                  	cmp	ah,12
  2680 00000C67 77ED                    	ja	short CmdIret
  2681                                  
  2682 00000C69 1F                      	pop	ds			;restore ds to old value
  2683 00000C6A 83C406                  	add	sp,6			; remove int frame
  2684 00000C6D F9                      	stc
  2685                                  
  2686                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2687 00000C6E CA0200                  	retf	2			; remove those flags...
  2688                                  
  2689                                  NotInit:
  2690                                  
  2691                                  ;*	We have now received a ^C for some process (maybe ourselves
  2692                                  ;	but not at INIT).
  2693                                  ;	
  2694                                  ;	Note that we are running on the user's stack!!! Bad news if
  2695                                  ;	any of the system calls below go and issue another INT
  2696                                  ;	24... Massive stack overflow! Another bad point is that
  2697                                  ;	SavHand will save an already saved handle, thus losing a
  2698                                  ;	possible redirection...
  2699                                  ;	
  2700                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2701                                  ;	The above code will correctly flag the ^C diring the
  2702                                  ;	message output and prompting while ignoring the ^C the rest
  2703                                  ;	of the time.
  2704                                  ;	
  2705                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2706                                  ;	file, we ask if he wants to terminate it. If he does, then
  2707                                  ;	we turn off all internal flags and let the DOS abort.
  2708                                  
  2709 00000C71 800E[1702]04            	or	byte [InitFlag],INITCTRLC ; 4
  2710                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2711 00000C76 FB                      	sti
  2712                                  
  2713                                  ;	push	cs			; el yucko! change the user's ds!!
  2714                                  ;	pop	ds
  2715                                  
  2716                                  ;	assume	ds:RESGROUP
  2717                                  
  2718 00000C77 58                      	pop	ax			; discard the old ds value
  2719                                  
  2720 00000C78 A1[A601]                	mov	ax,[SingleCom]
  2721 00000C7B 09C0                    	or	ax,ax
  2722 00000C7D 7506                    	jnz	short NoReset
  2723 00000C7F 50                      	push	ax
  2724 00000C80 B40D                    	mov	ah,DISK_RESET ; 0Dh
  2725 00000C82 CD21                    	int	21h			; reset disks in case files were open
  2726 00000C84 58                      	pop	ax
  2727                                  
  2728                                  NoReset:
  2729                                  
  2730                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2731                                  ;	walk the entire active list and free each segment. Here,
  2732                                  ;	we just free the single batch segment.
  2733                                  
  2734 00000C85 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2735 00000C8B 7452                    	jz	short ContCTerm
  2736 00000C8D 09C0                    	or	ax,ax
  2737 00000C8F 754E                    	jnz	short ContCTerm
  2738 00000C91 E88502                  	call	SavHand
  2739 00000C94 E89303                  	call	AskEnd			; ask if user wants to end batch
  2740                                  
  2741                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2742                                  
  2743 00000C97 7340                    	jnc	short ContBatch
  2744 00000C99 8A0E[A001]              	mov	cl,[EchoFlag]		; get current echo flag
  2745 00000C9D 53                      	push	bx
  2746                                  
  2747                                  ClearBatch:
  2748 00000C9E 8E06[4C01]              	mov	es,[Batch]		; get batch segment
  2749                                  	;mov	di,20h
  2750                                  	; 06/06/2023 (BugFix)
  2751 00000CA2 BF2000                  	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
  2752                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2753                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2754 00000CA5 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2755                                  	; MSDOS 3.3 ([ES:4])
  2756                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2757                                  	;
  2758 00000CAA 83FB00                  	cmp	bx,0			; is a FOR in progress
  2759 00000CAD 7408                    	je	short No_Bat_For	; no - don't deallocate
  2760 00000CAF 06                      	push	es			;
  2761 00000CB0 8EC3                    	mov	es,bx			; yes - free it up...
  2762 00000CB2 B449                    	mov	ah,49h
  2763                                  	;mov	ah,DEALLOC ; 49h	;
  2764 00000CB4 CD21                    	int	21h			;
  2765 00000CB6 07                      	pop	es			; restore to batch segment
  2766                                  
  2767                                  No_Bat_For:
  2768                                  	;mov	cl,[es:1]
  2769 00000CB7 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2770                                  	;mov	bx,[es:3]
  2771 00000CBC 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2772 00000CC1 B449                    	mov	ah,49h
  2773                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2774 00000CC3 CD21                    	int	21h
  2775 00000CC5 891E[4C01]              	mov	[Batch],bx		; get ready to deallocate next batch
  2776 00000CC9 FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
  2777 00000CCD 75CF                    	jnz	short ClearBatch	; keep going until no batch file
  2778                                  
  2779                                  ;	We are terminating a batch file; restore the echo status
  2780                                  
  2781                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2782 00000CCF 5B                      	pop	bx
  2783 00000CD0 880E[A001]              	mov	[EchoFlag],cl		; reset echo status
  2784                                  	; 29/05/2018
  2785 00000CD4 C606[1802]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2786                                  
  2787                                  ContBatch:
  2788 00000CD9 E8B105                  	call	crlf			; print out crlf before returning
  2789 00000CDC E86302                  	call	RestHand
  2790                                  
  2791                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2792                                  
  2793                                  ContCTerm:
  2794 00000CDF 31C0                    	xor	ax,ax			; indicate no read
  2795 00000CE1 89C5                    	mov	bp,ax
  2796                                  
  2797                                  ;	The following resetting of the state flags is good for the
  2798                                  ;	generalized batch processing.
  2799                                  
  2800 00000CE3 A2[AB01]                	mov	[IfFlag],al		; turn off iffing
  2801 00000CE6 A2[AC01]                	mov	[ForFlag],al		; turn off for processing
  2802 00000CE9 E81C00                  	call	ResPipeOff
  2803 00000CEC 3906[A601]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2804 00000CF0 7406                    	jz	short NoSetSing
  2805 00000CF2 C706[A601]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2806                                  					;  pipe, batch, for
  2807                                  NoSetSing:
  2808                                  
  2809                                  ;	If we are doing an internal command, go through the reload process.
  2810                                  ;	If we are doing an external, let DOS abort the process.
  2811                                  ;	In both cases, we are now done with the ^C processing.
  2812                                  
  2813 00000CF8 8026[1702]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2814 00000CFD 3806[9C01]              	cmp	[ExtCom],al
  2815 00000D01 7503                    	jnz	short DoDAb		; internal ^c
  2816 00000D03 E94501                  	jmp	LodCom1
  2817                                  DoDAb:
  2818 00000D06 F9                      	stc				; tell dos to abort
  2819                                  
  2820                                  ;SR;
  2821                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2822                                  ;by setting carry and leaving flags on the stack
  2823                                  
  2824 00000D07 CB                      	retf				; Leave flags on stack
  2825                                  
  2826                                  ;ContC	endp
  2827                                  
  2828                                  ;SR;
  2829                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2830                                  ;both have ds = DATARES
  2831                                  
  2832                                  	; 11/01/2023
  2833                                  ResPipeOff:
  2834 00000D08 50                      	push	ax
  2835 00000D09 31C0                    	xor	ax,ax
  2836                                  	;xchg	al,[cs:PIPEFLAG]
  2837 00000D0B 8606[1802]              	xchg	al,[PipeFlag]
  2838 00000D0F 08C0                    	or	al,al
  2839 00000D11 7404                    	jz	short NoPipePop
  2840                                  	;shr	byte [cs:ECHOFLAG],1
  2841 00000D13 D02E[A001]              	shr	byte [EchoFlag],1
  2842                                  NoPipePop:
  2843 00000D17 58                      	pop	ax
  2844 00000D18 C3                      	retn
  2845                                  
  2846                                  ;CODERES ends
  2847                                  
  2848                                  ;=============================================================================
  2849                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2850                                  ;=============================================================================
  2851                                  ; 21/09/2018 - Retro DOS v3.0
  2852                                  
  2853                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2854                                  ;	name	COMMAND2
  2855                                  
  2856                                  ;/*
  2857                                  ; *                      Microsoft Confidential
  2858                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2859                                  ; *                      All Rights Reserved.
  2860                                  ; */
  2861                                  
  2862                                  ;
  2863                                  ;	Revision History
  2864                                  ;	================
  2865                                  ;
  2866                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2867                                  ;			reserve memory by changing int 12h and then give it
  2868                                  ;			back to DOS by changing arenas in autoexec.bat.
  2869                                  ;			This makes command.com reload transient and this
  2870                                  ;			cannot be done at this stage.
  2871                                  ;
  2872                                  
  2873                                  ;CODERES segment public byte
  2874                                  
  2875                                  ;*	If we cannot allocate enough memory for the transient or there
  2876                                  ;	was some other allocation error, we display a message and
  2877                                  ;	then die.
  2878                                  
  2879                                  ;SR;
  2880                                  ; We will have to make sure that at this entry point and at FatalC, 
  2881                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2882                                  ;and so we should be able to do this
  2883                                  
  2884                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2885                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2886                                  
  2887                                  	;assume	ds:DATARES
  2888                                  BadMemErr:
  2889 00000D19 BA[E205]                	mov	dx,BMEMMES			; DX = ptr to msg
  2890                                  FatalC:
  2891                                  	; 12/01/2023
  2892                                  ;;	push	cs
  2893                                  ;;	pop	ds
  2894                                  ;;	assume	ds:ResGroup
  2895                                  ;	invoke	RPrint
  2896                                  
  2897                                  	; 12/01/2023
  2898                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2899 00000D1C E87105                  	call	RPrint
  2900                                  
  2901                                  	; MSDOS 3.3
  2902                                  	;call	RDISPMSG
  2903                                  
  2904                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2905                                  ;	we can't do anything else!
  2906                                  
  2907 00000D1F 803E[A501]00            	cmp	byte [PermCom],0
  2908 00000D24 7410                    	je	short FatalRet
  2909                                  
  2910                                  ;	We are a permanent command. If we are in the process of the
  2911                                  ;	magic interrupt (Singlecom) then exit too.
  2912                                  
  2913 00000D26 833E[A601]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2914 00000D2B 7509                    	jne	short FatalRet			; must take int_2e exit
  2915                                  
  2916                                  ;	Permanent command. We can't do ANYthing except halt.
  2917                                  
  2918 00000D2D BA[FC05]                	mov	dx,HALTMES			; DX = ptr to msg
  2919                                  	;invoke	RPrint
  2920                                  	; 12/01/2023	
  2921                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2922 00000D30 E85D05                  	call	RPrint	
  2923                                  	; MSDOS 3.3
  2924                                  	;call	RDISPMSG
  2925 00000D33 FB                      	sti
  2926                                  Stall:
  2927 00000D34 EBFE                    	jmp	short Stall			; crash the system nicely
  2928                                  
  2929                                  FatalRet:
  2930 00000D36 BA[2306]                	mov	dx,FRETMES			; DX = ptr to msg
  2931                                  	;call	RDISPMSG
  2932                                  	; 12/01/2023	
  2933 00000D39 E85405                  	call	RPrint	
  2934                                  FatalRet2:
  2935 00000D3C 803E[A501]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  2936 00000D41 7517                    	jne	short Ret_2e			; must be int_2e
  2937                                  
  2938                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  2939                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  2940                                  ;	case we decide to do that.)
  2941                                  
  2942 00000D43 A1[4101]                	mov	ax,[Parent]
  2943                                  	;mov	[16h],ax
  2944 00000D46 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  2945 00000D49 A1[4301]                	mov	ax,[OldTerm]
  2946                                  	;mov	[0Ah],ax
  2947 00000D4C A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  2948 00000D4F A1[4501]                	mov	ax,[OldTerm+2]
  2949                                  	;mov	[0Ch],ax
  2950 00000D52 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  2951 00000D55 B8004C                  	mov	ax,4C00h
  2952                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  2953 00000D58 CD21                    	int	21h
  2954                                  Ret_2e:
  2955                                  ;SR;
  2956                                  ; We will ensure that ds = DATARES for all entries to this place
  2957                                  ;
  2958                                  
  2959                                  ;;	push	cs
  2960                                  ;;	pop	ds
  2961                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  2962                                    	
  2963                                  ;	assume	ds:DATARES
  2964                                  
  2965                                  	;PUSH	CS
  2966                                  	;POP	DS
  2967                                  
  2968 00000D5A C706[A601]0000          	mov	word [SingleCom],0	; turn off SingleCom
  2969 00000D60 8E06[5F03]              	mov	es,[Res_Tpa]
  2970                                  	;mov	ah,49h	; 12/01/2023
  2971 00000D64 B449                    	mov	ah,DEALLOC
  2972 00000D66 CD21                    	int	21h			; free up space used by transient
  2973 00000D68 8B1E[3F01]              	mov	bx,[Save_Pdb]
  2974 00000D6C B450                    	mov	ah,50h
  2975                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  2976 00000D6E CD21                    	int	21h			; current process is user
  2977 00000D70 A1[9D01]                	mov	ax,[RetCode]
  2978 00000D73 803E[9C01]00            	cmp	byte [ExtCom],0
  2979 00000D78 7502                    	jne	short GotECode
  2980 00000D7A 31C0                    	xor	ax,ax			; internals always return 0
  2981                                  GotECode:
  2982 00000D7C C606[9C01]01            	mov	byte [ExtCom],1		; force external
  2983                                  
  2984                                  ;SR; This is actually returning to the caller. However, the old code had
  2985                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  2986                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  2987                                  
  2988                                  	; 12/01/2023
  2989 00000D81 FF2E[3B01]              	jmp	far [Int_2e_Ret]	; "iret"
  2990                                  
  2991                                  ;***	Int_2e, magic command executer
  2992                                  
  2993                                  Int_2e:
  2994                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2995                                  ;SR;
  2996                                  ;We are going to come here from the stub with the old ds and DATARES value
  2997                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  2998                                  
  2999                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3000                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3001                                  
  3002 00000D85 1F                      	pop	ds			; ds = DATARES
  3003                                  	;assume	ds:DATARES
  3004 00000D86 58                      	pop	ax
  3005                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3006                                  
  3007                                  	;pop	word [cs:Int_2e_Ret]
  3008                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3009                                  	;pop	ax			; chuck flags
  3010 00000D87 8F06[3B01]              	pop	word [Int_2e_Ret]
  3011 00000D8B 8F06[3D01]              	pop	word [Int_2e_Ret+2]
  3012                                  	
  3013 00000D8F 83C402                  	add	sp,2
  3014                                  
  3015                                  ;;	push	cs
  3016                                  ;;	pop	es
  3017                                  
  3018 00000D92 1E                      	push	ds
  3019 00000D93 07                      	pop	es			; es = DATARES
  3020                                  ;	;mov	ds,OldDS
  3021 00000D94 8ED8                    	mov	ds,ax
  3022                                  	;assume	ds:nothing		; ds = old value
  3023                                  
  3024 00000D96 BF8000                  	mov	di,80h
  3025 00000D99 B94000                  	mov	cx,64
  3026                                  ;	Bugbug:	cld
  3027 00000D9C F3A5                    	rep	movsw
  3028 00000D9E B451                    	mov	ah,51h
  3029                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3030 00000DA0 CD21                    	int	21h			; get user's header
  3031                                  	; 12/01/2023
  3032 00000DA2 26891E[3F01]            	mov	[es:Save_Pdb],bx
  3033                                  	;mov	[cs:Save_Pdb],bx
  3034 00000DA7 B450                    	mov	ah,50h
  3035                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3036                                  
  3037                                  ;;	mov	bx,cs
  3038                                  ;SR;
  3039                                  ;Set ds = DATARES because BadMemErr expects this
  3040                                  
  3041                                  	; 12/01/2023
  3042 00000DA9 06                      	push	es
  3043 00000DAA 1F                      	pop	ds
  3044                                  	;assume	ds:DATARES
  3045                                  
  3046 00000DAB 8CDB                    	mov	bx,ds			; es = our PSP now
  3047                                  	;mov	bx,cs
  3048                                  
  3049 00000DAD CD21                    	int	21h			; current process is me
  3050                                  	;mov	word [cs:SingleCom],81h
  3051                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3052                                  	; 12/01/2023
  3053 00000DAF C706[A601]8100          	mov	word [SingleCom],81h
  3054 00000DB5 C606[9C01]01            	mov	byte [ExtCom],1		; make sure this case forced
  3055                                  
  3056                                  ;SR;
  3057                                  ;We can enter LodCom directly after a command shell is terminated or we
  3058                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3059                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3060                                  ;be properly set. To fake this, we push dummy values here.
  3061                                  
  3062                                  	; 12/01/2023
  3063 00000DBA 1E                      	push	ds			; old value of ds
  3064 00000DBB 1E                      	push	ds			; data seg value, ds = DATARES
  3065                                  LodCom: 				; termination handler
  3066 00000DBC 1F                      	pop	ds			; ds = DATARES
  3067                                  	;assume	ds:DATARES
  3068 00000DBD 83C402                  	add	sp,2
  3069                                  ;	;pop	OldDS			; store old ds
  3070                                  	;cmp	ExtCom,0
  3071 00000DC0 803E[9C01]00            	cmp	byte [ExtCom],0
  3072                                  	;cmp	byte [cs:ExtCom],0
  3073                                  	;jne	short @f	 	; internal cmd - memory allocated
  3074                                  	; 16/04/2023
  3075 00000DC5 7503                    	jne	short LodCom0 ; 24/09/2018
  3076 00000DC7 E98100                  	jmp	LodCom1
  3077                                  	;je	short LodCom1 ; 25/09/2018	
  3078                                  ;@@:
  3079                                  LodCom0: ; 24/09/2018
  3080 00000DCA BBFFFF                  	mov	bx,0FFFFh
  3081 00000DCD B448                    	mov	ah,48h	; 12/01/2023
  3082                                  	;mov	ah,ALLOC ; 48h	
  3083 00000DCF CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3084                                  				; BX = number of 16-byte paragraphs desired
  3085 00000DD1 E80A00                  	call	SetSize
  3086 00000DD4 83C020                  	add	ax,20h
  3087 00000DD7 39C3                    	cmp	bx,ax
  3088 00000DD9 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3089                                  BadMemErrJ:
  3090 00000DDB E93BFF                  	jmp	BadMemErr		; not enough memory
  3091                                  
  3092                                  ;***	SetSize - get transient size in paragraphs
  3093                                  
  3094                                  SetSize:
  3095                                  	; 12/01/2023
  3096                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3097                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3098 00000DDE B81E96                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3099 00000DE1 B104                    	mov	cl,4
  3100 00000DE3 D3E8                    	shr	ax,cl
  3101 00000DE5 C3                      	retn
  3102                                  
  3103                                  MemOk:
  3104                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3105                                  
  3106 00000DE6 B448                    	mov	ah,48h
  3107                                  	;mov	ah,ALLOC  ; 48h
  3108 00000DE8 CD21                    	int	21h
  3109 00000DEA 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3110                                  	;mov	byte [cs:ExtCom],0
  3111                                  	;mov	[cs:Res_Tpa],ax
  3112                                  	; 12/01/2023
  3113 00000DEC C606[9C01]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3114 00000DF1 A3[5F03]                	mov	[Res_Tpa],ax		; save current tpa segment
  3115                                  
  3116 00000DF4 2500F0                  	and	ax,0F000h
  3117 00000DF7 050010                  	add	ax,1000h		; round up to next 64k boundary
  3118 00000DFA 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3119                                  
  3120                                  ;	Make sure that new boundary is within allocated range
  3121                                  
  3122                                  	;mov	dx,[cs:Res_Tpa]
  3123                                  	; 12/01/2023
  3124 00000DFC 8B16[5F03]              	mov	dx,[Res_Tpa]
  3125 00000E00 01DA                    	add	dx,bx			; compute maximum address
  3126 00000E02 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3127 00000E04 7608                    	jbe	short Bad_Tpa
  3128                                  
  3129                                  ;	Must have 64K of usable space.
  3130                                  
  3131 00000E06 29C2                    	sub	dx,ax			; compute the usable space
  3132 00000E08 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3133 00000E0C 7303                    	jae	short LTpaSet
  3134                                  Bad_Tpa:
  3135                                  	;mov	ax,[cs:Res_Tpa]
  3136                                  	; 12/01/2023
  3137 00000E0E A1[5F03]                	mov	ax,[Res_Tpa]
  3138                                  LTpaSet:
  3139                                  	;mov	[cs:LTPA],ax
  3140                                  	;mov	ax,[cs:Res_Tpa]
  3141                                  	; 12/01/2023
  3142 00000E11 A3[5103]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3143 00000E14 A1[5F03]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3144 00000E17 01C3                    	add	bx,ax
  3145                                  	;mov	[cs:MemSiz],bx
  3146 00000E19 891E[9801]              	mov	[MemSiz],bx
  3147 00000E1D E8BEFF                  	call	SetSize
  3148 00000E20 29C3                    	sub	bx,ax
  3149                                  
  3150                                  	; MSDOS 6.0
  3151                                  
  3152                                  ;M038; Start of changes
  3153                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3154                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3155                                  ;running a program that changes arenas. This changes the largest block that
  3156                                  ;command.com gets and so changes the transient segment. So, command.com does
  3157                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3158                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3159                                  ;reload fails, hanging the system. To get around this we just copy the
  3160                                  ;transient from the previous address to the new address(if changed) and
  3161                                  ;then let command.com do the checksum. So, if the transient area is not
  3162                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3163                                  ;is not really corrupted and so this should work.
  3164                                  
  3165                                  	; 12/01/2023
  3166                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3167                                  
  3168 00000E22 3B1E[9201]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3169 00000E26 7423                    	je	short LodCom1		; yes, dont copy
  3170                                  
  3171                                  ;Check if the new segment is above or below the current move. If the new
  3172                                  ;segment is above (i.e new block is larger than previous block), then we
  3173                                  ;have to move in the reverse direction
  3174                                  
  3175                                  	;mov	cx,98C5h
  3176 00000E28 B90F96                  	mov	cx,TRANSPACEEND		; cx = length to move
  3177 00000E2B 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3178 00000E2D 31F6                    	xor	si,si			; normal move
  3179 00000E2F 89F7                    	mov	di,si
  3180 00000E31 FC                      	cld
  3181 00000E32 EB06                    	jmp	short copy_trans
  3182                                  mov_down:
  3183 00000E34 89CE                    	mov	si,cx			; reverse move, start from end
  3184 00000E36 4E                      	dec	si
  3185 00000E37 89F7                    	mov	di,si
  3186 00000E39 FD                      	std
  3187                                  copy_trans:
  3188 00000E3A 1E                      	push	ds
  3189 00000E3B 06                      	push	es
  3190 00000E3C 8EC3                    	mov	es,bx			; dest segment
  3191 00000E3E 8E1E[9201]              	mov	ds,[TrnSeg]		; source segment
  3192                                  	;assume	ds:nothing
  3193                                  
  3194 00000E42 F3A4                    	rep	movsb			; copy transient
  3195 00000E44 FC                      	cld
  3196 00000E45 07                      	pop	es
  3197 00000E46 1F                      	pop	ds
  3198                                  	;assume	ds:DATARES
  3199                                  
  3200                                  ;M038; End of changes
  3201                                  
  3202                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3203                                  	; 12/01/2023
  3204 00000E47 891E[9201]              	mov	[TrnSeg],bx
  3205                                  
  3206                                  LodCom1:
  3207                                  ;;	mov	ax,cs
  3208                                  ;;	mov	ss,ax
  3209                                  ;SR; At this point ds = DATARES which is where the stack is located
  3210                                  
  3211                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3212                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3213 00000E4B 8CD8                    	mov	ax,ds
  3214 00000E4D 8ED0                    	mov	ss,ax
  3215                                  	;assume	ss:DATARES
  3216                                  	;;mov	sp,offset DATARES:RStack
  3217                                  	;mov	sp,53Eh
  3218 00000E4F BC[3804]                	mov	sp,RStack
  3219                                  
  3220                                  ;;	mov	ds,ax
  3221                                  
  3222                                  	;assume	ds:DATARES
  3223                                  	
  3224                                  	; MSDOS 3.3
  3225                                  	;mov	ax,cs
  3226                                  	;mov	ss,ax
  3227                                  	;mov	sp,RSTACK
  3228                                  	;mov	ds,ax
  3229                                  
  3230 00000E52 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3231 00000E55 31ED                    	xor	bp,bp			; flag command ok
  3232 00000E57 B8FFFF                  	mov	ax,-1
  3233 00000E5A 8706[A801]              	xchg	ax,[VerVal]
  3234 00000E5E 83F8FF                  	cmp	ax,-1
  3235 00000E61 7404                    	je	short NoSetVer
  3236 00000E63 B42E                    	mov	ah,2Eh
  3237                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3238 00000E65 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3239                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3240                                  NoSetVer:
  3241 00000E67 833E[A601]FF            	cmp	word [SingleCom],-1
  3242 00000E6C 7503                    	jne	short NoSng
  3243 00000E6E E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3244                                  NoSng:
  3245 00000E71 E87201                  	call	ChkSum			; check the transient
  3246                                  	;cmp	dx,[Sum]
  3247                                  	;je	short HavCom		; transient ok
  3248                                  	; 12/01/2023
  3249 00000E74 7412                    	jz	short HavCom
  3250                                  Bogus_Com:
  3251 00000E76 C606[4B01]01            	mov	byte [Loading],1	; flag DskErr routine
  3252 00000E7B E81E01                  	call	LoadCom
  3253                                  ChkSame:
  3254 00000E7E E86501                  	call	ChkSum
  3255                                  	;cmp	dx,[Sum]
  3256                                  	;je	short HavCom		; same command
  3257                                  	; 12/01/2023
  3258 00000E81 7405                    	jz	short HavCom
  3259                                  Also_Bogus:
  3260 00000E83 E85801                  	call	WrongCom
  3261 00000E86 EBF6                    	jmp	short ChkSame
  3262                                  
  3263                                  	; 12/01/2023
  3264                                  ;HavCom:
  3265                                  ;	; 25/09/2018
  3266                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3267                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3268                                  ;			; Return: AL = FFh unsupported subfunction
  3269                                  ;			; DL = current switch character
  3270                                  ;	mov     [RSWITCHAR],dl
  3271                                  ;	cmp     dl,'/'
  3272                                  ;	jnz     short USESLASH
  3273                                  ;	;mov	cl,'\'
  3274                                  ;	;mov	[RDIRCHAR],cl
  3275                                  ;	mov	byte [RDIRCHAR],'\'
  3276                                  ;USESLASH:
  3277                                  
  3278                                  HavCom:
  3279                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3280 00000E88 C606[4B01]00            	mov	byte [Loading],0		; flag to DskErr
  3281                                  	;;mov	si,offset DATARES:TranVars
  3282                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3283 00000E8D BE[4D03]                	mov	si,TranVars
  3284                                  	;;mov	di,offset TRANGROUP:HeadCall
  3285                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3286 00000E90 BF[BE8A]                	mov	di,HEADCALL
  3287 00000E93 8E06[9201]              	mov	es,[TrnSeg]
  3288 00000E97 FC                      	cld
  3289                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3290 00000E98 B9[6103]                	mov	cx,TranVarEnd
  3291 00000E9B 29F1                    	sub	cx,si
  3292 00000E9D F3A4                    	rep	movsb			; transfer info to transient
  3293 00000E9F A1[9801]                	mov	ax,[MemSiz]
  3294 00000EA2 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3295                                  
  3296                                  ;***	TJmp - jump-off to transient
  3297                                  ;
  3298                                  ;	Public label so debugger can find this spot.
  3299                                  
  3300                                  TJmp:	; 12/01/2023
  3301 00000EA5 FF2E[9001]              	jmp	far [Trans]		; jmp dword ptr Trans
  3302                                  
  3303                                  ;***	TRemCheck - far version of RemCheck for transient
  3304                                  
  3305                                  TRemCheck:
  3306                                  	; 12/01/2023
  3307 00000EA9 1F                      	pop	ds			; ds = DATARES
  3308 00000EAA 83C402                  	add	sp,2			; discard old value of ds
  3309                                  
  3310 00000EAD E80100                  	call	RemCheck
  3311 00000EB0 CB                      	retf
  3312                                  
  3313                                  ;***	RemCheck
  3314                                  ;
  3315                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3316                                  ;
  3317                                  ;	EXIT	ZR set if removeable media
  3318                                  ;		ZR clear if fixed media
  3319                                  ;
  3320                                  ;	USED	none
  3321                                  
  3322                                  	; 12/01/2023
  3323                                  RemCheck:
  3324 00000EB1 50                      	push	ax
  3325 00000EB2 53                      	push	bx
  3326 00000EB3 89C3                    	mov	bx,ax
  3327 00000EB5 B80844                  	mov	ax,4408h
  3328                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3329 00000EB8 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3330 00000EBA 7304                    	jnc	short rcCont		
  3331                                  
  3332                                  ;	If an error occurred, assume the media is non-removable.
  3333                                  ;	AX contains the non-zero error code from the int 21, so
  3334                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3335                                  ;	appear to be non-removable.				
  3336                                  					
  3337 00000EBC 09C0                    	or	ax,ax			
  3338 00000EBE EB05                    	jmp	short ResRegs
  3339                                  rcCont:
  3340 00000EC0 83E001                  	and	ax,1
  3341 00000EC3 F7D0                    	not	ax
  3342                                  ResRegs:
  3343 00000EC5 5B                      	pop	bx
  3344 00000EC6 58                      	pop	ax
  3345 00000EC7 C3                      	retn
  3346                                  
  3347                                  ;***	THeadFix
  3348                                  ;
  3349                                  ;	Far version of HeadFix, called from transient.
  3350                                  
  3351                                  THeadFix:
  3352                                  	; 12/01/2023
  3353 00000EC8 1F                      	pop	ds			; ds = DATARES
  3354 00000EC9 83C402                  	add	sp,2			; discard old ds value on stack
  3355                                  
  3356 00000ECC E80100                  	call	HeadFix
  3357 00000ECF CB                      	retf
  3358                                  
  3359                                  ;***	HeadFix
  3360                                  
  3361                                  	; 12/01/2023
  3362                                  HeadFix:
  3363 00000ED0 E83101                  	call	SetVect			; set vectors to our values
  3364                                  
  3365                                  ;	Clean up header
  3366                                  
  3367                                  ;	Bugbug:	optimize:
  3368                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3369                                  
  3370 00000ED3 31DB                    	xor	bx,bx			; BX = handle = 0
  3371 00000ED5 8B0E[A201]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3372                                  	;mov	dx,[18h] 
  3373 00000ED9 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3374 00000EDD 38D1                    	cmp	cl,dl
  3375 00000EDF 7408                    	je	short Chk1		; stdin matches
  3376 00000EE1 B43E                    	mov	ah,3Eh
  3377                                  	;mov	ah,CLOSE  ; 3Eh
  3378 00000EE3 CD21                    	int	21h			; close stdin
  3379                                  	;mov	[18h],cl
  3380 00000EE5 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3381                                  Chk1:
  3382 00000EE9 43                      	inc	bx			; BX = handle = 1
  3383 00000EEA 38F5                    	cmp	ch,dh			
  3384 00000EEC 7408                    	je	short ChkOtherHand	; stdout matches
  3385 00000EEE B43E                    	mov	ah,3Eh
  3386                                  	;mov	ah,CLOSE
  3387 00000EF0 CD21                    	int	21h			; close stdout
  3388                                  	;mov	[19h],ch
  3389 00000EF2 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3390                                  ChkOtherHand:
  3391 00000EF6 83C304                  	add	bx,4			; skip handles 2,3,4
  3392 00000EF9 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3393                                  					; (handles 0-4 already done)
  3394                                  CloseLoop:
  3395 00000EFC B43E                    	mov	ah,3Eh
  3396                                  	;mov	ah,CLOSE ; 3Eh
  3397 00000EFE CD21                    	int	21h			; close each handle
  3398 00000F00 43                      	inc	bx			; BX = next handle
  3399 00000F01 E2F9                    	loop	CloseLoop
  3400                                  
  3401                                  	; MSDOS 6.0
  3402                                  ;	Bugbug:	since this is for transient code, move it there
  3403                                  	
  3404                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3405                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3406                                  
  3407                                  ;	M012: remove this CS -> DS. Must've been missed during
  3408                                  ;	purification.
  3409                                  ;;	push	ds			; save data segment
  3410                                  ;;	push	cs			; get local segment into DS
  3411                                  ;;	pop	ds			;
  3412 00000F03 803E[C501]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3413 00000F08 750E                    	jne	short Append_Fix_End	; no - just exit
  3414 00000F0A B807B7                  	mov	ax,0B707h
  3415                                  	;mov	ax,AppendSetState	; set the state of Append
  3416 00000F0D 8B1E[C301]              	mov	bx,[Append_State] 	; back to the original state
  3417 00000F11 CD2F                    	int	2Fh			;
  3418 00000F13 C606[C501]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3419                                  Append_Fix_End: 			;
  3420                                  ;;	pop	ds			; get data segment back
  3421 00000F18 C3                      	retn
  3422                                  
  3423                                  	; MSDOS 3.3
  3424                                  	;retn
  3425                                  
  3426                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3427                                  ;
  3428                                  ;	ENTRY	nothing
  3429                                  ;
  3430                                  ;	EXIT	nothing
  3431                                  ;
  3432                                  ;	USED	flags
  3433                                  ;
  3434                                  ;	EFFECTS
  3435                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3436                                  ;	  current program's stdin,stdout set to our stderr
  3437                                  ;
  3438                                  
  3439                                  ;SR;
  3440                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3441                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3442                                  
  3443                                  SavHand:
  3444                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3445                                  
  3446                                  	; 12/01/2023
  3447                                  	;push	ds ; MSDOS 3.3
  3448                                  
  3449 00000F19 53                      	push	bx			;preserve registers
  3450 00000F1A 50                      	push	ax
  3451                                  	; 12/01/2023
  3452 00000F1B 06                      	push	es
  3453 00000F1C 1E                      	push	ds			; save DATARES value
  3454                                  
  3455 00000F1D B451                    	mov	ah,51h
  3456                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3457 00000F1F CD21                    	int	21h			; BX = user's header seg addr
  3458 00000F21 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3459                                  	;lds	bx,[34h]	
  3460 00000F23 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3461 00000F27 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3462                                  	; 12/01/2023
  3463 00000F29 07                      	pop	es			; es = DATARES
  3464 00000F2A 06                      	push	es			; save it back on stack
  3465 00000F2B 26A3[4901]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3466                                  	;mov	[cs:HANDLE01],ax
  3467                                  
  3468                                  ;SR;
  3469                                  ; Use es to address Handle01 & our JFN_Table
  3470                                  
  3471                                  	; 12/01/2023
  3472                                  	;mov	al,[es:1Ah]
  3473 00000F2F 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3474                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3475 00000F33 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3476 00000F35 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3477                                  	; 12/01/2023
  3478 00000F37 1F                      	pop	ds			; restore registers
  3479 00000F38 07                      	pop	es
  3480 00000F39 58                      	pop	ax
  3481 00000F3A 5B                      	pop	bx
  3482                                  	;pop	ds ; MSDOS 3.3
  3483 00000F3B C3                      	retn
  3484                                  
  3485                                  	;assume	ds:DATARES
  3486                                  GetComDsk2:
  3487 00000F3C E81F00                  	call	GetComDsk
  3488 00000F3F E909FF                  	jmp	LodCom1			; memory already allocated
  3489                                  
  3490                                  RestHand:
  3491 00000F42 1E                      	push	ds
  3492 00000F43 53                      	push	bx			; restore stdin, stdout to user
  3493 00000F44 50                      	push	ax
  3494                                  	; 12/01/2023
  3495 00000F45 B451                    	mov	ah,51h
  3496                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3497 00000F47 CD21                    	int	21h			; point to user's header
  3498 00000F49 A1[4901]                	mov	ax,[Handle01]
  3499 00000F4C 8EDB                    	mov	ds,bx
  3500                                  	;assume ds:NOTHING
  3501                                  	;lds	bx,[34h] 
  3502 00000F4E C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3503 00000F52 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3504 00000F54 58                      	pop	ax
  3505 00000F55 5B                      	pop	bx
  3506 00000F56 1F                      	pop	ds
  3507 00000F57 C3                      	retn
  3508                                  
  3509                                  	;assume ds:DATARES,ss:DATARES
  3510                                  Hopeless:
  3511 00000F58 BA[DF04]                	mov	dx,COMBAD
  3512 00000F5B E9BEFD                  	jmp	FatalC
  3513                                  
  3514                                  GetComDsk:
  3515 00000F5E A0[9701]                	mov	al,[ComDrv]
  3516 00000F61 E84DFF                  	call	RemCheck
  3517 00000F64 75F2                    	jnz	short Hopeless		; non-removable media
  3518                                  GetComDsk3:
  3519 00000F66 81FA[DF04]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3520 00000F6A 7503                    	jne	short GetComDsk4
  3521                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3522                                  	; 12/01/2023
  3523                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3524                                  	;invoke	RPrint			; say COMMAND is invalid
  3525 00000F6C E82103                  	call	RPrint
  3526                                  	;call	RDISPMSG
  3527                                  
  3528                                  GetComDsk4:
  3529                                  
  3530                                  ;	Bugbug:	there's always a drive here? No need to check?
  3531                                  
  3532 00000F6F 803E[3201]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3533 00000F74 7509                    	jne	short Users_Drive	; yes - use it
  3534 00000F76 B419                    	mov	ah,19h
  3535                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3536 00000F78 CD21                    	int	21h
  3537 00000F7A 0441                    	add	al,"A"                  ; convert to ascii
  3538 00000F7C A2[3201]                	mov	[PutBackDrv],al		; put in message to print out
  3539                                  
  3540                                  Users_Drive:
  3541                                  	; 12/01/2023
  3542                                  	; MSDOS 6.0
  3543 00000F7F BA[F504]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3544                                  	;mov	si,offset DATARES:PutBackSubst
  3545                                  	;invoke	RPrint
  3546 00000F82 BE[2C01]                	mov	si,PutBackSubst		; containing COMMAND
  3547 00000F85 E80803                  	call	RPrint
  3548                                  	;mov	dx,offset DATARES:Prompt
  3549                                  	;invoke	RPrint
  3550 00000F88 BA[1705]                	mov	dx,PROMPT		; "Press any key"
  3551 00000F8B E80203                  	call	RPrint
  3552                                  
  3553                                  	; MSDOS 3.3
  3554                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3555                                  	;call	RDISPMSG
  3556                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3557                                  	;mov	si,[COMSPEC_END]
  3558                                  	;mov	byte [si+1],'$'
  3559                                  	;call	RDISPMSG
  3560                                  	;mov	byte [si+1],0
  3561                                  	;mov	dx,PROMPT
  3562                                  	;call	RDISPMSG
  3563                                  
  3564                                  	;call	GetRawFlushedByte
  3565                                  	;retn
  3566                                  	; 12/01/2023
  3567                                  	;jmp	short GetRawFlushedByte
  3568                                  
  3569                                  ;***	GetRawFlushedByte - flush world and get raw input
  3570                                  
  3571                                  GetRawFlushedByte:
  3572                                  	; 12/01/2023
  3573 00000F8E B8070C                  	mov	ax,0C07h
  3574                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3575 00000F91 CD21                    	int	21h			; get char without testing or echo
  3576 00000F93 B8000C                  	mov	ax,0C00h
  3577                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3578 00000F96 CD21                    	int	21h
  3579                                  
  3580                                  ;	Bugbug:	get rid of this return and the following retz.
  3581                                  
  3582                                  LoadCom_retn:
  3583 00000F98 C3                      	retn
  3584                                  
  3585                                  	; 21/04/2023
  3586                                  TryDoOpen:
  3587 00000F99 E8C2FF                  	call	GetComDsk
  3588                                  	;jmp	short LoadCom
  3589                                  
  3590                                  ;***	LoadCom - load in transient
  3591                                  
  3592                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3593                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3594                                  
  3595                                  LoadCom:
  3596                                  	;assume	ds:DATARES
  3597                                  	
  3598 00000F9C 45                      	inc	bp				; flag command read
  3599                                  
  3600 00000F9D BA[4E01]                	mov	dx,ComSpec
  3601 00000FA0 B8003D                  	mov	ax,3D00h
  3602                                  	;mov	ax,OPEN<<8	; 3D00h
  3603 00000FA3 CD21                    	int	21h				; open command.com
  3604 00000FA5 730B                    	jnc	short ReadCom
  3605                                  	;cmp	ax,4
  3606 00000FA7 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3607 00000FAA 75ED                    	jnz	short TryDoOpen
  3608 00000FAC BA[A105]                	mov	dx,NOHANDMES
  3609 00000FAF E96AFD                  	jmp	FatalC				; will never find a handle
  3610                                  
  3611                                  	; 21/04/2023
  3612                                  ;TryDoOpen:
  3613                                  	;call	GetComDsk
  3614                                  	;jmp	short LoadCom
  3615                                  
  3616                                  ReadCom:
  3617 00000FB2 89C3                    	mov	bx,ax				; BX = handle
  3618                                  	;mov	dx,offset RESGROUP:TranStart
  3619 00000FB4 BA3022                  	mov	dx,TRANSTART
  3620 00000FB7 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3621 00000FB9 B80042                  	mov	ax,4200h
  3622                                  	;mov	ax,LSEEK<<8	; 4200h
  3623 00000FBC CD21                    	int	21h
  3624 00000FBE 7210                    	jc	short WrongCom1
  3625                                  	; 12/01/2023
  3626                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3627                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3628 00000FC0 B90F95                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3629 00000FC3 1E                      	push	ds
  3630 00000FC4 8E1E[9201]              	mov	ds,[TrnSeg]
  3631                                  	;assume	ds:NOTHING
  3632 00000FC8 BA0001                  	mov	dx,100h
  3633 00000FCB B43F                    	mov	ah,3Fh
  3634                                  	;mov	ah,READ	; 3Fh	
  3635 00000FCD CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3636                                  			; BX = file handle, CX = number of bytes to read
  3637                                  			; DS:DX -> buffer
  3638 00000FCF 1F                      	pop	ds
  3639                                  	;assume	ds:DATARES
  3640                                  WrongCom1:
  3641 00000FD0 9C                      	pushf
  3642 00000FD1 50                      	push	ax
  3643 00000FD2 B43E                    	mov	ah,3Eh
  3644                                  	;mov	ah,CLOSE ; 3Eh
  3645 00000FD4 CD21                    	int	21h			; close command.com
  3646 00000FD6 58                      	pop	ax
  3647 00000FD7 9D                      	popf
  3648 00000FD8 7204                    	jc	short WrongCom		; error on read
  3649 00000FDA 39C8                    	cmp	ax,cx
  3650                                  	;retz				; size matched
  3651 00000FDC 74BA                    	jz	short LoadCom_retn
  3652                                  WrongCom:
  3653 00000FDE BA[DF04]                	mov	dx,COMBAD
  3654 00000FE1 E87AFF                  	call	GetComDsk
  3655 00000FE4 EBB6                    	jmp	short LoadCom		; try again
  3656                                  
  3657                                  ;***	ChkSum - compute transient checksum
  3658                                  
  3659                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3660                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3661                                  ChkSum:
  3662 00000FE6 1E                      	push	ds
  3663 00000FE7 8E1E[9201]              	mov	ds,[TrnSeg]
  3664 00000FEB BE0001                  	mov	si,100h
  3665                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3666                                  	;mov	cx,87C2h
  3667 00000FEE B9[0B85]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3668                                  Check_Sum:
  3669 00000FF1 FC                      	cld
  3670 00000FF2 D1E9                    	shr	cx,1
  3671 00000FF4 31D2                    	xor	dx,dx
  3672                                  Chk:
  3673 00000FF6 AD                      	lodsw
  3674 00000FF7 01C2                    	add	dx,ax
  3675 00000FF9 83D200                  	adc	dx,0
  3676 00000FFC E2F8                    	loop	Chk
  3677                                  
  3678                                  	; 04/05/2023
  3679 00000FFE 1F                      	pop	ds
  3680                                  
  3681                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3682 00000FFF 3B16[9A01]              	cmp	dx,[Sum]
  3683                                  
  3684                                  	;pop	ds ; 04/05/2023
  3685 00001003 C3                      	retn
  3686                                  
  3687                                  ;***	SetVect - set interrupt vectors
  3688                                  
  3689                                  SetVect:
  3690                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3691                                  	; 12/01/2023
  3692 00001004 BA[7E00]                	mov	dx,LodCom_Trap
  3693                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3694 00001007 B82225                  	mov	ax,2522h
  3695                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3696 0000100A 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3697 0000100E 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3698 00001012 CD21                    	int	21h
  3699                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3700 00001014 BA[4A00]                	mov	dx,Ctrlc_Trap
  3701                                  	;mov	dx,CONTC ; MSDOS 3.3
  3702 00001017 FEC0                    	inc	al	; 23h
  3703 00001019 CD21                    	int	21h
  3704                                  	;mov	dx,offset DATARES:CritErr_Trap
  3705 0000101B BA[5500]                	mov	dx,CritErr_Trap
  3706                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3707 0000101E FEC0                    	inc	al	; 24h
  3708 00001020 CD21                    	int	21h
  3709 00001022 C3                      	retn
  3710                                  
  3711                                  	; MSDOS 6.0
  3712                                  ;;SR;
  3713                                  ;We have this to take care of the extra values pushed on the stack by 
  3714                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3715                                  ;Lodcom1
  3716                                  
  3717                                  ;public	TrnLodCom1
  3718                                  	; 12/01/2023
  3719                                  TrnLodCom1:
  3720 00001023 1F                      	pop	ds			; ds = DATARES
  3721 00001024 83C402                  	add	sp,2
  3722                                  ;	pop	ds:OldDS
  3723 00001027 E921FE                  	jmp	LodCom1
  3724                                  
  3725                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3726                                  
  3727                                  %if 0
  3728                                  
  3729                                  ;***	EndInit - end up initialization sequence
  3730                                  ;
  3731                                  ;	Move the environment to a newly allocated segment.
  3732                                  
  3733                                  	; MSDOS 3.3
  3734                                  ENDINIT:
  3735                                  	push	ds			; save segments
  3736                                  	push	es			;
  3737                                  	push	cs			; get resident segment to DS
  3738                                  	pop	ds			;
  3739                                  	;assume	ds:RESGROUP
  3740                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3741                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3742                                  	;assume	es:NOTHING
  3743                                  
  3744                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3745                                  	jne	short NO_RESET 		; no - we already did it
  3746                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3747                                  	push	es			; save environment - just to be sure
  3748                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3749                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3750                                  				; ES = segment address of block to change
  3751                                  				; BX = new size in paragraphs
  3752                                  	pop	es
  3753                                  
  3754                                  NO_RESET:
  3755                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3756                                  	mov	ds,[OLDENV]		; source environment segment
  3757                                  	;assume	ds:NOTHING
  3758                                  	xor	si,si			; set up offsets to start of segments
  3759                                  	xor	di,di
  3760                                  	cld
  3761                                  	rep	movsb			; move it
  3762                                  	xor	ax,ax
  3763                                  	stosb				; make sure it ends with double-null
  3764                                  
  3765                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3766                                  	pop	es
  3767                                  	pop	ds
  3768                                  	jmp	LODCOM			; allocate transient
  3769                                  
  3770                                  	; MSDOS 6.0
  3771                                  
  3772                                  ;The init code has been changed to take care of the new way in which the
  3773                                  ;environment segment is allocated.
  3774                                  ;NB: We can use all the init variables at this point because they are all in
  3775                                  ;RESGROUP
  3776                                  ;Bugbug: The above approach will not work for ROMDOS
  3777                                  
  3778                                  ;IF 0
  3779                                  ;
  3780                                  ;EndInit:
  3781                                  ;	push	ds
  3782                                  ;	push	es			;save segments
  3783                                  ;	push	cs
  3784                                  ;	pop	ds		
  3785                                  ;	assume	ds:RESGROUP
  3786                                  ;;
  3787                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3788                                  ;;
  3789                                  ;	mov	bx,ds
  3790                                  ;	mov	es,bx			;es = RESGROUP
  3791                                  ;;
  3792                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3793                                  ;; code + data for low COMMAND
  3794                                  ;;
  3795                                  ;	mov	bx,ResSize		;Total size of resident
  3796                                  ;	mov	ah,SETBLOCK
  3797                                  ;	int	21h			;Set block to resident size
  3798                                  ;;
  3799                                  ;;Allocate the correct size for the environment
  3800                                  ;;
  3801                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3802                                  ;	mov	ah,ALLOC
  3803                                  ;	int	21h			;get memory
  3804                                  ;	jc	nomem_err		;out of memory,signal error
  3805                                  ;
  3806                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3807                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3808                                  ;	mov	es,ax			;es = address of allocated memory
  3809                                  ;	assume	es:nothing
  3810                                  ;
  3811                                  ;;
  3812                                  ;;Copy the environment to the newly allocated segment
  3813                                  ;;
  3814                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3815                                  ;
  3816                                  ;	push	ds
  3817                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3818                                  ;	assume	ds:nothing
  3819                                  ;
  3820                                  ;	xor	si,si
  3821                                  ;	mov	di,si			;Start transfer from 0
  3822                                  ;
  3823                                  ;	cld
  3824                                  ;	rep	movsb			;Do the copy
  3825                                  ;
  3826                                  ;	xor	ax,ax			
  3827                                  ;	stosb				;Make it end with double-null
  3828                                  ;
  3829                                  ;	pop	ds			;ds = RESGROUP
  3830                                  ;	assume	ds:RESGROUP
  3831                                  ;;
  3832                                  ;;We have to free the old environment block if it was allocated by INIT
  3833                                  ;;
  3834                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3835                                  ;	je      no_free                 ;no, do not free it
  3836                                  ;
  3837                                  ;	mov	ax,OldEnv		;Get old environment
  3838                                  ;	mov	es,ax
  3839                                  ;	mov	ah,DEALLOC	
  3840                                  ;	int	21h			;Free it
  3841                                  ;no_free:
  3842                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3843                                  ;	
  3844                                  ;	pop	es
  3845                                  ;	pop	ds
  3846                                  ;	assume	ds:nothing
  3847                                  ;	
  3848                                  ;	jmp	LodCom			;allocate transient
  3849                                  ;
  3850                                  ;nomem_err:
  3851                                  ;;
  3852                                  ;;We call the error routine which will never return. It will either exit
  3853                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3854                                  ;;message ( if first COMMAND )
  3855                                  ;;
  3856                                  ;
  3857                                  ;	call	Alloc_error
  3858                                  ;ENDIF
  3859                                  ;
  3860                                  ;CODERES ends
  3861                                  
  3862                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3863                                  ;	the resident group which is the location where the transient
  3864                                  ;	segments will be loaded initial.
  3865                                  
  3866                                  ;TAIL		segment public para
  3867                                  ;
  3868                                  ;		org	0
  3869                                  ;TranStart	label	word
  3870                                  ;		public	TranStart
  3871                                  ;
  3872                                  ;TAIL		ends
  3873                                  ;
  3874                                  
  3875                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3876                                  ;	the transient group which is the location where the exec
  3877                                  ;	segments will be loaded initial.
  3878                                  ;
  3879                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3880                                  
  3881                                  ;TRANTAIL	segment public para
  3882                                  ;
  3883                                  ;		org	0
  3884                                  ;ExecStart   	label   word
  3885                                  ;
  3886                                  ;TRANTAIL    	ends
  3887                                  
  3888                                  %endif ; 12/01/2023
  3889                                  
  3890                                  ;=============================================================================
  3891                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3892                                  ;=============================================================================
  3893                                  ; 22/09/2018 - Retro DOS v3.0
  3894                                  
  3895                                  ;	title	Localizable code for resident COMMAND
  3896                                  
  3897                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3898                                  
  3899                                  ; ----------------------------------------------------------------------------
  3900                                  ;***	AskEnd - ask user to confirm batch file termination
  3901                                  ;
  3902                                  ;	Confirm with user before freeing batch ...
  3903                                  ;
  3904                                  ;	ENTRY	nothing
  3905                                  ;
  3906                                  ;	EXIT	CY = set if batch termination is confirmed
  3907                                  ;
  3908                                  ;		CY = clear if batch should continue
  3909                                  ;
  3910                                  ;	USED	AX,DX,...
  3911                                  ;
  3912                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3913                                  ;	Bugbug:	or move it to command1 1st.
  3914                                  ;
  3915                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3916                                  ; ----------------------------------------------------------------------------
  3917                                  
  3918                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3919                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3920                                  
  3921                                  AskEnd:
  3922                                  	;assume	ds:DATARES
  3923                                  
  3924 0000102A BA[3905]                	mov	dx,ENDBATMES			; DX = message #
  3925 0000102D E86002                  	call	RPrint
  3926                                  	;call	RDISPMSG  ; MSDOS 3.3
  3927 00001030 B8010C                  	mov	ax,0C01h
  3928                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3929 00001033 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3930                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  3931 00001035 E8F102                  	call	CharToUpper			; change to upper case
  3932 00001038 3A06[4004]              	cmp	al,[NO_CHAR]
  3933 0000103C 7407                    	je	short aeRet			; answer is no (CY is clear)
  3934 0000103E 3A06[3F04]              	cmp	al,[YES_CHAR]
  3935 00001042 75E6                    	jne	short AskEnd			; invalid response, try again
  3936 00001044 F9                      	stc					; answer is yes
  3937                                  aeRet:	
  3938 00001045 C3                      	retn
  3939                                  
  3940                                  ; ----------------------------------------------------------------------------
  3941                                  ;***	DskErr - critical error handler
  3942                                  ;
  3943                                  ;	Default critical error handler unless user intercepts int 24h.
  3944                                  ;
  3945                                  ;	ENTRY	int 24h
  3946                                  ;
  3947                                  ;	EXIT
  3948                                  ;
  3949                                  ;	USED
  3950                                  ;
  3951                                  ;	EFFECTS
  3952                                  ; ----------------------------------------------------------------------------
  3953                                  
  3954                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3955                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  3956                                  
  3957                                  ;SR; 
  3958                                  ;The stub is going to push the old ds value and the resident data segment
  3959                                  ;onto the stack in that order. Get it off the stack
  3960                                  
  3961                                  ;DskErr	proc	far
  3962                                  DSKERR:
  3963                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3964                                  	; 12/01/2023
  3965 00001046 1F                      	pop	ds			; ds = DATARES
  3966                                  	;assume ds:DATARES
  3967 00001047 8F06[3804]              	pop	word [OldDS]		; save old ds value
  3968                                  
  3969                                  ;CRITERR: ; MSDOS 3.3
  3970 0000104B FB                      	sti
  3971                                  	; 12/01/2023
  3972                                  	;push	ds ; 25/09/2018
  3973 0000104C 06                      	push	es
  3974 0000104D 56                      	push	si
  3975 0000104E 51                      	push	cx
  3976 0000104F 57                      	push	di
  3977 00001050 51                      	push	cx
  3978 00001051 50                      	push	ax
  3979                                  
  3980 00001052 1E                      	push	ds			;save our data segment
  3981                                  	;push	cs ; 25/09/2018
  3982 00001053 07                      	pop	es			;es = DATARES
  3983                                  
  3984 00001054 8EDD                    	mov	ds,bp
  3985                                  	;assume	ds:nothing
  3986                                  
  3987                                  	;mov	ax,[si].SDEVATT
  3988 00001056 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  3989 00001059 268826[2801]            	mov	[es:CDevAt],ah
  3990                                  
  3991                                  	;push	cs
  3992                                  	;pop	es
  3993                                  
  3994 0000105E BF[0601]                	mov	di,DevName
  3995 00001061 B90800                  	mov	cx,8
  3996                                  	;add	si,SDEVNAME  ; add si,10
  3997 00001064 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  3998                                  				
  3999 00001067 FC                      	cld
  4000 00001068 F3A4                    	rep	movsb
  4001 0000106A 58                      	pop	ax
  4002 0000106B 59                      	pop	cx
  4003 0000106C 5F                      	pop	di
  4004                                  
  4005                                  ;	Stack still contains DS and ES.
  4006                                  
  4007                                  ;SR;
  4008                                  ;We need ds = DATARES for SavHand
  4009                                  
  4010                                  	 ;12/01/2023
  4011 0000106D 06                      	push	es
  4012 0000106E 1F                      	pop	ds
  4013                                  	;assume	ds:DATARES
  4014                                  
  4015                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4016 0000106F E8A7FE                  	call	SavHand
  4017                                  
  4018                                  	; 12/01/2023
  4019                                  	; 25/09/2018
  4020                                  	;;push	cs
  4021                                  	;push	es
  4022                                  	;pop	ds		; set up local data segment
  4023                                  	;assume	ds:resgroup
  4024                                  
  4025 00001072 52                      	push	dx
  4026 00001073 E81702                  	call	crlf
  4027 00001076 5A                      	pop	dx
  4028                                  
  4029                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4030                                  
  4031 00001077 8826[9F01]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4032                                  
  4033                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4034                                  
  4035 0000107B 0441                    	add	al,'A'
  4036 0000107D A2[FF00]                	mov	[DrvLet],al
  4037                                  
  4038                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4039                                  
  4040 00001080 F6C480                  	test	ah,80h
  4041 00001083 740A                    	jz	short NoHardE		; it's a disk-device error
  4042 00001085 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4043 0000108A 7503                    	jnz	short NoHardE		; it's a character device
  4044 0000108C E9F101                  	jmp	FatErr			; it's a FAT error
  4045                                  
  4046                                  NoHardE:
  4047 0000108F BE[6104]                	mov	si,MREAD		; SI = "read" msg #
  4048 00001092 F6C401                  	test	ah,1
  4049 00001095 7403                    	jz	short SavMes		; it's a read error
  4050 00001097 BE[6A04]                	mov	si,MWRITE		; SI = "write" msg #
  4051                                  SavMes:
  4052 0000109A 893E[6103]              	mov	[OldErrNo],di		; save critical error code
  4053                                  
  4054                                  ;	Bugbug:	don't need to save/restore all here?
  4055                                  
  4056 0000109E 06                      	push	es
  4057 0000109F 1E                      	push	ds			; GetExtendedError likes to STOMP
  4058                                  	; 12/01/2023
  4059                                  	; (all registers are changed -in dos service- except bp) *
  4060                                  	;push	bp
  4061 000010A0 56                      	push	si
  4062 000010A1 52                      	push	dx
  4063 000010A2 51                      	push	cx
  4064 000010A3 53                      	push	bx
  4065 000010A4 B459                    	mov	ah,59h ; * ; 05/06/2023 (BugFix)
  4066                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4067 000010A6 CD21                    	int	21h
  4068 000010A8 5B                      	pop	bx
  4069 000010A9 59                      	pop	cx
  4070 000010AA 5A                      	pop	dx
  4071 000010AB 5E                      	pop	si
  4072                                  	; 12/01/2023
  4073                                  	;pop	bp
  4074 000010AC 1F                      	pop	ds
  4075 000010AD 893E[3601]              	mov	[NeedVol],di		; save possible ptr to volume label
  4076 000010B1 8C06[3801]              	mov	[NeedVol+2],es
  4077 000010B5 07                      	pop	es
  4078                                  
  4079                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4080                                  
  4081 000010B6 30E4                    	xor	ah,ah
  4082 000010B8 89C7                    	mov	di,ax			; DI = error code
  4083                                  
  4084                                  ; Bugbug: somewhat obsolete documentation?
  4085                                  ;
  4086                                  ; DI is now the correct error code. Classify things to see what we are
  4087                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4088                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4089                                  ; the like) are contiguous.
  4090                                  
  4091                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4092                                  ;	Check use of ErrCd_24, though.
  4093                                  
  4094 000010BA 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4095 000010BD 7303                    	jae	short HavCod
  4096                                  
  4097                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4098                                  ;	even though it's not a critical error?
  4099                                  
  4100 000010BF BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4101                                  
  4102                                  ; DI now has the mapped error code. Old style errors are:
  4103                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4104                                  ; New style errors are:
  4105                                  ;   FOOBAR
  4106                                  ; We need to figure out which the particular error belongs to.
  4107                                  
  4108                                  HavCod:
  4109 000010C2 C606[3A01]00            	mov	byte [ErrType],0	; assume old style
  4110 000010C7 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4111 000010CA 7405                    	je	short SetStyle
  4112 000010CC 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4113 000010CF 7504                    	jne	short GotStyle
  4114                                  
  4115                                  SetStyle:
  4116                                  ;	Bugbug:	use INC
  4117                                  	;mov	byte [ErrType],1		; must be new type
  4118 000010D1 FE06[3A01]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4119                                  
  4120                                  GotStyle:
  4121 000010D5 893E[4701]              	mov	[ErrCd_24],di
  4122                                  	; 12/01/2023
  4123                                  	; 25/09/2018
  4124                                  	; MSDOS 6.0
  4125 000010D9 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4126                                  	; MSDOS 3.3
  4127                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4128                                  
  4129                                  						; If the error message is unknown
  4130 000010DC 7642                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4131                                  
  4132                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4133                                  ; how to handle things
  4134                                  
  4135                                  ;input to IFSFUNC:    AL=1
  4136                                  ;		      BX=extended error number
  4137                                  ;
  4138                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4139                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4140                                  ;			   Abort, Retry, Ignore
  4141                                  ;			 1=<message>
  4142                                  ;			   Abort, Retry, Ignore
  4143                                  ;		      ES:DI=pointer to message text
  4144                                  ;		      carry set=>no message
  4145                                  
  4146 000010DE 89C7                    	mov	di,ax			; retrieve correct extended error...
  4147 000010E0 B80005                  	mov	ax,0500h		; is the redir there?
  4148 000010E3 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4149                                  			; Return: AL = 00h not installed, OK to install
  4150                                  			; 01h not installed, can't install
  4151                                  			; FFh installed
  4152 000010E5 3CFF                    	cmp	al,0FFh
  4153 000010E7 752A                    	jne	short NoHandler		; no, go to NoHandler
  4154                                  
  4155                                  	; 12/01/2023
  4156                                  	; MSDOS 6.0
  4157 000010E9 53                      	push	bx
  4158 000010EA 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4159 000010EC B80105                  	mov	ax,0501h
  4160 000010EF CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4161 000010F1 5B                      	pop	bx 
  4162 000010F2 721F                    	jc	short NoHandler
  4163                                  	
  4164                                  	; MSDOS 3.3
  4165                                  	;mov     ax,di
  4166                                  	;mov     ah,5
  4167                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4168                                  	;jc      short NOHANDLER
  4169                                  
  4170                                  ;	Bugbug:	need to record error type?
  4171                                  
  4172 000010F4 A2[3A01]                	mov	[ErrType],al
  4173                                  
  4174 000010F7 1E                      	push	ds
  4175 000010F8 06                      	push	es
  4176 000010F9 1F                      	pop	ds
  4177 000010FA 89FA                    	mov	dx,di
  4178 000010FC B9FFFF                  	mov	cx,-1			; find end of msg
  4179 000010FF 30C0                    	xor	al,al
  4180                                  
  4181 00001101 FC                      	cld
  4182 00001102 F2AE                    	repnz	scasb
  4183                                  
  4184                                  ;	Bugbug:	we can do better than this.
  4185                                  
  4186 00001104 C645FF24                	mov	byte [di-1],'$'
  4187                                  	
  4188                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4189                                  	
  4190 00001108 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4191 0000110A CD21                    	int	21h
  4192                                  
  4193 0000110C C645FF00                	mov	byte [di-1],0			; restore terminal byte
  4194                                  
  4195 00001110 1F                      	pop	ds				; clean up and continue
  4196 00001111 EB15                    	jmp	short CheckErrType
  4197                                  
  4198                                  ;*	Redir isn't available or doesn't recognize the error.
  4199                                  ;	Restore regs to unextended error.
  4200                                  
  4201                                  NoHandler:
  4202 00001113 C606[3A01]00            	mov	byte [ErrType],0
  4203                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4204 00001118 8B3E[6103]              	mov	di,[OldErrNo]
  4205 0000111C 893E[4701]              	mov	[ErrCd_24],di
  4206                                  
  4207                                  NormalError:
  4208                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4209                                  	; MSDOS 6.0
  4210 00001120 83C713                  	add	di,ERROR_WRITE_PROTECT
  4211 00001123 87FA                    	xchg	di,dx			; may need dx later
  4212 00001125 E88101                  	call	RPrintCrit		; print error type
  4213                                  
  4214                                  	; MSDOS 3.3
  4215                                  	;shl     di,1
  4216                                  	;mov     di,[CRMSGTBL+di]
  4217                                  	;xchg    di,dx
  4218                                  	;call    RDISPMSG
  4219                                  
  4220                                  CheckErrType:
  4221 00001128 803E[3A01]00            	cmp	byte [ErrType],0	; Check error style...
  4222 0000112D 7405                    	je	short ContOld
  4223 0000112F E85B01                  	call	crlf			; if new style then done printing
  4224 00001132 EB31                    	jmp	short Ask
  4225                                  
  4226                                  ContOld:
  4227                                  	; 12/01/2023
  4228                                  	; MSDOS 6.0
  4229 00001134 46                      	inc	si			; DS:SI = ptr to asciiz string
  4230                                  
  4231                                  ;	Bugbug:	combine some of the following two sections?
  4232                                  
  4233                                  	; 12/01/2023
  4234 00001135 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4235                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4236 0000113A 740F                    	jz	short BlkErr
  4237                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4238                                  	;mov	dx,ChardevErr
  4239 0000113C BA[8204]                	mov	dx,MDEVICE
  4240                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4241 0000113F 8936[0101]              	mov	[CharDevErrRw],si
  4242                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4243 00001143 BE[0001]                	mov	si,CharDevErrSubst
  4244                                  
  4245 00001146 E84701                  	call	RPrint				; print the message
  4246 00001149 EB1A                    	jmp	short Ask			; don't ralph on command
  4247                                  
  4248                                  	; 12/01/2023
  4249                                  	; MSDOS 3.3
  4250                                  	;mov	dx,ERRMES
  4251                                  	;call	RDISPMSG
  4252                                  	;mov	dx,si
  4253                                  	;call	RDISPMSG
  4254                                  	;
  4255                                  	;test	byte [CDevAt],80h
  4256                                  	;jz	short BLKERR
  4257                                  	;mov	dx,CHARDEVERR	; " device "
  4258                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4259                                  	;int	21h		; DOS - PRINT STRING
  4260                                  	;			; DS:DX -> string terminated by "$"
  4261                                  	;jmp	short ASK
  4262                                  
  4263                                  BlkErr:
  4264                                  	; 12/01/2023
  4265                                  	; MSDOS 6.0
  4266                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4267                                  	;mov	dx,BlkDevErr
  4268 0000114B BA[7304]                	mov	dx,MDRIVE
  4269                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4270 0000114E 8936[FA00]              	mov	[BlkDevErrRw],si
  4271                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4272 00001152 BE[F900]                	mov	si,BlkDevErrSubst
  4273 00001155 E83801                  	call	RPrint
  4274                                  
  4275                                  	; MSDOS 3.3
  4276                                  	;mov	dx,BLKDEVERR
  4277                                  	;call	RDISPMSG
  4278                                  
  4279 00001158 803E[4B01]00            	cmp	byte [Loading],0
  4280 0000115D 7406                    	jz	short Ask
  4281 0000115F E8E0FD                  	call	RestHand
  4282 00001162 E9D7FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4283                                  Ask:
  4284 00001165 833E[4701]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4285 0000116A 751E                    	jne	short Not15		; not error 15
  4286                                  
  4287                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4288                                  
  4289 0000116C 51                      	push	cx
  4290                                  
  4291                                  ;	Bugbug:	does this push/pop need to be done?
  4292                                  
  4293 0000116D 1E                      	push	ds
  4294 0000116E 07                      	pop	es
  4295 0000116F C536[3601]              	lds	si,[NeedVol]
  4296                                  	;assume	ds:NOTHING
  4297 00001173 57                      	push	di
  4298 00001174 BF[1801]                	mov	di,VolName
  4299                                  	; 12/01/2023
  4300                                  	; MSDOS 6.0
  4301 00001177 B91000                  	mov	cx,16			; copy volume name & serial #
  4302                                  	; MSDOS 3.3
  4303                                  	;mov	cx,11			; copy volume name
  4304 0000117A FC                      	cld
  4305 0000117B F3A4                    	rep	movsb
  4306 0000117D 5F                      	pop	di
  4307 0000117E 06                      	push	es
  4308 0000117F 1F                      	pop	ds
  4309 00001180 59                      	pop	cx
  4310                                  	;assume	ds:DATARES
  4311                                  	; 12/01/2023
  4312                                  	; MSDOS 6.0
  4313                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4314                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4315                                  	;mov	dx,NeedVolMsg
  4316 00001181 BA[9204]                	mov	dx,MVOLSERIAL
  4317 00001184 BE[0F01]                	mov	si,NeedVolSubst
  4318 00001187 E80601                  	call	RPrint
  4319                                  
  4320                                  	; MSDOS 3.3
  4321                                  	;mov	dx,NEEDVOLMSG
  4322                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4323                                  	;int	21h		; DOS - PRINT STRING
  4324                                  	;			; DS:DX -> string terminated by "$"
  4325                                  Not15:
  4326                                  ;*	Print abort, retry, ignore, fail message.
  4327                                  ;	Print only options that are valid.
  4328                                  
  4329                                  ;	Bugbug:	sizzle this.
  4330                                  
  4331                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4332 0000118A BA[4104]                	mov	dx,REQ_ABORT
  4333 0000118D E80001                  	call	RPrint
  4334                                  	;call	RDISPMSG
  4335 00001190 F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4336 00001195 7406                    	jz	short Try_Ignore
  4337 00001197 BA[4704]                	mov	dx,REQ_RETRY
  4338 0000119A E8F300                  	call	RPrint
  4339                                  	;call	RDISPMSG
  4340                                  Try_Ignore:
  4341 0000119D F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4342 000011A2 7406                    	jz	short Try_Fail
  4343 000011A4 BA[4F04]                	mov	dx,REQ_IGNORE
  4344 000011A7 E8E600                  	call	RPrint
  4345                                  	;call	RDISPMSG
  4346                                  Try_Fail:
  4347 000011AA F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4348 000011AF 7406                    	jz	short Term_Question
  4349 000011B1 BA[5804]                	mov	dx,REQ_FAIL
  4350 000011B4 E8D900                  	call	RPrint
  4351                                  	;call	RDISPMSG
  4352                                  Term_Question:
  4353 000011B7 BA[5F04]                	mov	dx,REQ_END
  4354 000011BA E8D300                  	call	RPrint
  4355                                  	;call	RDISPMSG
  4356                                  
  4357                                  ;	If the /f switch was given, we fail all requests.
  4358                                  
  4359 000011BD F606[AA01]FF            	test	byte [fFail],-1
  4360 000011C2 741B                    	jz	short DoPrompt
  4361 000011C4 B403                    	mov	ah,3				; signal fail
  4362 000011C6 E9A800                  	jmp	EExit
  4363                                  
  4364                                  	; 16/04/2023
  4365                                  Abort_Process:
  4366 000011C9 F606[1702]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4367 000011CE 745D                    	jz	short AbortCont			; no, handle it normally
  4368 000011D0 803E[A501]00            	cmp	byte [PermCom],0		; are we top level process?
  4369 000011D5 744B                    	jz	short JustExit			; yes, just exit
  4370                                  
  4371 000011D7 BA[4506]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4372                                  	; 12/01/2023
  4373 000011DA E8B300                  	call	RPrint				; print it
  4374                                  	;call	RDISPMSG
  4375                                  DeadInTheWater:
  4376 000011DD EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4377                                  
  4378                                  DoPrompt:
  4379                                  	; 12/01/2023
  4380 000011DF B8010C                  	mov	ax,0C01h
  4381                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4382 000011E2 CD21                    	int	21h				; get response
  4383                                  
  4384 000011E4 E8A600                  	call	crlf
  4385 000011E7 E83F01                  	call	CharToUpper			; convert to upper case
  4386 000011EA B400                    	mov	ah,0				; return code for ignore
  4387 000011EC F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4388 000011F1 7406                    	jz	short User_Retry
  4389 000011F3 3A06[3D04]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4390                                  	;jz	short EExitJ
  4391                                  	; 16/04/2023
  4392 000011F7 7478                    	jz	short EExit
  4393                                  
  4394                                  ;	Bugbug:	optimize following code.
  4395                                  
  4396                                  User_Retry:
  4397 000011F9 FEC4                    	inc	ah				; return code for retry
  4398 000011FB F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4399 00001200 7406                    	jz	short User_Abort
  4400 00001202 3A06[3C04]              	cmp	al,[RETRY_CHAR]			; retry?
  4401                                  	;jz	short EExitJ
  4402                                  	; 16/04/2023
  4403 00001206 7469                    	jz	short EExit
  4404                                  User_Abort:
  4405 00001208 FEC4                    	inc	ah				; return code for abort
  4406                                  						;  (abort always allowed)
  4407 0000120A 3A06[3B04]              	cmp	al,[ABORT_CHAR]			; abort?
  4408 0000120E 74B9                    	jz	short Abort_Process		; exit user program
  4409 00001210 FEC4                    	inc	ah				; return code for fail
  4410 00001212 F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4411 00001217 7406                    	jz	short AskJ
  4412 00001219 3A06[3E04]              	cmp	al,[FAIL_CHAR]			; fail?
  4413                                  	;jz	short EExitJ
  4414                                  	; 16/04/2023
  4415 0000121D 7452                    	jz	short EExit
  4416                                  AskJ:
  4417 0000121F E943FF                  	jmp	Ask
  4418                                  
  4419                                  	; 12/01/2023
  4420                                  ;EExitJ:
  4421                                  	;jmp	short EExit
  4422                                  
  4423                                  JustExit:
  4424                                  	;assume	ds:DATARES
  4425                                  	; 12/01/2023
  4426 00001222 A1[4101]                	mov	ax,[Parent]			; load real parent pid
  4427                                  	;mov	[16h],ax
  4428 00001225 A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4429 00001228 B8FF4C                  	mov	ax,4CFFh
  4430                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4431 0000122B CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4432                                  				; AL = exit code
  4433                                  AbortCont:
  4434 0000122D F606[9501]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4435 00001232 7405                    	jz	short Not_Batch_Abort
  4436 00001234 C606[9601]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4437                                  
  4438                                  Not_Batch_Abort:
  4439 00001239 8A16[1802]              	mov	dl,[PipeFlag]
  4440 0000123D E8C8FA                  	call	ResPipeOff
  4441 00001240 08D2                    	or	dl,dl
  4442 00001242 740D                    	je	short CheckForA
  4443 00001244 833E[A601]00            	cmp	word [SingleCom],0
  4444 00001249 7406                    	je	short CheckForA
  4445 0000124B C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4446                                  
  4447                                  CheckForA:
  4448 00001251 833E[4701]00            	cmp	word [ErrCd_24],0		; write protect?
  4449 00001256 7407                    	je	short abortfor
  4450 00001258 833E[4701]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4451 0000125D 7512                    	jne	short EExit			; don't abort the FOR
  4452                                  
  4453                                  abortfor:
  4454 0000125F C606[AC01]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4455 00001264 833E[A601]00            	cmp	word [SingleCom],0
  4456 00001269 7406                    	je	short EExit
  4457 0000126B C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4458                                  
  4459                                  EExit:
  4460 00001271 88E0                    	mov	al,ah
  4461 00001273 89FA                    	mov	dx,di
  4462                                  RestHd:
  4463 00001275 E8CAFC                  	call    RestHand
  4464 00001278 59                      	pop	cx
  4465 00001279 5E                      	pop	si				; restore registers
  4466 0000127A 07                      	pop	es
  4467                                  
  4468                                  	; 12/01/2023	
  4469                                  	; MSDOS 6.0
  4470                                  ;;	pop	ds
  4471                                  ;SR;
  4472                                  ;ds has to be got from the variable we saved it in
  4473                                  
  4474 0000127B 8E1E[3804]               	mov	ds,[OldDS]			; restore old value of ds
  4475                                  
  4476                                  ;	pop	ds
  4477                                  ;	assume	ds:nothing
  4478                                  
  4479                                  	; MSDOS 3.3
  4480                                  	;pop	ds
  4481                                  
  4482 0000127F CF                      	iret
  4483                                  
  4484                                  FatErr:
  4485                                  	; 12/01/2023
  4486                                  	; MSDOS 6.0
  4487                                  	;mov	dx,offset DATARES:BadFatMsg
  4488                                  	;mov	si,offset DATARES:BadFatSubst
  4489 00001280 BA[B904]                	mov	dx,BADFATMSG
  4490 00001283 BE[2901]                	mov	si,BadFatSubst
  4491 00001286 E80700                  	call	RPrint
  4492                                  
  4493                                  	; MSDOS 3.3
  4494                                  	;mov	dx,BADFATMSG
  4495                                  	;call	RDISPMSG
  4496                                  	;mov	dx,BLKDEVERR
  4497                                  	;call	RDISPMSG
  4498                                  
  4499 00001289 B002                    	mov	al,2				; abort
  4500 0000128B EBE8                    	jmp	short RestHd
  4501                                  
  4502                                  ;DskErr	endp
  4503                                  
  4504                                  	; MSDOS 6.0
  4505                                  ; ----------------------------------------------------------------------------
  4506                                  ;***	RPrint - print message
  4507                                  ;***	Crlf - display cr/lf
  4508                                  ;
  4509                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4510                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4511                                  ;		variable fields related to substitution blocks are set
  4512                                  ;
  4513                                  ;	EXIT	nothing
  4514                                  ;
  4515                                  ;	USED	flags
  4516                                  ;
  4517                                  ;	EFFECTS
  4518                                  ;	  Message is displayed on stdout.
  4519                                  ;
  4520                                  ;	NOTE
  4521                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4522                                  ;	  be greater than number of substition blocks present.
  4523                                  ; ----------------------------------------------------------------------------
  4524                                  
  4525                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4526                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4527                                  
  4528                                  crlf: 
  4529                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4530                                  	; 14/01/2023
  4531 0000128D BA[7406]                	mov	dx,NEWLINE
  4532                                  
  4533                                  ;RPrint	proc
  4534                                  ;
  4535                                  ;	assume	ds:DATARES,ss:DATARES
  4536                                  ;
  4537                                  	; 14/01/2023
  4538                                  RPrint:
  4539                                  
  4540                                  ;	Bugbug:	do we need to save all reg's?
  4541                                  
  4542 00001290 56                      	push	si			; preserve registers
  4543 00001291 50                      	push	ax
  4544 00001292 53                      	push	bx
  4545 00001293 51                      	push	cx
  4546 00001294 52                      	push	dx
  4547                                  
  4548 00001295 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4549 00001297 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4550 00001299 AC                      	lodsb				; AL = message length
  4551                                  					; DS:SI = ptr to message text
  4552 0000129A 31C9                    	xor	cx,cx
  4553 0000129C 88C1                    	mov	cl,al			; CX = message length
  4554 0000129E E303                    	jcxz	rpRet
  4555                                  
  4556 000012A0 E81900                  	call	RDispMsg
  4557                                  
  4558 000012A3 5A                      rpRet:	pop	dx
  4559 000012A4 59                      	pop	cx
  4560 000012A5 5B                      	pop	bx
  4561 000012A6 58                      	pop	ax
  4562 000012A7 5E                      	pop	si
  4563 000012A8 C3                      	retn
  4564                                  
  4565                                  ;RPrint	endp
  4566                                  
  4567                                  	; 14/01/2023
  4568                                  ;	; MSDOS 3.3
  4569                                  ;CRLF:
  4570                                  ;	mov     dx,NEWLIN
  4571                                  ;
  4572                                  ;RDISPMSG: ; Display message/text
  4573                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4574                                  ;	push    ax
  4575                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4576                                  ;	clc
  4577                                  ;	int     21h             ; DOS - PRINT STRING
  4578                                  ;				; DS:DX -> string terminated by "$"
  4579                                  ;	pop     ax
  4580                                  ;	retn
  4581                                  
  4582                                  
  4583                                  	; MSDOS 6.0
  4584                                  ; ----------------------------------------------------------------------------
  4585                                  ;***	RPrintCrit - print critical error message
  4586                                  ;
  4587                                  ;	ENTRY	DX = extended error # (19-39)
  4588                                  ;
  4589                                  ;	EXIT	nothing
  4590                                  ;
  4591                                  ;	USED	flags
  4592                                  ;
  4593                                  ;	EFFECTS
  4594                                  ;	  Message is displayed on stdout
  4595                                  ; ----------------------------------------------------------------------------
  4596                                  
  4597                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4598                                  
  4599                                  ;RPrintCrit	proc
  4600                                  ;	assume	ds:DATARES,ss:DATARES
  4601                                  
  4602                                  	; 14/01/2023
  4603                                  RPrintCrit:
  4604 000012A9 52                      	push	dx			; preserve DX
  4605 000012AA 87DA                    	xchg	bx,dx			; BX = extended error #
  4606                                  					; DX = saved BX
  4607 000012AC 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4608 000012AF D1E3                    	shl	bx,1			; BX = offset in word table
  4609 000012B1 8B9F[0E08]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4610 000012B5 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4611                                  					; BX = restored
  4612 000012B7 E8D6FF                  	call	RPrint			; print the message
  4613 000012BA 5A                      	pop	dx			; restore DX
  4614 000012BB C3                      	retn
  4615                                  
  4616                                  ;RPrintCrit	endp
  4617                                  
  4618                                  ; ----------------------------------------------------------------------------
  4619                                  ;***	RDispMsg - display message
  4620                                  ;
  4621                                  ;	Display message, with substitutions, for RPrint.
  4622                                  ;
  4623                                  ;	ENTRY	DS:SI = ptr to message text
  4624                                  ;		CX = message length
  4625                                  ;		DS:BX = ptr to substitution block, if any
  4626                                  ;
  4627                                  ;	EXIT	nothing
  4628                                  ;
  4629                                  ;	USED	AX,CX,DX,SI
  4630                                  ; ----------------------------------------------------------------------------
  4631                                  
  4632                                  ;RDispMsg	proc
  4633                                  ;	assume	ds:DATARES,ss:DATARES
  4634                                  
  4635                                  RDispMsg:
  4636                                  	; 14/01/2023
  4637                                  rdNextChar:
  4638 000012BC AC                      	lodsb				; AL = next char
  4639 000012BD 3C25                    	cmp	al,'%'
  4640 000012BF 7511                    	jne	short rdOutChar		; not a substitution
  4641 000012C1 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4642 000012C3 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4643 000012C6 80FA09                  	cmp	dl,9
  4644 000012C9 7307                    	jae	short rdOutChar		; not a substitution
  4645                                  
  4646                                  ;*	A substitution code %1 - %9 has been encountered.
  4647                                  ;	DL = 0-8, indicating %1-%9
  4648                                  ;	DS:BX = ptr to substitution block
  4649                                  
  4650 000012CB E80D00                  	call	SubstMsg		; display the substitution
  4651 000012CE 46                      	inc	si			; SI = ptr past %n
  4652 000012CF 49                      	dec	cx			; count extra character in %n
  4653 000012D0 EB06                    	jmp	short rdCharDone
  4654                                  
  4655                                  ;*	Normal character output.
  4656                                  
  4657                                  rdOutChar:
  4658 000012D2 88C2                    	mov	dl,al			; DL = char
  4659 000012D4 B402                    	mov	ah,2			; AH = DOS Character Output code
  4660 000012D6 CD21                    	int	21h			; call DOS
  4661                                  rdCharDone:
  4662 000012D8 E2E2                    	loop	rdNextChar
  4663 000012DA C3                      	retn
  4664                                  
  4665                                  ;RDispMsg	endp
  4666                                  
  4667                                  ; ----------------------------------------------------------------------------
  4668                                  ;***	SubstMsg - display message substitution
  4669                                  ;
  4670                                  ;	Display a substitution string within a message.
  4671                                  ;	Substitution can be a char, an ASCIIZ string, or
  4672                                  ;	a word to be displayed as hex digits.
  4673                                  ;
  4674                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4675                                  ;		DS:BX = ptr to substitution block
  4676                                  ;
  4677                                  ;	EXIT	nothing
  4678                                  ;
  4679                                  ;	USED	AX,DX
  4680                                  ; ----------------------------------------------------------------------------
  4681                                  
  4682                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4683                                  
  4684                                  ;SubstMsg	proc
  4685                                  ;	assume	ds:DATARES,ss:DATARES
  4686                                  	
  4687                                  	; 14/01/2023
  4688                                  SubstMsg:
  4689 000012DB 53                      	push	bx			; preserve BX
  4690 000012DC 51                      	push	cx			; preserve CX
  4691                                  
  4692                                  	;mov	al,size SUBST		; AL = size of substitution block
  4693 000012DD B003                    	mov	al,3
  4694 000012DF F6E2                    	mul	dl			; AX = offset of desired subst block
  4695 000012E1 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4696                                  
  4697                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4698 000012E3 8A07                    	mov	al,[bx]
  4699                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4700 000012E5 8B5F01                  	mov	bx,[bx+1]
  4701                                  
  4702                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4703                                  
  4704 000012E8 FEC8                    	dec	al
  4705 000012EA 7428                    	jz	short smChar
  4706 000012EC FEC8                    	dec	al
  4707 000012EE 742C                    	jz	short smStr
  4708                                  
  4709                                  ;*	Hex number substitution.
  4710                                  
  4711                                  	;mov	ax,ds:[bx]		; AX = word value
  4712 000012F0 8B07                    	mov	ax,[bx]
  4713 000012F2 B90400                  	mov	cx,4			; CX = # digits to display
  4714                                  smDigit:
  4715 000012F5 D1C0                    	rol	ax,1
  4716 000012F7 D1C0                    	rol	ax,1
  4717 000012F9 D1C0                    	rol	ax,1
  4718 000012FB D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4719                                  
  4720 000012FD 50                      	push	ax			; save other digits
  4721 000012FE 240F                    	and	al,0Fh			; AL = binary digit
  4722 00001300 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4723 00001302 3C39                    	cmp	al,'9'
  4724 00001304 7602                    	jbe	short smDigit09		; it's 0-9
  4725                                  	;add	al,7
  4726 00001306 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4727                                  smDigit09:
  4728 00001308 88C2                    	mov	dl,al			; DL = ascii digit
  4729 0000130A B402                    	mov	ah,2
  4730 0000130C CD21                    	int	21h			; output the ascii digit
  4731 0000130E 58                      	pop	ax			; restore all digits
  4732                                  
  4733 0000130F E2E4                    	loop	smDigit
  4734                                  	;jmp	short smRet
  4735                                  	; 14/01/2023
  4736                                  smRet:	
  4737 00001311 59                      	pop	cx
  4738 00001312 5B                      	pop	bx
  4739 00001313 C3                      	retn
  4740                                  
  4741                                  ;*	Char substitution.
  4742                                  
  4743                                  smChar:
  4744                                  	;mov	dl,ds:[bx]		; DL = char to output
  4745 00001314 8A17                    	mov	dl,[bx]
  4746 00001316 B402                    	mov	ah,2
  4747 00001318 CD21                    	int	21h
  4748 0000131A EBF5                    	jmp	short smRet
  4749                                  
  4750                                  ;*	String substitution.
  4751                                  
  4752                                  smStr:
  4753                                  	;mov	dl,ds:[bx]		; DL = next char
  4754 0000131C 8A17                    	mov	dl,[bx]
  4755 0000131E 08D2                    	or	dl,dl
  4756 00001320 74EF                    	jz	short smRet		; null char - we're done
  4757 00001322 B402                    	mov	ah,2
  4758 00001324 CD21                    	int	21h			; display char
  4759 00001326 43                      	inc	bx			; DS:BX = ptr to next char
  4760 00001327 EBF3                    	jmp	short smStr
  4761                                  
  4762                                  ;smRet:	pop	cx
  4763                                  ;	pop	bx
  4764                                  ;	retn
  4765                                  
  4766                                  ;SubstMsg	endp
  4767                                  
  4768                                  	; MSDOS 6.0
  4769                                  ; ----------------------------------------------------------------------------
  4770                                  ;***	CharToUpper - convert character to uppercase
  4771                                  ;
  4772                                  ;	ENTRY	AL = char
  4773                                  ;
  4774                                  ;	EXIT	AL = uppercase char
  4775                                  ;
  4776                                  ;	USED	AX
  4777                                  ; ----------------------------------------------------------------------------
  4778                                  
  4779                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4780                                  
  4781                                  ;CharToUpper	proc
  4782                                  ;	assume	ds:DATARES
  4783                                  CharToUpper:
  4784 00001329 50                      	push	ax		; put char on stack as arg to int 2F
  4785 0000132A B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4786 0000132D CD2F                    	int	2Fh
  4787 0000132F 44                      	inc	sp		; throw away old char on stack
  4788 00001330 44                      	inc	sp
  4789 00001331 C3                      	retn
  4790                                  
  4791                                  ;CharToUpper	endp
  4792                                  
  4793                                  	; 14/01/2023
  4794                                  ;	; MSDOS 3.3
  4795                                  ;CHARTOUPPER:
  4796                                  ;	cmp	al,80h
  4797                                  ;	jb	short CHARTOUPPER1
  4798                                  ;	sub	al,80h
  4799                                  ;	push	ds
  4800                                  ;	push	bx
  4801                                  ;	lds	bx,[UPPERCASETBL]
  4802                                  ;	add	bx,2
  4803                                  ;	xlat
  4804                                  ;	pop	bx
  4805                                  ;	pop	ds
  4806                                  ;	jmp	short CHARTOUPPER_RETN
  4807                                  ;CHARTOUPPER1:
  4808                                  ;	cmp	al,'a'
  4809                                  ;	jb	short CHARTOUPPER_RETN
  4810                                  ;	cmp	al,'z'
  4811                                  ;	ja	short CHARTOUPPER_RETN
  4812                                  ;	sub	al,20h
  4813                                  ;CHARTOUPPER_RETN:
  4814                                  ;	retn
  4815                                  
  4816                                  ;public	EndCode
  4817                                  ;EndCode label byte
  4818                                  
  4819                                  	; MSDOS 6.0
  4820                                  ; ----------------------------------------------------------------------------
  4821                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4822                                  ;
  4823                                  ;	ENTRY	If we handle it -
  4824                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4825                                  ;		  DL = operation =
  4826                                  ;		     0 = get extended error messages
  4827                                  ;		     1 = set extended error messages
  4828                                  ;		     2 = get parse error messages
  4829                                  ;		     3 = set parse error messages
  4830                                  ;		     4 = get critical error messages
  4831                                  ;		     5 = set critical error messages
  4832                                  ;		     6 = get file system error messages
  4833                                  ;		     7 = set file system error messages
  4834                                  ;		     8 = get disk retriever routine
  4835                                  ;		     9 = set disk retriever routine
  4836                                  ;		  ES:DI = address for 'set' operations
  4837                                  ;
  4838                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4839                                  ;
  4840                                  ;	NOTE
  4841                                  ;	  This handler replaces the one that used to reside in DOS.
  4842                                  ;	  'Set' operations are ignored.
  4843                                  ;	  'File system error messages' are not supported.
  4844                                  ; ----------------------------------------------------------------------------
  4845                                  
  4846                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4847                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4848                                  ;SR;
  4849                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4850                                  ;segment address. Get them off the stack
  4851                                  
  4852                                  ;MsgInt2fHandler proc	far
  4853                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4854                                  
  4855                                  	; 14/01/2023
  4856                                  MsgInt2fHandler:
  4857 00001332 1F                      	pop	ds			; ds = DATARES
  4858                                  	;assume	ds:DATARES
  4859                                  ;	pop	word [OldDS]		; save old value of ds
  4860                                  
  4861 00001333 3D2E12                  	cmp	ax,122Eh
  4862                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4863                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4864 00001336 742A                    	je	short miOurs		; it's ours
  4865                                  
  4866                                  ;ifndef ROMDOS
  4867                                  	;cmp	ax,5500h
  4868 00001338 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4869                                  ;else
  4870                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4871                                  ;endif	;ROMDOS
  4872 0000133B 741C                    	je	short fcOurs
  4873                                  
  4874                                  ;SR;
  4875                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4876                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4877                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4878                                  ;current value of ds as it points at the data segment. So we do some kinky
  4879                                  ;stack manipulations.
  4880                                  
  4881 0000133D 50                      	push	ax
  4882 0000133E 50                      	push	ax			; create 2 words on stack for retf
  4883                                  
  4884 0000133F 55                      	push	bp
  4885 00001340 50                      	push	ax
  4886                                  
  4887 00001341 89E5                    	mov	bp,sp			; bp can be used to address stack
  4888                                  
  4889                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4890                                  ;do a 'pop ds' at the end to restore our ds
  4891                                  
  4892 00001343 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4893 00001346 894604                  	mov	[bp+4],ax
  4894                                  	
  4895                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4896 00001349 A1[B503]                	mov	ax,[Int2fHandler+2]
  4897 0000134C 894608                  	mov	[bp+8],ax		; put segment address
  4898                                  	;mov	ax,word ptr ds:Int2fHandler
  4899 0000134F A1[B303]                	mov	ax,[Int2fHandler]
  4900 00001352 894606                  	mov	[bp+6],ax		; put offset address
  4901                                  
  4902 00001355 58                      	pop	ax
  4903 00001356 5D                      	pop	bp
  4904 00001357 1F                      	pop	ds
  4905                                  
  4906 00001358 CB                      	retf				; chain on to next handler
  4907                                  
  4908                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4909                                  
  4910                                  fcOurs:
  4911                                  
  4912                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4913                                  
  4914 00001359 58                      	pop	ax			; discard ds currently on stack
  4915 0000135A 1E                      	push	ds			; store our data segment
  4916                                  
  4917                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4918 0000135B BE[0400]                	mov	si,Int2f_Entry
  4919                                  
  4920 0000135E 31C0                    	xor	ax,ax			; indicate COMMAND present
  4921 00001360 EB11                    	jmp	short miRet		; return to caller
  4922                                  
  4923                                  miOurs:
  4924 00001362 F6C201                  	test	dl,1
  4925 00001365 750C                    	jnz	short miRet		; ignore 'set' operations
  4926                                  
  4927 00001367 53                      	push	bx			; preserve BX
  4928 00001368 89D3                    	mov	bx,dx
  4929 0000136A 30FF                    	xor	bh,bh			; BX = index in word table
  4930 0000136C D1E3                    	shl	bx,1			; BX = index in dword table
  4931                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  4932 0000136E C4BF[7706]              	les	di,[bx+MsgPtrLists]
  4933 00001372 5B                      	pop	bx			; restore BX
  4934                                  miRet:
  4935                                  ;	mov	ds,[OldDS]		; restore ds
  4936 00001373 1F                      	pop	ds
  4937                                  	;assume	ds:nothing
  4938                                  
  4939 00001374 CF                      	iret
  4940                                  
  4941                                  ;MsgInt2fHandler endp
  4942                                  
  4943                                  	; MSDOS 6.0
  4944                                  ; ----------------------------------------------------------------------------
  4945                                  ;***	MsgRetriever - message retrieval routine for utilities
  4946                                  ;
  4947                                  ;	Address of this routine is passed to utility programs via 
  4948                                  ;	message services int 2f. We try to find the desired message
  4949                                  ;	in memory or in our disk image.
  4950                                  ;
  4951                                  ;	ENTRY	AX = message #
  4952                                  ;		DI = offset in RESGROUP of msg ptr list
  4953                                  ;		ComSpec = asciiz pathname to our disk image
  4954                                  ;
  4955                                  ;	EXIT	CY clear for success
  4956                                  ;		ES:DI = ptr to count byte, followed by message text
  4957                                  ;
  4958                                  ;		CY set for failure
  4959                                  ;		ES,DI undefined
  4960                                  ;
  4961                                  ;	USED	flags
  4962                                  ;
  4963                                  ;	NOTE
  4964                                  ;	  The message # in AX is used to compute an offset into
  4965                                  ;	  the message ptr list pointed to by DI. The lists must
  4966                                  ;	  start with message # 1 and proceed through consecutive
  4967                                  ;	  message #'s.  
  4968                                  ;
  4969                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  4970                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  4971                                  ;	  valid message #.  ;M033
  4972                                  ;
  4973                                  ;	  List positions with no corresponding message text are
  4974                                  ;	  indicated by null pointers, which this routine detects.
  4975                                  ; ----------------------------------------------------------------------------
  4976                                  
  4977                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4978                                  
  4979                                  ;SR; This routine will be called directly by the utilities. So, we have
  4980                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  4981                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  4982                                  
  4983                                  ;MsgRetriever	proc	far
  4984                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4985                                  
  4986                                  	; 14/01/2023
  4987                                  MsgRetriever:
  4988 00001375 1F                      	pop	ds			; ds = DATARES
  4989                                  	;assume	ds:DATARES
  4990                                  ;	pop	word [OldDS]		; save old ds
  4991                                  
  4992 00001376 50                      	push	ax			; preserve registers
  4993 00001377 53                      	push	bx
  4994 00001378 51                      	push	cx
  4995 00001379 52                      	push	dx
  4996 0000137A 56                      	push	si
  4997                                  
  4998                                  ;;	push	ds
  4999                                  ;;	push	cs
  5000                                  ;;	pop	ds			; DS = DATARES seg addr
  5001                                  ;;	assume	ds:RESGROUP
  5002                                  ;;	push	cs
  5003                                  
  5004 0000137B 1E                      	push	ds			; get es from ds
  5005 0000137C 07                      	pop	es			; ES = DATARES seg addr
  5006                                  
  5007                                  ;	Begin modification M033.
  5008                                  
  5009                                  ;	Make sure msg # is valid.
  5010                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5011                                  
  5012                                  	;mov	bx,11
  5013 0000137D BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5014                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5015 00001380 81FF[1609]              	cmp	di,PARSMSGPTRS
  5016 00001384 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5017                                  	;mov	bx,90
  5018 00001386 BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5019                                  chkmsgnum:
  5020 00001389 39C3                    	cmp	bx,ax
  5021 0000138B 725A                    	jc	short mrRet		; msg # too high, return carry
  5022                                  
  5023                                  ;	Msg # is valid.
  5024                                  
  5025                                  ;	End modification M033.
  5026                                  
  5027 0000138D 48                      	dec	ax
  5028 0000138E D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5029 00001390 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5030                                  
  5031 00001392 81FF[B703]              	cmp	di,ResMsgEnd
  5032 00001396 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5033                                  
  5034                                  ;*	Retrieve message from disk (or ROM) image.
  5035                                  ;	Read once to get the ptr to the message, then again for the message.
  5036                                  
  5037                                  ;ifndef	ROMDOS
  5038                                  	; 14/01/2023
  5039                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5040 00001398 BE[4E01]                	mov	si,ComSpec
  5041 0000139B BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5042 0000139E BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5043 000013A1 B8006C                  	mov	ax,6C00h
  5044                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5045 000013A4 CD21                    	int	21h				; call DOS
  5046 000013A6 723F                    	jc	short mrRet			; return failure
  5047                                  
  5048 000013A8 89C3                    	mov	bx,ax				; BX = file handle
  5049 000013AA 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5050 000013AC 31F6                    	xor	si,si				; SI = read count
  5051                                  mrRead:
  5052 000013AE 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5053 000013B2 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5054 000013B4 B80042                  	mov	ax,4200h
  5055                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5056 000013B7 CD21                    	int	21h				; call DOS
  5057 000013B9 721A                    	jc	short mrCloseFile		; handle error
  5058                                  
  5059                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5060 000013BB BA[6303]                	mov	dx,MsgBuffer
  5061 000013BE B94000                  	mov	cx,64				; CX = # bytes to read
  5062 000013C1 B43F                    	mov	ah,3Fh
  5063                                  	;mov	ah,READ				; AH = 'Read File'
  5064 000013C3 CD21                    	int	21h				; call DOS
  5065 000013C5 720E                    	jc	short mrCloseFile		; handle error
  5066                                  
  5067 000013C7 09F6                    	or	si,si				; (CY cleared)
  5068 000013C9 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5069 000013CB 46                      	inc	si				; mark one read done
  5070 000013CC 8B16[6303]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5071 000013D0 09D2                    	or	dx,dx
  5072 000013D2 75DA                    	jnz	short mrRead			; go read the message
  5073 000013D4 F9                      	stc					; null ptr found- no msg
  5074                                  
  5075                                  mrCloseFile:
  5076 000013D5 9C                      	pushf				; save success/failure (CY)
  5077 000013D6 B43E                    	mov	ah,3Eh
  5078                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5079 000013D8 CD21                    	int	21h			; call DOS
  5080                                  ;	Bugbug: should we avoid this popf?
  5081 000013DA 9D                      	popf				; CY = success/failure
  5082 000013DB 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5083 000013DD EB08                    	jmp	short mrRet		; we're done
  5084                                  
  5085                                  ;else	;ROMDOS
  5086                                  ;
  5087                                  ;;	DI = ptr to msg ptr
  5088                                  ;
  5089                                  ;	mov	si,di			; SI = ptr to msg ptr
  5090                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5091                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5092                                  ;
  5093                                  ;;	ASSUME ES:NOTHING is still in effect.
  5094                                  ;
  5095                                  ;	push	ds
  5096                                  ;	pop	es				; ES = DATARES seg addr
  5097                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5098                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5099                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5100                                  ;	or	si,si
  5101                                  ;	jz	mrNoMsg			; null ptr- no message text
  5102                                  ;
  5103                                  ;	sub	si,100h			; SI = offset into image of msg
  5104                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5105                                  ;	mov	di,offset DATARES:MsgBuffer
  5106                                  ;	invoke	LoadFromROM
  5107                                  ;	clc					; success
  5108                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5109                                  ;	jmp	short mrRet
  5110                                  ;
  5111                                  ;mrNoMsg:
  5112                                  ;	stc
  5113                                  ;	jmp	short mrRet
  5114                                  ;
  5115                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5116                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5117                                  ;	assume	es:NOTHING
  5118                                  ;
  5119                                  ;endif	;ROMDOS
  5120                                  
  5121                                  ;*	Message ptr is in memory.
  5122                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5123                                  
  5124                                  mrInMem:
  5125                                  	; 14/01/2023
  5126 000013DF 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5127 000013E2 09FF                    	or	di,di			; (CY cleared)
  5128 000013E4 7501                    	jnz	short mrRet		; found message
  5129 000013E6 F9                      	stc				; null ptr found - no message
  5130                                  mrRet:	
  5131 000013E7 5E                      	pop	si			; restore all registers
  5132 000013E8 5A                      	pop	dx
  5133 000013E9 59                      	pop	cx
  5134 000013EA 5B                      	pop	bx
  5135 000013EB 58                      	pop	ax
  5136                                  
  5137                                  ;	mov	ds,[OldDS]		; restore ds
  5138 000013EC 1F                      	pop	ds
  5139                                  	;assume	ds:nothing
  5140                                  
  5141 000013ED CB                      	retf	; 21/04/2023
  5142                                  
  5143                                  ;MsgRetriever endp
  5144                                  
  5145                                  ; M003; Start of changes for UMB support
  5146                                  
  5147                                  ; ----------------------------------------------------------------------------
  5148                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5149                                  ;
  5150                                  ;	ENTRY	al = Saved alloc strat and link state
  5151                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5152                                  ;			b1 = 1 if link state to restore is Linked
  5153                                  ;
  5154                                  ;	EXIT	None
  5155                                  ;
  5156                                  ;	USED	ax, bx, cx
  5157                                  ; ----------------------------------------------------------------------------
  5158                                  
  5159                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5160                                  
  5161                                  ;public	Lh_OffUnlink
  5162                                  Lh_OffUnlink:	; proc	far
  5163                                  	; 14/01/2023
  5164 000013EE 88C5                    	mov	ch,al
  5165 000013F0 88C1                    	mov	cl,al
  5166                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5167                                  	;mov	ax,(ALLOCOPER<<8)
  5168 000013F2 B80058                  	mov	ax,5800h
  5169 000013F5 CD21                    	int	21h
  5170 000013F7 89C3                    	mov	bx,ax
  5171 000013F9 D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5172 000013FB 80E180                  	and	cl,80h				; mask off b6-b0
  5173 000013FE 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5174 00001401 08CB                    	or	bl,cl				; set HighFirst bit state
  5175                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5176                                  	;mov	ax,(ALLOCOPER<<8)|1
  5177 00001403 B80158                  	mov	ax,5801h
  5178 00001406 CD21                    	int	21h				; set alloc strat
  5179                                  
  5180 00001408 88EB                    	mov	bl,ch
  5181 0000140A D0EB                    	shr	bl,1
  5182 0000140C 30FF                    	xor	bh,bh				; bx = linkstate
  5183                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5184                                  	;mov	ax,(ALLOCOPER<<8)|3
  5185 0000140E B80358                  	mov	ax,5803h
  5186 00001411 CD21                    	int	21h				; set linkstate
  5187                                  
  5188 00001413 CB                      	retf
  5189                                  
  5190                                  ;Lh_OffUnlink endp
  5191                                  
  5192                                  ; M003; End of changes for UMB support
  5193                                  
  5194                                  ;public	EndCode
  5195                                  ; 14/01/2023
  5196                                  ;EndCode: ; label byte
  5197                                  ; 06/06/2023
  5198                                  ; 16/04/2023
  5199                                  EndCode equ ($-StartCode)+100h
  5200                                  ; 06/06/2023
  5201                                  ;EndCode equ $-StartCode	
  5202                                  
  5203                                  ;CODERES ends
  5204                                  ;	end
  5205                                  
  5206                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5207                                  
  5208 00001414 00<rep Ch>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5209                                  
  5210                                  ;align 16
  5211                                  
  5212                                  ;=============================================================================
  5213                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5214                                  ;=============================================================================
  5215                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5216                                  
  5217                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5218                                  
  5219                                  ;TITLE   COMMAND Initialization
  5220                                  
  5221                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5222                                  ;ENVIRONSIZ2 EQU 092H
  5223                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5224                                  
  5225                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5226                                  ; 23/09/2018
  5227                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5228                                  ; 14/01/2023
  5229                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5230                                  
  5231                                  ; ----------------------------------------------------------------------------
  5232                                  
  5233                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5234                                  
  5235                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5236                                  ENVIRONSIZ equ 160
  5237                                  ENVSML	equ 256	; minimum environment size
  5238                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5239                                  MAX_COMSPEC equ 146
  5240                                  ECOMSPEC equ 14
  5241                                  
  5242                                  ; 14/01/2023
  5243                                  TAB_CHAR equ 09h
  5244                                  SPACE_CHAR equ 20h	
  5245                                  
  5246                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5247                                  ;ENVIRONSIZ equ 180	; SIZE Environment 
  5248                                  
  5249                                  ;----------------------------------------------------
  5250                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5251                                  ;----------------------------------------------------
  5252                                  ;Environment Struc	; Default COMMAND environment
  5253                                  ;
  5254                                  ;Env_PathString  db	"path="
  5255                                  ;Env_PathSpec	 db	"c:\msdos"
  5256                                  ;                db	0
  5257                                  ;Env_PrmptString db	"prompt="
  5258                                  ;Env_PrmptSpec   db	"$p$g"
  5259                                  ;                db	0
  5260                                  ;Env_ComString   db	"comspec="
  5261                                  ;Env_ComSpec     db	"\command.com"
  5262                                  ;		 db	134 dup (0)
  5263                                  ;
  5264                                  ;Environment ends
  5265                                  ;----------------------------------------------------
  5266                                  
  5267                                  ;-----------------------------------------------------------------------------
  5268                                  
  5269                                  ;-----------------------------------------------------------------------------
  5270                                  ; START OF INIT PORTION
  5271                                  ; This code is deallocated after initialization.
  5272                                  ;-----------------------------------------------------------------------------
  5273                                  
  5274                                  ;INIT	SEGMENT PUBLIC PARA
  5275                                  
  5276                                  ; 	EXTRN   HEADER:BYTE
  5277                                  ;	EXTRN   BADCOMLKMES:BYTE
  5278                                  
  5279                                  ;	PUBLIC  CONPROC
  5280                                  
  5281                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5282                                  
  5283                                          ;ORG 0
  5284                                  ;ZERO = $
  5285                                  	; 23/09/2018
  5286                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5287                                  
  5288                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5289                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5290                                  ConProc:
  5291                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5292 00001420 BC[3804]                	mov	sp,RStack
  5293                                  
  5294                                  ; We need to set the PSP to us right at start because Carousel needs
  5295                                  ; to be lied to and it does not set PSP when it transfers control to
  5296                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5297                                  ; command.com is also not lied to.
  5298                                  
  5299                                  	; 14/01/2023
  5300                                  	; MSDOS 6.0
  5301 00001423 B450                            mov	ah,50h
  5302                                  	;mov	ah,SET_CURRENT_PDB
  5303 00001425 8CC3                            mov	bx,es
  5304 00001427 CD21                            int	21h
  5305                                  
  5306                                  	; 14/01/2023
  5307 00001429 B430                    	mov	ah,30h 
  5308                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5309                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5310                                  	;mov	ax,3000h
  5311 0000142B CD21                    	int	21h
  5312                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5313                                  	;cmp	ax,5
  5314 0000142D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5315 00001430 7411                    	je	short okdos			; DOS version is ok
  5316                                  
  5317 00001432 BA[481D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5318 00001435 E858FE                  	call	RPrint
  5319                                  
  5320                                  	; MSDOS 3.3
  5321                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5322                                  	;int	21h             ; DOS - PRINT STRING
  5323                                  				; DS:DX -> string terminated by "$"
  5324 00001438 8CC0                    	mov	ax,es
  5325 0000143A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5326                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5327                                  Here:	
  5328 0000143F 74FE                    	jz	short Here			;  loop forever
  5329                                  	
  5330 00001441 CD20                    	int	20h				; otherwise, exit
  5331                                  okdos:
  5332                                  	; 23/09/2018
  5333                                  
  5334                                  ;  Calculate and save the end of the INIT segment (which is also
  5335                                  ;  the beginning of TRANGROUP).
  5336                                  
  5337                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5338                                  	; MSDOS 3.3
  5339                                  	;mov	ah,65h
  5340                                  	;mov	al,2
  5341                                  	;mov	dx,-1
  5342                                  	;mov	bx,-1
  5343                                  	;mov	cx,5
  5344                                  	;mov	di,UCASE_ADDR
  5345                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5346                                  	;		; AL = 02h : Get pointer to character translation table
  5347                                  	;		; BX = code page (-1 = current global code page)
  5348                                  	;		; DX = country ID (-1 = current country)
  5349                                  	;		; CX = amount of data to return
  5350                                  	;; ES:DI = pointer to output buffer
  5351                                  	;; Buffer offset :
  5352                                  	;;	00h -  byte,  country Id
  5353                                  	;;  	01h -  dword, pointer to uppercase table	
  5354                                  
  5355                                  	; 14/01/2023
  5356                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5357                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5358 00001443 BA3F22                  	mov	dx,TRANSTART+15			; get end of init code
  5359                                  	; 27/09/2018
  5360                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5361 00001446 B104                    	mov	cl,4				; change to paragraphs
  5362 00001448 D3EA                            shr	dx,cl				;
  5363 0000144A 8CC8                            mov     ax,cs                           ; get current segment
  5364 0000144C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5365 0000144E A3[AB1C]                        mov     [initend],ax			; save this
  5366                                  
  5367                                  	; 14/01/2023
  5368                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5369                                  
  5370                                  ;  Check for /? on the command line. If found, display help text and exit.
  5371                                  ;  NOTE: this routine may terminate the program, never returning.
  5372                                  
  5373 00001451 E87406                  	call	CheckHelp
  5374                                  
  5375                                  ; We have to patch the segment values for the various interrupt entry points.
  5376                                  ; This is because we need to have the default addresses of the handlers in our
  5377                                  ; stub before the relocation is done. These values will then be changed once
  5378                                  ; the resident is relocated
  5379                                  
  5380 00001454 E8B407                  	call	patch_segs
  5381                                  
  5382                                  ;  Turn APPEND off during initialization processing
  5383                                  
  5384                                  	; 14/01/2023
  5385 00001457 B800B7                  	mov     ax,0B700h
  5386                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5387 0000145A CD2F                    	int	2Fh				;
  5388                                  	;cmp	al,0				; append installed?
  5389 0000145C 08C0                    	or	al,al
  5390 0000145E 7418                    	jz	short set_msg_addr		; no - continue
  5391                                  	
  5392 00001460 B802B7                  	mov	ax,0B702h
  5393                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5394 00001463 CD2F                    	int	2Fh				;
  5395                                  	;cmp	ax,-1				; append version correct?
  5396                                  	;jne	short set_msg_addr		; no - continue
  5397 00001465 40                      	inc	ax ; -1 -> 0
  5398 00001466 7510                    	jnz	short set_msg_addr        
  5399                                  	
  5400 00001468 B806B7                  	mov     ax,0B706h
  5401                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5402 0000146B CD2F                    	int	2Fh				;
  5403 0000146D 891E[C301]                      mov     [Append_State],bx		; save append state
  5404                                         
  5405 00001471 31DB                    	xor	bx,bx                           ; clear out state
  5406 00001473 B807B7                  	mov	ax,0B707h
  5407                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5408 00001476 CD2F                    	int	2Fh				; set everything off
  5409                                  
  5410                                  set_msg_addr:
  5411                                  	; 14/01/2023
  5412                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5413                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5414                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5415 00001478 BF[3808]                	mov	di,DataresEnd
  5416 0000147B 893E[B703]              	mov	[ResMsgEnd],di			; save it
  5417                                  
  5418 0000147F E89B07                          call    get_XMMAddr                     ; get XMM call address
  5419                                  
  5420                                  ; Check if this is the first instance of command.com. If not, we just exit
  5421                                  ; this routine without moving any code.
  5422                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5423                                  ; stub. We just have to copy this over
  5424                                  	
  5425                                  ;ifndef ROMDOS
  5426 00001482 B80055                  	mov	ax,5500h
  5427                                  	;mov	ax,GET_COMMAND_STATE	
  5428                                  ;else
  5429                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5430                                  ;endif ; ROMDOS
  5431                                  
  5432 00001485 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5433                                  	;assume	ds:nothing
  5434                                  
  5435                                  	; 03/05/2023
  5436                                  	; Return:
  5437                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5438                                  	;   DS:SI -> entry point table
  5439                                  
  5440                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5441                                  
  5442 00001487 09C0                    	or	ax,ax
  5443 00001489 750C                    	jnz	short first_com			; this is the first instance
  5444                                  
  5445                                  	; 14/01/2023
  5446 0000148B 268936[EC20]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5447 00001490 268C1E[EE20]            	mov	[es:ResJmpTable+2],ds
  5448 00001495 EB06                    	jmp	short init_cntry
  5449                                  
  5450                                  first_com:
  5451 00001497 26C606[F020]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5452                                  
  5453                                  init_cntry:
  5454                                  	; 14/01/2023
  5455 0000149D 06                      	push	es
  5456 0000149E 1F                      	pop	ds
  5457                                  	;assume	ds:RESGROUP
  5458                                  
  5459 0000149F B465                    	mov	ah,65h
  5460                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5461 000014A1 B004                    	mov	al,4				; get file ucase table
  5462 000014A3 BAFFFF                  	mov	dx,-1				;
  5463                                  	;mov	bx,-1				;
  5464 000014A6 89D3                    	mov	bx,dx
  5465 000014A8 B90500                  	mov	cx,5				; number of bytes we want
  5466                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5467 000014AB BF[B601]                	mov	di,FUCase_Addr
  5468 000014AE CD21                    	int	21h
  5469                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5470                                  		; AL = function -
  5471                                  
  5472                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5473                                  
  5474 000014B0 1E                      	push	ds				;
  5475 000014B1 B80063                  	mov	ax,6300h
  5476                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5477 000014B4 CD21                    	int	21h				;
  5478                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5479                                  			
  5480 000014B6 8CDB                    	mov	bx,ds				; get segment to bx
  5481 000014B8 1F                      	pop	ds				;
  5482 000014B9 8936[BF01]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5483 000014BD 891E[C101]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5484                                  
  5485                                  	;mov	ax,[16h]
  5486 000014C1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5487                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5488 000014C4 A3[4101]                	mov	[Parent],ax			;  correctly.
  5489 000014C7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5490 000014CA A3[4301]                	mov	[OldTerm],ax
  5491 000014CD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5492 000014D0 A3[4501]                	mov	[OldTerm+2],ax
  5493                                  
  5494                                  	; 14/01/2023
  5495                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5496                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5497                                  	;mov	ax,EndCode+15
  5498                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5499                                  	; 14/01/2023
  5500                                  	;mov	cl,4				; ax = size of resident part of
  5501                                  	;shr	ax,cl				;  command in paragraphs. Add
  5502                                  	;mov	cx,cs				;  this to CS and you get the
  5503                                  	;add	ax,cx				;  segment of the TPA.
  5504                                  
  5505 000014D3 8CC8                    	mov	ax,cs
  5506 000014D5 055201                  	add	ax,(EndCode+15)>>4
  5507                                  	
  5508 000014D8 A3[5F03]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5509 000014DB 2500F0                  	and     ax,0F000h
  5510 000014DE 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5511 000014E1 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5512 000014E3 A1[5F03]                	mov     ax,[Res_Tpa]
  5513                                  TpaSet:
  5514 000014E6 A3[5103]                	mov	[LTpa],ax			; Good enough for the moment
  5515                                  	;mov	ax,[2]
  5516 000014E9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5517                                  
  5518 000014EC 8C1E[5703]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5519 000014F0 8C1E[5B03]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5520 000014F4 8C1E[4F03]              	mov	[MySeg],ds			;  use to call resident routines.
  5521                                  	; 19/04/2023
  5522                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5523 000014F8 8C1E[8906]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5524                                  
  5525 000014FC A3[9801]                	mov	[MemSiz],ax			; Needed for execing other programs
  5526                                  
  5527                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5528                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5529                                  
  5530                                  ; First reallocate the COMMAND size to its memory image
  5531                                  	
  5532 000014FF 50                      	push	ax    
  5533                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5534                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5535                                  	;mov	bx,TRANSTART
  5536                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5537                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5538                                  	;add	bx,15 ; *			; round up the size
  5539                                  
  5540                                  	; 03/05/2023
  5541                                  	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5542                                  	;;add	bx,TRANSPACEEND
  5543                                  	; 06/06/2023
  5544                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5545                                          ;mov	cl,4				;
  5546                                          ;shr	bx,cl				; size of command.com
  5547 00001500 BB840B                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
  5548                                  	
  5549 00001503 B44A                    	mov	ah,4Ah
  5550                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5551 00001505 CD21                            int     21h				;
  5552 00001507 58                              pop     ax				;
  5553                                  	
  5554                                  ; Compute maximum size of environment
  5555                                  
  5556                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5557                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5558                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5559                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5560                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5561 00001508 C706[9F1C]4D00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5562                                  ;
  5563                                  ; Compute minimum size of environment
  5564                                  ;
  5565                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5566                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5567 0000150E C706[9D1C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5568                                  
  5569                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5570                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5571                                  	; 06/06/2023
  5572                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5573                                  	;mov	cl,4				;  in paragraphs.
  5574                                  	;shr	dx,cl
  5575 00001514 BA6109                  	mov	dx,(TRANSPACEEND+15)>>4
  5576 00001517 8916[AD1C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5577                                  
  5578 0000151B 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5579 0000151D A3[9201]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5580                                  	;mov	ax,[2Ch]
  5581 00001520 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5582                                  
  5583                                  	; 14/01/2023
  5584                                          ; MSDOS 6.0
  5585                                  	;mov	[EnvirSeg],ax
  5586                                          
  5587                                  	; 21/01/2023
  5588 00001523 09C0                    	or	ax,ax				; if there is no environment segment,
  5589 00001525 7406                    	jz	short buildenv			; make one
  5590                                    
  5591                                  	; 21/01/2023
  5592                                  	; MSDOS 3.3 & MSDOS 5.0
  5593                                  	;inc	byte [CHUCKENV]
  5594 00001527 FE06[811C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5595                                  	
  5596                                  	; MSDOS 3.3 & MSDOS 5.0
  5597 0000152B EB03                    	jmp	short environpassed
  5598                                  	; MSDOS 6.0
  5599                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5600                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5601                                  
  5602                                  	; MSDOS 6.0
  5603                                  
  5604                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5605                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5606                                  ; size and free this buffer. We need this buffer because we no longer have an
  5607                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5608                                  ; given on the command line before we know the environment size. This routine
  5609                                  ; will not return in case of an allocation error. It will either exit or hang
  5610                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5611                                  
  5612                                  	; 14/01/2023
  5613                                  buildenv:
  5614 0000152D E88106                  	call	alloc_env                       ; try to allocate buffer
  5615                                  environpassed:
  5616                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5617 00001530 A3[3F03]                	mov	[EnvirSeg],ax
  5618                                  	;
  5619 00001533 8EC0                    	mov	es,ax                           ; and it load into es.
  5620                                  	;assume	es:nothing
  5621                                  
  5622                                  gottheenvir:
  5623                                  
  5624                                  ; Initialize the command drive
  5625                                  
  5626                                  ; 14/01/2023
  5627                                  %if 0
  5628                                  	; MSDOS 3.3
  5629                                  BUILDENV:
  5630                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5631                                  	mov	ax,PATHSTRING ; "PATH="
  5632                                  	mov	cl,4
  5633                                  	shr	ax,cl
  5634                                  	mov	dx,ds
  5635                                  	add	ax,dx
  5636                                  ENVIRONPASSED:
  5637                                          mov	[ENVIRSEG],ax
  5638                                          MOV     es,ax
  5639                                  
  5640                                          ;mov	ax,CHAR_OPER<<8
  5641                                          mov	ax,CHAR_OPER*256 ; 3700h
  5642                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5643                                  			; Return: AL = FFh unsupported subfunction
  5644                                  			; DL = current switch character
  5645                                          mov	[RSWITCHAR],dl
  5646                                  
  5647                                          ;CMP	dl,'/'
  5648                                  	cmp	dl,[slash_chr]
  5649                                          jnz	short IUSESLASH
  5650                                  
  5651                                  	;mov	al,'\'
  5652                                   	mov	al,[bslash_chr]
  5653                                  	mov	[COMSPECT],al
  5654                                  
  5655                                  	cmp	byte [CHUCKENV],0
  5656                                  	jnz	short IUSESLASH
  5657                                  
  5658                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5659                                  	; 30/04/2018
  5660                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5661                                  	; 23/09/2018
  5662                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5663                                  gottheenvir:
  5664                                  IUSESLASH:
  5665                                  
  5666                                  ; Initialize the command drive
  5667                                  
  5668                                  %endif
  5669                                  	; 14/01/2023
  5670                                  	; MSDOS 3.3 & MSDOS 6.0
  5671 00001535 B419                    	mov	ah,19h
  5672                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5673 00001537 CD21                    	int	21h
  5674 00001539 FEC0                    	inc	al
  5675 0000153B A2[9701]                	mov	[ComDrv],al
  5676                                  
  5677                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5678 0000153E A05C00                          mov	al,[FCB]
  5679 00001541 08C0                    	or	al,al
  5680 00001543 7426                    	jz	short nocomdrv		; no drive specified
  5681                                  
  5682 00001545 B43A                    	mov	ah,':'
  5683 00001547 A2[9701]                	mov	[ComDrv],al
  5684 0000154A 0440                    	add	al,40h			; convert number to uppercase character
  5685                                  
  5686 0000154C FD                      	std
  5687                                  
  5688                                  	; MSDOS 6.0
  5689                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5690                                  	;je	short notwidenv		;  move the default comspec string in it
  5691                                  	; 14/01/2023
  5692                                  	; MSDOS 5.0 COMMAND.COM
  5693                                  	;mov	di,[ComspOffset]
  5694                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5695                                          ;je	short notwidenv		; yes, must have been inherited that way
  5696                                  
  5697                                  	; MSDOS 3.3
  5698                                  	;cmp	byte [CHUCKENV],0
  5699                                  	;jne	short NOTWIDENV
  5700                                  	; 21/01/2021
  5701                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5702 0000154D 803E[811C]00             	cmp	byte [AllocedEnv],0
  5703 00001552 7713                    	ja	short notwidenv
  5704                                  
  5705 00001554 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5706 00001555 06                      	push	es			;  the drivespec is in ax and is copied
  5707 00001556 1F                      	pop	ds			;  on to the front of the string.
  5708                                  
  5709                                  	; MSDOS 6.0
  5710                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5711                                          ;lea	di,[di+MAX_COMSPEC-1]
  5712                                  
  5713                                  	; 21/01/2023
  5714                                  	; 14/01/2023
  5715                                  	; MSDOS 5.0 COMMAND.COM
  5716                                  	; MSDOS 3.3
  5717                                  	; 23/09/2018
  5718                                  	; 30/04/2018
  5719                                  	;mov	di,159
  5720                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5721                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5722 00001557 BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5723                                  	;mov	si,157
  5724                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5725                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5726 0000155A BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5727                                  	;mov	cx,144
  5728                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5729 0000155D B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5730                                  
  5731 00001560 F3A4                    	rep	movsb
  5732 00001562 1F                      	pop	ds
  5733                                  
  5734                                  	; MSDOS 6.0
  5735                                  	;mov	word ptr es:[di-1],ax
  5736                                  
  5737                                  	; MSDOS 3.3
  5738                                  	;mov	[es:0Eh],ax
  5739                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5740                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5741                                  	; 14/01/2023
  5742 00001563 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5743                                  
  5744                                  	; MSDOS 3.3 & MSDOS 6.0
  5745                                  notwidenv:
  5746 00001567 FC                      	cld
  5747 00001568 A3[631C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5748                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5749                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5750                                  	;mov	[KAUTOBAT],ax
  5751                                  nocomdrv:
  5752 0000156B E896FA                  	call	SetVect        ; Set the vectors
  5753                                  
  5754                                  ; parsing starts here
  5755                                  
  5756                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5757                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5758                                  	; MSDOS 6.0
  5759 0000156E 0E                      	push	cs
  5760 0000156F 0E                      	push	cs
  5761 00001570 1F                      	pop	ds
  5762 00001571 07                      	pop	es
  5763                                  	;assume ds:ResGroup,es:ResGroup
  5764                                  
  5765                                  ; 14/01/2023
  5766                                  %if 0	
  5767                                  	; MSDOS 3.3
  5768                                  	mov	si,80h		; get command line
  5769                                  	lodsb			; get length of line
  5770                                  	mov	cl,al
  5771                                  	xor	ch,ch		; cx = length of command line
  5772                                  
  5773                                  ; insure that the command line correctly ends with a cr
  5774                                  
  5775                                  	add	si,cx		; go to end of command line	
  5776                                  	mov	byte [si], 0Dh	; insert a carriage return
  5777                                  
  5778                                  	mov	si,81h		; Start of parms
  5779                                  CHKARG:
  5780                                          jcxz	COMRETURNSJ     ; No parameters
  5781                                          dec	cx
  5782                                  	lodsb
  5783                                  CHECKSWITCHCHR:
  5784                                  	;cmp	al,' '
  5785                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5786                                  	jz	short CHKARG
  5787                                  	cmp	al,9		; Skip TAB characters
  5788                                  	jz	short CHKARG
  5789                                  	cmp	al,[RSWITCHAR]	; Switch?
  5790                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5791                                  	jmp	CHKOTHERARGS	; No
  5792                                  
  5793                                  %endif
  5794                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5795                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5796                                  	; MSDOS 6.0
  5797                                  
  5798 00001572 BE8000                  	mov	si,80h				; get command line
  5799 00001575 AC                      	lodsb					; get length of line
  5800 00001576 89F7                    	mov	di,si				; get line position in di
  5801 00001578 30E4                    	xor	ah,ah				; ax = length of command line
  5802                                  
  5803                                  ; insure that the command line correctly ends with a cr
  5804                                  
  5805 0000157A 01C7                    	add	di,ax				; go to end of command line
  5806 0000157C C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5807 0000157F 31C9                    	xor	cx,cx				; clear cx
  5808 00001581 890E[441D]                      mov	[num_positionals],cx		; initialize positionals
  5809                                  
  5810                                  ; Scan the command line looking for the parameters
  5811                                  
  5812                                  Parse_command_line:
  5813                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5814 00001585 BF[B61C]                	mov	di,PARSE_COMMAND
  5815 00001588 8B0E[441D]              	mov	cx,[num_positionals]		; Get number of positionals
  5816 0000158C 31D2                    	xor	dx,dx				; clear dx
  5817 0000158E 8936[461D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5818                                  	;call	dword ptr Init_Parse
  5819 00001592 FF1E[A91C]              	call	far [Init_Parse]		; call parser
  5820 00001596 890E[441D]                      mov     [num_positionals],cx		; Save number of positionals
  5821                                  	; 29/01/2023
  5822                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5823 0000159A 83F8FF                          cmp	ax,-1
  5824 0000159D 7503                    	jne	short t1
  5825 0000159F E9FC01                          jmp     ArgsDone                        ; yes - exit
  5826                                  t1:	
  5827                                  	;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5828                                  	;cmp	ax,0
  5829 000015A2 21C0                    	and	ax,ax
  5830 000015A4 7447                    	jz	short parse_cont		; no - continue
  5831                                  
  5832                                  ; Before issuing error message - make sure switch is not /C
  5833                                  
  5834                                  parse_line_error:
  5835                                  	; 14/01/2023
  5836                                  	;push	si				; save line position
  5837                                  	;push	ax				; save error number
  5838                                  	;cmp	ax,3
  5839 000015A6 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5840                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5841 000015A9 752A                    	jne	short parse_line_error_disp2
  5842 000015AB 56                      	push	si ; **				; save line position
  5843 000015AC 50                      	push	ax ; *				; save error number
  5844 000015AD 89F7                    	mov	di,si				; Get terminating pointer in DI
  5845 000015AF 8B36[461D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5846                                  
  5847                                  init_chk_delim:
  5848 000015B3 39FE                    	cmp	si,di				; at end of parsed parameter?
  5849 000015B5 741C                            je	short parse_line_error_disp	; Yes - just display message
  5850 000015B7 AC                      	lodsb					;
  5851 000015B8 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5852                                  	;cmp	al,space_chr ; 14/01/2023
  5853                                  	;;cmp	al,[space]			; Skip blank spaces
  5854 000015BA 74F7                    	je	short init_chk_delim		;
  5855                                  	;cmp	al,9
  5856 000015BC 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5857 000015BE 74F3                    	je	short init_chk_delim		;
  5858                                  
  5859 000015C0 3A06[5303]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5860 000015C4 750D                            jne	short parse_line_error_disp	; No - just issue message
  5861 000015C6 AC                      	lodsb					; Get the char after the switch
  5862                                  
  5863 000015C7 E86F04                  	call	iupconv 			; upper case it
  5864                                  
  5865                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5866                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5867                                  	;16/04/2023
  5868 000015CA 3C43                    	cmp	al,'C' ; scswitch
  5869 000015CC 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5870 000015CE 5A                      	pop	dx ; *				; even up stack
  5871 000015CF 5A                      	pop	dx ; **				; even up stack
  5872 000015D0 E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5873                                  
  5874                                  	; MSDOS 6.0
  5875                                  ;check_k_too:
  5876                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  5877                                          ;jne	short parse_line_error_disp	;
  5878                                  	;pop	dx ; *				; even up stack
  5879                                  	;pop	dx ; **				; even up stack
  5880                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5881                                  
  5882                                  parse_line_error_disp:
  5883                                  	; 14/01/2023
  5884 000015D3 58                      	pop	ax ; *				; restore error number
  5885 000015D4 5E                      	pop	si ; **				; restore line position
  5886                                  parse_line_error_disp2:
  5887 000015D5 89C2                    	mov	dx,ax				; get message number
  5888 000015D7 E80304                  	call	RPrintParse
  5889 000015DA E8B0FC                  	call	crlf
  5890 000015DD EBA6                            jmp     short Parse_command_line        ; continue parsing
  5891                                  
  5892                                  ; 16/04/2023
  5893                                  %if 1
  5894                                  SetMSwitch:
  5895                                          ;cmp	byte [ext_msg],1
  5896 000015DF 803E[B11C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5897                                  	; 16/04/2023
  5898                                  	;jnz	short setMswitchok		; no - set it
  5899                                  	;;mov	ax,1
  5900                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5901                                  	;jmp	parse_line_error                ; go issue error message
  5902                                  	; 16/04/2023
  5903 000015E4 744F                    	je	short parse_line_error_j
  5904                                  setMswitchok:
  5905                                          ;mov	byte [ext_msg],1
  5906 000015E6 C606[B11C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  5907                                  	; 06/06/2023
  5908 000015EB EB98                    	jmp	short Parse_command_line	; keep parsing
  5909                                  %endif
  5910                                  
  5911                                  parse_cont:
  5912                                  
  5913                                  ; 15/01/2023
  5914                                  %if 0
  5915                                  	; MSDOS 3.3
  5916                                  
  5917                                  ; See if a switch was entered
  5918                                  
  5919                                  	jcxz	COMRETURNSJ
  5920                                  	dec	cx
  5921                                  	lodsb
  5922                                  	or	al,20h		; Lower case
  5923                                  	cmp	al,'f'		; FAIL switch
  5924                                  	jnz     short CHECKPSWITCH
  5925                                  %endif
  5926                                  
  5927                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5928                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  5929                                  	; MSDOS 6.0
  5930                                  
  5931                                  ; See if a switch was entered
  5932                                  ;
  5933                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  5934                                  
  5935 000015ED 813E[3D1D][ED1C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  5936 000015F3 742A                    	je	short SetFSwitch		; yes go set fail switch
  5937 000015F5 813E[3D1D][E11C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  5938 000015FB 7431                    	Je	short SetPSwitch		; yes go set up PERMCOM
  5939 000015FD 813E[3D1D][F91C]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  5940 00001603 7453                    	je	short SetDSwitch		; yes go set date switch
  5941 00001605 813E[3D1D][1E1D]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  5942 0000160B 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  5943                                  	; MSDOS 6.0 only!
  5944                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  5945                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  5946 0000160D 813E[3D1D][051D]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  5947 00001613 7467                    	je	short SetESwitch		; yes go set up environment
  5948 00001615 813E[3D1D][2A1D]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  5949                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  5950                                  	; 15/01/2023
  5951 0000161B 74C2                    	je	short SetMSwitch 
  5952 0000161D EB7B                    	jmp	ChkOtherArgs		; Must be something else
  5953                                  
  5954                                  	; MSDOS 6.0
  5955                                  ;SetMSwitchjmp:
  5956                                  	;jmp	SetMSwitch
  5957                                  	
  5958                                  	; MSDOS 6.0
  5959                                  SetFSwitch:
  5960 0000161F 803E[AA01]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  5961                                  	; 16/04/2023
  5962                                  	;jne	short failok		; no - set it
  5963                                  	;;mov	ax,1
  5964                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  5965                                          ;jmp	parse_line_error        ; go issue error 
  5966                                  	; 16/04/2023
  5967 00001624 740F                    	je	short parse_line_error_j
  5968                                  
  5969                                  	; MSDOS 3.3 & MSDOS 6.0
  5970                                  failok:
  5971 00001626 C606[AA01]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  5972                                  	; MSDOS 3.3
  5973                                  	;jmp	short CHKARG
  5974                                  	; MSDOS 6.0
  5975 0000162B E957FF                  	jmp	Parse_command_line
  5976                                  
  5977                                  ;CHECKPSWITCH:
  5978                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  5979                                  	;cmp	al,[letter_p]
  5980                                          ;jnz	short CHECKDSWITCH
  5981                                  
  5982                                  SetPSwitch:
  5983                                  
  5984                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  5985                                  ; termination address.
  5986                                  
  5987                                  	; MSDOS 6.0
  5988 0000162E 803E[A501]00            	cmp	byte [PermCom],0	; has /p switch been set?
  5989 00001633 7406                    	jz	short permcomok		; no - set it
  5990                                  	; 16/04/2023
  5991                                  parse_line_error_j:
  5992                                          ;mov	ax,1
  5993 00001635 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  5994 00001638 E96BFF                          jmp	parse_line_error	; go issue error 
  5995                                  
  5996                                  permcomok:
  5997                                  	; MSDOS 3.3 & MSDOS 6.0
  5998 0000163B FE06[A501]              	inc	byte [PermCom]
  5999                                  	;mov	word [OLDTERM],LODCOM
  6000 0000163F C706[4301][7E00]        	mov	word [OldTerm],LodCom_Trap
  6001                                  	;mov	[OLDTERM+2],ds
  6002 00001645 8C1E[4501]              	mov	[OldTerm+2],ds
  6003                                  
  6004                                  ; make sure that we display the date and time. if the flag was not
  6005                                  ; initialized, set it to indicate yes, do prompt.
  6006                                  
  6007                                  	; MSDOS 3.3
  6008                                  	;cmp	byte [PRDATTM],-1
  6009                                  	;jnz	short CHKARG
  6010                                  	;mov	byte [PRDATTM],0
  6011                                  	;jmp	short CHKARG
  6012                                  
  6013                                  	; MSDOS 6.0
  6014 00001649 803E[741C]FF            	cmp	byte [PRDATTM],-1
  6015 0000164E 7505                    	jne	short Parse_command_line_jmp
  6016 00001650 C606[741C]00            	mov	byte [PRDATTM],0
  6017                                  Parse_command_line_jmp:
  6018 00001655 E92DFF                  	jmp     Parse_command_line	; keep parsing
  6019                                  
  6020                                  ;COMRETURNSJ:
  6021                                  ;	; MSDOS 3.3
  6022                                  ;	JMP	ARGSDONE
  6023                                  
  6024                                  ;CHECKDSWITCH:
  6025                                  	;;cmp	al,'d'
  6026                                          ;cmp	al,[letter_d]
  6027                                  	;jnz	short CHECKCSWITCH
  6028                                  
  6029                                  SetDSwitch:
  6030                                  
  6031                                  ; Flag no date/time prompting.
  6032                                  
  6033                                  	; MSDOS 6.0
  6034 00001658 803E[B31C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6035                                  	; 16/04/2023
  6036                                  	;jz	short setdateok		; no - set it
  6037                                          ;;mov	ax,1
  6038                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6039                                          ;jmp	parse_line_error	; go issue error message
  6040                                  	; 16/04/2023
  6041 0000165D 75D6                    	jnz	short parse_line_error_j
  6042                                  setdateok:
  6043 0000165F FE06[B31C]              	inc	byte  [dswitch]		; indicate /D entered
  6044                                  
  6045                                  	; MSDOS 3.3 & MSDOS 6.0
  6046 00001663 C606[741C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6047                                  	; MSDOS 3.3
  6048                                  	;jmp	short CHKARG
  6049                                  	; MSDOS 6.0
  6050 00001668 E91AFF                  	jmp     Parse_command_line	; continue parsing
  6051                                  
  6052                                  	; 15/01/2023
  6053                                  	; MSDOS 6.0 
  6054                                  ;SetKSwitch:
  6055                                  	;mov	byte [SemiPermCom],0
  6056                                  	;jmp	short SetSorKSwitch
  6057                                  
  6058                                  ;CHECKCSWITCH:
  6059                                  	;;cmp	al,'c'
  6060                                  	;cmp	al,[letter_c]
  6061                                          ;jnz	short CHECKESWITCH
  6062                                  
  6063                                  SetSSwitch:
  6064                                  ;SETCSWITCH:
  6065                                  
  6066                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6067                                  
  6068 0000166B C606[A501]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6069                                  ;SetSorKSwitch:
  6070 00001670 8936[A601]              	mov	[SingleCom],si		; Point to the rest of the command line
  6071 00001674 C606[741C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6072                                  ;COMRETURNSJ: ; 24/09/2018
  6073 00001679 E92201                  	jmp     ArgsDone
  6074                                  
  6075                                  ;CHECKESWITCH:
  6076                                  	;cmp	al,'e'
  6077                                  	;jnz	short CHKARG
  6078                                  
  6079                                  ; Look for environment-size setting switch
  6080                                  
  6081                                  ; The environment size is represented in decimal bytes and is
  6082                                  ; converted into paragraphs (rounded up to the next paragraph).
  6083                                  
  6084                                  SetESwitch:
  6085                                  	; MSDOS 6.0
  6086 0000167C 803E[B21C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6087                                  	; 16/04/2023
  6088                                  	;jz	short eswitchok		; no - set it
  6089                                  	;;mov	ax,1
  6090                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6091                                          ;jmp	parse_line_error	; go issue error message
  6092                                  	; 16/04/2023
  6093 00001681 75B2                    	jnz	short parse_line_error_j
  6094                                  eswitchok:
  6095 00001683 FE06[B21C]              	inc	byte [eswitch]		; indicate /E entered 	
  6096                                  
  6097                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6098                                  %if 0
  6099                                  	; 23/09/2018 - Retro DOS v3.0
  6100                                  
  6101                                  	; MSDOS 3.3
  6102                                  	; (COMMAND.COM offset 0FC5h)
  6103                                  ESWITCHOK:
  6104                                  	jcxz    CHKARG
  6105                                  	dec     cx
  6106                                  	lodsb
  6107                                  	cmp     al,':'
  6108                                  	jnz     short CHECKSWITCHCHR
  6109                                  	xor     bx,bx
  6110                                  	mov     ax,bx
  6111                                  GETENVSIZE:
  6112                                  	jcxz    SETENVSIZE
  6113                                  	dec     cx
  6114                                  	lodsb
  6115                                  	cmp     al,'0'
  6116                                  	jb      short NOTDECIMALCHR
  6117                                  	cmp     al,'9'
  6118                                  	ja      short NOTDECIMALCHR
  6119                                  	sub     al,'0'
  6120                                  	mov     dx,bx
  6121                                  	shl     dx,1
  6122                                  	shl     dx,1   ; dx = 4*bx	
  6123                                  	add     bx,dx  ; bx = 5*bx
  6124                                  	shl     bx,1   ; bx = 10*bx	
  6125                                  	add     bx,ax
  6126                                  	jmp     short GETENVSIZE
  6127                                  
  6128                                  NOTDECIMALCHR:
  6129                                  	;cmp	al,' '
  6130                                  	cmp	al,[SPACE_CHAR]
  6131                                  	jz      short CHECKENVSIZE
  6132                                  	;cmp	al,'/'
  6133                                  	cmp     al,[RSWITCHAR]
  6134                                  	jz      short CHECKENVSIZE
  6135                                  
  6136                                  CHECKNEXTECHR:
  6137                                  	jcxz    INVENVSIZE
  6138                                  	dec     cx
  6139                                  	lodsb
  6140                                  	;cmp	al,' '
  6141                                  	cmp     al,[SPACE_CHR]
  6142                                  	jz      short ENVSIZESPC
  6143                                  	;cmp	al,'/'
  6144                                  	cmp     al,[RSWITCHAR]
  6145                                  	jnz     short CHECKNEXTECHR
  6146                                  
  6147                                  ENVSIZESPC:
  6148                                  	dec     si
  6149                                  	inc     cx
  6150                                  	jmp     short INVENVSIZE
  6151                                  	
  6152                                  	;nop
  6153                                  
  6154                                  CHECKENVSIZE: 
  6155                                  	dec     si
  6156                                  	inc     cx
  6157                                  
  6158                                  SETENVSIZE:
  6159                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6160                                  	mov	word [ENVSIZ],ENVBIG/16
  6161                                  	cmp     bx,32768
  6162                                  	ja      short INVENVSIZE
  6163                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6164                                  	mov	word [ENVSIZ],ENVSML/16
  6165                                  	cmp     bx,160
  6166                                  	jb      short INVENVSIZE
  6167                                  	add     bx,15
  6168                                  	shr     bx,1
  6169                                  	shr     bx,1
  6170                                  	shr     bx,1
  6171                                  	shr     bx,1
  6172                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6173                                  	jmp     short NEXTCH2
  6174                                  
  6175                                  	;nop
  6176                                  
  6177                                  INVENVSIZE:
  6178                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6179                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6180                                  	int     21h             ; DOS - PRINT STRING
  6181                                  				; DS:DX -> string terminated by "$"
  6182                                  NEXTCH2:
  6183                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6184                                  	jmp     CHKARG
  6185                                  
  6186                                  	;jmp	ARGSDONE
  6187                                  
  6188                                  %endif
  6189                                  	; 15/01/2023
  6190                                  	; MSDOS 6.0
  6191                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6192 00001687 BF[3F1D]                        mov	di,COMND1_ADDR
  6193 0000168A 8B1D                    	mov     bx,[di]				; into bx
  6194                                  
  6195 0000168C 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6196 0000168F B104                    	mov	cl,4				; convert to pargraphs
  6197 00001691 D3EB                    	shr	bx,cl				; by right 4
  6198                                  
  6199 00001693 891E[9D1C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6200 00001697 E9EBFE                  	jmp	Parse_command_line		; continue parsing command line
  6201                                  
  6202                                  ; 16/04/2023
  6203                                  %if 0
  6204                                  SetMSwitch:
  6205                                          ;cmp	byte [ext_msg],1
  6206                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6207                                  	jnz	short setMswitchok		; no - set it
  6208                                  	;mov	ax,1
  6209                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6210                                  	jmp	parse_line_error                ; go issue error message
  6211                                  setMswitchok:
  6212                                          ;mov	byte [ext_msg],1
  6213                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6214                                  	jmp	Parse_command_line              ; keep parsing
  6215                                  %endif
  6216                                  
  6217                                  ;ArgsDoneJ:
  6218                                  	;jmp	ArgsDone
  6219                                  
  6220                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6221                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6222                                  	
  6223                                  ChkOtherArgs:
  6224                                  
  6225                                  ; We have a non-switch character here.
  6226                                  
  6227                                  	; MSDOS 6.0
  6228 0000169A 1E                      	push	ds ; ****			;
  6229 0000169B 56                      	push	si ; *** 			; save place in command line
  6230 0000169C C536[3F1D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6231                                  	;assume	ds:nothing			;
  6232                                  
  6233 000016A0 89F2                    	mov	dx,si				; put in dx also
  6234 000016A2 B8023D                  	mov	ax,3D02h
  6235                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6236 000016A5 CD21                    	int	21h
  6237 000016A7 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6238 000016A9 89C3                    	mov	bx,ax
  6239 000016AB B80044                  	mov	ax,4400h
  6240                                  	;mov	ax,IOCTL shl 8
  6241 000016AE CD21                    	int	21h
  6242 000016B0 F6C280                  	test	dl,80h
  6243 000016B3 7506                    	jnz	short IsaDevice
  6244                                  BadSetCon:
  6245 000016B5 B43E                    	mov	ah,3Eh
  6246                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6247 000016B7 CD21                    	int	21h
  6248 000016B9 EB4E                    	jmp	short ChkSrchSpec
  6249                                  
  6250                                  ; 15/01/2023
  6251                                  %if 0
  6252                                  	; MSDOS 3.3
  6253                                  	; (COMMAND.COM offset 1047h)
  6254                                          dec	si
  6255                                  	inc	cx
  6256                                  	mov	dx,si
  6257                                  	push	cx ; **
  6258                                  	push	si ; *
  6259                                  CONTRLOOP:
  6260                                  	lodsb
  6261                                  	dec	cx
  6262                                  	;cmp	al,' '
  6263                                  	cmp	al,[SPACE_CHR]
  6264                                  	jz	short SETCDEV
  6265                                  	cmp	al,9
  6266                                  	jz	short SETCDEV
  6267                                  	jcxz	SETCDEVA
  6268                                  	jmp	short CONTRLOOP
  6269                                  
  6270                                  SETCDEVA:
  6271                                          inc	si
  6272                                  SETCDEV:
  6273                                  	mov	byte [SI-1],0
  6274                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6275                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6276                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6277                                  			; DS:DX -> ASCIZ filename
  6278                                  			; AL = access mode
  6279                                  			; 2 - read & write
  6280                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6281                                          mov	bx,ax
  6282                                          ;mov	ax,IOCTL shl 8
  6283                                          mov     ax,IOCTL*256 ; 4400h
  6284                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6285                                  			; BX = file or device handle
  6286                                          test	dl,80H
  6287                                  	jnz	short ISADEVICE
  6288                                  BADSETCON: ; MSDOS 6.0
  6289                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6290                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6291                                  			; BX = file handle
  6292                                          JMP     short CHKSRCHSPEC
  6293                                  %endif
  6294                                  	;nop
  6295                                  
  6296                                  	; 15/01/2023
  6297                                  IsaDevice:
  6298                                  	; MSDOS 3.3 & MSDOS 6.0
  6299 000016BB 30F6                    	xor	dh,dh
  6300 000016BD 80CA03                  	or	dl,3				; Make sure has CON attributes
  6301                                  	;mov	ax,(IOCTL shl 8) or 1
  6302 000016C0 B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6303 000016C3 CD21                    	int	21h
  6304                                  	;
  6305                                  	; 15/01/2023
  6306 000016C5 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6307                                  	; 25/09/2018
  6308                                  	;pop	dx ; *
  6309                                  	;pop	dx ; **
  6310                                  	;
  6311                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6312                                  	
  6313 000016C7 89DA                    	mov	dx,bx				; Save new handle
  6314                                  
  6315                                  	; MSDOS 6.0
  6316 000016C9 26803E[F120]01          	cmp	byte [es:DevFlag],1
  6317 000016CF 742A                    	jz	short DevErr
  6318                                  
  6319                                  	; MSDOS 3.3
  6320                                          ;pop	bx ; *				; Throw away saved SI
  6321                                          ;pop	bx ; **				; Throw away saved CX
  6322                                  
  6323                                  	; MSDOS 3.3 & MSDOS 6.0
  6324 000016D1 51                      	push	cx ; **
  6325 000016D2 B90300                  	mov	cx,3
  6326 000016D5 31DB                    	xor	bx,bx
  6327                                  
  6328                                  	; 15/01/2023
  6329                                  rcclloop:
  6330 000016D7 B43E                    	mov	ah,3Eh
  6331                                  	;mov	ah,CLOSE ; 3Eh
  6332 000016D9 CD21                    	int	21h
  6333 000016DB 43                      	inc	bx
  6334 000016DC E2F9                    	loop	rcclloop
  6335                                  
  6336 000016DE 89D3                    	mov	bx,dx				; New device handle
  6337 000016E0 B445                    	mov	ah,45h
  6338                                  	;mov	ah,XDUP ; 45h
  6339 000016E2 CD21                    	int	21h				; Dup to 0
  6340 000016E4 B445                    	mov	ah,45h
  6341                                  	;mov	ah,XDUP
  6342 000016E6 CD21                    	int	21h				; Dup to 1
  6343 000016E8 B445                    	mov	ah,45h
  6344                                  	;mov	ah,XDUP
  6345 000016EA CD21                    	int	21h				; Dup to 2
  6346 000016EC B43E                    	mov	ah,3Eh
  6347                                  	;mov	ah,CLOSE
  6348 000016EE CD21                    	int	21h				; Close initial handle
  6349                                  	
  6350 000016F0 59                      	pop	cx ; **
  6351                                  	
  6352                                  	; MSDOS 6.0
  6353 000016F1 5E                      	pop	si ; ***			; restore position of command line
  6354 000016F2 1F                      	pop	ds ; ****			;
  6355                                  
  6356                                  ; Register the fact that we already have redirected the output
  6357                                  ; and can not do it again
  6358                                  
  6359 000016F3 26FE06[F120]            	inc	byte [es:DevFlag]		
  6360 000016F8 E98AFE                  	jmp	Parse_command_line		; continue parsing
  6361                                  
  6362                                  	; MSDOS 3.3
  6363                                  	;jcxz	ARGSDONEJ2
  6364                                  	;jmp	CHKARG
  6365                                  
  6366                                  	; MSDOS 6.0
  6367                                  DevErr:
  6368 000016FB 5E                      	pop	si ; ***
  6369 000016FC 1F                      	pop	ds ; ****
  6370 000016FD BA0100                  	mov	dx,1
  6371 00001700 E8DA02                          call	RPrintParse                     ; "Too many parameters"
  6372 00001703 E887FB                          call	crlf
  6373 00001706 E97CFE                  	jmp	Parse_command_line
  6374                                  
  6375                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6376                                  	; MSDOS 6.0
  6377 00001709 26803E[F220]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6378 0000170F 74EA                            jz	short DevErr			; yes, error
  6379                                  	
  6380 00001711 26FE06[F220]                    inc	byte [es:PathFlag]		; mark that we have a path
  6381                                  
  6382                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6383                                  ; This buffer will later be replaced by a proper environment
  6384                                  
  6385                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6386                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6387 00001716 36A1[3F03]              	mov	ax,[ss:EnvirSeg]
  6388                                  	
  6389                                  	; MSDOS 6.0
  6390                                  	;call	alloc_env                       ; environment buffer
  6391                                  
  6392                                  	; 15/01/2023
  6393                                  	; MSDOS 5.0
  6394 0000171A 36803E[811C]01          	cmp	byte [ss:AllocedEnv],1
  6395 00001720 36C606[811C]00          	mov	byte [ss:AllocedEnv],0
  6396 00001726 7507                    	jne     short env_alloced
  6397 00001728 E88604                  	call	alloc_env
  6398 0000172B 36A3[3F03]              	mov	[ss:EnvirSeg],ax
  6399                                  
  6400                                  env_alloced:
  6401                                  	; MSDOS 5.0 & MSDOS 6.0
  6402 0000172F 8EC0                    	mov	es,ax
  6403                                  	;assume	es:nothing
  6404 00001731 56                      	push	si ; **				; remember location of file
  6405 00001732 31C9                    	xor	cx,cx				; clear cx for counting
  6406                                  	
  6407                                  	; 15/01/2023
  6408                                  countloop:
  6409 00001734 AC                      	lodsb					; get a character
  6410 00001735 41                      	inc	cx				; increment counter
  6411                                          ;;cmp	al,0
  6412                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6413                                  	;jne	short countloop			; no - keep counting
  6414 00001736 08C0                    	or	al,al	
  6415 00001738 75FA                    	jnz	short countloop
  6416                                  
  6417                                  	;;;;mov	al,[Space]
  6418                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6419                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6420                                  	; 16/04/2023
  6421                                  	;mov	al,20h ; ' ' 
  6422 0000173A 4E                      	dec	si				; move back one
  6423                                          ;mov	[si],al				; put a space at end of line
  6424 0000173B C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6425                                  
  6426                                  ; We now know how long the new pathspec for command.com is. Time to
  6427                                  ; figure out how long the current COMSPEC setting is, and then to move
  6428                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6429                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6430                                  ; where the filespec exists in the environment) is updated as well.
  6431                                  
  6432                                  	; MSDOS 6.0 COMMAND.COM
  6433                                  	;push	cx                              ;
  6434                                          ;mov	cx,ENVBIG                       ;
  6435                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6436                                          ;mov	al,0                            ;
  6437                                          ;repne	scasb                           ; find the end of COMSPEC
  6438                                          ;mov	si,di                           ;
  6439                                  ;comp_endenv:                                   ;
  6440                                          ;scasb                                  ; end of env?
  6441                                          ;je	got_endenv                      ; yes
  6442                                          ;repne	scasb                           ;
  6443                                          ;jmp	comp_endenv                     ;
  6444                                  ;got_endenv:                                    ;
  6445                                          ;mov    cx,di                           ;
  6446                                          ;sub    cx,si                           ;
  6447                                          ;mov    di,ComspOffset                  ;
  6448                                          ;sub    di,ComspStrLen                  ;
  6449                                          ;push   ds                              ;
  6450                                          ;push   es                              ;
  6451                                          ;pop    ds                              ;
  6452                                          ;rep    movsb                           ;
  6453                                          ;dec    di                              ; copy in new COMSPEC=
  6454                                          ;push   cs                              ;
  6455                                          ;pop    ds                              ;
  6456                                          ;assume ds:ResGroup                     ;
  6457                                          ;mov    si,offset RESGROUP:ComspString  ;
  6458                                          ;mov    cx,ComspStrLen                  ;
  6459                                          ;rep    movsb                           ;
  6460                                          ;mov    ComspOffset,di                  ;
  6461                                          ;pop    ds                              ;
  6462                                          ;assume ds:nothing                      ;
  6463                                          ;pop    cx                              ;
  6464                                  	;
  6465                                          ;pop    si                              ; get new comspec location back
  6466                                  
  6467                                  	; MSDOS 3.3 COMMAND.COM
  6468                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6469                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6470                                  	;mov	cl,4
  6471                                  	;shr	ax,cl
  6472                                  	;mov	dx,ds
  6473                                  	;add	ax,dx
  6474                                  	;mov	[ENVIRSEG],ax
  6475                                  	;mov	es,ax
  6476                                  	;;mov	al,' '
  6477                                  	;mov	al,[SPACE_CHR]
  6478                                  	;mov	[si-1],al
  6479                                  	;pop	si ; **				; Remember location
  6480                                  	;pop	cx ; *				; and count
  6481                                  	;;mov	di,[ECOMLOC]
  6482                                  	;mov	di,[COMSPOFFSET]
  6483                                  
  6484                                  	; 15/01/2023
  6485                                  	; MSDOS 5.0 COMMAND.COM
  6486 0000173E 5E                      	pop	si ; **
  6487                                  	;mov	di,14
  6488 0000173F BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6489                                  
  6490                                  ComtrLoop:
  6491                                  	; MSDOS 3.3 & MSDOS 6.0
  6492 00001742 AC                      	lodsb
  6493 00001743 49                      	dec	cx
  6494                                  	;;;;cmp	al,' '
  6495                                  	;;;cmp	al,[space_chr]
  6496                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6497                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6498                                  	; 16/04/2023
  6499 00001744 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6500 00001746 7405                    	je	short SetComsr
  6501                                  	; MSDOS 3.3
  6502                                  	;cmp	al,9
  6503                                  	;je	short SetComsr
  6504                                  	; MSDOS 3.3 & MSDOS 6.0
  6505 00001748 AA                      	stosb
  6506 00001749 E302                    	jcxz	SetComsr
  6507 0000174B EBF5                    	jmp	short ComtrLoop
  6508                                  
  6509                                  SetComsr:
  6510                                  	; 15/01/2023
  6511                                  	; MSDOS 6.0
  6512 0000174D 51                      	push	cx ; **
  6513 0000174E 0E                      	push	cs				; Get local segment
  6514 0000174F 1F                      	pop	ds				;
  6515                                  	;assume	ds:ResGroup			;
  6516 00001750 1E                      	push	ds ; *
  6517                                  	;mov	si,offset ResGroup:ComSpect
  6518 00001751 BE[551C]                	mov	si,COMSPECT
  6519 00001754 B90E00                  	mov	cx,14
  6520 00001757 268A45FF                	mov	al,[es:di-1]
  6521 0000175B 3A06[5403]              	cmp	al,[RDirChar]
  6522 0000175F 7502                    	jne	short iNotRoot
  6523 00001761 46                      	inc	si				; Don't make a double /
  6524 00001762 49                      	dec	cx
  6525                                  	
  6526                                  	; MSDOS 3.3
  6527                                  	;push	si
  6528                                  	;push	cx
  6529                                  	;push	ds
  6530                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6531                                  	;mov	cx,14
  6532                                  	;mov	al,[es:di-1]
  6533                                  	;call	PATHCHRCMPR
  6534                                  	;jnz	short INOTROOT			
  6535                                  	;inc	si				; Don't make a double /
  6536                                  	;dec	cx
  6537                                  
  6538                                  iNotRoot:
  6539                                  	; MSDOS 3.3 & MSDOS 6.0
  6540 00001763 F3A4                    	rep	movsb
  6541                                  
  6542                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6543                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6544                                  	; 15/01/2023
  6545                                  	;mov	dx,14
  6546 00001765 BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6547                                  
  6548 00001768 06                      	push	es
  6549 00001769 1F                      	pop	ds
  6550                                  	;;mov	ax,OPEN shl 8
  6551                                  	;mov	ax,OPEN*256 ; 3D00h
  6552 0000176A B8003D                  	mov	ax,3D00h ; 15/01/2023
  6553 0000176D CD21                    	int	21h				; Open COMMAND.COM
  6554 0000176F 1F                      	pop	ds ; *
  6555 00001770 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6556 00001772 89C3                    	mov	bx,ax				; Handle
  6557 00001774 B43E                    	mov	ah,3Eh ; 15/01/2023
  6558                                  	;mov	ah,CLOSE ; 3Eh
  6559 00001776 CD21                    	int	21h				; Close COMMAND.COM
  6560                                  SetComsrRet:
  6561                                  	; 15/01/2023
  6562 00001778 59                      	pop	cx ; **
  6563 00001779 5E                      	pop	si ; ***
  6564                                  
  6565                                  	; MSDOS 6.0
  6566 0000177A 1F                      	pop	ds ; ****			;
  6567                                  	;assume	ds:ResGroup			;
  6568                                  	;
  6569 0000177B 0E                      	push	cs				; Make sure local ES is
  6570 0000177C 07                      	pop	es				;  restored
  6571 0000177D E905FE                  	jmp	Parse_command_line		; continue parsing command line
  6572                                  
  6573                                  	; MSDOS 3.3
  6574                                  ;ARGSDONEJ2:
  6575                                  	;jcxz	ARGSDONE
  6576                                  	;jmp	CHKARG
  6577                                  
  6578                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6579                                  SetComsrBad:
  6580                                  	; MSDOS 3.3 & MSDOS 6.0
  6581                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6582 00001780 BA[DA1D]                	mov	dx,BADCOMLKMES
  6583                                  
  6584                                  ;	Note: we're about to make a near call to TriageError, which
  6585                                  ;	lives in a different segment and group. Some linkers will
  6586                                  ;	generate a warning like "Possible fix-up overflow". We're
  6587                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6588                                  ;	we're still all together.
  6589                                  
  6590                                  	; 16/01/2023
  6591                                  	TRIAGEERROR equ TRANSTART+TriageError
  6592                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6593                                  
  6594                                  	;call	50B2h
  6595 00001783 E8(BB4E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6596                                  				; in original MSDOS 3.3 COMMAND.COM
  6597                                  
  6598                                  			; TriageError procedure is at offset 50B2h
  6599                                  			; in original MSDOS 5.0 COMMAND.COM	
  6600 00001786 83F841                  	cmp	ax,65
  6601 00001789 7503                    	jne	short doprt
  6602                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6603 0000178B BA[031E]                	mov	dx,BADCOMACCMSG
  6604                                  doprt:
  6605 0000178E E8FFFA                  	call	RPrint
  6606                                  	;mov	si,offset ResGroup:ComSpect
  6607 00001791 BE[551C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6608                                  	;;mov	di,[ECOMLOC]
  6609                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6610                                  	; 16/01/2023
  6611 00001794 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6612 00001797 B90E00                  	mov	cx,14
  6613 0000179A F3A4                    	rep	movsb				; get my default back
  6614                                  
  6615 0000179C EBDA                    	jmp	short SetComsrRet
  6616                                  
  6617                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6618                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6619                                  ArgsDone:
  6620                                  	; MSDOS 6.0
  6621 0000179E 8E06[3F03]              	mov	es,[EnvirSeg]			; get environment back
  6622                                  	;assume	es:nothing			;
  6623                                  
  6624                                  	; MSDOS 3.3 & MSDOS 6.0
  6625 000017A2 803E[A501]00                    cmp	byte [PermCom],0
  6626 000017A7 742E                            jz	short ComReturns
  6627                                  
  6628 000017A9 06                      	push	es				; Save environment pointer
  6629 000017AA B450                    	mov	ah,50h
  6630                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6631 000017AC 8CDB                    	mov	bx,ds
  6632 000017AE 8EC3                    	mov	es,bx
  6633 000017B0 CD21                    	int	21h				; current process is me
  6634 000017B2 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6635                                  	;;mov	ax,offset RESGROUP:LODCOM
  6636                                  	;mov	ax,LODCOM
  6637                                  	; 16/01/2023
  6638 000017B5 B8[7E00]                	mov	ax,LodCom_Trap
  6639 000017B8 AB                              stosw
  6640 000017B9 8CD8                            mov	ax,ds
  6641 000017BB AB                              stosw
  6642                                  	;;mov	ax,offset RESGROUP:CONTC
  6643                                  	;mov	ax,CONTC
  6644                                  	; 16/01/2023
  6645 000017BC B8[4A00]                	mov	ax,Ctrlc_Trap
  6646 000017BF AB                              stosw
  6647 000017C0 8CD8                            mov	ax,ds
  6648 000017C2 AB                              stosw
  6649                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6650                                  	;mov	ax,CRITERR
  6651                                  	; 16/01/2023
  6652 000017C3 B8[5500]                	mov	ax,CritErr_Trap
  6653 000017C6 AB                      	stosw
  6654 000017C7 8CD8                    	mov     ax,ds
  6655 000017C9 AB                      	stosw
  6656                                  	;;mov	word ptr ds:16h,ds
  6657                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6658 000017CA 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6659                                          ;;mov	dx,offset RESGROUP:Int_2e
  6660                                  	;mov	dx,Int_2e
  6661                                          ; 16/01/2023
  6662 000017CE BA[3F00]                	mov	dx,Int2e_Trap
  6663 000017D1 B82E25                  	mov	ax,252Eh
  6664                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6665                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6666 000017D4 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6667                                  			; AL = interrupt number
  6668                                  			; DS:DX = new vector to be used for specified interrupt
  6669 000017D6 07                              pop	es				; Remember environment
  6670                                  	
  6671                                  ComReturns:
  6672                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6673 000017D7 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6674                                  	; 16/01/2023
  6675 000017DA A3[4101]                	mov	[Parent],ax			; Save parent
  6676                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6677 000017DD 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6678                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6679 000017E1 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6680 000017E4 A3[A201]                        mov	[Io_Save],ax		; Get the default stdin and out
  6681 000017E7 8C1E[4303]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6682 000017EB 8C1E[4703]                      mov	[Com_Fcb1+2],ds
  6683 000017EF 8C1E[4B03]              	mov	[Com_Fcb2+2],ds
  6684                                          ;mov	di,offset ResGroup:ComSpec
  6685 000017F3 BF[4E01]                        mov	di,ComSpec
  6686                                  
  6687                                  	;;mov	si,[ECOMLOC]
  6688                                  	; 16/01/2023
  6689                                  	;mov	si,[ComspOffset]
  6690 000017F6 BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6691 000017F9 803E[811C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6692                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6693                                  	
  6694 000017FE 8CD8                    	mov	ax,ds				; Xchg es,ds
  6695 00001800 06                      	push	es
  6696 00001801 1F                      	pop	ds
  6697 00001802 8EC0                    	mov	es,ax
  6698                                  
  6699                                  	;jne	short CopyComsp ; MSDOS 6.0
  6700                                  	; 16/01/2023	
  6701 00001804 7417                    	je	short CopyComsp ; MSDOS 5.0
  6702                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6703                                  
  6704 00001806 0E                              push	cs
  6705 00001807 1F                              pop	ds
  6706                                  
  6707                                          ;mov	si,offset ResGroup:ComspString
  6708 00001808 BE[881C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6709 0000180B 06                      	push	es
  6710 0000180C 57                      	push	di
  6711 0000180D E8DE01                  	call	IfindE
  6712 00001810 89FE                    	mov	si,di
  6713 00001812 06                      	push	es
  6714 00001813 1F                      	pop	ds
  6715 00001814 5F                      	pop	di
  6716 00001815 07                      	pop	es
  6717 00001816 7305                            jnc	short CopyComsp
  6718                                  
  6719                                  	; MSDOS 6.0
  6720                                  ComSpecNofnd:
  6721                                  	;mov	si,offset ResGroup:ComspString
  6722                                  	;add	si,ComspStrLen
  6723                                  	;push	cs
  6724                                  	;pop	ds
  6725                                  
  6726                                  	; 21/01/2023
  6727                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6728                                  	;mov	si,0Eh
  6729 00001818 BE0E00                  	mov	si,ECOMSPEC
  6730 0000181B 0E                      	push	cs
  6731 0000181C 1F                      	pop	ds	
  6732                                  
  6733                                  	; 21/01/2023
  6734                                  ;COMSPECNOFND:
  6735                                  	; MSDOS 3.3
  6736                                          ;;mov	si,[es:ECOMLOC]
  6737                                          ;mov	si,[es:COMSPOFFSET]
  6738                                  	;;add	si,offset RESGROUP:PATHSTRING
  6739                                          ;add	si,PATHSTRING ; "PATH="
  6740                                  	;push	cs
  6741                                  	;pop	ds
  6742                                  
  6743                                  CopyComsp:
  6744                                  	; 21/01/2023
  6745                                  ;COPYCOMSP:
  6746                                  	; MSDOS 3.3 & MSDOS 6.0
  6747                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6748                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6749 0000181D 26893E[2D01]            	mov	[es:PutBackComSpec],di
  6750 00001822 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6751 00001826 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6752                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6753                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6754 00001828 268306[2D01]02          	add	word [es:PutBackComSpec],2
  6755                                  CopyComspLoop:
  6756 0000182E AC                      	lodsb
  6757 0000182F AA                      	stosb
  6758 00001830 08C0                    	or	al,al
  6759 00001832 75FA                    	jnz	short CopyComspLoop
  6760                                  
  6761 00001834 26893E[8E01]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6762 00001839 26FF0E[8E01]            	dec	word [es:ComSpec_End]
  6763 0000183E 268A26[9701]            	mov	ah,[es:ComDrv]
  6764 00001843 80C440                  	add	ah,'A'-1 ; 40h
  6765 00001846 268826[3201]            	mov	[es:PutBackDrv],ah		; save drive letter
  6766                                  
  6767                                  	; -------------------------------
  6768                                  
  6769                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6770                                  %if 0
  6771                                  
  6772                                  	; MSDOS 3.3
  6773                                  	push	cs
  6774                                          pop	ds
  6775                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6776                                  	mov	bx,DATARESEND+15
  6777                                          mov	cl,4
  6778                                          shr	bx,cl
  6779                                          MOV     AH,SETBLOCK ; 4Ah
  6780                                          int	21h			; Shrink me to the resident only
  6781                                  
  6782                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6783                                  
  6784                                  	mov	byte [TRNMVFLG], 1
  6785                                  	push	es ; *
  6786                                  	mov	si,TRANSTART
  6787                                  	mov	di,0
  6788                                  	mov	es,[TrnSeg]
  6789                                  	;mov	cx,4D5Ch
  6790                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6791                                  	push	cx
  6792                                  	mov	ax,cx
  6793                                  	add	ax,si
  6794                                  	mov	cl,4
  6795                                  	shr	ax,cl
  6796                                  	inc	ax
  6797                                  	mov	cx,ds
  6798                                  	add	ax,cx
  6799                                  	cmp	ax,[TrnSeg]
  6800                                  	pop	cx
  6801                                  	jb	short MOV_DOWN
  6802                                  
  6803                                  	call	LOADCOM
  6804                                  	jmp	short ICHKSUM
  6805                                  
  6806                                  MOV_DOWN:
  6807                                  	add     si,cx
  6808                                  	dec     si
  6809                                  	add     di,cx
  6810                                  	dec     di
  6811                                  	std
  6812                                  	rep	movsb
  6813                                  	cld
  6814                                  
  6815                                  ICHKSUM:
  6816                                  	; 24/09/2018
  6817                                  ;
  6818                                  ; Compute checksum right now before we can get corrupted and save it
  6819                                  ;
  6820                                  	; MSDOS 6.0
  6821                                  	;mov	si,offset RESGROUP:TranStart
  6822                                  	;add	si,100h
  6823                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6824                                  	;
  6825                                  	;cld
  6826                                  	;shr	cx,1
  6827                                  	;xor	dx,dx
  6828                                  ;Ichksum:
  6829                                  	;lodsw
  6830                                  	;add	dx,ax
  6831                                  	;adc	dx,0
  6832                                  	;loop	Ichksum
  6833                                  	;
  6834                                          ;mov	Sum,dx			; store checksum
  6835                                  
  6836                                  	; MSDOS 3.3
  6837                                  	pop     es ; *
  6838                                  	call    CHKSUM
  6839                                  	mov     [SUM],dx
  6840                                  
  6841                                  	; MSDOS 3.3 & MSDOS 6.0
  6842                                          cmp     byte [PRDATTM],0	;
  6843                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6844                                  ;
  6845                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6846                                  ;
  6847                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6848                                  	;mov	bx,3
  6849                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6850                                          mov     ah,ALLOC ; 48h		;
  6851                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6852                                  			; BX = number of 16-byte paragraphs desired
  6853                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6854                                          mov     [BATCH],ax		; save batch segment
  6855                                  
  6856                                  NOBATCHSEG:
  6857                                  
  6858                                  %endif
  6859                                  	; -------------------------------
  6860                                  
  6861                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6862                                  	
  6863                                  	; MSDOS 6.0
  6864 0000184B E81702                  	call	setup_for_messages		; set up parse and extended error messages
  6865                                  
  6866                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6867                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6868                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6869                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6870                                  ; the data otherwise it is just the data.
  6871                                   
  6872 0000184E E8B102                  	call	Setup_res_end			; put resident size in ResSize
  6873                                  
  6874 00001851 0E                      	push	cs
  6875 00001852 1F                      	pop	ds
  6876                                  	;assume	ds:RESGROUP
  6877                                  
  6878                                  ;Public EnvMaximum
  6879                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6880                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6881                                  
  6882                                  	; 21/01/2023
  6883                                  	; MSDOS 6.0
  6884                                  	;;mov	si,offset RESGROUP:TranStart
  6885                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6886                                  	;mov	si,TRANSTART
  6887                                  	;add	si,100h
  6888                                  	; 23/04/2023
  6889 00001853 BE3023                  	mov	si,TRANSTART+100h
  6890                                  
  6891                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6892                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6893 00001856 B9[0B85]                	mov	cx,TRANDATAEND-100h
  6894                                  
  6895 00001859 FC                      	cld
  6896 0000185A D1E9                    	shr	cx,1
  6897 0000185C 31D2                    	xor	dx,dx
  6898                                  Ichksum:
  6899 0000185E AD                      	lodsw
  6900 0000185F 01C2                    	add	dx,ax
  6901 00001861 83D200                  	adc	dx,0
  6902 00001864 E2F8                    	loop	Ichksum
  6903                                  
  6904 00001866 8916[9A01]                      mov	[Sum],dx			; store checksum
  6905                                  
  6906 0000186A 803E[741C]00                    cmp     byte [PRDATTM],0
  6907 0000186F 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6908                                  	
  6909                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6910                                  
  6911                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6912                                  	; 21/01/2023
  6913                                  	;mov	bx,4
  6914 00001871 BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  6915 00001874 B448                    	mov	ah,48h
  6916                                  	;mov	ah,ALLOC                        ;
  6917 00001876 CD21                            int	21h                             ;
  6918 00001878 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  6919 0000187A A3[4C01]                        mov	[Batch],ax			; save batch segment
  6920                                  
  6921                                  NoBatchSeg:
  6922                                  
  6923                                  ; 21/01/2023
  6924                                  %if 0
  6925                                  	; MSDOS 3.3
  6926                                  	mov     bx,0FFFFh ; 65535
  6927                                  	mov     ah,ALLOC ; 48h
  6928                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6929                                  			; BX = number of 16-byte paragraphs desired
  6930                                  	sub     bx,[TRNSIZE]
  6931                                  	sub     bx,128
  6932                                  	mov     [ENVMAX],bx
  6933                                  
  6934                                  	cmp     bx,4096
  6935                                  	jb      short ALLOCENVIRSEG
  6936                                  	mov     bx,4096-1		; max. allowed environment size
  6937                                  	mov     [ENVMAX],bx
  6938                                  
  6939                                  ALLOCENVIRSEG:
  6940                                  	mov     ah,ALLOC ; 48h
  6941                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6942                                  			; BX = number of 16-byte paragraphs desired
  6943                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  6944                                  	mov     [OLDENV],bx		; save it	
  6945                                  	mov     word [USEDENV],0	; initialize environment size counter
  6946                                  	mov     ds,bx
  6947                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  6948                                  	mov     es,ax
  6949                                  	xor     si,si
  6950                                  	mov     di,si
  6951                                  	mov     bx,[ss:ENVMAX]
  6952                                  	shl     bx,1
  6953                                  	shl     bx,1
  6954                                  	shl     bx,1
  6955                                  	shl     bx,1
  6956                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  6957                                  	dec     bx			; dec by one to leave room for double 0
  6958                                  	xor     dx,dx			; use dx to indicate that there was
  6959                                  					; no environment size error.
  6960                                  
  6961                                  NXSTR:
  6962                                  	call    GETSTRLEN		; get the size of the current env string
  6963                                  
  6964                                  	push    ds
  6965                                  	push    cs
  6966                                  	pop     ds
  6967                                  	add     [USEDENV],cx		; add the string length to env size
  6968                                  	pop     ds
  6969                                  	cmp     cx,1			; end of environment was encountered.
  6970                                  	je      short ENVEXIT
  6971                                  	sub     bx,cx
  6972                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  6973                                  	inc     dx			; out of env space msg must be displayed
  6974                                  	jmp     short ENVEXIT
  6975                                  
  6976                                  	;nop
  6977                                  
  6978                                  OKCPYSTR:
  6979                                  	jmp     short NXSTR
  6980                                  
  6981                                  ENVEXIT: 
  6982                                  	push    cs
  6983                                  	pop     ds
  6984                                  	or      dx, dx			; dx will be non-zero if error
  6985                                  	jz      short ENVNOERR
  6986                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  6987                                  	call    RPRINT
  6988                                  
  6989                                  %endif
  6990                                  
  6991                                  	; 21/01/2023
  6992                                  	; MSDOS 6.0 (& MSDOS 5.0)
  6993 0000187D 8B1E[3F03]              	mov	bx,[EnvirSeg]			; get old environment segment
  6994 00001881 891E[A11C]              	mov	[OldEnv],bx			; save it
  6995 00001885 C706[A31C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  6996 0000188B 8EDB                    	mov	ds,bx
  6997                                  	;assume	ds:nothing
  6998                                  	
  6999 0000188D 31F6                    	xor	si,si
  7000 0000188F 89F7                    	mov	di,si
  7001                                  
  7002                                  ; This is the maximum allowed size for the environment
  7003                                  
  7004                                  	; 21/01/2023
  7005                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7006                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7007                                  	;;mov	[ss:EnvMax],bx
  7008                                  	;shl	bx,1
  7009                                  	;shl	bx,1
  7010                                  	;shl	bx,1
  7011                                  	;shl	bx,1
  7012 00001891 BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7013 00001894 36891E[9F1C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7014 00001899 4B                      	dec	bx				; dec by one to leave room for double 0
  7015 0000189A 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7016                                  						; no environment size error.
  7017                                  ;public NxtStr
  7018                                  NxtStr:
  7019 0000189C E82501                  	call	GetStrLen			; get the size of the current env string
  7020                                  
  7021                                  ;Bugbug: Can use ss here to address UsedEnv
  7022                                  
  7023 0000189F 1E                      	push	ds                              ; get addressability to environment
  7024 000018A0 0E                              push	cs                              ;                       counter
  7025 000018A1 1F                              pop	ds                              ;
  7026                                  	;assume	ds:ResGroup
  7027 000018A2 010E[A31C]                      add	[UsedEnv],cx			; add the string length to env size
  7028 000018A6 1F                      	pop	ds                              ;
  7029                                  	;assume	ds:nothing
  7030                                  	
  7031 000018A7 83F901                  	cmp	cx,1				; end of environment was encountered.
  7032 000018AA 7405                    	je	short EnvExit
  7033 000018AC 29CB                    	sub	bx,cx
  7034                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7035                                  	; 21/01/2023
  7036 000018AE 73EC                    	jae	short NxtStr
  7037 000018B0 42                      	inc	dx				; out of env space msg must be displayed
  7038                                  	;jmp	short EnvExit
  7039                                  
  7040                                  ;OkCpyStr:
  7041                                  	;jmp	short NxtStr
  7042                                  
  7043                                  EnvExit:
  7044 000018B1 0E                      	push	cs
  7045 000018B2 1F                      	pop	ds
  7046                                  	;assume	ds:ResGroup
  7047 000018B3 09D2                    	or	dx,dx				; dx will be non-zero if error
  7048 000018B5 7406                    	jz	short EnvNoErr
  7049                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7050 000018B7 BA[601D]                	mov	dx,OUTENVMSG
  7051 000018BA E8D3F9                  	call 	RPrint
  7052                                  EnvNoErr:
  7053 000018BD A1[9D1C]                	mov	ax,[EnvSiz]			; env size previously set
  7054 000018C0 B104                    	mov	cl,4
  7055 000018C2 D3E0                    	shl	ax,cl				; get size in bytes
  7056 000018C4 3B06[A31C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7057 000018C8 7706                    	ja	short st_envsize		; yes, store the size
  7058 000018CA A1[A31C]                	mov	ax,[UsedEnv]
  7059 000018CD 83C00F                  	add	ax,15				; round up
  7060                                  st_envsize:	
  7061 000018D0 D3E8                    	shr	ax,cl
  7062 000018D2 A3[9D1C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7063                                  
  7064                                  ;if MSVER
  7065                                  	;cmp	SingleCom,0
  7066                                  	;jnz	nophead 			; don't print header if SingleCom
  7067                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7068                                  	;call	RPrint
  7069                                  ;nophead:
  7070                                  ;endif
  7071                                  
  7072                                  ; 21/01/2023
  7073                                  %if 0
  7074                                  	; MSDOS 3.3
  7075                                  ENVNOERR:
  7076                                  	mov     cx,[ENVMAX]
  7077                                  	sub     cx,bx			; current environment size in bytes
  7078                                  	add     cx,16			; add memory arena to the size
  7079                                  	shr     cx,1
  7080                                  	shr     cx,1
  7081                                  	shr     cx,1
  7082                                  	shr     cx,1			; convert current env size to paragraphs
  7083                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7084                                  	;jb	short SET_ENVSIZE
  7085                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7086                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7087                                  
  7088                                  SET_ENVSIZE:
  7089                                  	mov     bx,[ENVSIZ]
  7090                                  	mov     ax,es
  7091                                  	add     ax,bx			; get end segment of environemnt
  7092                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7093                                  	ja      short NOPHEAD
  7094                                  					; free unused paragraghs		
  7095                                  	mov     ax,es
  7096                                  	mov     bx,[INITEND]
  7097                                  	sub     bx,ax
  7098                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7099                                  	mov	word [RESETENV],1	; environment segment reset sign
  7100                                  
  7101                                  NOPHEAD:
  7102                                  	; MSDOS 3.3
  7103                                  	mov     ah,SETBLOCK ; 4Ah
  7104                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7105                                  			; ES = segment address of block to change
  7106                                  			; BX = new size in paragraphs
  7107                                  %endif
  7108                                  	; 21/01/2023
  7109                                  
  7110                                  	; MSDOS 3.3 & 6.0
  7111 000018D5 833E[4C01]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7112 000018DA 7503                    	jnz     short DoDate		; yes - go initialize it
  7113 000018DC E99500                  	jmp     NoDttm			; don't do autoexec or date time
  7114                                  
  7115                                  DoDate:
  7116                                  
  7117                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7118                                  
  7119 000018DF A1[4C01]                	mov	ax,[Batch]		; get batch segment
  7120 000018E2 C606[A001]03            	mov	byte [EchoFlag],3	; set batch echo
  7121 000018E7 C706[AF01]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7122 000018ED 8EC0                    	mov	es,ax
  7123                                  
  7124                                  ; initialize the segment
  7125                                  
  7126 000018EF 31FF                    	xor	di,di
  7127                                  	;;mov	al,0
  7128                                  	;mov	al,BATCHTYPE ; 0
  7129                                  	; 06/06/2023
  7130 000018F1 31C0                    	xor	ax,ax
  7131 000018F3 AA                      	stosb
  7132                                  	;mov	al,1			; initialize echo for batch exit
  7133 000018F4 FEC0                    	inc	al
  7134 000018F6 AA                      	stosb
  7135                                  
  7136                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7137                                  
  7138                                  	;xor	ax,ax			; initialize to zero
  7139                                  	; 06/06/2023
  7140 000018F7 FEC8                    	dec	al ; ax = 0	
  7141                                  
  7142                                  	; 21/01/2023
  7143 000018F9 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7144                                  
  7145 000018FA AB                      	stosw				; batch segment of last job - batlast
  7146 000018FB AB                      	stosw				; segment for FOR
  7147 000018FC AA                      	stosb				; FOR flag
  7148 000018FD AB                      	stosw				; position in file - batseek
  7149 000018FE AB                      	stosw
  7150                                  
  7151                                  ; clean out the parameters
  7152                                  
  7153                                  	;mov	ax,-1			; initialize to no parameters
  7154                                  	; 06/06/2023
  7155 000018FF 48                      	dec	ax ; ax = -1
  7156                                  
  7157 00001900 B90A00                  	mov	cx,10
  7158 00001903 F3AB                    	rep	stosw
  7159                                  
  7160                                  ; decide whether we should grab the default drive
  7161                                  
  7162 00001905 803E[631C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7163 0000190A 7509                    	jne	short NoAutSet
  7164 0000190C B419                    	mov	ah,19h	; 21/01/2023
  7165                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7166 0000190E CD21                    	int	21h
  7167                                  	;;add	al,'A'
  7168                                  	;add	al,[letter_A] ; Ucasea
  7169                                  	;add	al,[ucasea] ; 21/01/2023
  7170                                  	; 21/01/2023
  7171 00001910 0441                    	add	al,'A'
  7172 00001912 A2[631C]                	mov	[AUTOBAT],al
  7173                                  	; 21/01/2023
  7174                                  	;mov	[KAUTOBAT],al
  7175                                  NoAutSet:
  7176                                  
  7177                                  ; copy in the batch file name (including nul)
  7178                                  
  7179                                  	;mov	si,offset ResGroup:AutoBat
  7180 00001915 BE[631C]                	mov	si,AUTOBAT
  7181 00001918 B90800                  	mov	cx,8
  7182 0000191B F3A5                    	rep	movsw
  7183                                  	; 23/04/2023
  7184 0000191D A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7185                                  
  7186                                  	;mov	dx,offset ResGroup:AutoBat
  7187 0000191E BA[631C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7188                                  
  7189                                  	;;mov	ax,OPEN shl 8
  7190 00001921 B8003D                  	mov	ax,3D00h ; 21/01/2023
  7191                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7192 00001924 CD21                    	int	21h			; see if autoexec.bat exists
  7193 00001926 7208                    	jc	short noabat
  7194 00001928 89C3                    	mov	bx,ax
  7195 0000192A B43E                    	mov	ah,3Eh ; 21/01/2023
  7196                                  	;mov	ah,CLOSE  ; 3Eh
  7197 0000192C CD21                    	int	21h
  7198 0000192E EB51                    	jmp	short Drv0		; go process autoexec
  7199                                  
  7200                                  noabat:
  7201 00001930 50                      	push	ax
  7202 00001931 E89900                  	call	Setup_Seg
  7203 00001934 A3[7F1C]                	mov	[triage_add+2],ax
  7204 00001937 58                      	pop	ax
  7205 00001938 FF1E[7D1C]              	call	far [triage_add]	; get extended error
  7206 0000193C 83F841                  	cmp	ax,65			; network access denied?
  7207                                  	;jne	short OPENERR		; no - go deallocate batch
  7208                                  	; 21/01/2023
  7209                                  	;je	short AccDenErr
  7210 0000193F 7506                    	jne	short OpenErr 
  7211                                  
  7212                                  	; 21/01/2023
  7213                                  ;_ACCDENERROR:					; yes - put out message
  7214                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7215                                  ;	mov	dx,ACCDENERR
  7216                                  ;	call	RPRINT
  7217                                  
  7218                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7219                                  
  7220                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7221                                  
  7222                                  ; 21/01/2023
  7223                                  %if 0
  7224                                  
  7225                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7226                                  ; by Ellen to check only when in Korea. The country information
  7227                                  ; returned will overlay the old parse data area, but we don't care
  7228                                  ; since we won't need the parse information or country information.
  7229                                  ; We only care about the country code returned in BX.
  7230                                  
  7231                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7232                                  
  7233                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7234                                  	mov	dx,INTERNAT_INFO
  7235                                  	mov	ax,3800h
  7236                                  	;mov	ax,INTERNATIONAL<<8
  7237                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7238                                  	int	21h				;
  7239                                  	jc	short NoKabat 			; error - don't bother with it
  7240                                  	cmp	bx,52h
  7241                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7242                                  	jnz	short OpenErr 			; no, don't check for kautoexe
  7243                                  
  7244                                  	;mov	di,BatFile			; 3/3/kk
  7245                                  	mov	di,20h
  7246                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7247                                  	mov	si,KAUTOBAT
  7248                                  	mov	cx,8				; auto execution for the 3/3/kk
  7249                                  	rep	movsw				; non-english country	3/3/kk
  7250                                  	movsb					; move in carraige return to terminate string
  7251                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7252                                  	mov	dx,KAUTOBAT
  7253                                  	mov	ax,3D00h
  7254                                  	;mov	ax,OPEN<<8
  7255                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7256                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7257                                  	jc	short NoKabat 			; 3/3/kk
  7258                                  	mov	bx,ax				; 3/3/kk
  7259                                  	mov	ah,3Eh
  7260                                  	;mov	ah,CLOSE			; 3/3/kk
  7261                                  	int	21h				; 3/3/kk
  7262                                  	jmp	short Drv0			; 3/3/kk
  7263                                  
  7264                                  NoKabat:					; 3/3/kk
  7265                                  	call	far [Triage_Add]		; get extended error
  7266                                  	cmp	ax,65				; network access denied?
  7267                                  	jnz	short OpenErr 			; no - go deallocate batch
  7268                                  
  7269                                  %endif
  7270                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7271                                  
  7272                                  AccDenErr:					; yes - put out message
  7273                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7274 00001941 BA[D305]                	mov	dx,ACCDEN
  7275 00001944 E849F9                  	call	RPrint
  7276                                  OpenErr:
  7277                                  ;OPENERR:
  7278 00001947 8E06[4C01]              	mov	es,[Batch]		; not found--turn off batch job
  7279 0000194B B449                    	mov	ah,49h
  7280                                  	;mov	ah,DEALLOC ; 49h
  7281 0000194D CD21                    	int	21h
  7282 0000194F C706[4C01]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7283 00001955 C606[A001]01            	mov	byte [EchoFlag],1
  7284 0000195A C706[AF01]0000          	mov	word [Nest],0		; indicate no batch in progress
  7285                                  
  7286                                  ;DoDttm:
  7287                                  	;mov	ax,offset TranGroup:Datinit
  7288 00001960 B8[722E]                	mov	ax,DATINIT
  7289 00001963 A3[751C]                	mov	[INITADD],ax
  7290                                  
  7291                                  	; MSDOS 6.0
  7292                                  ;;M004;;mov	ax,TrnSeg	
  7293                                  ;
  7294                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7295                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7296                                  ; M004; We use TranStart to get the start of the transient segment.
  7297                                  
  7298                                  	; 21/01/2023
  7299                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7300                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7301                                  	; 06/06/2023
  7302                                  	;mov	ax,TRANSTART
  7303                                  	;mov	cl,4				; M004
  7304                                  	;shr	ax,cl				; get relative seg ; M004
  7305                                  	; 06/06/2023
  7306 00001966 B82302                  	mov	ax,TRANSTART>>4	
  7307                                  
  7308 00001969 8CC9                    	mov	cx,cs
  7309 0000196B 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7310                                  
  7311                                  	; 21/01/2023
  7312                                  	; MSDOS 3.3
  7313                                  	; 25/09/2018
  7314                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7315                                  
  7316                                  	; MSDOS 3.3 & MSDOS 6.0
  7317 0000196D A3[771C]                	mov	[INITADD+2],ax
  7318                                  	;call	dword ptr InitAdd
  7319 00001970 FF1E[751C]              	call	far [INITADD]
  7320                                  
  7321                                  NoDttm:
  7322                                  	; MSDOS 6.0
  7323                                  	; 21/01/2023
  7324                                  ;Copyright:
  7325                                  	;public	Copyright
  7326                                  ;	Bugbug:	remove Copyright label.
  7327                                  
  7328                                  ;if IBMVER
  7329 00001974 833E[A601]00            	cmp	word [SingleCom],0
  7330 00001979 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7331                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7332 0000197B BA[7B1D]                	mov	dx,COPYRIGHTMSG
  7333 0000197E E80FF9                  	call	RPrint
  7334                                  ;endif
  7335                                  	; 21/01/2023
  7336                                  	; MSDOS 3.3
  7337                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7338                                  	;jnz	short DRV0
  7339                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7340                                  	;call	RPRINT
  7341                                  ;DRV0:
  7342                                  	; MSDOS 3.3
  7343                                  	;mov	byte [INITFLAG],0
  7344                                  	;jmp	ENDINIT
  7345                                  
  7346                                  	; 21/01/2023
  7347                                  	; MSDOS 6.0
  7348                                  Drv0:						; Reset APPEND state
  7349 00001981 1E                      	push	ds				; save data segment
  7350 00001982 0E                      	push	cs				; Get local segment into DS
  7351 00001983 1F                      	pop	ds				;
  7352 00001984 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7353                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7354 00001987 8B1E[C301]              	mov	bx,[Append_State] 		;  back to the original state
  7355 0000198B CD2F                    	int	2Fh				;
  7356 0000198D 1F                      	pop	ds				; get data segment back
  7357                                  
  7358                                  ;Check FirstCom set previously to see if this is the first instance of
  7359                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7360                                  ;jump table from the previous stub to the current stub.
  7361                                  
  7362 0000198E 803E[F020]01            	cmp	byte [FirstCom],1		; first command.com?
  7363 00001993 7429                    	jz	short move_code			; yes, move it
  7364                                  
  7365 00001995 06                      	push	es
  7366 00001996 1E                      	push	ds
  7367                                  
  7368 00001997 1E                      	push	ds
  7369 00001998 07                      	pop	es
  7370                                  	;mov	di,offset DATARES:Int2f_Entry
  7371 00001999 BF[0400]                	mov	di,Int2f_Entry	
  7372                                  
  7373 0000199C 268E1E[EE20]            	mov	ds,[es:ResJmpTable+2]		; get segment address
  7374 000019A1 268B36[EC20]            	mov	si,[es:ResJmpTable]		; get offset address
  7375                                  
  7376                                  	;mov	cx,11
  7377                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7378                                  	;shl	cx,1
  7379                                  	;shl	cx,1				; size of table in bytes
  7380                                  	; 21/01/2023
  7381 000019A6 B92C00                  	mov	cx,44				; size of table in bytes
  7382                                  
  7383 000019A9 FC                      	cld
  7384 000019AA F3A4                    	rep	movsb				; copy the jump table
  7385                                  
  7386                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7387                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7388                                  
  7389 000019AC 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7390 000019B2 7206                    	jb	short res_low			; no, dont set flag
  7391                                  
  7392 000019B4 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7393                                  res_low:
  7394 000019BA 1F                      	pop	ds
  7395 000019BB 07                      	pop	es
  7396 000019BC EB03                    	jmp	short finish_init
  7397                                  
  7398                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7399                                  ;or to overlay the messages in the data segment if the user has not used the
  7400                                  ;/msg switch.
  7401                                  
  7402                                  move_code:
  7403 000019BE E88A01                  	call	Move_res_code			; move the code
  7404                                  
  7405                                  finish_init:
  7406                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7407 000019C1 E956E8                  	jmp	EndInit
  7408                                  
  7409                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7410                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7411                                  
  7412                                  GetStrLen:
  7413                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7414                                  ;	Length is returned in CX
  7415                                  
  7416                                  	; MSDOS 3.3 & MSDOS 6.0
  7417 000019C4 31C9                    	xor	cx,cx
  7418                                  NxtChar:
  7419 000019C6 AC                      	lodsb
  7420 000019C7 41                      	inc	cx
  7421 000019C8 08C0                    	or	al,al
  7422 000019CA 75FA                    	jnz	short NxtChar
  7423 000019CC C3                      	retn
  7424                                  
  7425                                  	; 29/01/2023
  7426                                  Setup_Seg:
  7427                                  
  7428                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7429                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7430                                  ; code segment is used
  7431                                  ; Segment returned in AX.
  7432                                  
  7433                                  	; MSDOS 3.3 & MSDOS 6.0
  7434 000019CD A1[9201]                	mov	ax,[TrnSeg]
  7435 000019D0 803E[9401]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7436 000019D5 7405                    	je	short setup_end
  7437                                  
  7438                                  ;06/06/2023
  7439                                  %if 0
  7440                                  	push	bx
  7441                                  	mov	bx,cs
  7442                                  	;mov	ax,offset ResGroup:TranStart
  7443                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7444                                  	; 06/06/2023
  7445                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7446                                  	;mov	ax,TRANSTART
  7447                                  	;shr	ax,1
  7448                                  	;shr	ax,1
  7449                                  	;shr	ax,1
  7450                                  	;shr	ax,1
  7451                                  	; 29/01/2023
  7452                                  	mov	ax,TRANSTART>>4
  7453                                  	add	ax,bx
  7454                                  	pop	bx
  7455                                  %endif
  7456                                  	; 06/06/2023
  7457 000019D7 8CC8                    	mov	ax,cs
  7458 000019D9 052302                  	add	ax,TRANSTART>>4
  7459                                  
  7460                                  setup_end:
  7461 000019DC C3                      	retn
  7462                                  
  7463                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7464                                  ;RPRINT:
  7465                                  	; MSDOS 3.3
  7466                                  	;push    ax
  7467                                  	;call    SETUP_SEG
  7468                                  	;mov     [PRINTADD+2], ax
  7469                                  	;;call	dword ptr PRINTADD
  7470                                  	;call	far [PRINTADD]
  7471                                  	;pop     ax
  7472                                  	;retn
  7473                                  
  7474                                  	; 29/01/2023
  7475                                  	; MSDOS 6.0
  7476                                  ;***	RPrintParse - display parse error message
  7477                                  ;
  7478                                  ;	ENTRY	DX = parse error #
  7479                                  ;
  7480                                  ;	EXIT	nothing
  7481                                  ;
  7482                                  ;	USED	flags
  7483                                  ;
  7484                                  ;	EFFECTS
  7485                                  ;	  Message is displayed on stdout.
  7486                                  
  7487                                  RPrintParse:	;proc
  7488                                  	;assume	ds:ResGroup,ss:ResGroup
  7489                                  
  7490 000019DD 52                      	push	dx				; preserve DX
  7491 000019DE 87DA                    	xchg	bx,dx				; bx = parse error #
  7492                                  						; dx = saved BX
  7493 000019E0 4B                      	dec	bx				; bx = parse error index, from 0
  7494 000019E1 D1E3                    	shl	bx,1				; bx = offset in word table
  7495                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7496 000019E3 8B9F[1609]              	mov	bx,[bx+PARSMSGPTRS]
  7497 000019E7 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7498                                  						; bx = restored
  7499 000019E9 E8A4F8                  	call	RPrint				; print the message
  7500 000019EC 5A                      	pop	dx				; restore DX
  7501 000019ED C3                      	retn
  7502                                  
  7503                                  ;RPrintParse	endp
  7504                                  
  7505                                  	; 29/01/2023
  7506                                  ;PATHCHRCMPR:
  7507                                  	; MSDOS 3.3
  7508                                  	;push	dx
  7509                                  	;mov	dl,[slash_chr]
  7510                                  	;;cmp	byte [RSWITCHAR],'/'
  7511                                          ;cmp	[RSWITCHAR],dl
  7512                                  	;je	short RNOSLASHT
  7513                                  	;;cmp	al,'/'
  7514                                  	;cmp	al,dl
  7515                                  	;je	short RET41 ; zf = 1 
  7516                                  ;RNOSLASHT:
  7517                                          ;;cmp	al,'\'
  7518                                  	;cmp	al,[bslash_chr]
  7519                                  ;RET41:
  7520                                  	;pop	dx
  7521                                  	;retn
  7522                                  
  7523                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7524                                  IfindE:
  7525                                  	; MSDOS 3.3 & MSDOS 6.0
  7526 000019EE E80300                  	call	ifind				; find the name
  7527                                  	;jc	short ifind2			; carry means not found
  7528                                  	;jmp	short Iscasb1 			; scan for = sign
  7529                                  	; 29/01/2023
  7530 000019F1 733A                    	jnc	short Iscasb1
  7531                                  ifind2:
  7532 000019F3 C3                      	retn
  7533                                  
  7534                                  	; 29/01/2023
  7535                                  
  7536                                  ; on return of find1, es:di points to beginning of name
  7537                                  
  7538                                  ifind:
  7539 000019F4 FC                      	cld
  7540 000019F5 E82700                  	call	Icount0				; cx = length of name
  7541 000019F8 8E06[3F03]              	mov	es,[EnvirSeg]
  7542 000019FC 31FF                    	xor	di,di
  7543                                  ifind1:
  7544 000019FE 51                      	push	cx
  7545 000019FF 56                      	push	si
  7546 00001A00 57                      	push	di
  7547                                  ifind11:
  7548 00001A01 AC                      	lodsb
  7549 00001A02 E83400                  	call	iupconv
  7550 00001A05 47                      	inc	di
  7551 00001A06 263A45FF                	cmp	al,[es:di-1]
  7552 00001A0A 7502                    	jnz	short ifind12
  7553 00001A0C E2F3                    	loop	ifind11
  7554                                  ifind12:
  7555 00001A0E 5F                      	pop	di
  7556 00001A0F 5E                      	pop	si
  7557 00001A10 59                      	pop	cx
  7558 00001A11 74E0                    	jz	short ifind2
  7559 00001A13 51                      	push	cx
  7560 00001A14 E81A00                  	call	Iscasb2 			; scan for a nul
  7561 00001A17 59                      	pop	cx
  7562                                  	;cmp	byte [es:di],0
  7563                                  	;jnz	short ifind1
  7564                                  	;stc					; indicate not found
  7565 00001A18 26803D01                	cmp	byte [es:di],1
  7566 00001A1C 73E0                    	jnb	short ifind1
  7567                                  	; cf=1					; indicate not found
  7568                                  ;ifind2:
  7569 00001A1E C3                      	retn
  7570                                  
  7571                                  	; 29/01/2023
  7572                                  Icount0:
  7573 00001A1F 1E                      	push	ds
  7574 00001A20 07                      	pop	es
  7575 00001A21 89F7                    	mov	di,si
  7576                                  
  7577 00001A23 57                      	push	di				; count number of chars until "="
  7578 00001A24 E80600                  	call	Iscasb1
  7579                                  	; 25/09/2018
  7580                                  	;jmp	short Icountx
  7581                                  	;push	di				; count number of chars until nul
  7582                                  	;call	Iscasb2
  7583                                  ;Icountx:
  7584 00001A27 59                      	pop	cx
  7585 00001A28 29CF                    	sub	di,cx
  7586 00001A2A 87F9                    	xchg	di,cx
  7587 00001A2C C3                      	retn
  7588                                  
  7589                                  Iscasb1:
  7590                                  	; 29/01/2023
  7591 00001A2D B03D                    	mov	al,"="
  7592                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7593 00001A2F EB02                    	jmp	short Iscasbx
  7594                                  Iscasb2:
  7595 00001A31 30C0                    	xor	al,al				; scan for a nul
  7596                                  Iscasbx:
  7597 00001A33 B90001                  	mov	cx,256 ; 100h
  7598 00001A36 F2AE                    	repnz	scasb
  7599 00001A38 C3                      	retn
  7600                                  
  7601                                  	; 29/01/2023
  7602                                  ;IUPCONV:
  7603                                  	; MSDOS 3.3
  7604                                          ;;cmp	al,"a"
  7605                                  	;cmp	al,[letter_a]
  7606                                          ;jb	short IRET22
  7607                                          ;;cmp	al,"z"
  7608                                          ;cmp	al,[letter_z]
  7609                                  	;ja	short IRET22
  7610                                          ;sub	al,20h			; Lower-case changed to upper-case
  7611                                  ;IRET22:
  7612                                  	;retn
  7613                                  
  7614                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7615                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7616                                  
  7617                                  	; MSDOS 6.0
  7618                                  ; *****************************************************************
  7619                                  ; *
  7620                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7621                                  ; *
  7622                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7623                                  ; *		 the character in AL from the file upper case table
  7624                                  ; *		 in DOS if character if above ascii 128, else
  7625                                  ; *		 subtracts 20H if between "a" and "z".
  7626                                  ; *
  7627                                  ; * INPUT:	 DS	      set to resident
  7628                                  ; *		 AL	      char to be upper cased
  7629                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7630                                  ; *
  7631                                  ; * OUTPUT:	 AL	      upper cased character
  7632                                  ; *
  7633                                  ; *****************************************************************
  7634                                  
  7635                                  iupconv:	;proc	near				
  7636                                  	;assume	ds:ResGroup			;
  7637                                  
  7638 00001A39 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7639 00001A3B 7210                    	jb	short other_fucase		; no - upper case math
  7640 00001A3D 2C80                    	sub	al,80h				; only upper 128 chars in table
  7641 00001A3F 1E                      	push	ds				;
  7642 00001A40 53                      	push	bx				;
  7643                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7644 00001A41 C51E[B701]              	lds     bx,[FUCase_Addr+1]
  7645 00001A45 83C302                  	add	bx,2				; skip over first word
  7646                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7647 00001A48 D7                      	xlat
  7648 00001A49 5B                      	pop	bx				;
  7649 00001A4A 1F                      	pop	ds				;
  7650 00001A4B EB0A                    	jmp	short iupconv_end		; we finished - exit
  7651                                  
  7652                                  other_fucase:					;
  7653                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7654 00001A4D 3C61                    	cmp	al,'a'
  7655 00001A4F 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7656                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7657 00001A51 3C7A                    	cmp	al,'z'
  7658 00001A53 7702                    	ja	short iupconv_end		;
  7659 00001A55 2C20                    	sub	al,20h				; Change lower-case to upper
  7660                                  iupconv_end:					;
  7661 00001A57 C3                      	retn
  7662                                  
  7663                                  ;iupConv endp
  7664                                  
  7665                                  	; 29/01/2023
  7666                                  init_contc_specialcase:
  7667                                  	; MSDOS 3.3 & MSDOS 6.0
  7668                                  						; This routine is called if control-C
  7669 00001A58 83C406                  	add	sp,6				;  is type during the date/time prompt
  7670 00001A5B 56                      	push	si				;  at initialization time.  The desired
  7671 00001A5C 89D6                    	mov	si,dx				;  response is to make it look like the
  7672 00001A5E C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7673 00001A63 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7674 00001A64 CF                      	iret					;  a <CR> in the user's buffer, and
  7675                                  						;  returning directly to the user.
  7676                                  						; In this case the user is TCODE.
  7677                                  
  7678                                  ; ----------------------------------------------------------------------------
  7679                                  
  7680                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7681                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7682                                  
  7683                                  	; MSDOS 6.0
  7684                                  ; ****************************************************************
  7685                                  ; *
  7686                                  ; * ROUTINE:	 Setup_for_messages
  7687                                  ; *
  7688                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7689                                  ; *		 messages as follows:
  7690                                  ; *
  7691                                  ; *		 IF /P and /MSG are entered
  7692                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7693                                  ; *		 ELSE IF /P is entered
  7694                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7695                                  ; *		    remove PARSE ERRORS from memory
  7696                                  ; *		 ELSE
  7697                                  ; *		    remove PARSE ERRORS from memory
  7698                                  ; *		 ENDIF
  7699                                  ; *
  7700                                  ; * INPUT:	 PERMCOM	Set up with user input
  7701                                  ; *		 EXT_MSG	Set up with user input
  7702                                  ; *		 System set up to retain PARSE ERRORS
  7703                                  ; *
  7704                                  ; * OUTPUT:	 registers unchanged
  7705                                  ; *
  7706                                  ; ****************************************************************
  7707                                  
  7708                                  setup_for_messages: ;proc near		
  7709                                  
  7710 00001A65 53                      	push	bx
  7711 00001A66 1E                      	push	ds				; save data segment
  7712 00001A67 06                      	push	es				; save environment segment
  7713 00001A68 50                      	push	ax				;
  7714 00001A69 52                      	push	dx				;
  7715 00001A6A 57                      	push	di				;
  7716 00001A6B 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7717 00001A6D 8ED8                    	mov	ds,ax				;
  7718 00001A6F 8EC0                    	mov	es,ax				;
  7719                                  
  7720 00001A71 803E[A501]00            	cmp	byte [PermCom],0		; was permcom set?
  7721 00001A76 743C                    	jz	short no_permcom		; No - don't worry about messages
  7722                                  
  7723                                  ;*	We're permanent. Install our message services int 2f handler.
  7724                                  
  7725 00001A78 06                      	push	es
  7726                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7727 00001A79 B82F35                  	mov	ax,352Fh
  7728 00001A7C CD21                    	int	21h
  7729                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7730                                  			; AL = interrupt number
  7731                                  			; Return: ES:BX = value of interrupt vector
  7732 00001A7E 891E[B303]              	mov	[Int2fHandler],bx
  7733 00001A82 8C06[B503]              	mov	[Int2fHandler+2],es
  7734 00001A86 07                      	pop	es
  7735                                  
  7736                                  ;	DS = RESGROUP seg addr
  7737                                  
  7738                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7739                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7740                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7741                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7742                                  ; M005; call) goes off into space.
  7743                                  
  7744 00001A87 803E[F020]00            	cmp	byte [FirstCom],0		; M005
  7745 00001A8C 7416                    	je	short no_msg_hook		; M005
  7746                                  ;
  7747                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7748                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7749                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7750                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7751                                  ; M005; segment matches the command.com PSP and then updates these segments
  7752                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7753                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7754                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7755                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7756                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7757                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7758                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7759                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7760                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7761                                  ; M005; jump to the actual int 2fh entry point.
  7762                                  ;
  7763 00001A8E 1E                      	push	ds				; M005
  7764                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7765 00001A8F BA[AF00]                	mov     dx,Carousel_i2f_Hook
  7766 00001A92 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7767 00001A95 8CD8                    	mov	ax,ds				; M005
  7768 00001A97 40                      	inc	ax				; Relocated cs ; M005
  7769 00001A98 8ED8                    	mov	ds,ax				; M005
  7770                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7771 00001A9A B82F25                  	mov	ax,252Fh
  7772 00001A9D CD21                    	int	21h
  7773                                  			; DOS - SET INTERRUPT VECTOR
  7774                                  			; AL = interrupt number
  7775                                  			; DS:DX = new vector to be used for specified interrupt
  7776 00001A9F 1F                      	pop	ds				; M005
  7777                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7778 00001AA0 8C1E[B200]              	mov	[Carousel_i2f_Hook+3],ds
  7779                                  						; patch in the cs for jump
  7780                                  no_msg_hook:					; M005
  7781 00001AA4 803E[B11C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7782 00001AA9 7516                    	jne	short permcom_end		; no /msg - exit
  7783                                  
  7784                                  permcom_slash_msg:				; Keep messages in memory
  7785                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7786 00001AAB BF[0F0C]                	mov     di,ExtMsgEnd
  7787 00001AAE 893E[B703]              	mov	[ResMsgEnd],di			; save it
  7788 00001AB2 EB0D                    	jmp	short permcom_end		; exit
  7789                                  
  7790                                  no_permcom:					
  7791                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7792 00001AB4 803E[B11C]01            	cmp	byte [ext_msg],1
  7793 00001AB9 7506                    	jne	short permcom_end		; no - no error
  7794                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7795 00001ABB BA0200                  	mov	dx,2
  7796 00001ABE E81CFF                  	call	RPrintParse
  7797                                  
  7798                                  permcom_end:
  7799 00001AC1 5F                      	pop	di				;
  7800 00001AC2 5A                      	pop	dx				;
  7801 00001AC3 58                      	pop	ax				;
  7802 00001AC4 07                      	pop	es				; get environment back
  7803 00001AC5 1F                      	pop	ds				;
  7804 00001AC6 5B                      	pop	bx
  7805                                  
  7806 00001AC7 C3                      	retn					;
  7807                                  
  7808                                  ;setup_for_messages	endp
  7809                                  
  7810                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7811                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7812                                  
  7813                                  	; MSDOS 6.0
  7814                                  
  7815                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7816                                  ;
  7817                                  ;	ENTRY	command-line tail at 81h
  7818                                  ;
  7819                                  ;	EXIT	return if /? not found
  7820                                  ;		terminate if /? found
  7821                                  ;
  7822                                  ;	USED	AX,BX,CX,DX,SI,DI
  7823                                  ;
  7824                                  ;	EFFECTS	Help text displayed if /? found on command line
  7825                                  
  7826                                  CheckHelp:	; proc
  7827                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7828                                  
  7829 00001AC8 BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7830                                  	;mov	di,offset RESGROUP:Parse_Command
  7831 00001ACB BF[B61C]                	mov	di,PARSE_COMMAND
  7832                                  					; ES:DI = ptr to primary parse block
  7833 00001ACE 31C9                    	xor	cx,cx			; CX = # positional param's found
  7834 00001AD0 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7835                                  chParse:
  7836                                  	;call	dword ptr Init_Parse
  7837 00001AD2 FF1E[A91C]              	call	far [Init_Parse]	; call system parser
  7838                                  
  7839                                  	;cmp	ax,END_OF_LINE
  7840 00001AD6 83F8FF                  	cmp	ax,-1 ; 0FFFFh	
  7841 00001AD9 7414                    	je	short chRet		; end of command line, no /? found
  7842                                  	;cmp	ax,RESULT_NO_ERROR
  7843                                  	;cmp	ax,0
  7844                                  	;je	short chWhich		; valid syntax element found
  7845                                  	;jmp	short chParse		; go parse more
  7846 00001ADB 21C0                    	and	ax,ax ; cmp ax,0
  7847 00001ADD 75F3                    	jnz	short chParse ; jne 
  7848                                  chWhich:
  7849                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7850 00001ADF 813E[3D1D][381D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7851 00001AE5 7409                    	je	short chHelp		; /? found - display help & exit
  7852                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7853 00001AE7 813E[3D1D][1E1D]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7854                                  	;je	short chRet		; /c found - ignore rest of line
  7855                                  	; 29/01/2023
  7856 00001AED 75E3                    	jne	short chParse
  7857                                  	; MSDOS 6.0
  7858                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7859                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7860                                  	;je	short chRet		; /k found - ignore rest of line
  7861                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7862                                  chRet:
  7863 00001AEF C3                      	retn
  7864                                  chHelp:
  7865                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7866 00001AF0 BE[C220]                	mov	si,HelpMsgs
  7867                                  chHelpNext:
  7868 00001AF3 AD                      	lodsw					; AX = ptr to msg
  7869 00001AF4 09C0                    	or	ax,ax
  7870 00001AF6 7407                    	jz	short chHelpDone		; end of list - all done
  7871 00001AF8 89C2                    	mov	dx,ax				; DX = ptr to msg
  7872 00001AFA E893F7                  	call	RPrint				; display msg
  7873 00001AFD EBF4                    	jmp	short chHelpNext		; go do next msg
  7874                                  
  7875                                  chHelpDone:
  7876 00001AFF CD20                    	int	20h				; terminate program
  7877                                  ;chRet:
  7878 00001B01 C3                      	retn
  7879                                  
  7880                                  ;CheckHelp	endp
  7881                                  
  7882                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7883                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7884                                  
  7885                                  	; MSDOS 6.0
  7886                                  
  7887                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7888                                  ;
  7889                                  ; It determines based on 2 factors:
  7890                                  ;	1. Is this is the first COMMAND?
  7891                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7892                                  ;   The strategy works as follows:
  7893                                  ;
  7894                                  ;	if (First COMMAND)
  7895                                  ;	then if (COMMAND in HIMEM)
  7896                                  ;		ResSize = resident_data;
  7897                                  ;	     else
  7898                                  ;		ResSize = resident_data + resident_code;
  7899                                  ;	else
  7900                                  ;	   ResSize = resident_data;
  7901                                  ;
  7902                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7903                                  ; COMMAND and whether DOS is in HIMEM.
  7904                                  ;
  7905                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7906                                  ;
  7907                                  ;	EXIT:  ResSize = resident size in low memory
  7908                                  ;
  7909                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7910                                  ;
  7911                                  
  7912                                  GET_HMA_ADDR	equ	4A02h
  7913                                  
  7914                                  Setup_res_end:	;proc near
  7915                                  	
  7916 00001B02 1E                      	push	ds
  7917 00001B03 8CC8                    	mov	ax,cs
  7918 00001B05 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7919                                  	;assume	ds:RESGROUP
  7920                                  
  7921 00001B07 8B0E[B703]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7922                                  
  7923                                  ;ifndef	ROMDOS
  7924                                  
  7925                                  ;M042 -- Begin changes
  7926                                  ;If messages are to be kept behind, we need to round up the messages to
  7927                                  ;the next para boundary. This is because we have a dummy segment between the
  7928                                  ;data and the resident code segment so that the code segment starts on a
  7929                                  ;para boundary
  7930                                  
  7931                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7932 00001B0B 81F9[0F0C]              	cmp	cx,ExtMsgEnd
  7933 00001B0F 7506                    	jne	short calc_res			;no, continue
  7934 00001B11 83C10F                  	add	cx,15				;round up
  7935 00001B14 83E1F0                  	and	cx,0FFF0h
  7936                                  calc_res:
  7937                                  
  7938                                  ;M042 -- End changes
  7939                                  
  7940 00001B17 31C0                    	xor	ax,ax
  7941 00001B19 803E[F020]01                   	cmp	byte [FirstCom],1		;is it first command.com?
  7942                                  	;jne	short not_first			;no, do not keep code
  7943                                  	; 06/06/2023
  7944 00001B1E 751A                    	jne	short not_first2
  7945                                  
  7946                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7947                                  ;bit 4 of dh is set
  7948                                  
  7949 00001B20 53                      	push	bx
  7950 00001B21 51                      	push	cx
  7951                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7952 00001B22 B80633                  	mov	ax,3306h
  7953 00001B25 CD21                    	int	21h
  7954                                  		; DOS - 5+ Get TRUE Version Number
  7955                                  		; (BL major, BH minor, DL revision, DH flags)
  7956 00001B27 59                      	pop	cx
  7957                                  
  7958                                  ;bugbug: remove version check after testing
  7959                                  
  7960 00001B28 80FB05                  	cmp	bl,5				;bl has true version ; M013
  7961 00001B2B 7207                    	jb	short oldver
  7962                                  
  7963 00001B2D 31C0                    	xor	ax,ax
  7964 00001B2F 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  7965                                  	;pop	bx
  7966                                  	;jnz	short not_first			;DOS in HIMEM, code not
  7967                                  						;	resident
  7968                                  	; 29/01/2023
  7969 00001B32 7503                    	jnz	short not_first_pop
  7970                                  oldver:
  7971                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7972                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  7973                                  	; 06/06/2023
  7974                                  	; 29/01/2023
  7975                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  7976                                  	; 03/05/2023
  7977 00001B34 B8(0409)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  7978                                  
  7979                                  not_first_pop:
  7980                                  	; 29/01/2023
  7981 00001B37 5B                      	pop	bx
  7982                                  
  7983                                  not_first:
  7984                                  
  7985                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  7986                                  
  7987 00001B38 01C1                    	add	cx,ax
  7988                                  
  7989                                  not_first2:	; 06/06/2023
  7990                                  
  7991                                  ;endif	;not ROMDOS
  7992                                  
  7993 00001B3A 83C10F                  	add	cx,15				;round up to next para
  7994 00001B3D D1E9                    	shr	cx,1
  7995 00001B3F D1E9                    	shr	cx,1
  7996 00001B41 D1E9                    	shr	cx,1
  7997 00001B43 D1E9                    	shr	cx,1				;ax = para size of res code
  7998 00001B45 890E[B903]              	mov	[ResSize],cx			;store resident size
  7999                                  
  8000 00001B49 1F                      	pop	ds
  8001                                  	;assume	ds:nothing
  8002 00001B4A C3                      	retn
  8003                                  
  8004                                  ;ifndef	ROMDOS
  8005                                  
  8006                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8007                                  
  8008                                  	; 29/01/2023
  8009                                  ;oldver:
  8010                                  ;	pop	bx
  8011                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8012                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8013                                  ;	; 29/01/2023
  8014                                  ;	mov	ax,EndCode-RCODE_START
  8015                                  ;	jmp	short not_first
  8016                                  
  8017                                  ;endif	;not ROMDOS
  8018                                  
  8019                                  ;setup_res_end	endp
  8020                                  
  8021                                  ;ifndef	ROMDOS
  8022                                  
  8023                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8024                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8025                                  
  8026                                  	; MSDOS 6.0
  8027                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8028                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8029                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8030                                  ; the correct resident size. When remaining low, we have to check if we 
  8031                                  ; need to overlay the messages part of the data segment which is determined
  8032                                  ; by the /msg switch.
  8033                                  ;
  8034                                  ;	ENTRY: ResMsgEnd = end of resident data
  8035                                  ;
  8036                                  ;	EXIT:  The resident code is either up high or in its final location
  8037                                  ;		down low.
  8038                                  ;
  8039                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8040                                  	
  8041                                  Move_res_code:	;proc near
  8042                                  
  8043 00001B4B 1E                      	push	ds
  8044 00001B4C 06                      	push	es
  8045                                  
  8046 00001B4D 8CC8                    	mov	ax,cs
  8047 00001B4F 8ED8                    	mov	ds,ax
  8048                                  	;assume	ds:RESGROUP
  8049                                  
  8050                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8051 00001B51 B80633                  	mov	ax,3306h
  8052 00001B54 CD21                    	int	21h				;DOS in HIMEM?
  8053                                  		; DOS - 5+ Get TRUE Version Number
  8054                                  		; (BL major, BH minor, DL revision, DH flags)
  8055                                  
  8056 00001B56 80E610                  	and	dh,10h				; M013
  8057 00001B59 750E                    	jnz	short move_high			;yes, move code high
  8058                                  
  8059                                  ;Check if messages have been discarded or not
  8060                                  
  8061                                  load_low:
  8062 00001B5B 1E                      	push	ds
  8063 00001B5C 07                      	pop	es				;es = RESGROUP
  8064 00001B5D 8B3E[B703]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8065                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8066                                  	;mov	bx,ExtMsgEnd
  8067                                  	; 29/01/2023
  8068 00001B61 81FF[0F0C]              	cmp	di,ExtMsgEnd
  8069                                  	;cmp	di,bx				;are messages to be kept?
  8070 00001B65 7431                    	je	short no_move			;yes, dont move code
  8071                                  
  8072 00001B67 EB37                    	jmp	short setup_move		;es:di points at dest.
  8073                                  
  8074                                  move_high:
  8075                                  
  8076                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8077                                  ;We pass in bx the number of bytes we need
  8078                                  
  8079                                  	;mov	bx,offset CODERES:EndCode
  8080                                  	; 29/01/2023
  8081                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8082                                  	; 06/06/2023
  8083                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8084                                  	; 03/05/2023
  8085 00001B69 BB(0409)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8086                                  
  8087                                  ;M030;
  8088                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8089                                  
  8090 00001B6C BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8091                                  						;this ; M030
  8092 00001B6F B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8093 00001B72 CD2F                    	int	2Fh
  8094                                  
  8095                                  ;If the offset = 0xffff, then no HMA available
  8096                                  
  8097 00001B74 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8098 00001B77 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8099 00001B7C 7522                    	jne	short setup_move		;no error, es:di = memory
  8100                                  
  8101                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8102                                  	; 29/01/2023	
  8103 00001B7E FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8104                                  
  8105                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8106                                  ;ResSize to reflect this
  8107                                  
  8108 00001B82 8B0E[B703]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8109                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8110                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8111                                  	;mov	ax,EndCode-RCODE_START
  8112                                  	;add	cx,ax
  8113                                  	; 06/06/2023
  8114                                  	; 29/01/2023
  8115                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8116                                  	;add	cx,15				;round up to next para
  8117                                  	; 03/05/2023
  8118 00001B86 81C1(1309)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8119 00001B8A D1E9                    	shr	cx,1
  8120 00001B8C D1E9                    	shr	cx,1
  8121 00001B8E D1E9                    	shr	cx,1
  8122 00001B90 D1E9                    	shr	cx,1				;ax = para size of res code
  8123 00001B92 890E[B903]              	mov	[ResSize],cx			;store resident size
  8124 00001B96 EBC3                    	jmp	short load_low			;let code remain low
  8125                                  
  8126                                  no_move:
  8127                                  	; 05/05/2023
  8128                                  	;mov	cl,4
  8129 00001B98 83C70F                  	add	di,0Fh
  8130 00001B9B 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8131 00001B9E EB0B                    	jmp	short patch_up
  8132                                  
  8133                                  setup_move:
  8134                                  	;mov	si,offset RESGROUP:StartCode
  8135                                  	; 03/05/2023
  8136 00001BA0 BE[100C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8137                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8138                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8139                                  	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8140                                  	; 06/06/2023
  8141                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8142                                  	; 03/05/2023
  8143 00001BA3 B9(0409)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8144                                  
  8145 00001BA6 FC                      	cld
  8146 00001BA7 57                      	push	di				;need di for patching offset
  8147 00001BA8 F3A4                    	rep	movsb
  8148 00001BAA 5F                      	pop	di
  8149                                  
  8150                                  patch_up:
  8151 00001BAB E84200                  	call	patch_stub
  8152 00001BAE 07                      	pop	es
  8153 00001BAF 1F                      	pop	ds
  8154                                  	;assume	ds:nothing
  8155 00001BB0 C3                      	retn
  8156                                  
  8157                                  ;Move_res_code endp
  8158                                  
  8159                                  ;else	;ROMDOS
  8160                                  ;
  8161                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8162                                  ;
  8163                                  ;Move_res_code	proc
  8164                                  ;
  8165                                  ;	push	es
  8166                                  ;
  8167                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8168                                  ;	call	patch_stub
  8169                                  ;
  8170                                  ;	pop	es
  8171                                  ;	ret
  8172                                  ;
  8173                                  ;Move_res_code	endp
  8174                                  ;
  8175                                  ;	assume	ds:NOTHING		; to match ending assume above
  8176                                  ;
  8177                                  ;endif	;ROMDOS
  8178                                  
  8179                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8180                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8181                                  
  8182                                  	; MSDOS 6.0
  8183                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8184                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8185                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8186                                  ; the contents of this temporary environment are copied to it. This routine
  8187                                  ; will not be called in case a valid environment is passed to command.com
  8188                                  ;
  8189                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8190                                  ;
  8191                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8192                                  ;
  8193                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8194                                  
  8195                                  alloc_env:	;proc near
  8196                                  	;assume ds:nothing
  8197                                  	
  8198 00001BB1 1E                              push    ds
  8199 00001BB2 06                      	push	es
  8200 00001BB3 56                      	push	si
  8201 00001BB4 57                      	push	di
  8202                                  
  8203                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8204                                  %if 0
  8205                                          push    ss
  8206                                          pop     ds
  8207                                  	;assume ds:RESGROUP
  8208                                  
  8209                                          mov     ax,[EnvirSeg]
  8210                                  
  8211                                          cmp	byte [AllocedEnv],0
  8212                                          je	short alloc_cont
  8213                                          jmp     alloc_done
  8214                                  
  8215                                  alloc_cont:
  8216                                          sub     di,di                           ; default start
  8217                                          ;mov	bx,SIZE Environment             ; default size needed
  8218                                  	; 29/01/2023
  8219                                  	mov	bx,ENVIRONSIZ
  8220                                  
  8221                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8222                                          je	short alloc_seg			; no
  8223                                  
  8224                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8225                                  ;   Record their respective locations and do not add the default vars.
  8226                                  
  8227                                  	or      ax,ax
  8228                                  	jz	short alloc_new			; no previous environment
  8229                                  
  8230                                          mov     es,ax
  8231                                  	;assume es:nothing
  8232                                  
  8233                                  _find_path:
  8234                                          mov     al,0
  8235                                          sub     di,di
  8236                                  comp_path:
  8237                                          scasb                                   ; end of env?
  8238                                  	je	short _find_prompt		; yes
  8239                                          dec     di
  8240                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8241                                          ;mov	si,offset RESGROUP:PathString
  8242                                  	mov	si,PathString	
  8243                                          repe    cmpsb
  8244                                          je	short got_path
  8245                                          mov	cx,256
  8246                                          repne   scasb                           ; find next NULL
  8247                                          jmp     short comp_path
  8248                                  
  8249                                  got_path:
  8250                                          mov	byte [PathString],0		; don't add it
  8251                                  
  8252                                  _find_prompt:
  8253                                          sub     di,di
  8254                                  comp_prompt:
  8255                                  	scasb                                   ; end of env?
  8256                                  	je	short find_comspec		; yes
  8257                                  	dec     di
  8258                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8259                                  	;mov	si,offset RESGROUP:PrmptString
  8260                                  	mov	si,PrmptString
  8261                                          repe    cmpsb
  8262                                          je	short got_prompt
  8263                                          mov     cx,256
  8264                                          repne   scasb                           ; find next NULL
  8265                                          jmp	short comp_prompt
  8266                                  
  8267                                  got_prompt:
  8268                                  	mov	byte [PrmptString],0		; don't add it
  8269                                  
  8270                                  find_comspec:
  8271                                          sub     di,di
  8272                                  comp_comspec:
  8273                                          scasb                                   ; end of env?
  8274                                          je	short got_envend		; yes
  8275                                          dec     di
  8276                                          mov	cx,ComspStrLen ; mov cx,8
  8277                                  	;mov	si,offset RESGROUP:ComspString
  8278                                  	mov	si,ComspString
  8279                                          repe    cmpsb
  8280                                          je	short got_comspec
  8281                                          mov     cx,256
  8282                                          repne   scasb                           ; find next NULL
  8283                                          jmp	short comp_comspec
  8284                                  
  8285                                  got_comspec:
  8286                                          mov     [ComspOffset],di
  8287                                  
  8288                                  find_envend:
  8289                                          sub     di,di
  8290                                          mov     cx,ENVBIG                       ; max env size
  8291                                  comp_envend:
  8292                                          dec     cx                              ;
  8293                                          scasb                                   ; end of env?
  8294                                          je	short got_envend		; yes
  8295                                          repne   scasb
  8296                                          jmp	short comp_envend
  8297                                  
  8298                                  got_envend:
  8299                                          dec     di
  8300                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8301                                  
  8302                                  ;   We want to fall through to alloc_new and set up default
  8303                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8304                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8305                                  
  8306                                          push    ds
  8307                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8308                                          mov	ds,[PDB.PARENT_PID]
  8309                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8310                                  	cmp	word [PDB.PARENT_PID],0
  8311                                  	pop     ds
  8312                                          jne	short alloc_seg			; no, we're not the first process
  8313                                                                                  ; so don't muck with the env.
  8314                                  alloc_new:
  8315                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8316                                  
  8317                                  alloc_seg:
  8318                                  
  8319                                  ; Allocate default environment size
  8320                                  
  8321                                          mov     cx,bx                           ; save byte-granular size in CX
  8322                                          add     bx,15
  8323                                          shr     bx,1
  8324                                          shr     bx,1
  8325                                          shr     bx,1
  8326                                          shr     bx,1                            ; BX = # paras
  8327                                  	mov	ah,ALLOC
  8328                                  	int	21h
  8329                                          jnc	short init_ok
  8330                                          jmp     init_nomem                      ; insufficient memory, error
  8331                                  
  8332                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8333                                  ; the new buffer
  8334                                  
  8335                                  init_ok:
  8336                                  	mov	es,ax
  8337                                  	;assume	es:nothing                      ; es = temp env segment
  8338                                  
  8339                                  	or      di,di
  8340                                          jz	short copy_path
  8341                                  
  8342                                          push    cx
  8343                                          push    ds
  8344                                          mov     ds,[EnvirSeg]
  8345                                          ;assume ds:nothing
  8346                                          sub     si,si
  8347                                          mov     cx,di
  8348                                          sub     di,di
  8349                                          rep     movsb
  8350                                          pop     ds
  8351                                          ;assume ds:RESGROUP
  8352                                          pop     cx
  8353                                          sub     cx,di
  8354                                  
  8355                                  copy_path:
  8356                                  
  8357                                  ; First clear out (the rest of) the buffer
  8358                                  
  8359                                          push    di
  8360                                          sub     ax,ax
  8361                                          rep     stosb
  8362                                          pop     di
  8363                                  
  8364                                  ; Initialize the path string (PATH=) first
  8365                                  
  8366                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8367                                  	mov	si,PathString
  8368                                          cmp     byte [si],al			; add it?
  8369                                          je	short init_prompt		; no
  8370                                  	;mov	cx,PathStrLen+1                 ;
  8371                                  	mov	cx,6 ; db "PATH=",0
  8372                                          rep     movsb                           ;
  8373                                          cmp     [AllocedEnv],al			; virgin env?
  8374                                          je	short init_prompt		; no
  8375                                  
  8376                                  ; Establish a more reasonable default for the PATH
  8377                                  
  8378                                  	;mov	ah,GET_DEFAULT_DRIVE
  8379                                  	mov	ah,19h
  8380                                  	int	21h
  8381                                          add     al,'A'                          ; convert to letter
  8382                                          mov     [DefPathString],al              ;
  8383                                          mov     [DefPath2String],al             ; now our default paths are complete
  8384                                  
  8385                                          mov     dl,0                            ; get dir for default drive
  8386                                          push    ds                              ;
  8387                                          push    es                              ;
  8388                                          pop     ds                              ;
  8389                                          mov     byte [di],'\'			;
  8390                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8391                                  	;mov	ah,Current_Dir                  ;
  8392                                          mov	ah,47h
  8393                                  	int     21h                             ;
  8394                                          pop     ds                              ;
  8395                                  
  8396                                  	;mov	cx,DefPathStrLen+1              ;
  8397                                  	mov	cx,9 ; db "C:\MSDOS",0
  8398                                  	;mov	dx,offset RESGROUP:DefPathString
  8399                                  	mov	dx,DefPathString 
  8400                                  	mov	si,dx                           ;
  8401                                          ;mov	ah,CHDir                        ;
  8402                                          mov	ah,3Bh
  8403                                  	int     21h                             ;
  8404                                          jnc	short init_setpath		; DefPathString exists!
  8405                                  
  8406                                  	;mov	cx,DefPath2StrLen+1		;
  8407                                          mov	cx,7 ; db "C:\DOS",0
  8408                                  	;mov	dx,offset RESGROUP:DefPath2String
  8409                                  	mov	dx,DefPath2String
  8410                                          mov     si,dx                           ;
  8411                                          ;mov	ah,CHDir                        ;
  8412                                          mov	ah,3Bh
  8413                                          int     21h                             ;
  8414                                          jc	short init_prompt		; DefPath2String doesn't exist
  8415                                  
  8416                                  init_setpath:
  8417                                          mov     dx,di                           ; success
  8418                                          push    ds                              ; so restore prev dir
  8419                                          push    es                              ;
  8420                                          pop     ds                              ; DS:DX -> prev dir
  8421                                          ;mov	ah,CHDir                        ;
  8422                                          mov	ah,3Bh
  8423                                          int     21h                             ;
  8424                                          pop     ds                              ;
  8425                                  
  8426                                          dec     di                              ; then copy in DefPathString
  8427                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8428                                  
  8429                                  ; Initialize the default prompt
  8430                                  
  8431                                  init_prompt:
  8432                                          push    di                              ;
  8433                                          sub     ax,ax                           ;
  8434                                          mov     cx,64                           ; insure any data read in
  8435                                          rep     stosb                           ; from Current_Dir is zapped
  8436                                          pop     di                              ;
  8437                                  
  8438                                  	cmp	[AllocedEnv],al			; virgin env?
  8439                                          je	short init_comspec		; no
  8440                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8441                                          mov	si,PrmptString
  8442                                  	cmp     [si],al				; add it?
  8443                                          je      short init_comspec		; no
  8444                                  	;mov	cx,PrmptStrLen+1                ;
  8445                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8446                                  	rep     movsb                           ;
  8447                                  
  8448                                  ; Initialize the Comspec string
  8449                                  
  8450                                  init_comspec:
  8451                                          cmp	[ComspOffset],ax		; add it?
  8452                                          jne	short init_done			; no
  8453                                          lea     ax,[di+ComspStrLen]             ;
  8454                                          mov	[ComspOffset],ax		;
  8455                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8456                                          mov	si,ComspString
  8457                                  	;mov	cx,ComspStrLen2+1               ;
  8458                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8459                                  	rep     movsb                           ;
  8460                                  
  8461                                  init_done:
  8462                                          mov     ax,es                           ; return env seg in ax
  8463                                          mov     [EnvirSeg],ax			; save env seg
  8464                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8465                                  %endif
  8466                                  
  8467                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8468                                  %if 1
  8469                                  	;mov	bx,10
  8470 00001BB5 BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8471 00001BB8 B448                    	mov	ah,48h
  8472 00001BBA CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8473                                  			; BX = number of 16-byte paragraphs desired
  8474 00001BBC 722C                    	jc	short init_nomem
  8475                                  
  8476                                  init_ok:
  8477 00001BBE 8EC0                    	mov	es,ax
  8478                                  	;assume	es:nothing                      ; es = temp env segment
  8479                                  
  8480 00001BC0 31FF                    	xor	di,di
  8481 00001BC2 89F8                    	mov	ax,di
  8482                                  	;mov	cx,160	
  8483 00001BC4 B9A000                          mov     cx,ENVIRONSIZ
  8484 00001BC7 F3AA                            rep	stosb
  8485                                  
  8486                                  init_pathstr:
  8487                                  
  8488                                  ; Initialize the path string (PATH=) first
  8489                                  
  8490 00001BC9 16                      	push	ss
  8491 00001BCA 1F                      	pop	ds
  8492                                  
  8493                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8494 00001BCB BE[821C]                	mov	si,PathString
  8495 00001BCE BF0000                  	mov	di,0
  8496                                  init_cp_pathstr:
  8497 00001BD1 AC                      	lodsb
  8498 00001BD2 AA                      	stosb
  8499 00001BD3 08C0                    	or	al,al
  8500 00001BD5 75FA                    	jnz	short init_cp_pathstr
  8501                                  
  8502                                  ; Initialize the Comspec string
  8503                                  
  8504                                  init_comspec:
  8505                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8506 00001BD7 BE[881C]                        mov	si,ComspString
  8507                                  	; 05/05/2023
  8508 00001BDA BF0600                  	mov	di,6
  8509                                  init_cp_compstr:
  8510 00001BDD AC                      	lodsb
  8511 00001BDE AA                      	stosb
  8512 00001BDF 08C0                    	or	al,al
  8513 00001BE1 75FA                    	jnz	short init_cp_compstr
  8514                                  
  8515                                  init_done:
  8516 00001BE3 8CC0                            mov     ax,es                           ; return env seg in ax
  8517                                          ;mov	[EnvirSeg],ax			; save env seg
  8518                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8519                                  %endif	
  8520                                  
  8521                                  	; 29/01/2023
  8522                                  alloc_done:
  8523 00001BE5 5F                      	pop	di
  8524 00001BE6 5E                      	pop	si
  8525 00001BE7 07                      	pop	es
  8526 00001BE8 1F                              pop     ds
  8527                                  	;assume	ds:nothing
  8528 00001BE9 C3                      	retn
  8529                                  
  8530                                  	; 29/01/2023
  8531                                  init_nomem:
  8532                                  
  8533                                  ;We call the error routine from here. This routine never returns. It either
  8534                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8535                                  ;the system ( if it is the first COMMAND.COM ).
  8536                                  
  8537 00001BEA E80000                  	call	Alloc_error
  8538                                  
  8539                                  ;Alloc_env	endp
  8540                                  
  8541                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8542                                  ; check if this is a permanent or secondary command.com and take the 
  8543                                  ; appropriate action.
  8544                                  ;
  8545                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8546                                  ;
  8547                                  ;	EXIT:	None - does not return
  8548                                  ;
  8549                                  ;	REGISTERS AFFECTED: Does not matter
  8550                                  ;
  8551                                  
  8552                                  ;public Alloc_error
  8553                                  Alloc_error:	;proc	near
  8554                                  
  8555                                  	;jmp	RESGROUP:BadMemErr
  8556                                  	; 29/01/2023
  8557 00001BED E929F1                  	jmp	BadMemErr	
  8558                                  	
  8559                                  ;Alloc_error	endp
  8560                                  
  8561                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8562                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8563                                  
  8564                                  	; MSDOS 6.0
  8565                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8566                                  ; the stub table of the various entry points in the resident code segment.
  8567                                  ; Some of them are interrupt entry points and some of them are entries from
  8568                                  ; the transient to the resident code segment.
  8569                                  ;
  8570                                  ;	ENTRY:	ds = RESGROUP
  8571                                  ;		es:di = segment:offset of final location of resident code
  8572                                  ;
  8573                                  ;	EXIT:	All segments and offsets patched into the stub table
  8574                                  ;
  8575                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8576                                  
  8577                                  patch_stub:	;proc near
  8578                                  	;assume	ds:RESGROUP
  8579                                  	
  8580 00001BF0 06                      	push	es
  8581                                  
  8582 00001BF1 8CC3                    	mov	bx,es			;bx = resident code segment
  8583 00001BF3 89FA                    	mov	dx,di
  8584                                  	;mov	di,offset DATARES:Int2f_Entry
  8585 00001BF5 BF[0400]                	mov	di,Int2f_Entry
  8586                                  	;mov	si,offset RESGROUP:Reloc_Table
  8587 00001BF8 BE[D620]                	mov	si,Reloc_Table
  8588 00001BFB 1E                      	push	ds
  8589 00001BFC 07                      	pop	es			;es = RESGROUP = DATARES
  8590                                  
  8591                                  ;bx:dx = segment:offset of resident code segment
  8592                                  ;es:di = entry point table in stub
  8593                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8594                                  
  8595                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8596 00001BFD B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8597                                  patchlp:
  8598 00001C00 AD                      	lodsw				;get current offset
  8599 00001C01 01D0                    	add	ax,dx			;offset it by code seg location 
  8600 00001C03 AB                      	stosw				;store offset
  8601 00001C04 89D8                    	mov	ax,bx			
  8602 00001C06 AB                      	stosw				;store segment 
  8603 00001C07 E2F7                    	loop	patchlp
  8604                                  
  8605 00001C09 07                      	pop	es
  8606 00001C0A C3                      	retn
  8607                                  
  8608                                  ;Patch_stub	endp
  8609                                  
  8610                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8611                                  
  8612                                  	; MSDOS 6.0
  8613                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8614                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8615                                  ; are temporarily needed to handle these interrupts if they occur before
  8616                                  ; the resident is relocated to its final position and all the addresses of
  8617                                  ; the handlers have been updated.
  8618                                  ;
  8619                                  ;	ENTRY:	es = PSP segment = code segment
  8620                                  ;
  8621                                  ;	EXIT:	Current segment values patched into the jump table in the
  8622                                  ;		stub.
  8623                                  ;
  8624                                  ;	REGISTERS AFFECTED: ax, cx, di
  8625                                  
  8626                                  patch_segs:	;proc near
  8627                                  
  8628                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8629 00001C0B BF[0400]                	mov	di,Int2f_Entry 
  8630 00001C0E B90400                  	mov	cx,4			;we have to patch 4 handlers
  8631 00001C11 83C702                  	add	di,2
  8632 00001C14 8CC0                    	mov	ax,es
  8633                                  pseglp:
  8634 00001C16 AB                      	stosw				;store the segment value
  8635 00001C17 83C702                  	add	di,2			;skip the next offset value
  8636 00001C1A E2FA                    	loop	pseglp
  8637                                  
  8638 00001C1C C3                      	retn
  8639                                  
  8640                                  ;Patch_segs	endp
  8641                                  
  8642                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8643                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8644                                  
  8645                                  	; MSDOS 6.0
  8646                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8647                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8648                                  ; and is used by the stub when we have to jump to the resident in HMA
  8649                                  ;
  8650                                  ;	ENTRY:	ds = RESGROUP
  8651                                  ;
  8652                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8653                                  ;
  8654                                  ;	REGISTERS AFFECTED:
  8655                                  ;
  8656                                  
  8657                                  get_XMMAddr:	;proc near
  8658                                  	;assume	ds:RESGROUP
  8659                                  
  8660 00001C1D 06                      	push	es
  8661                                  
  8662                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8663 00001C1E B80043                  	mov	ax,4300h
  8664 00001C21 CD2F                    	int	2Fh
  8665                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8666                                  		; Return: AL = 80h XMS driver installed
  8667                                  		; AL <> 80h no driver
  8668 00001C23 3C80                    	cmp	al,80h			; Q: installed
  8669 00001C25 750D                    	jne	short cXMMexit		; N: set error, quit
  8670                                  ;
  8671                                  ; get the XMM control functions entry point, save it, we
  8672                                  ; need to call it later.
  8673                                  ;
  8674                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8675 00001C27 B81043                  	mov	ax,4310h
  8676 00001C2A CD2F                    	int	2Fh
  8677                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8678                                  		; Return: ES:BX -> driver entry point
  8679                                  
  8680 00001C2C 891E[3000]              	mov	[XMMCallAddr], bx
  8681 00001C30 8C06[3200]              	mov	[XMMCallAddr+2],es
  8682                                  cXMMexit:
  8683 00001C34 07                      	pop	es
  8684 00001C35 C3                      	retn				; done
  8685                                  
  8686                                  ;get_XMMAddr	endp
  8687                                  
  8688                                  ;=============================================================================
  8689                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8690                                  ;=============================================================================
  8691                                  ; 24/09/2018 - Retro DOS v3.0
  8692                                  
  8693                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8694                                  
  8695                                  ; TITLE	COMMAND Initialization messages
  8696                                  
  8697                                  ;INIT	SEGMENT PUBLIC PARA
  8698                                  
  8699                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8700                                  
  8701                                  	; 25/09/2018
  8702                                  	; (15 bytes filler)
  8703 00001C36 00                      	db 0
  8704                                  	;db "25/9/2018 ETAN"
  8705                                  	; 10/06/2023
  8706 00001C37 31302F362F32303233-     	db "10/6/2023 ETAN"	
  8706 00001C40 204554414E         
  8707 00001C45 00                      	db 0
  8708                                  
  8709                                  ; 30/01/2023
  8710                                  %if 0
  8711                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8712                                  	;dw 0
  8713                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8714                                  	db 0Dh,0Ah
  8715                                  	db 0Dh,0Ah
  8716                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8717                                  	db 0Dh,0Ah
  8718                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8719                                  	db ' ',0Dh,0Ah
  8720                                  	db '                                                   ',
  8721                                  	db 0Dh,0Ah,0
  8722                                  
  8723                                  	times 43 db 20h
  8724                                  
  8725                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8726                                  BADCOMLKMES:
  8727                                  	dw _152Fh
  8728                                  
  8729                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8730                                  BADCOMACCMSG:
  8731                                  	dw _155Ah
  8732                                  
  8733                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8734                                  ACCDENERR:
  8735                                  	dw _1593h
  8736                                  
  8737                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8738                                  OUTENVMSG:
  8739                                  	dw _15A5h
  8740                                  
  8741                                  BADVERMSG:
  8742                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8743                                  
  8744                                  BADENVSIZMSG:
  8745                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8746                                  
  8747                                  HEADERPTR:
  8748                                  	dw COPYRIGHTMSG
  8749                                  %endif
  8750                                  
  8751                                  ; 30/01/2023
  8752                                  ;align 16
  8753                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8754                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8755                                  ICONDEV:
  8756 00001C46 2F4445562F                      db '/DEV/'
  8757 00001C4B 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8758                                  BADCSPFL:
  8759 00001C54 00                      	db 0
  8760                                  COMSPECT:
  8761 00001C55 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8761 00001C5E 434F4D00           
  8762 00001C62 00                      	db 0
  8763                                  AUTOBAT:
  8764 00001C63 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8764 00001C6C 45432E424154000D   
  8765                                  ;KAUTOBAT:
  8766                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8767                                  PRDATTM:
  8768 00001C74 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8769                                  INITADD:
  8770 00001C75 00000000                	dd 0
  8771                                  print_add:
  8772 00001C79 [114E]                  	dw Printf_Init
  8773 00001C7B 0000                    	dw 0
  8774                                  triage_add:
  8775 00001C7D [B22C]                  	dw Triage_Init
  8776 00001C7F 0000                    	dw 0
  8777                                  ;CHUCKENV:
  8778                                  AllocedEnv:
  8779 00001C81 00                      	db 0
  8780                                  
  8781                                  ; 30/01/2023 - MSDOS 3.3
  8782                                  ;COMSPOFFSET:
  8783                                  ;ECOMLOC:
  8784                                  ;	;dw 0Eh
  8785                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8786                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8787                                  ;COMSPSTRING:
  8788                                  ;	db 'COMSPEC='
  8789                                  
  8790                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8791                                  PathString:
  8792 00001C82 504154483D00            	db 'PATH=',0
  8793                                  PathStrLen equ $-PathString-1
  8794                                  ; MSDOS 6.0
  8795                                  ;DefPathString:
  8796                                  ;	db 'C:\MSDOS',0
  8797                                  ;DefPathStrLen equ  $-DefPathString-1
  8798                                  ;DefPath2String:
  8799                                  ;	db 'C:\DOS',0
  8800                                  ;DefPath2StrLen equ $-DefPath2String-1
  8801                                  ;
  8802                                  ;PrmptString:
  8803                                  ;	db 'PROMPT=$P$G',0
  8804                                  ;PrmptStrLen equ $-PrmptString-1
  8805                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8806                                  ;ComspOffset:
  8807                                  ;	dw 0
  8808                                  ComspString:
  8809 00001C88 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8809 00001C91 434F4D4D414E442E43-
  8809 00001C9A 4F4D00             
  8810                                  ComspStrLen equ 8		; length of COMSPEC=
  8811                                  ComspStrLen2 equ $-ComspString-1
  8812                                  				; length of full COMSPEC
  8813                                  	; 29/01/2023
  8814                                  ;equal_sign:
  8815                                  ;equalsign:
  8816                                  ;	db '='
  8817                                  ;letter_a:
  8818                                  ;lcasea:
  8819                                  ;	db 'a'
  8820                                  ;letter_z:
  8821                                  ;lcasez:
  8822                                  ;	db 'z'
  8823                                  	; 30/01/2023
  8824                                  ;;slash_chr:
  8825                                  ;;	db '/'
  8826                                  ;;bslash_chr:
  8827                                  ;;	db '\'
  8828                                  ;space_chr:
  8829                                  ;;space:
  8830                                  ;	db 20h
  8831                                  ;;letter_p:
  8832                                  ;;	db 'p'
  8833                                  ;;letter_d:
  8834                                  ;;	db 'd'
  8835                                  ;;letter_c:
  8836                                  ;;	db 'c'
  8837                                  	; 16/04/2023
  8838                                  ; MSDOS 5.0 & MSDOS 6.0
  8839                                  ;scswitch:
  8840                                  ;	db 'C'		; Single command
  8841                                  ;;skswitch:
  8842                                  ;	db 'K' ; MSDOS 6.0
  8843                                  ;;letter_A:
  8844                                  ;ucasea: ; 21/01/2023 
  8845                                  ;	db 'A'
  8846                                  
  8847                                  	; 30/01/2023
  8848                                  EnvSiz:
  8849 00001C9D 0000                    	dw 0		; size user wants to allocate
  8850                                  EnvMax:
  8851 00001C9F 0000                    	dw 0		; maximum size allowed
  8852                                  OldEnv:
  8853 00001CA1 0000                    	dw 0		; envirseg at initialization
  8854                                  UsedEnv:
  8855 00001CA3 0000                    	dw 0		; amount of envirseg used
  8856                                  	; MSDOS 5.0 & MSDOS 6.0
  8857                                  PARS_MSG_OFF:
  8858 00001CA5 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8859                                  PARS_MSG_SEG:
  8860 00001CA7 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8861                                  
  8862                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8863                                  
  8864                                  Init_Parse:
  8865                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8866                                  init_p:
  8867 00001CA9 [0D4E]                  	dw append_parse
  8868                                  initend:
  8869 00001CAB 0000                    	dw 0		; segment address of end of init
  8870                                  TrnSize:
  8871 00001CAD 0000                    	dw 0		; size of transient in paragraphs
  8872                                  resetenv:
  8873 00001CAF 0000                    	dw 0		; set if we need to setblck env at endinit
  8874                                  
  8875                                  ext_msg:
  8876 00001CB1 00                      	db 0		; set if /MSG switch entered
  8877                                  eswitch:
  8878 00001CB2 00                      	db 0		; set if /e was entered
  8879                                  dswitch:
  8880 00001CB3 00                      	db 0		; set if /d was entered
  8881                                  parsemes_ptr:
  8882 00001CB4 0000                    	dw 0		; word to store parse error number
  8883                                  
  8884                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8885                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  8886                                  
  8887                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8888                                  ;  The following parse control block is used for COMMAND. This block is
  8889                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8890                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8891                                  ;
  8892                                  ;  Anything on the command line after the /C switch will be passed to the
  8893                                  ;  executable command, so if /C is used, it must be specified last. The
  8894                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8895                                  ;
  8896                                  ;  The /? switch causes help text to be displayed. Any other options
  8897                                  ;  on the command line are ignored. Command.com will not load if /?
  8898                                  ;  is specified.
  8899                                  
  8900                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8901                                  PARSE_COMMAND:
  8902 00001CB6 [B91C]                  	dw COMMAND_PARMS
  8903 00001CB8 00                      	db 0			; no extra delimiter
  8904                                  COMMAND_PARMS:
  8905 00001CB9 0002                    	db 0,2			; 1 positional parm
  8906 00001CBB [CF1C]                  	dw COMMAND_FILE
  8907 00001CBD [CF1C]                  	dw COMMAND_FILE
  8908                                          ; MSDOS 5.0
  8909 00001CBF 07                      	db 7			; 7 switches
  8910                                  	; MSDOS 6.0
  8911                                  	;db 8 			; 8 switches
  8912 00001CC0 [D81C]                  	dw COMMAND_SWITCH1
  8913 00001CC2 [E41C]                  	dw COMMAND_SWITCH2
  8914 00001CC4 [F01C]                  	dw COMMAND_SWITCH3
  8915 00001CC6 [FC1C]                  	dw COMMAND_SWITCH4
  8916 00001CC8 [151D]                  	dw COMMAND_SWITCH5
  8917 00001CCA [211D]                  	dw COMMAND_SWITCH6
  8918 00001CCC [2F1D]                  	dw COMMAND_SWITCH7
  8919                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  8920 00001CCE 00                      	db 0			; no keywords
  8921                                  
  8922                                  COMMAND_FILE:
  8923 00001CCF 0102                    	dw 0201h		; filespec - optional
  8924 00001CD1 0100                    	dw 1			; capitalize - file table
  8925 00001CD3 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8926 00001CD5 [431D]                  	dw NO_VAL 		;
  8927 00001CD7 00                      	db 0			; no keywords
  8928                                  
  8929                                  COMMAND_SWITCH1:
  8930 00001CD8 0000                    	dw 0			; no match flags
  8931 00001CDA 0200                    	dw 2			; capitalize by char table
  8932 00001CDC [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8933 00001CDE [431D]                  	dw NO_VAL 		;
  8934 00001CE0 01                      	db 1			; 1 keyword
  8935                                  COMMAND_P_SYN:
  8936 00001CE1 2F5000                  	db '/P',0		; /P switch
  8937                                  
  8938                                  COMMAND_SWITCH2:
  8939 00001CE4 0000                    	dw 0			; no match flags
  8940 00001CE6 0200                    	dw 2			; capitalize by char table
  8941 00001CE8 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8942 00001CEA [431D]                  	dw NO_VAL 		;
  8943 00001CEC 01                      	db 1			; 1 keyword
  8944                                  COMMAND_F_SYN:
  8945 00001CED 2F4600                  	db '/F',0		; /F switch
  8946                                  
  8947                                  COMMAND_SWITCH3:
  8948 00001CF0 0000                    	dw 0			; no match flags
  8949 00001CF2 0200                    	dw 2			; capitalize by char table
  8950 00001CF4 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8951 00001CF6 [431D]                  	dw NO_VAL 		;
  8952 00001CF8 01                      	db 1			; 1 keyword
  8953                                  COMMAND_D_SYN:
  8954 00001CF9 2F4400                  	db '/D',0		; /D switch
  8955                                  
  8956                                  COMMAND_SWITCH4:
  8957 00001CFC 0080                    	dw 8000h		; numeric value - required
  8958 00001CFE 0000                    	dw 0			; no function flags
  8959 00001D00 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8960 00001D02 [081D]                  	dw COMMAND_E_VAL	; pointer to value list
  8961 00001D04 01                      	db 1			; 1 keyword
  8962                                  COMMAND_E_SYN:
  8963 00001D05 2F4500                  	db '/E',0		; /E switch
  8964                                  
  8965                                  COMMAND_E_VAL:
  8966 00001D08 01                      	db 1			;
  8967 00001D09 01                      	db 1			; 1 range
  8968 00001D0A 01                      	db 1			; returned if result
  8969                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  8970                                  	; MSDOS 5.0 COMMAND.COM
  8971                                  	; (RESGROUP:1F2Bh)
  8972 00001D0B A0000000                	dd 160	 ; ENVSML
  8973 00001D0F 00800000                	dd 32768 ; ENVBIG
  8974 00001D13 00                      	db 0			; no numeric values
  8975 00001D14 00                      	db 0			; no string values
  8976                                  
  8977                                  COMMAND_SWITCH5:
  8978 00001D15 0000                    	dw 0			; no match flags
  8979 00001D17 0200                    	dw 2			; capitalize by char table
  8980 00001D19 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8981 00001D1B [431D]                  	dw NO_VAL 		;
  8982 00001D1D 01                      	db 1			; 1 keyword
  8983                                  COMMAND_C_SYN:
  8984 00001D1E 2F4300                  	db '/C',0		; /C switch
  8985                                  
  8986                                  COMMAND_SWITCH6:
  8987 00001D21 0000                    	dw 0			; no match flags
  8988 00001D23 0200                    	dw 2			; capitalize by char table
  8989 00001D25 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8990 00001D27 [431D]                  	dw NO_VAL 		;
  8991 00001D29 01                      	db 1			; 1 keyword
  8992                                  COMMAND_M_SYN:
  8993 00001D2A 2F4D534700              	db '/MSG',0		; /MSG switch
  8994                                  
  8995                                  COMMAND_SWITCH7:
  8996 00001D2F 0000                    	dw 0			; no match flags
  8997 00001D31 0200                    	dw 2			; capitalize by char table
  8998 00001D33 [3B1D]                  	dw COMND1_OUTPUT	; result buffer
  8999 00001D35 [431D]                  	dw NO_VAL 		;
  9000 00001D37 01                      	db 1			; 1 keyword
  9001                                  COMMAND_?_SYN:
  9002 00001D38 2F3F00                  	db '/?',0 		; /? switch
  9003                                  
  9004                                  	; MSDOS 6.0
  9005                                  ;COMMAND_SWITCH8:
  9006                                  ;	dw 0			; no match flags
  9007                                  ;	dw 2			; capitalize by char table
  9008                                  ;	dw COMND1_OUTPUT	; result buffer
  9009                                  ;	dw NO_VAL 		;
  9010                                  ;	db 1			; 1 keyword
  9011                                  ;COMMAND_K_SYN:
  9012                                  ;	db '/K',0		; /K switch
  9013                                  
  9014                                  COMND1_OUTPUT:
  9015                                  COMND1_TYPE:
  9016 00001D3B 00                      	db 0			; type
  9017                                  COMND1_CODE:
  9018 00001D3C 00                      	db 0			; return value
  9019                                  COMND1_SYN:
  9020 00001D3D 0000                    	dw 0			; synonym pointer
  9021                                  COMND1_ADDR:
  9022 00001D3F 00000000                	dd 0			; numeric value / address
  9023                                  					; of string value
  9024                                  NO_VAL:
  9025 00001D43 00                      	db 0			; no values
  9026                                  num_positionals:
  9027 00001D44 0000                    	dw 0			; counter for positionals
  9028                                  old_parse_ptr:
  9029 00001D46 0000                    	dw 0			; SI position before calling parser
  9030                                  
  9031                                  	; 30/01/2023
  9032                                  ;***	INITIALIZATION MESSAGES
  9033                                  ;	-------------------------
  9034                                  ;	include	comimsg.inc	;M00
  9035                                  ;-----------------------------------------------------------------------------	
  9036                                  
  9037                                  BADVERMSG:
  9038 00001D48 17                      	db 23
  9039 00001D49 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9039 00001D52 20444F532076657273-
  9039 00001D5B 696F6E0D0A         
  9040                                  OUTENVMSG:
  9041 00001D60 1A                      	db 26
  9042 00001D61 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9042 00001D6A 7669726F6E6D656E74-
  9042 00001D73 2073706163650D0A   
  9043                                  COPYRIGHTMSG:
  9044 00001D7B 5E                      	db 94
  9045 00001D7C 0D0A                    	db 0Dh,0Ah
  9046 00001D7E 0D0A                    	db 0Dh,0Ah
  9047 00001D80 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9047 00001D89 285229204D532D444F-
  9047 00001D92 532852292056657273-
  9047 00001D9B 696F6E20352E30300D-
  9047 00001DA4 0A                 
  9048 00001DA5 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9048 00001DAE 20202020284329436F-
  9048 00001DB7 70797269676874204D-
  9048 00001DC0 6963726F736F667420-
  9048 00001DC9 436F72702031393831-
  9048 00001DD2 2D313939312E0D0A   
  9049                                  BADCOMLKMES:
  9050 00001DDA 28                      	db 40
  9051 00001DDB 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9051 00001DE4 20434F4D4D414E4420-
  9051 00001DED 736561726368206469-
  9051 00001DF6 726563746F72792062-
  9051 00001DFF 61640D0A           
  9052                                  BADCOMACCMSG:
  9053 00001E03 36                      	db 54
  9054 00001E04 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9054 00001E0D 20434F4D4D414E4420-
  9054 00001E16 736561726368206469-
  9054 00001E1F 726563746F72792062-
  9054 00001E28 616420             
  9055 00001E2B 616363657373206465-     	db 'access denied',0Dh,0Ah
  9055 00001E34 6E6965640D0A       
  9056                                  HELPMSG1:
  9057 00001E3A 3C                      	db 60
  9058 00001E3B 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9058 00001E44 6E657720696E737461-
  9058 00001E4D 6E6365206F66207468-
  9058 00001E56 65204D532D444F5320-
  9058 00001E5F 636F6D6D616E642069-
  9058 00001E68 6E7465727072657465-
  9058 00001E71 722E0D0A           
  9059 00001E75 0D0A                    	db 0Dh,0Ah
  9060                                  HELPMSG2:
  9061 00001E77 46                      	db 70
  9062 00001E78 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9062 00001E81 5B64726976653A5D70-
  9062 00001E8A 6174685D205B646576-
  9062 00001E93 6963655D205B2F453A-
  9062 00001E9C 6E6E6E6E6E5D205B2F-
  9062 00001EA5 505D205B2F43207374-
  9062 00001EAE 72696E675D205B2F4D-
  9062 00001EB7 53475D             
  9063 00001EBA 0D0A                    	db 0Dh,0Ah
  9064 00001EBC 0D0A                    	db 0Dh,0Ah
  9065                                  HELPMSG3:
  9066 00001EBE 48                              db 72
  9067 00001EBF 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9067 00001EC8 5D7061746820202020-
  9067 00001ED1 537065636966696573-
  9067 00001EDA 207468652064697265-
  9067 00001EE3 63746F727920636F6E-
  9067 00001EEC 7461696E696E672043-
  9067 00001EF5 4F4D4D414E442E434F-
  9067 00001EFE 4D20               
  9068 00001F00 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9069                                  HELPMSG4:
  9070 00001F07 4D                      	db 77
  9071 00001F08 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9071 00001F11 202020202020202020-
  9071 00001F1A 537065636966696573-
  9071 00001F23 207468652064657669-
  9071 00001F2C 636520746F20757365-
  9071 00001F35 20666F7220636F6D6D-
  9071 00001F3E 616E6420696E707574-
  9071 00001F47 20616E6420         
  9072 00001F4C 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9073                                  HELPMSG5:
  9074 00001F55 45                      	db 69
  9075 00001F56 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9075 00001F5F 6E2020202020202020-
  9075 00001F68 536574732074686520-
  9075 00001F71 696E697469616C2065-
  9075 00001F7A 6E7669726F6E6D656E-
  9075 00001F83 742073697A6520746F-
  9075 00001F8C 206E6E6E6E6E206279-
  9075 00001F95 7465732E           
  9076 00001F99 0D0A                    	db 0Dh,0Ah
  9077                                  HELPMSG6:
  9078 00001F9B 4D                      	db 77
  9079 00001F9C 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9079 00001FA5 202020202020202020-
  9079 00001FAE 4D616B657320746865-
  9079 00001FB7 206E657720636F6D6D-
  9079 00001FC0 616E6420696E746572-
  9079 00001FC9 707265746572207065-
  9079 00001FD2 726D616E656E7420   
  9080 00001FDA 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9080 00001FE3 6974292E0D0A       
  9081                                  HELPMSG7:
  9082 00001FE9 50                      	db 80
  9083 00001FEA 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9083 00001FF3 6E6720202020202020-
  9083 00001FFC 43617272696573206F-
  9083 00002005 75742074686520636F-
  9083 0000200E 6D6D616E6420737065-
  9083 00002017 636966696564206279-
  9083 00002020 20737472696E672C20-
  9083 00002029 616E6420           
  9084 0000202D 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9084 00002036 732E0D0A           
  9085                                  HELPMSG8:
  9086 0000203A 4E                      	db 78
  9087 0000203B 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9087 00002044 202020202020202020-
  9087 0000204D 537065636966696573-
  9087 00002056 207468617420616C6C-
  9087 0000205F 206572726F72206D65-
  9087 00002068 737361676573206265-
  9087 00002071 2073746F7265642069-
  9087 0000207A 6E20               
  9088 0000207C 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9088 00002085 6F750D0A           
  9089                                  HELPMSG9:
  9090 00002089 38                      	db 56
  9091 0000208A 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9091 00002093 202020202020202020-
  9091 0000209C 6E65656420746F2073-
  9091 000020A5 706563696679202F50-
  9091 000020AE 207769746820746869-
  9091 000020B7 73207377697463682E-
  9091 000020C0 0D0A               
  9092                                  HelpMsgs:
  9093 000020C2 [3A1E]                          dw HELPMSG1
  9094 000020C4 [771E]                  	dw HELPMSG2
  9095 000020C6 [BE1E]                  	dw HELPMSG3
  9096 000020C8 [071F]                  	dw HELPMSG4
  9097 000020CA [551F]                  	dw HELPMSG5
  9098 000020CC [9B1F]                  	dw HELPMSG6
  9099 000020CE [E91F]                  	dw HELPMSG7
  9100 000020D0 [3A20]                  	dw HELPMSG8
  9101 000020D2 [8920]                  	dw HELPMSG9
  9102                                  
  9103                                  	; 23/04/2023
  9104 000020D4 0000                    	dw 0
  9105                                  
  9106                                  ;-----------------------------------------------------------------------------
  9107                                  
  9108                                  ;SR;
  9109                                  ; This table of offsets is used by the init code to calculate the new offsets
  9110                                  ;for these labels after the resident code has been relocated
  9111                                  
  9112                                  ;Reloc_Table:
  9113                                  	;dw offset CODERES:MsgInt2fHandler
  9114                                  	;dw offset CODERES:Int_2e
  9115                                  	;dw offset CODERES:ContC
  9116                                  	;dw offset CODERES:DskErr
  9117                                  	;dw offset CODERES:Exec_Ret
  9118                                  	;dw offset CODERES:TRemCheck
  9119                                  	;dw offset CODERES:TrnLodCom1
  9120                                  	;dw offset CODERES:LodCom
  9121                                  	;dw offset CODERES:MsgRetriever
  9122                                  	;dw offset CODERES:THeadFix
  9123                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9124                                  
  9125                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9126                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9127                                  
  9128                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9129 000020D6 2207                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9130 000020D8 7501                    	dw Int_2e - RCODE_START		  ; 177h	
  9131 000020DA 3300                    	dw ContC - RCODE_START		  ; 035h
  9132 000020DC 3604                    	dw DSKERR - RCODE_START		  ; 445h
  9133 000020DE 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9134 000020E0 9902                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9135 000020E2 1304                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9136 000020E4 AC01                    	dw LodCom - RCODE_START		  ; 1AEh
  9137 000020E6 6507                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9138 000020E8 B802                    	dw THeadFix - RCODE_START	  ; 2C2h
  9139 000020EA DE07                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9140                                  
  9141                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9142                                  
  9143                                  ResJmpTable:
  9144 000020EC 00000000                	dd 0			; stores prev stub jump table addr
  9145                                  FirstCom:
  9146 000020F0 00                      	db 0			; flag set if first command.com
  9147                                  DevFlag:
  9148 000020F1 00                      	db 0
  9149                                  PathFlag:
  9150 000020F2 00                      	db 0
  9151                                  
  9152                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9153                                  	;times 13 db 0
  9154                                  
  9155                                  ; 30/01/2023
  9156                                  coderes_end equ $
  9157                                  
  9158                                  ;INIT	ENDS
  9159                                  
  9160                                  ;	END
  9161                                  
  9162                                  ;-----------------------------------------------------------------------------
  9163                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9164                                  ;-----------------------------------------------------------------------------
  9165                                  
  9166                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9167                                  	; 30/01/2023
  9168 000020F3 00                      db	0
  9169 000020F4 526574726F20444F53-     db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9169 000020FD 2076342E3020434F4D-
  9169 00002106 4D414E442E434F4D20-
  9169 0000210F 6279204572646F6761-
  9169 00002118 6E2054616E205B3230-
  9169 00002121 32335D             
  9170 00002124 00                      db	0
  9171                                  
  9172                                  ;-----------------------------------------------------------------------------
  9173                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9174                                  ;-----------------------------------------------------------------------------
  9175                                  
  9176                                  ;TAIL    SEGMENT PUBLIC PARA
  9177                                  ;        ORG     0
  9178                                  ;TRANSTART LABEL WORD
  9179                                  ;TAIL    ENDS
  9180                                  
  9181                                  ;ALIGN 16  ; 25/09/2018
  9182                                  
  9183                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9184                                  
  9185                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9186                                  numbertomod equ (numbertodiv % 16)
  9187                                  
  9188                                  %if numbertomod>0 & numbertomod<16
  9189 00002125 00<rep Bh>              	times (16-numbertomod) db 0
  9190                                  %endif
  9191                                  
  9192                                  ; 30/01/2023
  9193                                  ;TRANSTART:
  9194                                  
  9195                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9196                                  ;	times	128 db 0	
  9197                                  
  9198                                  ;-----------------------------------------------------------------------------
  9199                                  ; SEGMENT - TRANSCODE
  9200                                  ;-----------------------------------------------------------------------------
  9201                                  
  9202                                  ;TRANGROUP: ; 21/04/2018
  9203                                  
  9204                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9205                                  ;-----------------------------------------------------------------------------
  9206                                  
  9207                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9208                                  
  9209                                  ; 21/04/2018 - Retro DOS v2.0
  9210                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9211                                  ; (these values must be changed when transcom.s source code is changed
  9212                                  ; and data offsets are changed)
  9213                                  ;
  9214                                  ; 30/04/2018
  9215                                  ; 29/04/2018
  9216                                  
  9217                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9218                                  ;COMMAND      EQU  012CH
  9219                                  ;DATINIT      EQU  2091H
  9220                                  ;HEADCALL     EQU  428FH
  9221                                  ;TRANSPACEEND EQU  4D5CH
  9222                                  ;TRANDATAEND  EQU  3F44H
  9223                                  
  9224                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9225                                  ;TRIAGE_INIT  EQU  1F15H
  9226                                  ;PRINTF_INIT  EQU  34E0H 
  9227                                  
  9228                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9229                                  
  9230                                  ;TPA	EQU  4293H
  9231                                  ;TRNLEN	EQU  04D6H
  9232                                  
  9233                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9234                                  ;COMMAND      EQU  012CH
  9235                                  ;DATINIT      EQU  206FH
  9236                                  ;HEADCALL     EQU  426FH
  9237                                  ; 09/01/2023
  9238                                  ;TRANSPACEEND EQU  4D3CH
  9239                                  ;TRANDATAEND  EQU  3F24H
  9240                                  ;TRIAGE_INIT  EQU  1EF3H
  9241                                  ;PRINTF_INIT  EQU  34BFH 
  9242                                  ;
  9243                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9244                                  
  9245                                  ;-----------------------------------------------------------------------------
  9246                                  ; ARENA.INC, MSDOS 6.0, 1991
  9247                                  ;-----------------------------------------------------------------------------
  9248                                  ; 13/10/2018 - Retro DOS 3.0
  9249                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9250                                  
  9251                                  ;BREAK <Memory arena structure>
  9252                                  
  9253                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9254                                  
  9255                                  ; arena item
  9256                                  
  9257                                  struc ARENA
  9258 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9259 00000001 ????                      .owner:	resw 1		; owner of arena item
  9260 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9261                                  endstruc
  9262                                  
  9263                                  ;-----------------------------------------------------------------------------
  9264                                  ;START OF TRANSIENT PORTION
  9265                                  ;This code is loaded at the end of memory and may be overwritten by
  9266                                  ;memory-intensive user programs.
  9267                                  ;-----------------------------------------------------------------------------
  9268                                  
  9269                                  ; 16/04/2023
  9270                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9271                                  ; 29/09/2018
  9272                                  ; 31/01/2023 
  9273                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9274                                  			; 09/01/2023
  9275                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9276                                  
  9277                                  ; 25/09/2018
  9278                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9279                                  ;
  9280                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9281                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9282                                  ;
  9283                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9284                                  ;
  9285                                  ;
  9286                                  ;COMTRANS:
  9287                                  ;
  9288                                  ; 20/10/2018 - Retro DOS v3.0	
  9289                                  ;INCBIN	"TRANCOM3.BIN"
  9290                                  ;
  9291                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9292                                  ;
  9293                                  ; 29/04/2018
  9294                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9295                                  ;
  9296                                  ;TIMES BSS_SIZE db 0
  9297                                  ;
  9298                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9299                                  
  9300                                  ;COMMANDCOMSIZE equ $ - 100h
  9301                                  
  9302                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9303                                  ; ============================================================================
  9304                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9305                                  ; ============================================================================
  9306                                  
  9307                                  ; ----------------------------------------------------------------------------
  9308                                  ; START OF TRANSIENT PORTION
  9309                                  ; ----------------------------------------------------------------------------
  9310                                  ; SEGMENT - TRANSCODE
  9311                                  ; ----------------------------------------------------------------------------
  9312                                  
  9313                                  ; 18/04/2023
  9314                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9315                                  
  9316                                  ; 18/04/2023
  9317                                  ;-----------------------------------------------------------------------------
  9318                                  ; TRANSCODE segment offset 0
  9319                                  TRANSIENTSTART:
  9320                                  
  9321                                  	; 31/01/2023
  9322 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9323                                  
  9324                                  ;============================================================================
  9325                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9326                                  ;============================================================================
  9327                                  ; 12/10/2018 - Retro DOS v3.0
  9328                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9329                                  
  9330                                  ;[ORG 100h]
  9331                                  
  9332                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9333                                  
  9334                                  ; ---------------------------------------------------------------------------
  9335                                  		
  9336                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9337                                  		; (TRANGROUP:0100h)
  9338                                  SETDRV:
  9339 00000100 B40E                    	mov	ah,0Eh
  9340                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9341 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9342                                  			; DL = new default drive number
  9343                                  			;		(0 = A, 1 = B, ..)
  9344                                  			; Return: AL = number of logical drives
  9345                                  
  9346                                  ; ---------------------------------------------------------------------------
  9347                                  
  9348                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9349                                  ; No registers (CS:IP) no flags, nothing.
  9350                                  
  9351                                  TCOMMAND:
  9352 00000104 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
  9353 00000109 B8FFFF                  	mov	ax,-1
  9354 0000010C 8706[A801]              	xchg	ax,[VerVal]
  9355 00000110 83F8FF                  	cmp	ax,-1
  9356 00000113 7404                    	je	short NOSETVER2
  9357 00000115 B42E                    	mov	ah,2Eh
  9358                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9359 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9360                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9361                                  NOSETVER2:
  9362 00000119 2EFF1E[BE8A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9363 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9364 00000120 833E[A601]FF            	cmp	word [SingleCom],-1
  9365 00000125 7505                    	jne	short COMMAND
  9366                                  _$EXITPREP:
  9367 00000127 0E                      	push	cs
  9368 00000128 1F                      	pop	ds
  9369 00000129 E92520                  	jmp	_$EXIT		; Have finished the single command
  9370                                  
  9371                                  ; ---------------------------------------------------------------------------
  9372                                  ;
  9373                                  ; Main entry point from resident portion.
  9374                                  ;
  9375                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9376                                  ;   just beginning the processing of another command.
  9377                                  ;
  9378                                  ; ---------------------------------------------------------------------------
  9379                                  
  9380                                  ; We are not always sure of the state of the world at this time. We presume
  9381                                  ; worst case and initialize the relevant registers: segments and stack.
  9382                                  
  9383                                  COMMAND:
  9384 0000012C FC                      	cld
  9385 0000012D 8CC8                    	mov	ax,cs
  9386 0000012F FA                      	cli
  9387 00000130 8ED0                    	mov	ss,ax
  9388                                  	;mov	sp,offset TRANGROUP:STACK
  9389                                  				; 07/06/2023
  9390 00000132 BC[9E95]                	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
  9391                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9392 00000135 FB                      	sti
  9393                                  		
  9394 00000136 8EC0                    	mov	es,ax
  9395                                  		
  9396                                  	; MSDOS 6.0
  9397 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9398                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9399                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9400                                  	; 31/01/2023
  9401 0000013A E8C74D                  	call	TSYSLOADMSG
  9402 0000013D C606[358E]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9403                                  
  9404                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9405                                  	;mov	ds,[ss:RESSEG]
  9406                                  	; 31/01/2023
  9407 00000142 8E1E[C08A]              	mov	ds,[RESSEG]
  9408 00000146 36C606[9C88]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9409 0000014C 36C606[1F89]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9410                                  
  9411                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9412                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9413                                  ; I guess not: the only circumstances in which we reload the command processor
  9414                                  ; is after a transient program execution. In this case, we let the current
  9415                                  ; directory lie where it may.
  9416                                  
  9417 00000152 09ED                    	or	bp,bp		; See if just read
  9418 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9419 00000156 36C706[9D88]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9420 0000015D EB17                    	jmp	short NOSETBUF
  9421                                  TESTRDIR:
  9422 0000015F 803E[A401]00            	cmp	byte [RestDir],0
  9423 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9424 00000166 1E                      	push	ds
  9425                                  
  9426                                  ; We have an unusual situation to handle. The user *may* have changed his
  9427                                  ; directory as a result of an internal command that got aborted. Restoring it
  9428                                  ; twice may not help us: the problem may never go away. We just attempt it
  9429                                  ; once and give up.
  9430                                  
  9431 00000167 C606[A401]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9432                                  
  9433                                  	; Restore users directory
  9434 0000016C 0E                      	push	cs
  9435 0000016D 1F                      	pop	ds
  9436 0000016E BA[A289]                	mov	dx,USERDIR1
  9437 00000171 B43B                    	mov	ah,3Bh
  9438                                  	;mov	ah,CHDir ; 3Bh
  9439 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9440                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9441 00000175 1F                      	pop	ds
  9442                                  NOSETBUF:
  9443 00000176 803E[1902]00            	cmp	byte [PipeFiles],0
  9444 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9445 0000017D 803E[1802]00            	cmp	byte [PipeFlag],0
  9446 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9447 00000184 E8772B                  	call	PIPEDEL
  9448                                  NOPCLOSE:
  9449                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9450                                  	; 31/01/2023
  9451 00000187 C606[9C01]00            	mov	byte [ExtCom],0 ; Flag internal command
  9452 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9453 0000018E 8ED8                    	mov	ds,ax
  9454 00000190 50                      	push	ax
  9455                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9456 00000191 BA[9E95]                	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
  9457                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9458 00000194 B80038                  	mov	ax,3800h
  9459                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9460 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9461                                  			; get current-country info
  9462                                  			; DS:DX	-> buffer for returned info
  9463 00000199 58                      	pop	ax
  9464 0000019A 2B06[C28A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9465 0000019E 53                      	push	bx
  9466 0000019F BB1000                  	mov	bx,16
  9467 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9468 000001A4 5B                      	pop	bx
  9469 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9470 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9471 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9472                                  SAVSIZ:
  9473                                  
  9474                                  ; AX is the number of bytes free in the buffer between the resident and the
  9475                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9476                                  
  9477 000001AC 3D0002                  	cmp	ax,512
  9478 000001AF 7603                    	jbe	short GOTSIZE
  9479                                  	;and	ax,~1FFh
  9480 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9481                                  GOTSIZE:
  9482 000001B4 A3[E18A]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9483 000001B7 8E1E[C08A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9484                                  
  9485 000001BB F606[A001]01            	test	byte [EchoFlag],1 
  9486 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9487 000001C2 E8182B                  	call	SINGLETEST
  9488 000001C5 7219                    	jb	short GETCOM
  9489 000001C7 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1
  9490 000001CC 7512                    	jnz	short GETCOM
  9491                                  				; G  Don't print prompt in FOR
  9492 000001CE F606[AC01]FF            	test	byte [ForFlag],0FFh ; -1
  9493 000001D3 750B                    	jnz	short GETCOM
  9494                                  				; G  Don't print prompt if in batch
  9495 000001D5 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
  9496 000001DB 7503                    	jnz	short GETCOM
  9497 000001DD E8F923                  	call	CRLF2
  9498                                  GETCOM:
  9499 000001E0 C606[B101]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9500 000001E5 C606[B201]00            	mov	byte [Call_Batch_Flag],0
  9501 000001EA B419                    	mov	ah,19h
  9502                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9503 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9504 000001EE 36A2[D48A]              	mov	[ss:CURDRV],al
  9505 000001F2 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9506 000001F7 7403                    	jz	short NOPIPE
  9507 000001F9 E9CD2B                  	jmp	PIPEPROC	; Continue the pipeline
  9508                                  NOPIPE:
  9509 000001FC F606[A001]01            	test	byte [EchoFlag],1
  9510 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9511 00000203 E8D72A                  	call	SINGLETEST
  9512 00000206 7212                    	jb	short NOPDRV
  9513 00000208 F606[AC01]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9514 0000020D 750B                    	jnz	short NOPDRV
  9515 0000020F F706[4C01]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9516 00000215 750D                    	jnz	short TESTFORBAT
  9517 00000217 E8781B                  	call	PRINT_PROMPT	; Prompt the user
  9518                                  NOPDRV:
  9519 0000021A F606[AC01]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9520 0000021F 7403                    	jz	short TESTFORBAT
  9521 00000221 E9BD0B                  	jmp	FORPROC		; Continue the FOR
  9522                                  
  9523                                  TESTFORBAT:
  9524 00000224 36C606[6B8A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9525 0000022A C606[C701]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9526 0000022F C606[C601]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9527 00000234 C606[AB01]00            	mov	byte [IfFlag],0	; no more ifs...
  9528 00000239 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9529 0000023F 7441                    	jz	short ISNOBAT
  9530                                  
  9531                                  	; 31/01/2023
  9532                                  
  9533                                  	; MSDOS 6.0
  9534                                  
  9535                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9536                                  
  9537 00000241 06                      	push	es			;AN000; save ES
  9538 00000242 1E                      	push	ds			;AN000; save DS
  9539                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9540                                  	; 05/02/2023
  9541 00000243 B80219                  	mov	ax,1902h
  9542 00000246 8E06[4C01]              	mov	es,[Batch]		;AN000; get batch segment
  9543                                  	;mov	di,20h
  9544 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9545 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9546 0000024E 1F                      	pop	ds			;AN000;
  9547                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9548 0000024F BA[1F89]                	mov	dx,COMBUF
  9549 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9550                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9551                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9552                                  		; final filename element uppercased
  9553                                  		; DS:DX -> buffer for results
  9554                                  	;cmp	al,0FFh
  9555 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9556 00000256 1F                      	pop	ds			;AN000; restore DS
  9557 00000257 07                      	pop	es			;AN000; restore ES
  9558 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9559                                  
  9560                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9561 0000025A 1E                      	push	ds
  9562 0000025B E81603                  	call	READBAT			; Continue BATCH
  9563 0000025E 1F                      	pop	ds
  9564 0000025F C606[B501]00            	mov	byte [NullFlag],0	;G reset no command flag
  9565 00000264 F706[4C01]FFFF          	test	word [Batch],0FFFFh
  9566 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9567 0000026C 8B1E[B301]              	mov	bx,[Next_Batch]
  9568                                  	; 31/01/2023
  9569 00000270 09DB                    	or	bx,bx
  9570                                  	;cmp	bx,0			;G see if there is a new batch file
  9571 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9572 00000274 891E[4C01]              	mov	[Batch],bx		;G get segment of next batch file
  9573 00000278 C706[B301]0000          	mov	word [Next_Batch],0	;G reset next batch
  9574                                  JDOCOM1:
  9575 0000027E 0E                      	push	cs
  9576 0000027F 1F                      	pop	ds
  9577 00000280 EB55                    	jmp	short DOCOM1
  9578                                  ISNOBAT:
  9579 00000282 833E[A601]00            	cmp	word [SingleCom],0
  9580 00000287 741C                    	jz	short REGCOM
  9581                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9582 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9583 0000028C 8736[A601]              	xchg	si,[SingleCom]
  9584 00000290 BF[2189]                	mov	di,COMBUF+2
  9585 00000293 31C9                    	xor	cx,cx
  9586                                  SINGLELOOP:
  9587 00000295 AC                      	lodsb
  9588 00000296 AA                      	stosb
  9589 00000297 41                      	inc	cx
  9590 00000298 3C0D                    	cmp	al,0Dh
  9591 0000029A 75F9                    	jnz	short SINGLELOOP
  9592 0000029C 49                      	dec	cx
  9593 0000029D 0E                      	push	cs
  9594 0000029E 1F                      	pop	ds
  9595 0000029F 880E[2089]              	mov	[COMBUF+1],cl
  9596                                  
  9597                                  ; do NOT issue a trailing CRLF...
  9598                                  
  9599 000002A3 EB32                    	jmp	short DOCOM1
  9600                                  
  9601                                  	;nop
  9602                                  
  9603                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9604                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9605                                  
  9606                                  ; We have a normal command.  
  9607                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9608                                  ; sometimes they aren't. At this point, we automatically close all spool
  9609                                  ; files and turn on truncation mode.
  9610                                  
  9611                                  REGCOM:
  9612                                  	;mov	ax,(ServerCall shl 8) + 9
  9613                                  	; 31/01/2023
  9614 000002A5 B8095D                  	mov	ax,5D09h
  9615                                  	;mov	ax,(SERVERCALL<<8)+9
  9616 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9617                                  	;mov	ax,(ServerCall shl 8) + 8
  9618 000002AA B8085D                  	mov	ax,5D08h
  9619                                  	;mov	ax,(SERVERCALL<<8)+8
  9620 000002AD B201                    	mov	dl,1
  9621 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9622                                  			; DL = 00h redirected output is	combined
  9623                                  			;      01h redirected output placed in separate	jobs
  9624                                  			; start	new print job now
  9625 000002B1 0E                      	push	cs
  9626 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9627 000002B3 BA[9C88]                	mov	dx,UCOMBUF
  9628                                  
  9629                                  	; MSDOS 6.0
  9630                                  ;	Try to read interactive command line via DOSKey.
  9631                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9632                                  
  9633                                  	; 31/01/2023
  9634 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9635 000002B9 CD2F                    	int	2Fh
  9636 000002BB 09C0                    	or	ax,ax
  9637 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9638                                  
  9639 000002BF B40A                    	mov	ah,0Ah
  9640                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9641 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9642                                  			; DS:DX	-> buffer
  9643                                  GOTCOM:
  9644 000002C3 8A0E[9C88]              	mov	cl,[UCOMBUF]
  9645 000002C7 30ED                    	xor	ch,ch
  9646 000002C9 83C103                  	add	cx,3
  9647 000002CC BE[9C88]                	mov	si,UCOMBUF
  9648 000002CF BF[1F89]                	mov	di,COMBUF
  9649 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9650                                  DOCOM:
  9651 000002D4 E80223                  	call	CRLF2
  9652                                  DOCOM1:
  9653 000002D7 E88626                  	call	PRESCAN		; Cook the input buffer
  9654 000002DA 7406                    	jz	short NOPIPEPROC
  9655 000002DC E9692A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9656                                  
  9657                                  NULLCOMJ:
  9658 000002DF E9FA00                  	jmp	NULLCOM
  9659                                  
  9660                                  NOPIPEPROC:
  9661 000002E2 E86D2D                  	call	PARSELINE
  9662 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9663                                  BADPARSE:
  9664 000002E7 0E                      	push	cs
  9665 000002E8 1F                      	pop	ds
  9666 000002E9 BA[787F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9667 000002EC E82C4B                  	call	std_eprintf
  9668 000002EF E912FE                  	jmp	TCOMMAND
  9669                                  
  9670                                  OKPARSE:
  9671                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9672                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9673                                  	; 01/02/2023
  9674 000002F2 F606[518E]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9675 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9676                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9677 000002F9 833E[0F91]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9678 000002FE 74DF                    	jz	short NULLCOMJ
  9679                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9680 00000300 833E[548E]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9681 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9682                                  
  9683 00000307 BE[2189]                	mov	si,COMBUF+2
  9684 0000030A BF[4A8B]                	mov	di,IDLEN
  9685                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9686                                  				; Make FCB with blank scan-off
  9687                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9688 0000030D B80129                  	mov	ax,2901h
  9689 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9690                                  			; DS:SI	-> string to parse
  9691                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9692                                  			; AL = bit mask	to control parsing
  9693                                  	;mov	bx,[ARG_ARGV]
  9694 00000312 8B1E[4F8E]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9695 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9696 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9697 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9698                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9699                                  	;and	dl,~20h
  9700 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9701                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9702                                  	; 31/01/2023
  9703 00000321 80EA41                  	sub	dl,'A'
  9704 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9705 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9706                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9707 00000328 8B3E[528E]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9708 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9709 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9710 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9711                                  DRVBADJ:
  9712 00000334 E92B25                  	jmp	DRVBAD
  9713                                  DRVGD:
  9714 00000337 8A05                    	mov	al,[di]
  9715 00000339 A2[E08A]                	mov	[SPECDRV],al
  9716 0000033C B020                    	mov	al,' '
  9717 0000033E B90900                  	mov	cx,9
  9718 00000341 47                      	inc	di
  9719 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9720 00000344 B008                    	mov	al,8
  9721 00000346 28C8                    	sub	al,cl
  9722 00000348 A2[4A8B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9723 0000034B BF8100                  	mov	di,81h
  9724 0000034E 56                      	push	si
  9725 0000034F BE[2189]                	mov	si,COMBUF+2	; Skip over all leading delims
  9726 00000352 E89122                  	call	scanoff
  9727                                  
  9728                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9729                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9730                                  
  9731                                  	; MSDOS 6.0
  9732                                  ;SR;
  9733                                  ; We are going to skip over the first char always. The logic is that the
  9734                                  ;command tail can never start from the first character. The code below is 
  9735                                  ;trying to figure out the command tail and copy it to the command line 
  9736                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9737                                  ;character and the user given command line is a full 128 bytes, we try to
  9738                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9739                                  ;char overwrites the code and leads to a crash on future commands.
  9740                                  
  9741 00000355 46                      	inc	si ;  MSDOS 6.0
  9742                                  DO_SKIPCOM:
  9743 00000356 AC                      	lodsb			; move command line pointer over
  9744 00000357 E89422                  	call	DELIM		; pathname -- have to do it ourselves
  9745 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9746 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9747 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9748 00000360 3A06[C48A]              	cmp	al,[SWITCHAR]	; specified command string
  9749 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9750                                  DO_SKIPPED:
  9751 00000366 4E                      	dec	si
  9752 00000367 31C9                    	xor	cx,cx
  9753                                  COMTAIL:
  9754 00000369 AC                      	lodsb
  9755 0000036A AA                      	stosb			; Move command tail to 80h
  9756 0000036B 3C0D                    	cmp	al,0Dh
  9757 0000036D E0FA                    	loopne	COMTAIL
  9758 0000036F 4F                      	dec	di
  9759 00000370 89FD                    	mov	bp,di
  9760 00000372 F6D1                    	not	cl
  9761 00000374 880E8000                	mov	[80h],cl
  9762 00000378 5E                      	pop	si
  9763                                  ;-----
  9764                                  ; Some of these comments are sadly at odds with this brave new code.
  9765                                  ;-----
  9766                                  ; If the command has 0 parameters must check here for
  9767                                  ; any switches that might be present.
  9768                                  ; SI -> first character after the command.
  9769                                  
  9770                                  	;mov	di,arg.argv[0].argsw_word
  9771                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9772 00000379 8B3E[568E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9773 0000037D 893E[D78A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9774                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9775                                  				; s = argv[1];
  9776                                  	;mov	si,[ARGV1_ARGPOINTER]
  9777 00000381 8B36[5A8E]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9778 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9779 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9780 00000389 89EE                    	mov	si,bp
  9781                                  DOPARSE:
  9782 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9783                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9784                                  	; 01/02/2023
  9785 0000038E B80129                  	mov	ax,2901h
  9786                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9787 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9788                                  			; DS:SI	-> string to parse
  9789                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9790                                  			; AL = bit mask	to control parsing
  9791 00000393 A2[D58A]                	mov	[PARM1],al	; Save result of parse
  9792                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9793                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9794 00000396 8B3E[618E]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9795 0000039A 893E[D98A]              	mov	[ARG1S],di
  9796                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9797                                  				; s = argv[2];
  9798                                  	;mov	si,[ARGV2_ARGPOINTER]
  9799 0000039E 8B36[658E]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9800 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9801 000003A4 7502                    	jnz	short DOPARSE2
  9802 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9803                                  DOPARSE2:			
  9804 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9805                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9806 000003AB B80129                  	mov	ax,2901h
  9807                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9808 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9809                                  			; DS:SI	-> string to parse
  9810                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9811                                  			; AL = bit mask	to control parsing
  9812 000003B0 A2[D68A]                	mov	[PARM2],al	; Save result
  9813                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9814                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9815 000003B3 8B3E[6C8E]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9816 000003B7 893E[DB8A]              	mov	[ARG2S],di
  9817                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9818                                  	;mov	di,arg.argv[0].argsw_word
  9819 000003BB 8B3E[568E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9820 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9821                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9822                                  	;and	di,arg.argswinfo	
  9823 000003C1 233E[1191]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9824 000003C5 893E[DD8A]              	mov	[ARGTS],di
  9825                                  
  9826 000003C9 A0[4A8B]                	mov	al,[IDLEN]
  9827 000003CC 8A16[E08A]              	mov	dl,[SPECDRV]
  9828 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9829 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9830 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9831 000003D6 E9DC23                  	jmp	FNDCOM		; otherwise, check internal com table
  9832                                  EXTERNALJ1:
  9833 000003D9 E9DE24                  	jmp	EXTERNAL
  9834                                  NULLCOM:
  9835 000003DC 8E1E[C08A]              	mov	ds,[RESSEG]
  9836 000003E0 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9837 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9838 000003E8 C606[B501]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9839                                  	;mov	byte [NullFlag],nullcommand ; 1
  9840                                  NOSETFLAG:
  9841 000003ED 833E[A601]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9842 000003F2 7403                    	je	short EXITJ
  9843 000003F4 E9E9FD                  	jmp	GETCOM
  9844                                  EXITJ:
  9845 000003F7 E92DFD                  	jmp	_$EXITPREP
  9846                                  
  9847                                  ;============================================================================
  9848                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9849                                  ;============================================================================
  9850                                  ; 12/10/2018 - Retro DOS v3.0
  9851                                  
  9852                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9853                                  
  9854                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9855                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9856                                  ;   there is a header that describes a block of rom program.  This header
  9857                                  ;   contains information needed to initialize a module and to provide PCDOS
  9858                                  ;   with a set of reserved names for execution.
  9859                                  ;
  9860                                  ;   This header has the following format:
  9861                                  ;
  9862                                  ;   rom_header	STRUC
  9863                                  ;	Signature1  DB	55h
  9864                                  ;	Signature2  DB	AAh
  9865                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9866                                  ;	init_jmp    DB	3 dup (?)
  9867                                  ;	name_list   name_struc <>
  9868                                  ;   rom_header	ENDS
  9869                                  ;
  9870                                  ;   name_struc	STRUC
  9871                                  ;	name_len    DB	?
  9872                                  ;	name_text   DB	? DUP (?)
  9873                                  ;	name_jmp    DB	3 DUP (?)
  9874                                  ;   name_struc	ENDS
  9875                                  ;
  9876                                  ;   The name list is a list of names that are reserved by a particular section
  9877                                  ;   of a module.  This list of names is terminated by a null name (length
  9878                                  ;   is zero).
  9879                                  ;
  9880                                  ;   Consider now, the PCDOS action when a user enters a command:
  9881                                  ;
  9882                                  ;	COMMAND.COM has control.
  9883                                  ;	o   If location FFFFEh has FDh then
  9884                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  9885                                  ;		    by AAh, stop scan if we get above or = F0000H
  9886                                  ;	o	When we've found one, compare the name entered by the user
  9887                                  ;		    with the one found in the rom.  If we have a match, then
  9888                                  ;		    set up the environment for execution and do a long jump
  9889                                  ;		    to the near jump after the found name.
  9890                                  ;	o	If no more names in the list, then continue scanning the module
  9891                                  ;		    for more 55h followed by AAh.
  9892                                  ;	o   We get to this point only if there is no matching name in the
  9893                                  ;		rom.  We now look on disk for the command.
  9894                                  ;
  9895                                  ;   This gives us the flexibility to execute any rom cartridge without having
  9896                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  9897                                  ;   want to be invisible to the DOS should not have any names in their lists
  9898                                  ;   (i.e. they have a single null name).
  9899                                  ;
  9900                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  9901                                  ;   Clearly this version will be available on disk.  How does a user actually
  9902                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  9903                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  9904                                  ;   solution:
  9905                                  ;
  9906                                  ;   o	Keep things consistent and force the user to have his software named
  9907                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  9908                                  
  9909                                  struc ROM_HEADER
  9910 00000000 ??                          .signature1: resb 1
  9911 00000001 ??                          .signature2: resb 1
  9912 00000002 ??                          .rom_length: resb 1
  9913 00000003 ??????                      .init_jmp:	 resb 3
  9914 00000006 ??                          .name_list:	 resb 1
  9915                                      .size:
  9916                                  endstruc
  9917                                  
  9918                                  struc NAME_STRUC
  9919 00000000 ??                          .name_len:	resb 1
  9920 00000001 ??                          .name_text:	resb 1
  9921 00000002 ??????                      .name_jmp:	resb 3
  9922                                      .size:	
  9923                                  endstruc
  9924                                  
  9925                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  9926                                  
  9927                                  ; =============== S U B	R O U T	I N E =======================================
  9928                                  
  9929                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  9930                                  
  9931                                  ; 05/02/2023
  9932                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
  9933                                  
  9934                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  9935                                  
  9936                                  ROM_SCAN:
  9937 000003FA 06                      	push	es
  9938 000003FB 56                      	push	si
  9939 000003FC 57                      	push	di
  9940 000003FD 51                      	push	cx
  9941 000003FE 50                      	push	ax
  9942 000003FF 53                      	push	bx
  9943                                  
  9944                                  	; check for PC Jr signature in rom
  9945                                  
  9946 00000400 B800F0                  	mov	ax,0F000h
  9947 00000403 8EC0                    	mov	es,ax
  9948 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
  9949 0000040B 7408                    	je	short SCAN_IT
  9950                                  NO_ROM:
  9951 0000040D F8                      	clc
  9952                                  ROM_RET:
  9953 0000040E 5B                      	pop	bx
  9954 0000040F 58                      	pop	ax
  9955 00000410 59                      	pop	cx
  9956 00000411 5F                      	pop	di
  9957 00000412 5E                      	pop	si
  9958 00000413 07                      	pop	es
  9959 00000414 C3                      	retn
  9960                                  
  9961                                  	; start scanning at C000h
  9962                                  SCAN_IT:
  9963 00000415 B800C0                  	mov	ax,0C000h
  9964                                  SCAN_ONE:
  9965 00000418 8EC0                    	mov	es,ax
  9966 0000041A 31FF                    	xor	di,di
  9967                                  
  9968                                  	; check for a valid header
  9969                                  SCAN_MODULE:
  9970 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
  9971 00000421 740A                    	je	short SCAN_LIST
  9972 00000423 058000                  	add	ax,80h
  9973                                  SCAN_END:
  9974 00000426 3D00F0                  	cmp	ax,0F000h
  9975 00000429 72ED                    	jb	short SCAN_ONE
  9976 0000042B EBE0                    	jmp	short NO_ROM
  9977                                  
  9978                                  	; trundle down list of names
  9979                                  SCAN_LIST:
  9980                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
  9981 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
  9982 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
  9983 00000433 D1E3                    	shl	bx,1
  9984 00000435 D1E3                    	shl	bx,1		; number of paragraphs
  9985 00000437 83C37F                  	add	bx,7Fh
  9986 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
  9987                                  	;mov	di,6
  9988                                  	; 05/05/2023
  9989 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
  9990                                  	;nop
  9991                                  SCAN_NAME:
  9992 00000440 268A0D                  	mov	cl,[es:di]	; length of name
  9993 00000443 47                      	inc	di		; point to name
  9994 00000444 30ED                    	xor	ch,ch
  9995 00000446 09C9                    	or	cx,cx		; zero length name
  9996 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
  9997 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
  9998 0000044C EBD8                    	jmp	short SCAN_END
  9999                                  
 10000                                  	; compare a single name
 10001                                  SCAN_TEST:
 10002 0000044E 89D6                    	mov	si,dx
 10003 00000450 46                      	inc	si
 10004 00000451 F3A6                    	repe cmpsb		 ; compare name
 10005 00000453 7407                    	jz	short SCAN_FOUND ; success!
 10006                                  SCAN_NEXT:
 10007 00000455 01CF                    	add	di,cx		; failure, next name piece
 10008 00000457 83C703                  	add	di,3
 10009 0000045A EBE4                    	jmp	short SCAN_NAME
 10010                                  
 10011                                  	; found a name. save entry location
 10012                                  SCAN_FOUND:	
 10013 0000045C 803C3F                  	cmp	byte [si],'?'
 10014 0000045F 7405                    	je	short SCAN_SAVE
 10015 00000461 803C20                  	cmp	byte [si],' '
 10016 00000464 75EF                    	jne	short SCAN_NEXT
 10017                                  SCAN_SAVE:
 10018 00000466 2E8C06[C58C]            	mov	[cs:ROM_CS],es
 10019 0000046B 2E893E[C38C]            	mov	[cs:ROM_IP],di
 10020 00000470 F9                      	stc
 10021 00000471 EB9B                    	jmp	short ROM_RET
 10022                                  
 10023                                  ; ---------------------------------------------------------------------------
 10024                                  
 10025                                  ; execute a rom-placed body of code. allocate largest block
 10026                                  
 10027                                  ROM_EXEC:
 10028 00000473 BBFFFF                  	mov	bx,0FFFFh
 10029                                  	; 05/02/2023
 10030 00000476 B448                    	mov	ah,48h
 10031                                  	;mov	ah,ALLOC ; 48h
 10032 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10033                                  			; BX = number of 16-byte paragraphs desired
 10034 0000047A B448                    	mov	ah,48h
 10035                                  	;mov	ah,ALLOC ; 48h
 10036 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10037                                  			; BX = number of 16-byte paragraphs desired
 10038 0000047E 53                      	push	bx
 10039 0000047F 50                      	push	ax
 10040                                  
 10041                                  	; set terminate addresses
 10042                                  
 10043 00000480 B82225                  	mov	ax,2522h
 10044                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10045                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10046 00000483 1E                      	push	ds
 10047 00000484 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 10048                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10049                                  	;mov	dx,131h ; MSDOS 3.3
 10050                                  	; 05/02/2023
 10051                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10052 00000489 BA[390C]                	mov	dx,Exec_Wait
 10053 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10054                                  			; AL = interrupt number
 10055                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10056 0000048E 8CDA                    	mov	dx,ds
 10057 00000490 8EC2                    	mov	es,dx
 10058 00000492 1F                      	pop	ds
 10059                                  		
 10060                                  	; and create program header and dup all jfn's
 10061                                  
 10062 00000493 5A                      	pop	dx
 10063 00000494 B455                    	mov	ah,55h
 10064                                  	;mov	ah,DUP_PDB ; 55h
 10065 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10066                                  			; DX = segment number at which to set up PSP
 10067                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10068                                  		
 10069                                  	; set up dma address
 10070                                  
 10071 00000498 8EDA                    	mov	ds,dx
 10072 0000049A BA8000                  	mov	dx,80h
 10073 0000049D B41A                    	mov	ah,1Ah
 10074                                  	;mov	ah,Set_DMA ; 1Ah
 10075 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10076                                  			; DS:DX	-> disk	transfer buffer
 10077                                  
 10078                                  	; copy in environment info
 10079                                  
 10080 000004A1 26A1[3F03]              	mov	ax,[es:EnvirSeg]
 10081                                  	;mov	[2Ch],ax
 10082 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10083                                  
 10084                                  	; set up correct size of block
 10085                                  
 10086 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10087 000004A9 8CDA                    	mov	dx,ds
 10088 000004AB 01DA                    	add	dx,bx
 10089                                  	;mov	[2],dx
 10090 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10091                                  
 10092                                  	; change ownership of block
 10093                                  
 10094 000004B1 8CDA                    	mov	dx,ds
 10095 000004B3 4A                      	dec	dx
 10096 000004B4 8EDA                    	mov	ds,dx
 10097 000004B6 42                      	inc	dx	
 10098                                  	;mov	[1],dx
 10099 000004B7 89160100                	mov	[ARENA.owner],dx
 10100 000004BB 8EDA                    	mov	ds,dx
 10101                                  
 10102                                  	; set up correct stack
 10103                                  
 10104 000004BD 81FB0010                	cmp	bx,1000h
 10105 000004C1 7202                    	jb	short GOT_STACK
 10106 000004C3 31DB                    	xor	bx,bx
 10107                                  GOT_STACK:
 10108 000004C5 B104                    	mov	cl,4
 10109 000004C7 D3E3                    	shl	bx,cl
 10110 000004C9 8CDA                    	mov	dx,ds
 10111 000004CB 8ED2                    	mov	ss,dx
 10112 000004CD 89DC                    	mov	sp,bx
 10113 000004CF 31C0                    	xor	ax,ax
 10114 000004D1 50                      	push	ax
 10115                                  
 10116                                  	; set up initial registers and go to the guy
 10117                                  
 10118 000004D2 F7D0                    	not	ax
 10119 000004D4 2EFF36[C58C]            	push	word [cs:ROM_CS]
 10120 000004D9 2EFF36[C38C]            	push	word [cs:ROM_IP]
 10121 000004DE 8EC2                    	mov	es,dx
 10122 000004E0 CB                      	retf	; far return
 10123                                  
 10124                                  ;============================================================================
 10125                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10126                                  ;============================================================================
 10127                                  ; 12/10/2018 - Retro DOS v3.0
 10128                                  
 10129                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10130                                  
 10131                                  ; =============== S U B	R O U T	I N E =======================================
 10132                                  
 10133                                  ;Break	<PromptBat - Open or wait for batch file>
 10134                                  
 10135                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10136                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10137                                  
 10138                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10139                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10140                                  ; file. Leave segment registers alone.
 10141                                  
 10142                                  PROMPTBAT:
 10143 000004E1 E84D08                  	call	BATOPEN
 10144 000004E4 7201                    	jc	short PROMPTBAT1
 10145 000004E6 C3                      	retn
 10146                                  PROMPTBAT1:
 10147                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10148                                  	; MSDOS 6.0 COMMAND.COM
 10149 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10150 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10151 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10152 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10153                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10154 000004F1 E83500                  	call	output_batch_name
 10155 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10156                                  
 10157                                  	; 05/02/2023
 10158                                  	; MSDOS 3.3 COMMAND.COM
 10159                                  	;cmp	dx,ACCDENPTR
 10160                                  	;jz	short BATDIE
 10161                                  
 10162                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10163                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10164 000004F6 2EFF1E[CA8A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10165 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10166                                  
 10167                                  ; The media is not changeable. Turn everything off.
 10168                                  
 10169 000004FD E8450B                  	call	FOROFF
 10170 00000500 E8822A                  	call	PipeOff
 10171 00000503 A2[AB01]                	mov	[IfFlag],al	; No If in progress.	
 10172 00000506 BA[727F]                	mov	dx,BADBAT_PTR
 10173                                  BATDIE:
 10174 00000509 E8F203                  	call	BATCHOFF
 10175 0000050C 0E                      	push	cs
 10176 0000050D 1F                      	pop	ds
 10177                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10178                                  	; 05/02/2023
 10179 0000050E E80A49                  	call	std_eprintf	; MSDOS 6.0
 10180                                  	;call	STD_PRINTF	; MSDOS 3.3
 10181                                  
 10182                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10183                                  
 10184 00000511 E9F0FB                  	jmp	TCOMMAND
 10185                                  
 10186                                  ; Ask the user to reinsert the batch file
 10187                                  
 10188                                  ASKFORBAT:
 10189 00000514 1E                      	push	ds
 10190 00000515 0E                      	push	cs
 10191 00000516 1F                      	pop	ds
 10192                                  
 10193                                  	; MSDOS 6.0
 10194                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10195 00000517 BA[757F]                	mov	dx,NEEDBAT_PTR
 10196                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10197                                  	; 05/02/2023
 10198 0000051A E8FE48                  	call	std_eprintf
 10199                                  	;mov	dx,offset trangroup:pausemes_ptr
 10200 0000051D BA[E77F]                	mov	dx,PAUSEMES_PTR
 10201                                  	;invoke std_eprintf		;AN000; get second part of message
 10202 00000520 E8F848                  	call	std_eprintf
 10203                                  					;AN000; print it to stderr
 10204                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10205                                  	;call	STD_EPRINTF
 10206 00000523 E82E00                  	call	GETKEYSTROKE
 10207 00000526 1F                      	pop	ds
 10208 00000527 EBB8                    	jmp	short PROMPTBAT
 10209                                  
 10210                                  
 10211                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10212                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10213                                  
 10214                                  	; MSDOS 6.0
 10215                                  ;****************************************************************
 10216                                  ;*
 10217                                  ;* ROUTINE:	Output_batch_name
 10218                                  ;*
 10219                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10220                                  ;*
 10221                                  ;* INPUT:	DX - extended error number
 10222                                  ;*
 10223                                  ;* OUTPUT:	Ready to call print routine
 10224                                  ;*
 10225                                  ;****************************************************************
 10226                                  ;
 10227                                  ;public	output_batch_name		;AN022;
 10228                                  
 10229                                  output_batch_name:	;proc near	;AN022;
 10230                                  
 10231 00000529 1E                      	push	ds			;AN022; save resident segment
 10232 0000052A 8E1E[4C01]              	mov	ds,[Batch]		;AN022; get batch file segment
 10233                                  	;assume	DS:nothing		;AN022;
 10234                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10235                                  	; 05/02/2023
 10236                                  	;mov	si,20h
 10237                                  	; 24/04/2023
 10238 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10239                                  	;invoke	dstrlen 		;AN022; get length of string
 10240 00000531 E84927                  	call	dstrlen
 10241                                  	;mov	di,offset Trangroup:bwdbuf
 10242                                  					;AN022; target for batch name
 10243 00000534 BF[C98B]                	mov	di,BWDBUF
 10244 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10245                                  
 10246 00000539 0E                      	push	cs			;AN022; get local segment
 10247 0000053A 1F                      	pop	ds			;AN022;
 10248                                  	;assume	DS:trangroup		;AN022;
 10249                                  	; 05/02/2023
 10250 0000053B 8916[557F]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10251                                  	;mov	byte [msg_disp_class],1
 10252 0000053F C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 10253                                  					;AN022; set up extended error msg class
 10254                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10255 00000544 BA[557F]                	mov	dx,extend_buf_ptr	
 10256                                  					;AN022; get extended message pointer
 10257                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10258 00000547 C706[B08C][C98B]        	mov	word [string_ptr_2],BWDBUF	
 10259                                  					;AN022; point to substitution
 10260                                  	;mov	byte [extend_buf_sub],1
 10261 0000054D C606[577F]01            	mov	byte [extend_buf_sub],one_subst
 10262                                  					;AN022; set up for one subst
 10263 00000552 1F                      	pop	ds			;AN022; restore data segment
 10264 00000553 C3                      	retn				;AN022; return
 10265                                  
 10266                                  ;output_batch_name    endp		;AN022;
 10267                                  
 10268                                  
 10269                                  ; =============== S U B	R O U T	I N E =======================================
 10270                                  
 10271                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10272                                  
 10273                                  ; Read the next keystroke. Since there may be several characters in the queue
 10274                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10275                                  ; AFTER waiting.
 10276                                  
 10277                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10278                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10279                                  
 10280                                  GETKEYSTROKE:
 10281                                  	; 05/02/2023
 10282                                  	; MSDOS 3.3
 10283                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10284                                  	;;mov	ax,0C08h
 10285                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10286                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10287                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10288                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10289                                  	;;mov	ax,0C00h
 10290                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10291                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10292                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10293                                  	;retn
 10294                                  
 10295                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10296                                  	; MSDOS 6.0
 10297 00000554 52                      	push	dx			;AN000;  3/3/KK
 10298                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10299                                  					;AN000;  3/3/KK
 10300 00000555 B80263                  	mov	ax,6302h
 10301 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10302                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10303                                  	
 10304 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10305                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10306                                  					;AN000;  3/3/KK
 10307 0000055B B80163                  	mov	ax,6301h
 10308 0000055E B201                    	mov	dl,1
 10309                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10310 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10311                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10312                                  		; DL = new mode
 10313                                  		; 00h return only full characters on DOS keyboard input functions
 10314                                  		; 01h return partially-formed characters also
 10315                                  	
 10316                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10317 00000562 B8080C                  	mov	ax,0C08h
 10318 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10319                                  		; DOS - CLEAR KEYBOARD BUFFER
 10320                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10321                                  
 10322                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10323 00000567 B8000C                  	mov	ax,0C00h
 10324 0000056A CD21                    	int	21h
 10325                                  		; DOS - CLEAR KEYBOARD BUFFER
 10326                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10327                                  
 10328                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10329                                  					;AN000;  3/3/KK
 10330 0000056C B80163                  	mov	ax,6301h
 10331 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10332 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10333 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10334                                  	
 10335 00000573 C3                      	retn
 10336                                  
 10337                                  ; =============== S U B	R O U T	I N E =======================================
 10338                                  
 10339                                  ; Break	<ReadBat - read 1 line from batch file>
 10340                                  
 10341                                  ; ReadBat - read a single line from the batch file. 
 10342                                  ; Perform all substitutions as appropriate.
 10343                                  
 10344                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10345                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10346                                  
 10347                                  READBAT:
 10348                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10349                                  		
 10350                                  	;mov	byte [Suppress],1
 10351                                  				; initialize line suppress status
 10352 00000574 C606[A101]01            	mov	byte [Suppress],YES_ECHO 
 10353 00000579 F606[9601]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10354 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10355 00000580 C606[9501]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10356                                  
 10357                                  	; MSDOS 6.0
 10358                                  
 10359                                  ;M037; Start of changes
 10360                                  ; We check here if we have set the flag indicating that the batchfile is at
 10361                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10362                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10363                                  ;batch file gets closed etc. and then return as if everything is done.
 10364                                  
 10365                                  	; 05/02/2023
 10366 00000585 1E                      	push	ds
 10367 00000586 8E1E[4C01]              	mov	ds,[Batch]
 10368                                  	;cmp	byte [2],0
 10369 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10370                                  				; are we at EOF in batchfile
 10371 0000058F 1F                      	pop	ds
 10372 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10373                                  	;invoke	GetBatByt	; frees up batchseg
 10374 00000592 E8D803                  	call	GETBATBYT
 10375 00000595 26A2[2189]              	mov	[es:COMBUF+2],al
 10376                                  				; stuff CR into command buffer
 10377                                  				; as a dummy command
 10378                                  	;;invoke CrLf2		; print a CR-LF
 10379                                  	;call	CRLF2
 10380                                  	;;return		; done batch processing
 10381                                  	;retn
 10382                                  	; 24/04/2023
 10383 00000599 E93D20                  	jmp	CRLF2
 10384                                  
 10385                                  ;M037; End of changes
 10386                                  		
 10387                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10388                                  CONTBAT:
 10389 0000059C E842FF                  	call	PROMPTBAT
 10390                                  
 10391                                  TRYING_TO_ABORT:
 10392 0000059F BF[2189]                	mov	di,COMBUF+2
 10393                                  
 10394                                  ; Save position and try to scan for first non delimiter.
 10395                                  
 10396                                  TESTNOP:
 10397 000005A2 8CD8                    	mov	ax,ds
 10398 000005A4 8E1E[4C01]              	mov	ds,[Batch]
 10399 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10400 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10401                                  				; save current location.
 10402 000005B0 8ED8                    	mov	ds,ax
 10403 000005B2 E85006                  	call	SKIPDELIM	; skip to first non-delim
 10404                                  
 10405                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10406                                  ; beginning and read the line.
 10407                                  
 10408 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10409 000005B7 59                      	pop	cx
 10410 000005B8 5A                      	pop	dx		; restore position in bat file
 10411 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10412 000005BB F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10413 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10414                                  
 10415                                  	;cmp	al,'@'
 10416 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10417 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10418                                  	;mov	byte [Suppress],0
 10419 000005C7 C606[A101]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10420 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10421                                  	;nop
 10422                                  SET_BAT_POS:
 10423 000005CE 1E                      	push	ds
 10424 000005CF 8E1E[4C01]              	mov	ds,[Batch]
 10425                                  	;mov	[8],dx
 10426 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10427                                  	;mov	[10],cx
 10428 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10429 000005DB 1F                      	pop	ds
 10430                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10431                                  	; 05/02/2023
 10432 000005DC B80042                  	mov	ax,4200h
 10433                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10434 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10435                                  			; AL = method: offset from beginning of	file
 10436                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10437                                  	; 24/04/2023
 10438                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10439 000005E1 26C706[C795]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10440                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10441 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10442 000005EA EB0F                    	jmp	short RDBAT
 10443                                  
 10444                                  	;nop
 10445                                  
 10446                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10447                                  ; We eat characters until a CR is seen.
 10448                                  
 10449                                  NOPLINE:
 10450 000005EC E80501                  	call	SKIPTOEOL
 10451 000005EF E87B03                  	call	GETBATBYT	; eat trailing LF
 10452                                  	;test	word [Batch],0FFFFh
 10453 000005F2 F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10454 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10455                                  READBAT_RETN:				; Hit EOF			
 10456 000005FA C3                      	retn
 10457                                  
 10458                                  ; ---------------------------------------------------------------------------
 10459                                  
 10460                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10461                                  ; input, we are to consider two special cases:
 10462                                  ;
 10463                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10464                                  ;   %sym%	This is a symbol from the environment
 10465                                  
 10466                                  RDBAT:
 10467 000005FB E86F03                  	call	GETBATBYT
 10468 000005FE 41                      	inc	cx		; Inc the line length
 10469                                  
 10470                                  	; 05/02/2023
 10471                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10472 000005FF E8C21D                  	call	testkanj
 10473 00000602 740C                    	jz	short RDBAT1
 10474                                  	;cmp	cx,127
 10475 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10476 00000607 7350                    	jnb	short TOOLONG
 10477 00000609 AA                      	stosb
 10478 0000060A E86003                  	call    GETBATBYT
 10479 0000060D 41                      	inc	cx
 10480 0000060E EB0A                    	jmp	short SAVBATBYT
 10481                                  RDBAT1:
 10482 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10483 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10484                                  
 10485                                  ; See if we have a parameter character.
 10486                                  
 10487 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10488 00000618 7449                    	je	short NEEDPARM
 10489                                  
 10490                                  ; no parameter character. Store it as usual and see if we are done.
 10491                                  
 10492                                  SAVBATBYT:
 10493 0000061A AA                      	stosb			; End of line found?
 10494 0000061B 3C0D                    	cmp	al,0Dh
 10495 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10496                                  
 10497                                  ; We have read in an entire line. 
 10498                                  ; Decide whether we should echo the command line or not.
 10499                                  
 10500                                  FOUND_EOL:
 10501 0000061F 81EF[2289]              	sub	di,COMBUF+3
 10502 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10503 00000625 26A2[2089]              	mov	[es:COMBUF+1],al
 10504                                  				; Set length of line
 10505 00000629 E84103                  	call	GETBATBYT	; Eat linefeed
 10506 0000062C E8EE06                  	call	BATCLOSE
 10507 0000062F 803E[A101]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10508 00000634 7407                    	jz	short RESET
 10509 00000636 F606[A001]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10510 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10511                                  RESET:
 10512 0000063D 0E                      	push	cs
 10513 0000063E 1F                      	pop	ds		; Go back to local segment
 10514 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10515                                  TRY_NEXTFLAG:
 10516 00000641 803E[B501]01            	cmp	byte [NullFlag],nullcommand ; 1
 10517                                  				;G was there a command last time?
 10518 00000646 7403                    	jz	short NO_CRLF_PRINT
 10519                                  				;G no - don't print crlf
 10520 00000648 E88E1F                  	call	CRLF2		;G Print out prompt
 10521                                  NO_CRLF_PRINT:
 10522 0000064B E84417                  	call	PRINT_PROMPT
 10523 0000064E 0E                      	push	cs		;G change data segment
 10524 0000064F 1F                      	pop	ds
 10525 00000650 BA[2189]                	mov	dx,COMBUF+2	; get command line for echoing
 10526 00000653 E8DC1F                  	call	CRPRINT
 10527                                  	;call	CRLF2
 10528                                  	;retn
 10529                                  	; 06/02/2023
 10530 00000656 E9801F                  	jmp	CRLF2
 10531                                  
 10532                                  ; The line was too long. Eat remainder of input text up until the CR
 10533                                  
 10534                                  TOOLONG:
 10535 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10536 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10537 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10538                                  LTLCONT:
 10539 00000660 AA                      	stosb			; Terminate the command
 10540 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10541                                  
 10542                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10543                                  
 10544                                  NEEDPARM:
 10545 00000663 E80703                  	call	GETBATBYT	; get next character
 10546 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10547 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10548 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10549 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10550                                  
 10551                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10552                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10553                                  ; see if the <something> has a terminating % and then look up the contents
 10554                                  ; in the environment.
 10555                                  
 10556                                  PAROK:
 10557 0000066E 2C30                    	sub	al,'0'
 10558 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10559 00000672 3C09                    	cmp	al,9
 10560 00000674 7735                    	ja	short NEEDENV
 10561                                  
 10562                                  ; We have found %<number>. This is taken from the parameters in the
 10563                                  ; allocated batch area.
 10564                                  
 10565 00000676 98                      	cbw
 10566 00000677 89C3                    	mov	bx,ax		; move index into AX
 10567 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10568 0000067B 06                      	push	es
 10569 0000067C 8E06[4C01]              	mov	es,[Batch]
 10570                                  
 10571                                  ; The structure of the batch area is:
 10572                                  ;
 10573                                  ;   BYTE    type of segment
 10574                                  ;   DWORD   offset for next line
 10575                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10576                                  ;   ASCIZ   file name (with . and ..)
 10577                                  ;   BYTES   CR-terminated parameters
 10578                                  ;   BYTE    0 flag to indicate end of parameters
 10579                                  ;
 10580                                  ; Get pointer to BX'th argument
 10581                                  
 10582                                  	;;mov	si,[es:bx+0Bh]
 10583                                  	; 05/02/2023
 10584                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10585 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10586 00000684 07                      	pop	es
 10587                                  
 10588                                  ; Is there a parameter here?
 10589                                  
 10590 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10591 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10592 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10593                                  
 10594                                  ; Copy in the found parameter from batch segment
 10595                                  
 10596                                  YES_THERE_IS:
 10597 0000068D 1E                      	push	ds
 10598 0000068E 8E1E[4C01]              	mov	ds,[Batch]
 10599 00000692 49                      	dec	cx		; Don't count '%' in line length
 10600                                  COPYPARM:
 10601 00000693 AC                      	lodsb			; From resident segment
 10602 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10603 00000696 740F                    	je	short ENDPARAM
 10604 00000698 41                      	inc	cx		; Inc the line length
 10605 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10606 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10607 0000069F AA                      	stosb
 10608 000006A0 EBF1                    	jmp	short COPYPARM
 10609                                  
 10610                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10611                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10612                                  ; believing that we are at EOL. Clobber AL too.
 10613                                  
 10614                                  LINETOOL:
 10615 000006A2 30C0                    	xor	al,al
 10616 000006A4 1F                      	pop	ds
 10617 000006A5 EBB2                    	jmp	short TOOLONG
 10618                                  
 10619                                  ; We have copied in an entire parameter. Go back for more
 10620                                  
 10621                                  ENDPARAM:
 10622 000006A7 1F                      	pop	ds
 10623 000006A8 E950FF                  	jmp	RDBAT
 10624                                  
 10625                                  ; We have found % followed by something other than 0-9. We presume that there
 10626                                  ; will be a following % character. In between is an environment variable that
 10627                                  ; we will fetch and replace in the batch line with its value.
 10628                                  
 10629                                  NEEDENV:
 10630                                  	; MSDOS 6.0 COMMAND.COM
 10631                                  	; 05/02/2023 
 10632 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10633                                  
 10634                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10635 000006AC 1E                      	push	ds
 10636 000006AD 57                      	push	di
 10637                                  				; temp spot for name
 10638 000006AE BF[4B8B]                	mov	di,ID
 10639 000006B1 0430                    	add	al,'0'		; reconvert character
 10640 000006B3 AA                      	stosb			; store it in appropriate place
 10641                                  
 10642                                  ; loop getting characters until the next % is found or until EOL
 10643                                  
 10644                                  GETENV1:
 10645 000006B4 E8B602                  	call	GETBATBYT	; get the byte
 10646 000006B7 AA                      	stosb			; store it
 10647 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10648 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10649                                  
 10650                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10651                                  
 10652 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10653 000006C1 BE[4B8B]                	mov	si,ID 		; point to buffer
 10654 000006C4 5F                      	pop	di		; point to line buffer
 10655 000006C5 0E                      	push	cs
 10656 000006C6 1F                      	pop	ds
 10657 000006C7 E89002                  	call	STRCPY
 10658                                  	; 05/02/2023
 10659 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10660                                  	; 24/04/2023
 10661                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10662 000006CC 1F                      	pop	ds
 10663 000006CD E94AFF                  	jmp	SAVBATBYT
 10664                                  GETENV15:
 10665 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10666 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10667                                  
 10668                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10669                                  ; This was the source of bug #1.
 10670                                  ;	dec	cx		;AN070; Don't count "%"
 10671                                  
 10672 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10673 000006D6 268845FF                	mov	[es:di-1],al
 10674                                  
 10675                                  ; ID now either has a =-terminated string which we are to find in the
 10676                                  ; environment or a non =-terminated string which will not be found in the
 10677                                  ; environment.
 10678                                  
 10679                                  GETENV2:
 10680 000006DA BE[4B8B]                	mov	si,ID
 10681 000006DD 0E                      	push	cs
 10682 000006DE 1F                      	pop	ds		; DS:SI points to name
 10683 000006DF 51                      	push	cx
 10684 000006E0 E8371C                  	call	find_name_in_environment
 10685 000006E3 59                      	pop	cx
 10686 000006E4 06                      	push	es
 10687 000006E5 1F                      	pop	ds
 10688 000006E6 0E                      	push	cs
 10689 000006E7 07                      	pop	es
 10690 000006E8 89FE                    	mov	si,di
 10691 000006EA 5F                      	pop	di		; get back pointer to command line
 10692                                  
 10693                                  ; If the parameter was not found, there is no need to perform any replacement.
 10694                                  ; We merely pretend that we've copied the parameter.
 10695                                  
 10696 000006EB 7203                    	jc	short GETENV6
 10697                                  
 10698                                  ; ES:DI points to command line being built
 10699                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10700                                  
 10701 000006ED E86A02                  	call	STRCPY		; (let RdBat handle overflow)
 10702                                  	; 24/04/2022
 10703                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10704                                  GETENV6:
 10705 000006F0 1F                      	pop	ds
 10706 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10707                                  
 10708                                  ; =============== S U B	R O U T	I N E =======================================
 10709                                  
 10710                                  ;   SkipToEOL - read from batch file until end of line
 10711                                  
 10712                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10713                                  SKIPTOEOL:
 10714 000006F4 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10715                                  	;jnz	short SKIPTOEOL1  	
 10716                                  	;retn			; no batch file in effect
 10717                                  	
 10718 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10719                                  SKIPTOEOL1:
 10720 000006FC E86E02                  	call	GETBATBYT
 10721 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10722 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10723                                  SKIPTOEOL2:
 10724 00000703 C3                      	retn
 10725                                  
 10726                                  ; =============== S U B	R O U T	I N E =======================================
 10727                                  
 10728                                  ;Break	<Allocate and deallocate the transient portion>
 10729                                  
 10730                                  ; Free Transient. Modify ES,AX,flags
 10731                                  
 10732                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10733                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10734                                  FREE_TPA:
 10735 00000704 06                      	push	es
 10736 00000705 8E06[C08A]              	mov	es,[RESSEG]
 10737 00000709 268E06[5F03]            	mov	es,[es:Res_Tpa]
 10738 0000070E B449                    	mov	ah,49h
 10739                                  	;mov	ah,DEALLOC ; 49h
 10740 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10741                                  			; ES = segment address of area to be freed
 10742 00000712 07                      	pop	es
 10743 00000713 C3                      	retn
 10744                                  
 10745                                  ; =============== S U B	R O U T	I N E =======================================
 10746                                  
 10747                                  ; Allocate transient. Modify AX,BX,DX,flags
 10748                                  
 10749                                  	; 06/02/2023
 10750                                  ALLOC_TPA:
 10751 00000714 06                      	push	es
 10752 00000715 8E06[C08A]              	mov	es,[RESSEG]
 10753 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10754 0000071C B448                    	mov	ah,48h
 10755                                  	;mov	ah,ALLOC ; 48h
 10756 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10757                                  			; BX = number of 16-byte paragraphs desired
 10758 00000720 53                      	push	bx	  	; Save size of block
 10759 00000721 B448                    	mov	ah,48h
 10760                                  	;mov	ah,ALLOC ; 48h
 10761 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10762                                  			; BX = number of 16-byte paragraphs desired
 10763                                  
 10764                                  ; Attempt to align TPA on 64K boundary
 10765                                  
 10766 00000725 5B                      	pop	bx		; Restore size of block
 10767 00000726 26A3[5F03]              	mov	[es:Res_Tpa],ax
 10768                                  				; Save segment to beginning of block
 10769 0000072A A3[D08A]                	mov	[TRAN_TPA],ax
 10770                                  
 10771                                  ; Is the segment already aligned on a 64K boundary
 10772                                  
 10773 0000072D 89C2                    	mov	dx,ax		; Save segment
 10774 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10775 00000732 7507                    	jnz	short CALC_TPA
 10776 00000734 89D0                    	mov	ax,dx
 10777 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10778 00000739 7523                    	jnz	short NOROUND
 10779                                  CALC_TPA:
 10780 0000073B 89D0                    	mov	ax,dx
 10781 0000073D 2500F0                  	and	ax,0F000h
 10782 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10783 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10784                                  
 10785                                  ; Make sure that new boundary is within allocated range
 10786                                  
 10787 00000745 268B16[5F03]            	mov	dx,[es:Res_Tpa]
 10788 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10789 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10790 0000074E 720E                    	jb	short NOROUND
 10791                                  
 10792                                  ; Make sure that we won't overwrite the transient
 10793                                  
 10794 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10795 00000752 39C3                    	cmp	bx,ax
 10796 00000754 7208                    	jb	short NOROUND
 10797                                  
 10798                                  ; The area from the 64K boundary to the beginning of the transient must
 10799                                  ; be at least 64K.
 10800                                  
 10801 00000756 29C3                    	sub	bx,ax
 10802                                  	;cmp	bx,4096
 10803 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10804 0000075C 7304                    	jnb	short ROUNDDONE
 10805                                  NOROUND:
 10806 0000075E 26A1[5F03]              	mov	ax,[es:Res_Tpa]
 10807                                  ROUNDDONE:
 10808 00000762 26A3[5103]              	mov	[es:LTpa],ax	; Re-compute everything
 10809 00000766 A3[C28A]                	mov	[TPA],ax
 10810 00000769 89C3                    	mov	bx,ax
 10811 0000076B 8CC8                    	mov	ax,cs
 10812 0000076D 29D8                    	sub	ax,bx
 10813 0000076F 53                      	push	bx
 10814 00000770 BB1000                  	mov	bx,16
 10815 00000773 F7E3                    	mul	bx
 10816 00000775 5B                      	pop	bx
 10817 00000776 09D2                    	or	dx,dx
 10818 00000778 7403                    	jz	short SAVSIZ2
 10819 0000077A B8FFFF                  	mov	ax,-1
 10820                                  SAVSIZ2:
 10821                                  
 10822                                  ; AX is the number of bytes free in the buffer between the resident and the
 10823                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10824                                  
 10825 0000077D 3D0002                  	cmp	ax,512
 10826 00000780 7603                    	jbe	short GOTSIZE2
 10827                                  	;and	ax,~1FFh
 10828 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10829                                  GOTSIZE2:
 10830 00000785 A3[E18A]                	mov	[BYTCNT],ax
 10831 00000788 07                      	pop	es
 10832 00000789 C3                      	retn
 10833                                  
 10834                                  ; =============== S U B	R O U T	I N E =======================================
 10835                                  
 10836                                  ;Break	<BatCom - enter a batch file>
 10837                                  
 10838                                  ; The exec search has determined that the user has requested a batch file for
 10839                                  ; execution. We parse the arguments, create the batch segment, and signal
 10840                                  ; batch processing.
 10841                                  
 10842                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10843                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10844                                  BATCOM:	
 10845                                  
 10846                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10847                                  
 10848                                  ; Batch parameters are read with ES set to segment of resident part
 10849                                  
 10850                                  	; MSDOS 6.0
 10851 0000078A 8E06[C08A]              	mov	es,[RESSEG]
 10852                                  	;ASSUME	ES:RESGROUP
 10853                                  	;cmp	byte [es:Call_Batch_Flag],1
 10854 0000078E 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10855                                  					;AN043; If in CALL,
 10856 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10857                                  	;invoke	IOSET			; Set up any redirection
 10858 00000796 E8F323                  	call	IOSET
 10859                                  skip_ioset:				;AN043;
 10860 00000799 E868FF                  	call	FREE_TPA		; G
 10861                                  	;cmp	byte [es:Call_Batch_Flag],1
 10862 0000079C 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10863 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10864                                  
 10865                                  	; 12/02/2023
 10866                                  	; MSDOS 3.3
 10867                                  	;call	IOSET
 10868                                  	;mov	es,[RESSEG]
 10869                                  	;call	FREE_TPA
 10870                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 10871                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 10872                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 10873                                  
 10874                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10875                                  
 10876                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 10877                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 10878                                  ; Don't execute if in call
 10879                                  
 10880 000007A4 E89E08                  	call	FOROFF
 10881                                  GETECHO:
 10882 000007A7 E8DB27                  	call	PipeOff
 10883 000007AA 26A0[A001]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 10884 000007AE 2401                    	and	al,1			; Save current echo state
 10885                                  
 10886 000007B0 50                      	push	ax
 10887 000007B1 31C0                    	xor	ax,ax
 10888 000007B3 26F706[4C01]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 10889 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 10890 000007BC 26A1[4C01]              	mov	ax,[es:Batch] 		; Get current batch segment
 10891                                  	;cmp	byte [es:Call_Batch_Flag],1
 10892 000007C0 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10893 000007C6 7408                    	jz	short LEAVEBAT
 10894                                  
 10895                                  ;  We are in a chained batch file, save batlast from previous batch segment
 10896                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 10897                                  
 10898 000007C8 06                      	push	es
 10899 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 10900                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 10901                                  				; Get previous batch segment
 10902                                  	; 12/02/2023
 10903                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 10904 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 10905 000007CF 07                      	pop	es
 10906                                  LEAVEBAT:
 10907 000007D0 50                      	push	ax		; Keep segment until new one created
 10908                                  	;cmp	byte [es:Call_Batch_Flag],1
 10909 000007D1 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10910 000007D7 7403                    	jz	short STARTBAT
 10911 000007D9 E82201                  	call	BATCHOFF
 10912                                  
 10913                                  ; Find length of batch file
 10914                                  
 10915                                  STARTBAT:
 10916 000007DC 26C606[B201]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 10917 000007E2 BE[E889]                	mov	si,EXECPATH
 10918                                  
 10919                                  	; 12/02/2023
 10920                                  	; MSDOS 6.0
 10921 000007E5 B811B7                  	mov	ax,0B711h
 10922                                  	;mov	ax,AppendTruename
 10923                                  				;AN042; Get the real path where the batch file
 10924 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 10925 000007EA B44E                    	mov	ah,4Eh
 10926                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 10927 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 10928 000007EE B91300                  	mov	cx,13h
 10929                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 10930 000007F1 CD21                    	int	21h		;AN042;
 10931                                  
 10932                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10933 000007F3 E88724                  	call	dstrlen
 10934                                  ;
 10935                                  ; Allocate batch area:
 10936                                  ;   BYTE    type of segment
 10937                                  ;   WORD    segment of last batch file
 10938                                  ;   WORD    segment for FOR command
 10939                                  ;   BYTE    FOR flag state on entry to batch file
 10940                                  ;   DWORD   offset for next line
 10941                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 10942                                  ;   ASCIZ   file name (with . and ..)
 10943                                  ;   BYTES   CR-terminated parameters
 10944                                  ;   BYTE    0 flag to indicate end of parameters
 10945                                  ;
 10946                                  ; We allocate the maximum size for the command line and use setblock to shrink
 10947                                  ; later when we've squeezed out the extra
 10948                                  ;
 10949 000007F6 89CB                    	mov	bx,cx		; length of file name.
 10950                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 10951                                  	; 12/02/2023
 10952                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 10953                                  	; 25/04/2023
 10954 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 10955                                  					; structure + max len + round up
 10956 000007FC 51                      	push	cx
 10957 000007FD B104                    	mov	cl,4
 10958 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 10959 00000801 53                      	push	bx		; Save size of batch segment
 10960 00000802 B448                    	mov	ah,48h
 10961                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 10962 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10963                                  				; BX = number of 16-byte paragraphs desired
 10964 00000806 5B                      	pop	bx		; Get size of batch segment
 10965                                  
 10966                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 10967                                  ; the batch segment. This may not be true, however, in a multitasking system.
 10968                                  ; G This error will occur with nesting of batch files. We also need to
 10969                                  ; G make sure that we don't overlay the transient.
 10970                                  
 10971 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 10972                                  
 10973 00000809 50                      	push	ax		;G save batch segment
 10974 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 10975 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 10976 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 10977                                  
 10978                                  	; MSDOS 6.0
 10979                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 10980                                  ; M006; batchseg is always above the transient. We need to change this code
 10981                                  ; M006; to only check for an overlap
 10982                                  
 10983                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 10984                                  	; 12/02/2023
 10985                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 10986                                  	;mov	dx,TRANSPACEEND		
 10987                                  	;add	dx,15		;round up para; M006
 10988 00000811 BA1E96                  	mov	dx,TRANSPACEEND+15
 10989                                  
 10990 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 10991 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 10992                                  
 10993 00000818 39D8                    	cmp	ax,bx		; M006
 10994 0000081A 7211                    	jb	short ENOUGH_MEM
 10995                                  				; Batchseg below transient
 10996                                  				; enough memory ; M006
 10997 0000081C 39D0                    	cmp	ax,dx		; M006
 10998 0000081E 770D                    	ja	short ENOUGH_MEM	
 10999                                  				; Batchseg above transient
 11000                                  				; enough memory ; M006
 11001                                  
 11002                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11003                                  
 11004 00000820 58                      	pop	ax		; restore ax; M006
 11005                                  
 11006                                  	; 12/02/2023
 11007                                  	; MSDOS 3.3
 11008                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11009                                  ; M006;	pop	ax		;G get batch segment back
 11010                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11011                                  
 11012                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11013 00000821 06                      	push	es		;G no we're hitting the transient
 11014 00000822 8EC0                    	mov	es,ax
 11015 00000824 B80049                  	mov	ax,4900h
 11016                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11017 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11018                                  			; ES = segment address of area to be freed
 11019 00000829 07                      	pop	es
 11020                                  MEM_ERROR:
 11021 0000082A E9BA00                  	jmp	NO_MEMORY	;G Set up for message and exit
 11022                                  
 11023                                  ENOUGH_MEM:
 11024                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11025                                  	; MSDOS 6.0
 11026 0000082D 58                      	pop	ax		; restore ax; M006
 11027                                  
 11028                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11029 0000082E 26A3[4C01]              	mov	[es:Batch],ax
 11030 00000832 E8DFFE                  	call	ALLOC_TPA
 11031                                  
 11032                                  ; Initialize batch segment
 11033                                  
 11034 00000835 5A                      	pop	dx		; length of name
 11035 00000836 58                      	pop	ax		;G get saved batch segment back
 11036 00000837 26FF06[AF01]            	inc	word [es:Nest]	;G increment # batch files in progress
 11037 0000083C 06                      	push	es
 11038 0000083D 268E06[4C01]            	mov	es,[es:Batch]
 11039                                  	;mov	byte [ES:0],0
 11040                                  				; signal batch file type
 11041 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11042                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11043                                  				;G save segment of last batch file
 11044                                  	;mov	[es:3],ax	; MSDOS 6.0
 11045 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11046 0000084C 1E                      	push	ds
 11047 0000084D 8E1E[C08A]              	mov	ds,[RESSEG]	;G set to resident data
 11048                                  
 11049 00000851 31C0                    	xor	ax,ax
 11050 00000853 8A1E[AC01]              	mov	bl,[ForFlag]	;G get the current FOR state
 11051                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11052                                  				;G save it in the batch segment
 11053                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11054 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11055 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11056 0000085F 7408                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11057 00000861 A1[AD01]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11058 00000864 C606[AC01]00            	mov	byte [ForFlag],0 ;G reset forflag
 11059                                  FOR_NOT_ON:
 11060                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11061                                  				;G save FOR segment in batch segment
 11062                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11063 00000869 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11064 0000086D 31C0                    	xor	ax,ax
 11065 0000086F A3[AD01]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11066 00000872 8A1E[A001]              	mov	bl,[EchoFlag]
 11067 00000876 1F                      	pop	ds
 11068                                  	;mov	[es:1],bl 
 11069                                  				 ;G save echo state of parent
 11070 00000877 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11071                                  ;SR;
 11072                                  ; Initialize the new BatchEOF flag we have added to 0
 11073                                  
 11074                                  	; MSDOS 6.0
 11075                                  	;mov	byte [es:2],0
 11076 0000087C 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11077                                  
 11078                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11079 00000882 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11080                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11081 00000886 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11082                                  
 11083                                  ; Initialize pointers
 11084                                  
 11085 0000088A 48                      	dec	ax		; put -1 into AX
 11086                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11087                                  				; point to parm area
 11088                                  	;mov	di,0Ch	; MSDOS 6.0
 11089 0000088B BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11090 0000088E 89FB                    	mov	bx,di
 11091 00000890 B90A00                  	mov	cx,10
 11092 00000893 F3AB                    	rep stosw		; Init to no parms
 11093                                  
 11094                                  ; Move in batch file name
 11095                                  
 11096 00000895 89D1                    	mov	cx,dx
 11097 00000897 F3A4                    	rep	movsb
 11098                                  
 11099                                  ; Now copy the command line into batch segment, parsing the arguments along
 11100                                  ; the way. Segment will look like this:
 11101                                  ;
 11102                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11103                                  ;
 11104                                  ; or, in the case of fewer arguments:
 11105                                  ;
 11106                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11107                                  
 11108 00000899 BE[2189]                	mov	si,COMBUF+2
 11109                                  	;mov	cx,10		; at most 10 arguments
 11110                                  	; 07/06/2023
 11111 0000089C B10A                    	mov	cl,10
 11112                                  EACHPARM:
 11113 0000089E E8451D                  	call	scanoff		; skip to argument
 11114                                  
 11115                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11116                                  
 11117 000008A1 3C0D                    	cmp	al,0Dh		; end of road?
 11118 000008A3 741D                    	jz	short HAVPARM	; yes, no more arguments
 11119                                  
 11120                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11121                                  
 11122 000008A5 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11123                                  
 11124                                  ; Go into allocated piece and stick in new argument pointer.
 11125                                  
 11126 000008A7 26893F                  	mov	[es:bx],di	; store batch pointer
 11127 000008AA 83C302                  	add	bx,2		; advance arg counter
 11128                                  
 11129                                  ; Move the parameter into batch segment
 11130                                  
 11131                                  MOVPARM:
 11132 000008AD AC                      	lodsb			; get byte
 11133 000008AE E83D1D                  	call	DELIM		; if delimiter
 11134 000008B1 7407                    	jz	short ENDPARM	; then done with parm
 11135 000008B3 AA                      	stosb			; store byte
 11136 000008B4 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11137 000008B6 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11138 000008B8 EBF3                    	jmp	short MOVPARM
 11139                                  
 11140                                  ; We have copied a parameter up until the first separator.
 11141                                  ; Terminate it with CR.
 11142                                  
 11143                                  ENDPARM:
 11144 000008BA B00D                    	mov	al,0Dh
 11145 000008BC AA                      	stosb
 11146 000008BD E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11147 000008BF 49                      	dec	cx		; remember that we've seen one.	
 11148 000008C0 EBDC                    	jmp	short EACHPARM
 11149                                  
 11150                                  ; We have parsed the entire line. Terminate the arg list
 11151                                  
 11152                                  HAVPARM:
 11153 000008C2 30C0                    	xor	al,al		; Nul terminate the parms
 11154 000008C4 AA                      	stosb
 11155                                  
 11156                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11157                                  ; into paragraphs and setblock to the appropriate size
 11158                                  
 11159 000008C5 8D5D0F                  	lea	bx,[di+15]
 11160 000008C8 B104                    	mov	cl,4
 11161 000008CA D3EB                    	shr	bx,cl
 11162 000008CC B44A                    	mov	ah,4Ah
 11163                                  	;mov	ah,SETBLOCK ; 4Ah
 11164 000008CE CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11165                                  			; ES = segment address of block	to change
 11166                                  			; BX = new size	in paragraphs
 11167 000008D0 07                      	pop	es
 11168 000008D1 06                      	push	es
 11169 000008D2 1F                      	pop	ds		; Simply batch FCB setup
 11170 000008D3 833E[A601]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11171 000008D8 7506                    	jne	short NOBATSING
 11172 000008DA C706[A601]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11173                                  
 11174                                  NOBATSING:
 11175                                  
 11176                                  ; Enter the batch file with the current echo state
 11177                                  
 11178 000008E0 58                      	pop	ax		; Get original echo state
 11179 000008E1 A2[A001]                	mov	[EchoFlag],al	; restore it
 11180 000008E4 E91DF8                  	jmp	TCOMMAND
 11181                                  
 11182                                  ; The following is executed if there isn't enough memory for batch segment
 11183                                  
 11184                                  NO_MEMORY:
 11185 000008E7 5A                      	pop	dx		; even up our stack 
 11186 000008E8 58                      	pop	ax
 11187 000008E9 58                      	pop	ax
 11188 000008EA E827FE                  	call	ALLOC_TPA	; reallocate memory
 11189                                  
 11190                                  	; 12/02/2023
 11191                                  	; MSDOS 3.3
 11192                                  	;mov	dx,INSFMEMMESPTR
 11193                                  	;jmp	CERROR
 11194                                  
 11195                                  	; MSDOS 6.0
 11196                                  	;mov	byte [msg_disp_class],1
 11197 000008ED C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 11198                                  				;AN000; set up extended error msg class
 11199                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11200 000008F2 BA[557F]                	mov	dx,extend_buf_ptr
 11201                                  	;			;AC000; get extended message pointer
 11202                                  	;mov	word [extend_buf_ptr],8
 11203 000008F5 C706[557F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11204                                  				;AN000; get message number in control block
 11205 000008FB E95C20                  	jmp	cerror		;g print error message and go...
 11206                                  
 11207                                  ; =============== S U B	R O U T	I N E =======================================
 11208                                  
 11209                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11210                                  BATCHOFF:
 11211 000008FE 50                      	push	ax
 11212 000008FF 06                      	push	es
 11213 00000900 1E                      	push	ds
 11214 00000901 53                      	push	bx
 11215                                  
 11216 00000902 2E8E06[C08A]            	mov	es,[cs:RESSEG]
 11217 00000907 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 11218 0000090C A1[4C01]                	mov	ax,[Batch]	; Free the batch segment
 11219 0000090F 09C0                    	or	ax,ax
 11220 00000911 7442                    	jz	short NOTFREE
 11221                                  
 11222 00000913 06                      	push	es
 11223 00000914 8EC0                    	mov	es,ax
 11224 00000916 F606[A001]01            	test	byte [EchoFlag],1
 11225                                  				;G Is echo on?
 11226 0000091B 7505                    	jnz	short ECHO_LAST_LINE
 11227                                  				;G Yes - echo last line in file
 11228                                  	;mov	byte [SUPPRESS],0
 11229 0000091D C606[A101]00            	mov	byte [Suppress],NO_ECHO
 11230                                  				;G no - don't echo last line in file	
 11231                                  ECHO_LAST_LINE:
 11232                                  	;mov	bl,[es:1]
 11233 00000922 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11234                                  				; G get echo state
 11235 00000927 881E[A001]              	mov	[EchoFlag],bl
 11236                                  				; G  and restore it
 11237                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11238                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11239 0000092B 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11240                                  				;G Get FOR segment
 11241 00000930 891E[AD01]              	mov	[ForPtr],bx	;G  and restore it
 11242                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11243                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11244 00000934 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11245                                  				;G Get FOR flag
 11246 00000939 881E[AC01]              	mov	[ForFlag],bl
 11247                                  				;G  and restore it
 11248                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11249                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11250 0000093D 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11251                                  				;G  Get old batch segment
 11252                                  
 11253 00000942 B449                    	mov	ah,49h
 11254                                  	;mov	ah,DEALLOC ; 49h
 11255 00000944 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11256                                  			; ES = segment address of area to be freed
 11257 00000946 07                      	pop	es
 11258 00000947 891E[B301]              	mov	[Next_Batch],bx	;G reset batch segment	
 11259 0000094B 26FF0E[AF01]            	dec	word [es:Nest]
 11260 00000950 31C0                    	xor	ax,ax
 11261 00000952 A3[4C01]                	mov	[Batch],ax	; No batch in progress
 11262                                  NOTFREE:
 11263 00000955 5B                      	pop	bx
 11264 00000956 1F                      	pop	ds
 11265 00000957 07                      	pop	es
 11266 00000958 58                      	pop	ax
 11267 00000959 C3                      	retn
 11268                                  
 11269                                  ; =============== S U B	R O U T	I N E =======================================
 11270                                  
 11271                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11272                                  
 11273                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11274                                  ;	Entry : DS:SI ==> source string
 11275                                  ;		ES:DI ==> destination string
 11276                                  ;		CX = current length of destination string
 11277                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11278                                  
 11279                                  	; 12/02/2023	
 11280                                  	; MSDOS 3.3
 11281                                  ;STRCPY:
 11282                                  	;push	ax
 11283                                  ;CCYCLE:
 11284                                  	;lodsb
 11285                                  	;stosb
 11286                                  	;or	al,al
 11287                                  	;jnz	short CCYCLE
 11288                                  	;pop	ax
 11289                                  	;retn
 11290                                  
 11291                                  ;Procedure StrCpy,NEAR
 11292                                  
 11293                                  	; 12/02/2023
 11294                                  	; MSDOS 6.0
 11295                                  STRCPY:
 11296 0000095A 50                      	push	ax
 11297                                  ccycle:
 11298 0000095B AC                      	lodsb
 11299 0000095C 41                      	inc	cx
 11300                                  	;cmp	cx,128
 11301 0000095D 81F98000                	cmp	cx,COMBUFLEN
 11302                                  	;jb	short ccopy
 11303                                  	;stc			; set carry to signal error
 11304                                  	;jmp	short ccend
 11305                                  	; 12/02/2023
 11306 00000961 F5                      	cmc
 11307 00000962 7205                    	jc	short ccend
 11308                                  ccopy:
 11309 00000964 AA                      	stosb
 11310 00000965 08C0                    	or	al,al
 11311 00000967 75F2                    	jnz	short ccycle
 11312                                  ccend:
 11313 00000969 49                      	dec	cx		; discount extra byte
 11314 0000096A 4F                      	dec	di		; back up pointer
 11315 0000096B 58                      	pop	ax
 11316 0000096C C3                      	retn			; return carry clear
 11317                                  
 11318                                  ;EndProc StrCpy
 11319                                  
 11320                                  ;============================================================================
 11321                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11322                                  ;============================================================================
 11323                                  ; 12/10/2018 - Retro DOS v3.0
 11324                                  
 11325                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11326                                  
 11327                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11328                                  
 11329                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11330                                  
 11331                                  ; =============== S U B	R O U T	I N E =======================================
 11332                                  
 11333                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11334                                  
 11335                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11336                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11337                                  ; AH, DX destroyed.
 11338                                  
 11339                                  GETBATBYT:
 11340 0000096D 53                      	push	bx
 11341 0000096E 51                      	push	cx
 11342 0000096F 1E                      	push	ds
 11343 00000970 F606[9601]FF            	test	byte [Batch_Abort],-1
 11344                                  	;jnz	short BATEOF
 11345                                  	; 14/02/2023
 11346 00000975 7403                    	jz	short getbatbyt1
 11347 00000977 E9D100                  	jmp	BATEOF
 11348                                  getbatbyt1:
 11349 0000097A F706[4C01]FFFF          	test	word [Batch],-1
 11350                                  	;jz	short BATEOF
 11351                                  	; 14/02/2023
 11352 00000980 7503                    	jnz	short getbatbyt2
 11353 00000982 E9C600                  	jmp	BATEOF
 11354                                  getbatbyt2:
 11355 00000985 06                      	push	es
 11356 00000986 8E06[4C01]              	mov	es,[Batch]
 11357                                  
 11358                                  	; MSDOS 6.0
 11359                                  ;M020;
 11360                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11361                                  ;try to read from the batchfile again.
 11362                                  
 11363                                  	;cmp	byte [es:2],0
 11364 0000098A 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11365                                  				;already reached EOF?	;M020
 11366 00000990 7403                    	jz	short not_eof	;no, read batch file	;M020
 11367 00000992 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11368                                  not_eof:						;M020
 11369                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11370                                  	;add	word [es:8],1	; MSDOS 6.0
 11371 00000995 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11372                                  	;adc	word [es:10],0	; MSDOS 6.0
 11373 0000099B 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11374 000009A1 07                      	pop	es
 11375                                  
 11376                                  ; See if we have bytes buffered...
 11377                                  
 11378 000009A2 8CC8                    	mov	ax,cs
 11379 000009A4 8ED8                    	mov	ds,ax
 11380 000009A6 8B1E[C795]              	mov	bx,[BATBUFPOS]
 11381 000009AA 83FBFF                  	cmp	bx,-1
 11382 000009AD 7540                    	jnz	short UNBUF
 11383                                  
 11384                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11385                                  
 11386 000009AF BA[C995]                	mov	dx,BATBUF
 11387 000009B2 8B0E[9D84]              	mov	cx,[BATBUFLEN] ; max to read.
 11388 000009B6 8B1E[F48D]              	mov	bx,[BATHAND]
 11389                                  	; 14/02/2023
 11390 000009BA B43F                    	mov	ah,3Fh
 11391                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11392 000009BC CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11393                                  			; BX = file handle,CX = number	of bytes to read
 11394                                  			; DS:DX	-> buffer
 11395                                  	; MSDOS 6.0
 11396 000009BE 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11397                                  	;invoke	get_ext_error_number	;AN022; get the error
 11398 000009C0 E83F13                  	call	get_ext_error_number
 11399 000009C3 1E                      	push	ds			;AN022; save local segment
 11400 000009C4 8E1E[C08A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11401                                  	;assume ds:resgroup		;AN022;
 11402 000009C8 89C2                    	mov	dx,ax			;AN022; put error in DX
 11403                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11404 000009CA E85CFB                  	call	output_batch_name
 11405 000009CD 1F                      	pop	ds			;AN022;
 11406                                  	;assume	ds:trangroup		;AN022;
 11407                                  	;invoke	std_eprintf		;AN022; print out the error
 11408 000009CE E84A44                  	call	std_eprintf
 11409                                  	;mov	byte ptr combuf+2,end_of_line_in
 11410 000009D1 C606[2189]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11411                                  	;				;AN022; terminate the batch line for parsing
 11412                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11413 000009D6 C606[2289]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11414                                  	;				;AN022; terminate the batch line for output
 11415                                  ;M020;
 11416                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11417                                  ;error is never hit (and it shouldn't be)
 11418                                  
 11419 000009DB 8E1E[C08A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11420 000009DF EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11421                                  bat_read_ok:				;AN022;
 11422                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11423 000009E1 89C1                    	mov	cx,ax
 11424                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11425                                  	; 14/02/2023
 11426 000009E3 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11427 000009E5 890E[E995]              	mov	[BATBUFEND],cx
 11428 000009E9 31DB                    	xor	bx,bx
 11429 000009EB 891E[C795]              	mov	[BATBUFPOS],bx
 11430                                  
 11431                                  	; Buffered bytes!
 11432                                  UNBUF:
 11433 000009EF 8A87[C995]              	mov	al,[BATBUF+bx]		; get next byte
 11434 000009F3 43                      	inc	bx
 11435 000009F4 3B1E[E995]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11436 000009F8 7203                    	jb	short SETBUFPOS
 11437 000009FA BBFFFF                  	mov	bx,-1
 11438                                  SETBUFPOS:
 11439 000009FD 891E[C795]              	mov	[BATBUFPOS],bx
 11440 00000A01 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11441 00000A03 7575                    	jne	short GETBYTEDONE
 11442                                  
 11443                                  ;We get here only when we hit an EOF
 11444                                  	
 11445                                  	; MSDOS 6.0
 11446                                  BATEOFDS:
 11447                                  ;SR;
 11448                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11449                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11450                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11451                                  ;batch processing is turned off before the last line is processed and so 
 11452                                  ;this line would never be executed. 
 11453                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11454                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11455                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11456                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11457                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11458                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11459                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11460                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11461                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11462                                  ;another redundant CR-LF. There is no work-around I can think of.
 11463                                  ; 	I would love to restructure this entire routine and its caller to
 11464                                  ;make the flow really easy to understand but I guess this will have to wait.
 11465                                  ;
 11466 00000A05 06                      	push	es
 11467 00000A06 8E06[C08A]              	mov	es,[RESSEG]
 11468                                  ;SR;
 11469                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11470                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11471                                  ;
 11472 00000A0A 268E06[4C01]            	mov	es,[es:Batch]
 11473                                  	;cmp	byte [es:2],0
 11474 00000A0F 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11475 00000A15 7516                    	jnz	short crpresent
 11476                                  
 11477                                  	;inc	byte [es:2]
 11478 00000A17 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11479                                  					;match the dec following
 11480 00000A1C 8B1E[E995]              	mov	bx,[BATBUFEND]
 11481 00000A20 80BF[C895]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11482 00000A25 7406                    	je	short crpresent		;yes, no need to fake it
 11483                                  
 11484                                  	;add	byte [es:2],3
 11485 00000A27 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11486                                  					;BatchEOF == 4 to fake CR-LF
 11487                                  crpresent:
 11488                                  ;;	;pop	es
 11489                                  
 11490                                  	;ASSUME	DS:TranGroup
 11491                                  	; 14/02/2023
 11492 00000A2D 8E1E[C08A]              	mov	ds,[RESSEG]
 11493                                  	;ASSUME	DS:ResGroup
 11494                                  ;SR;
 11495                                  ; The shift operation is done here to replace the decrement. This is because
 11496                                  ;we can jump to this label directly from above when bogus calls are made to
 11497                                  ;this routine even after batch processing is turned off. The shift ensures
 11498                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11499                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11500                                  ;calls.
 11501                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11502                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11503                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11504                                  ;turning batch processing off.
 11505                                  
 11506                                  At_EOF:					;new label added ;M020
 11507                                  	;shr	byte [es:2],1
 11508 00000A31 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11509                                  					;decrement the flag
 11510 00000A36 7412                    	jz	short turn_off		;zero,turn batch off
 11511                                  	;cmp	byte [es:2],1
 11512 00000A38 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11513 00000A3E 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11514                                  ;
 11515                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11516                                  ;
 11517 00000A40 B00D                    	mov	al,0Dh			;return fake CR.
 11518 00000A42 07                      	pop	es
 11519 00000A43 EB35                    	jmp	short GETBYTEDONE
 11520                                  ret_lf:
 11521 00000A45 B00A                    	mov	al,0Ah			;return fake LF
 11522 00000A47 07                      	pop	es
 11523 00000A48 EB30                    	jmp	short GETBYTEDONE		
 11524                                  turn_off:
 11525 00000A4A 07                      	pop	es
 11526                                  ;BATEOF:
 11527                                  	; MSDOS 3.3
 11528                                  ;TURN_OFF:
 11529                                  	;mov	ds,[RESSEG]
 11530                                  
 11531                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11532                                  BATEOF:
 11533 00000A4B E8B0FE                  	call	BATCHOFF
 11534 00000A4E E8CC02                  	call	BATCLOSE
 11535                                  
 11536                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11537                                  
 11538                                  ;SR; BugBug
 11539                                  ; There is a good reason why this carriage return is being returned here. 
 11540                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11541                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11542                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11543                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11544                                  ;the batchfile already had a CR-LF. 
 11545                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11546                                  ;the end-of-line. This CR is to mark the end-of-file.
 11547                                  
 11548 00000A51 B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11549 00000A53 F606[9601]FF            	test	byte [Batch_Abort],-1
 11550 00000A58 C606[9601]00            	mov	byte [Batch_Abort],0
 11551 00000A5D 7407                    	jz	short CONT_GET_BYT
 11552 00000A5F BF[2189]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11553 00000A62 31C9                    	xor	cx,cx			; zero line length
 11554 00000A64 EB14                    	jmp	short GETBYTEDONE
 11555                                  CONT_GET_BYT:
 11556 00000A66 833E[A601]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11557 00000A6B 750D                    	jne	short GETBYTEDONE
 11558 00000A6D 833E[AF01]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11559 00000A72 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11560 00000A74 C706[A601]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11561                                  GETBYTEDONE:
 11562 00000A7A 1F                      	pop	ds
 11563 00000A7B 59                      	pop	cx
 11564 00000A7C 5B                      	pop	bx
 11565 00000A7D C3                      	retn
 11566                                  
 11567                                  ; ---------------------------------------------------------------------------
 11568                                  
 11569                                  ;break	<$If - conditional execution>
 11570                                  
 11571                                  	; 17/04/2023
 11572                                  ;IFERRORP:
 11573                                  ;	pop	ax
 11574                                  ;IFERROR:
 11575                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11576                                  ;FORERROR:
 11577                                  ;	mov	dx,SYNTMES_PTR
 11578                                  ;	jmp	cerror
 11579                                  
 11580                                  ; ---------------------------------------------------------------------------
 11581                                  
 11582                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11583                                  _$IF:
 11584                                  	; MSDOS 6.0
 11585                                  ; Turn off any pipes in progress.
 11586 00000A7E 1E                      	push	ds			;AN004; save local DS
 11587 00000A7F 8E1E[C08A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11588                                  	;assume	ds:resgroup		;AN004;
 11589 00000A83 803E[1902]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11590 00000A88 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11591                                  	;invoke	PipeDel 		;AN004; turn off piping
 11592 00000A8A E87122                  	call	PIPEDEL	
 11593                                  IFNoPipe:				;AN004;
 11594 00000A8D 1F                      	pop	ds			;AN004; get local DS back
 11595                                  	;assume	ds:trangroup		;AN004;
 11596                                  
 11597                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11598 00000A8E C606[D38A]00            	mov	byte [IFNOTFLAG],0
 11599 00000A93 C706[9B94]0000          	mov	word [IF_NOT_COUNT],0
 11600 00000A99 BE8100                  	mov	si,81h
 11601                                  IFREENT:
 11602 00000A9C E8471B                  	call	scanoff
 11603 00000A9F 3C0D                    	cmp	al,0Dh
 11604 00000AA1 743C                    	je	short IFERROR
 11605 00000AA3 89F5                    	mov	bp,si
 11606 00000AA5 BF[EE82]                	mov	di,IFTAB		; Prepare to search if table	
 11607                                  	;mov	ch,0
 11608                                  	; 17/04/2023
 11609 00000AA8 30ED                    	xor	ch,ch
 11610                                  IFINDCOM:
 11611 00000AAA 89EE                    	mov	si,bp
 11612 00000AAC 8A0D                    	mov	cl,[di]
 11613 00000AAE 47                      	inc	di
 11614 00000AAF E33E                    	jcxz	IFSTRING
 11615 00000AB1 EB02                    	jmp	short FIRSTCOMP
 11616                                  IFCOMP:
 11617 00000AB3 7510                    	jnz	short IF_DIF
 11618                                  FIRSTCOMP:
 11619 00000AB5 AC                      	lodsb
 11620 00000AB6 268A25                  	mov	ah,[es:di]
 11621 00000AB9 47                      	inc	di
 11622 00000ABA 38E0                    	cmp	al,ah
 11623 00000ABC 7405                    	je	short IFLP
 11624 00000ABE 80CC20                  	or	ah,20h			; Try lower case
 11625 00000AC1 38E0                    	cmp	al,ah
 11626                                  IFLP:
 11627 00000AC3 E2EE                    	loop	IFCOMP
 11628                                  IF_DIF:
 11629 00000AC5 9F                      	lahf
 11630 00000AC6 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11631 00000AC8 8B1D                    	mov	bx,[di]			; Get handler address
 11632 00000ACA 47                      	inc	di
 11633 00000ACB 47                      	inc	di
 11634 00000ACC 9E                      	sahf
 11635 00000ACD 75DB                    	jnz	short IFINDCOM
 11636 00000ACF AC                      	lodsb
 11637 00000AD0 3C0D                    	cmp	al,0Dh
 11638                                  IFERRJ:
 11639 00000AD2 740B                    	jz	short IFERROR
 11640 00000AD4 E8171B                  	call	DELIM
 11641 00000AD7 75D1                    	jnz	short IFINDCOM
 11642 00000AD9 E80A1B                  	call	scanoff
 11643 00000ADC FFE3                    	jmp	bx
 11644                                  
 11645                                  	; 17/04/2023
 11646                                  IFERRORP:
 11647 00000ADE 58                      	pop	ax
 11648                                  IFERROR:
 11649                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11650                                  FORERROR:
 11651 00000ADF BA[ED7F]                	mov	dx,SYNTMES_PTR
 11652 00000AE2 E9751E                  	jmp	cerror
 11653                                  
 11654                                  IFNOT:
 11655 00000AE5 F616[D38A]              	not	byte [IFNOTFLAG]
 11656 00000AE9 FF06[9B94]              	inc	word [IF_NOT_COUNT]
 11657 00000AED EBAD                    	jmp	short IFREENT
 11658                                  
 11659                                  ; We are comparing two strings for equality. First, find the end of the
 11660                                  ; first string.
 11661                                  
 11662                                  IFSTRING:
 11663 00000AEF 56                      	push	si			; save away pointer for later compare
 11664 00000AF0 31C9                    	xor	cx,cx			; count of chars in first string
 11665                                  FIRST_STRING:
 11666 00000AF2 AC                      	lodsb				; get character
 11667 00000AF3 3C0D                    	cmp	al,0Dh			; end of line?
 11668 00000AF5 74E7                    	jz	short IFERRORP		; yes => error
 11669 00000AF7 E8F41A                  	call	DELIM			; is it a delimiter?
 11670 00000AFA 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11671 00000AFC 41                      	inc	cx			; remember 1 byte for the length
 11672 00000AFD EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11673                                  EQUAL_CHECK:
 11674 00000AFF 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11675 00000B01 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11676 00000B03 3C0D                    	cmp	al,0Dh			; end of line?
 11677 00000B05 74D7                    	je	short IFERRORP		; yes, syntax error
 11678 00000B07 AC                      	lodsb				; get next char
 11679 00000B08 EBF5                    	jmp	short EQUAL_CHECK
 11680                                  
 11681                                  ; The first = has been found. The next char had better be an = too.
 11682                                  
 11683                                  EQUAL_CHECK2:
 11684 00000B0A AC                      	lodsb				; get potential = char
 11685 00000B0B 3C3D                    	cmp	al,'='			; is it good?	
 11686                                  	;jnz	short IFERRPJ		; no, error
 11687                                  	; 17/04/2023
 11688 00000B0D 75CF                    	jne	short IFERRORP
 11689                                  
 11690                                  ; Find beginning of second string.
 11691                                  
 11692 00000B0F E8D41A                  	call	scanoff
 11693 00000B12 3C0D                    	cmp	al,0Dh
 11694                                  	;jz	short IFERRPJ
 11695                                  	; 17/04/2023
 11696 00000B14 74C8                    	je	short IFERRORP
 11697 00000B16 5F                      	pop	di
 11698                                  
 11699                                  ; DS:SI points to second string
 11700                                  ; CX has number of chars in first string
 11701                                  ; ES:DI points to first string
 11702                                  
 11703 00000B17 F3A6                    	repe	cmpsb
 11704 00000B19 7414                    	jz	short MATCH		; match found!
 11705                                  
 11706                                  ; No match. Let's find out what was wrong. The character that did not match
 11707                                  ; has been advanced over. Let's back up to it.
 11708                                  
 11709 00000B1B 4E                      	dec	si
 11710                                  
 11711                                  ; If it is EOL, then syntax error
 11712                                  
 11713 00000B1C 803C0D                  	cmp	byte [si],0Dh
 11714                                  	;jz	short IFERRJ
 11715                                  	; 17/04/2023
 11716 00000B1F 74BE                    	je	short IFERROR
 11717                                  
 11718                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11719                                  
 11720                                  SKIPSTRINGEND:
 11721 00000B21 AC                      	lodsb
 11722                                  NOTMATCH:
 11723 00000B22 3C0D                    	cmp	al,0Dh
 11724                                  IFERRORJ2:
 11725                                  	;jz	short IFERRJ
 11726                                  	; 17/04/2023
 11727 00000B24 74B9                    	jz	short IFERROR
 11728 00000B26 E8C51A                  	call	DELIM
 11729 00000B29 75F6                    	jnz	short SKIPSTRINGEND
 11730                                  
 11731                                  ; Signal that we did NOT have a match
 11732                                  
 11733 00000B2B B0FF                    	mov	al,-1
 11734 00000B2D EB37                    	jmp	short IFRET
 11735                                  
 11736                                  	; 17/04/2023
 11737                                  ;IFERRPJ:
 11738                                  	;jmp	IFERRORP
 11739                                  
 11740                                  ; The compare succeeded. Was the second string longer than the first?
 11741                                  ; We do this by seeing if the next char is a delimiter.
 11742                                  
 11743                                  MATCH:
 11744 00000B2F AC                      	lodsb
 11745 00000B30 E8BB1A                  	call	DELIM
 11746 00000B33 75ED                    	jnz	short NOTMATCH ; not same.
 11747 00000B35 30C0                    	xor	al,al
 11748 00000B37 EB2D                    	jmp	short IFRET
 11749                                  
 11750                                  ; ---------------------------------------------------------------------------
 11751                                  
 11752                                  IFEXISTS:
 11753                                  
 11754                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11755                                  
 11756                                  ;MOREDELIM:
 11757 00000B39 AC                      	lodsb
 11758 00000B3A E8B11A                  	call	DELIM
 11759 00000B3D 75FA                    	jnz	short IFEXISTS
 11760                                  	;jnz	short MOREDELIM
 11761                                  
 11762 00000B3F BA[C98B]                	mov	dx,DIRBUF
 11763 00000B42 B8001A                  	mov	ax,1A00h
 11764                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11765 00000B45 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11766                                  			; DS:DX	-> disk	transfer buffer
 11767 00000B47 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11768 00000B4A 031E[9B94]              	add	bx,[IF_NOT_COUNT]
 11769                                  	;mov	ax,ARG_ARGV
 11770                                  	;mov	ax,ARG+ARG_UNIT.argv
 11771 00000B4E B8[4F8E]                	mov	ax,ARG
 11772 00000B51 E82426                  	call	argv_calc		; convert arg index to pointer
 11773 00000B54 8B17                    	mov	dx,[bx]
 11774                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11775                                  	;mov	cx,6
 11776 00000B56 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11777 00000B59 B8004E                  	mov	ax,4E00h
 11778                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11779 00000B5C CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11780                                  			; CX = search attributes
 11781                                  			; DS:DX	-> ASCIZ filespec
 11782                                  			; (drive,path, and wildcards allowed)
 11783 00000B5E 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11784 00000B60 30C0                    	xor	al,al
 11785 00000B62 EB02                    	jmp	short IFRET
 11786                                  
 11787                                  	;nop
 11788                                  IF_EX_C:
 11789 00000B64 B0FF                    	mov	al,-1			; false 'n' fall through...
 11790                                  IFRET:
 11791 00000B66 F606[D38A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11792 00000B6B 7402                    	jz	short REALTEST
 11793 00000B6D F6D0                    	not	al
 11794                                  REALTEST:
 11795 00000B6F 08C0                    	or	al,al
 11796 00000B71 7403                    	jz	short IFTRUE
 11797 00000B73 E98EF5                  	jmp	TCOMMAND
 11798                                  
 11799                                  IFTRUE:
 11800 00000B76 E86D1A                  	call	scanoff
 11801 00000B79 89F1                    	mov	cx,si
 11802 00000B7B 81E98100                	sub	cx,81h
 11803 00000B7F 280E8000                	sub	[80h],cl
 11804 00000B83 8A0E8000                	mov	cl,[80h]
 11805 00000B87 880E[2089]              	mov	[COMBUF+1],cl
 11806 00000B8B BF[2189]                	mov	di,COMBUF+2
 11807 00000B8E FC                      	cld
 11808 00000B8F F3A4                    	rep	movsb
 11809 00000B91 B00D                    	mov	al,0Dh
 11810 00000B93 AA                      	stosb
 11811                                  
 11812                                  ; Signal that an IF was done. 
 11813                                  ; This prevents the redirections from getting lost.
 11814                                  
 11815 00000B94 1E                      	push	ds
 11816 00000B95 8E1E[C08A]              	mov	ds,[RESSEG]
 11817 00000B99 C606[AB01]FF            	mov	byte [IfFlag],-1
 11818 00000B9E 1F                      	pop	ds
 11819                                  
 11820                                  ; Go do the command
 11821                                  
 11822 00000B9F E935F7                  	jmp	DOCOM1
 11823                                  
 11824                                  ; ---------------------------------------------------------------------------
 11825                                  
 11826                                  IFERRORJ3:
 11827 00000BA2 EB80                    	jmp	IFERRORJ2
 11828                                  
 11829                                  IFERLEV:
 11830 00000BA4 B70A                    	mov	bh,10
 11831 00000BA6 30DB                    	xor	bl,bl
 11832                                  GETNUMLP:
 11833 00000BA8 AC                      	lodsb
 11834 00000BA9 3C0D                    	cmp	al,0Dh
 11835 00000BAB 74F5                    	je	short IFERRORJ3
 11836 00000BAD E83E1A                  	call	DELIM
 11837 00000BB0 740C                    	jz	short GOTNUM
 11838 00000BB2 2C30                    	sub	al,'0'
 11839 00000BB4 86C3                    	xchg	al,bl
 11840 00000BB6 F6E7                    	mul	bh
 11841 00000BB8 00D8                    	add	al,bl
 11842 00000BBA 86C3                    	xchg	al,bl
 11843 00000BBC EBEA                    	jmp	short GETNUMLP
 11844                                  GOTNUM:
 11845 00000BBE 1E                      	push	ds
 11846 00000BBF 8E1E[C08A]              	mov	ds,[RESSEG]
 11847 00000BC3 8A26[9D01]              	mov	ah,[RetCode]
 11848 00000BC7 1F                      	pop	ds
 11849 00000BC8 30C0                    	xor	al,al
 11850 00000BCA 38DC                    	cmp	ah,bl
 11851 00000BCC 7398                    	jnb	short IFRET
 11852 00000BCE FEC8                    	dec	al
 11853 00000BD0 EB94                    	jmp	short IFRET
 11854                                  
 11855                                  ; ---------------------------------------------------------------------------
 11856                                  
 11857                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11858                                  ; This is a NOP if no batch in progress.
 11859                                  
 11860                                  _SHIFT:
 11861 00000BD2 8E1E[C08A]              	mov	ds,[RESSEG]
 11862 00000BD6 A1[4C01]                	mov	ax,[Batch]		; get batch pointer
 11863 00000BD9 09C0                    	or	ax,ax			; in batch mode?
 11864 00000BDB 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 11865                                  SHIFT_RETN:				; no, done.
 11866 00000BDD C3                      	retn
 11867                                  SHIFT1:
 11868 00000BDE 8EC0                    	mov	es,ax
 11869 00000BE0 8ED8                    	mov	ds,ax
 11870                                  
 11871                                  ; Now move the batch args down by 1 word
 11872                                  
 11873                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 11874                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 11875 00000BE2 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 11876 00000BE5 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 11877 00000BE8 B90900                  	mov	cx,9			; move 9 parameters
 11878 00000BEB F3A5                    	rep	movsw			; SHIFT down
 11879                                  
 11880                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 11881                                  ; We have copied it into the previous position.
 11882                                  
 11883 00000BED 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 11884 00000BF0 74EB                    	je	short SHIFT_RETN ; No new parm
 11885                                  
 11886                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 11887                                  ; Assume, first, that there is no next argument.
 11888                                   
 11889 00000BF2 8B35                    	mov	si,[di]
 11890 00000BF4 C705FFFF                	mov	word [di],-1		; Assume no parm
 11891                                  
 11892                                  ; The parameters are CR separated. Scan for end of this parm.
 11893                                  
 11894                                  SKIPCRLP:
 11895 00000BF8 AC                      	lodsb
 11896 00000BF9 3C0D                    	cmp	al,0Dh
 11897 00000BFB 75FB                    	jne	short SKIPCRLP
 11898                                  
 11899                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 11900                                  ; are finished. There are no more parms and the pointer has been previously
 11901                                  ; initialized to indicate it.
 11902                                  
 11903 00000BFD 803C00                  	cmp	byte [si],0
 11904 00000C00 74DB                    	jz	short SHIFT_RETN 	; End of parms
 11905 00000C02 8935                    	mov	[di],si			; Pointer to next parm as %9
 11906 00000C04 C3                      	retn
 11907                                  
 11908                                  ; =============== S U B	R O U T	I N E =======================================
 11909                                  
 11910                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 11911                                  ; returns char in AL, carry set -> eof
 11912                                  
 11913                                  SKIPDELIM:
 11914 00000C05 F706[4C01]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 11915 00000C0B 740A                    	jz	short SKIPERR
 11916 00000C0D E85DFD                  	call	GETBATBYT		; get a char
 11917 00000C10 E8DB19                  	call	DELIM			; check for ignoreable chars
 11918 00000C13 74F0                    	jz	short SKIPDELIM		; ignore this char.
 11919 00000C15 F8                      	clc
 11920 00000C16 C3                      	retn
 11921                                  SKIPERR:
 11922 00000C17 F9                      	stc
 11923                                  GOTO_RETN:
 11924 00000C18 C3                      	retn
 11925                                  
 11926                                  ; ---------------------------------------------------------------------------
 11927                                  
 11928                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 11929                                  ;  .com file. This routine strips the CALL off the command line, sets
 11930                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 11931                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 11932                                  ;  being CALLed.
 11933                                  
 11934                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11935                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 11936                                  _$CALL:
 11937                                  
 11938                                  ;  strip off CALL from command line
 11939                                  
 11940                                  	;ASSUME DS:trangroup,ES:trangroup
 11941                                  
 11942 00000C19 56                      	push	si
 11943 00000C1A 57                      	push	di
 11944 00000C1B 50                      	push	ax
 11945 00000C1C 51                      	push	cx
 11946 00000C1D BE[2189]                	mov	si,COMBUF+2
 11947 00000C20 E8C319                  	call	scanoff			;get to first non-delimeter
 11948                                  	;add	si,4
 11949 00000C23 83C604                  	add	si,length_call		;point to char past CALL
 11950 00000C26 BF[2189]                	mov	di,COMBUF+2
 11951                                  	;mov	cx,124		
 11952 00000C29 B97C00                  	mov	cx,COMBUFLEN-length_call 
 11953                                  					;get length of buffer
 11954 00000C2C F3A4                    	rep	movsb			;move it
 11955 00000C2E 59                      	pop	cx
 11956 00000C2F 58                      	pop	ax
 11957 00000C30 5F                      	pop	di
 11958 00000C31 5E                      	pop	si
 11959                                  
 11960                                  ;  set call flag to indicate call in progress
 11961                                  
 11962 00000C32 1E                      	push	ds
 11963 00000C33 8E1E[C08A]              	mov	ds,[RESSEG]
 11964 00000C37 C606[B101]01            	mov	byte [Call_Flag],call_in_progress ; 1
 11965 00000C3C C606[B201]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 11966                                  
 11967                                  ; Turn off any pipes in progress.
 11968                                  
 11969 00000C41 803E[1902]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 11970 00000C46 7403                    	jz	short _NOPIPE
 11971 00000C48 E8B320                  	call	PIPEDEL
 11972                                  _NOPIPE:
 11973 00000C4B 1F                      	pop	ds
 11974 00000C4C C3                      	retn
 11975                                  
 11976                                  ; ---------------------------------------------------------------------------
 11977                                  
 11978                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11979                                  _GOTO:
 11980 00000C4D 8E1E[C08A]              	mov	ds,[RESSEG]
 11981 00000C51 F706[4C01]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 11982 00000C57 74BF                    	jz	short GOTO_RETN
 11983 00000C59 31D2                    	xor	dx,dx
 11984 00000C5B 1E                      	push	ds
 11985 00000C5C 8E1E[4C01]              	mov	ds,[Batch]
 11986                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 11987 00000C60 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 11988                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 11989 00000C64 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 11990                                  
 11991                                  	; MSDOS 6.0
 11992                                  ;M037
 11993                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 11994                                  ;
 11995 00000C68 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 11996                                  					; clear eof indicator ;M037
 11997                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11998 00000C6D 1F                      	pop	ds
 11999                                  GOTOOPEN:
 12000 00000C6E E870F8                  	call	PROMPTBAT
 12001                                  	;mov	di,5Dh
 12002 00000C71 BF5D00                  	mov	di,FCB+1		; Get the label
 12003 00000C74 B90B00                  	mov	cx,11
 12004 00000C77 B020                    	mov	al,' '
 12005 00000C79 F2AE                    	repne	scasb
 12006 00000C7B 7501                    	jnz	short NOINC
 12007 00000C7D 41                      	inc	cx
 12008                                  NOINC:
 12009 00000C7E 83E90B                  	sub	cx,11
 12010 00000C81 F7D9                    	neg	cx
 12011                                  	;mov	[cs:GOTOLEN],cx
 12012                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12013 00000C83 26890E[C98B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12014                                  
 12015                                  ; At beginning of file. Skip to first non-delimiter char
 12016                                  
 12017 00000C88 E87AFF                  	call	SKIPDELIM
 12018 00000C8B 721C                    	jb	short BADGOTO
 12019 00000C8D 3C3A                    	cmp	al,':'
 12020 00000C8F 7426                    	jz	short CHKLABEL
 12021                                  LABLKLP:				; Look for the label
 12022 00000C91 E8D9FC                  	call	GETBATBYT
 12023 00000C94 3C0A                    	cmp	al,0Ah
 12024 00000C96 7509                    	jne	short LABLKTST
 12025                                  
 12026                                  ; At beginning of line. Skip to first non-delimiter char
 12027                                  
 12028 00000C98 E86AFF                  	call	SKIPDELIM
 12029 00000C9B 720C                    	jb	short BADGOTO
 12030 00000C9D 3C3A                    	cmp	al,':'
 12031 00000C9F 7416                    	je	short CHKLABEL
 12032                                  LABLKTST:
 12033 00000CA1 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
 12034 00000CA7 75E8                    	jnz	short LABLKLP
 12035                                  BADGOTO:
 12036 00000CA9 E87100                  	call	BATCLOSE
 12037                                  
 12038                                  	; MSDOS 6.0
 12039                                  ;SR;
 12040                                  ; At this point we are terminating without freeing up any nested batch 
 12041                                  ;segments i.e if the error occurred within a called batch file. This routine
 12042                                  ;will traverse the linked list of batch segments and free all of them.
 12043                                  ;
 12044 00000CAC E8BB00                  	call	free_batch		; free up nested batch segments
 12045                                  
 12046                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12047 00000CAF 0E                      	push	cs
 12048 00000CB0 1F                      	pop	ds
 12049 00000CB1 BA[EA7F]                	mov	dx,BADLAB_PTR
 12050 00000CB4 E9A31C                  	jmp	cerror
 12051                                  
 12052                                  ; Found the :.	Skip to first non-delimiter char
 12053                                  
 12054                                  CHKLABEL:
 12055 00000CB7 E84BFF                  	call	SKIPDELIM
 12056 00000CBA 72ED                    	jb	short BADGOTO
 12057 00000CBC BF5D00                  	mov	di,FCB+1 ; 5Dh
 12058                                  	;mov	cx,[cs:GOTOLEN]
 12059                                  	; 14/02/2023
 12060 00000CBF 268B0E[C98B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12061 00000CC4 EB05                    	jmp	short GOTBYTE
 12062                                  
 12063                                  NEXTCHRLP:
 12064 00000CC6 51                      	push	cx
 12065 00000CC7 E8A3FC                  	call	GETBATBYT
 12066 00000CCA 59                      	pop	cx
 12067                                  GOTBYTE:
 12068                                  	; 18/03/2023
 12069                                  	; 14/02/2023
 12070                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12071 00000CCB E8F616                  	call	testkanj
 12072 00000CCE 7413                    	jz	short NOTKANJ1
 12073 00000CD0 263A05                  	cmp	al,[es:di]
 12074 00000CD3 75CC                    	jne	short LABLKTST
 12075 00000CD5 47                      	inc	di
 12076 00000CD6 49                      	dec	cx
 12077 00000CD7 E3C8                    	jcxz	LABLKTST
 12078 00000CD9 51                      	push	cx
 12079 00000CDA E890FC                  	call	GETBATBYT
 12080 00000CDD 59                      	pop	cx
 12081 00000CDE 263A05                  	cmp	al,[es:di]
 12082 00000CE1 EB0C                    	jmp	short KNEXTLABCHR
 12083                                  NOTKANJ1:
 12084                                  	; 14/02/2023
 12085                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12086 00000CE3 0C20                    	or	al,20h
 12087 00000CE5 263A05                  	cmp	al,[es:di]
 12088                                  	;jne	short TRYUPPER
 12089                                  	;jmp	short NEXTLABCHR
 12090                                  	; 25/04/2023
 12091 00000CE8 7407                    	je	short NEXTLABCHR 
 12092                                  TRYUPPER:
 12093 00000CEA 2C20                    	sub	al,20h
 12094 00000CEC 263A05                  	cmp	al,[es:di]
 12095                                  KNEXTLABCHR:
 12096 00000CEF 75B0                    	jnz	short LABLKTST
 12097                                  NEXTLABCHR:
 12098 00000CF1 47                      	inc	di
 12099 00000CF2 E2D2                    	loop	NEXTCHRLP
 12100 00000CF4 E876FC                  	call	GETBATBYT
 12101                                  	; 14/02/2023
 12102 00000CF7 26833E[C98B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12103                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12104 00000CFD 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12105 00000CFF 3C20                    	cmp	al,' '
 12106 00000D01 779E                    	ja	short LABLKTST
 12107                                  GOTOCONT:
 12108 00000D03 3C0D                    	cmp	al,0Dh
 12109 00000D05 7407                    	je	short SKIPLFEED
 12110                                  TONEXTBATLIN:
 12111 00000D07 E863FC                  	call	GETBATBYT
 12112 00000D0A 3C0D                    	cmp	al,0Dh
 12113 00000D0C 75F9                    	jne	short TONEXTBATLIN
 12114                                  SKIPLFEED:
 12115 00000D0E E85CFC                  	call	GETBATBYT
 12116                                  
 12117                                  	; MSDOS 6.0
 12118                                  ;SR;
 12119                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12120                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12121                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12122                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12123                                  ;all other cases, EOF will be hit while trying to read the next line and
 12124                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12125                                  ;
 12126 00000D11 06                      	push	es
 12127 00000D12 8E06[4C01]              	mov	es,[Batch]
 12128 00000D16 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12129                                  					;invalidate fake CR-LF flag
 12130 00000D1C 07                      	pop	es
 12131                                  
 12132                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12133                                  	;call	BATCLOSE
 12134                                  	;retn
 12135                                  	; 14/02/2023
 12136                                  	;jmp	short BATCLOSE
 12137                                  
 12138                                  ; =============== S U B	R O U T	I N E =======================================
 12139                                  
 12140                                  BATCLOSE:
 12141 00000D1D 2E8B1E[F48D]            	mov	bx,[cs:BATHAND]
 12142 00000D22 83FB05                  	cmp	bx,5
 12143 00000D25 7204                    	jb	short CLOSERETURN
 12144                                  	; 14/02/2023
 12145 00000D27 B43E                    	mov	ah,3Eh
 12146                                  	;mov	ah,CLOSE ; 3Eh
 12147 00000D29 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12148                                  			; BX = file handle
 12149                                  CLOSERETURN:
 12150 00000D2B C606[9501]00            	mov	byte [In_Batch],0 ; reset flag	
 12151 00000D30 C3                      	retn
 12152                                  
 12153                                  ; =============== S U B	R O U T	I N E =======================================
 12154                                  
 12155                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12156                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12157                                  
 12158                                  	; 14/02/2023
 12159                                  BATOPEN:
 12160 00000D31 1E                      	push	ds
 12161 00000D32 8E1E[4C01]              	mov	ds,[Batch]
 12162                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12163                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12164 00000D36 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12165 00000D39 B8003D                  	mov	ax,3D00h
 12166                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12167 00000D3C CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12168                                  			; DS:DX	-> ASCIZ filename
 12169                                  			; AL = access mode
 12170                                  			; 0 - read
 12171 00000D3E 721C                    	jb	short SETERRDL
 12172                                  	;mov	dx,[8]
 12173 00000D40 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12174                                  	;mov	cx,[10]
 12175 00000D44 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12176 00000D48 1F                      	pop	ds
 12177                                  	;mov	[cs:BATHAND],ax
 12178 00000D49 26A3[F48D]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12179 00000D4D 89C3                    	mov	bx,ax
 12180 00000D4F B80042                  	mov	ax,4200h
 12181                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12182 00000D52 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12183                                  			; AL = method: offset from beginning of	file
 12184                                  
 12185                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12186                                  					; nuke batch buffer position
 12187 00000D54 26C706[C795]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12188                                  BATOPEN_RETN:
 12189 00000D5B C3                      	retn
 12190                                  
 12191                                  SETERRDL:
 12192 00000D5C 89D3                    	mov	bx,dx
 12193                                  	; MSDOS 6.0
 12194                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12195                                  	; 14/02/2023
 12196 00000D5E E8A10F                  	call	get_ext_error_number
 12197 00000D61 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12198                                  
 12199                                  	; MSDOS 3.3
 12200                                  	;mov	dx,INSERTDSKPTR
 12201                                  	;call	GET_EXT_ERR_NUMBER
 12202                                  
 12203                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12204 00000D63 8A07                    	mov	al,[bx]			; Get drive spec
 12205 00000D65 2C40                    	sub	al,'@'			; A = 1
 12206 00000D67 1F                      	pop	ds
 12207 00000D68 F9                      	stc				; SUB mucked over carry
 12208 00000D69 C3                      	retn
 12209                                  
 12210                                  ; =============== S U B	R O U T	I N E =======================================
 12211                                  
 12212                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12213                                  ;the batch and FOR segments until all of them are freed. It also restores
 12214                                  ;the old state of the EchoFlag.
 12215                                  ;
 12216                                  ;	ENTRY:	ds = RESGROUP
 12217                                  ;
 12218                                  ;	EXIT: 	All batch & FOR segments freed.
 12219                                  ;		EchoFlag restored to old state before batch process.
 12220                                  ;
 12221                                  ;	REGISTERS AFFECTED: bx, cx
 12222                                  
 12223                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12224                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12225                                  
 12226                                  free_batch: ;proc near
 12227                                  	;assume	ds:RESGROUP,es:nothing
 12228                                  
 12229 00000D6A 06                      	push	es
 12230 00000D6B 8B1E[B301]              	mov	bx,[Next_Batch]
 12231 00000D6F 09DB                    	or	bx,bx
 12232 00000D71 7432                    	jz	short fb_ret
 12233                                  _ClearBatch:
 12234 00000D73 8EC3                    	mov	es,bx			; get batch segment
 12235                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12236 00000D75 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12237 00000D7A 83FB00                  	cmp	bx,0			; is a FOR in progress
 12238 00000D7D 7408                    	je	short no_bat_for	; no - don't deallocate
 12239 00000D7F 06                      	push	es			;
 12240 00000D80 8EC3                    	mov	es,bx			; yes - free it up...
 12241 00000D82 B449                    	mov	ah,49h
 12242                                  	;mov	ah,DEALLOC		;
 12243 00000D84 CD21                    	int	21h			;
 12244 00000D86 07                      	pop	es			; restore to batch segment
 12245                                  no_bat_for:
 12246                                  	;mov	cl,[es:1]
 12247 00000D87 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12248                                  					; get old echo flag
 12249                                  	;mov	bx,[es:3]
 12250 00000D8C 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12251                                  					; get old batch segment
 12252 00000D91 B449                    	mov	ah,49h
 12253                                  	;mov	ah,DEALLOC		; free it up...
 12254 00000D93 CD21                    	int	21h
 12255                                  	; 14/02/2023
 12256                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12257 00000D95 FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
 12258 00000D99 75D8                    	jnz	short _ClearBatch	; keep going until no batch file
 12259                                  	
 12260 00000D9B 880E[A001]              	mov	[EchoFlag],cl		;restore echo status
 12261 00000D9F C706[4C01]0000          	mov	word [Batch],0		;no batch process in progress
 12262                                  fb_ret:
 12263 00000DA5 07                      	pop	es
 12264 00000DA6 C3                      	ret
 12265                                  
 12266                                  ;free_batch endp
 12267                                  
 12268                                  ;============================================================================
 12269                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12270                                  ;============================================================================
 12271                                  ; 10/10/2018 - Retro DOS v3.0
 12272                                  
 12273                                  ; All batch proccessing has DS set to segment of resident portion
 12274                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12275                                  
 12276                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12277                                  
 12278                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12279                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12280                                  
 12281                                  ; ---------------------------------------------------------------------------
 12282                                  
 12283                                  	; 15/02/2023
 12284                                  FORTERM:
 12285                                  	; MSDOS 6.0
 12286 00000DA7 0E                      	push	cs			;AN037; Get local segment into
 12287 00000DA8 1F                      	pop	ds			;AN037;  DS, ES
 12288 00000DA9 0E                      	push	cs			;AN037;
 12289 00000DAA 07                      	pop	es			;AN037;
 12290                                  
 12291                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12292 00000DAB E89702                  	call	FOROFF
 12293                                  	;mov	ds,[cs:RESSEG]
 12294 00000DAE 268E1E[C08A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12295 00000DB3 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12296 00000DB9 750F                    	jne	short BAT_CRLF
 12297 00000DBB 833E[AF01]00            	cmp	word [Nest],0		;See if we have nested batch files
 12298 00000DC0 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12299 00000DC2 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12300 00000DC8 EB12                    	jmp	short NOFORP2
 12301                                  BAT_CRLF:
 12302 00000DCA F606[A001]01            	test	byte [EchoFlag],1 	; Is echo on?
 12303 00000DCF 740B                    	jz	short NOFORP2		; no - exit
 12304 00000DD1 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12305                                  					; print CRLF if in batch
 12306 00000DD7 7403                    	jz	short NOFORP2
 12307 00000DD9 E8FD17                  	call	CRLF2
 12308                                  NOFORP2:
 12309 00000DDC E925F3                  	jmp	TCOMMAND
 12310                                  
 12311                                  ; ---------------------------------------------------------------------------
 12312                                  
 12313                                  ;------
 12314                                  ;   For-loop processing. For loops are of the form:
 12315                                  ;	    for %<loop-variable> in (<list>) do <command>
 12316                                  ; where <command> may contain references of the form %<variable>, which are
 12317                                  ; later substituted with the items in <list>. The for-loop structure is
 12318                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12319                                  ; <command> once for each item in <list>. All of the information needed for
 12320                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12321                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12322                                  ; a complete copy of the original command-line structure as parsed by
 12323                                  ; 'parseline', loop control variables, and a dma buffer for the
 12324                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12325                                  ; processing has completed, this chunk of memory is returned to the system.
 12326                                  ;
 12327                                  ;   All of the previously defined variables, in 'datares', used for loop
 12328                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12329                                  ;
 12330                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12331                                  ; containing all of the other error messages.
 12332                                  ;
 12333                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12334                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12335                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12336                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12337                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12338                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12339                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12340                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12341                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12342                                  ; instead of
 12343                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12344                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12345                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12346                                  ; doesn't matter whether we put brackets around the location or not -- the
 12347                                  ; assembler is "smart" enough to know that we want an address instead of the
 12348                                  ; contents of that location.
 12349                                  ;
 12350                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12351                                  ; One method would be to have a link field in each for-structure pointing to
 12352                                  ; its parent.  Variable references that couldn't be resolved in the local
 12353                                  ; frame would cause a search of prior frames. For-structures would still be
 12354                                  ; allocated and released in exactly the same fashion. The only limit on the
 12355                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12356                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12357                                  ; maintained in the resident data area. This structure would be an array of
 12358                                  ; control-variable names and pointers to for-structure blocks. This would
 12359                                  ; greatly speed up the resolution of non-local variable references. However,
 12360                                  ; since space in the resident is precious, we would have to compromise on a
 12361                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12362                                  ; allocation and de-allocation would have to be modified slightly to take this
 12363                                  ; new structure into account.
 12364                                  ;
 12365                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12366                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12367                                  ; it may be easier to allocate it as part of 'for_segment'.
 12368                                  ;------
 12369                                  		; include fordata.asm
 12370                                  
 12371                                  ; Data structure definitions included by tfor.asm
 12372                                  
 12373                                  struc FOR_INFO
 12374 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12375 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12376 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12377 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12378 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12379 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12380 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12381 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12382                                    .size:
 12383                                  endstruc
 12384                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12385                                  _$FOR_EXIT:
 12386 00000DDF EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12387                                  
 12388                                  ; ---------------------------------------------------------------------------
 12389                                  
 12390                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
 12391                                  FORPROC:
 12392 00000DE1 A1[AD01]                	mov	ax,[ForPtr]
 12393 00000DE4 8ED8                    	mov	ds,ax
 12394 00000DE6 8EC0                    	mov	es,ax			; operate in for-info area
 12395                                  	;mov	dx,5CBh	; MSDOS 5.0
 12396 00000DE8 BACB05                  	mov	dx,FOR_INFO.FORDMA ; 5CBh
 12397                                  					; 1348+1+2+2+2+128 = 1483 = 5CBh
 12398 00000DEB B8001A                  	mov	ax,1A00h
 12399                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12400 00000DEE CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12401                                  			; DS:DX	-> disk	transfer buffer
 12402                                  FOR_BEGIN:
 12403                                  	;cmp	word [545h],0
 12404 00000DF0 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0 ; [545h]
 12405 00000DF5 7404                    	jz	short FOR_BEGIN1
 12406                                  					; non-zero for_expand equals FALSE
 12407                                  	;inc	word [547h]
 12408 00000DF7 FF064705                	inc	word [FOR_INFO.FOR_MINARG] ; [547h]
 12409                                  FOR_BEGIN1:
 12410 00000DFB 8B1E4705                	mov	bx,[FOR_INFO.FOR_MINARG] ; [547h]
 12411                                  					; current item in <list> to examine
 12412 00000DFF 3B1E4905                	cmp	bx,[FOR_INFO.FOR_MAXARG] ; [549h]
 12413 00000E03 7FDA                    	jg	short _$FOR_EXIT	; exceeding maxarg means all done	
 12414                                  	;mov	ax,0
 12415 00000E05 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12416 00000E08 E86D23                  	call	argv_calc		; compute argv[x] address
 12417                                  	;mov	cx,[bx+3]
 12418 00000E0B 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12419 00000E0E 8B17                    	mov	dx,[bx]
 12420                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12421                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12422 00000E10 F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12423 00000E14 7514                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12424 00000E16 8B37                    	mov	si,[bx]
 12425                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12426                                  
 12427                                  	;mov	al,[cs:LPAREN]
 12428                                  	; 15/02/2023
 12429                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12430 00000E18 B028                    	mov	al,'('	; mov al,lparen
 12431 00000E1A 3844FF                  	cmp	[si-1],	al		; If the current token is the first
 12432 00000E1D 750B                    	jne	short FORSUB		;  one in the list and originally had
 12433 00000E1F 41                      	inc	cx			;  the opening paren as its first char,
 12434                                  					;  the argstartel ptr needs to be
 12435                                  					;  advanced passed it before the prefix
 12436                                  					;  length is computed.
 12437 00000E20 B03A                    	mov	al,':'
 12438 00000E22 384401                  	cmp	[si+1],	al		; If the token begins with "(d:",
 12439 00000E25 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12440 00000E27 83C102                  	add	cx,2			;  rest of the prefix as well.
 12441                                  FORSUB:
 12442 00000E2A 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12443                                  	;cmp	word [545h],0
 12444 00000E2C 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12445                                  					; are we still expanding a name?
 12446 00000E31 7416                    	jz	short FOR_FIND_NEXT
 12447                                  					; if so, get next matching filename
 12448                                  	;test	byte [bx+2],2
 12449 00000E33 F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12450 00000E37 7505                    	jnz	short FOR_FIND_FIRST
 12451                                  					; should we expand THIS (new) arg?
 12452                                  	;mov	cx,[bx+5]	
 12453                                  					; else, just copy all of it directly	
 12454 00000E39 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12455 00000E3C EB1D                    	jmp	short FOR_SMOOSH
 12456                                  
 12457                                  	;nop
 12458                                  	; 15/02/2023
 12459                                  FOR_FIND_FIRST:
 12460 00000E3E 51                      	push	cx
 12461 00000E3F 31C9                    	xor	cx,cx
 12462 00000E41 B8004E                  	mov	ax,4E00h
 12463                                  	;mov	ax,Find_First*256 ; 4E00h
 12464 00000E44 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12465                                  			; CX = search attributes
 12466                                  			; DS:DX	-> ASCIZ filespec
 12467                                  			; (drive,path, and wildcards allowed)
 12468 00000E46 59                      	pop	cx
 12469 00000E47 EB05                    	jmp	short FOR_RESULT
 12470                                  
 12471                                  	;nop
 12472                                  FOR_FIND_NEXT:
 12473 00000E49 B8004F                  	mov	ax,4F00h
 12474                                  	;mov	ax,Find_Next*256 ;4F00h
 12475 00000E4C CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12476                                  			; [DTA]	= data block from
 12477                                  			; last AH = 4Eh/4Fh call
 12478                                  FOR_RESULT:
 12479 00000E4E B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12480 00000E51 7201                    	jc	short FOR_CHECK
 12481                                  	; 15/02/2023
 12482 00000E53 40                      	inc	ax ; ax = 0
 12483                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12484                                  FOR_CHECK:				; record success of findfirst/next
 12485 00000E54 A34505                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12486 00000E57 09C0                    	or	ax,ax			; anything out there?
 12487 00000E59 7595                    	jnz	short FOR_BEGIN		; if not, try next arg
 12488                                  FOR_SMOOSH:
 12489                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12490 00000E5B 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12491                                  	;mov	di,54Bh	; MSDOS 5.0
 12492 00000E5D BF4B05                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12493 00000E60 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12494                                  					
 12495 00000E62 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12496                                  					; if we're not expanding, we can
 12497 00000E67 7509                    	jnz	short FOR_MAKE_COM 	; skip the following	
 12498                                  	; 15/02/2023
 12499                                  	;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.0 COMMAND.COM
 12500 00000E69 BEE905                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12501                                  FOR_MORE:
 12502                                  	;cmp	byte [si],0		; tack on matching filename
 12503                                  	;jz	short FOR_MAKE_COM
 12504                                  	;movsb
 12505                                  	;jnz	short FOR_MORE
 12506                                  	; 25/04/2023
 12507 00000E6C AC                      	lodsb
 12508 00000E6D AA                      	stosb
 12509 00000E6E 08C0                    	or	al,al
 12510 00000E70 75FA                    	jnz	short FOR_MORE
 12511                                  FOR_MAKE_COM:
 12512                                  	; 25/04/2023
 12513                                  	;xor	al,al			; tack a null byte onto the end
 12514                                  	;stosb				; of the substitute string
 12515 00000E72 31C9                    	xor	cx,cx			; character count for command line
 12516 00000E74 F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12517 00000E76 31DB                    	xor	bx,bx			; argpointer
 12518 00000E78 BF[2189]                	mov	di,COMBUF+2
 12519                                  	; 15/02/2023
 12520                                  	;mov	bl,[544h]  ; MSDOS 5.0
 12521 00000E7B 8A1E4405                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12522                                  	;mov	dh,[64Bh]
 12523 00000E7F 8A364B06                	mov	dh,[FOR_INFO.FOR_VAR] 
 12524                                  					; %<for-var> is replaced by [forbuf]
 12525 00000E83 0E                      	push	cs			; time to form the <command> string
 12526 00000E84 07                      	pop	es
 12527                                  	;assume ES:trangroup
 12528                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12529 00000E85 B80000                  	mov	ax,0			; translate offset to pointer
 12530 00000E88 E8ED22                  	call	argv_calc
 12531                                  	;mov	si,[bx+9]
 12532 00000E8B 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr] 
 12533                                  					; mov ptr passed beginning space
 12534 00000E8E 46                      	inc	si
 12535                                  FOR_MAKE_LOOP:
 12536 00000E8F 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12537 00000E91 46                      	inc	si
 12538 00000E92 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12539 00000E94 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12540 00000E96 3834                    	cmp	[si],dh			; got the right <variable>?
 12541 00000E98 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12542 00000E9A 46                      	inc	si			; skip over <for-variable>
 12543                                  
 12544 00000E9B 56                      	push	si
 12545                                  	; 15/02/2023
 12546                                  	;mov	si,54Bh	; MSDOS 5.0
 12547 00000E9C BE4B05                  	mov	si,FOR_INFO.FORBUF
 12548                                  					; substitute the <item> for <variable>
 12549                                  					; to make a final <command> to execute
 12550                                  SLOOP:					
 12551 00000E9F AC                      	lodsb				; grab all those <item> bytes, and
 12552 00000EA0 AA                      	stosb				; add 'em to the <command> string,
 12553 00000EA1 08C0                    	or	al,al			; until we run into a null
 12554 00000EA3 E0FA                    	loopne	SLOOP
 12555 00000EA5 4F                      	dec	di			; adjust length and <command> pointer
 12556 00000EA6 41                      	inc	cx			; so we can overwrite the null
 12557 00000EA7 5E                      	pop	si
 12558 00000EA8 EBE5                    	jmp	short FOR_MAKE_LOOP
 12559                                  					; got back for more <command> bytes
 12560                                  FOR_STOSB:
 12561 00000EAA AA                      	stosb				; take a byte from the <command> arg
 12562 00000EAB 49                      	dec	cx			; and put it into the <command> to be
 12563                                  					; executed (and note length, too)
 12564 00000EAC 3C0D                    	cmp	al,0Dh		
 12565 00000EAE 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12566                                  FOR_MADE_COM:
 12567 00000EB0 F6D1                    	not	cl
 12568                                  	;mov	[cs:COMBUF+1],cl
 12569                                  	;mov	ds,[cs:RESSEG]
 12570                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12571                                  	; MSDOS 5.0 COMMAND.COM
 12572 00000EB2 26880E[2089]            	mov	[es:COMBUF+1],cl
 12573 00000EB7 268E1E[C08A]            	mov	ds,[es:RESSEG]				
 12574                                  	;assume DS:resgroup
 12575 00000EBC F606[A001]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12576 00000EC1 742F                    	jz	short NOECHO3
 12577                                  	;cmp	byte [NullFlag],nullcommand
 12578 00000EC3 803E[B501]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12579 00000EC8 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf	 	
 12580                                  
 12581 00000ECA E80C17                  	call	CRLF2		  	;G Print out prompt
 12582                                  NO_CRLF_PR:
 12583 00000ECD C606[B501]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12584 00000ED2 0E                      	push	cs
 12585 00000ED3 1F                      	pop	ds
 12586 00000ED4 57                      	push	di
 12587 00000ED5 E8BA0E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12588 00000ED8 5F                      	pop	di
 12589                                  
 12590 00000ED9 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12591 00000EDE C706[B08C][2189]        	mov	word [string_ptr_2],COMBUF+2
 12592                                  	; 17/04/2023
 12593 00000EE4 BA[1C81]                	mov	dx,string_buf_ptr
 12594 00000EE7 E8393F                  	call	std_printf
 12595 00000EEA 26C645FF0D              	mov	byte [es:di-1],0Dh
 12596 00000EEF E9E2F3                  	jmp	DOCOM		  	; run silent, run deep...
 12597                                  NOECHO3:
 12598 00000EF2 C606[B501]00            	mov	byte [NullFlag],0
 12599 00000EF7 0E                      	push	cs
 12600 00000EF8 1F                      	pop	ds
 12601 00000EF9 E9DBF3                  	jmp	DOCOM1
 12602                                  
 12603                                  FORNESTERRJ:				; no multi-loop processing... yet!		
 12604 00000EFC E84601                  	call	FOROFF
 12605 00000EFF E92901                  	jmp	FORNESTERR
 12606                                  
 12607                                  ; ---------------------------------------------------------------------------
 12608                                  
 12609                                  FORERRORJ:
 12610 00000F02 E9DAFB                  	jmp	FORERROR
 12611                                  
 12612                                  ; ---------------------------------------------------------------------------
 12613                                  
 12614                                  _$FOR:
 12615 00000F05 8E06[C08A]              	mov	es,[RESSEG]
 12616 00000F09 26803E[AC01]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12617 00000F0F 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12618                                  
 12619                                  ; Turn off any pipes in progress.
 12620                                  
 12621 00000F11 26803E[1902]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12622 00000F17 7403                    	jz	short NO_PIPE
 12623 00000F19 E8E21D                  	call	PIPEDEL
 12624                                  NO_PIPE:
 12625 00000F1C 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12626 00000F1E E8F400                  	call	NEXTARG			; move to next argv[n]
 12627 00000F21 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12628 00000F23 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12629 00000F25 75DB                    	jne	short FORERRORJ
 12630 00000F27 89C5                    	mov	bp,ax			; save forloop variable
 12631 00000F29 AC                      	lodsb
 12632 00000F2A 08C0                    	or	al,al			; and MUST end immediately...
 12633 00000F2C 75D4                    	jnz	short FORERRORJ
 12634 00000F2E E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12635 00000F31 72CF                    	jb	short FORERRORJ
 12636                                  	;and	ax,0DFDFh
 12637 00000F33 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12638                                  	; 15/02/2023
 12639                                  	;cmp	ax,4E49h  	; MSDOS 5.0	
 12640                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12641                                  	;cmp	ax,in_word	; MSDOS 5.0
 12642 00000F36 3D494E                  	cmp	ax,'IN'
 12643 00000F39 75C7                    	jnz	short FORERRORJ
 12644 00000F3B AC                      	lodsb
 12645                                  
 12646                                  	; 15/02/2023
 12647                                  	; MSDOS 3.3
 12648                                  	;or	al,al			; it, too, must end right away
 12649                                  	;jz	short CHECKLPAREN
 12650                                  	;cmp	al,[LPAREN]
 12651                                  	;jnz	short FORERRORJ
 12652                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12653                                  	;add	word [bx],2
 12654                                  	;;add	word [bx+9],2
 12655                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12656                                  	;;sub	word [bx+5],2
 12657                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12658                                  	;mov	ax,[si-1]
 12659                                  	;jmp	short LPCHECK
 12660                                  
 12661                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12662                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12663                                  
 12664                                  	; MSDOS 6.0
 12665                                  ; Compaq bug fix -- exit from this loop on error
 12666                                  
 12667 00000F3C 08C0                    	or	al,al
 12668 00000F3E 75C2                    	jne	short FORERRORJ		; jump on error
 12669                                  
 12670                                  ;	je	short CHECKLPAREN
 12671                                  ;
 12672                                  ; Not null. Perhaps there are no spaces between this and the (:
 12673                                  ;   FOR %i in(foo bar...
 12674                                  ; Check for the Lparen here
 12675                                  ;
 12676                                  ;;	cmp	al,lparen
 12677                                  ;;	jnz	short FORERRORJ	
 12678                                  ;
 12679                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12680                                  ; being there in the first place.
 12681                                  ;
 12682                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12683                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12684                                  ;;						; advance original string
 12685                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12686                                  ;
 12687                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12688                                  ; current value.
 12689                                  ;
 12690                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12691                                  ;;	jmp	short LPCHECK
 12692                                  ;
 12693                                  ; end of Compaq bug fix
 12694                                  
 12695                                  ; ---------------------------------------------------------------------------
 12696                                  
 12697                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12698                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12699                                  
 12700                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12701                                  CHECKLPAREN:
 12702 00000F40 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12703 00000F43 72BD                    	jc	short FORERRORJ
 12704                                  LPCHECK:
 12705                                  	; 15/02/2023
 12706                                  	; MSDOS 5.0 (% MSDOS 6.0)	
 12707                                  	;;cmp	al,[LPAREN]
 12708                                  	;cmp	al,lparen
 12709 00000F45 3C28                    	cmp	al,'('
 12710 00000F47 75B9                    	jne	short FORERRORJ
 12711 00000F49 80FC00                  	cmp	ah,0
 12712 00000F4C 7410                    	je	short FOR_PAREN_TOKEN
 12713                                  	;;cmp	ah,[RPAREN]		; special case:  null list	
 12714                                  	;cmp	ah,rparen
 12715 00000F4E 80FC29                  	cmp	ah,')'
 12716 00000F51 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12717 00000F53 E951FE                  	jmp	FORTERM
 12718                                  FOR_LIST_NOT_EMPTY:
 12719                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12720 00000F56 FF07                    	inc	word [bx]		; Advance ptr past "("
 12721                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry	
 12722 00000F58 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12723 00000F5B 46                      	inc	si			; Inc si so check for ")" works
 12724 00000F5C EB0D                    	jmp	short FOR_LIST
 12725                                  
 12726                                  	;nop
 12727                                  FOR_PAREN_TOKEN:
 12728 00000F5E E8B400                  	call	NEXTARG			; what have we in our <list>?
 12729 00000F61 729F                    	jc	short FORERRORJ
 12730                                  	; 15/02/2023
 12731                                  	;;;cmp	ax,[RPAREN+1]	
 12732                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12733                                  	;cmp	ax,nullrparen
 12734 00000F63 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12735 00000F66 7503                    	jne	short FOR_LIST
 12736 00000F68 E93CFE                  	jmp	FORTERM
 12737                                  
 12738                                  ;FORERORJJ:
 12739                                  	;jmp	FORERROR
 12740                                  
 12741                                  FOR_LIST:				; skip over rest of <list>
 12742 00000F6B 89D1                    	mov	cx,dx			; first arg of <list>
 12743                                  
 12744                                  SKIP_LIST:
 12745                                  	;add	si,[bx+5]
 12746 00000F6D 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12747 00000F70 83EE03                  	sub	si,3			; si = ptr to last char of token
 12748                                  	; 15/02/2023
 12749                                  	;;mov	al,[RPAREN]
 12750                                  	;mov	al,rparen
 12751 00000F73 B029                    	mov	al,')'
 12752 00000F75 3804                    	cmp	[si],al			; Is this the last element in <list>
 12753 00000F77 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12754 00000F79 E89900                  	call	NEXTARG			; No, get next arg <list>
 12755                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12756                                  	;jmp	short SKIP_LIST
 12757                                  	; 15/02/2023
 12758 00000F7C 73EF                    	jnc	short SKIP_LIST
 12759                                  
 12760                                  	; 15/02/2023
 12761                                  FORERORJJ:
 12762 00000F7E E95EFB                  	jmp	FORERROR
 12763                                  
 12764                                  FOR_END_LIST:
 12765 00000F81 89D7                    	mov	di,dx			; record position of last arg in <list>
 12766 00000F83 C60400                  	mov	byte [si],0		; Zap the rparen
 12767                                  	; 15/02/2023
 12768                                  	;;;cmp	ax,[RPAREN+1]	
 12769                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12770                                  	;cmp	ax,nullparen
 12771 00000F86 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12772 00000F89 7401                    	je	short FOR_DO		; Yes, continue
 12773 00000F8B 47                      	inc	di			; No, inc position of last arg
 12774                                  FOR_DO:
 12775 00000F8C E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12776 00000F8F 72ED                    	jc	short FORERORJJ
 12777                                  	;and	ax,0DFDFh	
 12778 00000F91 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12779                                  	; 15/02/2023
 12780                                  	;;cmp	ax,[DO_WORD]
 12781                                  	;cmp	ax,do_word ; 4F44h
 12782 00000F94 3D444F                  	cmp	ax,'DO'	 ; 4F44h	
 12783 00000F97 75E5                    	jne	short FORERORJJ
 12784 00000F99 AC                      	lodsb
 12785 00000F9A 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12786 00000F9C 75E0                    	jnz	short FORERORJJ
 12787                                  		
 12788 00000F9E E87400                  	call	NEXTARG			; on to the beginning of <command>
 12789 00000FA1 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12790                                  
 12791 00000FA3 50                      	push	ax
 12792 00000FA4 53                      	push	bx
 12793 00000FA5 51                      	push	cx
 12794 00000FA6 52                      	push	dx			; preserve registers against disaster
 12795 00000FA7 57                      	push	di
 12796 00000FA8 56                      	push	si
 12797 00000FA9 55                      	push	bp
 12798 00000FAA E857F7                  	call	FREE_TPA		; need to make free memory, first
 12799 00000FAD E89500                  	call	FOROFF
 12800                                  	;mov	bx,264
 12801 00000FB0 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12802 00000FB3 E8ED24                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12803 00000FB6 9C                      	pushf
 12804 00000FB7 26A3[AD01]              	mov	[es:ForPtr],ax
 12805 00000FBB E856F7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12806 00000FBE 9D                      	popf
 12807 00000FBF 5D                      	pop	bp
 12808 00000FC0 5E                      	pop	si
 12809 00000FC1 5F                      	pop	di
 12810 00000FC2 5A                      	pop	dx
 12811 00000FC3 59                      	pop	cx
 12812 00000FC4 5B                      	pop	bx
 12813 00000FC5 58                      	pop	ax
 12814 00000FC6 723C                    	jc	short FOR_ALLOC_ERR
 12815                                  
 12816 00000FC8 06                      	push	es			; save resgroup seg...
 12817 00000FC9 26FF36[AD01]            	push	word [es:ForPtr]
 12818 00000FCE 07                      	pop	es
 12819                                  	;assume es:for_segment	
 12820 00000FCF 49                      	dec	cx			; forproc wants min pointing before
 12821 00000FD0 4F                      	dec	di			; first arg, max right at last one
 12822                                  	; 15/02/2023
 12823                                  	;mov	[547h],cx
 12824 00000FD1 26890E4705              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12825                                  	;mov	[549h],di
 12826 00000FD6 26893E4905              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12827                                  	;mov	[544h],dl
 12828 00000FDB 2688164405              	mov	[es:FOR_INFO.FOR_COM_START],dl
 12829                                  	;mov	word [545h],0FFFFh ; -1
 12830 00000FE0 26C7064505FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 12831                                  					; non-zero means FALSE
 12832 00000FE7 89E8                    	mov	ax,bp
 12833                                  	;mov	[64Bh],ah
 12834 00000FE9 2688264B06              	mov	[es:FOR_INFO.FOR_VAR],ah
 12835 00000FEE 07                      	pop	es
 12836                                  	;assume es:resgroup	
 12837 00000FEF 26FE06[AC01]            	inc	byte [es:ForFlag]
 12838 00000FF4 26833E[A601]FF          	cmp	word [es:SingleCom],-1
 12839 00000FFA 7507                    	jne	short FOR_RET
 12840 00000FFC 26C706[A601]00FF        	mov	word [es:SingleCom],0FF00h
 12841                                  FOR_RET:
 12842 00001003 C3                      	retn
 12843                                  
 12844                                  FOR_ALLOC_ERR:
 12845                                  	; 15/02/2023
 12846                                  	; MSDOS 3.3
 12847                                  	;mov	dx,INSFMEMMESPTR
 12848                                  	;jmp	CERROR
 12849                                  
 12850                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12851                                  	; MSDOS 6.0
 12852                                  	;mov	byte [msg_disp_class],1
 12853 00001004 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class	
 12854                                  					;AN000; set up extended error msg class
 12855                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr     
 12856 00001009 BA[557F]                	mov	dx,extend_buf_ptr
 12857                                  					;AC000; get extended message pointer
 12858                                  	;mov	word [extend_buf_ptr],8
 12859 0000100C C706[557F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 12860                                  					;AN000; get message number in control block
 12861 00001012 E94519                  	jmp	cerror
 12862                                  
 12863                                  
 12864                                  ; =============== S U B	R O U T	I N E =======================================
 12865                                  
 12866                                  NEXTARG:
 12867 00001015 42                      	inc	dx			; next argv[n]
 12868                                  	;cmp	dx,[ARG_ARGVCNT]
 12869 00001016 3B16[0F91]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 12870                                  					; make sure we don't run off end
 12871 0000101A 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 12872 0000101C 89D3                    	mov	bx,dx
 12873                                  	;mov	ax,ARG_ARGV
 12874                                  	;mov	ax,ARG+ARG_UNIT.argv
 12875 0000101E B8[4F8E]                	mov	ax,ARG
 12876 00001021 E85421                  	call	argv_calc		; convert array index to pointer
 12877 00001024 8B37                    	mov	si,[bx]			; load pointer to argstring
 12878                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12879 00001026 AD                      	lodsw				; and load first two chars
 12880 00001027 F8                      	clc
 12881 00001028 C3                      	retn
 12882                                  NEXTARG_ERR:
 12883 00001029 F9                      	stc
 12884 0000102A C3                      	retn
 12885                                  
 12886                                  ; ---------------------------------------------------------------------------
 12887                                  
 12888                                  FORNESTERR:
 12889 0000102B 1E                      	push	ds
 12890 0000102C 8E1E[C08A]              	mov	ds,[RESSEG]
 12891                                  	;ASSUME DS:RESGROUP
 12892 00001030 BA[B380]                	mov	dx,FORNESTMES_PTR
 12893 00001033 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12894 00001039 7506                    	jne	short NOFORP3
 12895 0000103B C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 12896                                  NOFORP3:
 12897 00001041 1F                      	pop	ds
 12898 00001042 E91519                  	jmp	cerror
 12899                                  
 12900                                  ; =============== S U B	R O U T	I N E =======================================
 12901                                  
 12902                                  ; General routine called to free the for segment. We also clear the forflag
 12903                                  ; too. Change no registers.
 12904                                  
 12905                                  FOROFF:
 12906 00001045 50                      	push	ax
 12907 00001046 06                      	push	es
 12908 00001047 2E8E06[C08A]            	mov	es,[cs:RESSEG]
 12909 0000104C 26A1[AD01]              	mov	ax,[es:ForPtr]
 12910 00001050 09C0                    	or	ax,ax
 12911 00001052 7408                    	jz	short FREEDONE
 12912 00001054 06                      	push	es
 12913 00001055 8EC0                    	mov	es,ax
 12914                                  	; 15/02/2023
 12915 00001057 B449                    	mov	ah,49h
 12916                                  	;mov	ah,DEALLOC ; 49h
 12917 00001059 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 12918                                  			; ES = segment address of area to be freed
 12919 0000105B 07                      	pop	es
 12920                                  FREEDONE:
 12921 0000105C 26C706[AD01]0000        	mov	word [es:ForPtr],0
 12922 00001063 26C606[AC01]00          	mov	byte [es:ForFlag],0
 12923 00001069 07                      	pop	es
 12924 0000106A 58                      	pop	ax
 12925 0000106B C3                      	retn
 12926                                  
 12927                                  ;============================================================================
 12928                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 12929                                  ;============================================================================
 12930                                  ; 09/10/2018 - Retro DOS v3.0
 12931                                  
 12932                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 12933                                  
 12934                                  ; ---------------------------------------------------------------------------
 12935                                  
 12936                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12937                                  
 12938                                  %if 0
 12939                                  
 12940                                  ; The DIR command displays the contents of a directory.
 12941                                  ;
 12942                                  ; ****************************************************************
 12943                                  ; *
 12944                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 12945                                  ; *
 12946                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 12947                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 12948                                  ; *		 If an error occurs issue and error message and
 12949                                  ; *		 transfer control to CERROR.
 12950                                  ; *
 12951                                  ; * INPUT:	 command line at offset 81H
 12952                                  ; *
 12953                                  ; * OUTPUT:	 none
 12954                                  ; *
 12955                                  ; ****************************************************************
 12956                                  
 12957                                  CATALOG:
 12958                                  	; MSDOS 3.3
 12959                                  
 12960                                  	;mov	ax,ARG_ARGV
 12961                                  	;mov	ax,ARG+ARG_UNIT.argv
 12962                                  	mov	ax,ARG
 12963                                  	mov	dx,0FFFFh
 12964                                  	xor	cx,cx
 12965                                  	xor	si,si
 12966                                  DIR1:
 12967                                  	;cmp	cx,[ARG_ARGVCNT]
 12968                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 12969                                  	jnb	short DIR6 ; No more arguments
 12970                                  	mov	bx,cx
 12971                                  	call	ARGV_CALC
 12972                                  	;or	si,[bx+7]
 12973                                  	or	si,[bx+ARGV_ELE.argsw_word]
 12974                                  	test	si,7FFCh  ; test si,~8003
 12975                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 12976                                  	;test	byte [bx+2],1
 12977                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 12978                                  	jz	short DIR3
 12979                                  	jmp	short DIR5
 12980                                  DIR2:
 12981                                  	mov	dx,BADPARMPTR
 12982                                  	jmp	CERROR
 12983                                  DIR3:
 12984                                  	or	cx,cx
 12985                                  	jnz	short DIR4	
 12986                                  	;cmp	word [bx+5],3
 12987                                  	cmp	word [bx+ARGV_ELE.arglen],3
 12988                                  	jz	short DIR5
 12989                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 12990                                  	add	word [bx],3
 12991                                  	;add	word [bx+9],3
 12992                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 12993                                  	;add	word [bx+3],3
 12994                                  	add	word [bx+ARGV_ELE.argstartel],3
 12995                                  	;sub	word [bx+5],3
 12996                                  	sub	word [bx+ARGV_ELE.arglen],3
 12997                                  DIR4:
 12998                                  	cmp	dx,0FFFFh
 12999                                  	jnz	short DIR2
 13000                                  	mov	dx,bx
 13001                                  DIR5:
 13002                                  	inc	cx
 13003                                  	jmp	short DIR1
 13004                                  DIR6:
 13005                                  	mov	[COMSW],si
 13006                                  	push	dx
 13007                                  	xor	al,al
 13008                                  	cmp	dx,0FFFFh
 13009                                  	jz	short DIR7
 13010                                  	mov	bx,dx
 13011                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13012                                  	mov	di,[bx]
 13013                                  	cmp	byte [di+1],':'
 13014                                  	jnz	short DIR7
 13015                                  	mov	al,[di]
 13016                                  	or	al,20h		; Lowercase drive name	
 13017                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13018                                  DIR7:
 13019                                  	;mov	[5CH],al
 13020                                  	mov	[FCB],al
 13021                                  	call	OKVOLARG
 13022                                  	mov	al,'?'		; *.* is default file spec.
 13023                                  	;mov	di,5Dh
 13024                                  	mov	di,FCB+1
 13025                                  	mov	cx,11
 13026                                  	rep stosb
 13027                                  
 13028                                  ; Begin by processing any switches that may have been specified.
 13029                                  ; BITS will contain any information about switches that was
 13030                                  ; found when the command line was parsed.
 13031                                  
 13032                                  	mov	ax,[COMSW]	; Get switches from command
 13033                                  	mov	[_BITS],ax	; initialize switches
 13034                                  	mov	word [COMSW],0	; initialize flags
 13035                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13036                                  	;test	al,1
 13037                                  	test	al,SWITCHW	; /W ?
 13038                                  	;mov	al,1
 13039                                  	mov	al,NORMPERLIN
 13040                                  	jz	short DIR8
 13041                                  	;mov	al,5
 13042                                  	mov	al,WIDEPERLIN
 13043                                  DIR8:
 13044                                  	mov	[LINLEN],al	; Set number of entries per line
 13045                                  	mov	[LINCNT],al
 13046                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13047                                  	mov	dx,DIRBUF
 13048                                  	mov	ah,Set_DMA ; 1Ah
 13049                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13050                                  			; DS:DX	-> disk	transfer buffer
 13051                                  	;mov	dl,[5Ch]
 13052                                  	mov	dl,[FCB]
 13053                                  	call	SAVUDIR
 13054                                  	pop	bx
 13055                                  	cmp	bx,0FFFFh
 13056                                  	jz	short DIR9
 13057                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13058                                  	mov	dx,[bx]
 13059                                  
 13060                                  ; The user may have specified a device. Search for the path and see if the
 13061                                  ; attributes indicate a device.
 13062                                  
 13063                                  	mov	ah,Find_First ; 4Eh
 13064                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13065                                  			; CX = search attributes
 13066                                  			; DS:DX	-> ASCIZ filespec
 13067                                  			; (drive,path, and wildcards allowed)
 13068                                  	jc	short DIR10
 13069                                  			; Check device atrribute..
 13070                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13071                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13072                                  	; 14/10/2018
 13073                                  	;test	byte [DIRBUF+21],40h
 13074                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13075                                  	jz	short DIR10	; no, go do normal operation
 13076                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13077                                  DIR9:
 13078                                  	jmp	short DOHEADER
 13079                                  DIR10:
 13080                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13081                                  	mov	dx,[bx]
 13082                                  	mov	ah,CHDir ; 3Bh
 13083                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13084                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13085                                  	jnc	short DOHEADER
 13086                                  	;mov	si,[bx+3]
 13087                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13088                                  	cmp	dx,si
 13089                                  	jz	short DIR_NO_DRIVE
 13090                                  	xor	cl,cl
 13091                                  	xchg	cl,[si]
 13092                                  	mov	ah,CHDir ; 3Bh
 13093                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13094                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13095                                  	xchg	cl,[si]
 13096                                  	jnc	short DIR_NO_DRIVE
 13097                                  	mov	al,[si-1]
 13098                                  	call	PATHCHRCMP
 13099                                  	jnz	short DIR11
 13100                                  	mov	al,[si-2]
 13101                                  	call	PATHCHRCMP
 13102                                  	jz	short DIR12
 13103                                  	xchg	cl,[si-1]
 13104                                  	mov	ah,CHDir ; 3Bh
 13105                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13106                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13107                                  	xchg	cl,[si-1]
 13108                                  	jnc	short DIR_NO_DRIVE
 13109                                  DIR11:
 13110                                  	mov	ch,':'
 13111                                  	cmp	ch,[si-1]
 13112                                  	jnz	short DIR12
 13113                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13114                                  	mov	cx,[bx]
 13115                                  	xchg	cx,si
 13116                                  	sub	cx,si
 13117                                  	cmp	cx,2
 13118                                  	jz	short DIR_NO_DRIVE
 13119                                  DIR12:
 13120                                  	mov	dx,BADCDPTR
 13121                                  	;test	byte [bx+2],4
 13122                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13123                                  	jnz	short DIRERROR
 13124                                  DIRNF:
 13125                                  	mov	dx,FNOTFOUNDPTR
 13126                                  DIRERROR:
 13127                                  	jmp	CERROR
 13128                                  DIR_NO_DRIVE:
 13129                                  	cmp	word [si],'..'
 13130                                  	jnz	short DOREALPARSE
 13131                                  	cmp	byte [si+2],0
 13132                                  	jnz	short DOREALPARSE
 13133                                  	inc	word [COMSW]
 13134                                  	jmp	short DOHEADER
 13135                                  DOREALPARSE:
 13136                                  	mov	di,FCB ; 5Ch	
 13137                                  	;mov	ax,290Eh
 13138                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13139                                  	int	21h	; DOS -	PARSE FILENAME
 13140                                  			; DS:SI	-> string to parse
 13141                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13142                                  			; AL = bit mask	to control parsing
 13143                                  	cmp	byte [si],0
 13144                                  	jz	short DOHEADER
 13145                                  	dec	word [COMSW]
 13146                                  DOHEADER:
 13147                                  		
 13148                                  ; Display the header
 13149                                  
 13150                                  	push	bx
 13151                                  	call	BUILD_DIR_STRING
 13152                                  	mov	dx,DIRBUF
 13153                                  	mov	[VOL_DIR],dx
 13154                                  	mov	dx,DIRHEADPTR
 13155                                  	call	PRINTF_CRLF
 13156                                  	pop	bx
 13157                                  	cmp	bx,0FFFFh
 13158                                  	jz	short DOSEARCH
 13159                                  
 13160                                  ; If there were chars left after parse or device, then invalid file name
 13161                                  
 13162                                  	cmp	word [COMSW],0
 13163                                  	jz	short DOSEARCH	; nothing left; good parse
 13164                                  	jl	short DIRNFFIX	; not .. => error file not found
 13165                                  	call	RESTUDIR
 13166                                  	mov	dx,BADCDPTR
 13167                                  	jmp	CERROR		; was .. => error directory not found
 13168                                  DIRNFFIX:
 13169                                  	call	RESTUDIR
 13170                                  	jmp	short DIRNF
 13171                                  
 13172                                  ; We are assured that everything is correct. Let's go and search. Use
 13173                                  ; attributes that will include finding directories. Perform the first search
 13174                                  ; and reset our directory afterward.
 13175                                  
 13176                                  DOSEARCH:
 13177                                  	;mov	byte [55h],0FFh
 13178                                  	mov	byte [FCB-7],0FFh
 13179                                  	;mov	byte [5Bh],10h
 13180                                  	mov	byte [FCB-1],10h
 13181                                  
 13182                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13183                                  ; the directory information as an extended FCB. We must bias all fetches into
 13184                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13185                                  
 13186                                  	mov	ah,Dir_Search_First ; 11h
 13187                                  	mov	dx,FCB-7 ; 55h
 13188                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13189                                  			; DS:DX	-> FCB
 13190                                  
 13191                                  ; Restore the user's directory. We preserve, though, the return from the
 13192                                  ; previous system call for later checking.
 13193                                  
 13194                                  FOUND_FIRST_FILE:
 13195                                  	push	ax		; save return state
 13196                                  	call	RESTUDIR	; restore user's dir	
 13197                                  	pop	ax		; get return state back
 13198                                  
 13199                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13200                                  ; no more.
 13201                                  
 13202                                  DIRSTART:
 13203                                  	inc	al		; 0FFh = file not found
 13204                                  	jnz	short DISPLAY	; Either an error or we are finished
 13205                                  	jmp	CHKCNT
 13206                                  DISPLAY:
 13207                                  	inc	word [FILECNT]	; Keep track of how many we find
 13208                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13209                                  	;call	SHONAME
 13210                                  	call	DISPLAYNAME
 13211                                  	;test	byte [_BITS],1
 13212                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13213                                  	jz	short DIRTEST	; If so, no size, date, or time
 13214                                  	jmp	NEXENT
 13215                                  DIRTEST:
 13216                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13217                                  	; 14/10/2018
 13218                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13219                                  	;test	byte [DIRBUF+19],10h
 13220                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13221                                  	jz	short FILEENT
 13222                                  	mov	dx,DMESPTR
 13223                                  	call	STD_PRINTF
 13224                                  	jmp	short NOFSIZ
 13225                                  FILEENT:
 13226                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13227                                  	;mov	dx,[DIRBUF+36]
 13228                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13229                                  	mov	[FILESIZE_L],dx
 13230                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13231                                  	;mov	dx,[DIRBUF+38]
 13232                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13233                                  	mov	[FILESIZE_H],dx
 13234                                  	mov	dx,FSIZEMESPTR
 13235                                  	call	STD_PRINTF	; Print size of file
 13236                                  NOFSIZ:
 13237                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13238                                  	;mov	ax,[DIRBUF+32]
 13239                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13240                                  	or	ax,ax
 13241                                  	jz	short NEXENT	; Skip if no date
 13242                                  	mov	di,CHARBUF
 13243                                  	push	ax
 13244                                  	mov	ax,'  '
 13245                                  	stosw
 13246                                  	pop	ax
 13247                                  	mov	bx,ax
 13248                                  	and	ax,1Fh		; Get day
 13249                                  	mov	dl,al
 13250                                  	mov	ax,bx
 13251                                  	mov	cl,5
 13252                                  	shr	ax,cl		; Align month
 13253                                  	and	al,0Fh		; Get month
 13254                                  	mov	dh,al
 13255                                  	mov	cl,bh
 13256                                  	shr	cl,1		; Align year
 13257                                  	xor	ch,ch
 13258                                  	add	cx,80		; Relative 1980
 13259                                  	cmp	cl,100
 13260                                  	jb	short MILLENIUM
 13261                                  	sub	cl,100
 13262                                  MILLENIUM:
 13263                                  	call	DATE_CXDX
 13264                                  	;mov	cx,[DIRBUF_FTIME]
 13265                                  	;mov	cx,[DIRBUF+30]
 13266                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13267                                  	jcxz	PRBUF		; Time field present?
 13268                                  	mov	ax,2020h
 13269                                  	stosw
 13270                                  	shr	cx,1
 13271                                  	shr	cx,1
 13272                                  	shr	cx,1
 13273                                  	shr	cl,1
 13274                                  	shr	cl,1		; Hours in CH, minutes in CL
 13275                                  	mov	bl,[TIME_24]
 13276                                  	or	bl,80h		; Tell P_TIME called from DIR
 13277                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13278                                  PRBUF:
 13279                                  	xor	ax,ax
 13280                                  	stosb
 13281                                  	mov	dx,CHARBUF
 13282                                  	mov	[STRING_PTR_2],dx
 13283                                  	mov	dx,STRINGBUF2PTR
 13284                                  	call	STD_PRINTF
 13285                                  NEXENT:
 13286                                  	dec	byte [LINCNT]
 13287                                  	jnz	short SAMLIN
 13288                                  NEXLIN:
 13289                                  	mov	al,[LINLEN]
 13290                                  	mov	[LINCNT],al
 13291                                  	call	CRLF2
 13292                                  	dec	byte [LINPERPAG]
 13293                                  	jnz	short SCROLL
 13294                                  	;test	byte [_BITS],2
 13295                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13296                                  	jz	short SCROLL	; If not, just continue
 13297                                  	mov	byte [LINPERPAG],23
 13298                                  	call	PAUSE
 13299                                  	jmp	short SCROLL
 13300                                  SAMLIN:
 13301                                  	mov	dx,TABPTR	; Output a tab
 13302                                  	call	STD_PRINTF
 13303                                  SCROLL:
 13304                                  	mov	ah,Dir_Search_Next ; 12h
 13305                                  	;mov	dx,55h
 13306                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13307                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13308                                  			; DS:DX	-> FCB
 13309                                  			; Return: AL = status
 13310                                  	jmp	DIRSTART
 13311                                  CHKCNT:
 13312                                  	test	word [FILECNT],0FFFFh ; -1
 13313                                  	jnz	short TRAILER
 13314                                  	jmp	DIRNF
 13315                                  TRAILER:
 13316                                  	mov	al,[LINLEN]
 13317                                  	cmp	al,[LINCNT]
 13318                                  	jz	short MMESSAGE
 13319                                  	call	CRLF2
 13320                                  MMESSAGE:
 13321                                  	mov	dx,DIRMESPTR
 13322                                  	mov	si,[FILECNT]
 13323                                  	mov	[DIR_NUM],si
 13324                                  	call	STD_PRINTF
 13325                                  DTFREE:
 13326                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13327                                  	;mov	dl,[5Ch]
 13328                                  	mov	dl,[FCB]
 13329                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13330                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13331                                  	cmp	ax,-1
 13332                                  	jnz	short DTFREE1
 13333                                  DTRET:
 13334                                  	retn
 13335                                  DTFREE1:
 13336                                  	mul	cx
 13337                                  	mul	bx
 13338                                  	mov	[BYTES_FREE],ax
 13339                                  	mov	[BYTES_FREE+2],dx
 13340                                  	mov	dx,BYTEMESPTR
 13341                                  	jmp	STD_PRINTF
 13342                                  
 13343                                  ; =============== S U B	R O U T	I N E =======================================
 13344                                  
 13345                                  SHONAME:
 13346                                  DISPLAYNAME:
 13347                                  	; MSDOS 3.3
 13348                                  	mov	di,CHARBUF
 13349                                  	mov	cx,8
 13350                                  	rep	movsb
 13351                                  	mov	al,' '
 13352                                  	stosb
 13353                                  	mov	cx,3
 13354                                  	rep	movsb
 13355                                  	xor	ax,ax
 13356                                  	stosb
 13357                                  	push	dx
 13358                                  	mov	dx,CHARBUF
 13359                                  	mov	[STRING_PTR_2],dx
 13360                                  	mov	dx,STRINGBUF2PTR
 13361                                  	call	STD_PRINTF
 13362                                  	pop	dx
 13363                                  	retn
 13364                                  
 13365                                  %endif
 13366                                  
 13367                                  ;============================================================================
 13368                                  ; DIR.ASM, MSDOS 6.0, 1991
 13369                                  ;============================================================================
 13370                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13371                                  
 13372                                  	; MSDOS 6.0
 13373                                  %if 0
 13374                                  
 13375                                  ;***	DIR.ASM - DIR internal command
 13376                                  
 13377                                  comment	% =================================================================
 13378                                  
 13379                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13380                                  "PART4 COMMAND Transient routines".
 13381                                  
 13382                                  From residual documentation, I surmise that TCMD.ASM originally
 13383                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13384                                  VER.  The file seems to have been successively split:
 13385                                  
 13386                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13387                                  
 13388                                  TCMD1A.ASM contained only the DIR command.
 13389                                  
 13390                                  Usage:
 13391                                  ------
 13392                                  
 13393                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13394                                  
 13395                                  DIR /?
 13396                                  
 13397                                  
 13398                                  <filespec> may include any or none of:  drive; directory path;
 13399                                             wildcarded filename.  If drive or directory path are
 13400                                  	   omitted, the current defaults are used.  If the
 13401                                  	   file name or extension is omitted, wildcards are
 13402                                  	   assumed.
 13403                                  
 13404                                  /w	Wide listing format.  Files are displayed in compressed
 13405                                  	'name.ext' format.  Subdirectory files are enclosed in
 13406                                  	brackets, '[dirname]'.
 13407                                  
 13408                                  /p	Paged, or prompted listing.  A screenful is displayed
 13409                                  	at a time.  The name of the directory being listed appears
 13410                                  	at the top of each page.
 13411                                  
 13412                                  	Bugbug:  pages nead to be uniform length..?
 13413                                  
 13414                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13415                                  	listed in compressed 'name.ext' format, one per line,
 13416                                  	without additional information.  Good for making batch
 13417                                  	files or for piping.  When used with /s, complete
 13418                                  	pathnames are listed.
 13419                                  
 13420                                  /s	Descend subdirectory tree.  Performs command on current
 13421                                  	or specified directory, then for each subdirectory below
 13422                                  	that directory.  Directory header and footer is displayed
 13423                                  	for each directory where matching files are found, unless
 13424                                  	used with /b.  /b suppresses headers and footers.
 13425                                  
 13426                                  	Tree is explored depth first, alphabetically within the
 13427                                  	same level.
 13428                                  
 13429                                  	Bugbug:  hidden directories aren't searched.
 13430                                  
 13431                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13432                                  
 13433                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13434                                  	compressed volume.
 13435                                  
 13436                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13437                                  	extension).  A sort order may be specified after /o.  Any of
 13438                                  	the following characters may be used: nedsgc (name, extension,
 13439                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13440                                  	a '-' before any letter causes a downward sort on that field.
 13441                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13442                                  	then within each extension sort by date and time in reverse
 13443                                  	chronological order.
 13444                                  
 13445                                  /a	Attribute selection.  Without /a, hidden and system files
 13446                                  	are suppressed from the listing.  With /a alone, all files
 13447                                  	are listed.  An attribute list may follow /a, consisting of
 13448                                  	any of the following characters:  hsdar (hidden, system,
 13449                                  	directory, archive, read-only).  A '-' before any letter
 13450                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13451                                  	are marked read-only and are not directory files.  Note
 13452                                  	that hidden or system files may be included in the listing.
 13453                                  	They are suppressed without /a but are treated like any other
 13454                                  	attribute with /a.
 13455                                  
 13456                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13457                                  
 13458                                  /h has been removed.					;M008
 13459                                  
 13460                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13461                                  	DIR command line.  Any command line options may be specified
 13462                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13463                                  	A filespec may be specified in DIRCMD and will be used unless
 13464                                  	a filespec is specified on the command line.  Any switch
 13465                                  	specified in DIRCMD may be overridden on the command line.
 13466                                  	If the original DIR default action is desired for a particular
 13467                                  	switch, the switch letter may be preceded by a '-' on the
 13468                                  	command line.  E.g.,
 13469                                  
 13470                                  	  /-w	use long listing format
 13471                                  	  /-p	don't page the listing
 13472                                  	  /-b	don't use bare format
 13473                                  	  /-s	don't descend subdirectory tree
 13474                                  	  /-o	display files in disk order
 13475                                  	  /-a	suppress hidden and system files
 13476                                  
 13477                                  Notes:
 13478                                  ------
 13479                                  
 13480                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13481                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13482                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13483                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13484                                  a flag byte which is made zero when the entry is loaded, and made one
 13485                                  when the entry is used.
 13486                                  
 13487                                  Revision History
 13488                                  ================
 13489                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13490                                  				in the absence of ANSI.SYS
 13491                                  
 13492                                  M007	sa	8/1/90		Allow /p/b combination
 13493                                  
 13494                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13495                                  				to internally handle /? message.
 13496                                  
 13497                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13498                                  
 13499                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13500                                  				first FCB with the drive number when the drive
 13501                                  				letter in the command line is preceded by a
 13502                                  				switch.  Now dir manually loads the drive
 13503                                  				number after parsing.
 13504                                  
 13505                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13506                                  				from the ROM BIOS.
 13507                                  
 13508                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13509                                  				a subdirectory having len(pathname)>MAXPATH.
 13510                                  				Just skip over that subdirectory.
 13511                                  
 13512                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13513                                  				byte value, rather than collating table.
 13514                                  				This to match MS-DOS Shell's sort order.
 13515                                  
 13516                                  ========================================================================= %
 13517                                  
 13518                                  %endif
 13519                                  
 13520                                  ; 16/02/2023
 13521                                  
 13522                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13523                                  
 13524                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13525                                  ;
 13526                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13527                                  ;		(order is hard-coded; see OnOffSw)
 13528                                  ;		Inmem is set when entries are loaded in memory.
 13529                                  
 13530                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13531                                  mask.wide  equ 1
 13532                                  mask.pagd  equ 2
 13533                                  mask.subd  equ 4
 13534                                  mask.bare  equ 8
 13535                                  mask.lcase equ 16
 13536                                  mask.inmem equ 32
 13537                                  ;
 13538                                  mask.dev    equ 1
 13539                                  mask.baddir equ 2	
 13540                                  
 13541                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13542                                  
 13543                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13544                                  
 13545                                  ;ResultBuffer	struc		; structure of parse result buffer
 13546                                  ;ValueType	db	?
 13547                                  ;ValueTag	db	?
 13548                                  ;SynPtr		dw	?
 13549                                  ;ValuePtr	dd	?
 13550                                  ;ResultBuffer	ends
 13551                                  
 13552                                  ;ErrorRec	record	baddir:1,dev:1
 13553                                  ;
 13554                                  ;		Error bits are:
 13555                                  ;		  Invalid directory format
 13556                                  ;		  File is device
 13557                                  
 13558                                  ;EntryStruc	struc			; our private directory entry structure
 13559                                  ;used		db	?		; =0 until entry used, then =1
 13560                                  ;filename	db	8 dup (?)	; filename
 13561                                  ;fileext	db	3 dup (?)	; extension
 13562                                  ;fileattr	db	?		; file attributes
 13563                                  ;filetime	dw	?		; file time
 13564                                  ;filedate	dw	?		; file date
 13565                                  ;filesize	dd	?		; file size
 13566                                  ;EntryStruc	ends
 13567                                  
 13568                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13569                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13570                                  ;	push	ax
 13571                                  ;	endm
 13572                                  
 13573                                  ;	public	Catalog		; our entry point
 13574                                  ;
 13575                                  ;	break	<DIR (Catalog) principal routines>
 13576                                  ;
 13577                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13578                                  ; ---------------------------------------------------------------------------
 13579                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13580                                  
 13581                                  ;----------------------------------------------------------------------------
 13582                                  ;----------------------------------------------------------------------------
 13583                                  
 13584                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13585                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13586                                  
 13587                                  ;***	Catalog - DIR command main routine
 13588                                  ;
 13589                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13590                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13591                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13592                                  ;		Tpa = TPA buffer seg addr
 13593                                  ;		BytCnt = # bytes in TPA buffer
 13594                                  ;
 13595                                  ;	EXIT	nothing
 13596                                  ;
 13597                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13598                                  ;
 13599                                  ;	ERROR EXITS
 13600                                  ;
 13601                                  ;	  Errors are handled by setting up error message pointers
 13602                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13603                                  ;	   the environment variable, however, are handled by printing
 13604                                  ;	   an error message and continuing.
 13605                                  ;
 13606                                  ;	EFFECTS
 13607                                  ;
 13608                                  ;	  Directory listing is displayed (on standard output).
 13609                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13610                                  ;	   restore APPEND state.
 13611                                  ;	  Working directory may be changed. The user's default
 13612                                  ;	   directory is saved and flagged for restoration by RestUDir
 13613                                  ;	   during COMMAND cycle.
 13614                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13615                                  ;
 13616                                  ;	NOTES
 13617                                  ;
 13618                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13619                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13620                                  
 13621                                  	; 16/02/2023
 13622                                  CATALOG:
 13623 0000106C E8A500                  	call	SetDefaults
 13624 0000106F E8C900                  	call	ParseEnvironment
 13625 00001072 E8E100                  	call	ParseCmdLine
 13626 00001075 7303                    	jnc	short catalog1	; no parse error
 13627 00001077 E99700                  	jmp	catErr		; error msg is set up
 13628                                  catalog1:
 13629 0000107A E80A01                  	call	SetOptions
 13630 0000107D E8E000                  	call	SetCollatingTable
 13631                                  
 13632                                  ;	Drive # to operate on has already been placed in FCB by
 13633                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13634                                  
 13635                                  	;;;test	Bits,mask bare
 13636                                  	;;test 	word [_Bits],8
 13637                                  	;test	byte [_Bits],8
 13638 00001080 F606[1B8C]08            	test	byte [_Bits],mask.bare
 13639 00001085 750A                    	jnz	short catalog2	; don't display volume info for /b
 13640                                  	;invoke	OkVolArg	; find & display volume info
 13641 00001087 E8EA0B                  	call	OkVolArg
 13642                                  	;sub	byte [LeftOnpage],2
 13643 0000108A 832E[EA8A]02            	sub	word [LeftOnPage],2
 13644                                  				; record display lines used by volume info
 13645 0000108F EB15                    	jmp	short catCrunch
 13646                                  
 13647                                  ;	OkVolArg side effects:
 13648                                  ;	APPEND is disabled;
 13649                                  ;	DTA established at DirBuf;
 13650                                  ;	Filename fields in FCB are wildcarded.
 13651                                  
 13652                                  catalog2:
 13653                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13654                                  
 13655                                  	;invoke	DisAppend	; disable APPEND
 13656 00001091 E8AD0B                  	call	DisAppend
 13657                                  
 13658                                  	;mov	dx,offset TRANGROUP:DirBuf
 13659 00001094 BA[C98B]                	mov	dx,DIRBUF
 13660 00001097 B41A                    	mov	ah,1Ah
 13661                                  	;mov	ah,Set_DMA
 13662 00001099 CD21                    	int	21h		; set DTA
 13663                                  
 13664 0000109B BF5C00                  	mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13665 0000109E 47                      	inc	di		; ES:DI = ptr to filename field of FCB
 13666 0000109F B03F                    	mov	al,'?'		; AL = wildcard character
 13667 000010A1 B90B00                  	mov	cx,11
 13668 000010A4 F3AA                    	rep	stosb		; wildcard filename field
 13669                                  
 13670                                  catCrunch:
 13671 000010A6 E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13672 000010A9 7230                    	jc	short catRecErr	; handle recorded or extended error
 13673                                  
 13674                                  ;	User's directory has been saved, we've changed to specified directory.
 13675                                  ;	ComSw = error bits for later use
 13676                                  ;	FCB contains parsed filename
 13677                                  
 13678                                  	;cmp	byte [COMSW],0
 13679 000010AB 833E[D78A]00            	cmp	word [COMSW],0
 13680 000010B0 7529                    	jne	short catRecErr	; handle recorded error
 13681                                  
 13682 000010B2 E88701                  	call	InstallCtrlC	; install control-C handler
 13683 000010B5 E8D008                  	call	ZeroTotals	; zero grand totals
 13684 000010B8 E84304                  	call	ListDir		; list main directory
 13685 000010BB 7244                    	jc	short catExtErr
 13686                                  
 13687                                  	;;;test	Bits,mask subd
 13688                                  	;;test	word [_Bits],4
 13689                                  	;test	byte [_Bits],4
 13690 000010BD F606[1B8C]04            	test	byte [_Bits],mask.subd
 13691 000010C2 7405                    	jz	short catalog3	; subdirectories option not set
 13692 000010C4 E88D01                  	call	ListSubds	; list subdirectories
 13693 000010C7 7238                    	jc	short catExtErr
 13694                                  catalog3:
 13695                                  ;	Check if any files were found.
 13696                                  
 13697                                  	;;;test	Bits,mask bare
 13698                                  	;;test	word [_Bits],8
 13699                                  	;test	byte [_Bits],8
 13700 000010C9 F606[1B8C]08            	test	byte [_Bits],mask.bare
 13701 000010CE 750A                    	jnz	short catRet	; don't bother for bare format
 13702                                  
 13703 000010D0 A1[F28A]                	mov	ax,[FileCntTotal]
 13704 000010D3 09C0                    	or	ax,ax
 13705 000010D5 7417                    	jz	short catNoFiles ; no files found
 13706                                  
 13707 000010D7 E8A702                  	call	DisplayTotals	; display trailing grand totals
 13708                                  	;jmp	short catRet	; all done
 13709                                  	; 25/04/2023
 13710                                  catRet:
 13711 000010DA C3                      	retn
 13712                                  
 13713                                  catRecErr:
 13714                                  
 13715                                  ;	ComSw may have error bit set. If not, do extended error.
 13716                                  
 13717                                  	;;;test	ComSw,mask dev
 13718                                  	;;test	word [COMSW],1
 13719                                  	;test	byte [COMSW],1
 13720 000010DB F606[D78A]01            	test	byte [COMSW],mask.dev
 13721 000010E0 750C                    	jnz	short catNoFiles 
 13722                                  				; filename is device, respond 'file not found'
 13723                                  	;;test	ComSw,mask baddir
 13724                                  	;;test	word [COMSW],2
 13725                                  	;test	byte [COMSW],2
 13726 000010E2 F606[D78A]02            	test	byte [COMSW],mask.baddir
 13727 000010E7 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13728                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13729                                  				; invalid directory
 13730 000010E9 BA[9080]                	mov	dx,badcd_ptr
 13731 000010EC EB23                    	jmp	short catErr
 13732                                  
 13733                                  catNoFiles:
 13734                                  
 13735                                  ;	Display header and force 'file not found' message.
 13736                                  
 13737 000010EE E81207                  	call	DisplayHeader
 13738 000010F1 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13739 000010F4 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13740 000010F9 BA[557F]                	mov	dx,extend_buf_ptr
 13741 000010FC A3[557F]                	mov	[extend_buf_ptr],ax
 13742 000010FF EB10                    	jmp	short catErr
 13743                                  
 13744                                  catExtErr:
 13745                                  
 13746                                  ;	DOS has returned an error status. Get the extended error#, and
 13747                                  ;	set up an error message, changing 'No more files' error 
 13748                                  ;	to 'File not found' error.
 13749                                  
 13750 00001101 E8EE0B                  	call	Set_Ext_Error_Msg
 13751 00001104 833E[557F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13752 00001109 7506                    	jne	short catalog4  ; catErr
 13753 0000110B C706[557F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13754                                  catalog4:
 13755                                  
 13756                                  ;	Error exit. Error message information has been set up
 13757                                  ;	for Std_EPrintf.
 13758                                  
 13759                                  catErr:
 13760 00001111 E94618                  	jmp	cerror		; go to COMMAND error recycle point
 13761                                  
 13762                                  	; 25/04/2023
 13763                                  ;catRet:
 13764                                  	;retn
 13765                                  
 13766                                  ; ---------------------------------------------------------------------------
 13767                                  
 13768                                  ;***	SetDefaults - set default pathname, options
 13769                                  ;
 13770                                  ;	ENTRY	DS = TRANGROUP seg addr
 13771                                  ;
 13772                                  ;	EXIT	nothing
 13773                                  ;
 13774                                  ;	USED	AX,DI
 13775                                  ;
 13776                                  ;	EFFECTS
 13777                                  ;	  SrcBuf = '*',EOL - default pathname
 13778                                  ;	  PathPos = ptr to pathname
 13779                                  ;	  PathCnt = length of pathname
 13780                                  
 13781                                  	; 16/02/2023
 13782                                  SetDefaults:
 13783 00001114 BF[2F8D]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13784 00001117 893E[1F8C]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13785                                  	;mov	al,STAR
 13786 0000111B B02A                    	mov	al,'*'
 13787 0000111D AA                      	stosb
 13788                                  	;mov	al,END_OF_LINE_IN
 13789 0000111E B00D                    	mov	al,0Dh ; cr
 13790 00001120 AA                      	stosb				; SrcBuf = '*',0Dh
 13791 00001121 C706[1D8C]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13792                                  
 13793 00001127 31C0                    	xor	ax,ax			; AX = 0
 13794 00001129 A3[D78A]                	mov	[COMSW],ax		; = no error
 13795 0000112C A3[1B8C]                	mov	[_Bits],ax		; = options off
 13796 0000112F A2[CC8C]                	mov	[DestBuf],al		; = no sort
 13797 00001132 C606[238C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13798 00001137 A2[248C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13799                                  peRet:	; 25/04/2023
 13800 0000113A C3                      	retn
 13801                                  
 13802                                  ; ---------------------------------------------------------------------------
 13803                                  
 13804                                  ;***	ParseEnvironment - find and parse our environment variable
 13805                                  ;
 13806                                  ;	Find our environment variable and parse it. If a parse
 13807                                  ;	error occurs, issue an error message. The parse results
 13808                                  ;	up to the error will still have effect. Always leave
 13809                                  ;	the option variables in a useable state.
 13810                                  ;
 13811                                  ;	ENTRY	DS = TRANGROUP seg addr
 13812                                  ;
 13813                                  ;	EXIT	nothing
 13814                                  ;
 13815                                  ;	USED	AX,BX,CX,DX,SI,DI
 13816                                  ;
 13817                                  ;	EFFECTS
 13818                                  ;
 13819                                  ;	  Bits may contain new option settings.
 13820                                  ;	  DestBuf may contain new series of sort codes.
 13821                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13822                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13823                                  ;	  PathPos, PathCnt updated for new pathname.
 13824                                  ;
 13825                                  ;	  If a parse error occurred, an error message will be issued.
 13826                                  
 13827                                  	; 16/02/2023
 13828                                  ParseEnvironment:
 13829 0000113B E87603                  	call	GetEnvValue		; get environment variable value
 13830 0000113E 72FA                    	jc	short peRet		; name not found in environment
 13831                                  
 13832                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 13833                                  
 13834 00001140 E8BA04                  	call	Parse_Line		; parse environment value
 13835 00001143 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13836                                  	;cmp	ax,END_OF_LINE
 13837 00001146 74F2                    	je	short peRet		; successful completion
 13838                                  
 13839                                  ;	Some kind of parse error occurred.
 13840                                  ;	We're set up for a Std_EPrintf call.
 13841                                  
 13842 00001148 E8D03C                  	call	std_eprintf		; display the parse error
 13843                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 13844                                  					; restore default msg class
 13845 0000114B C606[537F]FF            	mov	byte [msg_disp_class],0FFh ; -1
 13846                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 13847 00001150 BA[9481]                	mov	dx,errparsenv_ptr
 13848                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 13849                                  	;call	Printf_Crlf
 13850                                  	; 25/04/2023
 13851                                  	;retn
 13852 00001153 E9BF3C                  	jmp	Printf_Crlf
 13853                                  					;M008;Internal handling of /? removed
 13854                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 13855                                  	; 25/04/2023
 13856                                  ;peRet:
 13857                                  	;retn
 13858                                  
 13859                                  ; ---------------------------------------------------------------------------
 13860                                  
 13861                                  ;***	ParseCmdLine - parse and record command line parameters
 13862                                  ;
 13863                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 13864                                  ;		DS, ES, CS = TRANGROUP seg addr
 13865                                  ;
 13866                                  ;	EXIT	CY = set if parse error occurred
 13867                                  ;
 13868                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 13869                                  ;		AX = system parser error code
 13870                                  ;		DX = ptr to message block
 13871                                  ;
 13872                                  ;	USED	AX,BX,CX,DX,SI,DI
 13873                                  ;
 13874                                  ;	EFFECTS
 13875                                  ;
 13876                                  ;	  Bits may contain new option settings.
 13877                                  ;	  DestBuf may contain new series of sort codes.
 13878                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13879                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13880                                  ;	  PathPos, PathCnt updated for new pathname.
 13881                                  ;
 13882                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 13883                                  ;	  Msg_Disp_Class = parse error class
 13884                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 13885                                  ;	  Message block (see DX) is set up for parse error message
 13886                                  
 13887                                  	; 16/02/2023
 13888                                  ParseCmdLine:
 13889 00001156 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 13890 00001159 E8A104                  	call	Parse_Line		; parse cmd line tail
 13891 0000115C 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13892                                  	;;cmp	ax,END_OF_LINE
 13893                                  	; 25/04/2023
 13894                                  	;je	short pcOk		; parse completed successfully
 13895                                  
 13896                                  ;	A parse error occurred. We're all set up for message output.
 13897                                  
 13898                                  	; 25/04/2023
 13899                                  	; cf = 1 (ax < 0FFFFh)
 13900                                  	;stc		   		; return failure
 13901                                  	;jmp	short pcRet
 13902                                  	; 25/04/2023
 13903                                  	;retn
 13904                                  pcOk:
 13905                                  	; 25/04/2023
 13906                                  	;cf = 0 (ax = 0FFFFh)
 13907                                  	;clc				; return success
 13908                                  pcRet:
 13909 0000115F C3                      	retn
 13910                                  
 13911                                  ; ---------------------------------------------------------------------------
 13912                                  
 13913                                  ;***	SetCollatingTable - set up character collating table for sorting
 13914                                  ;
 13915                                  ;	If country is other than USA, try to get a collating table
 13916                                  ;	for character sorting. For USA, use straight byte values.
 13917                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 13918                                  ;	by straight byte values in the USA for better performance.
 13919                                  ;
 13920                                  ;	ENTRY	ES = TRANGROUP seg addr
 13921                                  ;
 13922                                  ;	EXIT	nothing
 13923                                  ;
 13924                                  ;	USED	AX,BX,CX,DX,DI
 13925                                  ;
 13926                                  ;	EFFECTS
 13927                                  ;
 13928                                  ;	  If collating table is set -
 13929                                  ;	    CountryPtrId = 6.
 13930                                  ;	    CountryPtr points to collating table.
 13931                                  ;
 13932                                  ;	  Otherwise -
 13933                                  ;	    CountryPtrId = 0.
 13934                                  
 13935                                  SetCollatingTable:
 13936                                  
 13937                                  ;	Begin modification M028
 13938                                  
 13939                                  	;mov	dx,offset TRANGROUP:InternatVars
 13940                                  	;			; DS:DX = ptr to international info buffer
 13941 00001160 BA[9E95]                	mov	dx,INTERNATVARS
 13942 00001163 B80038                  	mov	ax,3800h
 13943                                  	;mov	ax,INTERNATIONAL << 8
 13944                                  	;;mov	ax,INTERNATIONAL shl 8
 13945                                  				; AX = 'Get current country info'
 13946 00001166 CD21                    	int	21h		; call DOS
 13947 00001168 7217                    	jc	short scNoTable	; error - so don't collate
 13948                                  
 13949                                  ;	BX = country code
 13950                                  
 13951 0000116A 83FB01                  	cmp	bx,1
 13952 0000116D 7412                    	je	short scNoTable	; we're in USA, don't collate
 13953                                  
 13954                                  ;	End modification M028
 13955                                  
 13956                                  ;*	Country code is other than USA. Try to get a collating table.
 13957                                  
 13958 0000116F B80665                  	mov	ax,6506h
 13959                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 13960                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 13961                                  				; AH = 'Get Extended Country Info'
 13962                                  				; AL = 'Get Pointer to Collating Table'
 13963 00001172 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 13964 00001175 B90500                  	mov	cx,5		; CX = length of info buffer
 13965 00001178 89DA                    	mov	dx,bx		; DX = country ID = default
 13966                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 13967 0000117A BF[BE95]                	mov	di,CountryPtrInfo
 13968                                  				; ES:DI = ptr to info buffer
 13969 0000117D CD21                    	int	21h		; call DOS
 13970 0000117F 7305                    	jnc	short scRet	; success
 13971                                  
 13972                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 13973                                  
 13974                                  scNoTable:			;M028
 13975 00001181 C606[BE95]00            	mov	byte [CountryPtrId],0
 13976                                  scRet:
 13977 00001186 C3                      	retn
 13978                                  
 13979                                  ; ---------------------------------------------------------------------------
 13980                                  
 13981                                  ;***	SetOptions - check and set options
 13982                                  ;
 13983                                  ;	ENTRY	nothing
 13984                                  ;
 13985                                  ;	EXIT	nothing
 13986                                  ;
 13987                                  ;	USED	AX,BX,CX,DX
 13988                                  ;
 13989                                  ;	EFFECTS
 13990                                  ;
 13991                                  ;	  Bits may contain modified option settings.
 13992                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 13993                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 13994                                  ;	  PerLine is set according to /w presence.
 13995                                  
 13996                                  	; 16/02/2023
 13997                                  SetOptions:
 13998                                  
 13999                                  ;	If bare listing requested, cancel wide listings.
 14000                                  
 14001                                  	;;;test	Bits,mask bare
 14002                                  	;;test	word [_Bits],8
 14003                                  	;test	byte [_Bits],8
 14004 00001187 F606[1B8C]08            	test	byte [_Bits],mask.bare
 14005 0000118C 7405                    	jz	short setopts1
 14006                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14007                                  	;;and	word [_Bits],0FFFEh
 14008                                  	;;and	byte [_Bits],0FEh
 14009 0000118E 8026[1B8C]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 14010                                  setopts1:
 14011                                  ;	Set # lines per display page.
 14012                                  
 14013                                  ;M01  Obtain screen height from ROM BIOS data area
 14014                                  ;
 14015                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14016                                  
 14017 00001193 1E                      	push	ds
 14018                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14019 00001194 B84000                  	mov	ax,40h
 14020 00001197 8ED8                    	mov	ds,ax			;
 14021                                  	;Assume	DS:ROMBIOS_DATA
 14022                                  
 14023                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14024 00001199 A08400                  	mov	al,[84h]
 14025 0000119C 1F                      	pop	ds			;
 14026                                  	;Assume	DS:Trangroup
 14027                                  
 14028 0000119D 08C0                    	or	al,al			; If zero specified
 14029 0000119F 7502                    	jnz	short setopts2		;
 14030                                  
 14031                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14032 000011A1 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14033                                  setopts2:
 14034 000011A3 30E4                    	xor	ah,ah
 14035                                  setopts3:
 14036 000011A5 FEC0                    	inc	al			; height + 1 ;M018
 14037                                  
 14038 000011A7 A3[168E]                	mov	[LinPerPag],ax		; set the rows now
 14039                                  
 14040                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14041                                  
 14042                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE 
 14043                                  					; IOCTL for handles
 14044 000011AA B80C44                  	mov	ax,440Ch
 14045                                  	;mov	bx,STDOUT		; handle #
 14046 000011AD BB0100                  	mov	bx,1
 14047                                  	;mov	ch,IOC_SC		; screen
 14048 000011B0 B503                    	mov	ch,3
 14049                                  	;mov	cl,get_generic		; get display info
 14050 000011B2 B17F                    	mov	cl,7Fh
 14051 000011B4 BA[068E]                	mov	dx,Display_Ioctl	; info block
 14052 000011B7 CD21                    	int	21h			; call DOS
 14053                                  
 14054 000011B9 A1[168E]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14055 000011BC A3[EA8A]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14056                                  
 14057                                  ;	Set # entries per line.
 14058                                  
 14059                                  	;mov	byte [PerLine],NORMPERLIN
 14060                                  					; # entries per line without /w
 14061 000011BF C606[E78A]01            	mov	byte [PerLine],1
 14062                                  	;;;test	Bits,mask wide
 14063                                  	;;test	word [_Bits],1
 14064                                  	;test	byte [_Bits],1
 14065 000011C4 F606[1B8C]01            	test	byte [_Bits],mask.wide
 14066 000011C9 7405                    	jz	short setopts4
 14067                                  	;mov	byte [PerLine],WIDEPERLIN
 14068                                  					; # entries per line with /w
 14069 000011CB C606[E78A]05            	mov	byte [PerLine],5
 14070                                  setopts4:
 14071                                  				;M011;start;The following code checks if a drive
 14072                                  				;letter has been parsed into SrcBuf, and if
 14073                                  				;so, the correct drive number is loaded into
 14074                                  				;the first FCB, at offset 5C.
 14075                                  
 14076                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14077 000011D0 803E[308D]3A            	cmp	byte [SrcBuf+1],':'
 14078 000011D5 750A                    	jne	short soRet
 14079                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14080 000011D7 A0[2F8D]                	mov	al,[SrcBuf]
 14081                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14082 000011DA 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14083 000011DC 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14084 000011DE A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14085                                  						;M011;end
 14086                                  soRet:
 14087 000011E1 C3                      	retn
 14088                                  
 14089                                  ; ---------------------------------------------------------------------------
 14090                                  
 14091                                  ;***	CrunchPath - analyze supplied or default pathname
 14092                                  ;
 14093                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14094                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14095                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14096                                  ;		 must have space for another char after the delimiter.
 14097                                  ;
 14098                                  ;	EXIT	CY = clear if no error
 14099                                  ;		We are changed to directory found in pathname
 14100                                  ;		Previous directory ready to be restored via RestUDir
 14101                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14102                                  ;
 14103                                  ;		If error occurred,
 14104                                  ;		CY = set
 14105                                  ;		ComSw = error bits (see ErrorRec)
 14106                                  ;		If ComSw not set,
 14107                                  ;		Ready for DOS Get Extended Error call
 14108                                  
 14109                                  	; 16/02/2023
 14110                                  CrunchPath:
 14111 000011E2 E8E101                  	call	FileIsDevice
 14112 000011E5 7507                    	jne	short crpath1	; not a device, skip ahead
 14113                                  	;;;or	ComSw,mask dev	; signal file is device
 14114                                  	;;or	word [COMSW],1
 14115                                  	;or	byte [COMSW],1
 14116 000011E7 800E[D78A]01            	or	byte [COMSW],mask.dev
 14117 000011EC EB2F                    	jmp	short cpErr	; return error
 14118                                  crpath1:
 14119 000011EE FF36[1F8C]              	push	word [PathPos]	; save ptr to pathname
 14120 000011F2 C606[278C]FF            	mov	byte [DirFlag],-1
 14121                                  				; tell PathCrunch not to parse file into FCB
 14122 000011F7 E88814                  	call	PathCrunch	; change to directory in pathname
 14123 000011FA C606[278C]00            	mov	byte [DirFlag],0
 14124                                  				; reset our little flag
 14125 000011FF 5E                      	pop	si		; SI = ptr to pathname
 14126 00001200 7208                    	jc	short cpNoDir	; didn't find directory path
 14127 00001202 741A                    	jz	short cpRet	; found directory path w/ no filename
 14128                                  				;  - leave wildcard default in FCB and return
 14129                                  
 14130                                  ;*	We found a directory, and there was a filename attached.
 14131                                  ;	DestTail = ptr to ASCIIZ filename
 14132                                  
 14133 00001204 8B36[C98C]              	mov	si,[DestTail]	; SI = ptr to filename
 14134 00001208 EB28                    	jmp	short cpFile	; go parse the file into FCB
 14135                                  
 14136                                  ;*	PathCrunch failed to find a directory in the pathname.
 14137                                  ;
 14138                                  ;	Msg_Numb = error code
 14139                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14140                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14141                                  
 14142                                  cpNoDir:
 14143 0000120A A1[338E]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14144 0000120D 09C0                    	or	ax,ax
 14145 0000120F 750C                    	jnz	short cpErr	  ; error occurred - return it
 14146 00001211 803E[C78C]00            	cmp	byte [DestIsDir],0
 14147 00001216 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14148                                  crpath3:
 14149                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14150                                  	;;or	word [COMSW],2
 14151                                  	;or	byte [COMSW],2
 14152 00001218 800E[D78A]02            	or	byte [COMSW],mask.baddir
 14153                                  	;jmp	short cpErr	  ; return error
 14154                                  	; 16/02/2023
 14155                                  cpErr:
 14156 0000121D F9                      	stc			  ; return error
 14157                                  cpRet:
 14158 0000121E C3                      	retn
 14159                                  
 14160                                  cpMaybe:
 14161                                  ;	SI = ptr to pathname
 14162                                  
 14163                                  	;cmp	byte [si+1],COLON_CHAR
 14164 0000121F 807C013A                	cmp	byte [si+1],':'
 14165 00001223 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14166 00001225 AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14167                                  crpath2:
 14168 00001226 813C2E2E                	cmp	word [si],".."
 14169 0000122A 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14170 0000122C 807C0200                	cmp	byte [si+2],0
 14171                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14172                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14173                                  	;;;or	word [COMSW],2
 14174                                  	;;or	byte [COMSW],2
 14175                                  	;or	byte [COMSW],mask.baddir
 14176                                  	;jmp	short cpErr	  ; return error
 14177                                  	; 16/02/2023
 14178 00001230 74E6                    	je	short crpath3
 14179                                  
 14180                                  ;	The preceding code was taken from the old DIR routine.
 14181                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14182                                  ;	occurring when we're at the root directory. Too bad it
 14183                                  ;	doesn't handle problems with "..\..", etc.
 14184                                  
 14185                                  ;	We're ready to parse a filename into the FCB.
 14186                                  ;	SI = ptr to ASCIIZ filename
 14187                                  
 14188                                  cpFile:	
 14189 00001232 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14190 00001235 B80E29                  	mov	ax,290Eh
 14191                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14192                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14193                                  				; wildcards already in FCB used as defaults
 14194 00001238 CD21                    	int	21h
 14195 0000123A F8                      	clc			; return success
 14196                                  	;jmp	short cpRet
 14197                                  	; 16/02/2023
 14198 0000123B C3                      	retn
 14199                                  
 14200                                  ;cpErr:
 14201                                  ;	stc			; return error
 14202                                  ;cpRet:
 14203                                  ;	retn
 14204                                  
 14205                                  ; ---------------------------------------------------------------------------
 14206                                  
 14207                                  ;***	InstallCtrlC - install our private control-C handler
 14208                                  ;
 14209                                  ;	Put our control-c handler in front of command.com's default
 14210                                  ;	handler, to make sure the user's default directory gets restored.
 14211                                  ;	This shouldn't be necessary, but, for now, there are situations
 14212                                  ;	where the TDATA segment is left in a modified state when a
 14213                                  ;	control-c occurs.  This means that the transient will be
 14214                                  ;	reloaded, and the user's directory cannot be restored.
 14215                                  ;
 14216                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14217                                  ;
 14218                                  ;	ENTRY	nothing
 14219                                  ;
 14220                                  ;	EXIT	nothing
 14221                                  ;
 14222                                  ;	USED	AX,BX,DX
 14223                                  ;
 14224                                  ;	EFFECTS
 14225                                  ;
 14226                                  ;	  CtrlCHandler address placed in int 23 vector.
 14227                                  ;
 14228                                  ;	NOTE
 14229                                  ;
 14230                                  ;	  Command.com's basic control-c handler will be restored
 14231                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14232                                  
 14233                                  	; 16/02/2023
 14234                                  InstallCtrlC:
 14235 0000123C 06                      	push	es			; preserve ES
 14236 0000123D B82335                  	mov	ax,3523h
 14237                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14238                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14239 00001240 CD21                    	int	21h
 14240 00001242 891E[C395]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14241 00001246 8C06[C595]              	mov	[OldCtrlCHandler+2],es	 
 14242 0000124A 07                      	pop	es			; restore ES
 14243                                  
 14244 0000124B BA[9319]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14245 0000124E B82325                  	mov	ax,2523h
 14246                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14247                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14248 00001251 CD21                    	int	21h
 14249 00001253 C3                      	retn
 14250                                  
 14251                                  ; ---------------------------------------------------------------------------
 14252                                  
 14253                                  ;***	ListSubds - search and list files in subdirectories
 14254                                  ;
 14255                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14256                                  ;		FCB is still set up for file searches
 14257                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14258                                  ;
 14259                                  ;	EXIT	CY = clear if no error
 14260                                  ;		FileCnt = # files found & displayed
 14261                                  ;		FileSiz = total size of files found
 14262                                  ;
 14263                                  ;		If error,
 14264                                  ;		CY = set
 14265                                  ;		Ready for DOS Get Extended Error call
 14266                                  ;
 14267                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14268                                  ;
 14269                                  ;	EFFECTS
 14270                                  ;
 14271                                  ;	  FileCntTotal, FileSizTotal are updated.
 14272                                  ;	  Subdirectories may be listed on standard output device.
 14273                                  ;
 14274                                  ;	NOTES
 14275                                  ;
 14276                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14277                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14278                                  ;	   Each name is stored ASCIIZ.
 14279                                  
 14280                                  	; 16/02/2023
 14281                                  ListSubds:
 14282                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14283 00001254 E89B1A                  	call	SetRest1
 14284                                  
 14285 00001257 BB[898D]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14286                                  lsNode:
 14287 0000125A C60700                  	mov	byte [bx],0		; start with null child name
 14288                                  lsLoop:
 14289 0000125D E8F001                  	call	FindNextChild		; search for next subdirectory
 14290 00001260 7235                    	jc	short lsErr		; search failed - examine error
 14291                                  
 14292 00001262 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14293 00001264 E84104                  	call	ChangeDir		; enter child directory
 14294                                  
 14295                                  					; M023;start
 14296 00001267 7306                    	jnc	short lstsd1		; check for error
 14297                                  	;cmp	ax,3
 14298 00001269 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14299 0000126C 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14300                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14301                                  	; 16/02/2023			; M023;end
 14302 0000126E C3                      	retn
 14303                                  lstsd1:	
 14304 0000126F 53                      	push	bx
 14305 00001270 E88B02                  	call	ListDir			; list the directory
 14306 00001273 5B                      	pop	bx
 14307                                  
 14308                                  ;	Note we're ignoring errors returned here.
 14309                                  
 14310 00001274 89DF                    	mov	di,bx			; DI = ptr to child's name
 14311 00001276 B90D00                  	mov	cx,13			; CX = max name length w/ null
 14312 00001279 30C0                    	xor	al,al			; AL = zero byte to look for
 14313 0000127B F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14314 0000127D 53                      	push	bx			; save ptr to child's name
 14315 0000127E 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14316 00001280 E8D7FF                  	call	lsNode			; recurse from new node
 14317 00001283 5B                      	pop	bx			; BX = ptr to child's name
 14318 00001284 9C                      	pushf				; save error condition
 14319                                  	
 14320                                  	;;shove	0
 14321                                  	;mov	ax,0
 14322 00001285 29C0                    	sub	ax,ax ; 0
 14323 00001287 50                      	push	ax
 14324                                  	;shove	".."
 14325 00001288 B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14326 0000128B 50                      	push	ax
 14327 0000128C 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14328 0000128E E81704                  	call	ChangeDir		; return to parent directory
 14329 00001291 58                      	pop	ax			; restore stack
 14330 00001292 58                      	pop	ax
 14331                                  
 14332 00001293 9D                      	popf				; restore error condition from child
 14333                                  	;jc	short lsRet		; return error
 14334                                  	;jmp	short lsLoop		; look for more children
 14335                                  	; 16/02/2023
 14336 00001294 73C7                    	jnc	short lsLoop
 14337 00001296 C3                      	retn
 14338                                  lsErr:
 14339 00001297 E8680A                  	call	get_ext_error_number	; AX = extended error code
 14340                                  	;cmp	ax,2
 14341 0000129A 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14342 0000129D 7406                    	je	short lsRet		; file not found, we're ok
 14343                                  	;cmp	ax,18
 14344 0000129F 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14345 000012A2 7401                    	je	short lsRet		; no more files, we're ok
 14346 000012A4 F9                      	stc				; return other errors
 14347                                  lsRet:	
 14348 000012A5 C3                      	retn
 14349                                  
 14350                                  ; ---------------------------------------------------------------------------
 14351                                  
 14352                                  	;break	<DIR support routines>
 14353                                  
 14354                                  ;***	SUPPORT ROUTINES
 14355                                  
 14356                                  ; ----------------------
 14357                                  
 14358                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14359                                  ;
 14360                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14361                                  ;		BX = ptr to last child's name
 14362                                  ;		BP = ptr to temp child's name
 14363                                  ;
 14364                                  ;	EXIT	nothing
 14365                                  ;
 14366                                  ;	USED	AX,CX,SI,DI
 14367                                  ;
 14368                                  ;	EFFECTS
 14369                                  ;
 14370                                  ;	  Filename pointed to by BP may be changed.
 14371                                  ;
 14372                                  ;	NOTES
 14373                                  ;
 14374                                  ;	  Potential filename replaces temp filename if:
 14375                                  ;	   it's a subdirectory file;
 14376                                  ;	   it doesn't start with a '.';
 14377                                  ;	   it's alphanumerically greater than last child's name;
 14378                                  ;	   and it's alphanumerically less than temp name.
 14379                                  
 14380                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14381                                  	; 07/06/2023
 14382                                  CheckChild:
 14383                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14384 000012A6 F606[DE8B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14385 000012AB 741D                    	jz	short ccRet	; not a subdirectory file- return
 14386                                  
 14387                                  	; 16/02/2023
 14388 000012AD BE[E78B]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14389 000012B0 803C2E                  	cmp	byte [si],'.'
 14390                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14391                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14392 000012B3 7415                    	je	short ccRet	; starts with a dot- return
 14393                                  
 14394                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14395                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14396 000012B5 89DF                    	mov	di,bx
 14397 000012B7 E80504                  	call	CmpAscz		; compare candidate to last child's name
 14398 000012BA 760E                    	jna	short ccRet	; it's not above it- return
 14399                                  
 14400                                  
 14401                                  	; 07/06/2023
 14402                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14403                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14404                                  	; si = DIRBUF+FIND_BUF.PNAME
 14405 000012BC 89EF                    	mov	di,bp
 14406 000012BE E8FE03                  	call	CmpAscz		; compare candidate to temp name
 14407 000012C1 7307                    	jnb	short ccRet	; it's not below it- return
 14408                                  
 14409                                  ;	New kid is alright. Copy to temp.
 14410                                  
 14411                                  	; 07/06/2023
 14412                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14413                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14414                                  	; si = DIRBUF+FIND_BUF.PNAME
 14415 000012C3 89EF                    	mov	di,bp
 14416 000012C5 B90D00                  	mov	cx,13
 14417 000012C8 F3A4                    	rep	movsb
 14418                                  ccRet:
 14419 000012CA C3                      	retn
 14420                                  
 14421                                  ; ---------------------------------------------------------------------------
 14422                                  
 14423                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14424                                  ;
 14425                                  ;	Compare one directory entry against another according to
 14426                                  ;	the sort codes in DestBuf. One or more comparisons
 14427                                  ;	may be made of file name, extension, time/date, and
 14428                                  ;	size.  Comparisons may be made for upward or downward
 14429                                  ;	sort order.
 14430                                  ;
 14431                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14432                                  ;		ES:BP = ptr to entry to be compared against
 14433                                  ;		DestBuf contains sort codes (see DestBuf)
 14434                                  ;		DS = TRANGROUP seg addr
 14435                                  ;
 14436                                  ;	EXIT	BX = unchanged
 14437                                  ;		BP = unchanged
 14438                                  ;		Condition flags set for same, above, or below
 14439                                  ;		 comparing BX entry against BP entry.
 14440                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14441                                  ;
 14442                                  ;	USED:	AX,CX,DX,SI,DI
 14443                                  
 14444                                  	; 16/02/2023
 14445                                  CmpEntry:
 14446 000012CB BE[CC8C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14447                                  ceLoop:
 14448 000012CE 31C0                    	xor	ax,ax		; AX = 0
 14449 000012D0 8A04                    	mov	al,[si]		; AL = sort code
 14450 000012D2 08C0                    	or	al,al
 14451 000012D4 741C                    	jz	short ceDone	; sort code is zero, we're done
 14452 000012D6 46                      	inc	si		; DS:SI = ptr to next sort code
 14453 000012D7 56                      	push	si		; save ptr to next sort code
 14454 000012D8 FEC8                    	dec	al
 14455 000012DA D0E0                    	shl	al,1
 14456                                  	;sal	al,1		; AX = index into cmp call table
 14457                                  				; CY set for downward sort order
 14458 000012DC 89C6                    	mov	si,ax		; SI = index into cmp call table
 14459 000012DE 2E8B84[F312]            	mov	ax,[cs:si+FieldCmps]
 14460                                  				; AX = addr of compare routine
 14461 000012E3 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14462 000012E5 FFD0                    	call	ax 		; do upwards sort
 14463 000012E7 EB06                    	jmp	short ceNs
 14464                                  ceDn:
 14465 000012E9 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14466 000012EB FFD0                    	call	ax		; do sort
 14467 000012ED 87DD                    	xchg	bx,bp		; swap ptrs back
 14468                                  ceNs:
 14469 000012EF 5E                      	pop	si		; SI = ptr to next sort code
 14470 000012F0 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14471                                  ceDone:
 14472                                  
 14473                                  ;	Get here either from unequal compare or sort code = 0.
 14474                                  ;	In the latter case, condition codes indicate equality,
 14475                                  ;	which is correct.
 14476                                  
 14477 000012F2 C3                      	retn
 14478                                  
 14479                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14480                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14481                                  
 14482                                  FieldCmps:		; call table of entry comparisons
 14483 000012F3 [FD12]                  	dw	CmpName
 14484 000012F5 [0813]                  	dw	CmpExt
 14485 000012F7 [4613]                  	dw	CmpTime
 14486 000012F9 [6213]                  	dw	CmpSize
 14487 000012FB [6713]                  	dw	CmpType
 14488                                  
 14489                                  ; ---------------------------------------------------------------------------
 14490                                  
 14491                                  ;***	CmpName - compare file name of two entries
 14492                                  ;***	CmpExt - compare extension of two entries
 14493                                  ;
 14494                                  ;	ENTRY	ES:BX = ptr to one entry
 14495                                  ;		ES:BP = ptr to another entry
 14496                                  ;
 14497                                  ;	EXIT	BX = unchanged
 14498                                  ;		BP = unchanged
 14499                                  ;		Condition flags set for same, above, or below
 14500                                  ;		comparing BX entry to BP entry.
 14501                                  ;
 14502                                  ;	USED:	AX,CX,DX,SI,DI
 14503                                  
 14504                                  	; 16/02/2023
 14505                                  CmpName:
 14506 000012FD 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14507 000012FF 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14508                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14509                                  	;add	si,1
 14510                                  	; 25/04/2023
 14511 00001301 46                      	inc	si
 14512                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14513                                  	;add	di,1
 14514                                  	; 25/04/2023
 14515 00001302 47                      	inc	di
 14516                                  	;mov	cx,size filename
 14517                                  				; CX = length of name
 14518 00001303 B90800                  	mov	cx,8
 14519 00001306 EB0C                    	jmp	short CmpStr
 14520                                  
 14521                                  CmpExt:
 14522                                  	; 07/06/2023
 14523                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14524                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14525                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14526                                  	;add	si,9
 14527                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14528                                  	;add	di,9
 14529                                  	;
 14530 00001308 BE0900                  	mov	si,9
 14531 0000130B 89F7                    	mov	di,si ; mov di,9
 14532 0000130D 01DE                    	add	si,bx
 14533 0000130F 01EF                    	add	di,bp
 14534                                  	;
 14535                                  	;mov	cx,size fileext	; CX = length of extension field
 14536 00001311 B90300                  	mov	cx,3
 14537                                  
 14538                                  ;	Bugbug:	use symbol for subfunction code.
 14539                                  
 14540                                  CmpStr:	
 14541 00001314 803E[BE95]06            	cmp	byte [CountryPtrId],6
 14542 00001319 7527                    	jne	short cnNoCollTable
 14543                                  				; no collating table available
 14544                                  
 14545                                  ;*	Compare strings using collating table.
 14546                                  ;
 14547                                  ;	ES:SI = ptr to 1st string
 14548                                  ;	ES:DI = ptr to 2nd string
 14549                                  ;	CX = length
 14550                                  
 14551 0000131B 55                      	push	bp		; preserve BP
 14552 0000131C 53                      	push	bx		; preserve BX
 14553 0000131D 1E                      	push	ds		; preserve DS
 14554 0000131E C51E[BF95]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14555                                  	;assume	ds:NOTHING
 14556 00001322 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14557 00001324 43                      	inc	bx
 14558 00001325 43                      	inc	bx		; DS:BX = ptr to collating values
 14559                                  				; DS:[BX]-2 = size of table
 14560 00001326 31C0                    	xor	ax,ax		; AX = 0 for starters
 14561                                  
 14562                                  ;	Bugbug:	Investigate removing collating table length checks.
 14563                                  
 14564                                  cnNextChar:
 14565 00001328 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14566 0000132B 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14567 0000132C 39E8                    	cmp	ax,bp		; compare to collating table length
 14568 0000132E 7301                    	jae	short cn1 	; char not in table
 14569 00001330 D7                      	xlat				
 14570                                  cn1:				; AL = AX = collating value
 14571 00001331 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14572                                  	;lods	byte ptr es:[si]
 14573 00001333 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14574                                  				; ES:SI = ptr to next char 1st string
 14575 00001335 39E8                    	cmp	ax,bp		; compare to collating table length
 14576 00001337 7301                    	jae	short cn2	; char not in table
 14577 00001339 D7                      	xlat				
 14578                                  cn2:				; AL = AX = collating value
 14579 0000133A 39D0                    	cmp	ax,dx		; compare collating values
 14580 0000133C E1EA                    	loope	cnNextChar	; until unequal or no more left
 14581                                  
 14582 0000133E 1F                      	pop	ds		; restore DS
 14583                                  	;assume	ds:TRANGROUP
 14584 0000133F 5B                      	pop	bx		; restore BX
 14585 00001340 5D                      	pop	bp		; restore BP
 14586 00001341 C3                      	retn
 14587                                  
 14588                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14589                                  ;	Don't we wish we could just do this all the time?  Sigh.
 14590                                  
 14591                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14592                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14593                                  cnNoCollTable:
 14594                                  	;repe	cmps byte ptr es:[si],[di]
 14595                                  				;db 0F3h,26h,0A6h,0C3h
 14596 00001342 F3                      	repe	; 0F3h
 14597 00001343 26                      	es	; 26h
 14598 00001344 A6                      	cmpsb	; 0A6h
 14599 00001345 C3                      	retn	; 0C3h
 14600                                  
 14601                                  ; ---------------------------------------------------------------------------
 14602                                  
 14603                                  ;***	CmpTime - compare entries by date/time
 14604                                  ;
 14605                                  ;	ENTRY	ES:BX = ptr to one entry
 14606                                  ;		ES:BP = ptr to another entry
 14607                                  ;
 14608                                  ;	EXIT	BX = unchanged
 14609                                  ;		BP = unchanged
 14610                                  ;		Condition flags set for same, above, or below
 14611                                  ;		 comparing BX entry to BP entry.
 14612                                  ;
 14613                                  ;	USED:	CX,SI,DI
 14614                                  ;
 14615                                  ;	NOTE	Filetime and filedate fields in our private entry
 14616                                  ;		structure must be adjacent and in that order.
 14617                                  
 14618                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14619                                  	; 07/06/2023
 14620                                  CmpTime:
 14621 00001346 89DE                    	mov	si,bx
 14622 00001348 89EF                    	mov	di,bp
 14623                                  	;add	si,filedate + size filedate - 1
 14624 0000134A 83C610                  	add	si,16 ; 15+2-1
 14625                                  	;add	di,filedate + size filedate - 1
 14626 0000134D 83C710                  	add	di,16 ; 15+2-1
 14627                                  	; 07/06/2023
 14628 00001350 BE1000                  	mov	si,16
 14629                                  CmpST2:		; 07/06/2023
 14630 00001353 89F7                    	mov	di,si	; mov di,16
 14631 00001355 01DE                    	add	si,bx
 14632 00001357 01EF                    	add	di,bp
 14633                                  
 14634                                  	;mov	cx,size filetime + size filedate
 14635 00001359 B90400                  	mov	cx,4 ; 2+2
 14636 0000135C FD                      	std
 14637                                  	;repe	cmps byte ptr es:[si],[di]
 14638                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 14639 0000135D F3                      	repe	; 0F3h
 14640 0000135E 26                      	es	; 26h
 14641 0000135F A6                      	cmpsb	; 0A6h
 14642                                  	
 14643 00001360 FC                      	cld	; 0FCh
 14644 00001361 C3                      	retn	; 0C3h
 14645                                  
 14646                                  ; ---------------------------------------------------------------------------
 14647                                  
 14648                                  ;***	CmpSize - compare entries by size
 14649                                  ;
 14650                                  ;	ENTRY	ES:BX = ptr to one entry
 14651                                  ;		ES:BP = ptr to another entry
 14652                                  ;
 14653                                  ;	EXIT	BX = unchanged
 14654                                  ;		BP = unchanged
 14655                                  ;		Condition flags set for same, above, or below
 14656                                  ;		 comparing BX entry to BP entry.
 14657                                  ;
 14658                                  ;	USED:	CX,SI,DI
 14659                                  
 14660                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14661                                  	; 07/06/2023
 14662                                  CmpSize:
 14663                                  	;mov	si,bx
 14664                                  	;mov	di,bp
 14665                                  	;;add	si,filesize + size filesize - 1
 14666                                  	;add	si,20  ; 17+4-1
 14667                                  	;;add	di,filesize + size filesize - 1
 14668                                  	;add	di,20  ; 17+4-1
 14669                                  	; 07/06/2023
 14670 00001362 BE1400                  	mov	si,20
 14671                                  	;;;
 14672 00001365 EBEC                    	jmp	short CmpST2 ; 07/06/2023
 14673                                  	;;;
 14674                                  ;CmpST2:
 14675                                  ;	mov	di,si	; mov di,20
 14676                                  ;	add	si,bx
 14677                                  ;	add	di,bp
 14678                                  ;
 14679                                  ;	;mov	cx,size filesize
 14680                                  ;	mov	cx,4
 14681                                  ;	std
 14682                                  ;	;repe	cmps byte ptr es:[si],[di]
 14683                                  ;				;db 0F3h,26h,0A6h
 14684                                  ;	repe	; 0F3h
 14685                                  ;	es	; 26h
 14686                                  ;	cmpsb	; 0A6h
 14687                                  ;
 14688                                  ;	cld
 14689                                  ;	retn
 14690                                  
 14691                                  ; ---------------------------------------------------------------------------
 14692                                  
 14693                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14694                                  ;
 14695                                  ;	ENTRY	ES:BX = ptr to one entry
 14696                                  ;		ES:BP = ptr to another entry
 14697                                  ;
 14698                                  ;	EXIT	BX = unchanged
 14699                                  ;		BP = unchanged
 14700                                  ;		Condition flags set for same, above, or below
 14701                                  ;		 comparing BX entry to BP entry.
 14702                                  ;
 14703                                  ;	USED:	AX
 14704                                  
 14705                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14706                                  CmpType:
 14707                                  	;mov	al,es:[bx].fileattr
 14708 00001367 268A470C                	mov	al,[es:bx+12]
 14709                                  	;mov	ah,es:[bp].fileattr
 14710 0000136B 268A660C                	mov	ah,[es:bp+12]
 14711                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14712                                  	;and	ax,1010h
 14713 0000136F 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14714 00001372 38C4                    	cmp	ah,al
 14715 00001374 C3                      	retn
 14716                                  
 14717                                  ; ---------------------------------------------------------------------------
 14718                                  
 14719                                  ;***	DefaultAttr - set default attribute conditions
 14720                                  ;
 14721                                  ;	ENTRY	nothing
 14722                                  ;
 14723                                  ;	EXIT	CY clear
 14724                                  ;
 14725                                  ;	USED
 14726                                  ;
 14727                                  ;	EFFECTS
 14728                                  ;
 14729                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14730                                  
 14731                                  	; 16/02/2023
 14732                                  DefaultAttr:
 14733                                  	;mov	byte [AttrSpecified],6
 14734 00001375 C606[238C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14735                                  					; specify H and S
 14736 0000137A C606[248C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14737 0000137F F8                      	clc				; return success
 14738                                  dtRet:	; 18/02/2023
 14739 00001380 C3                      	retn
 14740                                  
 14741                                  ; ---------------------------------------------------------------------------
 14742                                  
 14743                                  ;***	DisplayTotals - display grand total stats
 14744                                  ;
 14745                                  ;	If we searched subdirectories, display the total # files found
 14746                                  ;	 and total size of files found.
 14747                                  ;	Display disk space remaining.
 14748                                  ;
 14749                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14750                                  ;		Bits contains setting of /s
 14751                                  ;		FCB contains drive #
 14752                                  ;
 14753                                  ;	EXIT	nothing
 14754                                  ;
 14755                                  ;	USES	AX,DX
 14756                                  ;		FileSiz
 14757                                  
 14758                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14759                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14760                                  
 14761                                  DisplayTotals:
 14762                                  	;;;test	Bits,mask subd
 14763                                  	;;test	word [_Bits],4
 14764                                  	;test	byte [_Bits],4
 14765 00001381 F606[1B8C]04            	test	byte [_Bits],mask.subd
 14766 00001386 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14767                                  
 14768 00001388 E84E12                  	call	CRLF2			; start on new line
 14769 0000138B E8C503                  	call	UseLine
 14770                                  
 14771 0000138E BA[9181]                	mov	dx,total_ptr
 14772 00001391 E88F3A                  	call	std_printf		; "Total:",cr,lf
 14773 00001394 E8BC03                  	call	UseLine
 14774                                  
 14775 00001397 A1[F28A]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14776 0000139A BE[F68A]                	mov	si,FileSizTotal
 14777 0000139D BF[EE8A]                	mov	di,FileSiz
 14778 000013A0 A5                      	movsw
 14779 000013A1 A5                      	movsw				; move total size to size variable
 14780 000013A2 E87705                  	call	DisplayCntSiz		; display file count & size &
 14781                                  dtFree: 				;   (maybe) compression ratio
 14782 000013A5 B436                    	mov	ah,36h
 14783                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14784 000013A7 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14785 000013AB CD21                    	int	21h			; call DOS
 14786 000013AD 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14787 000013B0 74CE                    	jz	short dtRet		; can't get drive space - return
 14788 000013B2 F7E1                    	mul	cx
 14789 000013B4 F7E3                    	mul	bx
 14790 000013B6 A3[B78C]                	mov	[Bytes_Free],ax
 14791 000013B9 8916[B98C]              	mov	[Bytes_Free+2],dx
 14792 000013BD BA[A37F]                	mov	dx,bytmes_ptr
 14793 000013C0 E8603A                  	call	std_printf		; "nnn bytes free",cr,lf
 14794                                  	;call	UseLine
 14795                                  ;dtRet:
 14796                                  	;retn
 14797                                  	; 18/02/2023
 14798 000013C3 E98D03                  	jmp	UseLine
 14799                                  
 14800                                  ; ---------------------------------------------------------------------------
 14801                                  
 14802                                  ;***	FileIsDevice - see if file looks like a device
 14803                                  ;
 14804                                  ;	ENTRY	PathPos = ptr to pathname
 14805                                  ;		PathCnt = length of pathname w/o terminating char
 14806                                  ;		DirBuf is DOS DTA
 14807                                  ;
 14808                                  ;	EXIT	ZR = set if file looks like a device
 14809                                  ;
 14810                                  ;	USED	AX,BX,CX,DX,DI
 14811                                  ;
 14812                                  ;	EFFECTS
 14813                                  ;
 14814                                  ;	  DTA buffer holds results of Find First function
 14815                                  ;
 14816                                  ;	NOTES
 14817                                  ;
 14818                                  ;	  We try to flag devices in two ways. First, we try
 14819                                  ;	  the DOS Find First function. It returns attribute bit 6
 14820                                  ;	  set on a successful find if it identifies a device name.
 14821                                  ;	  Unfortunately, it returns 'path not found' for a device
 14822                                  ;	  name terminated with colon, such as "CON:". So, we look
 14823                                  ;	  for any colon in the pathname after the 2nd character,
 14824                                  ;	  and flag the pathname as a device if we find one.
 14825                                  
 14826                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14827                                  FileIsDevice:
 14828 000013C6 8B16[1F8C]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 14829                                  
 14830 000013CA 89D7                    	mov	di,dx
 14831 000013CC 033E[1D8C]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 14832 000013D0 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 14833 000013D2 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 14834                                  
 14835 000013D4 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 14836 000013D6 B44E                    	mov	ah,4Eh
 14837                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 14838 000013D8 CD21                    	int	21h	 	 ; call DOS
 14839 000013DA 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 14840 000013DC 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 14841                                  
 14842                                  ;	Found a dir entry, see if Find First thinks it's a device.
 14843                                  
 14844                                  	;test	byte [DIRBUF+21],40h
 14845 000013DE F606[DE8B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 14846 000013E3 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 14847 000013E5 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 14848                                  	;jmp	short piRet
 14849                                  	; 25/04/2023
 14850                                  piRet:
 14851 000013E7 C3                      	retn
 14852                                  
 14853                                  ;	Device attribute not returned by Find First function. But
 14854                                  ;	let's check for a colon anywhere in the pathname after the
 14855                                  ;	second byte.
 14856                                  ;
 14857                                  ;	DI = ptr to byte after pathname
 14858                                  
 14859                                  piCol:
 14860 000013E8 4F                      	dec	di		 ; DI = ptr to last char in pathname
 14861 000013E9 B03A                    	mov	al,':'
 14862                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 14863 000013EB 8B0E[1D8C]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 14864 000013EF 49                      	dec	cx
 14865 000013F0 49                      	dec	cx		 ; ignore 1st two chars of pathname
 14866 000013F1 09C9                    	or	cx,cx
 14867 000013F3 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 14868 000013F5 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 14869 000013F7 FD                      	std			 ; scan downward
 14870 000013F8 F2AE                    	repne	scasb
 14871 000013FA FC                      	cld			 ; restore default upward direction
 14872                                  
 14873                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 14874                                  ;piRet:
 14875 000013FB C3                      	retn
 14876                                  
 14877                                  ;FileIsDevice endp
 14878                                  
 14879                                  ; ---------------------------------------------------------------------------
 14880                                  
 14881                                  ;***	FindFirst - find first directory entry to display
 14882                                  ;***	FindNext - find next directory entry to display
 14883                                  ;
 14884                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 14885                                  ;		AttrSpecified, AttrSelect are set
 14886                                  ;
 14887                                  ;	EXIT	CY = clear if successful
 14888                                  ;		BX = offset in TPA buffer of directory entry found
 14889                                  ;
 14890                                  ;		If unsuccessful,
 14891                                  ;		CY = set
 14892                                  ;		AX = DOS error code
 14893                                  ;		DOS Get Extended Error call will get error code
 14894                                  ;
 14895                                  ;		NOTE: if entries were loaded into TPA, AX contains
 14896                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 14897                                  ;		but DOS Get Extended Error call WON'T return the correct
 14898                                  ;		error. That's ok, because we'll see the value in AX
 14899                                  ;		and recognize it as a non-error condition.
 14900                                  ;
 14901                                  ;	USED	AX,CX,DX,SI,DI
 14902                                  ;
 14903                                  ;	EFFECTS
 14904                                  ;
 14905                                  ;	  Entries in memory may be marked as output.
 14906                                  ;	  If not sorted, entry is loaded at TPA.
 14907                                  ;
 14908                                  ;	NOTES
 14909                                  ;
 14910                                  ;	  If we don't find a qualifying file, we return after the final
 14911                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 14912                                  ;	   indicate an appropriate condition.
 14913                                  
 14914                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14915                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 14916                                  	
 14917                                  FindFirst:
 14918                                  	;mov	ax,offset TRANGROUP:GetFirst
 14919 000013FC B8[D314]                	mov	ax,GetFirst
 14920 000013FF EB03                    	jmp	short ffFindEntry
 14921                                  
 14922                                  	; 18/02/2023
 14923                                  FindNext:
 14924                                  	;mov	ax,offset TRANGROUP:GetNext
 14925 00001401 B8[E114]                	mov	ax,GetNext
 14926                                  
 14927                                  ;	AX = address of correct disk get routine to use.
 14928                                  
 14929                                  ffFindEntry:
 14930 00001404 06                      	push	es			; save TRANGROUP seg addr
 14931                                  	;;;test	Bits,mask inmem
 14932                                  	;;test	word [_Bits],20h
 14933                                  	;test	byte [_Bits],20h
 14934 00001405 F606[1B8C]20            	test	byte [_Bits],mask.inmem
 14935 0000140A 7405                    	jz	short ffDisk		; entries not in memory, search disk
 14936                                  
 14937                                  ;	Entries are loaded in memory to sort out. Find the first one.
 14938                                  ;	There will always be one, or LoadEntries would've failed.
 14939                                  
 14940 0000140C E81A00                  	call	FindInMem		; find first entry in TPA
 14941 0000140F EB16                    	jmp	short ffRet		; return what TPA search returns
 14942                                  
 14943                                  ;	Get entry from disk.
 14944                                  
 14945                                  ffDisk:
 14946 00001411 FFD0                    	call	ax			; get entry from disk
 14947 00001413 720E                    	jc	short ffGetErr		; get & return error
 14948 00001415 8E06[C28A]              	mov	es,[TPA]		; ES = seg addr of TPA
 14949 00001419 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 14950 0000141B 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 14951 0000141D E85701                  	call	LoadEntry		; load entry to TPA
 14952 00001420 F8                      	clc				; return success
 14953 00001421 EB04                    	jmp	short ffRet
 14954                                  
 14955                                  ffGetErr:
 14956 00001423 E8DC08                  	call	 get_ext_error_number	; AX = DOS error code
 14957 00001426 F9                      	stc
 14958                                  ffRet:
 14959 00001427 07                      	pop	es			; ES = TRANGROUP seg addr again
 14960 00001428 C3                      	retn
 14961                                  
 14962                                  ; ---------------------------------------------------------------------------
 14963                                  
 14964                                  ;***	FindInMem - find next directory entry in TPA buffer
 14965                                  ;
 14966                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 14967                                  ;
 14968                                  ;	EXIT	BX = offset in TPA of entry found
 14969                                  ;
 14970                                  ;		If no more files,
 14971                                  ;		CY = set
 14972                                  ;		AX = DOS 'no more files' error code
 14973                                  ;
 14974                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 14975                                  ;
 14976                                  ;	EFFECTS
 14977                                  ;
 14978                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 14979                                  
 14980                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14981                                  FindInMem:
 14982 00001429 8E06[C28A]              	mov	es,[TPA]		; ES = TPA seg addr
 14983 0000142D 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 14984 0000142F FC                      	cld				; make sure default string direction is up
 14985                                  	
 14986 00001430 E86D00                  	call	FindOneInMem		; locate an entry
 14987 00001433 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 14988                                  
 14989                                  ;	BX = ptr to entry in TPA
 14990                                  
 14991                                  fiBest:
 14992 00001435 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 14993                                  fiNext:
 14994 00001437 E87300                  	call	FindNextInMem		; locate next entry
 14995 0000143A 720C                    	jc	short fiFound		; no more, best entry so far wins
 14996                                  
 14997                                  ;	BX = ptr to next entry
 14998                                  
 14999 0000143C E88CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15000 0000143F 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15001 00001441 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15002                                  
 15003                                  fiNoMore:
 15004                                  
 15005                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15006                                  
 15007                                  	;mov	ax,18
 15008 00001443 B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15009 00001446 F9                      	stc				; return error
 15010                                  	;jmp	short fiRet
 15011                                  	; 18/02/2023
 15012 00001447 C3                      	retn
 15013                                  
 15014                                  fiFound:
 15015 00001448 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15016 0000144A 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15017 0000144E F8                      	clc				; return success
 15018                                  fiRet:
 15019 0000144F C3                      	retn
 15020                                  
 15021                                  ; ---------------------------------------------------------------------------
 15022                                  
 15023                                  ;***	FindNextChild - find next subdirectory in current directory
 15024                                  ;
 15025                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15026                                  ;		DirBuf is established DTA
 15027                                  ;
 15028                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15029                                  ;
 15030                                  ;		If failure,
 15031                                  ;		CY = set
 15032                                  ;		DOS Get Extended Error call will get error
 15033                                  ;
 15034                                  ;	USED	AX,CX,DX,SI,DI,BP
 15035                                  ;
 15036                                  ;	EFFECTS
 15037                                  ;
 15038                                  ;	  DirBuf is used for find first/next calls.
 15039                                  ;
 15040                                  ;	NOTES
 15041                                  ;
 15042                                  ;	  We keep on checking files until DOS returns an error. If
 15043                                  ;	  the error is 'no more files' and the temp filename is not
 15044                                  ;	  the initial high tag, copy the temp to the child's name spot
 15045                                  ;	  and return success. Otherwise, send the error back to caller.
 15046                                  ;
 15047                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15048                                  
 15049                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15050                                  FindNextChild:
 15051 00001450 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15052                                  	;shove	00FFh			; temp filename = high tag
 15053 00001453 B8FF00                  	mov	ax,0FFh
 15054 00001456 50                      	push	ax
 15055 00001457 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15056                                  	;shove	"*"	
 15057 00001459 B02A                    	mov	al,'*'  ; ax = 002Ah
 15058 0000145B 50                      	push	ax
 15059                                  	;;shove	".*" 
 15060                                  	;mov	ax,"*."
 15061                                  	;mov	ax,2E2Ah
 15062 0000145C B42E                    	mov	ah,'.'
 15063 0000145E 50                      	push	ax
 15064 0000145F E8FA04                  	call	GetDriveLtr		; AX = "d:"
 15065 00001462 50                      	push	ax
 15066 00001463 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15067                                  
 15068                                  ;	See that the stack is restored properly at the end of this proc.
 15069                                  
 15070                                  	;mov	cx,10h
 15071 00001465 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15072 00001468 B44E                    	mov	ah,4Eh
 15073                                  	;mov	ah,Find_First
 15074 0000146A CD21                    	int	21h			; DOS- Find First matching file
 15075 0000146C 722C                    	jc	short fcRet		; return error
 15076                                  
 15077 0000146E E835FE                  	call	CheckChild		; check child against last, temp
 15078                                  fcNext:	
 15079                                  	;mov	cx,10h
 15080 00001471 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15081 00001474 B44F                    	mov	ah,4Fh
 15082                                  	;mov	ah,Find_Next
 15083 00001476 CD21                    	int	21h			; DOS- Find Next matching file
 15084 00001478 7205                    	jc	short fcErr		; examine error
 15085                                  
 15086 0000147A E829FE                  	call	CheckChild		; check child against last, temp
 15087 0000147D EBF2                    	jmp	short fcNext		; go find another child
 15088                                  
 15089                                  fcErr:
 15090 0000147F E88008                  	call	get_ext_error_number	; AX = extended error code
 15091                                  	;cmp	ax,18
 15092 00001482 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15093 00001485 7512                    	jne	short fcNope		; some other error- return it
 15094                                  
 15095                                  ;	We ran out of files. See if we qualified at least one.
 15096                                  
 15097 00001487 807E00FF                	cmp	byte [bp],0FFh
 15098 0000148B 740C                    	je	short fcNope		; temp filename is unused- no child
 15099                                  
 15100                                  ;	Move temp filename to child name position.
 15101                                  
 15102 0000148D 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15103 0000148F 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15104                                  fcMove:
 15105 00001491 AC                      	lodsb				; AL = next byte of filename
 15106 00001492 AA                      	stosb				; store byte
 15107 00001493 08C0                    	or	al,al
 15108 00001495 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15109 00001497 EBF8                    	jmp	short fcMove		; go move another byte
 15110                                  fcNope:
 15111 00001499 F9                      	stc				; return error
 15112                                  fcRet:
 15113 0000149A 9F                      	lahf
 15114 0000149B 83C414                  	add	sp,20			; restore stack
 15115 0000149E 9E                      	sahf
 15116 0000149F C3                      	retn
 15117                                  
 15118                                  ; ---------------------------------------------------------------------------
 15119                                  
 15120                                  ;***	FindOneInMem - find the first available entry in TPA
 15121                                  ;***	FindNextInMem - find the next available entry in TPA
 15122                                  ;
 15123                                  ;	ENTRY	ES = TPA seg addr
 15124                                  ;		BX = ptr to entry in TPA
 15125                                  ;
 15126                                  ;	EXIT	BX = ptr to entry found
 15127                                  ;		CY = set if no more entries available in TPA
 15128                                  ;
 15129                                  ;	USED	AL
 15130                                  
 15131                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15132                                  FindOneInMem:
 15133 000014A0 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15134 000014A3 3C01                    	cmp	al,1
 15135 000014A5 7406                    	je	short FindNextInMem	; entry has already been used
 15136 000014A7 3CFF                    	cmp	al,0FFh
 15137 000014A9 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15138                                  
 15139                                  ;	BX = ptr to entry that hasn't been output yet.
 15140                                  
 15141 000014AB F8                      	clc				; return success
 15142 000014AC C3                      	retn
 15143                                  
 15144                                  FindNextInMem:
 15145 000014AD 83C315                  	add	bx,21
 15146                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15147 000014B0 EBEE                    	jmp	short FindOneInMem	; go look at it
 15148                                  foNoMore:
 15149 000014B2 F9                      	stc				; ran out of entries, return failure
 15150 000014B3 C3                      	retn
 15151                                  
 15152                                  ; ---------------------------------------------------------------------------
 15153                                  
 15154                                  ;***	GetEnvValue - get value of our environment variable
 15155                                  ;
 15156                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15157                                  ;
 15158                                  ;	EXIT	CY = set if environment variable not in environment
 15159                                  ;
 15160                                  ;		Otherwise:
 15161                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15162                                  ;
 15163                                  ;	USED	AX,BX,CX,DX,DI
 15164                                  ;		(We assume the (almost) worst, since we don't know about
 15165                                  ;		Find_Name_In_Environment.)
 15166                                  ;
 15167                                  ;	EFFECTS
 15168                                  ;
 15169                                  ;	  ScanBuf is loaded with value text
 15170                                  
 15171                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15172                                  GetEnvValue:
 15173 000014B4 06                      	push	es				; save ES
 15174                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15175 000014B5 BE[D981]                	mov	si,DirEnvVar
 15176                                  	;invoke	Find_Name_In_Environment
 15177 000014B8 E85F0E                  	call	find_name_in_environment
 15178 000014BB 7214                    	jc	short geRet			; name not found in environment
 15179                                  
 15180                                  ;	ES:DI = ptr to value of environment variable
 15181                                  ;	We're assuming DS, CS, and SS are unchanged.
 15182                                  
 15183 000014BD 1E                      	push	ds
 15184 000014BE 06                      	push	es
 15185 000014BF 1F                      	pop	ds
 15186 000014C0 07                      	pop	es
 15187                                  
 15188                                  	;assume	ds:nothing
 15189                                  
 15190                                  ;	DS = seg addr of environment variable value (in environment segment)
 15191                                  ;	ES = TRANGROUP seg addr
 15192                                  
 15193 000014C1 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15194                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15195 000014C3 BF[898D]                	mov	di,ScanBuf
 15196                                  geLoop:
 15197                                  ;@@:	
 15198 000014C6 AC                      	lodsb
 15199 000014C7 08C0                    	or	al,al
 15200 000014C9 AA                      	stosb
 15201                                  	;loopnz	@B		; move the string, including trailing null
 15202 000014CA E0FA                    	loopnz	geLoop
 15203                                  
 15204 000014CC 06                      	push	es
 15205 000014CD 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15206                                  	;assume	ds:TRANGROUP
 15207                                  
 15208                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15209 000014CE BE[898D]                	mov	si,ScanBuf
 15210                                  geRet:
 15211 000014D1 07                      	pop	es				; restore ES
 15212 000014D2 C3                      	retn
 15213                                  
 15214                                  ; ---------------------------------------------------------------------------
 15215                                  
 15216                                  ;***	GetFirst - get first directory entry from disk
 15217                                  ;
 15218                                  ;	ENTRY	DOS DTA established at DirBuf
 15219                                  ;		FCB contains drive # and filename
 15220                                  ;		Current directory (on selected drive) is the one to search
 15221                                  ;		AttrSpecified & AttrSelect masks set
 15222                                  ;
 15223                                  ;	EXIT	CY = clear if success
 15224                                  ;		DirBuf contains extended FCB for file found
 15225                                  ;
 15226                                  ;		If unsuccessful,
 15227                                  ;		CY = set
 15228                                  ;		Ready for DOS Get Extended Error call
 15229                                  ;
 15230                                  ;	USED	AX,DX
 15231                                  ;
 15232                                  ;	EFFECTS
 15233                                  ;
 15234                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15235                                  ;	  FCB-1 = attribute mask to find all files
 15236                                  ;	  These fields should remain unmodified for GetNext calls.
 15237                                  ;
 15238                                  ;***	GetNext - get next directory entry from disk
 15239                                  ;
 15240                                  ;	ENTRY	As for GetFirst, plus
 15241                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15242                                  ;
 15243                                  ;	EXIT	As for GetFirst
 15244                                  ;
 15245                                  ;	USED	AX,DX
 15246                                  
 15247                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15248                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15249                                  GetFirst:
 15250                                  	;mov	byte [55h],0FFh	; -1
 15251 000014D3 C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15252                                  	;mov	byte [5Bh],16h
 15253 000014D8 C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15254                                  					; find any file
 15255                                  	; 07/06/2023
 15256                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15257 000014DD B411                    	mov	ah,11h
 15258                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15259                                  	; 07/06/2023
 15260                                  	;int	21h			; call DOS
 15261                                  	;shl	al,1			; CY = set if error
 15262                                  	;jc	short gfRet		; return error
 15263                                  	;jmp	short gfFound		; go look at attr's
 15264                                  	; 07/06/2023
 15265 000014DF EB02                    	jmp	short GetFrstNxt
 15266                                  GetNext:
 15267                                  	; 07/06/2023
 15268                                  	;;mov	dx,55h
 15269                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15270 000014E1 B412                    	mov	ah,12h
 15271                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15272                                  GetFrstNxt:
 15273                                  	; 07/06/2023
 15274 000014E3 BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15275                                  	;
 15276 000014E6 CD21                    	int	21h			; call DOS
 15277 000014E8 D0E0                    	shl	al,1			; CY = set if error
 15278 000014EA 7211                    	jc	short gfRet		; return error
 15279                                  
 15280                                  ;*	Found an entry. Check attributes.
 15281                                  gfFound:
 15282                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15283                                  	;mov	al,[DIRBUF+19]
 15284 000014EC A0[DC8B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15285 000014EF 8A26[238C]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15286 000014F3 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15287 000014F5 2226[248C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15288 000014F9 38E0                    	cmp	al,ah
 15289 000014FB 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15290                                  gfRet:
 15291 000014FD C3                      	retn
 15292                                  
 15293                                  ; ---------------------------------------------------------------------------
 15294                                  
 15295                                  ;***	ListDir - search for and list files in the current directory
 15296                                  ;
 15297                                  ;	List header, files, and trailer for current directory on selected
 15298                                  ;	drive. Header & trailer are listed if at least one file is found.
 15299                                  ;	If no qualifying files are found, no display output occurs.
 15300                                  ;
 15301                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15302                                  ;		FCB contains selected drive # and filename spec
 15303                                  ;		Option bits, attribute masks, and sort codes set up
 15304                                  ;
 15305                                  ;	EXIT	CY = clear if no error
 15306                                  ;		FileCnt = # files found & displayed
 15307                                  ;
 15308                                  ;		If error,
 15309                                  ;		CY = set
 15310                                  ;		Ready for DOS Get Extended Error call
 15311                                  ;
 15312                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15313                                  ;		FileSiz
 15314                                  ;
 15315                                  ;	EFFECTS
 15316                                  ;
 15317                                  ;	  FileCntTotal, FileSizTotal are updated.
 15318                                  ;	  Files found are listed. A directory header and trailer are
 15319                                  ;	   displayed only if files are found.
 15320                                  
 15321                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15322                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15323                                  
 15324                                  ListDir:
 15325 000014FE 31C0                    	xor	ax,ax
 15326 00001500 A3[EC8A]                	mov	[FileCnt],ax		; zero file count
 15327 00001503 A3[EE8A]                	mov	[FileSiz],ax		; zero file size accumulator
 15328 00001506 A3[F08A]                	mov	[FileSiz+2],ax
 15329 00001509 803E[CC8C]00            	cmp	byte [DestBuf],0	; check for sort code
 15330 0000150E 740A                    	je	short ld1		; no sort
 15331 00001510 E83000                  	call	LoadEntries		; load entries for sorted listing
 15332 00001513 7305                    	jnc	short ld1		; no error - continue
 15333 00001515 E8EA07                  	call	get_ext_error_number	; AX = DOS error code
 15334                                  	; 19/02/2023
 15335                                  	;stc
 15336 00001518 EB12                    	jmp	short ldErr		; return error
 15337                                  ld1:
 15338 0000151A E8DFFE                  	call	FindFirst		; find first file
 15339 0000151D 720D                    	jc	short ldErr		; not found, return error
 15340                                  
 15341                                  ;	BX = offset in TPA buffer of entry found
 15342                                  
 15343 0000151F E8E102                  	call	DisplayHeader		; if at least one file, display header
 15344                                  ldNext:
 15345 00001522 E8B902                  	call	DisplayFile		; display the file entry
 15346                                  ;ldNext:
 15347 00001525 E8D9FE                  	call	FindNext		; find another file
 15348 00001528 7202                    	jc	short ldErr		; not found
 15349                                  	;call	DisplayFile		; display entry
 15350                                  	;jmp	short ldNext		; go find another one
 15351                                  	; 19/02/2023
 15352 0000152A EBF6                    	jmp	short ldNext
 15353                                  ldErr:
 15354                                  	;cmp	ax,2
 15355 0000152C 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15356 0000152F 7407                    	je	short ldDone		; file not found, we're done
 15357                                  	;cmp	ax,18
 15358 00001531 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15359 00001534 7402                    	je	short ldDone		; no more files, we're done
 15360 00001536 F9                      	stc
 15361                                  	;jmp	short ldRet
 15362                                  	; 19/02/2023
 15363 00001537 C3                      	retn
 15364                                  ldDone:
 15365 00001538 833E[EC8A]00            	cmp	word [FileCnt],0
 15366                                  	;je	short ld2		; no files found, just return
 15367                                  	; 25/04/2023
 15368 0000153D 7403                    	jz	short ldRet
 15369 0000153F E8CA03                  	call	DisplayTrailer		; display trailing info
 15370                                  	; 08/06/2023
 15371                                  	; cf=0
 15372                                  ;ld2:	
 15373                                  	;clc				; return success
 15374                                  ldRet:
 15375 00001542 C3                      	retn
 15376                                  
 15377                                  ; ---------------------------------------------------------------------------
 15378                                  
 15379                                  ;***	LoadEntries - attempt to load entries from current directory
 15380                                  ;
 15381                                  ;	Load all qualifying directory entries from the current directory
 15382                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15383                                  ;	other than 'no more files', return to caller with carry flag set.
 15384                                  ;	If we run out of buffer space, display a message that we haven't
 15385                                  ;	enough memory to sort this directory, but return without error.
 15386                                  ;	Other routines know whether or not entries have been loaded by
 15387                                  ;	the 'inmem' flag bit, which we set here.
 15388                                  ;
 15389                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15390                                  ;	this allows sorting over 3000 entries in a directory.
 15391                                  ;
 15392                                  ;	ENTRY	Tpa = buffer seg addr
 15393                                  ;		BytCnt = buffer length, in bytes
 15394                                  ;		Current directory (on selected drive) is the one to load
 15395                                  ;		FCB contains drive # and filespec
 15396                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15397                                  ;
 15398                                  ;	EXIT	CY = set if error
 15399                                  ;		If error, DOS Get Extended Error will get error info
 15400                                  ;
 15401                                  ;	USED	AX,CX,DX,SI,DI
 15402                                  ;
 15403                                  ;	EFFECTS
 15404                                  ;
 15405                                  ;	  Inmem bit of Bits = set if load succeeded.
 15406                                  ;	  Tpa buffer contains directory entries.
 15407                                  ;	  Byte after last entry = 0FFh.
 15408                                  
 15409                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15410                                  LoadEntries:
 15411 00001543 06                      	push	es			; save TRANGROUP seg addr
 15412 00001544 8E06[C28A]              	mov	es,[TPA]		; ES = TPA seg addr
 15413 00001548 31FF                    	xor	di,di			; ES:DI = destination ptr
 15414                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15415                                  	;;and	word [_Bits],0FFDFh
 15416                                  	;and	byte [_Bits],0DFh	; not 20h
 15417 0000154A 8026[1B8C]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15418                                  
 15419 0000154F E881FF                  	call	GetFirst		; look for first file
 15420 00001552 7221                    	jc	short leRet		; return any error
 15421 00001554 E82000                  	call	LoadEntry		; load entry into TPA
 15422                                  leNext:
 15423 00001557 E887FF                  	call	GetNext			; get another file
 15424 0000155A 720F                    	jc	short leLoaded		; assume any error is no more files
 15425 0000155C A1[E18A]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15426 0000155F 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15427                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15428 00001561 83F817                  	cmp	ax,23 ; 21+2 
 15429 00001564 720E                    	jb	short leOk		; not enough memory left, give up
 15430 00001566 E80E00                  	call	LoadEntry		; load entry into TPA
 15431 00001569 EBEC                    	jmp	short leNext		; go get another file
 15432                                  
 15433                                  leLoaded:
 15434 0000156B 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15435                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15436                                  	;;or	word [_Bits],20h
 15437                                  	;or	byte [_Bits],20h
 15438 0000156F 800E[1B8C]20            	or	byte [_Bits],mask.inmem
 15439                                  	; 25/04/2023
 15440                                  	; cf = 0
 15441                                  leOk:
 15442 00001574 F8                      	clc				; return no error
 15443                                  leRet:
 15444 00001575 07                      	pop	es			; ES = TRANGROUP seg addr again
 15445 00001576 C3                      	retn
 15446                                  
 15447                                  
 15448                                  ; ---------------------------------------------------------------------------
 15449                                  
 15450                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15451                                  ;
 15452                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15453                                  ;		DirBuf contains extended FCB of entry to load
 15454                                  ;
 15455                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15456                                  ;
 15457                                  ;	USED	AX,CX,SI
 15458                                  ;
 15459                                  ;	NOTES
 15460                                  ;
 15461                                  ;	  I could've used symbolic offsets and sizes of fields from
 15462                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15463                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15464                                  ;	   as well as our private directory entry structure.
 15465                                  ;
 15466                                  ;	  We force a zero size for subdirectory files. A zero size is
 15467                                  ;	   ordinarily returned for subdirectories, but with Novell
 15468                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15469                                  
 15470                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15471                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15472                                  LoadEntry:
 15473                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15474 00001577 BE[D18B]                	mov	si,DIRBUF+8
 15475 0000157A 30C0                    	xor	al,al				; AL = 0
 15476 0000157C AA                      	stosb					; 'used' byte = false
 15477 0000157D B90B00                  	mov	cx,11
 15478 00001580 F3A4                    	rep	movsb				; transfer filename & extension
 15479 00001582 AC                      	lodsb					; AL = attrib byte
 15480 00001583 AA                      	stosb					; store attrib byte
 15481                                  	;add	si,10 ; 22-11-1
 15482                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15483 00001584 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15484 00001587 A5                      	movsw					; transfer time
 15485 00001588 A5                      	movsw					; transfer date
 15486 00001589 46                      	inc	si				; skip alloc unit
 15487 0000158A 46                      	inc	si
 15488                                  	;and	al,10h
 15489 0000158B 2410                    	and	al,ATTR_DIRECTORY
 15490 0000158D 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15491 0000158F A5                      	movsw
 15492 00001590 A5                      	movsw					; transfer size
 15493 00001591 C3                      	retn
 15494                                  leSetDirSize:
 15495 00001592 31C0                    	xor	ax,ax ; 0
 15496 00001594 AB                      	stosw
 15497 00001595 AB                      	stosw					; store zero size
 15498 00001596 C3                      	retn
 15499                                  
 15500                                  ; ---------------------------------------------------------------------------
 15501                                  
 15502                                  ;***	NoOrder - turn sorting off
 15503                                  ;
 15504                                  ;	ENTRY	nothing
 15505                                  ;
 15506                                  ;	EXIT	CY clear
 15507                                  ;
 15508                                  ;	USED	AX
 15509                                  ;
 15510                                  ;	EFFECTS
 15511                                  ;
 15512                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15513                                  
 15514                                  	; 19/02/2023
 15515                                  NoOrder:
 15516 00001597 C606[CC8C]00            	mov	byte [DestBuf],0
 15517                                  				; no sort
 15518 0000159C F8                      	clc			; no error
 15519 0000159D C3                      	retn
 15520                                  
 15521                                  ; ---------------------------------------------------------------------------
 15522                                  
 15523                                  ;***	OnOffSw - record occurence of on/off option switch
 15524                                  ;
 15525                                  ;	ENTRY	DI = index into word list of switches
 15526                                  ;
 15527                                  ;	EXIT	CY clear
 15528                                  ;
 15529                                  ;	USED	AX,CX
 15530                                  ;
 15531                                  ;	EFFECTS
 15532                                  ;
 15533                                  ;	  Bits modified to indicate option state.
 15534                                  
 15535                                  	; 19/02/2023
 15536                                  OnOffSw:
 15537 0000159E 89F9                    	mov	cx,di		; CX = index into word list of options
 15538 000015A0 D1E9                    	shr	cx,1
 15539 000015A2 D1E9                    	shr	cx,1		; CX = bit position of option
 15540 000015A4 B80100                  	mov	ax,1		
 15541 000015A7 D3E0                    	shl	ax,cl		; AX = bit mask of option
 15542 000015A9 F7C70200                	test	di,2		; check if it is a negated option
 15543 000015AD 7405                    	jz	short oo1	; it's negated
 15544                                  	;or	Bits,ax		; turn option on
 15545 000015AF 0906[1B8C]              	or	[_Bits],ax
 15546                                  	;jmp	short ooRet
 15547                                  	; 19/02/2023
 15548                                  	;cf=0
 15549 000015B3 C3                      	retn
 15550                                  oo1:	
 15551 000015B4 F7D0                    	not	ax		; AX = complemented bit mask of option
 15552                                  	;and	Bits,ax		; turn option off
 15553 000015B6 2106[1B8C]              	and	[_Bits],ax
 15554                                  ooRet:
 15555                                  	; 19/02/2023
 15556                                  	;cf=0
 15557                                  	;clc			; always return success
 15558 000015BA C3                      	retn
 15559                                  
 15560                                  ; ---------------------------------------------------------------------------
 15561                                  
 15562                                  ;***	ParseAttr - parse and record /A option
 15563                                  ;
 15564                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15565                                  ;
 15566                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15567                                  ;
 15568                                  ;		For parse error, we set up for Std_EPrintf call:
 15569                                  ;		AX = parse error code, like system parser
 15570                                  ;		DX = ptr to message block
 15571                                  ;
 15572                                  ;	USED	AX,CX,DX,DI
 15573                                  ;
 15574                                  ;	EFFECTS
 15575                                  ;
 15576                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15577                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15578                                  ;
 15579                                  ;	  For parse error, we set up for Std_EPrintf call:
 15580                                  ;	  Msg_Disp_Class = parse error message class
 15581                                  ;	  Message block (see DX) is set up for parse error message
 15582                                  
 15583                                  	; 19/02/2023
 15584                                  ParseAttr:
 15585 000015BB 56                      	push	si			; save SI
 15586 000015BC C606[238C]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15587                                  
 15588                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15589                                  
 15590                                  	;;mov	si,word ptr [bx].ValuePtr
 15591                                  					; SI = ptr to string after /A
 15592                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15593 000015C1 8B7704                  	mov	si,[bx+4]
 15594                                  paLoop:	
 15595 000015C4 BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15596 000015C7 AC                      	lodsb				; AL = next char in string
 15597 000015C8 08C0                    	or	al,al
 15598                                  	;jz	short paOk		; it's terminating null, we're done
 15599                                  	; 19/02/2023
 15600 000015CA 742F                    	jz	short paRet ; cf=0
 15601 000015CC 3C2D                    	cmp	al,'-'
 15602 000015CE 7502                    	jne	short pa1		; not '-', go look for letter
 15603 000015D0 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15604 000015D1 AC                      	lodsb				; AL = next char
 15605                                  pa1:	
 15606                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15607                                  					; DI = ptr to attrib letter list
 15608 000015D2 BF[9184]                	mov	di,AttrLtrs ; "RHSvDA"
 15609                                  	;mov	cx,6
 15610 000015D5 B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15611 000015D8 F2AE                    	repne	scasb			; look for our letter in the list
 15612 000015DA 751B                    	jne	short paErr		; not found, return error
 15613                                  
 15614 000015DC F7D1                    	not	cx
 15615                                  	;add	cx,6
 15616 000015DE 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15617                                  
 15618                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15619                                  ;	starting from bit 0.
 15620                                  
 15621                                  ;	Record this attribute bit in AttrSpecified.
 15622                                  
 15623 000015E1 B001                    	mov	al,1
 15624 000015E3 D2E0                    	shl	al,cl			; AL = mask for our bit
 15625 000015E5 0806[238C]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15626                                  
 15627                                  ;	Record the selected state for this attribute in AttrSelect.
 15628                                  ;	DX = 0 or 1, the selected state for this attribute.
 15629                                  
 15630 000015E9 F6D0                    	not	al			; AL = mask for all other bits
 15631 000015EB 2006[248C]              	and	[AttrSelect],al		; clear our bit
 15632 000015EF D2E2                    	shl	dl,cl			; DL = our bit state in position
 15633 000015F1 0816[248C]              	or	[AttrSelect],dl		; set selected attr state
 15634 000015F5 EBCD                    	jmp	short paLoop		; go look at next char
 15635                                  
 15636                                  ;	The attribute letter string is invalid.
 15637                                  
 15638                                  paErr:	
 15639 000015F7 E87303                  	call	SetupParamError		; set message up for Std_EPrintf
 15640 000015FA F9                      	stc		   		; return error
 15641                                  	; 19/02/2023
 15642                                  	;jmp	short paRet
 15643                                  ;paOk:
 15644                                  	;clc				; return success		
 15645                                  paRet:	
 15646 000015FB 5E                      	pop	si			; restore SI
 15647 000015FC C3                      	retn
 15648                                  
 15649                                  ; ---------------------------------------------------------------------------
 15650                                  
 15651                                  ;***	ParseLine - parse a line of text
 15652                                  ;
 15653                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15654                                  ;	error occurs.
 15655                                  ;
 15656                                  ;	ENTRY	DS:SI = ptr to text
 15657                                  ;		CS, DS, ES = TRANGROUP seg addr
 15658                                  ;
 15659                                  ;	EXIT	AX = last return code from system parser
 15660                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15661                                  ;
 15662                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15663                                  ;		DX = ptr to message block
 15664                                  ;
 15665                                  ;	USED	BX,CX,DX,SI,DI
 15666                                  ;
 15667                                  ;	EFFECTS
 15668                                  ;
 15669                                  ;	  Bits may contain new option settings.
 15670                                  ;	  DestBuf may contain new series of sort codes.
 15671                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15672                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15673                                  ;	  PathPos, PathCnt updated for new pathname.
 15674                                  ;
 15675                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15676                                  ;	  Msg_Disp_Class = parse error class
 15677                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15678                                  ;	  Message block (see DX) is set up for parse error message
 15679                                  
 15680                                  	; 19/02/2023
 15681                                  Parse_Line:
 15682                                  	; 04/05/2023
 15683 000015FD BF[5E85]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15684 00001600 31C9                    	xor	cx,cx			; CX = # positionals found
 15685                                  plPars:
 15686 00001602 E8B90B                  	call	Parse_With_Msg		; call parser
 15687 00001605 83F8FF                  	cmp	ax,-1
 15688                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15689 00001608 7411                    	je	short plRet		; EOL encountered, return
 15690 0000160A 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15691 0000160D 750C                    	jne	short plRet		; parse error occurred, return
 15692                                  
 15693                                  ;	Parse call succeeded. We have a filespec or a switch.
 15694                                  ;	DX = ptr to result buffer
 15695                                  
 15696 0000160F 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15697 00001611 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15698 00001614 7406                    	je	short plFil		; we have a filespec
 15699                                  
 15700 00001616 E85900                  	call	ParseSwitch		; else we have a switch
 15701                                  	;jc	short plRet		; error parsing switch, return
 15702                                  	;jmp	short plPars		; parse more
 15703                                  	; 19/02/2023
 15704 00001619 73E7                    	jnc	short plPars
 15705                                  plRet:
 15706 0000161B C3                      	retn	
 15707                                  plFil:	
 15708 0000161C E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15709 0000161F EBE1                    	jmp	short plPars		; parse more
 15710                                  ;plRet:
 15711                                  ;	retn
 15712                                  
 15713                                  ; ---------------------------------------------------------------------------
 15714                                  
 15715                                  ;***	ParseOrder - parse and record /O option
 15716                                  ;
 15717                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15718                                  ;
 15719                                  ;	EXIT	CY = set if error occurs parsing order
 15720                                  ;
 15721                                  ;		For parse error, we set up for Std_EPrintf call:
 15722                                  ;		AX = parse error code, like system parser
 15723                                  ;		DX = ptr to message block
 15724                                  ;
 15725                                  ;	USED	AX,CX,DX,DI
 15726                                  ;
 15727                                  ;	EFFECTS
 15728                                  ;
 15729                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15730                                  ;
 15731                                  ;	  For parse error, we set up for Std_EPrintf call:
 15732                                  ;	  Msg_Disp_Class = parse error message class
 15733                                  ;	  Message block (see DX) is set up for parse error message
 15734                                  
 15735                                  	; 19/02/2023
 15736                                  ParseOrder:
 15737 00001621 56                      	push	si			; save SI
 15738 00001622 53                      	push	bx			; save ptr to result buffer
 15739                                  
 15740                                  	;;mov	si,word ptr [bx].ValuePtr
 15741                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15742 00001623 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15743                                  	;mov	bx,offset TRANGROUP:DestBuf
 15744                                  	; 08/06/2023 (BugFix)
 15745 00001626 BB[CC8C]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 15746 00001629 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15747 0000162B 08C0                    	or	al,al
 15748 0000162D 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15749                                  
 15750                                  ;	We have /O alone. Set standard sort order.
 15751                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15752                                  
 15753 0000162F C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15754 00001632 43                      	inc	bx
 15755 00001633 C60701                  	mov	byte [bx],1		; then by name
 15756 00001636 43                      	inc	bx
 15757 00001637 C60702                  	mov	byte [bx],2		; then by extension
 15758 0000163A 43                      	inc	bx
 15759 0000163B EB2F                    	jmp	short poOk		; return success
 15760                                  
 15761                                  ;	We have /O<something>. Parse sort order letters.
 15762                                  
 15763                                  poLtr:	
 15764 0000163D 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15765 0000163F AC                      	lodsb				; AL = next sort order letter
 15766 00001640 08C0                    	or	al,al
 15767 00001642 7428                    	jz	short poOk		; NUL found, return success
 15768                                  
 15769 00001644 3C2D                    	cmp	al,'-'
 15770 00001646 7503                    	jne	short po1		; not '-', go look for letter
 15771 00001648 B280                    	mov	dl,80h			; DL = downward sort mask
 15772 0000164A AC                      	lodsb				; AL = next char
 15773                                  po1:
 15774                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15775                                  	; 08/06/2023 (BugFix)
 15776 0000164B BF[9784]                	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
 15777 0000164E B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15778 00001651 F2AE                    	repne	scasb			; look for our letter in the list
 15779 00001653 7510                    	jne	short poErr		; not found, return error
 15780                                  
 15781 00001655 F7D9                    	neg	cx
 15782 00001657 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15783                                  
 15784 0000165A 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15785 0000165C 880F                    	mov	[bx],cl			; store sort order code in buffer
 15786 0000165E 43                      	inc	bx			; BX = ptr to next spot in buffer
 15787                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15788 0000165F 81FB[238D]              	cmp	bx,EndDestBuf
 15789                                  	;jae	short poErr		; too many letters
 15790                                  	;
 15791                                  	;jmp	short poLtr		; go look at next char
 15792                                  	; 19/02/2023
 15793 00001663 72D8                    	jb	short poLtr
 15794                                  
 15795                                  ;	The sort order string is invalid.  
 15796                                  
 15797                                  poErr:
 15798 00001665 5B                      	pop	bx			; BX = ptr to result buffer
 15799 00001666 E80403                  	call	SetupParamError		; set message up for Std_EPrintf
 15800 00001669 F9                      	stc				; return failure
 15801 0000166A EB04                    	jmp	short poRet
 15802                                  poOk:	
 15803 0000166C C60700                  	mov	byte [bx],0		; mark end of sort code list
 15804 0000166F 5B                      	pop	bx			; BX = ptr to result buffer
 15805                                  	; 19/02/2023
 15806                                  	;cf=0
 15807                                  	;clc				; return success
 15808                                  poRet:
 15809 00001670 5E                      	pop	si			; restore SI
 15810 00001671 C3                      	retn
 15811                                  
 15812                                  ; ---------------------------------------------------------------------------
 15813                                  
 15814                                  ;***	ParseSwitch - parse a switch
 15815                                  ;
 15816                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15817                                  ;		     a switch
 15818                                  ;
 15819                                  ;	EXIT	CY = set if parse error occurred
 15820                                  ;
 15821                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15822                                  ;		AX = parse error code, like system parser
 15823                                  ;		DX = ptr to message block
 15824                                  ;
 15825                                  ;	USED	AX,BX,DX
 15826                                  ;
 15827                                  ;	EFFECTS
 15828                                  ;
 15829                                  ;	  Bits may contain new option settings.
 15830                                  ;	  DestBuf may contain new series of sort codes.
 15831                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15832                                  ;
 15833                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15834                                  ;	  Msg_Disp_Class = parse error class
 15835                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15836                                  ;	  Message block (see DX) is set up for parse error message
 15837                                  
 15838                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15839                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 15840                                  ParseSwitch:
 15841 00001672 51                      	push	cx			; save CX
 15842 00001673 57                      	push	di			; save DI
 15843                                  
 15844                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 15845                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 15846 00001674 8B4702                  	mov	ax,[bx+2]
 15847                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 15848 00001677 BF[AE85]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 15849 0000167A B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 15850 0000167D FC                      	cld				; scan direction = upward
 15851 0000167E F2AF                    	repne	scasw			; locate synonym ptr in list
 15852                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 15853 00001680 81EF[B085]              	sub	di,Dir_Sw_Ptrs+2
 15854                                  
 15855                                  ;	DI = index into word list of synonym ptrs
 15856                                  
 15857 00001684 2EFF95[8C16]            	call	word [cs:di+SwHandler]	; use same index into call table
 15858                                  
 15859 00001689 5F                      	pop	di			; restore DI
 15860 0000168A 59                      	pop	cx			; restore CX
 15861                                  
 15862 0000168B C3                      	retn
 15863                                  
 15864                                  ; ---------------------------------------------------------------------------
 15865                                  
 15866                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 15867                                  ;	Simple on/off switches must occur first in both lists, and must be
 15868                                  ;	  in order of option bits in Bits, starting with bit 0.
 15869                                  
 15870                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15871                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 15872                                  
 15873                                  SwHandler:
 15874 0000168C [9E15]                  	dw	OnOffSw		; /-W
 15875 0000168E [9E15]                  	dw	OnOffSw		; /W
 15876 00001690 [9E15]                  	dw	OnOffSw		; /-P
 15877 00001692 [9E15]                  	dw	OnOffSw		; /P
 15878 00001694 [9E15]                  	dw	OnOffSw		; /-S
 15879 00001696 [9E15]                  	dw	OnOffSw		; /S
 15880 00001698 [9E15]                  	dw	OnOffSw		; /-B
 15881 0000169A [9E15]                  	dw	OnOffSw		; /B
 15882 0000169C [9E15]                  	dw	OnOffSw		; /-L	;M010
 15883 0000169E [9E15]                  	dw	OnOffSw		; /L	;M010
 15884 000016A0 [9715]                  	dw	NoOrder		; /-O
 15885 000016A2 [2116]                  	dw	ParseOrder	; /O
 15886 000016A4 [7513]                  	dw	DefaultAttr	; /-A
 15887 000016A6 [BB15]                  	dw	ParseAttr	; /A
 15888                                  
 15889                                  ; ---------------------------------------------------------------------------
 15890                                  
 15891                                  	;break	<DIR utility routines>
 15892                                  
 15893                                  ;***	UTILITY ROUTINES
 15894                                  ; ---------------------- 
 15895                                  
 15896                                  ; ---------------------------------------------------------------------------
 15897                                  
 15898                                  ;***	ChangeDir - change directory on target drive
 15899                                  ;
 15900                                  ;	ENTRY	FCB contains drive #
 15901                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 15902                                  ;
 15903                                  ;	EXIT	Changed current directory on drive
 15904                                  ;
 15905                                  ;		If error,
 15906                                  ;		CY = set
 15907                                  ;		DOS Get Extended Error call will get error
 15908                                  ;
 15909                                  ;	USED	AX,DX,SI,DI
 15910                                  ;
 15911                                  ;	EFFECTS
 15912                                  ;
 15913                                  ;	  DirBuf is used to build "d:string".
 15914                                  
 15915                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15916                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 15917                                  
 15918                                  ChangeDir:
 15919                                  	;mov	di,offset TRANGROUP:DirBuf
 15920 000016A8 BF[C98B]                	mov	di,DIRBUF
 15921 000016AB E8AE02                  	call	GetDriveLtr	; AX = "d:"
 15922 000016AE AB                      	stosw			; put drive specifier in buffer
 15923 000016AF 89D6                    	mov	si,dx		; SI = ptr to argument string
 15924                                  cdLoop:
 15925 000016B1 AC                      	lodsb
 15926 000016B2 AA                      	stosb			; move byte to buffer
 15927 000016B3 08C0                    	or	al,al
 15928 000016B5 75FA                    	jne	short cdLoop	; continue until null transferred
 15929                                  
 15930                                  	;mov	dx,offset TRANGROUP:DirBuf
 15931 000016B7 BA[C98B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 15932                                  	;mov	ah,CHDir
 15933 000016BA B43B                    	mov	ah,3Bh
 15934 000016BC CD21                    	int	21h		; change directory
 15935 000016BE C3                      	retn			; return what CHDIR returns
 15936                                  
 15937                                  ; ---------------------------------------------------------------------------
 15938                                  
 15939                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 15940                                  ;
 15941                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 15942                                  ;		ES:DI = ptr to another ASCIIZ string
 15943                                  ;
 15944                                  ;	EXIT	flags set after REPE CMPSB
 15945                                  ;
 15946                                  ;	USED	AL,CX,SI,DI
 15947                                  ;
 15948                                  ;	NOTES
 15949                                  ;
 15950                                  ;	Maximum run of comparison is length of DS:SI string.
 15951                                  ;	This ensures that two identical strings followed by
 15952                                  ;	random characters will compare correctly.
 15953                                  
 15954                                  	; 19/02/2023
 15955                                  CmpAscz:
 15956                                  	; 07/06/2023
 15957 000016BF 56                      	push	si ; *
 15958                                  	;
 15959 000016C0 57                      	push	di
 15960                                  
 15961 000016C1 89F7                    	mov	di,si
 15962 000016C3 30C0                    	xor	al,al
 15963 000016C5 B9FFFF                  	mov	cx,0FFFFh
 15964 000016C8 F2AE                    	repne	scasb
 15965 000016CA F7D1                    	not	cx
 15966                                  
 15967 000016CC 5F                      	pop	di
 15968 000016CD F3A6                    	repe	cmpsb
 15969                                  
 15970                                  	; 07/06/2023
 15971 000016CF 5E                      	pop	si ; *
 15972                                  	;
 15973 000016D0 C3                      	retn
 15974                                  
 15975                                  ; ---------------------------------------------------------------------------
 15976                                  
 15977                                  ;***	CopyPathname - copy pathname to our buffer
 15978                                  ;
 15979                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15980                                  ;		     a filespec
 15981                                  ;
 15982                                  ;	EXIT	nothing
 15983                                  ;
 15984                                  ;	USED	AX
 15985                                  ;
 15986                                  ;	EFFECTS
 15987                                  ;
 15988                                  ;	  SrcBuf may contain a new pathname/filespec.
 15989                                  ;	  PathPos, PathCnt updated for new pathname.
 15990                                  
 15991                                  	; 19/02/2023
 15992                                  CopyPathname:
 15993 000016D1 56                      	push	si
 15994                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 15995                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 15996 000016D2 C57704                  	lds	si,[bx+4]
 15997                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 15998 000016D5 E8DE15                  	call	Move_To_SrcBuf
 15999 000016D8 5E                      	pop	si
 16000 000016D9 C3                      	retn
 16001                                  
 16002                                  ; ---------------------------------------------------------------------------
 16003                                  
 16004                                  ;***	CountFile - update counters with current file
 16005                                  ;
 16006                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16007                                  ;
 16008                                  ;	EXIT	nothing
 16009                                  ;
 16010                                  ;	USED	AX,DX
 16011                                  ;
 16012                                  ;	EFFECTS
 16013                                  ;
 16014                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16015                                  
 16016                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16017                                  CountFile:
 16018 000016DA 06                      	push	es			; save TRANGROUP seg addr
 16019 000016DB 8E06[C28A]              	mov	es,[TPA]		; ES = TPA seg addr
 16020                                  
 16021 000016DF FF06[EC8A]              	inc	word [FileCnt]		; # files this directory
 16022 000016E3 FF06[F28A]              	inc	word [FileCntTotal]	; # files total
 16023 000016E7 7504                    	jnz	short cntf1
 16024 000016E9 FF06[F48A]              	inc	word [FileCntTotal+2]
 16025                                  cntf1:
 16026                                  	;mov	ax,word ptr es:[bx].filesize
 16027                                  					; AX = low word of file size
 16028                                  	;mov	dx,word ptr es:[bx].filesize+2
 16029                                  					; DX = high word of file size
 16030 000016ED 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16031 000016F1 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16032 000016F5 0106[EE8A]              	add	[FileSiz],ax
 16033 000016F9 1116[F08A]              	adc	[FileSiz+2],dx		; size of this directory
 16034 000016FD 0106[F68A]              	add	[FileSizTotal],ax
 16035 00001701 1116[F88A]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16036                                  
 16037 00001705 07                      	pop	es			; ES = TRANGROUP seg addr again
 16038                                  dbRet:	; 19/02/2023
 16039 00001706 C3                      	retn
 16040                                  
 16041                                  ; ---------------------------------------------------------------------------
 16042                                  
 16043                                  ;***	DisplayBare - display filename in bare format
 16044                                  ;
 16045                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16046                                  ;
 16047                                  ;	EXIT	DX = # char's displayed, including dot
 16048                                  ;
 16049                                  ;	USED	AX,CX,SI,DI
 16050                                  ;
 16051                                  ;	EFFECTS
 16052                                  ;
 16053                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16054                                  ;	  If /s is on, complete pathname is displayed.
 16055                                  ;
 16056                                  ;	NOTE
 16057                                  ;
 16058                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16059                                  
 16060                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16061                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16062                                  
 16063                                  DisplayBare:
 16064                                  ;	Suppress . and .. files from bare listing.
 16065                                  
 16066 00001707 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16067 00001709 8E1E[C28A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16068                                  	;assume	ds:NOTHING
 16069                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16070 0000170D 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16071 00001711 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16072                                  	;assume	ds:TRANGROUP
 16073 00001713 74F1                    	je	short dbRet		; it's . or .. - don't display
 16074                                  
 16075                                  	;;;test	Bits,mask subd
 16076                                  	;;test	word [_Bits],4
 16077                                  	;test	byte [_Bits],4
 16078 00001715 F606[1B8C]04            	test	byte [_Bits],mask.subd
 16079 0000171A 7431                    	jz	short dbNameExt		; not /s - display filename only
 16080                                  
 16081                                  	;invoke	Build_Dir_String
 16082 0000171C E82C07                  	call	build_dir_string
 16083                                  	;mov	di,offset TRANGROUP:BwdBuf
 16084 0000171F BF[C98B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16085                                     
 16086                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16087                                  	;;test	word [_Bits],10h
 16088                                  	;test	byte [_Bits],10h
 16089 00001722 F606[1B8C]10            	test	byte [_Bits],mask.lcase
 16090                                  	;jz	@F			;M010;lowercase not needed
 16091 00001727 7405                    	jz	short dbare1
 16092 00001729 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16093 0000172B E88002                  	call	LowercaseString		;M010;path string is in BwdBuf
 16094                                  dbare1:
 16095                                  ;@@:	
 16096                                  	;xor	al,al			; AL = 0
 16097                                  	; 19/02/2023
 16098 0000172E 31C0                    	xor	ax,ax
 16099 00001730 B9FFFF                  	mov	cx,0FFFFh
 16100 00001733 FC                      	cld
 16101 00001734 F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16102 00001736 4F                      	dec	di			; ES:DI = ptr to null byte
 16103                                  
 16104 00001737 26807DFF5C              	cmp	byte [es:di-1],'\'
 16105                                  	;je	@F
 16106 0000173C 7403                    	je	short dbare2		; already terminated w/ '\'
 16107                                  
 16108                                  	;mov	ax,'\'			; AX = '\',0
 16109 0000173E B05C                    	mov	al,'\'
 16110 00001740 AB                      	stosw				; add to dir string
 16111                                  ;@@:
 16112                                  dbare2:
 16113                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16114 00001741 C706[B08C][C98B]        	mov	word [string_ptr_2],BWDBUF
 16115                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16116 00001747 BA[1C81]                	mov	dx,string_buf_ptr
 16117                                  	;invoke	Std_Printf		; display device & directory path
 16118 0000174A E8D636                  	call	std_printf
 16119                                  dbNameExt:
 16120 0000174D E82D00                  	call	DisplayDotForm		; display name.ext
 16121                                  	;invoke	CrLf2			; display cr/lf
 16122 00001750 E8860E                  	call	CRLF2
 16123                                  	; 19/02/2023
 16124                                  	;call	UseLine			;M007;Allow /p with /b
 16125                                  ;dbRet:
 16126                                  	;retn
 16127                                  
 16128                                  	; 19/02/2023
 16129                                  	;jmp	short UseLine
 16130                                  
 16131                                  ; ---------------------------------------------------------------------------
 16132                                  
 16133                                  ;***	UseLine - use a display line, start a new page if none left
 16134                                  ;
 16135                                  ;	ENTRY	nothing
 16136                                  ;
 16137                                  ;	EXIT	nothing
 16138                                  ;
 16139                                  ;	USED	flags
 16140                                  
 16141                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16142                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16143                                  UseLine:
 16144 00001753 FF0E[EA8A]              	dec	word [LeftOnPage]
 16145 00001757 833E[EA8A]02            	cmp	word [LeftOnPage],2
 16146 0000175C 771E                    	ja	short ulRet
 16147                                  	; 19/02/2023
 16148                                  	;call	EndPage
 16149                                  ;ulRet:
 16150                                  	;retn
 16151                                  
 16152                                  	; 19/02/2023
 16153                                  	;jmp	short EndPage
 16154                                  
 16155                                  ; ---------------------------------------------------------------------------
 16156                                  
 16157                                  ;***	EndPage - end the current display page
 16158                                  ;
 16159                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16160                                  ;		Current directory (on selected drive) is the one being listed
 16161                                  ;		Bits contains /p setting
 16162                                  ;
 16163                                  ;	EXIT	LeftOnPage = # lines left for next page
 16164                                  ;
 16165                                  ;	USED	AX,DX
 16166                                  ;
 16167                                  ;	EFFECTS
 16168                                  ;
 16169                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16170                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16171                                  
 16172                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16173                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16174                                  
 16175                                  EndPage:
 16176                                  	;;;test	Bits,mask pagd
 16177                                  	;;test	word [_Bits],2
 16178                                  	;test	byte [_Bits],2
 16179 0000175E F606[1B8C]02            	test	byte [_Bits],mask.pagd
 16180 00001763 7410                    	jz	short epNew		; paged display isn't enabled
 16181                                  
 16182 00001765 53                      	push	bx			; save BX
 16183 00001766 51                      	push	cx			; save CX
 16184                                  
 16185                                  	;invoke	Pause			; "Press any key to continue..."
 16186 00001767 E85502                  	call	PAUSE
 16187                                  
 16188                                  	;invoke	Build_Dir_String
 16189 0000176A E8DE06                  	call	build_dir_string
 16190                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16191 0000176D BA[9781]                	mov	dx,dircont_ptr
 16192                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16193 00001770 E8A236                  	call	Printf_Crlf
 16194                                  
 16195 00001773 59                      	pop	cx			; restore CX
 16196 00001774 5B                      	pop	bx			; restore BX
 16197                                  epNew:	
 16198 00001775 A1[168E]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16199 00001778 48                      	dec	ax			; AX = # lines till next EndPage
 16200 00001779 A3[EA8A]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16201                                  ulRet:	
 16202                                  	; 19/02/2023
 16203 0000177C C3                      	retn
 16204                                  
 16205                                  ; ---------------------------------------------------------------------------
 16206                                  
 16207                                  ;***	DisplayDotForm - display filename in compressed dot format
 16208                                  ;
 16209                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16210                                  ;	if the filename has a nonblank extension.
 16211                                  ;
 16212                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16213                                  ;
 16214                                  ;	EXIT	DX = # char's displayed, including dot
 16215                                  ;
 16216                                  ;	USED	AX,CX,SI,DI
 16217                                  ;
 16218                                  ;	EFFECTS
 16219                                  ;
 16220                                  ;	  Filename is displayed in name.ext format.
 16221                                  ;
 16222                                  ;	NOTE
 16223                                  ;
 16224                                  ;	  We allow for bogus filenames that have blanks embedded
 16225                                  ;	  in the name or extension.
 16226                                  
 16227                                  ;	Bugbug:	might be a good performance gain if we buffered
 16228                                  ;	up the output and used DOS function 9.
 16229                                  
 16230                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16231                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16232                                  
 16233                                  DisplayDotForm:
 16234 0000177D 1E                      	push	ds			; save TRANGROUP seg addr
 16235 0000177E 06                      	push	es			; save ES
 16236 0000177F 2EA1[C28A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16237 00001783 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16238                                  	;assume	ds:nothing
 16239 00001785 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16240                                  
 16241                                  	; 08/06/2023
 16242                                  	;mov	di,bx			; ES:DI = ptr to entry
 16243                                  	;;;add	di,filename + size filename - 1
 16244                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16245                                  	;;mov	cx,size filename	; CX = length of name field
 16246                                  	;mov	cx,8
 16247                                  	; 08/06/2023
 16248 00001787 B90800                  	mov	cx,8
 16249 0000178A 89CF                    	mov	di,cx
 16250 0000178C 01DF                    	add	di,bx	
 16251                                  	
 16252 0000178E B020                    	mov	al,' '
 16253 00001790 FD                      	std				; scan down
 16254 00001791 F3AE                    	repe	scasb			; scan for nonblank
 16255                                  
 16256                                  ;	Assume file name has at least one character.
 16257                                  
 16258 00001793 41                      	inc	cx			; CX = # chars in name
 16259 00001794 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16260                                  
 16261 00001796 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16262                                  	;;add	si,filename		; DS:SI = ptr to name
 16263                                  	;add	si,1 
 16264                                  	;		; add si,EntryStruc.filename
 16265                                  	; 25/04/2023
 16266 00001798 46                      	inc	si
 16267                                  NextNameChar:
 16268 00001799 FC                      	cld
 16269 0000179A AC                      	lodsb				; AL = next char
 16270                                  
 16271                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16272                                  	;;test	word [ss:_Bits],10h
 16273                                  	;test	byte [ss:_Bits],10h
 16274 0000179B 36F606[1B8C]10          	test	byte [ss:_Bits],mask.lcase
 16275                                  	;jz	short @F		;M010;lowercase not required
 16276 000017A1 7403                    	jz	short ddf1
 16277 000017A3 E8FD01                  	call	LowerCase		;M010;filename char is in AL
 16278                                  ddf1:
 16279                                  ;@@:	
 16280                                  	;invoke	Print_Char		; display it
 16281 000017A6 E85306                  	call	PRINT_CHAR
 16282 000017A9 E2EE                    	loop	NextNameChar
 16283                                  
 16284                                  ;	Now do extension.
 16285                                  
 16286 000017AB 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16287                                  	;add	di,fileext + size fileext - 1
 16288 000017AD 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16289                                  	;mov	cx,size fileext		; CX = length of ext field
 16290 000017B0 B90300                  	mov	cx,3
 16291 000017B3 B020                    	mov	al,' '
 16292 000017B5 FD                      	std				; scan down
 16293 000017B6 F3AE                    	repe	scasb			; scan for nonblank
 16294 000017B8 7420                    	je	short ddDone		; no nonblank chars in ext
 16295                                  
 16296 000017BA 41                      	inc	cx			; CX = # chars in ext
 16297 000017BB 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16298 000017BD 42                      	inc	dx			;      including dot
 16299                                  
 16300 000017BE B02E                    	mov	al,'.'
 16301 000017C0 E83906                  	call	PRINT_CHAR
 16302 000017C3 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16303                                  	;add	si,fileext		; DS:SI = ptr to ext
 16304 000017C5 83C609                  	add	si,9
 16305                                  
 16306                                  NextExtChar:
 16307 000017C8 FC                      	cld
 16308 000017C9 AC                      	lodsb				; AL = next char
 16309                                  
 16310                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16311                                  	;;test	word [cs:_Bits],10h
 16312                                  	;test	byte [cs:_Bits],10h
 16313 000017CA 2EF606[1B8C]10          	test	byte [cs:_Bits],mask.lcase
 16314                                  	;jz	short @F		;M010;lowercase not required
 16315 000017D0 7403                    	jz	short ddf2
 16316 000017D2 E8CE01                  	call	LowerCase		;M010;fileext char is in AL
 16317                                  ;@@:	
 16318                                  ddf2:
 16319                                  	;invoke	Print_Char		; display it
 16320 000017D5 E82406                  	call	PRINT_CHAR
 16321 000017D8 E2EE                    	loop	NextExtChar
 16322                                  ddDone:
 16323 000017DA 07                      	pop	es			; restore ES
 16324 000017DB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16325                                  	;assume	ds:TRANGROUP
 16326 000017DC FC                      	cld				; leave direction flag = up
 16327 000017DD C3                      	retn
 16328                                  
 16329                                  ; ---------------------------------------------------------------------------
 16330                                  
 16331                                  ;***	DisplayFile - display file entry, update counters
 16332                                  ;
 16333                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16334                                  ;		Bits contains /w, /p settings
 16335                                  ;
 16336                                  ;	EXIT	nothing
 16337                                  ;
 16338                                  ;	USED	AX,CX,DX,SI,DI,BP
 16339                                  ;
 16340                                  ;	EFFECTS
 16341                                  ;
 16342                                  ;	  Entry is displayed.  
 16343                                  ;	  If not /b,
 16344                                  ;	    Cursor is left at end of entry on screen.
 16345                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16346                                  ;	  If /b,
 16347                                  ;	    Cursor is left at beginning of next line.
 16348                                  ;	    Cnt's and Siz's aren't updated.
 16349                                  
 16350                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16351                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16352                                  
 16353                                  DisplayFile:
 16354                                  	;;;test	Bits,mask bare
 16355                                  	;;test	word [_Bits],8
 16356                                  	;test	byte [_Bits],8
 16357 000017DE F606[1B8C]08            	test	byte [_Bits],mask.bare
 16358 000017E3 7405                    	jz	short dfNorm		; not /b - do normal display
 16359                                  
 16360 000017E5 E81FFF                  	call	DisplayBare		; display file in bare format
 16361 000017E8 EB18                    	jmp	short dfRet
 16362                                  dfNorm:	
 16363 000017EA E87800                  	call	DisplayNext		; pos'n cursor for next entry
 16364                                  	;;;test	Bits,mask wide
 16365                                  	;;test	word [_Bits],1
 16366                                  	;test	byte [_Bits],1
 16367 000017ED F606[1B8C]01            	test	byte [_Bits],mask.wide
 16368 000017F2 7405                    	jz	short dfFull		; full format
 16369 000017F4 E83701                  	call	DisplayWide		; wide format
 16370 000017F7 EB06                    	jmp	short dfCnt
 16371                                  dfFull:	
 16372 000017F9 E83400                  	call	DisplayName		; display filename & extension
 16373 000017FC E88D00                  	call	DisplayTheRest		; display size, date, time
 16374                                  dfCnt:
 16375 000017FF E8D8FE                  	call	CountFile		; update file counters
 16376                                  dfRet:
 16377                                  dhRet:	; 19/02/2023
 16378 00001802 C3                      	retn
 16379                                  
 16380                                  ; ---------------------------------------------------------------------------
 16381                                  
 16382                                  ;***	DisplayHeader - display directory header of working directory
 16383                                  ;
 16384                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16385                                  ;		LeftOnPage = # lines left on display page
 16386                                  ;
 16387                                  ;	EXIT	nothing
 16388                                  ;
 16389                                  ;	ERROR EXIT
 16390                                  ;
 16391                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16392                                  ;	   specification" if there's a problem obtaining the current 
 16393                                  ;	   directory pathname.
 16394                                  ;
 16395                                  ;	USED	AX,DX,SI,DI
 16396                                  ;
 16397                                  ;	EFFECTS
 16398                                  ;
 16399                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16400                                  ;	   we are using for the DTA) contains the directory string.
 16401                                  ;	  LeftOnPage is adjusted.
 16402                                  
 16403                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16404                                  
 16405                                  DisplayHeader:
 16406                                  	;;;test	Bits,mask bare
 16407                                  	;;test	word [_Bits],8
 16408                                  	;test	byte [_Bits],8
 16409 00001803 F606[1B8C]08            	test	byte [_Bits],mask.bare
 16410 00001808 75F8                    	jnz	short dhRet		; /b - don't display header
 16411                                  
 16412                                  	;;;test	Bits,mask subd
 16413                                  	;;test	word [_Bits],4
 16414                                  	;test	byte [_Bits],4
 16415 0000180A F606[1B8C]04            	test	byte [_Bits],mask.subd
 16416 0000180F 7408                    	jz	short dhNorm		; not /s
 16417                                  
 16418                                  ;	For subdirectory listings, put a blank line before the header.
 16419                                  
 16420                                  	;invoke	Crlf2			; start with a blank line
 16421 00001811 E8C50D                  	call	CRLF2
 16422 00001814 E83CFF                  	call	UseLine
 16423 00001817 EB05                    	jmp	short dhCom
 16424                                  dhNorm:
 16425 00001819 B020                    	mov	al,' ' ; 20h
 16426                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16427 0000181B E8DE05                  	call	PRINT_CHAR		; print a leading blank
 16428                                  dhCom:
 16429 0000181E E82A06                  	call	build_dir_string
 16430 00001821 BA[9C80]                	mov	dx,dirhead_ptr
 16431 00001824 E8FC35                  	call	std_printf		; print header & cr/lf
 16432 00001827 E829FF                  	call	UseLine
 16433 0000182A E8AC0D                  	call	CRLF2			; another cr/lf
 16434                                  	;call	UseLine
 16435                                  ;dhRet:
 16436                                  	;retn
 16437                                  
 16438                                  	; 19/02/2023
 16439 0000182D E923FF                  	jmp	UseLine
 16440                                  
 16441                                  ; ---------------------------------------------------------------------------
 16442                                  
 16443                                  ;***	DisplayName - display file name & extension
 16444                                  ;
 16445                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16446                                  ;
 16447                                  ;	EXIT	nothing
 16448                                  ;
 16449                                  ;	USED	AX,CX,DX,SI,DI
 16450                                  ;
 16451                                  ;	EFFECTS
 16452                                  ;
 16453                                  ;	  Filename & extension are displayed in spread format.
 16454                                  ;	  Cursor is left at end of extension.
 16455                                  
 16456                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16457                                  	; 08/06/2023
 16458                                  DisplayName:
 16459 00001830 1E                      	push	ds			; save TRANGROUP seg addr
 16460 00001831 8E1E[C28A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16461                                  	;assume	ds:nothing
 16462 00001835 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16463                                  	;add	si,filename		; DS:SI = ptr to filename
 16464                                  	;add	si,1  ; EntryStruc.filename
 16465                                  	; 08/06/2023
 16466 00001837 46                      	inc	si
 16467 00001838 BF[FA8A]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16468                                  
 16469 0000183B B90800                  	mov	cx,8
 16470 0000183E FC                      	cld
 16471 0000183F F3A4                    	rep	movsb			; move filename to CharBuf
 16472 00001841 B020                    	mov	al,' '
 16473 00001843 AA                      	stosb				; add a blank
 16474                                  	;mov	cx,3
 16475                                  	; 08/06/2023
 16476 00001844 B103                    	mov	cl,3
 16477 00001846 F3A4                    	rep	movsb			; add extension
 16478 00001848 30C0                    	xor	al,al
 16479 0000184A AA                      	stosb				; add a NULL
 16480                                  
 16481 0000184B 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16482                                  	;assume	ds:TRANGROUP
 16483                                  
 16484                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16485                                  	;;test	word [_Bits],10h
 16486                                  	;test	byte [_Bits],10h
 16487 0000184C F606[1B8C]10            	test	byte [_Bits],mask.lcase
 16488 00001851 7406                    	jz	short dn1		;M010;lowercase not required
 16489 00001853 BE[FA8A]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16490 00001856 E85501                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16491                                  dn1:	
 16492 00001859 C706[B08C][FA8A]        	mov	word [string_ptr_2],CHARBUF
 16493 0000185F BA[1C81]                	mov	dx,string_buf_ptr
 16494                                  	;call	std_printf		; print filename & extension
 16495                                  	;retn
 16496                                  	; 19/02/2023
 16497 00001862 E9BE35                  	jmp	std_printf
 16498                                  
 16499                                  ; ---------------------------------------------------------------------------
 16500                                  
 16501                                  ;***	DisplayNext - move display cursor to next entry position
 16502                                  ;
 16503                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16504                                  ;		LeftOnPage = # lines can still be printed for this page
 16505                                  ;		FileCnt = # files in this dir displayed before this one
 16506                                  ;		Bits contains /w setting
 16507                                  ;
 16508                                  ;	EXIT	nothing
 16509                                  ;
 16510                                  ;	USED	AX,DX
 16511                                  ;
 16512                                  ;	EFFECTS
 16513                                  ;
 16514                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16515                                  ;	   displayed.
 16516                                  ;	  LeftOnPage may be updated.
 16517                                  
 16518                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16519                                  
 16520                                  DisplayNext:
 16521 00001865 833E[EC8A]00            	cmp	word [FileCnt],0
 16522 0000186A 7415                    	je	short dn1st		; 1st file in directory
 16523 0000186C 803E[E68A]00            	cmp	byte [LeftOnLine],0
 16524 00001871 7E08                    	jng	short dnEol		; no more room on this line
 16525                                  
 16526                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16527                                  ;	we still have room for more on this line.
 16528                                  ;	Tab to next position.
 16529                                  
 16530 00001873 BA[2B81]                	mov	dx,tab_ptr
 16531 00001876 E8AA35                  	call	std_printf
 16532 00001879 EB0C                    	jmp	short dnDone
 16533                                  dnEol:	
 16534                                  ;	Start this entry on a new line.
 16535                                  
 16536 0000187B E85B0D                  	call	CRLF2		; start on new line
 16537 0000187E E8D2FE                  	call	UseLine
 16538                                  dn1st:
 16539 00001881 A0[E78A]                	mov	al,[PerLine]
 16540 00001884 A2[E68A]                	mov	[LeftOnLine],al	; reset # entries left on line
 16541                                  
 16542                                  dnDone:
 16543 00001887 FE0E[E68A]              	dec	byte [LeftOnLine]
 16544                                  				; reflect the entry about to be displayed
 16545 0000188B C3                      	retn
 16546                                  
 16547                                  ; ---------------------------------------------------------------------------
 16548                                  
 16549                                  ;***	DisplayTheRest - display file size/dir, date, time
 16550                                  ;
 16551                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16552                                  ;		Display cursor is at end of file extension
 16553                                  ;
 16554                                  ;	EXIT	nothing
 16555                                  ;
 16556                                  ;	USED	AX,CX,DX,SI,DI,BP
 16557                                  ;
 16558                                  ;	EFFECTS
 16559                                  ;
 16560                                  ;	  File size, date, & time are displayed.
 16561                                  
 16562                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16563                                  DisplayTheRest	:
 16564 0000188C 06                      	push	es			; save TRANGROUP seg addr
 16565 0000188D 8E06[C28A]              	mov	es,[TPA]		; ES = TPA seg addr
 16566 00001891 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16567                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16568                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16569 00001893 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16570 00001898 7408                    	jz	short drNonDir		; not a directory file
 16571                                  
 16572                                  ;	For a directory file, display <DIR> instead of size.
 16573                                  
 16574 0000189A BA[2E81]                	mov	dx,dmes_ptr
 16575 0000189D E88335                  	call	std_printf
 16576 000018A0 EB16                    	jmp	short drCom		; skip to common fields
 16577                                  
 16578                                  drNonDir:
 16579                                  ;	For a non-directory file, display file size.
 16580                                  
 16581                                  	;;mov	dx,word ptr es:[bp].filesize
 16582                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16583 000018A2 268B5611                	mov	dx,[es:bp+17]
 16584 000018A6 8916[AC8C]              	mov	[File_Size_Low],dx
 16585                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16586                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16587 000018AA 268B5613                	mov	dx,[es:bp+19]
 16588 000018AE 8916[AE8C]              	mov	[File_Size_High],dx
 16589 000018B2 BA[0E81]                	mov	dx,disp_file_size_ptr
 16590 000018B5 E86B35                  	call	std_printf
 16591                                  drCom:
 16592                                  ;	For all files, display date & time.
 16593                                  
 16594                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16595                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16596 000018B8 268B460F                	mov	ax,[es:bp+15]
 16597 000018BC 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16598 000018BE 7448                    	jz	short drDone		; no date, skip date/time display
 16599 000018C0 89C3                    	mov	bx,ax			; BX = date word
 16600 000018C2 83E01F                  	and	ax,1Fh			; AX = day of month
 16601 000018C5 88C2                    	mov	dl,al			; DL = day of month
 16602 000018C7 89D8                    	mov	ax,bx			; AX = date word
 16603 000018C9 B105                    	mov	cl,5
 16604 000018CB D3E8                    	shr	ax,cl			; shift day out
 16605 000018CD 240F                    	and	al,0Fh			; AL = month
 16606 000018CF 88C6                    	mov	dh,al			; DH = month
 16607 000018D1 88F9                    	mov	cl,bh
 16608 000018D3 D0E9                    	shr	cl,1			; CL = year - 1980
 16609 000018D5 30ED                    	xor	ch,ch			; CX = year - 1980
 16610 000018D7 83C150                  	add	cx,80			; CX = 2-digit year
 16611 000018DA 80F964                  	cmp	cl,100
 16612 000018DD 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16613 000018DF 80E964                  	sub	cl,100			; adjust for 21st century
 16614                                  dr_1:	
 16615 000018E2 86F2                    	xchg	dh,dl			; DX = month/day
 16616 000018E4 890E[6C81]              	mov	[DirDat_Yr],cx		; move year to msg block
 16617 000018E8 8916[6E81]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16618                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16619                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16620 000018EC 268B4E0D                	mov	cx,[es:bp+13]
 16621 000018F0 E310                    	jcxz	drPrint			; no time field - go print
 16622 000018F2 D1E9                    	shr	cx,1
 16623 000018F4 D1E9                    	shr	cx,1
 16624 000018F6 D1E9                    	shr	cx,1			; CH = hours
 16625 000018F8 D0E9                    	shr	cl,1
 16626 000018FA D0E9                    	shr	cl,1			; CL = minutes
 16627 000018FC 86E9                    	xchg	ch,cl			; CX = hr/min
 16628 000018FE 890E[7781]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16629                                  drPrint:
 16630 00001902 BA[6781]                	mov	dx,dirdattim_ptr
 16631 00001905 E81B35                  	call	std_printf		; print date & time
 16632                                  drDone:
 16633 00001908 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16634 00001909 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16635                                  dtrRet:
 16636                                  	; 19/02/2023
 16637 0000190B C3                      	retn
 16638                                  
 16639                                  ; ---------------------------------------------------------------------------
 16640                                  
 16641                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16642                                  ;
 16643                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16644                                  ;		FileCnt = # files listed
 16645                                  ;		FileSiz = total size of files listed
 16646                                  ;
 16647                                  ;	EXIT	nothing
 16648                                  ;
 16649                                  ;	USED
 16650                                  ;
 16651                                  ;	EFFECTS
 16652                                  ;
 16653                                  ;	  Trailing info lines are displayed
 16654                                  
 16655                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16656                                  
 16657                                  DisplayTrailer:
 16658                                  	;;;test	Bits,mask bare
 16659                                  	;;test	word [_Bits],8
 16660                                  	;test	byte [_Bits],8
 16661 0000190C F606[1B8C]08            	test	byte [_Bits],mask.bare
 16662 00001911 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16663                                  
 16664 00001913 E8C30C                  	call	CRLF2			; start on new line
 16665 00001916 E83AFE                  	call	UseLine
 16666 00001919 A1[EC8A]                	mov	ax,[FileCnt]		; AX = # files found
 16667                                  
 16668                                  ;	DisplayTotals uses this entry point.
 16669                                  ;
 16670                                  DisplayCntSiz:
 16671                                  ;	AX = # files
 16672                                  ;	FileSiz = dword total size of files
 16673                                  
 16674 0000191C A3[B58C]                	mov	[Dir_Num],ax		; load # files
 16675 0000191F BA[957F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16676 00001922 E8FE34                  	call	std_printf		; "nnn File(s)"
 16677                                  
 16678 00001925 BA[8381]                	mov	dx,bytes_ptr
 16679 00001928 E8F834                  	call	std_printf		; "nnn bytes",cr,lf
 16680                                  	; 19/02/2023
 16681                                  	;call	UseLine
 16682                                  ;dtrRet:
 16683                                  	;retn
 16684                                  
 16685                                  	; 19/02/2023
 16686 0000192B E925FE                  	jmp	UseLine
 16687                                  
 16688                                  ; ---------------------------------------------------------------------------
 16689                                  
 16690                                  ;***	DisplayWide - display filename in wide format
 16691                                  ;
 16692                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16693                                  ;
 16694                                  ;	EXIT	nothing
 16695                                  ;
 16696                                  ;	USED	AX,CX,DX,SI,DI
 16697                                  ;
 16698                                  ;	EFFECTS
 16699                                  ;
 16700                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16701                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16702                                  
 16703                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16704                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16705                                  
 16706                                  DisplayWide:
 16707 0000192E 1E                      	push	ds			; save TRANGROUP seg addr
 16708 0000192F 8E1E[C28A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16709                                  	;assume	ds:nothing
 16710                                  
 16711                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16712                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16713 00001933 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16714 00001937 7405                    	jz	short dw1		; not a subdirectory file
 16715 00001939 B05B                    	mov	al,'['
 16716 0000193B E8BE04                  	call	PRINT_CHAR		; prefix subdirectory
 16717                                  dw1:	
 16718 0000193E E83CFE                  	call	DisplayDotForm		; display name.ext
 16719                                  
 16720                                  ;	DX = # chars displayed in name.ext
 16721                                  
 16722                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16723                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16724 00001941 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16725 00001945 7405                    	jz	short dw2		; not a subdirectory file
 16726 00001947 B05D                    	mov	al,']'
 16727 00001949 E8B004                  	call	PRINT_CHAR		; postfix subdirectory
 16728                                  dw2:
 16729                                  ;	Pad field with blanks.
 16730                                  
 16731                                  	;mov	cx,size filename + size fileext + 1
 16732 0000194C B90C00                  	mov	cx,12 ; 8+3+1
 16733                                  					; CX = field size
 16734 0000194F 29D1                    	sub	cx,dx			; CX = # pad char's
 16735 00001951 E307                    	jcxz	dwDone
 16736 00001953 B020                    	mov	al,' '
 16737                                  dw3:	
 16738 00001955 E8A404                  	call	PRINT_CHAR
 16739 00001958 E2FB                    	loop	dw3
 16740                                  dwDone:	
 16741 0000195A 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16742                                  	;assume	ds:TRANGROUP
 16743 0000195B C3                      	retn
 16744                                  
 16745                                  ; ---------------------------------------------------------------------------
 16746                                  
 16747                                  ;***	GetDriveLtr - get target drive letter
 16748                                  ;
 16749                                  ;	ENTRY	FCB contains drive #
 16750                                  ;
 16751                                  ;	EXIT	AX = "d:"
 16752                                  ;
 16753                                  ;	USED	nothing
 16754                                  
 16755                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16756                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16757                                  GetDriveLtr:
 16758 0000195C A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16759 0000195F 08C0                    	or	al,al
 16760 00001961 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16761 00001963 A0[D48A]                	mov	al,[CURDRV]	; AL = current drive #
 16762 00001966 FEC0                    	inc	al		; AL = 1-based drive #
 16763                                  gdl1:	
 16764 00001968 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16765 0000196A B43A                    	mov	ah,':'		; AX = "d:"
 16766 0000196C C3                      	retn
 16767                                  
 16768                                  ; ---------------------------------------------------------------------------
 16769                                  
 16770                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16771                                  ;
 16772                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16773                                  ;	for system parser calls. Set up a message substitution block,
 16774                                  ;	etc. for invalid value strings. I copied the procedure from
 16775                                  ;	Setup_Parse_Error_Msg.
 16776                                  ;
 16777                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16778                                  ;		
 16779                                  ;
 16780                                  ;	EXIT	AX = system parser error return code for bad param format
 16781                                  ;		DX = ptr to message description block for Std_EPrintf
 16782                                  ;
 16783                                  ;	USED	SI
 16784                                  ;
 16785                                  ;	EFFECTS
 16786                                  ;
 16787                                  ;	  Msg_Disp_Class = parse error message class
 16788                                  ;	  Message block (see DX) is set up for parse error message
 16789                                  
 16790                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16791                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16792                                  SetupParamError:
 16793 0000196D B80900                  	mov	ax,9			; parse error #
 16794 00001970 C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class
 16795                                  	;mov	byte [msg_disp_class],2
 16796 00001975 A3[557F]                	mov	[extend_buf_ptr],ax
 16797                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16798 00001978 8B7704                  	mov	si,[bx+4]
 16799 0000197B 8936[B08C]              	mov	[string_ptr_2],si
 16800 0000197F C606[577F]01            	mov	byte [extend_buf_sub],one_subst
 16801                                  	;mov	byte [extend_buf_sub],1
 16802 00001984 BA[557F]                	mov	dx,extend_buf_ptr
 16803 00001987 C3                      	retn
 16804                                  
 16805                                  ; ---------------------------------------------------------------------------
 16806                                  
 16807                                  ;***	ZeroTotals - zero grand total file count, size
 16808                                  ;
 16809                                  ;	ENTRY	nothing
 16810                                  ;
 16811                                  ;	EXIT	nothing
 16812                                  ;
 16813                                  ;	USED	AX
 16814                                  ;
 16815                                  ;	EFFECTS
 16816                                  ;
 16817                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 16818                                  ;
 16819                                  ;	NOTES
 16820                                  ;
 16821                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 16822                                  	
 16823                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16824                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 16825                                  ZeroTotals:
 16826 00001988 BF[F28A]                	mov	di,FileCntTotal
 16827                                  
 16828                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 16829 0000198B B90800                  	mov	cx,8
 16830                                  
 16831 0000198E 30C0                    	xor	al,al
 16832 00001990 F3AA                    	rep	stosb
 16833 00001992 C3                      	retn	
 16834                                  
 16835                                  ; ---------------------------------------------------------------------------
 16836                                  
 16837                                  ;***	CtrlCHandler - our own control-c handler
 16838                                  ;
 16839                                  ;	Make sure user's default directory gets restored. See notes
 16840                                  ;	at InstallCtrlCHandler.
 16841                                  ;
 16842                                  ;	ENTRY	control-c
 16843                                  ;
 16844                                  ;	EXIT	to OldCtrlCHandler
 16845                                  ;
 16846                                  ;	USED	DS,flags
 16847                                  ;
 16848                                  ;	EFFECTS
 16849                                  ;
 16850                                  ;	  Restore user's default directory.
 16851                                  ;
 16852                                  ;	NOTES
 16853                                  ;
 16854                                  ;	  This handler is only installed after calling PathCrunch,
 16855                                  ;	  which sets UserDir1, so the restoration will work.
 16856                                  ;
 16857                                  ;	  The original control-c vector will be restored, whether
 16858                                  ;	  or not this one is invoked, in the HeadFix routine.
 16859                                  
 16860                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 16862                                  
 16863                                  CtrlCHandler:	;proc	far
 16864                                  
 16865                                  ;SR;
 16866                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 16867                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 16868                                  ;
 16869 00001993 1E                      	push	ds
 16870 00001994 0E                      	push	cs
 16871 00001995 1F                      	pop	ds			; DS = TRANGROUP seg addr
 16872 00001996 50                      	push	ax
 16873 00001997 52                      	push	dx
 16874 00001998 E8F80A                  	call	RestUDir		; restore user's default directory
 16875 0000199B 5A                      	pop	dx
 16876 0000199C 58                      	pop	ax
 16877 0000199D 1F                      	pop	ds
 16878 0000199E 2EFF2E[C395]            	jmp	far [cs:OldCtrlCHandler]
 16879                                  					; go to previous int 23 handler
 16880                                  
 16881                                  ; ---------------------------------------------------------------------------
 16882                                  
 16883                                  ;M010;start
 16884                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 16885                                  ;
 16886                                  ;	ENTRY	AL = character to be displayed
 16887                                  ;
 16888                                  ;	EXIT	AL is lowercase
 16889                                  ;
 16890                                  ;	USED	nothing
 16891                                  
 16892                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16893                                  LowerCase:
 16894 000019A3 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 16895 000019A5 7206                    	jb	short lcRet
 16896 000019A7 3C5A                    	cmp	al,'Z'
 16897 000019A9 7702                    	ja	short lcRet
 16898                                  
 16899 000019AB 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 16900                                  lcRet:
 16901 000019AD C3                      	retn
 16902                                  
 16903                                  ; ---------------------------------------------------------------------------
 16904                                  
 16905                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 16906                                  ;
 16907                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 16908                                  ;		ES = DS
 16909                                  ;
 16910                                  ;	EXIT	nothing
 16911                                  ;	
 16912                                  ;	USED	AL,SI
 16913                                  
 16914                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16915                                  LowercaseString:
 16916 000019AE 57                      	push	di			; save di
 16917 000019AF 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 16918 000019B1 FC                      	cld
 16919                                  NextChar: 
 16920 000019B2 AC                      	lodsb				; get character from string into al
 16921 000019B3 08C0                    	or	al,al			; are we at end of string?
 16922 000019B5 7406                    	jz	short EndOfString
 16923                                  
 16924 000019B7 E8E9FF                  	call	LowerCase		; convert character to lowercase
 16925 000019BA AA                      	stosb				; store character back into buffer
 16926 000019BB EBF5                    	jmp	short NextChar		; repeat until end of string
 16927                                  
 16928                                  EndOfString:
 16929 000019BD 5F                      	pop	di			; restore di
 16930 000019BE C3                      	retn
 16931                                  
 16932                                  ;M010;end
 16933                                  
 16934                                  ;============================================================================
 16935                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 16936                                  ;============================================================================
 16937                                  ; 09/10/2018 - Retro DOS v3.0
 16938                                  
 16939                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 16940                                  
 16941                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16942                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 16943                                  
 16944                                  ; =============== S U B	R O U T	I N E =======================================
 16945                                  
 16946                                  PAUSE:
 16947 000019BF BA[E77F]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 16948 000019C2 E85E34                  	call	std_printf
 16949 000019C5 E88CEB                  	call	GETKEYSTROKE
 16950                                  	;call	CRLF2
 16951                                  	;retn
 16952                                  	; 19/02/2023
 16953 000019C8 E90E0C                  	jmp	CRLF2
 16954                                  
 16955                                  ; ---------------------------------------------------------------------------
 16956                                  
 16957                                  ;****************************************************************
 16958                                  ;*
 16959                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 16960                                  ;*
 16961                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 16962                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 16963                                  ;*		up an error message and transfer control to CERROR.
 16964                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 16965                                  ;*		entered or SLASHP_ERASE if /P entered.
 16966                                  ;*
 16967                                  ;* INPUT:	command line at offset 81H
 16968                                  ;*
 16969                                  ;* OUTPUT:	if no error:
 16970                                  ;*		FCB at 5ch set up with filename(s) entered
 16971                                  ;*		Current directory set to entered directory
 16972                                  ;*
 16973                                  ;****************************************************************
 16974                                  
 16975                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16976                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 16977                                  ERASE:
 16978                                  	; MSDOS 6.0
 16979                                  
 16980                                  	;assume	ds:trangroup,es:trangroup
 16981                                  
 16982 000019CB BE8100                  	mov	si,81h		;AC000; get command line
 16983 000019CE C706[D78A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 16984 000019D4 BF[5385]                	mov	di,PARSE_ERASE
 16985                                  				;AN000; Get address of PARSE_ERASE
 16986 000019D7 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 16987                                  erase_scan:
 16988 000019D9 31D2                    	xor	dx,dx		;AN000;
 16989 000019DB E8E007                  	call	Parse_With_Msg	;AC018; call parser
 16990 000019DE 83F8FF                  	cmp	ax,-1  ; 0FFFFh
 16991                                  	;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 16992 000019E1 743D                    	je	short good_line	;AN000; yes - done parsing
 16993                                  	;cmp	ax,0
 16994                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 16995 000019E3 21C0                    	and	ax,ax		;AC000; did we have an error?
 16996 000019E5 7566                    	jnz	short errj2	;AC000; yes exit
 16997                                  
 16998 000019E7 813E[F195][C684]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 16999                                  				;AN000; was /P entered?
 17000 000019ED 741C                    	je	short set_erase_prompt
 17001                                  				;AN000; yes - go set prompt
 17002                                  ;
 17003                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 17004                                  ;
 17005 000019EF 56                      	push	si		;AC000; save position in line
 17006 000019F0 C536[F395]              	lds	si,[PARSE1_ADDR]
 17007                                  				;AC000; get address of filespec
 17008                                  	;cmp	byte [si+1],colon_char
 17009 000019F4 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 17010 000019F8 750B                    	jne	short erase_drive_ok
 17011                                  				;AC000; no - continue
 17012                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 17013 000019FA 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 17014 000019FE 7505                    	jne	short erase_drive_ok
 17015                                  				;AC000; no - continue
 17016 00001A00 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 17017                                  				;AN022; get message number in control block
 17018 00001A03 EB3D                    	jmp	short extend_setup
 17019                                  				;AC000; exit
 17020                                  erase_drive_ok:
 17021 00001A05 E8AE12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17022 00001A08 5E                      	pop	si		;AC000; get position back
 17023 00001A09 EBCE                    	jmp	short erase_scan
 17024                                  				;AN000; continue parsing
 17025                                  set_erase_prompt:
 17026 00001A0B 833E[D78A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 17027 00001A10 7408                    	jz	short ok_to_set_erase_prompt
 17028                                  				;AN018; no go set switch
 17029                                  	;mov	ax,1
 17030 00001A12 B80100                  	mov	ax,MoreArgs_Ptr 
 17031                                  				;AN018; set up too many arguments
 17032 00001A15 E8B507                  	call	setup_parse_error_msg
 17033                                  				;AN018; set up an error message
 17034 00001A18 EB33                    	jmp	short errj2	;AN018; exit
 17035                                  
 17036                                  ok_to_set_erase_prompt: 	;AN018;
 17037 00001A1A FF06[D78A]              	inc	word [COMSW]	;AN000; indicate /p specified
 17038 00001A1E EBB9                    	jmp	short erase_scan
 17039                                  				;AN000; continue parsing
 17040                                  good_line:			;G  We know line is good
 17041 00001A20 E85F0C                  	call	PathCrunch
 17042 00001A23 730D                    	jnc	short checkdr
 17043 00001A25 A1[338E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17044                                  	;cmp	ax,0		;AN022; was message flag set?
 17045 00001A28 09C0                    	or	ax,ax
 17046 00001A2A 7516                    	jnz	short extend_setup
 17047                                  				;AN022; yes - print out message
 17048                                  	;cmp	byte [DestIsDir],0
 17049 00001A2C 3806[C78C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 17050 00001A30 750D                    	jnz	short badpath_err
 17051                                  				;AC022; see if they should have
 17052                                  checkdr:
 17053 00001A32 833E[D78A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 17054 00001A37 7403                    	jz	short notest2j	;AN000; no - go to notest2
 17055 00001A39 E92A1B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 17056                                  notest2j:
 17057 00001A3C E9C21A                  	jmp	notest2
 17058                                  
 17059                                  badpath_err:			;AN022; "Path not found" message
 17060 00001A3F B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 17061                                  				;AN022; set up error number
 17062                                  extend_setup:			;AN022;
 17063                                  	;mov	byte [msg_disp_class],1
 17064 00001A42 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 17065                                  				;AN022; set up extended error msg class
 17066 00001A47 BA[557F]                	mov	dx,extend_buf_ptr
 17067                                  				;AC022; get extended message pointer
 17068 00001A4A A3[557F]                	mov	[extend_buf_ptr],ax
 17069                                  				;AN022; get message number in control block
 17070                                  errj2:				;AC022; exit jump
 17071 00001A4D E90A0F                  	jmp	cerror		;AN022;
 17072                                  
 17073                                  ; 20/02/2023
 17074                                  %if 0
 17075                                  	; MSDOS 3.3
 17076                                  	mov	dx,BADARGSPTR
 17077                                  	mov	si,80h
 17078                                  	lodsb
 17079                                  	or	al,al
 17080                                  	jz	short ERRJ2
 17081                                  	call	SCANOFF
 17082                                  	cmp	al,0Dh		; Return key
 17083                                  	jz	short ERRJ2	; If so no parameters specified
 17084                                  	push	dx
 17085                                  	push	si
 17086                                  	mov	dx,FNOTFOUNDPTR
 17087                                  ERASE_SCAN:
 17088                                  	lodsb
 17089                                  	call	DELIM
 17090                                  	jz	short ERASE_CHKDELIMCHR
 17091                                  	cmp	al,0Dh
 17092                                  	jz	short GOOD_LINE
 17093                                  	jmp	short ERASE_SCAN
 17094                                  ERASE_CHKDELIMCHR:
 17095                                  	cmp	al,20h
 17096                                  	jg	short ERRJ2
 17097                                  	lodsb
 17098                                  	call	DELIM
 17099                                  	jz	short ERASE_CHKDELIMCHR
 17100                                  	cmp	al,0Dh
 17101                                  	jz	short GOOD_LINE
 17102                                  	mov	dx,BADARGSPTR
 17103                                  	jmp	short ERRJ2
 17104                                  GOOD_LINE:
 17105                                  	pop	si
 17106                                  	pop	dx
 17107                                  	push	si
 17108                                  	call	PATHCRUNCH
 17109                                  	jnc	short CHECKDR
 17110                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17111                                  	jz	short CHECKDR	   ; see if they should have
 17112                                  BADCDERR:
 17113                                  	pop	si
 17114                                  	mov	dx,BADCDPTR
 17115                                  ERRJ2:
 17116                                  	jmp	CERROR
 17117                                  CHECKDR:
 17118                                  	mov	dx,FNOTFOUNDPTR
 17119                                  	pop	cx
 17120                                  	mov	al,' '
 17121                                  	;cmp	[5Dh],al
 17122                                  	cmp	[FCB+1],al
 17123                                  	jz	short ERRJ2
 17124                                  	add	cx,3
 17125                                  	cmp	si,cx
 17126                                  	jnz	short NOTEST2J
 17127                                  	mov	al,':'
 17128                                  	cmp	[si-2],al
 17129                                  	jz	short ERRJ2
 17130                                  NOTEST2J:
 17131                                  	jmp	NOTEST2
 17132                                  %endif
 17133                                  
 17134                                  ; ---------------------------------------------------------------------------
 17135                                  
 17136                                  ; ****************************************************************
 17137                                  ; *
 17138                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17139                                  ; *
 17140                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17141                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17142                                  ; *		 Make sure the second filespec only contains a
 17143                                  ; *		 filename. If both openands are valid, attempt
 17144                                  ; *		 to rename the file.
 17145                                  ; *
 17146                                  ; * INPUT:	 command line at offset 81H
 17147                                  ; *
 17148                                  ; * OUTPUT:	 none
 17149                                  ; *
 17150                                  ; ****************************************************************
 17151                                  
 17152                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17153                                  CRENAME:
 17154                                  	; MSDOS 6.0
 17155                                  	;assume	ds:trangroup,es:trangroup
 17156                                  
 17157 00001A50 BE8100                  	mov	si,81h		;AC000; Point to command line
 17158 00001A53 BF[CA85]                	mov	di,PARSE_RENAME
 17159                                  				;AN000; Get address of PARSE_RENAME
 17160 00001A56 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17161 00001A58 31D2                    	xor	dx,dx		;AN000;
 17162 00001A5A E86107                  	call	Parse_With_Msg	;AC018; call parser
 17163                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17164 00001A5D 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17165                                  ;	jz	short crename_no_parse_error
 17166                                  				;AC000; no - continue
 17167 00001A5F 752C                    	jnz	short crename_parse_error
 17168                                  				;AC000; Yes, fail. (need long jump)
 17169                                  ;
 17170                                  ;  Get first file name returned from parse into our buffer
 17171                                  ;
 17172                                  crename_no_parse_error:
 17173 00001A61 56                      	push	si		;AN000; save position in line
 17174 00001A62 C536[F395]              	lds	si,[PARSE1_ADDR]
 17175                                  				;AN000; get address of filespec
 17176 00001A66 E84D12                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17177 00001A69 5E                      	pop	si		;AN000; restore position in line
 17178                                  
 17179 00001A6A 31D2                    	xor	dx,dx		;AN000; clear dx
 17180 00001A6C E84F07                  	call	Parse_With_Msg	;AC018; call parser
 17181                                  	;cmp	ax,RESULT_NO_ERROR
 17182 00001A6F 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17183 00001A71 751A                    	jnz	short crename_parse_error
 17184                                  				;AN000; Yes, fail.
 17185                                  ;
 17186                                  ;  Check the second file name for drive letter colon
 17187                                  ;
 17188 00001A73 56                      	push	si		;AN000; save position in line
 17189 00001A74 C536[F395]              	lds	si,[PARSE1_ADDR]
 17190                                  				;AC000; get address of path
 17191                                  	;mov	al,':'		;AC000;
 17192                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17193 00001A78 807C013A                	cmp	byte [si+1],':'
 17194 00001A7C 7511                    	jnz	short ren_no_drive
 17195                                  				;AN000; Yes, error
 17196                                  	;mov	byte [msg_disp_class],2
 17197 00001A7E C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class
 17198                                  				;AN000; set up parse error msg class
 17199 00001A83 BA[557F]                	mov	dx,extend_buf_ptr
 17200                                  				;AC000; get extended message pointer
 17201                                  	;mov	word [extend_buf_ptr],0Ah
 17202 00001A86 C706[557F]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17203                                  				;AN000; get "Invalid parameter" message number
 17204 00001A8C 5E                      	pop	si		;AN000;
 17205                                  crename_parse_error:		;AC022;
 17206 00001A8D EB64                    	jmp	short errj	;AC000;
 17207                                  
 17208                                  ;  Get second file name returned from parse into the fCB. Save
 17209                                  ;  character after file name so we can later check to make sure it
 17210                                  ;  isn't a path character.
 17211                                  
 17212                                  ren_no_drive:
 17213 00001A8F BF6C00                  	mov	di,FCB+10h ; 6Ch
 17214                                  				;AC000; set up to parse second file name
 17215                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17216 00001A92 B80129                  	mov	ax,2901h
 17217 00001A95 CD21                    	int	21h		;AC000; do the function
 17218 00001A97 AC                      	lodsb			;AC000; Load char after filename
 17219 00001A98 A2[BF8C]                	mov	[One_Char_Val],al
 17220                                  				;AN000; save char after filename
 17221 00001A9B 5E                      	pop	si		;AN000; get line position back
 17222                                  ;
 17223                                  ; We have source and target. See if any args beyond.
 17224                                  ;
 17225 00001A9C BF[CA85]                	mov	di,PARSE_RENAME
 17226                                  				;AC000; get address of parse_rename
 17227 00001A9F E80607                  	call	parse_check_eol ;AC000; are we at end of line?
 17228 00001AA2 75E9                    	jnz	short crename_parse_error
 17229                                  				;AN000; no, fail.
 17230                                  
 17231 00001AA4 E8DB0B                  	call	PathCrunch
 17232 00001AA7 BA[667F]                	mov	dx,BADCPMES_PTR
 17233 00001AAA 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17234 00001AAC 730F                    	jnc	short notest3
 17235 00001AAE A1[338E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17236                                  	;cmp	ax,0		;AN022; was message flag set?
 17237 00001AB1 21C0                    	and	ax,ax ; 0 ?
 17238 00001AB3 758D                    	jnz	short extend_setup
 17239                                  				;AN022; yes - print out message
 17240                                  	;cmp	byte [DestIsDir],0
 17241 00001AB5 3806[C78C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17242 00001AB9 7402                    	jz	short notest3 	; see if they should have
 17243 00001ABB EB82                    	Jmp	badpath_err	;AC022; set up error
 17244                                  notest3:
 17245 00001ABD A0[BF8C]                	mov	al,[One_Char_Val]
 17246                                  				;AN000; move char into AX
 17247 00001AC0 BA[847F]                	mov	dx,INORNOT_PTR 
 17248                                  				; Load invalid fname error ptr
 17249 00001AC3 E8AE0B                  	call	pathchrcmp	; Is the char in al a path sep?
 17250 00001AC6 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17251                                  				;  filename only.
 17252                                  	;mov	ah,FCB_Rename
 17253 00001AC8 B417                    	mov	ah,17h
 17254 00001ACA BA5C00                  	mov	dx,FCB ; 5Ch
 17255 00001ACD CD21                    	int	21h
 17256 00001ACF 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17257 00001AD1 7506                    	jne	short renameok
 17258                                  
 17259 00001AD3 E82C02                  	call	get_ext_error_number
 17260                                  				;AN022; get extended error
 17261 00001AD6 50                      	push	ax		;AC022; Save results
 17262 00001AD7 B0FF                    	mov	al,0FFh		; Restore original error state
 17263                                  renameok:
 17264 00001AD9 50                      	push	ax
 17265 00001ADA E8B609                  	call	RestUDir
 17266 00001ADD 58                      	pop	ax
 17267 00001ADE FEC0                    	inc	al
 17268                                  	;;retnz
 17269                                  	;jz	short rn1
 17270                                  	;retn	
 17271 00001AE0 7514                    	jnz	short ret56
 17272                                  rn1:
 17273 00001AE2 58                      	pop	ax		;AC022; get the error number back
 17274 00001AE3 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17275                                  				;AN022; error file not found?
 17276 00001AE6 7408                    	jz	short use_renerr
 17277                                  				;AN022; yes - use generic error message
 17278 00001AE8 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17279                                  				;AN022; error file not found?
 17280 00001AEB 7403                    	jz	short use_renerr
 17281                                  				;AN022; yes - use generic error message
 17282 00001AED E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17283                                  
 17284                                  use_renerr:
 17285 00001AF0 BA[637F]                	mov	dx,RENERR_PTR	;AC022;
 17286                                  errj:
 17287 00001AF3 E9640E                  	jmp	cerror
 17288                                  ret56:
 17289                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17290 00001AF6 C3                      	retn
 17291                                  
 17292                                  ; 20/02/2023
 17293                                  %if 0
 17294                                  	; MSDOS 3.3
 17295                                  	mov	dx,BADARGSPTR
 17296                                  	call	SCANOFF
 17297                                  	cmp	al,0Dh
 17298                                  	jz	short ERRJ2
 17299                                  	call	PATHCRUNCH
 17300                                  	mov	dx,BADCPMESPTR
 17301                                  	jz	short ERRJ2
 17302                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17303                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17304                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17305                                  	jmp	short BADCDERR
 17306                                  
 17307                                  ;  Get first file name returned from parse into our buffer
 17308                                  
 17309                                  CRENAME_NO_PARSE_ERROR:
 17310                                  	mov	si,[PATHPOS]
 17311                                  	call	SCANOFF
 17312                                  	cmp	al,0Dh
 17313                                  	mov	dx,BADARGSPTR
 17314                                  	jz	short ERRJ
 17315                                  	mov	al,':'
 17316                                  	mov	dx,BADPARMPTR
 17317                                  	cmp	[si+1],al
 17318                                  	jz	short ERRJ
 17319                                  
 17320                                  ;  Get second file name returned from parse into the FCB. Save
 17321                                  ;  character after file name so we can later check to make sure it
 17322                                  ;  isn't a path character.
 17323                                  
 17324                                  REN_NO_DRIVE:
 17325                                  	;mov	di,6Ch
 17326                                  	mov	di,FCB+10h
 17327                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17328                                  	int	21h	; DOS -	PARSE FILENAME
 17329                                  			; DS:SI	-> string to parse
 17330                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17331                                  			; AL = bit mask	to control parsing
 17332                                  	mov	al,' '
 17333                                  	;cmp	[6Dh],al
 17334                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17335                                  	jz	short ERRJ	; Error if missing parameter
 17336                                  	lodsb
 17337                                  	mov	dx,INORNOTPTR
 17338                                  	call	PATHCHRCMP
 17339                                  	jz	short ERRJ
 17340                                  	mov	ah,FCB_RENAME ; 17h
 17341                                  	mov	dx,FCB ; 5Ch
 17342                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17343                                  			; DS:DX	-> FCB
 17344                                  			; FCB contains new name	starting at byte 17h.
 17345                                  	cmp	al,0FFh		; Did an error occur??	
 17346                                  	jnz	short RENAMEOK
 17347                                  	stc
 17348                                  	mov	dx,RENERRPTR
 17349                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17350                                  	push	dx
 17351                                  	mov	al,0FFh		; Restore original error state
 17352                                  RENAMEOK:
 17353                                  	push	ax
 17354                                  	call	RESTUDIR
 17355                                  	pop	ax
 17356                                  	inc	al
 17357                                  	jz	short RENAME_ERR
 17358                                  RENAME_RETN:
 17359                                  TYPELP_RET:
 17360                                  	retn
 17361                                  RENAME_ERR:
 17362                                  	pop	dx
 17363                                  ERRJ:				; Retro DOS v3.0
 17364                                  	call	STD_EPRINTF
 17365                                  	jmp	TCOMMAND
 17366                                  
 17367                                  ; ---------------------------------------------------------------------------
 17368                                  
 17369                                  ;ERRJ:
 17370                                  ;	jmp	CERROR
 17371                                  
 17372                                  ; ---------------------------------------------------------------------------
 17373                                  
 17374                                  ;TYPELP_RET:
 17375                                  ;	retn
 17376                                  
 17377                                  %endif
 17378                                  
 17379                                  ; ---------------------------------------------------------------------------
 17380                                  
 17381                                  ;****************************************************************
 17382                                  ;*
 17383                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17384                                  ;*		standard output device
 17385                                  ;*
 17386                                  ;* SYNTAX:	TYPE filespec
 17387                                  ;*
 17388                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17389                                  ;*		1Ah and display the contents to STDOUT.
 17390                                  ;*
 17391                                  ;* INPUT:	command line at offset 81H
 17392                                  ;*
 17393                                  ;* OUTPUT:	none
 17394                                  ;*
 17395                                  ;****************************************************************
 17396                                  
 17397                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17398                                  TYPEFIL:
 17399                                  	; MSDOS 6.0	
 17400                                  	;assume	ds:trangroup,es:trangroup
 17401                                  
 17402 00001AF7 BE8100                  	mov	si,81h
 17403 00001AFA BF[4185]                	mov	di,PARSE_MRDIR
 17404                                  				;AN000; Get address of PARSE_MRDIR
 17405 00001AFD 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17406 00001AFF 31D2                    	xor	dx,dx		;AN000;
 17407 00001B01 E8BA06                  	call	Parse_With_Msg	;AC018; call parser
 17408                                  	;cmp	ax,RESULT_NO_ERROR
 17409 00001B04 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17410 00001B06 751E                    	jnz	short typefil_parse_error
 17411                                  				;AN000; yes - issue error message
 17412                                  
 17413 00001B08 56                      	push	si		;AC000; save position in line
 17414 00001B09 C536[F395]              	lds	si,[PARSE1_ADDR]
 17415                                  				;AC000; get address of filespec
 17416 00001B0D E8A611                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17417 00001B10 5E                      	pop	si		;AC000; get position back
 17418 00001B11 BF[4185]                	mov	di,PARSE_MRDIR
 17419                                  				;AC000; get address of parse_mrdir
 17420 00001B14 E89106                  	call	parse_check_eol ;AC000; are we at end of line?
 17421                                  	;jz	short gottarg 	;AC000; yes - continue
 17422                                  	; 20/02/2023
 17423                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17424                                  	;jmp	cerror
 17425 00001B17 750D                    	jnz	short typefil_parse_error
 17426                                  gottarg:
 17427 00001B19 E8D80F                  	call	SETPATH
 17428 00001B1C F606[CB8C]02            	test	byte [DestInfo],00000010b ; 2
 17429                                  				; Does the filespec contain wildcards
 17430 00001B21 7406                    	jz	short nowilds 	; No, continue processing
 17431 00001B23 BA[847F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17432                                  	; 20/02/2023
 17433                                  typefil_parse_error:
 17434 00001B26 E9310E                  	jmp	cerror
 17435                                  nowilds:
 17436                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17437 00001B29 B8006C                  	mov	ax,6C00h
 17438                                  	;mov	bx,read_open_mode ; 0
 17439                                  				;AN000; get open mode for TYPE
 17440 00001B2C 31C9                    	xor	cx,cx		;AN000; no special files
 17441 00001B2E 89CB                    	mov	bx,cx ; 20/02/2023
 17442 00001B30 BA0101                  	mov	dx,101h
 17443                                  	;mov	dx,read_open_flag ; 101h
 17444                                  				;AN000; set up open flags
 17445 00001B33 BE[2F8D]                	mov	si,SrcBuf	;AN030; get file name
 17446 00001B36 CD21                    	int	21h
 17447 00001B38 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17448                                  
 17449                                  typerr: 			;AN022;
 17450 00001B3A 0E                      	push	cs		;AN022; make sure we have local segment
 17451 00001B3B 1F                      	pop	ds		;AN022;
 17452 00001B3C E8B301                  	call	Set_Ext_Error_Msg ;AN022;
 17453 00001B3F C706[B08C][2F8D]        	mov	word [string_ptr_2],SrcBuf 
 17454                                  				;AC022; get address of failed string
 17455                                  	;mov	byte [extend_buf_sub],1
 17456 00001B45 C606[577F]01            	mov	byte [extend_buf_sub],one_subst
 17457                                  				;AC022; put number of subst in control block
 17458 00001B4A E90D0E                  	jmp	cerror		;AC022; exit
 17459                                  
 17460                                  typecont:
 17461 00001B4D 89C3                    	mov	bx,ax		;AC000; get Handle
 17462                                  ;M043
 17463                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17464                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17465                                  ;indicate it is a device.
 17466                                  ;
 17467                                  	;mov	ax,(IOCTL shl 8) or 0
 17468 00001B4F B80044                  	mov	ax,4400h
 17469 00001B52 CD21                    	int	21h
 17470                                  
 17471 00001B54 F6C280                  	test	dl,80h		;is it a device?
 17472 00001B57 7408                    	jz	short not_device
 17473                                  				;no, a file
 17474                                  
 17475 00001B59 C706[ED95]FFFF          	mov	word [TypeFilSiz+2],-1
 17476                                  				;indicate it is a device
 17477 00001B5F EB17                    	jmp	short dotype
 17478                                  not_device:
 17479                                  ;SR;
 17480                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17481                                  ;start of file
 17482                                  
 17483                                  	;mov	ax,(LSEEK shl 8) or 2
 17484 00001B61 B80242                  	mov	ax,4202h
 17485 00001B64 31D2                    	xor	dx,dx
 17486 00001B66 89D1                    	mov	cx,dx		;seek  to end of file
 17487 00001B68 CD21                    	int	21h
 17488                                  
 17489 00001B6A A3[EB95]                	mov	[TypeFilSiz],ax
 17490 00001B6D 8916[ED95]              	mov	[TypeFilSiz+2],dx ;store filesize
 17491                                  	;mov	ax,(LSEEK shl 8) or 0
 17492 00001B71 B80042                  	mov	ax,4200h
 17493 00001B74 31D2                    	xor	dx,dx
 17494 00001B76 CD21                    	int	21h	        ;reset file pointer to start
 17495                                  dotype:				;M043
 17496 00001B78 C606[9D94]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17497 00001B7D 8E1E[C28A]              	mov	ds,[TPA]
 17498 00001B81 31D2                    	xor	dx,dx
 17499                                  	;ASSUME	DS:NOTHING
 17500                                  typelp:
 17501 00001B83 2E803E[9D94]00          	cmp	byte [cs:zflag],0
 17502                                  				;AC050; Is the ^Z flag set?
 17503                                  	;retnz			; Yes, return
 17504                                  	; 17/04/2023
 17505 00001B89 7401                    	jz	short tf1
 17506 00001B8B C3                      	retn
 17507                                  tf1:
 17508 00001B8C 2E8B0E[E18A]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17509                                  
 17510                                  ;Update the filesize left to read
 17511                                  
 17512 00001B91 2E833E[ED95]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17513                                  				;is it a device? M043
 17514 00001B97 7431                    	je	short typ_read	;yes, just read from it; M043
 17515                                  
 17516 00001B99 2E833E[ED95]00          	cmp	word [cs:TypeFilSiz+2],0
 17517                                  				;more than 64K left?
 17518 00001B9F 740D                    	jz	short lt64k	;no, do word subtraction
 17519 00001BA1 2E290E[EB95]            	sub	[cs:TypeFilSiz],cx
 17520 00001BA6 2E831E[ED95]00          	sbb	word [cs:TypeFilSiz+2],0
 17521                                  				;update filesize
 17522 00001BAC EB1C                          	jmp	short typ_read	;do the read
 17523                                  lt64k:
 17524 00001BAE 2E3B0E[EB95]            	cmp	cx,[cs:TypeFilSiz]
 17525                                  				;readsize <= buffer?
 17526 00001BB3 7610                    	jbe	short gtbuf	; yes, just update readsize
 17527                                  
 17528                                  ;Buffer size is larger than bytes to read
 17529                                  
 17530 00001BB5 2E8B0E[EB95]            	mov	cx,[cs:TypeFilSiz]
 17531 00001BBA E361                    	jcxz	typelp_ret
 17532 00001BBC 2EC706[EB95]0000        	mov	word [cs:TypeFilSiz],0
 17533 00001BC3 EB05                    	jmp	short typ_read
 17534                                  gtbuf:
 17535 00001BC5 2E290E[EB95]            	sub	[cs:TypeFilSiz],cx
 17536                                  				;update filesize remaining
 17537                                  typ_read:
 17538                                  	;mov	ah,read
 17539 00001BCA B43F                    	mov	ah,3Fh
 17540 00001BCC CD21                    	int	21h		
 17541 00001BCE 7303                    	jnc	short tf2	;M043
 17542 00001BD0 E967FF                  	jmp	typerr		;M043
 17543                                  tf2:				;M043
 17544                                  ;M043;	jc	typerr		;AN022; Exit if error
 17545                                  
 17546 00001BD3 89C1                    	mov	cx,ax
 17547 00001BD5 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17548 00001BD7 1E                      	push	ds
 17549 00001BD8 07                      	pop	es		; Check to see if a ^Z was read.
 17550                                  	;assume es:nothing
 17551 00001BD9 31FF                    	xor	di,di
 17552 00001BDB 50                      	push	ax
 17553 00001BDC B01A                    	mov	al,1Ah
 17554 00001BDE F2AE                    	repnz	scasb
 17555 00001BE0 58                      	pop	ax
 17556 00001BE1 91                      	xchg	ax,cx
 17557                                  	;cmp	ax,0
 17558 00001BE2 21C0                    	and	ax,ax
 17559 00001BE4 7506                    	jnz	short foundz	; Yes, handle it
 17560 00001BE6 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17561 00001BEA 750A                    	jnz	short typecont2	; No ^Z, continue
 17562                                  foundz:
 17563 00001BEC 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17564 00001BEE 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17565 00001BEF 0E                      	push	cs		;  will be typed.
 17566 00001BF0 07                      	pop	es
 17567                                  	;assume es:trangroup
 17568 00001BF1 26F616[9D94]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17569                                  typecont2:			;  will quit after this write.
 17570 00001BF6 53                      	push	bx
 17571 00001BF7 BB0100                  	mov	bx,1
 17572                                  	;mov	ah,Write
 17573 00001BFA B440                    	mov	ah,40h
 17574 00001BFC CD21                    	int	21h
 17575 00001BFE 5B                      	pop	bx
 17576 00001BFF 720C                    	jc	short Error_outputj
 17577 00001C01 39C8                    	cmp	ax,cx
 17578 00001C03 7503                    	jnz	short tf3	;M043
 17579 00001C05 E97BFF                  	jmp	typelp		;M043
 17580                                  tf3:				;M043
 17581                                  ;M043;	jz	short typelp
 17582 00001C08 49                      	dec	cx
 17583 00001C09 39C8                    	cmp	ax,cx
 17584                                  	;;retz			; One less byte OK (^Z)
 17585                                  	;jnz	short Error_outputj
 17586                                  ;tf4:
 17587                                  	;retn
 17588 00001C0B 7410                    	jz	short typelp_ret ; 20/02/2023
 17589                                  
 17590                                  Error_outputj:
 17591 00001C0D BB0100                  	mov	bx,1
 17592                                  	;mov	ax,IOCTL SHL 8
 17593 00001C10 B80044                  	mov	ax,4400h
 17594 00001C13 CD21                    	int	21h
 17595 00001C15 F6C280                  	test	dl,80h
 17596                                  	;test	dl,devid_ISDEV
 17597                                  	;;retnz			; If device, no error message
 17598                                  	;jnz	short tf4
 17599 00001C18 7503                    	jnz	short typelp_ret
 17600 00001C1A E93D0A                  	jmp	error_output
 17601                                  typelp_ret:
 17602 00001C1D C3                      	retn
 17603                                  
 17604                                  ; 20/02/2023
 17605                                  %if 0
 17606                                  	; MSDOS 3.3
 17607                                  	mov	si,81h
 17608                                  	call	SCANOFF		; Skip to first non-delim
 17609                                  	cmp	al,0Dh
 17610                                  	jnz	short GOTTARG
 17611                                  	mov	dx,BADARGSPTR
 17612                                  
 17613                                  	;jmp	CERROR
 17614                                  	jmp	short ERRJ	; No args
 17615                                  GOTTARG:
 17616                                  	call	SETPATH
 17617                                  	test	byte [DESTINFO],2
 17618                                  	jz	short NOWILDS
 17619                                  	mov	dx,INORNOTPTR
 17620                                  
 17621                                  	;jmp	CERROR
 17622                                  	jmp	short ERRJ
 17623                                  NOWILDS:
 17624                                  	mov	ax,OPEN*256 ; 3D00h
 17625                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17626                                  			; DS:DX	-> ASCIZ filename
 17627                                  			; AL = access mode
 17628                                  			; 0 - read
 17629                                  	jnc	short TYPECONT
 17630                                  	mov	dx,FNOTFOUNDPTR
 17631                                  	cmp	ax,2
 17632                                  	jz	short ERRJ
 17633                                  	mov	dx,BADCPMESPTR
 17634                                  	stc
 17635                                  	call	GET_EXT_ERR_NUMBER
 17636                                  	
 17637                                  	;jmp	CERROR
 17638                                  	jmp	short ERRJ
 17639                                  TYPECONT:
 17640                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17641                                  	mov	bx,ax		; Handle
 17642                                  	mov	ds,[TPA]
 17643                                  	xor	dx,dx
 17644                                  TYPELP:
 17645                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17646                                  	jnz	short RENAME_RETN ; Yes, return	
 17647                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17648                                  	mov	ah,READ ; 3Fh
 17649                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17650                                  			; BX = file handle,CX = number	of bytes to read
 17651                                  			; DS:DX	-> buffer
 17652                                  	mov	cx,ax
 17653                                  	jcxz	TYPELP_RET	; exit if nothing read
 17654                                  				; Check to see if a ^Z was read.
 17655                                  	push	ds
 17656                                  	pop	es		
 17657                                  	xor	di,di
 17658                                  	push	ax
 17659                                  	mov	al,1Ah
 17660                                  	repne	scasb
 17661                                  	pop	ax
 17662                                  	xchg	ax,cx
 17663                                  	cmp	ax,0
 17664                                  	jnz	short FOUNDZ	; Yes, handle it
 17665                                  	cmp	byte [di-1],1Ah	; No, double check
 17666                                  	jnz	short TYPECONT2	; No ^Z, continue
 17667                                  FOUNDZ:
 17668                                  	sub	cx,ax		; Otherwise change cx so that only those
 17669                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17670                                  	push	cs		;  will be typed.
 17671                                  	pop	es
 17672                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17673                                  				;  will quit after this write.
 17674                                  TYPECONT2:
 17675                                  	push	bx
 17676                                  	mov	bx,1
 17677                                  	mov	ah,WRITE ; 40h
 17678                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17679                                  			; BX = file handle, CX = number of bytes to write,
 17680                                  			; DS:DX -> buffer
 17681                                  	pop	bx
 17682                                  	jc	short ERROR_OUTPUTJ
 17683                                  	cmp	ax,cx
 17684                                  	jz	short TYPELP
 17685                                  	dec	cx
 17686                                  	cmp	ax,cx		; One less byte OK (^Z)
 17687                                  	jnz	short ERROR_OUTPUTJ
 17688                                  TYPEFIL_RETN:
 17689                                  	retn
 17690                                  ERROR_OUTPUTJ:
 17691                                  	mov	bx,1
 17692                                  	mov	ax,IOCTL*256 ; 4400h
 17693                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17694                                  			; BX = file or device handle
 17695                                  	;test	dl,devid_ISDEV
 17696                                  	test	dl,80h
 17697                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17698                                  	jmp	ERROR_OUTPUT
 17699                                  %endif
 17700                                  
 17701                                  ; ---------------------------------------------------------------------------
 17702                                  
 17703                                  ; VOLUME command displays the volume ID on the specified drive
 17704                                  
 17705                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17706                                  VOLUME:
 17707                                  	; MSDOS 6.0
 17708 00001C1E BE8100                  	mov	si,81h
 17709 00001C21 BF[2F85]                	mov	di,PARSE_VOL
 17710                                  				;AN000; Get address of PARSE_VOL
 17711 00001C24 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17712 00001C26 31D2                    	xor	dx,dx		;AN000;
 17713 00001C28 E89305                  	call	Parse_With_Msg	;AC018; call parser
 17714 00001C2B 83F8FF                  	cmp	ax,-1
 17715                                  	;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17716 00001C2E 7444                    	je	short OkVolArg	;AC000; Yes, display default volume ID
 17717                                  	;cmp	ax,RESULT_NO_ERROR
 17718                                  	;cmp	ax,0		;AC000; did we have an error?
 17719 00001C30 09C0                    	or	ax,ax ; 0?
 17720 00001C32 750A                    	jnz	short badvolarg	;AC000; Yes, fail.
 17721                                  
 17722                                  ; We have parsed off the drive. See if there are any more chars left
 17723                                  
 17724 00001C34 BF[2F85]                	mov	di,PARSE_VOL
 17725                                  				;AC000; get address of parse_vol
 17726 00001C37 31D2                    	xor	dx,dx		;AC000;
 17727 00001C39 E86C05                  	call	parse_check_eol ;AC000; call parser
 17728 00001C3C 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17729                                  
 17730                                  ; The line was not interpretable. Report an error.
 17731                                  
 17732                                  badvolarg:
 17733 00001C3E E9190D                  	jmp	cerror
 17734                                  
 17735                                  ; 20/02/2023
 17736                                  %if 0
 17737                                  	; MSDOS 3.3
 17738                                  	mov	si,81h
 17739                                  	call	SCANOFF		; Skip to first non-delim
 17740                                  	;mov	ah,[5Ch]
 17741                                  	mov	ah,[FCB]
 17742                                  	;mov	byte [5Ch],0
 17743                                  	mov	byte [FCB],0
 17744                                  	cmp	al,0Dh		; are we at end of line?
 17745                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17746                                  	;mov	[5Ch],ah
 17747                                  	mov	[FCB],ah
 17748                                  	lodsb
 17749                                  	lodsb
 17750                                  	cmp	al,':'
 17751                                  	jnz	short VOLUME_ERR
 17752                                  	call	SCANOFF
 17753                                  	cmp	al,0Dh
 17754                                  	jz	short OKVOLARG
 17755                                  VOLUME_ERR:
 17756                                  	mov	dx,BADDRVPTR
 17757                                  	jmp	CERROR
 17758                                  
 17759                                  ; ---------------------------------------------------------------------------
 17760                                  
 17761                                  OKVOLARG:
 17762                                  	call	CRLF2
 17763                                  	push	ds
 17764                                  	pop	es
 17765                                  	;mov	di,55h
 17766                                  	mov	di,FCB-7	; Set up extended FCB
 17767                                  	mov	al,-1
 17768                                  	stosb
 17769                                  	xor	ax,ax
 17770                                  	stosw
 17771                                  	stosw
 17772                                  	stosb
 17773                                  	mov	al,8		; Look for volume label
 17774                                  	stosb
 17775                                  	inc	di		; Skip drive byte
 17776                                  	mov	cx,11
 17777                                  	mov	al,'?'
 17778                                  	rep stosb
 17779                                  	mov	dx,DIRBUF
 17780                                  	mov	ah,Set_DMA ; 1Ah
 17781                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17782                                  			; DS:DX	-> disk	transfer buffer
 17783                                  	;mov	dx,55h
 17784                                  	mov	dx,FCB-7
 17785                                  	mov	ah,Dir_Search_First ; 11h
 17786                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17787                                  			; DS:DX	-> FCB
 17788                                  	jmp	PRINTVOL
 17789                                  %endif
 17790                                  
 17791                                  ; ---------------------------------------------------------------------------
 17792                                  
 17793                                  ;***	DisAppend - disable APPEND
 17794                                  ;
 17795                                  ;	ENTRY	nothing
 17796                                  ;
 17797                                  ;	EXIT	nothing
 17798                                  ;
 17799                                  ;	USED	AX,BX
 17800                                  ;
 17801                                  ;	EFFECTS
 17802                                  ;
 17803                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 17804                                  ;	  after the command finishes, by the HeadFix routine.
 17805                                  ;
 17806                                  ;	NOTE
 17807                                  ;
 17808                                  ;	  This routine must not be called more than once during a single
 17809                                  ;	  command cycle. The second call would permanently disable APPEND.
 17810                                  
 17811                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17812                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 17813                                  
 17814                                  	; MSDOS 6.0
 17815                                  DisAppend:
 17816 00001C41 1E                      	push	ds			; save DS
 17817 00001C42 06                      	push	es			; save ES
 17818 00001C43 57                      	push	di
 17819                                  
 17820                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 17821 00001C44 B800B7                  	mov	ax,0B700h
 17822 00001C47 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17823 00001C49 08C0                    	or	al,al
 17824 00001C4B 7423                    	jz	short daRet		; APPEND not installed, return
 17825                                  
 17826                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 17827 00001C4D B802B7                  	mov	ax,0B702h
 17828 00001C50 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17829 00001C52 83F8FF                  	cmp	ax,0FFFFh
 17830 00001C55 7519                    	jne	short daRet		; it's not a local version, return
 17831                                  
 17832                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 17833 00001C57 B806B7                  	mov	ax,0B706h
 17834 00001C5A CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17835                                  
 17836 00001C5C 8E1E[C08A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 17837                                  
 17838 00001C60 891E[C301]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 17839 00001C64 C606[C501]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 17840                                  
 17841 00001C69 31DB                    	xor	bx,bx			; BX = APPEND state = off
 17842                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 17843 00001C6B B807B7                  	mov	ax,0B707h
 17844 00001C6E CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17845                                  daRet:	
 17846 00001C70 5F                      	pop	di
 17847 00001C71 07                      	pop	es			; restore ES
 17848 00001C72 1F                      	pop	ds			; restore DS
 17849                                  
 17850 00001C73 C3                      	retn
 17851                                  
 17852                                  ; ---------------------------------------------------------------------------
 17853                                  
 17854                                  ; Find the Volume ID on the disk.
 17855                                  
 17856                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17857                                  
 17858                                  	; MSDOS 6.0
 17859                                  OkVolArg:
 17860 00001C74 E8CAFF                  	call	DisAppend		; disable APPEND
 17861 00001C77 E85F09                  	call	CRLF2
 17862                                  	;mov	al,blank			
 17863 00001C7A B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17864 00001C7C E87D01                  	call	PRINT_CHAR		;AN051;  before volume message
 17865 00001C7F 1E                      	push	ds
 17866 00001C80 07                      	pop	es
 17867                                  
 17868                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 17869                                  ; of volume_id ONLY.
 17870                                  
 17871 00001C81 BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 17872 00001C84 B0FF                    	mov	al,-1			; Tag to indicate Extention
 17873 00001C86 AA                      	stosb
 17874 00001C87 31C0                    	xor	ax,ax			; Zero padding to volume label
 17875 00001C89 AB                      	stosw
 17876 00001C8A AB                      	stosw
 17877 00001C8B AA                      	stosb
 17878 00001C8C B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 17879 00001C8E AA                      	stosb
 17880 00001C8F 47                      	inc	di			; Skip drive byte; it is already set
 17881 00001C90 B90B00                  	mov	cx,11			; fill in remainder of file
 17882 00001C93 B03F                    	mov	al,'?'
 17883 00001C95 F3AA                    	rep	stosb
 17884                                  
 17885                                  ; Set up transfer address (destination of search first information)
 17886                                  
 17887 00001C97 BA[C98B]                	mov	dx,DIRBUF
 17888                                  	;mov	ah,Set_DMA
 17889 00001C9A B41A                    	mov	ah,1Ah
 17890 00001C9C CD21                    	int	21h
 17891                                  
 17892                                  ; Do the search
 17893                                  
 17894 00001C9E BA5500                  	mov	dx,FCB-7 ; 55h
 17895                                  	;mov	ah,Dir_Search_First
 17896 00001CA1 B411                    	mov	ah,11h
 17897 00001CA3 CD21                    	int	21h
 17898                                  
 17899                                  ;********************************
 17900                                  ; Print volume ID info
 17901                                  
 17902 00001CA5 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 17903 00001CA6 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 17904 00001CA9 0440                    	add	al,'@'  ; add al,40h
 17905 00001CAB 3C40                    	cmp	al,'@'
 17906 00001CAD 7505                    	jne	short drvok
 17907 00001CAF A0[D48A]                	mov	al,[CURDRV]
 17908                                  	;add	al,capital_A
 17909 00001CB2 0441                    	add	al,'A'
 17910                                  drvok:
 17911 00001CB4 A2[C18C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 17912 00001CB7 58                      	pop	ax			;AC000; get return code back
 17913 00001CB8 08C0                    	or	al,al			;AC000; volume label found?
 17914 00001CBA 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 17915 00001CBC BA[5080]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 17916 00001CBF EB13                    	jmp	short print_serial	;AC000; go print it
 17917                                  
 17918                                  Get_vol_name:
 17919 00001CC1 BF[FA8A]                	mov	di,CHARBUF
 17920 00001CC4 89FA                    	mov	dx,di
 17921 00001CC6 BE[D18B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 17922 00001CC9 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 17923 00001CCC F3A4                    	rep	movsb			;AN000;  3/3/KK
 17924                                  
 17925 00001CCE 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 17926 00001CD0 AA                      	stosb
 17927 00001CD1 BA[5E80]                	mov	dx,VolMes_Ptr		;AC000; set up message
 17928                                  
 17929                                  print_serial:
 17930                                  
 17931                                  ; Attempt to get the volume serial number from the disk. If an error
 17932                                  ; occurs, do not print volume serial number.
 17933                                  
 17934 00001CD4 52                      	push	dx			;AN000; save message offset
 17935                                  	;mov	ax,(GetSetMediaID SHL 8)
 17936 00001CD5 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 17937 00001CD8 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 17938 00001CDC BA[188E]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 17939 00001CDF CD21                    	int	21h			;AN000; do the call
 17940                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 17941                                  			; AL = 00h get serial number / 01h set serial number
 17942                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 17943                                  			; DS:DX -> disk info
 17944 00001CE1 5A                      	pop	dx			;AN000; get message offset back
 17945 00001CE2 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 17946 00001CE4 E83C31                  	call	std_printf		;AC000; go print volume message
 17947                                  	;mov	al,blank				
 17948 00001CE7 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17949 00001CE9 E81001                  	call	PRINT_CHAR		;AN051;  before volume message
 17950 00001CEC BA[7780]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 17951                                  printvol_end:
 17952 00001CEF E93131                  	jmp	std_printf		;AC000; go print and exit
 17953                                  
 17954                                  ; ---------------------------------------------------------------------------
 17955                                  
 17956                                  ;****************************************************************
 17957                                  ;*
 17958                                  ;* ROUTINE:	Set_ext_error_msg
 17959                                  ;*
 17960                                  ;* FUNCTION:	Sets up extended error message for printing
 17961                                  ;*
 17962                                  ;* INPUT:	return from INT 21
 17963                                  ;*
 17964                                  ;* OUTPUT:	extended error message set up in extended error
 17965                                  ;*		buffer.
 17966                                  ;*
 17967                                  ;****************************************************************
 17968                                  	
 17969                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17970                                  
 17971                                  	; MSDOS 6.0
 17972                                  Set_Ext_Error_Msg:			;AN000;
 17973 00001CF2 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 17974 00001CF5 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 17975                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 17976 00001CFA BA[557F]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 17977 00001CFD A3[557F]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 17978 00001D00 F9                      	stc				;AN000; make sure carry is set
 17979 00001D01 C3                      	retn				;AN000; return
 17980                                  
 17981                                  ; ---------------------------------------------------------------------------
 17982                                  
 17983                                  ;****************************************************************
 17984                                  ;*
 17985                                  ;* ROUTINE:	Get_ext_error_number
 17986                                  ;*
 17987                                  ;* FUNCTION:	Does get extended error function call
 17988                                  ;*
 17989                                  ;* INPUT:	return from INT 21
 17990                                  ;*
 17991                                  ;* OUTPUT:	AX - extended error number
 17992                                  ;*
 17993                                  ;****************************************************************
 17994                                  
 17995                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17996                                  
 17997                                  	; MSDOS 6.0
 17998                                  get_ext_error_number:			;AN022;
 17999                                  
 18000                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 18001                                  					;AN022; save registers
 18002 00001D02 53                      	push	bx
 18003 00001D03 51                      	push	cx
 18004 00001D04 52                      	push	dx
 18005 00001D05 56                      	push	si
 18006 00001D06 57                      	push	di
 18007 00001D07 55                      	push	bp
 18008 00001D08 06                      	push	es
 18009 00001D09 1E                      	push	ds
 18010                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 18011 00001D0A B459                    	mov	ah,59h
 18012 00001D0C 31DB                    	xor	bx,bx			;AN022; clear BX
 18013 00001D0E CD21                    	int	21h			;AN022;
 18014                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 18015                                  			; BX = version code (0000h for DOS 3.x)
 18016                                  
 18017                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 18018                                  					;AN022; restore registers
 18019 00001D10 1F                      	pop	ds
 18020 00001D11 07                      	pop	es
 18021 00001D12 5D                      	pop	bp
 18022 00001D13 5F                      	pop	di
 18023 00001D14 5E                      	pop	si
 18024 00001D15 5A                      	pop	dx
 18025 00001D16 59                      	pop	cx
 18026 00001D17 5B                      	pop	bx
 18027                                  
 18028 00001D18 C3                      	retn				;AN022; return
 18029                                  
 18030                                  ;============================================================================
 18031                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 18032                                  ;============================================================================
 18033                                  ; 08/10/2018 - Retro DOS v3.0
 18034                                  
 18035                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 18036                                  
 18037                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18038                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 18039                                  
 18040                                  ; ---------------------------------------------------------------------------
 18041                                  
 18042                                  ; MSDOS 6.0
 18043                                  ;***	Version - display DOS version
 18044                                  ;
 18045                                  ;	SYNTAX	ver [/debug]
 18046                                  ;
 18047                                  ;		/debug - display additional DOS configuration info
 18048                                  ;
 18049                                  ;	ENTRY	command-line tail is in PSP
 18050                                  ;
 18051                                  ;	EXIT	if successful, nothing
 18052                                  ;		if parse fails,
 18053                                  ;		  parse error message is set up (for Std_EPrintf)
 18054                                  ;		    AX = system parser error code
 18055                                  ;		    DX = ptr to message block
 18056                                  ;		  we jump to CError
 18057                                  ;
 18058                                  ;	EFFECTS
 18059                                  ;	  If parse fails, a parse error message is displayed.
 18060                                  ;	  Otherwise, version message is displayed.
 18061                                  ;	  If /debug is specified, additional DOS info is displayed.
 18062                                  
 18063                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18064                                  VERSION:
 18065                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 18066                                  
 18067                                  ;	Parse command line for /debug switch.
 18068                                  
 18069 00001D19 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 18070 00001D1C BF[E785]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 18071 00001D1F 31C9                    	xor	cx,cx			; CX = # positional param's found
 18072 00001D21 E89A04                  	call	Parse_With_Msg
 18073                                  
 18074 00001D24 B301                    	mov	bl,1			; BL = flag = /debug present
 18075                                  	;cmp	ax,RESULT_NO_ERROR
 18076                                  	;cmp	ax,0
 18077                                  	;je	short verPrintVer	; something parsed - must be /debug
 18078 00001D26 09C0                    	or	ax,ax
 18079 00001D28 740A                    	jz	short verPrintVer 
 18080 00001D2A FECB                    	dec	bl			; BL = flag = no /debug present
 18081                                  	;cmp	ax,END_OF_LINE ; -1
 18082 00001D2C 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18083 00001D2F 7403                    	je	short verPrintVer	; reached end of line - ok
 18084                                  
 18085                                  ;	The parse failed. Error message has been set up.
 18086                                  
 18087 00001D31 E9260C                  	jmp	cerror
 18088                                  
 18089                                  verPrintVer:
 18090 00001D34 53                      	push	bx			; save /debug flag
 18091 00001D35 E8A108                  	call	CRLF2
 18092 00001D38 E83F00                  	call	PRINT_VERSION
 18093 00001D3B E89B08                  	call	CRLF2
 18094 00001D3E 5B                      	pop	bx   			; BL = /debug flag
 18095 00001D3F 08DB                    	or	bl,bl
 18096 00001D41 7434                    	jz	short verDone		; /debug is false - we're done
 18097                                  
 18098                                  ;*	For /debug, display DOS internal revision and DOS location
 18099                                  ;	(low memory, HMA, or ROM).
 18100                                  
 18101                                  ;	Bugbug:	use symbols for bitmasks below.
 18102                                  
 18103                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 18104 00001D43 B80633                  	mov	ax,3306h
 18105 00001D46 CD21                    	int	21h
 18106                                  		; DOS - 5+ Get TRUE Version Number
 18107                                  		; (BL major, BH minor, DL revision, DH flags)
 18108 00001D48 88D0                    	mov	al,dl			;revision number in dl; M013
 18109 00001D4A 88F7                    	mov	bh,dh			;flags in dh now; M013
 18110                                  ;M032	and	al,7			; AL = DOS internal revision
 18111 00001D4C 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18112                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18113 00001D4E 7602                    	jbe	short ver1
 18114 00001D50 B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18115                                  ;@@:
 18116                                  ver1:
 18117 00001D52 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18118 00001D54 A2[BF8C]                	mov	[One_Char_Val],al
 18119 00001D57 BA[A581]                	mov	dx,dosrev_ptr
 18120 00001D5A E8C630                  	call	std_printf		; print DOS internal revision
 18121                                  
 18122 00001D5D B104                    	mov	cl,4
 18123 00001D5F D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18124 00001D61 7209                    	jc	short verRom
 18125 00001D63 D0EF                    	shr	bh,1			; CY = DOS in HMA
 18126 00001D65 720A                    	jc	short verHma
 18127                                  
 18128                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18129                                  
 18130                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18131 00001D67 BA[B981]                	mov	dx,DosLow_Ptr
 18132 00001D6A EB08                    	jmp	short verPrintLoc
 18133                                  verRom: 
 18134                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18135 00001D6C BA[B381]                	mov	dx,DosRom_Ptr
 18136 00001D6F EB03                    	jmp	short verPrintLoc
 18137                                  verHma: 
 18138                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18139 00001D71 BA[B681]                	mov	dx,DosHma_Ptr
 18140                                  verPrintLoc:
 18141 00001D74 E8AC30                  	call	std_printf
 18142                                  verDone:
 18143 00001D77 E95F08                  	jmp	CRLF2
 18144                                  
 18145                                  ; 21/02/2023
 18146                                  ;	; MSDOS 3.3
 18147                                  ;VERSION:
 18148                                  ;	call	CRLF2
 18149                                  ;	call	PRINT_VERSION
 18150                                  ;	jmp	CRLF2
 18151                                  
 18152                                  ; =============== S U B	R O U T	I N E =======================================
 18153                                  
 18154                                  	; 21/02/2023 - Retro DOS v4.0
 18155                                  PRINT_VERSION:
 18156                                  	;mov	ah,GET_VERSION ; 30h
 18157 00001D7A B430                    	mov	ah,30h
 18158 00001D7C CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18159                                  			; Return: AL = major version number (00h for DOS 1.x)
 18160 00001D7E 50                      	push	ax
 18161 00001D7F 30E4                    	xor	ah,ah
 18162 00001D81 A3[BB8C]                	mov	[Major_Ver_Num],ax
 18163 00001D84 58                      	pop	ax
 18164 00001D85 86E0                    	xchg	ah,al
 18165 00001D87 30E4                    	xor	ah,ah
 18166 00001D89 A3[BD8C]                	mov	[Minor_Ver_Num],ax
 18167 00001D8C BA[3780]                	mov	dx,VerMes_Ptr
 18168 00001D8F E99130                  	jmp	std_printf
 18169                                  
 18170                                  ; =============== S U B	R O U T	I N E =======================================
 18171                                  
 18172                                  	; 21/02/2023 - Retro DOS v4.0
 18173                                  PRINT_PROMPT:
 18174 00001D92 1E                      	push	ds
 18175 00001D93 0E                      	push	cs
 18176 00001D94 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 18177 00001D95 06                      	push	es
 18178 00001D96 E87E05                  	call	find_prompt	; Look for prompt string
 18179 00001D99 7206                    	jc	short PP0	; Can't find one	
 18180 00001D9B 26803D00                	cmp	byte [es:di],0
 18181 00001D9F 7524                    	jnz	short PP1
 18182                                  PP0:				; Use default prompt
 18183 00001DA1 E86700                  	call	PRINT_DRIVE
 18184 00001DA4 B03E                    	mov	al,'>'
 18185                                  	;mov	al,SYM
 18186 00001DA6 E85300                  	call	PRINT_CHAR
 18187 00001DA9 EB36                    	jmp	short PP5
 18188                                  ;PP1:
 18189                                  ;	mov	al,[es:di]	; Get a char
 18190                                  ;	inc	di
 18191                                  ;	or	al,al
 18192                                  ;	jz	short PP5	; Nul terminated
 18193                                  ;	; 21/02/2023
 18194                                  ;	cmp	al,'$' ; 24h
 18195                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18196                                  ;	jz	short PP2	; Nope
 18197                                  ;	call	PRINT_CHAR
 18198                                  ;	jmp	short PP1
 18199                                  PP2:
 18200 00001DAB 268A05                  	mov	al,[es:di]
 18201 00001DAE 47                      	inc	di
 18202                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18203 00001DAF BB[C382]                	mov	bx,PROMPT_TABLE-3
 18204 00001DB2 08C0                    	or	al,al
 18205 00001DB4 742B                    	jz	short PP5
 18206                                  PP3:
 18207 00001DB6 83C303                  	add	bx,3
 18208                                  	; 21/02/2023
 18209 00001DB9 E83206                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18210                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18211 00001DBC 3A07                    	cmp	al,[bx]
 18212 00001DBE 7416                    	jz	short PP4
 18213 00001DC0 803F00                  	cmp	byte [bx],0
 18214 00001DC3 75F1                    	jnz	short PP3
 18215                                  	;jmp	short PP1
 18216                                  	; 21/02/2023
 18217                                  PP1:
 18218 00001DC5 268A05                  	mov	al,[es:di]	; Get a char
 18219 00001DC8 47                      	inc	di
 18220 00001DC9 08C0                    	or	al,al
 18221 00001DCB 7414                    	jz	short PP5	; Nul terminated
 18222                                  	; 21/02/2023
 18223 00001DCD 3C24                    	cmp	al,'$' ; 24h
 18224                                  	;cmp	al,[DOLLAR]	; Meta character
 18225 00001DCF 74DA                    	jz	short PP2	; Nope
 18226 00001DD1 E82800                  	call	PRINT_CHAR
 18227 00001DD4 EBEF                    	jmp	short PP1
 18228                                  PP4:
 18229 00001DD6 06                      	push	es
 18230 00001DD7 57                      	push	di
 18231 00001DD8 0E                      	push	cs
 18232 00001DD9 07                      	pop	es
 18233 00001DDA FF5701                  	call	word [bx+1]
 18234 00001DDD 5F                      	pop	di
 18235 00001DDE 07                      	pop	es
 18236 00001DDF EBE4                    	jmp	short PP1
 18237                                  PP5:
 18238 00001DE1 07                      	pop	es		; Restore segments
 18239 00001DE2 1F                      	pop	ds
 18240 00001DE3 C3                      	retn
 18241                                  
 18242                                  ; ---------------------------------------------------------------------------
 18243                                  
 18244                                  PRINT_BACK:
 18245                                  	; 21/02/2023
 18246 00001DE4 BA[3181]                	mov	dx,dback_ptr
 18247 00001DE7 E93930                  	jmp	std_printf
 18248                                  
 18249                                  ; ---------------------------------------------------------------------------
 18250                                  
 18251                                  PRINT_EQ:
 18252 00001DEA B03D                    	mov	al,'='
 18253 00001DEC EB0E                    	jmp	short PRINT_CHAR
 18254                                  
 18255                                  ; ---------------------------------------------------------------------------
 18256                                  
 18257                                  PRINT_ESC:
 18258 00001DEE B01B                    	mov	al,1Bh
 18259 00001DF0 EB0A                    	jmp	short PRINT_CHAR
 18260                                  
 18261                                  ; ---------------------------------------------------------------------------
 18262                                  
 18263                                  	; 21/02/2023
 18264                                  PRINT_G:
 18265                                  	;mov	al,[RABRACKET]
 18266 00001DF2 B03E                    	mov	al,'>' ; 3Eh
 18267 00001DF4 EB06                    	jmp	short PRINT_CHAR
 18268                                  
 18269                                  ; ---------------------------------------------------------------------------
 18270                                  
 18271                                  	; 21/02/2023
 18272                                  PRINT_L:
 18273                                  	;mov	al,[LABRACKET]
 18274 00001DF6 B03C                    	mov	al,'<' ; 3Ch
 18275 00001DF8 EB02                    	jmp	short PRINT_CHAR
 18276                                  
 18277                                  ; ---------------------------------------------------------------------------
 18278                                  
 18279                                  	; 21/02/2023
 18280                                  Print_B:
 18281                                  	;mov	al,[VBAR]
 18282 00001DFA B07C                    	mov	al,'|' ; 7Ch
 18283                                  
 18284                                  ; =============== S U B	R O U T	I N E =======================================
 18285                                  
 18286                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18287                                  PRINT_CHAR:
 18288                                  	; MSDOS 6.0
 18289                                  
 18290                                  ;	Bugbug:	Why bother with ds,es here?
 18291                                  		
 18292 00001DFC 06                      	push	es
 18293 00001DFD 1E                      	push	ds
 18294 00001DFE 07                      	pop	es
 18295 00001DFF 57                      	push	di
 18296 00001E00 52                      	push	dx
 18297 00001E01 88C2                    	mov	dl,al		;AC000; Get char into al
 18298                                  	;mov	ah,STD_CON_OUTPUT
 18299                                  				;AC000; print the char to stdout
 18300 00001E03 B402                    	mov	ah,2
 18301 00001E05 CD21                    	int	21h		;AC000;
 18302 00001E07 5A                      	pop	dx
 18303 00001E08 5F                      	pop	di
 18304 00001E09 07                      	pop	es
 18305 00001E0A C3                      	retn
 18306                                  
 18307                                  ;21/02/2023
 18308                                  %if 0
 18309                                  	; MSDOS 3.3
 18310                                  	push	es
 18311                                  	push	ds
 18312                                  	pop	es
 18313                                  	push	di
 18314                                  	push	dx
 18315                                  	mov	di,ONE_CHAR_VAL	
 18316                                  	stosb
 18317                                  	mov	dx,ONECHRVALPTR
 18318                                  	call	STD_PRINTF
 18319                                  	pop	dx
 18320                                  	pop	di
 18321                                  	pop	es
 18322                                  	retn
 18323                                  %endif
 18324                                  
 18325                                  ; ---------------------------------------------------------------------------
 18326                                  
 18327                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18328                                  PRINT_DRIVE:
 18329                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18330 00001E0B B419                    	mov	ah,19h
 18331 00001E0D CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18332 00001E0F 0441                    	add	al,'A'
 18333                                  	;add	al,[CAPITAL_A]
 18334                                  	;call	PRINT_CHAR
 18335                                  	;retn
 18336                                  	; 21/02/2023
 18337 00001E11 EBE9                    	jmp	short PRINT_CHAR
 18338                                  
 18339                                  ; ---------------------------------------------------------------------------
 18340                                  
 18341                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18342                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18343                                  
 18344                                  build_dir_for_prompt:
 18345 00001E13 30D2                    	xor	dl,dl
 18346 00001E15 BE[C98B]                	mov	si,BWDBUF
 18347 00001E18 89F7                    	mov	di,si
 18348 00001E1A A0[D48A]                	mov	al,[CURDRV]
 18349 00001E1D 0441                    	add	al,'A'
 18350 00001E1F B43A                    	mov	ah,':'
 18351 00001E21 AB                      	stosw
 18352 00001E22 A0[C58A]                	mov	al,[DIRCHAR]
 18353 00001E25 AA                      	stosb
 18354 00001E26 87F7                    	xchg	si,di
 18355 00001E28 893E[B08C]              	mov	[string_ptr_2],di
 18356                                  	;mov	ah,CURRENT_DIR ; 47h
 18357 00001E2C B447                    	mov	ah,47h
 18358 00001E2E CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18359                                  			; DL = drive (0=default,1=A,etc.)
 18360                                  			; DS:SI	points to 64-byte buffer area
 18361                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18362 00001E30 BA[1C81]                	mov	dx,string_buf_ptr
 18363 00001E33 7303                    	jnc	short doprint
 18364                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18365 00001E35 BA[E47F]                	mov	dx,BADCURDRV
 18366                                  doprint:
 18367                                  	;call	std_printf
 18368                                  	;retn
 18369 00001E38 E9E82F                  	jmp	std_printf
 18370                                  
 18371                                  ; =============== S U B	R O U T	I N E =======================================
 18372                                  
 18373                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18374                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18375                                  
 18376                                  build_dir_for_chdir:
 18377 00001E3B E80D00                  	call	build_dir_string
 18378 00001E3E BA[C98B]                	mov	dx,DIRBUF
 18379 00001E41 8916[B08C]              	mov	[string_ptr_2],dx
 18380                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18381                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18382 00001E45 BA[1C81]                	mov	dx,string_buf_ptr
 18383                                  	;call	std_printf
 18384                                  	;retn
 18385                                  	; 21/02/2023
 18386                                  	;jmp	short doprint
 18387 00001E48 E9D82F                  	jmp	std_printf
 18388                                  
 18389                                  
 18390                                  ; =============== S U B	R O U T	I N E =======================================
 18391                                  
 18392                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18393                                  build_dir_string:
 18394 00001E4B 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18395 00001E4F 88D0                    	mov	al,dl
 18396 00001E51 0440                    	add	al,'@'	; 40h
 18397 00001E53 3C40                    	cmp	al,'@'
 18398 00001E55 7506                    	jne	short gotdrive
 18399 00001E57 0206[D48A]              	add	al,[CURDRV]
 18400 00001E5B FEC0                    	inc	al
 18401                                  gotdrive:
 18402 00001E5D 50                      	push	ax
 18403 00001E5E BE[CC8B]                	mov	si,BWDBUF+3
 18404                                  	;mov	ah,CURRENT_DIR ; 47h
 18405 00001E61 B447                    	mov	ah,47h
 18406 00001E63 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18407                                  			; DL = drive (0=default,1=A,etc.)
 18408                                  			; DS:SI	points to 64-byte buffer area
 18409 00001E65 7305                    	jnc	short dpbisok
 18410 00001E67 0E                      	push	cs
 18411 00001E68 1F                      	pop	ds
 18412 00001E69 E9F609                  	jmp	DRVBAD
 18413                                  dpbisok:
 18414 00001E6C BF[C98B]                	mov	di,BWDBUF
 18415 00001E6F 89FA                    	mov	dx,di
 18416 00001E71 58                      	pop	ax
 18417 00001E72 B43A                    	mov	ah,':'
 18418 00001E74 AB                      	stosw
 18419 00001E75 A0[C58A]                	mov	al,[DIRCHAR]
 18420 00001E78 AA                      	stosb
 18421 00001E79 C3                      	retn
 18422                                  
 18423                                  ; ---------------------------------------------------------------------------
 18424                                  
 18425                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18426                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18427                                  PATH:
 18428                                  	; MSDOS 6.0
 18429 00001E7A 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18430 00001E7C BF[EE87]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18431 00001E7F AA                      	stosb				;AN049; Initialize PATH to null
 18432 00001E80 4F                      	dec	di			;AN049; point to the start of buffer
 18433 00001E81 E8EE0C                  	call	PGETARG 		; Pre scan for arguments
 18434 00001E84 7460                    	jz	short disppath		; Print the current path
 18435                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18436 00001E86 3C3B                    	cmp	al,';' ; 3Bh
 18437 00001E88 7503                    	jne	short pathslp 		;AC049;
 18438 00001E8A 46                      	inc	si			;AN049; point past semicolon
 18439 00001E8B EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18440                                  pathslp:					; Get the user specified path
 18441 00001E8D AC                      	lodsb				; Get a character
 18442 00001E8E 3C0D                    	cmp	al,0Dh
 18443                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18444 00001E90 7434                    	je	short path_eol		;AC049; yes - end of command
 18445 00001E92 E82F05                  	call	testkanj		;See if DBCS
 18446 00001E95 7405                    	jz	short notkanj2		;No - continue
 18447 00001E97 AA                      	stosb				;AC049; Yes - store the first byte
 18448 00001E98 AC                      	lodsb				;skip second byte of DBCS
 18449                                  path_hold:				;AN049;
 18450 00001E99 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18451 00001E9A EBF1                    	jmp	short pathslp		;continue parsing
 18452                                  notkanj2:
 18453 00001E9C E84F05                  	call	UPCONV			;upper case the character
 18454                                  
 18455 00001E9F 3C3B                    	cmp	al,';' ; 3Bh
 18456                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18457 00001EA1 74F6                    	je	short path_hold		;AC049; go store it
 18458 00001EA3 E84807                  	call	DELIM			;delimiter?
 18459 00001EA6 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18460                                  scan_white:				;AN049; make sure were at EOL
 18461 00001EA8 AC                      	lodsb				;AN049; get a character
 18462 00001EA9 3C0D                    	cmp	al,0Dh
 18463                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18464 00001EAB 7419                    	je	short path_eol		;AN049; yes - go set path
 18465 00001EAD 3C20                    	cmp	al,' ' ; 20h
 18466                                  	;cmp	al,blank		;AN049; whitespace?
 18467 00001EAF 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18468                                  	;cmp	al,9
 18469 00001EB1 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18470 00001EB3 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18471                                  
 18472 00001EB5 BA[557F]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18473                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18474 00001EB8 C706[557F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18475                                  	;mov	byte [msg_disp_class],2		
 18476                                  					;AN049; set up parse error msg class
 18477 00001EBE C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class
 18478 00001EC3 E9940A                  	jmp	cerror			;AN049;
 18479                                  path_eol:				;AN049; Parsing was clean
 18480 00001EC6 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18481 00001EC8 AA                      	stosb				;AN049;    buffer
 18482 00001EC9 E84604                  	call	find_path		;AN049; Find PATH in environment
 18483 00001ECC E81A04                  	call	delete_path		;AC049; Delete any offending name
 18484 00001ECF E8D004                  	call	scan_double_null	;AC049; Scan to end of environment
 18485 00001ED2 E8A004                  	call	move_name		;AC049; move in PATH=
 18486 00001ED5 BE[EE87]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18487                                  store_path:				;AN049; Store the PATH in the environment
 18488 00001ED8 AC                      	lodsb				;AN049; Get a character
 18489                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18490 00001ED9 20C0                    	and	al,al ; al=0 ?
 18491 00001EDB 7405                    	jz	short got_paths		;AN049; yes - exit
 18492 00001EDD E83005                  	call	store_char		;AN049; no - store character
 18493 00001EE0 EBF6                    	jmp	short store_path	;AN049; continue
 18494                                  got_paths:				;AN049; we're finished
 18495 00001EE2 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18496 00001EE4 AB                      	stosw				;    	the environment
 18497 00001EE5 C3                      	retn
 18498                                  disppath:
 18499 00001EE6 E82904                  	call	find_path		;AN049;
 18500 00001EE9 E80300                  	call	print_path
 18501                                  	;call	CRLF2
 18502                                  	;retn
 18503                                  	; 21/02/2023
 18504 00001EEC E9EA06                  	jmp	CRLF2
 18505                                  
 18506                                  ; 21/02/2023
 18507                                  %if 0
 18508                                  	; MSDOS 3.3
 18509                                  	call	FIND_PATH		; Find PATH in environment
 18510                                  	call	PGETARG			; Pre scan for arguments
 18511                                  	jz	short DISPPATH		; Print the current path
 18512                                  	call	DELETE_PATH		; Delete any offending name
 18513                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18514                                  	call	MOVE_NAME		; Move in PATH=
 18515                                  	call	PGETARG
 18516                                  	cmp	al,';'
 18517                                  	jz	short GOTPATHS
 18518                                  PATHSLP:
 18519                                  	lodsb
 18520                                  	cmp	al,0Dh			; End of line (CR) ?		
 18521                                  	jz	short GOTPATHS		; yes - exit
 18522                                  	;call	UPCONV	; MSDOS 6.0
 18523                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18524                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18525                                  	jz	short NOTDELIM		; go set path
 18526                                  	call	DELIM			; is it delim/null char ?
 18527                                  	jz	short GOTPATHS		; yes - exit
 18528                                  NOTDELIM:
 18529                                  	call	STORE_CHAR		; no - store character
 18530                                  	jmp	short PATHSLP
 18531                                  GOTPATHS:
 18532                                  	xor	ax,ax			; null terminate the PATH
 18533                                  	stosw				; in the environment
 18534                                  	retn
 18535                                  DISPPATH:
 18536                                  	call	PRINT_PATH
 18537                                  	call	CRLF2
 18538                                  	retn
 18539                                  %endif
 18540                                  
 18541                                  ; =============== S U B	R O U T	I N E =======================================
 18542                                  
 18543                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18544                                  print_path:
 18545 00001EEF 26803D00                	cmp	byte [es:di],0
 18546 00001EF3 750A                    	jnz	short path1
 18547                                  path0:
 18548 00001EF5 BA[AA80]                	mov	dx,NULLPATH_PTR
 18549 00001EF8 0E                      	push	cs
 18550 00001EF9 07                      	pop	es
 18551 00001EFA 0E                      	push	cs
 18552 00001EFB 1F                      	pop	ds
 18553 00001EFC E9242F                  	jmp	std_printf
 18554                                  path1:
 18555 00001EFF 06                      	push	es
 18556 00001F00 1F                      	pop	ds
 18557 00001F01 83EF05                  	sub	di,5
 18558 00001F04 89FE                    	mov	si,di
 18559 00001F06 E8B304                  	call	SCASB2		; Look for null
 18560                                  	;cmp	cx,0FFh ; 255
 18561                                  	; 21/02/2023
 18562                                  	;ch = 0
 18563 00001F09 80F9FF                  	cmp	cl,255
 18564 00001F0C 74E7                    	je	short path0
 18565 00001F0E 0E                      	push	cs
 18566 00001F0F 07                      	pop	es
 18567 00001F10 BF[2C8C]                	mov	di,Arg_Buf
 18568                                  	;mov	dx,100h ; 256
 18569                                  	;sub	dx,cx
 18570                                  	;xchg	dx,cx
 18571                                  	; 21/02/2023
 18572 00001F13 F6D9                    	neg	cl ; 256-cl
 18573 00001F15 F3A4                    	rep	movsb
 18574 00001F17 BA[F280]                	mov	dx,arg_buf_ptr
 18575 00001F1A 0E                      	push	cs
 18576 00001F1B 1F                      	pop	ds
 18577 00001F1C E9042F                  	jmp	std_printf
 18578                                  
 18579                                  ; ---------------------------------------------------------------------------
 18580                                  
 18581                                  ; ****************************************************************
 18582                                  ; *
 18583                                  ; * ROUTINE:	 CLS
 18584                                  ; *
 18585                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18586                                  ; *		 installed, send a control string to clear the
 18587                                  ; *		 screen.
 18588                                  ; *
 18589                                  ; * INPUT:	 command line at offset 81H
 18590                                  ; *
 18591                                  ; * OUTPUT:	 none
 18592                                  ; *
 18593                                  ; ****************************************************************
 18594                                  
 18595                                  	; MSDOS 6.0
 18596                                  
 18597                                  ANSI_installed	equ 0FFh
 18598                                  
 18599                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18600                                  CLS:
 18601                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18602                                  	;mov	ah,1Ah
 18603                                  	;mov	al,0			;AN000;
 18604 00001F1F B8001A                  	mov	ax,1A00h
 18605 00001F22 CD2F                    	int	2Fh			;AN000;
 18606                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18607                                  		; Return: AL = FFh if installed
 18608 00001F24 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18609 00001F26 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18610                                  
 18611                                  check_lines:
 18612                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18613 00001F28 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18614                                  	;mov	bx,stdout		;AN000; lines for stdout
 18615 00001F2B BB0100                  	mov	bx,1   ; handle
 18616                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18617                                  	;mov	ch,3   ; CON device	
 18618                                  	;;mov	cl,get_generic		;AN000; get information
 18619                                  	;mov	cl,7Fh ; minor function, get display info
 18620                                  	; 25/04/2023
 18621 00001F2E B97F03                  	mov	cx,037Fh
 18622 00001F31 BA[068E]                	mov	dx,Display_Ioctl	;AN000;
 18623 00001F34 CD21                    	int	21h			;AN000;
 18624 00001F36 720A                    	jc	short no_variable	;AN000; function had error, use default
 18625                                  		; 21/02/2023
 18626                                  		; ds:dx = parameter block
 18627                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18628                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18629                                  		;   	 01h  byte  reserved
 18630                                  		;   	 02h  word  length of following data
 18631                                  		;   	 04h  word  control flags
 18632                                  		;	       bit 0 set for blink, clear for intensity
 18633                                  		;	       bits 1 to 15 reserved
 18634                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18635                                  		;   	 07h  byte  reserved
 18636                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18637                                  		;   	 0Ah  word  pixel columns
 18638                                  		;   	 0Ch  word  pixel rows
 18639                                  		;   	 0Eh  word  character columns
 18640                                  		;   	 10h  word  character rows
 18641                                  	
 18642                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18643                                  	;				;AN000; get number of rows returned
 18644                                  	;mov	dh,al			;AN000; set number of rows
 18645                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18646                                  	;				;AN000; get number of columns returned
 18647                                  	;mov	dl,al			;AN000; set number of columns
 18648                                  	; 21/02/2023
 18649 00001F38 8A16[148E]              	mov	dl,[display_width]
 18650 00001F3C 8A36[168E]              	mov	dh,[LinPerPag]
 18651 00001F40 EB3B                    	jmp	short regcls		;AN000; go do cls
 18652                                  
 18653                                  no_variable:
 18654                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18655                                  	;mov	bx,1
 18656                                  	; bx = 1
 18657                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18658 00001F42 B80044                  	mov	ax,4400h
 18659 00001F45 CD21                    	int	21h			;AC000;
 18660 00001F47 F6C280                  	test	dl,80h
 18661                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18662 00001F4A 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18663 00001F4C F6C210                  	test	dl,10h
 18664                                  	;test	dl,devid_SPECIAL	;AC000;
 18665 00001F4F 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18666                                  
 18667                                  ansicls:
 18668 00001F51 E85200                  	call	ansi_cls		;AN000; clear the screen
 18669 00001F54 EB2C                    	jmp	short cls_ret		;AN000; exit
 18670                                  
 18671                                  ; Get video mode
 18672                                  
 18673                                  cls_normal:				;AC000;
 18674                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18675 00001F56 B40F                    	mov	ah,0Fh
 18676                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18677 00001F58 CD10                    	int	10h
 18678 00001F5A 3C03                    	cmp	al,3
 18679                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18680 00001F5C 760A                    	jbe	short DoAlpha
 18681 00001F5E 3C07                    	cmp	al,7
 18682                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18683 00001F60 7406                    	je	short DoAlpha
 18684                                  
 18685                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18686                                  ; be just as bogus and set the mode that we just got. This will blank the
 18687                                  ; screen too.
 18688                                  
 18689                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18690 00001F62 B400                    	mov	ah,0
 18691                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18692 00001F64 CD10                    	int	10h
 18693 00001F66 EB1A                    	jmp	short cls_ret		;AC000; exit
 18694                                  
 18695                                  DoAlpha:
 18696                                  
 18697                                  ; Get video mode and number of columns to scroll
 18698                                  
 18699                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18700                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18701                                  ;M01   area
 18702                                  ;M01   Commented out code here is the original
 18703                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18704                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18705                                  ;M01	mov	dl,ah
 18706                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18707                                  
 18708                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18709                                  
 18710 00001F68 1E                      	push	ds
 18711                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18712 00001F69 B84000                  	mov	ax,40h
 18713 00001F6C 8ED8                    	mov	ds,ax			;  *			M01
 18714                                  
 18715                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18716 00001F6E 8A164A00                	mov	dl,[4Ah]
 18717                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18718 00001F72 8A368400                	mov	dh,[84h]
 18719 00001F76 1F                      	pop	ds			;			M01
 18720                                  
 18721 00001F77 08F6                    	or	dh,dh			; Q:ZERO		M01
 18722 00001F79 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18723                                  
 18724                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18725                                  	; 25/04/2023
 18726 00001F7B B619                    	mov	dh,25
 18727                                  regcls:
 18728 00001F7D FEC6                    	inc	dh			; height+1		M018
 18729 00001F7F E80100                  	call	reg_cls 		; go clear the screen
 18730                                  cls_ret:
 18731 00001F82 C3                      	retn				; exit
 18732                                  
 18733                                  ; ---------------------------------------------------------------------------
 18734                                  
 18735                                  ; 21/02/2023
 18736                                  %if 0
 18737                                  	; MSDOS 3.3
 18738                                  CLS:
 18739                                  	mov	bx,STDOUT ; 1
 18740                                  	mov	ax,IOCTL*256 ; 4400h
 18741                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18742                                  			; BX = file or device handle
 18743                                  	test	dl,80h	; devid_ISDEV
 18744                                  	jz	short ANSICLS	; If a file put out ANSI
 18745                                  	test	dl,10h  ; devid_SPECIAL
 18746                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18747                                  
 18748                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18749                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18750                                  			; AL = interrupt number
 18751                                  			; Return: ES:BX	= value	of interrupt vector
 18752                                  	mov	dx,es
 18753                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18754                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18755                                  			; AL = interrupt number
 18756                                  			; Return: ES:BX	= value	of interrupt vector
 18757                                  	mov	ax,es
 18758                                  	cmp	dx,ax	; If not default driver, do ANSI
 18759                                  	ja	short ANSICLS
 18760                                  
 18761                                  	mov	ah,0Fh
 18762                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18763                                  			; Return: AH = number of columns on screen
 18764                                  			; AL = current video mode
 18765                                  			; BH = current active display page
 18766                                  	cmp	al,3
 18767                                  	jbe	short DOALPHA
 18768                                  	cmp	al,7
 18769                                  	jz	short DOALPHA
 18770                                  	mov	ah,0
 18771                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18772                                  			; AL = mode
 18773                                  	retn
 18774                                  
 18775                                  DOALPHA:
 18776                                  	mov	ah,0Bh	; Set overscan to black
 18777                                  	xor	bx,bx
 18778                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18779                                  			; BH = 00h, BL = border color
 18780                                  			; BH = 01h, BL = palette (0-3)
 18781                                  	mov	ah,0Fh
 18782                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18783                                  			; Return: AH = number of columns on screen
 18784                                  			; AL = current video mode
 18785                                  			; BH = current active display page
 18786                                  	mov	dl,ah
 18787                                  	dec	dl
 18788                                  	mov	dh,24
 18789                                  	xor	ax,ax
 18790                                  	mov	cx,ax
 18791                                  	mov	bx,700h
 18792                                  	mov	ah,6
 18793                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 18794                                  			; AL = number of lines to scroll window	
 18795                                  			;	(0 = blank whole window)
 18796                                  			; BH = attributes to be	used on	blanked	lines
 18797                                  			; CH,CL	= row,column of	upper left corner of window 
 18798                                  			;	  to scroll
 18799                                  			; DH,DL	= row,column of	lower right corner of window
 18800                                  	xor	dx,dx
 18801                                  	mov	bh,0
 18802                                  	mov	ah,2
 18803                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 18804                                  			; DH,DL	= row,column (0,0 = upper left)
 18805                                  			; BH = page number
 18806                                  	retn
 18807                                  
 18808                                  ANSICLS:
 18809                                  	mov	si,CLSSTRING
 18810                                  	lodsb
 18811                                  	mov	cl,al
 18812                                  	xor	ch,ch
 18813                                  	mov	ah,RAW_CON_IO ; 6
 18814                                  CLRLOOP:
 18815                                  	lodsb
 18816                                  	mov	dl,al
 18817                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 18818                                  			; DL = character <> FFh
 18819                                  			;  Return: ZF set = no character
 18820                                  			;   ZF clear = character recieved, AL = character
 18821                                  	loop	CLRLOOP
 18822                                  	retn
 18823                                  %endif
 18824                                  
 18825                                  ; ---------------------------------------------------------------------------
 18826                                  
 18827                                  ; MSDOS 6.0
 18828                                  
 18829                                  ; ****************************************************************
 18830                                  ; *
 18831                                  ; * ROUTINE:	 REG_CLS
 18832                                  ; *
 18833                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 18834                                  ; *
 18835                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 18836                                  ; *		 DH = NUMBER OF ROWS
 18837                                  ; *
 18838                                  ; * OUTPUT:	 none
 18839                                  ; *
 18840                                  ; ****************************************************************
 18841                                  
 18842                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18843                                  reg_cls:
 18844                                  ; Set overscan to black.
 18845                                  
 18846 00001F83 FECE                    	dec	dh			; decrement rows and columns
 18847 00001F85 FECA                    	dec	dl			;  to zero base
 18848 00001F87 52                      	push	dx			; save rows,columns
 18849                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 18850 00001F88 B40B                    	mov	ah,0Bh
 18851 00001F8A 31DB                    	xor	bx,bx
 18852                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18853 00001F8C CD10                    	int	10h
 18854 00001F8E 5A                      	pop	dx			;  restore rows,colums
 18855                                  
 18856 00001F8F 31C0                    	xor	ax,ax			; zero out ax
 18857 00001F91 89C1                    	mov	cx,ax			;  and cx
 18858                                  
 18859                                  ; Scroll active page
 18860                                  
 18861                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 18862 00001F93 B406                    	mov	ah,6
 18863                                  	;mov	bh,video_attribute	; attribute for blank line
 18864 00001F95 B707                    	mov	bh,7
 18865 00001F97 30DB                    	xor	bl,bl			; set BL to 0
 18866                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18867 00001F99 CD10                    	int	10h
 18868                                  
 18869                                  ; Seek to cursor to 0,0
 18870                                  
 18871                                  ;M022 following two lines added
 18872                                  	;mov	ah,get_video_state	; get current video page in BH
 18873 00001F9B B40F                    	mov	ah,0Fh
 18874                                  	;int	video_io_int
 18875 00001F9D CD10                    	int	10h
 18876                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 18877 00001F9F B402                    	mov	ah,2
 18878 00001FA1 31D2                    	xor	dx,dx			; row and column 0
 18879                                  ;M022	mov	bh,0
 18880                                  	;int	video_io_int		; do into 10h - BIOS video IO
 18881 00001FA3 CD10                    	int	10h
 18882                                  
 18883 00001FA5 C3                      	retn
 18884                                  
 18885                                  ; ---------------------------------------------------------------------------
 18886                                  
 18887                                  ; MSDOS 6.0
 18888                                  
 18889                                  ; ****************************************************************
 18890                                  ; *
 18891                                  ; * ROUTINE:	 ANSI_CLS
 18892                                  ; *
 18893                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 18894                                  ; *		 to STDOUT.
 18895                                  ; *
 18896                                  ; * INPUT:	 none
 18897                                  ; *
 18898                                  ; * OUTPUT:	 none
 18899                                  ; *
 18900                                  ; ****************************************************************
 18901                                  
 18902                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18903                                  ansi_cls:			;AC000;
 18904 00001FA6 BE[C182]                	mov	si,CLSSTRING
 18905                                  			; db 4,1Bh,'[2J'
 18906 00001FA9 AC                      	lodsb
 18907 00001FAA 88C1                    	mov	cl,al	; al = 4
 18908 00001FAC 30ED                    	xor	ch,ch
 18909                                  	;mov	ah,Raw_CON_IO
 18910 00001FAE B406                    	mov	ah,6
 18911                                  clrloop:
 18912 00001FB0 AC                      	lodsb
 18913 00001FB1 88C2                    	mov	dl,al
 18914 00001FB3 CD21                    	int	21h
 18915                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 18916 00001FB5 E2F9                    	loop	clrloop
 18917 00001FB7 C3                      	retn
 18918                                  
 18919                                  ;============================================================================
 18920                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 18921                                  ;============================================================================
 18922                                  ; 08/10/2018 - Retro DOS v3.0
 18923                                  
 18924                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 18925                                  
 18926                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18927                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 18928                                  
 18929                                  ; ---------------------------------------------------------------------------
 18930                                  
 18931                                  ; ****************************************************************
 18932                                  ; *
 18933                                  ; * ROUTINE:	 CTTY - Change console
 18934                                  ; *
 18935                                  ; * SYNTAX:	 CTTY device
 18936                                  ; *
 18937                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 18938                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 18939                                  ; *		 STDERR. This routine returns to LODCOM1.
 18940                                  ; *
 18941                                  ; * INPUT:	 command line at offset 81H
 18942                                  ; *
 18943                                  ; * OUTPUT:	 none
 18944                                  ; *
 18945                                  ; ****************************************************************
 18946                                  
 18947                                  	; 21/02/2023 - Retro DOS v4.0
 18948                                  CTTY:
 18949                                  	; MSDOS 6.0
 18950 00001FB8 1E                      	push	ds			;AN000; Get local ES
 18951 00001FB9 07                      	pop	es			;AN000;
 18952 00001FBA BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 18953 00001FBD BF[D585]                	mov	di,PARSE_CTTY
 18954                                  					;AC000; Get address of PARSE_CTTY
 18955 00001FC0 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 18956 00001FC2 31D2                    	xor	dx,dx			;AC000;
 18957 00001FC4 E88923                  	call	cmd_parse		;AC000; call parser
 18958 00001FC7 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18959                                  	;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 18960 00001FCA 7435                    	je	short ctty_error	;AN000; yes - error
 18961                                  	;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 18962 00001FCC 21C0                    	and	ax,ax ; ax > 0 ?
 18963 00001FCE 7531                    	jnz	short ctty_error	;AN000; YES -ERROR
 18964                                  
 18965 00001FD0 56                      	push	si			;AN000; save position in line
 18966 00001FD1 C536[F395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 18967 00001FD5 BF[2F8D]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 18968                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 18969 00001FD8 AC                      	lodsb				;AN000; get a char from buffer
 18970 00001FD9 AA                      	stosb				;AN000; store in srcbuf
 18971                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 18972 00001FDA 08C0                    	or	al,al ; al = 0 ?
 18973 00001FDC 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 18974                                  					;AN000; no - keep moving
 18975 00001FDE 5E                      	pop	si			;AN000; get line position back
 18976 00001FDF BF[D585]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 18977 00001FE2 E8C301                  	call	parse_check_eol 	;AN000; are we at end of line?
 18978                                  	;jz	short nocolon 		;AN000; yes - continue
 18979                                  	; 21/02/2023
 18980 00001FE5 751A                    	jnz	short ctty_error
 18981                                  ;ctty_error:
 18982                                  	;jmp	short isbaddev		;AC000; yes - exit
 18983                                  
 18984                                  	; 21/02/2023
 18985                                  	; MSDOS 3.3
 18986                                  	;call	SETPATH
 18987                                  	;dec	si
 18988                                  	;dec	si
 18989                                  	;cmp	byte [si],':'
 18990                                  	;jnz	short NOCOLON
 18991                                  	;mov	byte [si],0
 18992                                  nocolon:
 18993                                  	; 21/02/2023
 18994                                  	; MSDOS 6.0
 18995 00001FE7 BA[2F8D]                	mov	dx,SrcBuf
 18996                                  ;NOCOLON:
 18997                                  	; MSDOS 3.3 & MSDOS 6.0
 18998                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 18999                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 19000 00001FEA B8023D                  	mov	ax,3D02h ; 21/02/2023
 19001 00001FED CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 19002                                  			; DS:DX	-> ASCIZ filename
 19003                                  			; AL = access mode
 19004                                  			; 2 - read & write
 19005 00001FEF 7210                    	jc	short isbaddev
 19006 00001FF1 89C3                    	mov	bx,ax
 19007                                  	;mov	ax,IOCTL*256 ; 4400h
 19008 00001FF3 B80044                  	mov	ax,4400h
 19009 00001FF6 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 19010                                  			; BX = file or device handle
 19011 00001FF8 F6C280                  	test	dl,80h
 19012 00001FFB 750C                    	jnz	short devisok
 19013                                  closedev:
 19014                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 19015 00001FFD B43E                    	mov	ah,3Eh
 19016 00001FFF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19017                                  			; BX = file handle
 19018                                  ctty_error:
 19019                                  isbaddev:
 19020 00002001 BA[B080]                	mov	dx,BADDEV_PTR
 19021 00002004 E81C2E                  	call	std_printf
 19022 00002007 EB40                    	jmp	short resret
 19023                                  
 19024                                  	;nop
 19025                                  devisok:
 19026                                  	; 21/02/2023
 19027                                  	; MSDOS 6.0
 19028 00002009 52                      	push	dx		;AN007; save device info
 19029                                  	; 08/06/2023 (BugFix)
 19030 0000200A A1[3481]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 19031                                  	;mov	dh,util_msg_class
 19032 0000200D B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 19033 0000200F 53                      	push	bx		;AN021; save handle
 19034 00002010 E8F72E                  	call	TSYSGETMSG	;AN021; get the address of the message
 19035 00002013 89F2                    	mov	dx,si		;AN021; get address into dx
 19036                                  	;mov	ax,(Write shl 8)
 19037 00002015 B80040                  	mov	ax,4000h	;AN007; write to device
 19038 00002018 B90200                  	mov	cx,2		;AN007; write two bytes
 19039 0000201B CD21                    	int	21h		;AN007;
 19040 0000201D 5B                      	pop	bx		;AN021; get back handle
 19041 0000201E 5A                      	pop	dx		;AN007; get back device info
 19042 0000201F 72DC                    	jc	short closedev	;AN007; if error, quit
 19043                                  
 19044                                  	; MSDOS 3.3 & MSDOS 6.0
 19045 00002021 30F6                    	xor	dh,dh
 19046 00002023 80CA03                  	or	dl,3
 19047                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 19048                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 19049 00002026 B80144                  	mov	ax,4401h
 19050 00002029 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 19051                                  			; BX = device handle,DH = 0
 19052                                  			; DL = device information to set 
 19053                                  			;	(bits 0-7 from	function 0)
 19054 0000202B 53                      	push	bx
 19055 0000202C B90300                  	mov	cx,3
 19056 0000202F 31DB                    	xor	bx,bx
 19057                                  iclloop:			; Close basic handles
 19058                                  	;mov	ah,CLOSE ; 3Eh
 19059 00002031 B43E                    	mov	ah,3Eh
 19060 00002033 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19061                                  			; BX = file handle
 19062 00002035 43                      	inc	bx
 19063 00002036 E2F9                    	loop	iclloop
 19064 00002038 5B                      	pop	bx		; Get handle
 19065                                  	;mov	ah,XDUP ; 45h
 19066 00002039 B445                    	mov	ah,45h
 19067 0000203B CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19068                                  			; BX = file handle to duplicate
 19069                                  	;mov	ah,XDUP ; 45h
 19070 0000203D B445                    	mov	ah,45h
 19071 0000203F CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19072                                  			; BX = file handle to duplicate
 19073                                  	;mov	ah,XDUP ; 45h
 19074 00002041 B445                    	mov	ah,45h
 19075 00002043 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19076                                  			; BX = file handle to duplicate
 19077                                  	;mov	ah,CLOSE ; 3Eh
 19078 00002045 B43E                    	mov	ah,3Eh
 19079 00002047 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19080                                  			; BX = file handle
 19081                                  resret:
 19082 00002049 8E1E[C08A]              	mov	ds,[RESSEG]
 19083 0000204D 1E                      	push	ds
 19084                                  	;mov	ax,[18h]
 19085 0000204E A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 19086 00002051 A3[A201]                	mov	[Io_Save],ax
 19087                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 19088                                  	;;mov	ax,LODCOM1
 19089                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 19090                                  	;mov	ax,175h ; MSDOS 6.0
 19091 00002054 B8[7400]                	mov	ax,TrnLodCom1_Trap
 19092 00002057 50                      	push	ax
 19093                                  
 19094 00002058 CB                      	retf		; Far return
 19095                                  
 19096                                  ; ---------------------------------------------------------------------------
 19097                                  
 19098                                  ;****************************************************************
 19099                                  ;*
 19100                                  ;* ROUTINE:	CHCP - Change code page internal command
 19101                                  ;*		(added DOS 3.30 07/21/86)
 19102                                  ;*
 19103                                  ;* SYNTAX:	CHCP [xxx]
 19104                                  ;*		where xxx is a valid code page
 19105                                  ;*
 19106                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 19107                                  ;*		6402H to set the code page to xxxx. If no parameters
 19108                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19109                                  ;*		to get global code page and display it to the user.
 19110                                  ;*
 19111                                  ;* INPUT:	command line at offset 81H
 19112                                  ;*
 19113                                  ;* OUTPUT:	none
 19114                                  ;*
 19115                                  ;****************************************************************
 19116                                  
 19117                                  NLSFUNC_installed equ  0FFh
 19118                                  set_global_cp	  equ  2
 19119                                  get_global_cp	  equ  1
 19120                                  
 19121                                  	; 21/02/2023 - Retro DOS v4.0
 19122                                  	; 09/06/2023
 19123                                  CHCP:
 19124                                  	; MSDOS 6.0
 19125 00002059 1E                      	push	ds		;AN000; Get local ES
 19126 0000205A 07                      	pop	es		;AN000;
 19127 0000205B BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19128 0000205E BF[EC84]                	mov	di,PARSE_CHCP
 19129                                  				;AN000; Get address of PARSE_CHCP
 19130 00002061 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19131 00002063 31D2                    	xor	dx,dx		;AC000;
 19132 00002065 E85601                  	call    Parse_With_Msg	;AC018; call parser
 19133 00002068 83F8FF                  	cmp	ax,-1
 19134                                  	;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19135                                  	;jne	short setcp	;AC000; no go get number & set code page
 19136 0000206B 745D                    	je	short getcp	;AC000; yes - no parm - get code page
 19137                                  setcp:
 19138                                  	;cmp	ax,0
 19139                                  	;cmp	ax,RESULT_NO_ERROR
 19140                                  				;AN000; did we have an error?
 19141                                  	;jne	short cp_error	;AC018; yes - go issue message
 19142 0000206D 21C0                    	and	ax,ax ; ax > 0 ?
 19143 0000206F 7556                    	jnz	short cp_error	
 19144                                  
 19145                                  	;;push	cx		;AN000; save positional count
 19146                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 19147                                  	;;mov	cx,[bx]		;AN000;  into cx
 19148                                  	;;mov	[system_cpage],cx
 19149                                  	;			;AN000; save user input number
 19150                                  	;;pop	cx		;AC000; restore positional count
 19151                                  	;; 21/02/2023
 19152                                  	;mov	di,[bx]
 19153                                  	;mov	[system_cpage],di
 19154                                  	; 09/06/2023	
 19155 00002071 8B1E[F395]              	mov	bx,[PARSE1_ADDR]
 19156 00002075 891E[2A8C]              	mov	[system_cpage],bx
 19157                                  	;
 19158 00002079 BF[EC84]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19159 0000207C E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 19160 0000207F 7546                    	jnz	short cp_error	;AC000; no - exit
 19161                                  okset:
 19162                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19163                                  	;mov	ah,14h
 19164                                  	;mov	al,0		;AN000;
 19165 00002081 B80014                  	mov	ax,1400h
 19166 00002084 CD2F                    	int	2Fh		;AN000;
 19167                                  	;cmp	al,0FFh
 19168 00002086 3CFF                    	cmp	al,NLSFUNC_installed
 19169                                  				;AN000;
 19170 00002088 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19171 0000208A BA[DE7F]                	mov	dx,NLSFUNC_PTR
 19172                                  				;AN000; no - set up error message
 19173 0000208D EB38                    	jmp	short cp_error	;AN000; error exit
 19174                                  
 19175                                  ; 21/02/2023
 19176                                  %if 0
 19177                                  	; MSDOS 3.3
 19178                                  	mov	si,81h
 19179                                  	call	SCANOFF
 19180                                  	cmp	al,0Dh ; CR
 19181                                  	jnz	short SETCP
 19182                                  	jmp	short GETCP
 19183                                  
 19184                                  	;nop
 19185                                  SETCP:
 19186                                  	xor	bx,bx
 19187                                  	mov	cx,bx
 19188                                  	mov	ax,bx
 19189                                  GET_CP_DIGIT:
 19190                                  	lodsb
 19191                                  	cmp	al,'0'
 19192                                  	jb	short CHRNOTNUMBER
 19193                                  	cmp	al,'9'
 19194                                  	ja	short CHRNOTNUMBER
 19195                                  	sub	al,'0'
 19196                                  	inc	cl
 19197                                  	cmp	cl,4
 19198                                  	ja	short CHCP_BADPARM
 19199                                  	mov	dx,bx
 19200                                  	shl	dx,1
 19201                                  	shl	dx,1
 19202                                  	add	bx,dx
 19203                                  	shl	bx,1
 19204                                  	add	bx,ax
 19205                                  	jmp	short GET_CP_DIGIT
 19206                                  CP_NEXTCHR:
 19207                                  	lodsb
 19208                                  CHRNOTNUMBER:
 19209                                  	cmp	al,' '		; SPACE
 19210                                  	jz	short CP_NEXTCHR
 19211                                  	cmp	al,9		; TAB
 19212                                  	jz	short CP_NEXTCHR
 19213                                  	cmp	al,0Dh		; CR
 19214                                  	jz	short SET_CP_TBL_NUM
 19215                                  CHCP_BADPARM:
 19216                                  	mov	dx,BADPARMPTR
 19217                                  	jmp	CERROR
 19218                                  ;GOT_NLS:
 19219                                  %endif
 19220                                  	; 21/02/2023
 19221                                  got_NLS:
 19222                                  	; MSDOS 6.0
 19223 0000208F 8B1E[2A8C]              	mov	bx,[system_cpage]
 19224                                  				;AN000; get user input code page
 19225                                  ;SET_CP_TBL_NUM:
 19226                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19227                                  	;
 19228                                  	; MSDOS 3.3 & MSDOS 6.0
 19229                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19230                                  	;mov	ah,66h
 19231                                  	;;mov	al,set_global_cp 
 19232                                  	;mov	al,2		;minor - set
 19233                                  	; 26/04/2023
 19234 00002093 B80266                  	mov	ax,6602h
 19235 00002096 CD21                    	int	21h
 19236                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19237                                  		; BX = active code page
 19238                                  		; DX = system code page (active page at boot time)
 19239                                  
 19240 00002098 733F                    	jnc	short chcp_return
 19241                                  				;no error - exit
 19242                                  
 19243 0000209A 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19244 0000209D 7515                    	jnz	short chcp_other_error
 19245                                  
 19246                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19247 0000209F B459                    	mov	ah,59h
 19248 000020A1 31DB                    	xor	bx,bx
 19249 000020A3 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19250                                  			; BX = version code (0000h for DOS 3.x)
 19251                                  
 19252 000020A5 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19253 000020A8 7505                    	jne	short no_countrysys ; 26/04/2023
 19254                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19255 000020AA BA[E17F]                	mov	dx,INV_CODE_PAGE
 19256                                  	;jmp	cerror
 19257 000020AD EB18                    	jmp	short cp_error
 19258                                  
 19259                                  	; 21/02/2023
 19260                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19261                                  no_countrysys:
 19262                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19263                                  ;					;AN000; set up extended error msg class
 19264                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19265                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19266                                  					;AN000; get message number in control block
 19267 000020AF BA[C281]                	mov	dx,NoCntry_Ptr
 19268 000020B2 EB13                    	jmp	short cp_error
 19269                                  
 19270                                  chcp_other_error:		; end of p716
 19271                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19272 000020B4 B459                    	mov	ah,59h
 19273 000020B6 31DB                    	xor	bx,bx
 19274 000020B8 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19275                                  			; BX = version code (0000h for DOS 3.x)
 19276 000020BA 83F841                  	cmp	ax,65		;was it access denied?
 19277 000020BD 7505                    	jne	short none_set	;no - assume all failed
 19278 000020BF BA[C27F]                	mov	dx,cp_not_all_ptr
 19279                                  				;set up message
 19280                                  	;jmp	cerror		;AC000; error exit
 19281 000020C2 EB03                    	jmp     short cp_error
 19282                                  none_set:
 19283 000020C4 BA[B47F]                	mov	dx,cp_not_set_ptr
 19284                                  				;set up message
 19285                                  cp_error:
 19286 000020C7 E99008                  	jmp	cerror		;exit
 19287                                  getcp:
 19288                                  	;;mov	ah,GETSETCDPG ; 66h
 19289                                  	;mov	ah,66h		;get/set global code page function	
 19290                                  	;;mov	al,get_global_cp ; 1
 19291                                  	;mov	al,1		;minor - get
 19292                                  	; 26/04/2023
 19293 000020CA B80166                  	mov	ax,6601h
 19294 000020CD CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19295 000020CF 891E[2A8C]              	mov	[system_cpage],bx
 19296                                  				;get active cp for output
 19297 000020D3 BA[D07F]                	mov	dx,cp_active_ptr
 19298 000020D6 E84A2D                  	call	std_printf	;print it out
 19299                                  chcp_return:
 19300 000020D9 C3                      	retn
 19301                                  
 19302                                  ; ---------------------------------------------------------------------------
 19303                                  
 19304                                  ; ****************************************************************
 19305                                  ; *
 19306                                  ; * ROUTINE:	 TRUENAME
 19307                                  ; *
 19308                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19309                                  ; *		 Parses the command line. If a path is found, set
 19310                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19311                                  ; *		 set SRCXNAME to the drive letter. If no path
 19312                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19313                                  ; *		 current directory. Use the NAME TRANSLATE system
 19314                                  ; *		 call to get the real name and  then display the 
 19315                                  ; *		 real name. If an error occurs issue an error
 19316                                  ; *		 message and transfer control to  CERROR.
 19317                                  ; *
 19318                                  ; * INPUT:	 command line at offset 81H
 19319                                  ; *
 19320                                  ; * OUTPUT:	 none
 19321                                  ; *
 19322                                  ; ****************************************************************
 19323                                  
 19324                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19325                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19326                                  	; 10/06/2023
 19327                                  TRUENAME:				;AN000; TRUENAME entry point
 19328 000020DA 1E                      	push	ds			;AN000; Get local ES
 19329 000020DB 07                      	pop	es			;AN000;
 19330 000020DC BE8100                  	mov	si,81h			;AN000; Get command line
 19331 000020DF BF[4A85]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19332 000020E2 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19333 000020E4 31D2                    	xor	dx,dx			;AN000;
 19334 000020E6 E8D500                  	call	Parse_With_Msg		;AC018; call parser
 19335                                  
 19336 000020E9 BF[EE87]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19337                                  	;cmp	ax,0FFFFh
 19338                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19339                                  	;je	short tn_eol		;AN000; yes - go process
 19340                                  	;; 22/02/2023
 19341                                  	;;cmp	ax,0
 19342                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19343                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 19344                                  	;and	ax,ax ; ax = 0 ?
 19345                                  	;jnz	short tn_parse_error ; no, parse error
 19346                                  	; 10/06/2023
 19347 000020EC 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 19348 000020ED 7433                    	jz	short tn_eol ; ah = 0 ; *
 19349 000020EF 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 19350 000020F0 752D                    	jnz	short tn_parse_error
 19351                                  
 19352                                  	;cmp	byte [PARSE1_TYPE],6
 19353 000020F2 803E[EF95]06            	cmp	byte [PARSE1_TYPE],result_drive
 19354                                  					;AN000; was a drive entered?
 19355                                  	;je	short tn_drive		;AN000; yes - go process
 19356                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19357                                  	; 23/02/2023
 19358 000020F7 7512                    	jne	short tn_filespec
 19359                                  
 19360                                  ;tn_eol: 
 19361                                  ;	;mov	ah,0			;AN000; no parameters on line
 19362                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19363                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19364                                  ;	mov	al,'.'
 19365                                  ;	stosw				;AN000; store in srcxname
 19366                                  ;	jmp	short tn_doit		;AN000; go do command
 19367                                  
 19368                                  tn_drive:				;AN000; a drive was entered
 19369 000020F9 56                      	push	si			;AN000; save position in line
 19370 000020FA BE[F395]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19371 000020FD AC                      	lodsb				;AN000; get the drive number
 19372 000020FE 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19373 00002100 AA                      	stosb				;AN000; store it in srcxname
 19374                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19375 00002101 B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19376 00002104 AB                      	stosw				;AN000;  store in srcxname
 19377                                  	;mov	al,0
 19378 00002105 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19379 00002107 AA                      	stosb				;AN000;
 19380 00002108 5E                      	pop	si			;AN000; get line position back
 19381 00002109 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19382                                  
 19383                                  tn_filespec:				;AN000; a filespec was entered
 19384 0000210B 56                      	push	si			;AN000; save position in line
 19385 0000210C C536[F395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19386                                  
 19387                                  tn_move_filename:			;AN000; put filespec in srcxname
 19388 00002110 AC                      	lodsb				;AN000; get a char from buffer
 19389 00002111 AA                      	stosb				;AN000; store in srcxname
 19390                                  	;;cmp	al,0
 19391                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19392 00002112 08C0                    	or	al,al ; al = 0 ?
 19393 00002114 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19394 00002116 5E                      	pop	si			;AN000; get line position back
 19395                                  
 19396                                  tn_check_eol:				;AN000; make sure no extra parms
 19397 00002117 BF[4A85]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19398 0000211A E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19399 0000211D 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 19400                                  tn_parse_error: 			;AN000; A parse error occurred
 19401 0000211F E93808                  	jmp	cerror			;AN000; Go to error routine
 19402                                  
 19403                                  tn_eol: 
 19404                                  	;23/02/2023
 19405                                  	;;mov	ah,0			;AN000; no parameters on line
 19406                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19407                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19408                                  	;mov	al,'.'
 19409                                  	; 10/06/2023
 19410                                  	;mov	ax,002Eh
 19411                                  	; ah = 0 ; *
 19412 00002122 B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 19413                                  	;
 19414 00002124 AB                      	stosw				;AN000; store in srcxname
 19415                                  	; 23/02/2023
 19416                                  	;jmp	short tn_doit		;AN000; go do command
 19417                                  
 19418                                  tn_doit:				;AN000;
 19419 00002125 BE[EE87]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19420 00002128 BF[1F89]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19421                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19422 0000212B B460                    	mov	ah,60h
 19423 0000212D CD21                    	int	21h			;AN000;
 19424 0000212F 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19425                                  
 19426 00002131 E8BEFB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19427 00002134 C706[B08C][EE87]        	mov	word [string_ptr_2],SRCXNAME
 19428                                  					;AN000; get address of failed string
 19429                                  	;mov	byte [extend_buf_sub],1
 19430 0000213A C606[577F]01            	mov	byte [extend_buf_sub],one_subst
 19431                                  					;AN000; put number of subst in control block
 19432 0000213F E91808                  	jmp	cerror			;AN000; Go to error routine
 19433                                  
 19434                                  tn_print_xname: 			;AN000;
 19435 00002142 C706[B08C][1F89]        	mov	word [string_ptr_2],COMBUF
 19436                                  					;AN000; Set up address of combuf
 19437 00002148 BA[1C81]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19438 0000214B E88B04                  	call	CRLF2			;AN000; print a crlf
 19439                                  	;call	Printf_Crlf		;AN000; print it out
 19440                                  	;retn				;AN000;
 19441                                  	; 23/02/2023
 19442 0000214E E9C42C                  	jmp	Printf_Crlf
 19443                                  
 19444                                  ; ---------------------------------------------------------------------------
 19445                                  
 19446                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19447                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19448                                  _$EXIT:
 19449                                  	; MSDOS 6.0
 19450 00002151 1E                      	push	ds			;AN000; save data segment
 19451 00002152 8E1E[C08A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19452                                  	;assume	ds:resgroup		;AN000;
 19453                                  
 19454 00002156 803E[A501]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19455 0000215B 740A                    	jz	short free_com		;AN045; no - free everything
 19456                                  
 19457                                  ;	We're a permanent command.
 19458                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19459                                  
 19460 0000215D 833E[A601]FF            	cmp	word [SingleCom],-1	;M034
 19461 00002162 7412                    	je	short no_reset		;M034 ; exit singlecom
 19462 00002164 E99DDF                  	jmp	TCOMMAND		;permanent command, recycle
 19463                                  
 19464                                  free_com:
 19465                                  	;mov	ax,(multdos shl 8 or message_2f)
 19466 00002167 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19467                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19468 0000216A B205                    	mov	dl,5
 19469 0000216C 8B3E[BB01]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19470 00002170 8E06[BD01]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19471 00002174 CD2F                    	int	2Fh			;AN000; go set it
 19472                                  no_reset:				;AN045;
 19473 00002176 1F                      	pop	ds			;AN000; restore local data segment
 19474                                  	;assume	ds:trangroup		;AN000;
 19475                                  ;M040
 19476                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19477                                  ;this, restores user dir if flag is set and resets the flag.
 19478                                  
 19479                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19480 00002177 E80C03                  	call	RestUDir1
 19481 0000217A 8E06[C08A]              	mov	es,[RESSEG]
 19482                                  	;assume	es:resgroup
 19483                                  
 19484 0000217E 26A1[4101]              	mov	ax,[es:Parent]
 19485                                  	;mov	[es:16h],ax
 19486                                  	;mov	[es:PDB_Parent_PID],ax
 19487 00002182 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19488 00002186 26A1[4301]              	mov	ax,[es:OldTerm]
 19489                                  	;mov	[es:0Ah],ax
 19490                                  	;mov	[es:PDB_Exit],ax
 19491 0000218A 26A30A00                	mov	[es:PDB.EXIT],ax
 19492 0000218E 26A1[4501]              	mov	ax,[es:OldTerm+2]
 19493                                  	;mov	[es:0Ch],ax
 19494                                  	;mov	[es:PDB_Exit+2],ax
 19495 00002192 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19496                                  
 19497 00002196 06                      	push	es
 19498 00002197 8E06[D08A]              	mov	es,[TRAN_TPA]
 19499                                  	;mov	ah,DEALLOC
 19500 0000219B B449                    	mov	ah,49h
 19501 0000219D CD21                    	int	21h			; Now running in "free" space
 19502 0000219F 07                      	pop	es
 19503                                  
 19504                                  	;mov	ah,Exit
 19505 000021A0 B44C                    	mov	ah,4Ch
 19506                                  	;mov	al,byte ptr RetCode
 19507 000021A2 26A0[9D01]              	mov	al,[es:RetCode]
 19508 000021A6 CD21                    	int	21h
 19509                                  
 19510                                  	;..........
 19511                                  
 19512                                  ; 23/02/2023
 19513                                  %if 0
 19514                                  _$EXIT:
 19515                                  	; MSDOS 3.3
 19516                                  	mov	es,[RESSEG]
 19517                                  	mov	ax,[es:PARENT]
 19518                                  	;mov	[es:16h],ax
 19519                                  	mov	[es:PDB.PARENT_PID],ax
 19520                                  	mov	ax,[es:OLDTERM]
 19521                                  	;mov	[es:0Ah],ax
 19522                                  	mov	[es:PDB.EXIT],ax
 19523                                  	mov	ax,[es:OLDTERM+2]
 19524                                  	;mov	[es:0Ch],ax
 19525                                  	mov	[es:PDB.EXIT+2],ax
 19526                                  	push	es
 19527                                  	mov	es,[TRAN_TPA]
 19528                                  	mov	ah,DEALLOC ; 49h
 19529                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19530                                  			; ES = segment address of area to be freed
 19531                                  	pop	es
 19532                                  	mov	ah,EXIT ; 4Ch
 19533                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19534                                  	mov	al,byte [es:RETCODE]
 19535                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19536                                  ;;here:
 19537                                  ;;	jmp	short here
 19538                                  %endif
 19539                                  
 19540                                  ; ---------------------------------------------------------------------------
 19541                                  
 19542                                  ; MSDOS 6.0
 19543                                  ; ****************************************************************
 19544                                  ; *
 19545                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19546                                  ; *
 19547                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19548                                  ; *		 If not end of line, set up to print parse
 19549                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19550                                  ; *		 EXPECTED!
 19551                                  ; *
 19552                                  ; * INPUT:	 DS:SI	  last output from parser
 19553                                  ; *		 ES:DI	  points to parse block
 19554                                  ; *		 CX	  last output from parser
 19555                                  ; *
 19556                                  ; * OUTPUT:	 AX	  parser return code
 19557                                  ; *
 19558                                  ; *		 if end of line found
 19559                                  ; *		     zero flag set
 19560                                  ; *		 else
 19561                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19562                                  ; *
 19563                                  ; ****************************************************************
 19564                                  
 19565                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19566                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19567                                  
 19568                                  parse_check_eol:
 19569 000021A8 31D2                    	xor	dx,dx			;AN000;
 19570 000021AA 8936[288C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19571 000021AE E89F21                  	call	cmd_parse		;AN000; call parser
 19572 000021B1 3CFF                    	cmp	al,-1 ; 0FFh
 19573                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19574 000021B3 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19575                                  	;cmp	ax,0
 19576                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19577 000021B5 21C0                    	and	ax,ax ; ax = 0 ?
 19578 000021B7 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19579 000021B9 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19580                                  ok_to_setup_pmsg:
 19581 000021BA E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19582                                  parse_good_eol:
 19583                                  parse_msg_good:	; 23/02/2023
 19584 000021BD C3                      	retn				;AN000;
 19585                                  
 19586                                  ; ---------------------------------------------------------------------------
 19587                                  
 19588                                  ; MSDOS 6.0
 19589                                  ; ****************************************************************
 19590                                  ; *
 19591                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19592                                  ; *
 19593                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19594                                  ; *		 message is set up.
 19595                                  ; *
 19596                                  ; * INPUT:	 DS:SI	  last output from parser
 19597                                  ; *		 ES:DI	  points to parse block
 19598                                  ; *		 CX	  last output from parser
 19599                                  ; *
 19600                                  ; * OUTPUT:	 AX	  parser return code
 19601                                  ; *
 19602                                  ; *		 if no error
 19603                                  ; *		     outputs from parser
 19604                                  ; *		 else
 19605                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19606                                  ; *		     error message set up for STD_PRINTF
 19607                                  ; *
 19608                                  ; ****************************************************************
 19609                                  
 19610                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19611                                  Parse_With_Msg:
 19612 000021BE 8936[288C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19613 000021C2 E88B21                  	call	cmd_parse		;AN018; call parser
 19614 000021C5 3CFF                    	cmp	al,-1 ; 0FFh
 19615                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19616 000021C7 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19617                                  	;cmp	ax,0
 19618                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19619 000021C9 09C0                    	or	ax,ax ; ax = 0 ?
 19620 000021CB 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19621                                  	; 23/02/2023
 19622                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19623                                  ;parse_msg_good:
 19624                                  	;retn				;AN018;
 19625                                  	; 23/02/2023
 19626                                  	;jmp	short setup_parse_error_msg	
 19627                                  
 19628                                  ; ---------------------------------------------------------------------------
 19629                                  
 19630                                  ; MSDOS 6.0
 19631                                  ; ****************************************************************
 19632                                  ; *
 19633                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19634                                  ; *
 19635                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19636                                  ; *		 message is set up.
 19637                                  ; *
 19638                                  ; * INPUT:	 AX	     Parse error number
 19639                                  ; *		 SI	     Set to past last parameter
 19640                                  ; *		 Parse_last  Set to start of last parameter
 19641                                  ; *
 19642                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19643                                  ; *		 error message set up for STD_PRINTF
 19644                                  ; *
 19645                                  ; ****************************************************************
 19646                                  
 19647                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19648                                  setup_parse_error_msg:
 19649 000021CD C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class
 19650                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19651 000021D2 BA[557F]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19652 000021D5 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19653                                  					;AC018; terminate the parameter string
 19654 000021D8 A3[557F]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19655 000021DB 83F802                  	cmp	ax,2
 19656                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19657 000021DE 740D                    	je	short setup_parse_msg_ret
 19658                                  					;AN018;    no subst
 19659 000021E0 8B36[288C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19660 000021E4 8936[B08C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19661 000021E8 C606[577F]01            	mov	byte [extend_buf_sub],one_subst
 19662                                  					;AC018; put number of subst in control block
 19663                                  	;mov	byte [extend_buf_sub],1
 19664                                  setup_parse_msg_ret:
 19665 000021ED 46                      	inc	si			;AN018; make sure zero flag not set
 19666 000021EE C3                      	retn				;AC018;
 19667                                  
 19668                                  ;============================================================================
 19669                                  ; TENV.ASM, MSDOS 6.0, 1991
 19670                                  ;============================================================================
 19671                                  ; 08/10/2018 - Retro DOS v3.0
 19672                                  
 19673                                  ; TITLE	Part6 COMMAND Transient routines.
 19674                                  
 19675                                  ;	Environment utilities and misc. routines
 19676                                  
 19677                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19678                                  
 19679                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19680                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19681                                  
 19682                                  ; ---------------------------------------------------------------------------
 19683                                  
 19684                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19685                                  ADD_PROMPT:
 19686 000021EF E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19687 000021F2 E8AD01                  	call	scan_double_null
 19688                                  
 19689                                  ADD_PROMPT2:
 19690 000021F5 56                      	push	si
 19691 000021F6 E89B01                  	call	GETARG
 19692 000021F9 5E                      	pop	si
 19693 000021FA 7501                    	jnz	short ADD_PROMPT3
 19694                                  ADD_PROMPT_RETN:
 19695 000021FC C3                      	retn
 19696                                  ADD_PROMPT3:			; Pre scan for arguments
 19697 000021FD E87501                  	call	move_name	; Move in name
 19698 00002200 E89101                  	call	GETARG
 19699 00002203 56                      	push	si
 19700 00002204 EB53                    	jmp	short ADD_NAME
 19701                                  
 19702                                  ;break	The SET command
 19703                                  
 19704                                  ; Input: DS:SI points to a CR terminated string
 19705                                  ; Output: carry flag is set if no room
 19706                                  ;	  otherwise name is added to environment
 19707                                  
 19708                                  DISP_ENVJ:
 19709 00002206 E9BC00                  	jmp	DISP_ENV
 19710                                  
 19711                                  ADD_NAME_TO_ENVIRONMENT:
 19712 00002209 E88801                  	call	GETARG
 19713 0000220C 74F8                    	jz	short DISP_ENVJ
 19714                                  
 19715                                  ; check if line contains exactly one equals sign
 19716                                  
 19717 0000220E 31DB                    	xor	bx,bx		; = count is 0
 19718 00002210 56                      	push	si		; Save pointer to beginning of line
 19719                                  EQLP:
 19720 00002211 AC                      	lodsb			; Get a char
 19721 00002212 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19722 00002214 740F                    	je	short QUEQ	
 19723 00002216 3C3D                    	cmp	al,'='		; Look for = sign	
 19724 00002218 75F7                    	jne	short EQLP	; not there, get next char
 19725 0000221A FEC3                    	inc	bl		; Otherwise increment EQ count
 19726 0000221C 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19727 0000221F 75F0                    	jne	short EQLP
 19728 00002221 FEC7                    	inc	bh		; Set BH=1 means no parameters
 19729 00002223 EBEC                    	jmp	short EQLP	; And look for more
 19730                                  QUEQ:
 19731 00002225 5E                      	pop	si		; Restore beginning of line
 19732 00002226 FECB                    	dec	bl		; Zero flag means only one EQ
 19733 00002228 7406                    	jz	short ONEQ	; Good line
 19734 0000222A BA[ED7F]                	mov	dx,SYNTMES_PTR
 19735 0000222D E92A07                  	jmp	cerror
 19736                                  ONEQ:
 19737 00002230 53                      	push	bx
 19738 00002231 E8BD00                  	call	delete_name_in_environment
 19739 00002234 5B                      	pop	bx
 19740 00002235 FECF                    	dec	bh
 19741 00002237 74C3                    	jz	short ADD_PROMPT_RETN
 19742 00002239 E86601                  	call	scan_double_null
 19743 0000223C 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19744 0000223E E83401                  	call	move_name
 19745 00002241 56                      	push	si
 19746 00002242 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19747                                  				;  env var name
 19748                                  		
 19749                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19750                                  ; necessary in the resident for re-reading the transient. Let's look for
 19751                                  ; COMSPEC=
 19752                                  
 19753 00002244 C606[9C84]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19754 00002249 BE[D181]                	mov	si,COMSPECSTR ; "COMSPEC="
 19755 0000224C B90400                  	mov	cx,4
 19756 0000224F F3A7                    	repe	cmpsw
 19757 00002251 7504                    	jnz	short NOT_COMSPEC
 19758                                  				; Zero set => exact match
 19759 00002253 FE06[9C84]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19760                                  	;mov	byte [COMSPEC_FLAG],1
 19761                                  NOT_COMSPEC:
 19762 00002257 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19763                                  ADD_NAME:
 19764 00002259 5E                      	pop	si		; Add the value of the new env var
 19765 0000225A 56                      	push	si		;  to the environment.
 19766                                  ADD_NAME1:
 19767 0000225B AC                      	lodsb
 19768 0000225C 3C0D                    	cmp	al,13 ; 0Dh
 19769 0000225E 7405                    	je	short ADD_NAME_RET
 19770 00002260 E8AD01                  	call	store_char
 19771 00002263 EBF6                    	jmp	short ADD_NAME1
 19772                                  ADD_NAME_RET:
 19773 00002265 5E                      	pop	si
 19774 00002266 803E[9C84]00            	cmp	byte [comspec_flag],0
 19775                                  				; If the new env var is comspec,	
 19776                                  ADD_NAME_JZ_RET:
 19777 0000226B 748F                    	jz	short ADD_PROMPT_RETN 
 19778                                  				;  copy the value into the
 19779                                  				;  comspec var in the resident
 19780                                  
 19781                                  ; We have changed the COMSPEC variable. We need to update the resident
 19782                                  ; pieces necessary to reread in the info. First, skip all delimiters
 19783                                  
 19784 0000226D E87603                  	call	scanoff
 19785 00002270 8E06[C08A]              	mov	es,[RESSEG]	;  comspec var in the resident
 19786                                  
 19787                                  ; Make sure that the printer knows where the beginning of the string is
 19788                                  
 19789 00002274 BF[4E01]                	mov	di,ComSpec
 19790 00002277 89FB                    	mov	bx,di
 19791                                  
 19792                                  ; Generate drive letter for display
 19793                                  
 19794 00002279 31C0                    	xor	ax,ax		;g assume no drive first
 19795 0000227B 26A2[9701]              	mov	[es:ComDrv],al
 19796                                  	; 23/02/2023
 19797                                  	; MSDOS 6.0 (& 5.0)
 19798 0000227F 50                      	push	ax		;AN000; 3/3/KK
 19799 00002280 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 19800 00002282 E83F01                  	call	testkanj	;AN000; 3/3/KK	
 19801 00002285 58                      	pop	ax		;AN000; 3/3/KK
 19802 00002286 7518                    	jnz	short _GOTDRIVE
 19803                                  	;
 19804 00002288 807C013A                	cmp	byte [si+1],':'	; drive specified?
 19805 0000228C 7512                    	jne	short _GOTDRIVE
 19806 0000228E 8A04                    	mov	al,[si]		; get his specified drive
 19807                                  	; 23/02/2023
 19808 00002290 E85B01                  	call	UPCONV
 19809                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 19810 00002293 2C41                    	sub	al,'A'		; convert to 0-based
 19811 00002295 83C702                  	add	di,2
 19812 00002298 FEC0                    	inc	al		; convert to 1-based number
 19813 0000229A 26A2[9701]              	mov	[es:ComDrv],al
 19814                                  
 19815                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 19816                                  ; done here..
 19817                                  	;add	al,40h
 19818 0000229E 0440                    	add	al,'A'-1
 19819                                  _GOTDRIVE:
 19820                                  	; 23/02/2023
 19821                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 19822                                  	;mov	[es:PUTBACKSUBSTPTR],di
 19823                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 19824 000022A0 26893E[2D01]            	mov	[es:PutBackComSpec],di
 19825                                  				;g point to beginning of name after drive
 19826                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 19827                                  	;mov	[es:PUTBACKDRV],al
 19828                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 19829 000022A5 26A2[3201]              	mov	[es:PutBackDrv],al
 19830                                  
 19831                                  ; Copy chars until delim      	
 19832                                  
 19833 000022A9 89DF                    	mov	di,bx
 19834                                  COPY_COMSPEC:
 19835 000022AB AC                      	lodsb
 19836 000022AC E83F03                  	call	DELIM
 19837 000022AF 7407                    	jz	short COPYDONE
 19838 000022B1 3C0D                    	cmp	al,13 ; 0Dh
 19839 000022B3 7403                    	je	short COPYDONE
 19840 000022B5 AA                      	stosb
 19841 000022B6 EBF3                    	jmp	short COPY_COMSPEC
 19842                                  COPYDONE:
 19843 000022B8 30C0                    	xor	al,al		; Null terminate the string and quit
 19844 000022BA AA                      	stosb
 19845                                  	;mov	byte [comspec_flag],0
 19846 000022BB A2[9C84]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 19847 000022BE 4F                      	dec	di
 19848 000022BF 26893E[8E01]            	mov	[es:ComSpec_End],di
 19849 000022C4 C3                      	retn
 19850                                  
 19851                                  DISP_ENV:
 19852 000022C5 8E1E[C08A]              	mov	ds,[RESSEG]
 19853 000022C9 8E1E[3F03]              	mov	ds,[EnvirSeg]
 19854                                  	; assume ds:nothing
 19855 000022CD 31F6                    	xor	si,si
 19856                                  PENVLP:
 19857 000022CF 803C00                  	cmp	byte [si],0
 19858 000022D2 7497                    	jz	short ADD_NAME_JZ_RET
 19859 000022D4 BF[2C8C]                	mov	di,Arg_Buf
 19860                                  PENVLP2:
 19861 000022D7 AC                      	lodsb
 19862 000022D8 AA                      	stosb
 19863 000022D9 08C0                    	or	al,al
 19864 000022DB 75FA                    	jnz	short PENVLP2
 19865 000022DD BA[F280]                	mov	dx,arg_buf_ptr
 19866 000022E0 1E                      	push	ds
 19867 000022E1 06                      	push	es
 19868 000022E2 1F                      	pop	ds
 19869                                  	; assume ds:nothing
 19870 000022E3 E82F2B                  	call	Printf_Crlf
 19871 000022E6 1F                      	pop	ds
 19872 000022E7 EBE6                    	jmp	short PENVLP
 19873                                  
 19874                                  ; =============== S U B	R O U T	I N E =======================================
 19875                                  
 19876                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19877                                  delete_path:
 19878 000022E9 BE[C581]                	mov	si,PATH_TEXT ; "PATH="
 19879 000022EC EB03                    	jmp	short delete_name_in_environment
 19880                                  
 19881                                  ; =============== S U B	R O U T	I N E =======================================
 19882                                  
 19883                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19884                                  delete_prompt:
 19885 000022EE BE[CA81]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19886                                  
 19887                                  ; ---------------------------------------------------------------------------
 19888                                  
 19889                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19890                                  delete_name_in_environment:
 19891                                  
 19892                                  ; Input: DS:SI points to a "=" terminated string
 19893                                  ; Output: carry flag is set if name not found
 19894                                  ;	  otherwise name is deleted
 19895                                  
 19896 000022F1 56                      	push	si
 19897 000022F2 1E                      	push	ds
 19898 000022F3 E82C00                  	call	FIND		; ES:DI points to name
 19899 000022F6 7217                    	jc	short del1
 19900 000022F8 89FE                    	mov	si,di		; Save it
 19901 000022FA E8BF00                  	call	SCASB2		; Scan for the nul
 19902 000022FD 87F7                    	xchg	si,di
 19903                                  ;SR;
 19904                                  ; If we have only one env string, then the double null is lost when the last
 19905                                  ;string is deleted and we have an invalid empty environment with only a 
 19906                                  ;single null. To avoid this, we will look for the double null case and then
 19907                                  ;move an extra null char.
 19908                                  ; Bugbug: The only possible problem is that the last pathstring 
 19909                                  ;will be followed by a triple null. Is this really a problem?
 19910                                  
 19911                                  	; MSDOS 6.0
 19912 000022FF 26803C00                	cmp	byte [es:si],0	;null char?
 19913 00002303 7501                    	jnz	short not_dnull	;no, we are at a double null
 19914 00002305 4E                      	dec	si		;point at the double null
 19915                                  not_dnull:
 19916                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19917 00002306 E86901                  	call	GETENVSIZ
 19918 00002309 29F1                    	sub	cx,si
 19919 0000230B 06                      	push	es
 19920 0000230C 1F                      	pop	ds		; ES:DI points to name
 19921                                  				; DS:SI points to next name
 19922 0000230D F3A4                    	rep	movsb
 19923                                  del1:
 19924 0000230F 1F                      	pop	ds
 19925 00002310 5E                      	pop	si
 19926                                  find_retn:
 19927 00002311 C3                      	retn
 19928                                  
 19929                                  ; =============== S U B	R O U T	I N E =======================================
 19930                                  
 19931                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19932                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 19933                                  find_path:
 19934 00002312 BE[C581]                	mov	si,PATH_TEXT ; "PATH="
 19935 00002315 EB03                    	jmp	short find_name_in_environment
 19936                                  
 19937                                  ; =============== S U B	R O U T	I N E =======================================
 19938                                  
 19939                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19940                                  find_prompt:
 19941 00002317 BE[CA81]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19942                                  
 19943                                  ; ---------------------------------------------------------------------------
 19944                                  
 19945                                  find_name_in_environment:
 19946                                  
 19947                                  ; Input: DS:SI points to a "=" terminated string
 19948                                  ; Output: ES:DI points to the arguments in the environment
 19949                                  ;	  zero is set if name not found
 19950                                  ;	  carry flag is set if name not valid format
 19951                                  
 19952 0000231A E80500                  	call	FIND		; Find the name
 19953 0000231D 72F2                    	jc	short find_retn	; Carry means not found	
 19954 0000231F E99600                  	jmp	SCASB1		; Scan for = sign
 19955                                  
 19956                                  ; ---------------------------------------------------------------------------
 19957                                  	;nop
 19958                                  
 19959                                  ; =============== S U B	R O U T	I N E =======================================
 19960                                  
 19961                                  ; On return of FIND1, ES:DI points to beginning of name
 19962                                  
 19963                                  FIND:
 19964 00002322 FC                      	cld
 19965 00002323 E84100                  	call	COUNT0		; CX = Length of name
 19966 00002326 8E06[C08A]              	mov	es,[RESSEG]
 19967                                  	;assume es:RESGROUP
 19968 0000232A 268E06[3F03]            	mov	es,[es:EnvirSeg]
 19969                                  	;assume es:NOTHING
 19970 0000232F 31FF                    	xor	di,di
 19971                                  find1:	
 19972 00002331 51                      	push	cx
 19973 00002332 56                      	push	si
 19974 00002333 57                      	push	di
 19975                                  find11:
 19976 00002334 AC                      	lodsb
 19977                                  	; 23/02/2023 
 19978                                  	; MSDOS 6.0 (& 5.0)
 19979 00002335 E88C00                  	call	testkanj	
 19980 00002338 740F                    	jz	short notkanj3
 19981 0000233A 4E                      	dec	si
 19982 0000233B AD                      	lodsw
 19983 0000233C 47                      	inc	di
 19984 0000233D 47                      	inc	di
 19985 0000233E 263B45FE                	cmp	ax,[es:di-2]
 19986 00002342 7511                    	jne	short find12
 19987 00002344 49                      	dec	cx
 19988 00002345 E2ED                    	loop	find11
 19989 00002347 EB0C                    	jmp	short find12
 19990                                  notkanj3:
 19991 00002349 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 19992                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 19993 0000234C 47                      	inc	di
 19994 0000234D 263A45FF                	cmp	al,[es:di-1]
 19995 00002351 7502                    	jne	short find12
 19996 00002353 E2DF                    	loop	find11
 19997                                  find12:
 19998 00002355 5F                      	pop	di
 19999 00002356 5E                      	pop	si
 20000 00002357 59                      	pop	cx
 20001 00002358 74B7                    	jz	short find_retn
 20002 0000235A 51                      	push	cx
 20003 0000235B E85E00                  	call	SCASB2		; Scan for a nul
 20004 0000235E 59                      	pop	cx
 20005 0000235F 26803D00                	cmp	byte [es:di],0
 20006 00002363 75CC                    	jnz	short find1
 20007 00002365 F9                      	stc			; Indicate not found
 20008 00002366 C3                      	retn
 20009                                  
 20010                                  ; =============== S U B	R O U T	I N E =======================================
 20011                                  
 20012                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20013                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 20014                                  COUNT0:
 20015 00002367 1E                      	push	ds
 20016 00002368 07                      	pop	es
 20017                                  	;assume es:nothing
 20018 00002369 89F7                    	mov	di,si
 20019                                  ;COUNT1:
 20020 0000236B 57                      	push	di		; Count number of chars until "="
 20021 0000236C E84900                  	call	SCASB1
 20022                                  	; 23/02/2023
 20023                                  ;	jmp	short COUNTX
 20024                                  ;COUNT2:
 20025                                  ;	push	di		; Count number of chars until nul
 20026                                  ;	call	SCASB2
 20027                                  ;COUNTX:
 20028 0000236F 59                      	pop	cx
 20029 00002370 29CF                    	sub	di,cx
 20030 00002372 87F9                    	xchg	di,cx
 20031                                  move_name_retn:
 20032 00002374 C3                      	retn
 20033                                  
 20034                                  ; =============== S U B	R O U T	I N E =======================================
 20035                                  
 20036                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20037                                  move_name:
 20038 00002375 803C0D                  	cmp	byte [si],13 ; 0Dh
 20039 00002378 74FA                    	je	short move_name_retn
 20040 0000237A AC                      	lodsb
 20041                                  	; 23/02/2023 
 20042                                  	; MSDOS 6.0 (& 5.0)
 20043 0000237B E84600                  	call	testkanj		
 20044 0000237E 7409                    	jz	short notkanj1
 20045 00002380 E88D00                  	call	store_char
 20046 00002383 AC                      	lodsb
 20047 00002384 E88900                  	call	store_char
 20048 00002387 EBEC                    	jmp	short move_name
 20049                                  notkanj1: 
 20050 00002389 E86200                  	call	UPCONV
 20051                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 20052 0000238C E88100                  	call	store_char
 20053 0000238F 3C3D                    	cmp	al,'='
 20054 00002391 75E2                    	jne	short move_name
 20055                                  getarg_retn:
 20056 00002393 C3                      	retn
 20057                                  
 20058                                  ; =============== S U B	R O U T	I N E =======================================
 20059                                  
 20060                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20061                                  GETARG:
 20062 00002394 BE8000                  	mov	si,80h
 20063 00002397 AC                      	lodsb
 20064 00002398 08C0                    	or	al,al
 20065 0000239A 74F7                    	jz	short getarg_retn
 20066 0000239C E84702                  	call	scanoff
 20067 0000239F 3C0D                    	cmp	al,13 ; 0Dh
 20068                                  sdn_retn:
 20069 000023A1 C3                      	retn
 20070                                  
 20071                                  ; =============== S U B	R O U T	I N E =======================================
 20072                                  
 20073                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 20074                                  ; there is NO double NULL, merely a string that is empty.
 20075                                  
 20076                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20077                                  scan_double_null:
 20078 000023A2 8E06[C08A]              	mov	es,[RESSEG]
 20079 000023A6 268E06[3F03]            	mov	es,[es:EnvirSeg]
 20080 000023AB 31FF                    	xor	di,di
 20081                                  
 20082                                  ; Top cycle-point. If the string here is empty, then we are done
 20083                                  
 20084                                  sdn1:
 20085 000023AD 26803D00                	cmp	byte [es:di],0	; nul string?
 20086 000023B1 74EE                    	jz	short sdn_retn	; yep, all done
 20087 000023B3 E80600                  	call	SCASB2
 20088 000023B6 EBF5                    	jmp	short sdn1
 20089                                  
 20090                                  ; =============== S U B	R O U T	I N E =======================================
 20091                                  
 20092                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20093                                  SCASB1:
 20094 000023B8 B03D                    	mov	al,'='		; Scan for an =
 20095 000023BA EB02                    	jmp	short SCASBX
 20096                                  
 20097                                  ; =============== S U B	R O U T	I N E =======================================
 20098                                  
 20099                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20100                                  SCASB2:
 20101 000023BC 30C0                    	xor	al,al		; Scan for a nul
 20102                                  
 20103                                  ; ---------------------------------------------------------------------------
 20104                                  
 20105                                  	; 23/02/2023
 20106                                  SCASBX:
 20107 000023BE B90001                  	mov	cx,256
 20108 000023C1 F2AE                    	repne	scasb
 20109 000023C3 C3                      	retn
 20110                                  
 20111                                  ; =============== S U B	R O U T	I N E =======================================
 20112                                  
 20113                                  ; MSDOS 6.0
 20114                                  
 20115                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 20116                                  
 20117                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20118                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 20119                                  testkanj:
 20120 000023C4 1E                      	push	ds			;AN000;  3/3/KK
 20121 000023C5 56                      	push	si			;AN000;  3/3/KK
 20122 000023C6 50                      	push	ax			;AN000;  3/3/KK
 20123 000023C7 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20124 000023CC C536[BF01]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20125                                  ktlop:					;AN000;  3/3/KK
 20126 000023D0 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20127 000023D3 740E                    	je	short notlead 		;AN000;  3/3/KK
 20128 000023D5 58                      	pop	ax			;AN000;  3/3/KK
 20129 000023D6 50                      	push	ax			;AN000;  3/3/KK
 20130 000023D7 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20131 000023D9 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20132 000023DB 46                      	inc	si			;AN000;  3/3/KK
 20133 000023DC 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20134 000023DE 7607                    	jbe	short islead		;AN000;  3/3/KK
 20135 000023E0 46                      	inc	si			;AN000;  3/3/KK
 20136 000023E1 EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20137                                  notlead:				;AN000;  3/3/KK
 20138 000023E3 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20139 000023E5 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20140                                  islead: 				;AN000;  3/3/KK
 20141 000023E7 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20142 000023E9 40                      	inc	ax			;AN000;  3/3/KK
 20143                                  ktret:					;AN000;  3/3/KK
 20144 000023EA 58                      	pop	ax			;AN000;  3/3/KK
 20145 000023EB 5E                      	pop	si			;AN000;  3/3/KK
 20146 000023EC 1F                      	pop	ds			;AN000;  3/3/KK
 20147 000023ED C3                      	retn				;AN000;  3/3/KK
 20148                                  
 20149                                  ; =============== S U B	R O U T	I N E =======================================
 20150                                  
 20151                                  ; MSDOS 6.0
 20152                                  
 20153                                  ; ****************************************************************
 20154                                  ; *
 20155                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20156                                  ; *
 20157                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20158                                  ; *		 the character in AL from the file upper case table
 20159                                  ; *		 in DOS if character if above  ascii 128, else
 20160                                  ; *		 subtracts 20H if between "a" and "z".
 20161                                  ; *
 20162                                  ; * INPUT:	 AL	      char to be upper cased
 20163                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20164                                  ; *
 20165                                  ; * OUTPUT:	 AL	      upper cased character
 20166                                  ; *
 20167                                  ; ****************************************************************
 20168                                  
 20169                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20170                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20171                                  UPCONV:
 20172 000023EE 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20173 000023F0 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20174 000023F2 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20175 000023F4 1E                      	push	ds			;AN000;
 20176 000023F5 53                      	push	bx			;AN000;
 20177 000023F6 8E1E[C08A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20178                                  	;lds	bx,dword ptr FUCase_Addr+1
 20179 000023FA C51E[B701]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20180 000023FE 83C302                  	add	bx,2			;AN000;  skip over first word
 20181                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20182 00002401 D7                      	xlat
 20183 00002402 5B                      	pop	bx			;AN000;
 20184 00002403 1F                      	pop	ds			;AN000;
 20185                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20186                                  	; 24/02/2023
 20187 00002404 C3                      	retn
 20188                                  oth_fucase:				;AN000;
 20189 00002405 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20190 00002407 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20191 00002409 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20192 0000240B 7702                    	ja	short upconv_end	;AC000;
 20193 0000240D 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20194                                  upconv_end:				;AN000;
 20195 0000240F C3                      	retn
 20196                                  
 20197                                  ; ---------------------------------------------------------------------------
 20198                                  
 20199                                  ; MSDOS 3.3
 20200                                  
 20201                                  	; 24/02/2023
 20202                                  ;UPCONV_MAPCALL:
 20203                                  	;			; If between "a" and "z"
 20204                                  	;cmp	al,[small_a]
 20205                                  	;jb	short UPCONV_END
 20206                                  	;cmp	al,[small_z]
 20207                                  	;ja	short UPCONV_END
 20208                                  	;sub	al,20h		; Change lower-case to upper
 20209                                  ;UPCONV_END:
 20210                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20211                                  	;			  ; 	  for (current) country
 20212                                  	;retn
 20213                                  
 20214                                  ; =============== S U B	R O U T	I N E =======================================
 20215                                  
 20216                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20217                                  
 20218                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20219                                  	; 10/06/2023
 20220                                  store_char:
 20221 00002410 51                      	push	cx
 20222 00002411 53                      	push	bx
 20223                                  
 20224                                  	; 24/02/2023
 20225                                  	;;16/10/2018
 20226                                  	; MSDOS 6.0
 20227 00002412 06                      	push	es		;AN056;*
 20228 00002413 1E                      	push	ds		;AN056; Save local DS
 20229 00002414 8E1E[C08A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20230 00002418 8E06[3F03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20231 0000241C 1F                      	pop	ds		;AN056; Get local segment back
 20232                                  
 20233                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20234 0000241D E85200                  	call	GETENVSIZ
 20235 00002420 89CB                    	mov	bx,cx		; Save room for double nul	
 20236 00002422 83EB02                  	sub	bx,2
 20237 00002425 39DF                    	cmp	di,bx
 20238 00002427 723F                    	jb	short store1
 20239 00002429 50                      	push	ax
 20240 0000242A 51                      	push	cx
 20241 0000242B 53                      	push	bx		; Save Size of environment
 20242 0000242C E8D5E2                  	call	FREE_TPA
 20243 0000242F 5B                      	pop	bx
 20244 00002430 83C302                  	add	bx,2		; Recover true environment size
 20245                                  
 20246 00002433 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20247 00002437 7203                    	jb	short envsiz_ok
 20248                                  bad_env_size:			;AN056;
 20249 00002439 F9                      	stc
 20250 0000243A EB16                    	jmp	short envnoset
 20251                                  	;nop
 20252                                  envsiz_ok:
 20253 0000243C B104                    	mov	cl,4
 20254 0000243E D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20255 00002440 43                      	inc	bx
 20256                                  	; 24/02/2023
 20257                                  	; MSDOS 6.0
 20258 00002441 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20259 00002443 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20260 00002445 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20261 00002448 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20262 0000244A 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20263 0000244C 73EB                    	jnb	short bad_env_size
 20264                                  				;AN056; Yes - don't do it!!!
 20265                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20266 0000244E B44A                    	mov	ah,4Ah
 20267                                  	;mov	ah,SETBLOCK ; 4Ah
 20268 00002450 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20269                                  			; ES = segment address of block	to change
 20270                                  			; BX = new size	in paragraphs
 20271                                  envnoset:
 20272 00002452 9C                      	pushf
 20273 00002453 06                      	push	es
 20274 00002454 8E06[C08A]              	mov	es,[RESSEG]
 20275 00002458 E8B9E2                  	call	ALLOC_TPA
 20276 0000245B 07                      	pop	es
 20277 0000245C 9D                      	popf
 20278 0000245D 59                      	pop	cx
 20279 0000245E 58                      	pop	ax
 20280                                  	; 24/02/2023
 20281                                  	;pop	es ; MSDOS 6.0	;AN056;*	
 20282 0000245F 7307                    	jnc	short store1
 20283                                  	; 10/06/2023 (BugFix)
 20284 00002461 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20285 00002462 BA[6C7F]                	mov	dx,ENVERR_PTR
 20286 00002465 E9F204                  	jmp	cerror
 20287                                  store1:	
 20288 00002468 AA                      	stosb
 20289 00002469 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20290                                  	; 24/02/2023
 20291 0000246E 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20292 0000246F 5B                      	pop	bx
 20293 00002470 59                      	pop	cx
 20294 00002471 C3                      	retn
 20295                                  
 20296                                  ; =============== S U B	R O U T	I N E =======================================
 20297                                  
 20298                                  	; 24/02/2023
 20299                                  GETENVSIZ:
 20300                                  
 20301                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20302                                  ;ES has environment segment
 20303                                  ;Size returned in CX, all other registers preserved
 20304                                  
 20305 00002472 06                      	push	es
 20306 00002473 50                      	push	ax
 20307 00002474 8CC0                    	mov	ax,es
 20308 00002476 48                      	dec	ax		;Point at arena	
 20309 00002477 8EC0                    	mov	es,ax
 20310                                  	;mov	ax,[es:3]
 20311 00002479 26A10300                	mov	ax,[es:ARENA.size]
 20312 0000247D B104                    	mov	cl,4
 20313 0000247F D3E0                    	shl	ax,cl		;Convert to bytes
 20314 00002481 89C1                    	mov	cx,ax
 20315 00002483 58                      	pop	ax
 20316 00002484 07                      	pop	es
 20317                                  getenvsiz_retn:
 20318 00002485 C3                      	retn
 20319                                  
 20320                                  ; =============== S U B	R O U T	I N E =======================================
 20321                                  
 20322                                  	; 24/02/2023
 20323                                  RestUDir1:
 20324 00002486 1E                      	push	ds
 20325 00002487 8E1E[C08A]              	mov	ds,[RESSEG]
 20326 0000248B 803E[A401]00            	cmp	byte [RestDir],0
 20327 00002490 1F                      	pop	ds
 20328 00002491 74F2                    	jz	short getenvsiz_retn
 20329                                  
 20330                                  ; =============== S U B	R O U T	I N E =======================================
 20331                                  
 20332                                  	; 24/02/2023
 20333                                  RestUDir:
 20334 00002493 BA[A289]                	mov	dx,USERDIR1
 20335 00002496 B43B                    	mov	ah,3Bh
 20336                                  	;mov	ah,CHDir ; 3Bh
 20337 00002498 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20338                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20339 0000249A 30C0                    	xor	al,al
 20340                                  	;call	SETREST
 20341                                  	;retn
 20342                                  	; 24/02/2023
 20343 0000249C E95508                  	jmp	SETREST	
 20344                                  
 20345                                  ;============================================================================
 20346                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20347                                  ;============================================================================
 20348                                  ; 07/10/2018 - Retro DOS v3.0
 20349                                  
 20350                                  ; TITLE	Part6 COMMAND Transient routines.
 20351                                  
 20352                                  ;	Environment utilities and misc. routines
 20353                                  
 20354                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20355                                  
 20356                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20357                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20358                                  
 20359                                  ; ---------------------------------------------------------------------------
 20360                                  
 20361                                  ; ****************************************************************
 20362                                  ; *
 20363                                  ; * ROUTINE:	 $CHDIR
 20364                                  ; *
 20365                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20366                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20367                                  ; *		 letter is found, get and display the current dir
 20368                                  ; *		 of the specified drive. If nothing is found, get
 20369                                  ; *		 and display the current dir of the default drive.
 20370                                  ; *
 20371                                  ; * INPUT:	 command line at offset 81H
 20372                                  ; *
 20373                                  ; * OUTPUT:	 none
 20374                                  ; *
 20375                                  ; ****************************************************************
 20376                                  
 20377                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20378                                  _$CHDIR:
 20379                                  	; MSDOS 6.0
 20380 0000249F BE8100                  	mov	si,81h
 20381 000024A2 BF[4A85]                	mov	di,PARSE_CHDIR
 20382                                  				;AN000; Get address of PARSE_CHDIR
 20383 000024A5 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20384 000024A7 31D2                    	xor	dx,dx		;AN000;
 20385 000024A9 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20386                                  	
 20387 000024AC 83F8FF                  	cmp	ax,-1
 20388                                  	;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20389 000024AF 7415                    	je	short bwdj	; No args
 20390                                  	;cmp	ax,0
 20391                                  	;cmp	ax,RESULT_NO_ERROR
 20392                                  				;AC000; did we have an error?
 20393 000024B1 09C0                    	or	ax,ax ; ax = 0 ?
 20394 000024B3 756D                    	jnz	short ChDirErr	;AC018; yes - exit
 20395                                  	
 20396                                  	;cmp	byte [PARSE1_TYPE],6
 20397 000024B5 803E[EF95]06            	cmp	byte [PARSE1_TYPE],result_drive
 20398                                  				;AC000; was a drive entered?
 20399 000024BA 7511                    	jne	short REALCD	; no
 20400                                  
 20401                                  ; D: was found. See if there is anything more.
 20402                                  
 20403 000024BC BF[4A85]                	mov	di,PARSE_CHDIR
 20404                                  				;AC000; get address of parse_chdir
 20405 000024BF 31D2                    	xor	dx,dx		;AC000;
 20406 000024C1 E8E4FC                  	call	parse_check_eol ;AC000; call parser
 20407 000024C4 755C                    	jnz	short ChDirErr	;AC000;
 20408                                  bwdj:
 20409 000024C6 E872F9                  	call	build_dir_for_chdir
 20410                                  				; Drive only specified
 20411 000024C9 E80D01                  	call	CRLF2
 20412                                  chdir_retn:
 20413 000024CC C3                      	retn
 20414                                  
 20415                                  	; 24/02/2023
 20416                                  	; MSDOS 3.3
 20417                                  	;mov	ax,[COMSW]
 20418                                  	;or	ax,[ALLSWITCH]
 20419                                  	;mov	dx,BADPARMPTR
 20420                                  	;jnz	short CHDIR_ERR
 20421                                  	;mov	si,81h
 20422                                  	;call	SCANOFF
 20423                                  	;cmp	al,0Dh		; are we at end of line?
 20424                                  	;je	short BWDJ	; No args
 20425                                  	;inc	si
 20426                                  	;lodsb
 20427                                  	;cmp	al,':'
 20428                                  	;jne	short REALCD
 20429                                  	;push	si
 20430                                  	;call	SCANOFF
 20431                                  	;pop	si
 20432                                  	;cmp	al,0Dh		; was a drive entered?
 20433                                  	;jne	short REALCD	; no
 20434                                  ;BWDJ:
 20435                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20436                                  	;call	CRLF2
 20437                                  ;CHDIR_RETN:
 20438                                  	;retn
 20439                                  
 20440                                  	; 24/02/2023
 20441                                  	; MSDOS 6.0
 20442                                  REALCD:
 20443 000024CD 56                      	push	si		;AN000; save position in line
 20444 000024CE C536[F395]              	lds	si,[PARSE1_ADDR]
 20445                                  				;AN000; get address of filespec
 20446 000024D2 E8E107                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20447 000024D5 5E                      	pop	si		;AN000; restore position in line
 20448 000024D6 BF[4A85]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20449 000024D9 31D2                    	xor	dx,dx		;AC000;
 20450 000024DB E8CAFC                  	call	parse_check_eol ;AC000; call parser
 20451 000024DE 7542                    	jnz	short ChDirErr	;AC000;
 20452                                  	
 20453 000024E0 E81106                  	call	SETPATH
 20454 000024E3 F606[CB8C]02            	test	byte [DestInfo],2
 20455 000024E8 7518                    	jnz	short BadChDir
 20456                                  
 20457                                  	; 26/04/2023
 20458 000024EA B43B                    	mov	ah,3Bh
 20459                                  	;mov	ah,CHDir
 20460 000024EC CD21                    	int	21h
 20461 000024EE 73DC                    	jnc	short chdir_retn
 20462                                  	
 20463 000024F0 E80FF8                  	call	get_ext_error_number
 20464                                  				;AN022; get the extended error
 20465 000024F3 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20466                                  				;AN022; see if path not found
 20467 000024F6 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20468                                  ;SR;
 20469                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20470                                  ;but is not a directory. The extended error returns "Access denied" which
 20471                                  ;is kind of confusing. Issue the old message if access denied error is 
 20472                                  ;returned
 20473                                  
 20474 000024F8 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20475 000024FB 7405                    	je	short BadChDir
 20476                                  	
 20477 000024FD E89E00                  	call	set_ext_error_subst ;AN022;
 20478 00002500 EB20                    	jmp	short ChDirErr	;AN022;
 20479                                  
 20480                                  BadChDir:
 20481 00002502 BA[9080]                	mov	dx,badcd_ptr
 20482                                  ;ChDirErr:
 20483                                  ;	call	std_eprintf
 20484                                  ;mkdir_retn:
 20485                                  	;retn
 20486                                  	; 24/02/2023
 20487 00002505 EB1B                    	jmp	short ChDirErr	;AN022;
 20488                                  
 20489                                  	; 24/02/2023
 20490                                  	; MSDOS 3.3
 20491                                  ;REALCD:
 20492                                  	;call	SETPATH
 20493                                  	;test	byte [DESTINFO],2
 20494                                  	;jnz	short BADCHDIR
 20495                                  	;mov	ah,CHDir ; 3Bh
 20496                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20497                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20498                                  	;jnc	short CHDIR_RETN
 20499                                  ;BADCHDIR:
 20500                                  	;mov	dx,BADCDPTR
 20501                                  ;CHDIR_ERR:
 20502                                  	;call	STD_EPRINTF
 20503                                  ;MKDIR_RETN:
 20504                                  	;retn
 20505                                  
 20506                                  ; =============== S U B	R O U T	I N E =======================================
 20507                                  
 20508                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20509                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20510                                  _$MKDIR:
 20511                                  	; MSDOS 6.0
 20512 00002507 E86300                  	call	SETRMMK
 20513 0000250A 7216                    	jc	short MkDirErr
 20514                                  
 20515 0000250C B439                    	mov	ah,39h
 20516                                  	;mov	ah,MKDIR
 20517 0000250E CD21                    	int	21h
 20518 00002510 7313                    	jnc	short mkdir_retn
 20519                                  
 20520 00002512 E8EDF7                  	call	get_ext_error_number	
 20521                                  				;AN022; get the extended error
 20522 00002515 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20523                                  				;AN022; see if path not found
 20524 00002518 742A                    	je	short MD_other_err
 20525                                  				;AN022; yes - issue old message
 20526 0000251A 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20527                                  				;AN022; access denied?
 20528 0000251D 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20529                                  	
 20530 0000251F E87C00                  	call	set_ext_error_subst
 20531                                  				;AN022;
 20532                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20533                                  	; 24/02/2023
 20534                                  ChDirErr:
 20535                                  MkDirErr:
 20536                                  RmDirErr:
 20537 00002522 E8F628                  	call	std_eprintf
 20538                                  mkdir_retn:
 20539                                  rmdir_retn:
 20540 00002525 C3                      	retn
 20541                                  	
 20542                                  badmderr:
 20543 00002526 BA[EE87]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20544 00002529 B41A                    	mov	ah,1Ah
 20545                                  	;mov	ah,Set_DMA	;AN006;
 20546 0000252B CD21                    	int	21h		;AN006;
 20547                                  	
 20548 0000252D B44E                    	mov	ah,4Eh
 20549                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20550                                  	;mov	cx,10h
 20551 0000252F B91000                  	mov	cx,ATTR_DIRECTORY
 20552                                  				;AN006;   search for directory
 20553 00002532 CD21                    	int	21h		;AN006;
 20554 00002534 720E                    	jc	short MD_other_err
 20555                                  				;AN006; doesn't exist - must be something else
 20556                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20557                                  				;AN006; we found a file/dir
 20558                                  	;mov	dl,[SRCXNAME+21] 
 20559 00002536 8A16[0388]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20560 0000253A F6C210                  	test	dl,ATTR_DIRECTORY
 20561                                  				;AN006; was it a directory?
 20562 0000253D 7405                    	jz	short MD_other_err
 20563                                  				;AN006; no - must have been a file
 20564 0000253F BA[8081]                	mov	dx,MD_EXISTS_PTR
 20565                                  				;AN006; set up already exists error
 20566 00002542 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20567                                  MD_other_err:			;AN006;
 20568 00002544 BA[9380]                	mov	dx,badmkd_ptr
 20569                                  ;MkDirErr:
 20570                                  	;call	std_eprintf
 20571                                  	;retn
 20572                                  	; 24/02/2023
 20573 00002547 EBD9                    	jmp	short MkDirErr
 20574                                  
 20575                                  	; 24/02/2023
 20576                                  	; MSDOS 3.3
 20577                                  	;call	SETRMMK
 20578                                  	;jb	short MKDIRERR
 20579                                  	;mov	ah,MKDIR ; 39h
 20580                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20581                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20582                                  	;jnc	short MKDIR_RETN
 20583                                  	;mov	dx,BADMKDPTR
 20584                                  	;call	GET_EXT_ERR_NUMBER
 20585                                  ;MKDIRERR:
 20586                                  	;call	STD_EPRINTF
 20587                                  	;retn
 20588                                  
 20589                                  ; =============== S U B	R O U T	I N E =======================================
 20590                                  
 20591                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20592                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20593                                  _$RMDIR:
 20594 00002549 E82100                  	call	SETRMMK
 20595 0000254C 72D4                    	jb	short RmDirErr
 20596 0000254E 7518                    	jnz	short badrderr
 20597                                  
 20598 00002550 B43A                    	mov	ah,3Ah
 20599                                  	;mov	ah,RMDIR ; 3Ah
 20600 00002552 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20601                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20602 00002554 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20603                                  
 20604                                  	; 24/02/2023
 20605                                  	; MSDOS 6.0
 20606 00002556 E8A9F7                  	call	get_ext_error_number
 20607                                  				;AN022; get the extended error
 20608 00002559 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20609                                  				;AN022; see if path not found
 20610 0000255C 740A                    	je	short badrderr	;AN022; yes - issue old message
 20611 0000255E 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20612                                  				;AN022; access denied?
 20613 00002561 7405                    	je	short badrderr	;AN022; yes - issue old message
 20614                                  
 20615 00002563 E83800                  	call	set_ext_error_subst
 20616                                  				;AN022;
 20617 00002566 EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20618                                  
 20619                                  	; MSDOS 6.0
 20620                                  badrderr:
 20621                                  	; 24/02/2023
 20622 00002568 BA[9680]                	mov	dx,badrmd_ptr
 20623 0000256B EBB5                    	jmp	short RmDirErr
 20624                                  ;RmDirErr:
 20625                                  	;call	std_eprintf
 20626                                  ;;rmdir_retn
 20627                                  	;retn
 20628                                  
 20629                                  	; 24/02/2023
 20630                                  	; MSDOS 3.3
 20631                                  	;mov	dx,BADRMDPTR
 20632                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20633                                  ;RMDIRERR:
 20634                                  	;call	STD_EPRINTF
 20635                                  ;RMDIR_RETN:
 20636                                  	;retn
 20637                                  
 20638                                  ; =============== S U B	R O U T	I N E =======================================
 20639                                  
 20640                                  ; 	<Common MkDir/RmDir set up code>
 20641                                  ;****************************************************************
 20642                                  ;*
 20643                                  ;* ROUTINE:	SETRMMK
 20644                                  ;*
 20645                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20646                                  ;*		commands. Parses the command line for a required
 20647                                  ;*		filespec.
 20648                                  ;*
 20649                                  ;* INPUT:	command line at offset 81H
 20650                                  ;*
 20651                                  ;* OUTPUT:	carry clear
 20652                                  ;*		    DS:DX points to ASCIIZ argument
 20653                                  ;*		carry set
 20654                                  ;*		    DS:DX has error message pointer
 20655                                  ;*
 20656                                  ;****************************************************************
 20657                                  
 20658                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20659                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20660                                  SETRMMK:
 20661                                  	; MSDOS 6.0
 20662 0000256D BE8100                  	mov	si,81h
 20663 00002570 BF[4185]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20664 00002573 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20665 00002575 31D2                    	xor	dx,dx		;AN000;
 20666                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20667 00002577 E844FC                  	call	Parse_With_Msg
 20668                                  	;cmp	ax,0
 20669                                  	;cmp	ax,RESULT_NO_ERROR
 20670 0000257A 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20671 0000257C 7519                    	jnz	short noargerr	;AC000; yes - exit
 20672                                  
 20673 0000257E BF[EE87]                	mov	di,SRCXNAME
 20674                                  				;AN000; get address of srcxname
 20675 00002581 57                      	push	di		;AN000; save address
 20676 00002582 56                      	push	si		;AN000; save position in line
 20677 00002583 C536[F395]              	lds	si,[PARSE1_ADDR]
 20678                                  				;AN000; get address of path
 20679                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20680 00002587 AC                      	lodsb			;get a char from buffer
 20681 00002588 AA                      	stosb			;AN000; store in srcxname
 20682                                  	;cmp	al,0
 20683                                  	;cmp	al,END_OF_LINE_OUT
 20684 00002589 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20685 0000258B 75FA                    	jnz	short mrdir_move_filename
 20686                                  				;AC000; no - keep moving
 20687 0000258D 5E                      	pop	si		;AN000; get line position back
 20688                                  
 20689                                  ; we have scanned an argument.	See if any args beyond.
 20690                                  
 20691 0000258E BF[4185]                	mov	di,PARSE_MRDIR
 20692 00002591 E814FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20693 00002594 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20694                                  	;retz			;yes - return no error
 20695 00002595 7406                    	jz	short setrmmk_retn
 20696                                  noargerr:
 20697 00002597 BA[557F]                	mov	dx,extend_buf_ptr
 20698                                  				;AC000; get extended message pointer
 20699 0000259A 31C0                    	xor	ax,ax
 20700 0000259C F9                      	stc
 20701                                  setrmmk_retn:
 20702 0000259D C3                      	retn
 20703                                  
 20704                                  	; 24/02/2023
 20705                                  	; MSDOS 3.3
 20706                                  ;SETRMMK:
 20707                                  	;mov	si,81h
 20708                                  	;call	SCANOFF
 20709                                  	;cmp	al,0Dh
 20710                                  	;je	short NOARGERR
 20711                                  	;mov	dx,si
 20712                                  ;SETRMMK1:
 20713                                  	;lodsb
 20714                                  	;call	DELIM
 20715                                  	;jz	short SETRMMK3
 20716                                  	;cmp	al,0Dh
 20717                                  	;jne	short SETRMMK1
 20718                                  	;mov	byte [si-1],0
 20719                                  ;SETRMMK2:
 20720                                  	;retn
 20721                                  ;SETRMMK3:
 20722                                  	;mov	byte [si-1],0
 20723                                  	;push	si
 20724                                  	;call	SCANOFF
 20725                                  	;pop	si
 20726                                  	;cmp	al,0Dh
 20727                                  	;je	short SETRMMK2
 20728                                  ;NOARGERR:
 20729                                  	;mov	dx,BADARGSPTR
 20730                                  	;xor	ax,ax
 20731                                  	;stc
 20732                                  ;SETRMMK_RETN:
 20733                                  	;retn
 20734                                  
 20735                                  ; =============== S U B	R O U T	I N E =======================================
 20736                                  
 20737                                  ; MSDOS 6.0
 20738                                  
 20739                                  ;****************************************************************
 20740                                  ;*
 20741                                  ;* ROUTINE:	Set_ext_error_subst
 20742                                  ;*
 20743                                  ;* FUNCTION:	Sets up substitution for extended error
 20744                                  ;*
 20745                                  ;* INPUT:	AX - extended error number
 20746                                  ;*		DX - offset of string
 20747                                  ;*
 20748                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20749                                  ;*
 20750                                  ;****************************************************************
 20751                                  
 20752                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20753                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20754                                  set_ext_error_subst:
 20755                                  	;mov	byte [msg_disp_class],1
 20756 0000259E C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 20757                                  					;AN022; set up extended error msg class
 20758 000025A3 8916[B08C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20759                                  	;mov	byte [extend_buf_sub],1
 20760 000025A7 C606[577F]01            	mov	byte [extend_buf_sub],one_subst 
 20761                                  	;AN022; put number of subst in control block
 20762 000025AC BA[557F]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 20763 000025AF A3[557F]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 20764                                  savudir_err_retn: ; 24/02/2023
 20765 000025B2 C3                      	retn				;AN022; return
 20766                                  
 20767                                  ; =============== S U B	R O U T	I N E =======================================
 20768                                  
 20769                                  ; <SavUDir - preserve the users current directory on a particular drive>
 20770                                  
 20771                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 20772                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 20773                                  ;   buffer
 20774                                  ;
 20775                                  ;   Inputs:	DL has 1-based drive number
 20776                                  ;		ES:DI has destination buffer (SavUDir1 only)
 20777                                  ;   Outputs:	Carry Clear
 20778                                  ;		    DS = TranGroup
 20779                                  ;		Carry Set
 20780                                  ;		    AX has error code
 20781                                  ;   Registers Modified: AX, SI
 20782                                  
 20783                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20784                                  SAVUDIR:
 20785 000025B3 BF[A289]                	mov	di,USERDIR1
 20786                                  ; --------------
 20787                                  SAVUDIR1:
 20788 000025B6 88D0                    	mov	al,dl
 20789 000025B8 0440                    	add	al,'@' ; 40h
 20790 000025BA 3C40                    	cmp	al,'@' ; 40h
 20791 000025BC 7506                    	jne	short GOTUDRV
 20792 000025BE 0206[D48A]              	add	al,[CURDRV]
 20793 000025C2 FEC0                    	inc	al		; A = 1
 20794                                  GOTUDRV:
 20795 000025C4 AA                      	stosb
 20796 000025C5 8A26[C58A]              	mov	ah,[DIRCHAR]
 20797 000025C9 B03A                    	mov	al,':' ; 3Ah
 20798 000025CB AB                      	stosw
 20799 000025CC 06                      	push	es
 20800 000025CD 1F                      	pop	ds
 20801 000025CE 89FE                    	mov	si,di
 20802 000025D0 B447                    	mov	ah,47h ; 24/02/2023
 20803                                  	;mov	ah,CURRENT_DIR	; 47h
 20804 000025D2 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 20805                                  			; DL = drive (0=default,1=A,etc.)
 20806                                  			; DS:SI	points to 64-byte buffer area
 20807 000025D4 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 20808 000025D6 0E                      	push	cs
 20809 000025D7 1F                      	pop	ds
 20810 000025D8 C3                      	retn
 20811                                  
 20812                                  ; =============== S U B	R O U T	I N E =======================================
 20813                                  
 20814                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20815                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 20816                                  CRLF2:
 20817 000025D9 52                      	push	dx
 20818 000025DA BA[3481]                	mov	dx,acrlf_ptr
 20819 000025DD 1E                      	push	ds
 20820 000025DE 0E                      	push	cs
 20821 000025DF 1F                      	pop	ds
 20822 000025E0 E84028                  	call	std_printf
 20823 000025E3 1F                      	pop	ds
 20824 000025E4 5A                      	pop	dx
 20825 000025E5 C3                      	retn
 20826                                  
 20827                                  ; =============== S U B	R O U T	I N E =======================================
 20828                                  
 20829                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 20830                                  ; may NOT be TRANGROUP
 20831                                  
 20832                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20833                                  scanoff:
 20834 000025E6 AC                      	lodsb
 20835 000025E7 E80400                  	call	DELIM
 20836 000025EA 74FA                    	jz	short scanoff
 20837 000025EC 4E                      	dec	si		; Point to first non-delimiter
 20838                                  scanoff_retn:
 20839 000025ED C3                      	retn
 20840                                  
 20841                                  ; =============== S U B	R O U T	I N E =======================================
 20842                                  
 20843                                  ; Input:    AL is character to classify
 20844                                  ; Output:   Z set if delimiter
 20845                                  ;	    NZ set otherwise
 20846                                  ; Registers modified: none
 20847                                  
 20848                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20849                                  DELIM:
 20850 000025EE 3C20                    	cmp	al,' '	 ;20h
 20851 000025F0 74FB                    	je	short scanoff_retn
 20852 000025F2 3C3D                    	cmp	al,'='  ; 3Dh
 20853 000025F4 74F7                    	je	short scanoff_retn
 20854 000025F6 3C2C                    	cmp	al,','	; 2Ch
 20855 000025F8 74F3                    	je	short scanoff_retn
 20856 000025FA 3C3B                    	cmp	al,';'	 ;3Bh
 20857 000025FC 74EF                    	je	short scanoff_retn
 20858 000025FE 3C09                    	cmp	al,9		; Check for TAB character
 20859 00002600 74EB                    	je	short scanoff_retn
 20860 00002602 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 20861 00002604 C3                      	retn
 20862                                  
 20863                                  
 20864                                  ; =============== S U B	R O U T	I N E =======================================
 20865                                  
 20866                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20867                                  FCB_TO_ASCZ:			
 20868                                  	; Convert DS:SI to ASCIZ ES:DI
 20869 00002605 B90800                  	mov	cx,8
 20870                                  MAINNAME:
 20871 00002608 AC                      	lodsb
 20872 00002609 3C20                    	cmp	al,' ' ; 20h
 20873 0000260B 7401                    	jz	short SKIPSPC
 20874 0000260D AA                      	stosb
 20875                                  SKIPSPC:
 20876 0000260E E2F8                    	loop	MAINNAME
 20877 00002610 AC                      	lodsb
 20878 00002611 3C20                    	cmp	al,' '
 20879 00002613 740F                    	je	short GOTNAME
 20880 00002615 88C4                    	mov	ah,al
 20881                                  	; 24/02/2023
 20882 00002617 B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 20883                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 20884                                  	;stosb
 20885                                  	;xchg	al,ah
 20886                                  	;stosb
 20887                                  	; 24/02/2023
 20888 00002619 AB                      	stosw
 20889 0000261A B102                    	mov	cl,2
 20890                                  EXTNAME:
 20891 0000261C AC                      	lodsb
 20892 0000261D 3C20                    	cmp	al,' '
 20893 0000261F 7403                    	je	short GOTNAME
 20894 00002621 AA                      	stosb
 20895 00002622 E2F8                    	loop	EXTNAME
 20896                                  GOTNAME:
 20897 00002624 30C0                    	xor	al,al
 20898 00002626 AA                      	stosb
 20899                                  STRCOMP_RETN:
 20900 00002627 C3                      	retn
 20901                                  
 20902                                  ; =============== S U B	R O U T	I N E =======================================
 20903                                  
 20904                                  ; Compare ASCIZ DS:SI with ES:DI.
 20905                                  ; SI,DI destroyed.
 20906                                  
 20907                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20908                                  STRCOMP:	
 20909 00002628 A6                      	cmpsb
 20910 00002629 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 20911 0000262B 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 20912                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 20913                                  	;jmp	short STRCOMP	; Equal so far, keep going
 20914                                  	; 24/02/2023
 20915 0000262F 75F7                    	jnz	short STRCOMP
 20916 00002631 C3                      	retn
 20917                                  
 20918                                  ; =============== S U B	R O U T	I N E =======================================
 20919                                  
 20920                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20921                                  CRPRINT:
 20922 00002632 50                      	push	ax
 20923                                  	;mov	al,13	; 0Dh
 20924 00002633 B00D                    	mov	al,0Dh
 20925 00002635 51                      	push	cx
 20926 00002636 57                      	push	di
 20927 00002637 89D7                    	mov	di,dx
 20928 00002639 B9FFFF                  	mov	cx,65535 ; 0FFFFh
 20929 0000263C 06                      	push	es
 20930 0000263D 1E                      	push	ds
 20931 0000263E 07                      	pop	es
 20932 0000263F F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 20933 00002641 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 20934 00002645 07                      	pop	es
 20935 00002646 8916[B08C]              	mov	[string_ptr_2],dx
 20936                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 20937 0000264A BA[1C81]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 20938 0000264D E8D327                  	call	std_printf
 20939                                  	;mov	byte [di-1],13
 20940 00002650 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 20941 00002654 7204                    	jb	short error_output
 20942 00002656 5F                      	pop	di
 20943 00002657 59                      	pop	cx
 20944 00002658 58                      	pop	ax
 20945 00002659 C3                      	retn
 20946                                  
 20947                                  ; ---------------------------------------------------------------------------
 20948                                  
 20949                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20950                                  error_output:
 20951 0000265A 0E                      	push	cs
 20952 0000265B 1F                      	pop	ds
 20953 0000265C 8E06[C08A]              	mov	es,[RESSEG]
 20954 00002660 BA[697F]                	mov	dx,NOSPACE_PTR
 20955 00002663 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 20956 00002669 7406                    	jz	short go_to_error
 20957 0000266B E81709                  	call	PipeOff
 20958 0000266E BA[B680]                	mov	dx,PIPEEMES_PTR
 20959                                  go_to_error:
 20960 00002671 E9E602                  	jmp	cerror
 20961                                  
 20962                                  ; =============== S U B	R O U T	I N E =======================================
 20963                                  
 20964                                  ;---- Mod for path invocation ----
 20965                                  
 20966                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20967                                  pathchrcmp:
 20968                                  	; 18/03/2023	
 20969                                  	;push	ax
 20970                                  	;mov	ah,'/' ; 2Fh
 20971                                  	;cmp	[SWITCHAR],ah
 20972 00002674 803E[C48A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 20973 00002679 7404                    	je	short noslasht
 20974 0000267B 3C2F                    	cmp	al,'/'
 20975 0000267D 7402                    	je	short pccont
 20976                                  noslasht:
 20977 0000267F 3C5C                    	cmp	al,'\' ; 5Ch
 20978                                  pccont:	
 20979                                  	;pop	ax
 20980 00002681 C3                      	retn
 20981                                  
 20982                                  ; =============== S U B	R O U T	I N E =======================================
 20983                                  
 20984                                  ; PATHCRUNCH -
 20985                                  ;
 20986                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 20987                                  ;       PathPos = ptr to string with pathname in it
 20988                                  ;       PathCnt = length of string
 20989                                  ;
 20990                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 20991                                  ;       PathCnt = length left in string
 20992                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 20993                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 20994                                  ;       If path crunched successfully,
 20995                                  ;         CY = clear
 20996                                  ;         Current directory is changed to directory in pathname
 20997                                  ;         UserDir1 contains previous directory for use by RestUDir
 20998                                  ;         RestDir = nonzero to flag later restoration of user's dir
 20999                                  ;         DestTail = ptr to beginning of filename
 21000                                  ;         If filename found in pathname,
 21001                                  ;           ZR = clear
 21002                                  ;           FCB filename fields contain filename
 21003                                  ;         If filename not found (pure directory path),
 21004                                  ;           ZR = set
 21005                                  ;           FCB filename fields are wildcarded with ?'s
 21006                                  ;       If pathcrunch failed (no ChDir's worked),
 21007                                  ;         CY = set
 21008                                  ;         Msg_Numb = extended error code
 21009                                  ;
 21010                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 21011                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 21012                                  ;       with the filename wildcarded.
 21013                                  
 21014                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21015                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 21016                                  
 21017                                  PathCrunch:
 21018                                  	; MSDOS 6.0
 21019 00002682 C706[338E]0000          	mov     word [Msg_Numb],0
 21020                                  				;AN022; Set up message flag
 21021                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21022                                  	;mov	dl,[5Ch]
 21023 00002688 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 21024 0000268C E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 21025                                  	; MSDOS 6.0
 21026 0000268F 7233                     	jc	short pcrunch_cderrj
 21027                                  				;AN022; if error on current dir - report
 21028 00002691 E86004                  	call	SETPATH		; scan past switches, whitespace
 21029                                  
 21030                                  ;       DX = ptr to pathname, NULL-terminated
 21031                                  ;       PathPos = ptr to byte after NULL at end of pathname
 21032                                  
 21033                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21034 00002694 F606[CB8C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 21035 00002699 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 21036                                  
 21037                                  	;mov	ah,CHDir ; 3Bh
 21038 0000269B B43B                    	mov	ah,3Bh
 21039 0000269D CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21040                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21041                                  	; MSDOS 6.0
 21042 0000269F 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 21043                                  	
 21044 000026A1 E85EF6                  	call	get_ext_error_number    ;AN022; get the extended error
 21045 000026A4 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 21046 000026A7 741E                    	je	short trypeel		;AC022;    keep trying
 21047 000026A9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 21048 000026AC 7419                    	je	short trypeel		;AC022;    keep trying
 21049 000026AE A3[338E]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 21050 000026B1 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 21051                                  
 21052                                  	; MSDOS 3.3
 21053                                  	;jc	short trypeel
 21054                                  chdir_worked:
 21055                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21056 000026B4 E83B06                  	call	SetRest1	; set 'Restore Directory' flag true
 21057 000026B7 B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 21058 000026B9 BF5D00                  	mov	di,5Dh  ; FCB+1
 21059 000026BC B90B00                  	mov	cx,11
 21060 000026BF F3AA                    	rep	stosb
 21061 000026C1 30C0                    	xor	al,al		; return carry clear, zero set
 21062 000026C3 C3                      	retn
 21063                                  
 21064                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 21065 000026C4 E98100                  	jmp	pcrunch_cderr	;AN022;
 21066                                  
 21067                                  trypeel:
 21068 000026C7 8B36[1F8C]              	mov	si,[PathPos]
 21069 000026CB 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 21070 000026CC 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 21071                                  	; 25/02/2023
 21072                                  	; MSDOS 5.0 (& 6.0)
 21073 000026CF 803E[4E8E]00            	cmp	byte [KPARSE],0
 21074 000026D4 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 21075                                  	
 21076 000026D6 E89BFF                  	call	pathchrcmp
 21077 000026D9 7475                    	jz	short peelfail	; Trailing '/'
 21078                                  delstrt:
 21079 000026DB 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 21080 000026DD 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 21081 000026DF 52                      	push	dx		; save ptr to pathname
 21082                                  delloop:
 21083 000026E0 39CE                    	cmp	si,cx
 21084                                  	;jz	short BADRET
 21085                                  	; 25/02/2023
 21086 000026E2 7413                    	je	short gotdele	; no char's left, we have what we have
 21087 000026E4 AC                      	lodsb			; AL = next char of pathname
 21088 000026E5 E8DCFC                  	call	testkanj
 21089 000026E8 7403                    	jz	short notkanj8	; not Kanji, move along
 21090 000026EA 46                      	inc	si
 21091 000026EB EBF3                    	jmp	short delloop	
 21092                                  
 21093                                  	; 25/02/2023
 21094                                  	; MSDOS 3.3
 21095                                  	;mov	al,[si]
 21096                                  	;call	PATHCHRCMP
 21097                                  	;jz	short TRYCD
 21098                                  	;dec	si
 21099                                  	;jmp	short delloop
 21100                                  
 21101                                  notkanj8:
 21102 000026ED E884FF                  	call	pathchrcmp
 21103 000026F0 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 21104 000026F2 89F2                    	mov	dx,si
 21105 000026F4 4A                      	dec	dx		; DX = ptr to last delimiter found	
 21106 000026F5 EBE9                    	jmp	short delloop	; go look for more
 21107                                  
 21108                                  	; 25/02/2023
 21109                                  	; MSDOS 5.0 (& 6.0)
 21110                                  gotdele:
 21111 000026F7 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 21112 000026F9 5A                      	pop	dx		; DX = ptr to pathname
 21113 000026FA 39D6                    	cmp	si,dx
 21114 000026FC 7454                    	je	short badret	; didn't find path delim
 21115 000026FE 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 21116 00002700 89D6                    	mov	si,dx		; SI = ptr to pathname
 21117                                  delloop2:			; Set value of KPARSE
 21118 00002702 39CE                    	cmp	si,cx
 21119 00002704 7412                    	je	short trycd	; roll up till SI meets CX
 21120 00002706 C606[4E8E]00            	mov	byte [KPARSE],0
 21121 0000270B AC                      	lodsb
 21122 0000270C E8B5FC                  	call	testkanj
 21123 0000270F 74F1                    	jz	short delloop2
 21124 00002711 46                      	inc	si
 21125 00002712 FE06[4E8E]              	inc	byte [KPARSE]
 21126 00002716 EBEA                    	jmp	short delloop2
 21127                                  
 21128                                  trycd:
 21129 00002718 50                      	push	ax
 21130                                  	; 25/02/2023
 21131 00002719 B02E                    	mov	al,'.'
 21132                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21133                                  	; MSDOS 6.0
 21134 0000271B 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21135                                  				;M019; allow continuation if '. ' or 
 21136                                  				;M019; '..' is not found.
 21137 0000271E 7509                    	jne	short trycd1	;M019; '.' not found
 21138 00002720 384402                  	cmp	[si+2],al	;M019; check for '..'
 21139 00002723 7404                    	je	short trycd1	;M019; found '..'
 21140 00002725 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21141                                  trycd1:	
 21142 00002729 58                      	pop     ax
 21143 0000272A 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21144                                  
 21145                                  	; 25/02/2023
 21146                                  	; MSDOS 3.3
 21147                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21148                                  	;pop	ax
 21149                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21150                                  
 21151                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21152 0000272C 8A44FF                  	mov	al,[si-1]
 21153 0000272F 3C3A                    	cmp	al,':' 		; Special case d:\file
 21154 00002731 741F                    	je	short badret
 21155                                  	; 25/02/2023
 21156                                  	; MSDOS 6.0
 21157 00002733 803E[4E8E]00            	cmp	byte [KPARSE],0
 21158 00002738 7505                    	jnz	short notdoublesl
 21159 0000273A E837FF                  	call	pathchrcmp
 21160                                  	;jnz	short notdoublesl
 21161                                  				; Last char is 2nd KANJI byte, might be '\'
 21162                                  	; 25/02/2023
 21163 0000273D 7411                    	jz	short peelfail 
 21164                                  ;peelfail:
 21165                                  	;stc
 21166                                  	;retn
 21167                                  
 21168                                  notdoublesl:
 21169 0000273F C60400                  	mov	byte [si],0
 21170                                  	;mov	ah,CHDir ; 3Bh
 21171 00002742 B43B                    	mov	ah,3Bh
 21172 00002744 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21173                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21174 00002746 7320                    	jnc	short cdsucc
 21175                                  
 21176                                  	; 25/02/2023
 21177                                  	; MSDOS 6.0
 21178                                  pcrunch_cderr:
 21179 00002748 E8B7F5                  	call	get_ext_error_number
 21180                                  				;AN022; get the extended error
 21181 0000274B A3[338E]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21182 0000274E 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21183                                  peelfail: ; 25/02/2023
 21184 00002750 F9                      	stc			;AN022; set up carry flag
 21185                                  pcrunch_retn:
 21186 00002751 C3                      	retn
 21187                                  
 21188                                  badret:
 21189                                  	; MSDOS 3.3 & MSDOS 6.0
 21190 00002752 8A04                    	mov	al,[si]
 21191 00002754 E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21192 00002757 F9                      	stc
 21193 00002758 75F7                    	jnz	short pcrunch_retn
 21194 0000275A 30DB                    	xor	bl,bl
 21195 0000275C 865C01                  	xchg	bl,[si+1]
 21196                                  	;mov	ah,CHDir ; 3Bh
 21197 0000275F B43B                    	mov	ah,3Bh
 21198 00002761 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21199                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21200                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21201                                  	; 25/02/2023
 21202 00002763 72E3                    	jc	short pcrunch_cderr
 21203                                  				;AN022; go to error exit 
 21204 00002765 885C01                  	mov	[si+1],bl
 21205                                  cdsucc:
 21206 00002768 E88705                  	call	SetRest1
 21207 0000276B 46                      	inc	si		; Reset zero
 21208 0000276C 8936[C98C]              	mov	[DestTail],si
 21209                                  	; 25/02/2023
 21210                                  	; MSDOS 6.0
 21211 00002770 9C                      	pushf			;AN015; save flags
 21212 00002771 803E[278C]FF            	cmp	byte [DirFlag],-1
 21213                                  				;AN015; don't do parse if in DIR
 21214 00002776 7408                    	je	short pcrunch_end
 21215                                  				;AN015;
 21216                                  	; MSDOS 3.3 & MSDOS 6.0
 21217 00002778 BF5C00                  	mov	di,FCB  ; 5Ch
 21218                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21219 0000277B B80229                  	mov	ax,2902h	
 21220 0000277E CD21                    	int	21h		; Parse with default drive
 21221                                  			; DOS -	PARSE FILENAME
 21222                                  			; DS:SI	-> string to parse
 21223                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21224                                  			; AL = bit mask	to control parsing
 21225                                  	; MSDOS 3.3
 21226                                  	;retn
 21227                                  
 21228                                  pcrunch_end:
 21229 00002780 9D                      	popf			;AN015; get flags back
 21230 00002781 C3                      	retn
 21231                                  
 21232                                  ;============================================================================
 21233                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21234                                  ;============================================================================
 21235                                  ; 05/10/2018 - Retro DOS v3.0
 21236                                  
 21237                                  ;TITLE	Part7 COMMAND Transient Routines
 21238                                  
 21239                                  ;	More misc routines
 21240                                  
 21241                                  ;---------------------------
 21242                                  ; We can get rid of this switch processing code if we can take
 21243                                  ; care of the remaining two calls to switch, later in the file.
 21244                                  ; However, I have not checked whether or not any other files use
 21245                                  ; switch -- after all, it IS public!
 21246                                  ;---------------------------
 21247                                  
 21248                                  ; 28/03/2023
 21249                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21250                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21251                                  
 21252                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21253                                  
 21254                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21255                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21256                                  
 21257                                  ; ---------------------------------------------------------------------------
 21258                                  
 21259                                  	; 25/02/2023
 21260                                  RETSW:
 21261 00002782 93                      	xchg	ax,bx		; Put switches in AX
 21262 00002783 C3                      	retn
 21263                                  
 21264                                  ; =============== S U B	R O U T	I N E =======================================
 21265                                  
 21266                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21267                                  SWITCH:
 21268 00002784 31DB                    	xor	bx,bx		; Initialize - no switches set
 21269                                  SWLOOP:
 21270 00002786 E85DFE                  	call	scanoff		; Skip any delimiters
 21271 00002789 3A06[C48A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21272 0000278D 75F3                    	jnz	short RETSW	; No -- we're finished
 21273 0000278F 81CB0080                	or	bx,8000h
 21274                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21275 00002793 46                      	inc	si		; Skip over the switch character
 21276 00002794 E84FFE                  	call	scanoff
 21277 00002797 3C0D                    	cmp	al,0Dh
 21278 00002799 74E7                    	je	short RETSW	; Oops
 21279 0000279B 46                      	inc	si
 21280                                  
 21281                                  	; Convert lower case input to upper case
 21282                                  
 21283 0000279C E84FFC                  	call	UPCONV
 21284                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21285                                  
 21286 0000279F BF[8B84]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21287                                  				; ("VBAPW" (for MSDOS 3.3))
 21288 000027A2 B90600                  	mov	cx,6  ; MSDOS 6.0
 21289                                  	;mov	cx,5  ; MSDOS 3.3
 21290                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21291                                  		
 21292                                  	;nop
 21293                                  		
 21294 000027A5 F2AE                    	repne	scasb		; Look for matching switch
 21295 000027A7 7507                    	jnz	short BADSW
 21296 000027A9 B80100                  	mov	ax,1
 21297 000027AC D3E0                    	shl	ax,cl		; Set a bit for the switch
 21298 000027AE 09C3                    	or	bx,ax
 21299                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21300 000027B0 EBD4                    	jmp	short SWLOOP
 21301                                  ;BADSW:
 21302                                  	;jmp	short SWLOOP
 21303                                  ;DRVBAD:
 21304                                  ;	mov	dx,baddrv_ptr
 21305                                  ;	jmp	cerror
 21306                                  EXTERNALJ:
 21307 000027B2 E90501                  	jmp	EXTERNAL
 21308                                  FNDCOM:				; search the internal command table
 21309 000027B5 08C0                    	or	al,al		; Get real length of first arg
 21310 000027B7 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21311                                  				;  to be external.
 21312                                  ; barryf code starts here
 21313                                  
 21314 000027B9 E82703                  	call	test_append	; see if APPEND installed
 21315 000027BC 7429                    	jz	short CONTCOM	; not loaded
 21316                                  
 21317                                  APPEND_INTERNAL:
 21318 000027BE 8A0E[4A8B]              	mov	cl,[IDLEN]
 21319 000027C2 B500                    	mov	ch,0
 21320 000027C4 890E[1F8C]              	mov	[PathPos],cx
 21321                                  	
 21322                                  	; 25/02/2023	
 21323                                  	; MSDOS 6.0
 21324 000027C8 FE06[358E]              	inc 	byte [append_exec]
 21325                                  				;AN041; set APPEND to ON
 21326 000027CC E8BD03                  	call	IOSET		; re-direct the o'l io
 21327                                  
 21328 000027CF BE[4A8B]                	mov	si,IDLEN	; address command name, DS already set	
 21329 000027D2 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21330                                  		
 21331                                  	; MSDOS 6.0
 21332 000027D5 BF[0D4E]                	mov	di,append_parse
 21333                                  				;AN010; Get the entry point for PARSE for APPEND
 21334                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21335 000027D8 B801AE                  	mov	ax,0AE01h
 21336 000027DB CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21337                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21338                                  			; DX = FFFFh, DS:SI -> buffer
 21339                                  			; Return: buffer at DS:SI filled with a	length byte
 21340                                  			; followed by the uppercase internal command
 21341                                  			; to execute (if length not 0)
 21342                                  	; 25/02/2023
 21343                                  	; INT 2Fh
 21344                                  	; 	AX = AE01h
 21345                                  	; entry:
 21346                                  	; 	DX = magic value FFFFh
 21347                                  	; 	CH = 00h
 21348                                  	; 	CL = length of command name
 21349                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21350                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21351                                  	; return:
 21352                                  	;	DS:SI buffer updated
 21353                                  	;	if length byte is nonzero, the following bytes contain
 21354                                  	;	the uppercase internal command to execute and the command line
 21355                                  	; 	buffer contains the command's parameters
 21356                                  	;	(the first DS:[SI] bytes are ignored)
 21357                                  	;
 21358                                  	; Format of COMMAND.COM command line buffer:
 21359                                  	;	Offset  Size    Description
 21360                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21361                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21362                                  	;	N BYTEs command line text, terminated by 0Dh
 21363                                  	;
 21364                                  	; Format of command name buffer:
 21365                                  	;	Offset  Size    Description
 21366                                  	;	00h     BYTE    length of command name
 21367                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21368                                  
 21369 000027DD 803E[4A8B]00            	cmp	byte [IDLEN],0 ; execute requested
 21370 000027E2 7503                    	jne	short CONTCOM
 21371 000027E4 E9A300                  	jmp	CMD_DONE
 21372                                  
 21373                                  	;nop
 21374                                  CONTCOM:			; continue with internal scan
 21375 000027E7 BF[0A83]                	mov	di,COMTAB
 21376 000027EA 31C9                    	xor	cx,cx
 21377                                  FINDCOM:
 21378 000027EC BE[4B8B]                	mov	si,ID		; pointer to command argument
 21379 000027EF 8A0D                    	mov	cl,[di]		; load length of internal command
 21380 000027F1 47                      	inc	di		; advance past length
 21381 000027F2 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21382 000027F4 3A0E[4A8B]              	cmp	cl,[IDLEN]	; that of the command argument
 21383 000027F8 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21384 000027FA 890E[1F8C]              	mov	[PathPos],cx	; store length of command
 21385 000027FE F3A6                    	repe	cmpsb
 21386                                  ABCD:					
 21387 00002800 9F                      	lahf			; save the good ol' flags
 21388 00002801 01CF                    	add	di,cx		; skip over remaining internal, if any
 21389 00002803 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21390 00002805 A2[D28A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21391 00002808 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21392 00002809 8B1D                    	mov	bx,[di]		; load internal command address
 21393 0000280B 47                      	inc	di		; skip over the puppy
 21394 0000280C 47                      	inc	di
 21395                                  		
 21396                                  	; MSDOS 6.0
 21397 0000280D 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21398 0000280F 47                      	inc	di
 21399 00002810 47                      	inc	di
 21400 00002811 9E                      	sahf			; remember those flags?
 21401 00002812 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21402                                  
 21403                                  ; All messages get redirected.
 21404                                  
 21405 00002814 803E[358E]00            	cmp     byte [append_exec],0
 21406                                  				;AN041; APPEND just executed?
 21407 00002819 7503                    	jnz 	short DONT_SET_IO
 21408                                  				;AN041; Yes - this junk is already set
 21409 0000281B E86E03                  	call	IOSET		; re-direct the ol' i/o
 21410                                  
 21411                                  DONT_SET_IO:			;AN041;
 21412                                  
 21413                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21414                                  ; respond to /? only if it is the only command-line argument.
 21415                                  
 21416 0000281E A1[D78A]                	mov	ax,[COMSW]	; AX = switches after command
 21417 00002821 0B06[DD8A]              	or	ax,[AllSwitch]	; AX = all switches
 21418                                  	;and	ax,SwitchQues	
 21419 00002825 83E020                  	and	ax,20h
 21420 00002828 7426                    	jz	short DRIVE_CHECK
 21421                                  				; /? not in command line
 21422 0000282A F606[D28A]04            	test	byte [CHKDRV],4	
 21423                                  	;test	byte [CHKDRV],fLimitHelp
 21424 0000282F 7407                    	jz	short DO_HELP	; /? allowed in combination
 21425                                  
 21426                                  ; Make sure /? is the only argument on the command line.
 21427                                  
 21428 00002831 833E[0F91]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21429 00002836 7518                    	jne	short DRIVE_CHECK
 21430                                  				; /? not only arg - ignore
 21431                                  
 21432                                  ; Note: this is all the check we need, even against things like /??.
 21433                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21434                                  
 21435                                  DO_HELP:
 21436                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21437                                  
 21438 00002838 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21439                                      	;mov	ax,no_subst	; AL = no subst's code
 21440 0000283A B80000                  	mov	ax,0
 21441 0000283D 50                      	push	ax		; build subst block on stack
 21442                                  
 21443                                  NEXT_HELP_MSG:
 21444 0000283E AD                      	lodsw			; AX = help msg # or zero
 21445 0000283F 09C0                    	or	ax,ax
 21446 00002841 7409                    	jz	short HELP_DONE
 21447 00002843 50                      	push	ax		; SS:SP = ptr to subst block
 21448                                  				; (msg # and no_subst byte)
 21449                                  ;; We assume DS = SS.
 21450                                  	
 21451 00002844 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21452 00002846 E8DA25                  	call	std_printf	; display help message	
 21453 00002849 58                      	pop	ax		; remove msg # from stack
 21454 0000284A EBF2                    	jmp	short NEXT_HELP_MSG
 21455                                  
 21456                                  HELP_DONE:
 21457 0000284C 58                      	pop	ax		; clean up stack
 21458 0000284D E9B4D8                  	jmp	TCOMMAND	
 21459                                  
 21460                                  	; 25/02/2023
 21461                                  	; MSDOS 3.3
 21462                                  	;sahf			; remember those flags?
 21463                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21464                                  	;call	IOSET		; re-direct the ol' i/o
 21465                                  
 21466                                  DRIVE_CHECK:
 21467 00002850 F606[D28A]01            	test	byte [CHKDRV],1
 21468                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21469                                  				; did we wanna check those drives?
 21470 00002855 7411                    	jz	short NOCHECK
 21471 00002857 A0[D58A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21472 0000285A 0A06[D68A]              	or	al,[PARM2]	; us whether those drives were OK
 21473 0000285E 3CFF                    	cmp	al,-1
 21474 00002860 7506                    	jne	short NOCHECK
 21475                                  	;jmp	DRVBAD
 21476                                  	; 25/02/2023
 21477                                  DRVBAD:
 21478 00002862 BA[B17F]                	mov	dx,baddrv_ptr
 21479 00002865 E9F200                  	jmp	cerror
 21480                                  
 21481                                  ; The user may have omitted the space between the command and its arguments.
 21482                                  ; We need to copy the remainder of the user's command line into the buffer.
 21483                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21484                                  ; into the command line at 80.
 21485                                  
 21486                                  NOCHECK:
 21487 00002868 E85B02                  	call	cmd_copy
 21488                                  SWITCHECK:
 21489                                  	;test	byte [CHKDRV],2
 21490 0000286B F606[D28A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21491                                  				; Does the command take switches
 21492 00002870 7516                    	jnz	short REALWORK	; Yes, process the command
 21493 00002872 E82F00                  	call	noswit		; No, check to see if any switches
 21494 00002875 7511                    	jnz	short REALWORK	; None, process the command
 21495                                  
 21496                                  	; MSDOS 6.0
 21497                                  	;mov	byte [msg_disp_class],2
 21498 00002877 C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class
 21499                                  				;AN000; set up parse error msg class
 21500 0000287C BA[557F]                	mov	dx,extend_buf_ptr	
 21501                                  				;AC000; get extended message pointer
 21502                                  	;mov	word [extend_buf_ptr],3
 21503 0000287F C706[557F]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21504                                  				;AN000; get "Invalid switch" message number
 21505 00002885 E9D200                  	jmp	cerror		; Print error and chill out...
 21506                                  
 21507                                  	; 25/02/2023
 21508                                  	; MSDOS 3.3
 21509                                  	;mov	dx,BADPARMPTR
 21510                                  	;jmp	CERROR
 21511                                  
 21512                                  REALWORK:
 21513 00002888 FFD3                    	call	bx		; do some real work, at last
 21514                                  
 21515                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21516                                  ; otherwise, go get another command.
 21517                                  
 21518                                  CMD_DONE:
 21519 0000288A 0E                      	push	cs		; g  restore data segment
 21520 0000288B 1F                      	pop	ds		; g
 21521 0000288C 1E                      	push	ds
 21522 0000288D 8E1E[C08A]              	mov	ds,[RESSEG]	; g  save data segment
 21523                                  	;cmp	byte [Call_Flag],1
 21524                                  				; G  Is a call in progress?
 21525 00002891 803E[B101]01            	cmp	byte [Call_Flag],call_in_progress
 21526 00002896 C606[B101]00            	mov	byte [Call_Flag],0
 21527                                  				; G  Either way, reset flag
 21528 0000289B 1F                      	pop	ds		; g  get data segment back
 21529 0000289C 7403                    	jz	short INCALL	; G
 21530 0000289E E963D8                  	jmp	TCOMMAND	; chill out...
 21531                                  INCALL:
 21532 000028A1 E933DA                  	jmp	DOCOM1
 21533                                  
 21534                                  ; =============== S U B	R O U T	I N E =======================================
 21535                                  
 21536                                  	; 25/02/2023
 21537                                  noswit:
 21538 000028A4 57                      	push	di		; Save di
 21539 000028A5 BF8100                  	mov	di,81h		; di = ptr to command args
 21540 000028A8 BE8000                  	mov	si,80h		; Get address of length of command args
 21541 000028AB AC                      	lodsb			; Load length
 21542 000028AC 88C1                    	mov	cl,al		; Move length to cl
 21543 000028AE 30ED                    	xor	ch,ch		; Zero ch
 21544 000028B0 2EA0[C48A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21545                                  	;cmp	al,0		; Turn off ZF
 21546                                  	; 25/02/2023
 21547 000028B4 20C0                    	and	al,al
 21548 000028B6 F2AE                    	repne	scasb		; Scan for a switch character and return
 21549 000028B8 5F                      	pop	di		;  with ZF set if one was found
 21550 000028B9 C3                      	retn
 21551                                  
 21552                                  ; ---------------------------------------------------------------------------
 21553                                  
 21554                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21555                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21556                                  
 21557                                  EXTERNAL:
 21558 000028BA E82602                  	call	test_append	; check to see if append installed
 21559 000028BD 7403                    	jz	short NOT_BARRYF
 21560                                  				; no - truly external command
 21561 000028BF E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21562                                  
 21563                                  NOT_BARRYF:
 21564 000028C2 2EC606[D38A]00          	mov	byte [cs:FILTYP],0
 21565 000028C8 2E8A16[E08A]            	mov	dl,[cs:SPECDRV]
 21566 000028CD 2E8816[4A8B]            	mov	[cs:IDLEN],dl
 21567 000028D2 2EC606[C28C]00          	mov	byte [cs:ROM_CALL],0
 21568 000028D8 52                      	push	dx
 21569 000028D9 BA[4A8B]                	mov	dx,IDLEN
 21570 000028DC E81BDB                  	call	ROM_SCAN
 21571 000028DF 5A                      	pop	dx
 21572                                  	;jnc	short POSTSAVE
 21573 000028E0 7305                    	jnc	short DO_SCAN
 21574 000028E2 2EFE06[C28C]            	inc	byte [cs:ROM_CALL]
 21575                                  	;jmp	short POSTSAVE
 21576                                  
 21577                                  	;nop
 21578                                  DO_SCAN:
 21579                                  POSTSAVE:
 21580 000028E7 BF[E889]                	mov	di,EXECPATH
 21581 000028EA C60500                  	mov	byte [di],0	; Initialize to current directory
 21582                                  	
 21583 000028ED 2E803E[C28C]00          	cmp	byte [cs:ROM_CALL],0
 21584                                  	;jz	short RESEARCH
 21585                                  	; 25/02/2023
 21586                                  	;jmp	short NEOEXECUTE
 21587 000028F3 750F                    	jnz	short NEOEXECUTE	
 21588                                  
 21589                                  	;nop
 21590                                  RESEARCH:
 21591 000028F5 E89808                  	call	path_search	; find the mother (result in execpath)
 21592 000028F8 09C0                    	or	ax,ax		; did we find anything?
 21593                                  	;jz	short BADCOMJ45	; null means no (sob)
 21594                                  	; 25/02/2023
 21595 000028FA 7459                    	jz	short BADCOM
 21596 000028FC 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21597                                  				; fuckin' sixteen-bit machine ought
 21598                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21599                                  				; DISPLACEMENT!!
 21600                                  	;;jmp	short NEOEXECUTE
 21601                                  	;jmp	short EXECUTE	
 21602                                  	; 25/02/2023
 21603 000028FF 7D03                    	jnl	short EXECUTE ; jge
 21604                                  
 21605                                  	; 02H is .bat
 21606                                  
 21607                                  	;nop
 21608                                  BATCOMJ:
 21609 00002901 E986DE                  	jmp	BATCOM
 21610                                  
 21611                                  	; 25/02/2023
 21612                                  ;BADCOMJ45:
 21613                                  	;jmp	short BADCOM
 21614                                  
 21615                                  	;nop
 21616                                  EXECUTE:
 21617                                  NEOEXECUTE:
 21618 00002904 E88502                  	call	IOSET
 21619                                  
 21620                                  ; MSDOS 6.0
 21621                                  ;M051
 21622                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21623                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21624                                  ;After a close, this would still leave one open active resulting in sharing
 21625                                  ;errors on subsequent opens of the redirected file.
 21626                                  
 21627                                  LH_EXECUTE:			;M051	
 21628 00002907 8E06[D08A]              	mov	es,[TRAN_TPA]
 21629                                  	;mov	ah,DEALLOC ; 49h
 21630 0000290B B449                    	mov	ah,49h
 21631 0000290D CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21632                                  			; ES = segment address of area to be freed
 21633                                  				; Now running in "free" space
 21634 0000290F 8E06[C08A]              	mov	es,[RESSEG]
 21635 00002913 26FE06[9C01]            	inc	byte [es:ExtCom] ; Indicate external command
 21636 00002918 26C606[A401]00          	mov	byte [es:RestDir],0 
 21637                                  				; Since USERDIR1 is in transient, insure
 21638                                  				; this flag value for re-entry to COMMAND
 21639                                  	; MSDOS 6.0
 21640 0000291E BE[E889]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21641 00002921 BF[6303]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21642                                  	;mov	cx,LENMSGORPATHBUF
 21643 00002924 B95000                  	mov	cx,80
 21644 00002927 FC                      	cld
 21645 00002928 F3A4                    	rep	movsb		; copy program pathname to resident
 21646                                  
 21647                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21648 0000292A BF5C00                  	mov	di,FCB ; 5Ch
 21649 0000292D 89FE                    	mov	si,di
 21650                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21651 0000292F B152                    	mov	cl,82 ; 25/02/2023
 21652 00002931 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21653                                  	
 21654                                  	; 25/02/2023
 21655                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21656                                  	; MSDOS 6.0 (& 5.0)
 21657                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21658 00002933 BA[6303]                	mov	dx,SafePathBuffer
 21659 00002936 06                      	push	es
 21660 00002937 1F                      	pop	ds
 21661                                  
 21662                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21663 00002938 BB[3F03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21664                                  	;mov	ax,EXEC*256 ; 4B00h
 21665 0000293B B8004B                  	mov	ax,4B00h
 21666                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21667 0000293E 2EF606[C28C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21668 00002944 7403                    	jz	short OK_EXEC
 21669 00002946 E92ADB                  	jmp	ROM_EXEC
 21670                                  
 21671                                  OK_EXEC:
 21672                                  
 21673                                  ; we are now running in free space. Anything we do from here on may get
 21674                                  ; trashed. Move the stack (also in free space) to allocated space because
 21675                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21676                                  
 21677 00002949 8CC1                    	mov	cx,es
 21678 0000294B 8ED1                    	mov	ss,cx
 21679 0000294D BC[3804]                	mov	sp,RStack
 21680                                  	; MSDOS 3.3
 21681                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21682                                  	; 25/02/2023
 21683                                  	; MSDOS 6.0
 21684 00002950 2EFF2E[C68A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21685                                  
 21686                                  ; ---------------------------------------------------------------------------
 21687                                  
 21688                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21689                                  BADCOM:
 21690 00002955 0E                      	push	cs
 21691 00002956 1F                      	pop	ds
 21692 00002957 BA[787F]                	mov	dx,BADNAM_PTR
 21693                                  cerror:		
 21694 0000295A E8BE24                  	call	std_eprintf
 21695 0000295D E9A4D7                  	jmp	TCOMMAND
 21696                                  
 21697                                  ; =============== S U B	R O U T	I N E =======================================
 21698                                  
 21699                                  ; Prescan converts the input buffer into a canonicalized form.
 21700                                  ; All redirections and pipes are removed.
 21701                                  
 21702                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21703                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21704                                  
 21705                                  PRESCAN:
 21706 00002960 31C9                    	xor	cx,cx
 21707 00002962 8E06[C08A]              	mov	es,[RESSEG]
 21708 00002966 BE[2189]                	mov	si,COMBUF+2
 21709 00002969 89F7                    	mov	di,si
 21710                                  COUNTQUOTES:
 21711 0000296B AC                      	lodsb			; get a byte
 21712 0000296C 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21713 0000296E 7504                    	jne	short COUNTEND	; no, try for end of road
 21714 00002970 FEC5                    	inc	ch		; bump count
 21715 00002972 EBF7                    	jmp	short COUNTQUOTES
 21716                                  				; go get next char
 21717                                  COUNTEND:
 21718 00002974 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21719 00002976 75F3                    	jne	short COUNTQUOTES
 21720                                  				; no, go back for next char
 21721                                  	; 26/02/2023
 21722                                  	; MSDOS 5.0 (& 6.0)
 21723 00002978 51                      	push	cx		; save count
 21724 00002979 89FE                    	mov	si,di		; restore pointer to begining
 21725                                  KanjiScan:
 21726 0000297B AC                      	lodsb			; get a byte
 21727 0000297C E845FA                  	call	testkanj	; is it a leadin byte
 21728 0000297F 740F                    	jz	short KanjiQuote
 21729                                  				; no, check for quotes
 21730 00002981 88C4                    	mov	ah,al		; save leadin
 21731 00002983 AC                      	lodsb			; get trailing byte
 21732 00002984 3D2020                  	cmp	ax,2020h
 21733                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21734 00002987 75F2                    	jne	short KanjiScan	; no, go get next
 21735 00002989 C744FE2020              	mov	word [si-2],2020h
 21736                                  				; replace with spaces
 21737 0000298E EBEB                    	jmp	short KanjiScan	; go get next char
 21738                                  	
 21739                                  KanjiQuote:
 21740 00002990 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21741 00002992 750D                    	jne	short KanjiEnd	; no, check for end
 21742 00002994 FECD                    	dec	ch		; drop count
 21743 00002996 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21744                                  KanjiQuoteLoop:
 21745 00002998 AC                      	lodsb			; get next byte
 21746 00002999 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21747 0000299B 75FB                    	jne	short KanjiQuoteLoop
 21748                                  				; no, get another
 21749 0000299D FECD                    	dec	ch		; yes, drop count
 21750 0000299F EBDA                    	jmp	short KanjiScan	; go get next char
 21751                                  KanjiEnd:
 21752 000029A1 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21753 000029A3 75D6                    	jne	short KanjiScan	; go back to beginning
 21754 000029A5 59                      	pop	cx		; get back original count
 21755                                  	; 26/04/2023
 21756 000029A6 89FE                    	mov	si,di		; restore pointer to beginning
 21757                                  	
 21758                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21759                                  PRESCANLP:
 21760 000029A8 AC                      	lodsb
 21761                                  	; 26/02/2023
 21762 000029A9 E818FA                  	call	testkanj
 21763 000029AC 740C                    	jz	short NOTKANJ6
 21764                                  	; MSDOS 6.0
 21765 000029AE 8805                    	mov	[di],al
 21766 000029B0 47                      	inc	di		; fake STOSB into DS
 21767 000029B1 AC                      	lodsb			; grab second byte
 21768 000029B2 8805                    	mov	[di],al		; fake stosb into DS
 21769 000029B4 FEC1                    	inc	cl
 21770 000029B6 FEC1                    	inc	cl
 21771 000029B8 EBEE                    	jmp	short PRESCANLP
 21772                                  
 21773                                  NOTKANJ6:
 21774                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21775 000029BA 3C22                    	cmp	al,'"'	; 22h	; " character
 21776 000029BC 7510                    	jne	short TRYGREATER
 21777 000029BE FECD                    	dec	ch
 21778 000029C0 740C                    	jz	short TRYGREATER
 21779                                  QLOOP:
 21780 000029C2 8805                    	mov	[di],al
 21781 000029C4 47                      	inc	di
 21782 000029C5 FEC1                    	inc	cl
 21783 000029C7 AC                      	lodsb
 21784 000029C8 3C22                    	cmp	al,'"'		; " character
 21785 000029CA 75F6                    	jne	short QLOOP
 21786 000029CC FECD                    	dec	ch
 21787                                  TRYGREATER:
 21788 000029CE 3C3E                    	cmp	al,'>' ; 3Eh
 21789                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 21790                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 21791 000029D0 7557                    	jne	short NOOUT
 21792                                  
 21793                                  ; We have found a ">" char. We need to see if there is another ">"
 21794                                  ; following it.
 21795                                  
 21796 000029D2 3804                    	cmp	[si],al
 21797 000029D4 7506                    	jne	short NOAPPND
 21798 000029D6 AC                      	lodsb
 21799 000029D7 26FE06[C601]            	inc	byte [es:Re_Out_App] ; Flag >>
 21800                                  NOAPPND:
 21801                                  ; Now we attempt to find the file name. First, scan off all whitespace
 21802                                  
 21803 000029DC E807FC                  	call	scanoff
 21804                                  
 21805                                  	; 26/02/2023
 21806                                  	; MSDOS 6.0
 21807 000029DF 3C3C                    	cmp	al,'<' ; 3Ch
 21808                                  	;cmp	al,labracket	;AN040; was there no filename?
 21809 000029E1 7404                    	je	short REOUT_ERRSET
 21810                                  				;AN040; yes - set up error
 21811                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21812 000029E3 3C0D                    	cmp	al,0Dh
 21813 000029E5 750D                    	jnz	short GOTREOFIL
 21814                                  
 21815                                  ; There was no file present. Set us up at end-of-line.
 21816                                  
 21817                                  REOUT_ERRSET:			;AN040; set up for an error
 21818 000029E7 C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 21819 000029EA 26C706[C701]0900        	mov	word [es:Re_OutStr],9
 21820                                  				; Cause an error later
 21821 000029F1 E9A900                  	jmp	PRESCANEND
 21822                                  
 21823                                  GOTREOFIL:
 21824 000029F4 57                      	push	di
 21825                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 21826 000029F5 BF[C701]                	mov	di,Re_OutStr
 21827 000029F8 89FB                    	mov	bx,di
 21828 000029FA 06                      	push	es
 21829                                  
 21830                                  	; 26/02/2023
 21831                                  	; MSDOS 6.0
 21832                                  SETREOUTSTR:			; Get the output redirection name
 21833                                  				; MSKK06 07/14/89
 21834 000029FB 51                      	push	cx		; save cx
 21835 000029FC B94D00                  	mov	cx,64+13	; CX = max string length
 21836                                  SETREOUTSTR_LOOP:
 21837 000029FF AC                      	lodsb
 21838 00002A00 3C0D                    	cmp	al,0Dh
 21839 00002A02 741A                    	je	short GOTRESTR_J
 21840 00002A04 E8E7FB                  	call	DELIM
 21841 00002A07 7415                    	jz	short GOTRESTR_J
 21842 00002A09 3A06[C48A]              	cmp	al,[SWITCHAR]
 21843 00002A0D 740F                    	je	short GOTRESTR_J
 21844 00002A0F 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 21845 00002A11 7413                    	je	short PIPEERRSYNJ5_J
 21846                                  				;AN033; Yes - get out quick - or system crashes
 21847 00002A13 3C3C                    	cmp	al,'<' ; 3Ch
 21848                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 21849 00002A15 7404                    	je	short ABRACKET_TERM
 21850                                  				;AN002; yes - end of string
 21851 00002A17 3C3E                    	cmp	al,'>' ; 3Eh
 21852                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 21853 00002A19 7506                    	jne	short NO_ABRACKET
 21854                                  				;AN002; no - not end of string
 21855                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 21856 00002A1B 4E                      	dec	si		;AN002; back up over symbol
 21857 00002A1C B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 21858                                  GOTRESTR_J:
 21859 00002A1E 59                      	pop	cx		; MSKK06 07/14/89
 21860 00002A1F EB58                    	jmp	short GOTRESTR	;AN002; go process it
 21861                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 21862 00002A21 AA                      	stosb			; store it into resgroup
 21863 00002A22 E2DB                    	loop	SETREOUTSTR_LOOP
 21864                                  				; MSKK06 07/14/89
 21865 00002A24 EBF8                    	jmp	short GOTRESTR_J
 21866                                  PIPEERRSYNJ5_J:
 21867 00002A26 59                      	pop	cx		; recover CX
 21868 00002A27 EB4B                    	jmp	short PIPEERRSYNJ5
 21869                                  
 21870                                  	; 26/02/2023
 21871                                  ;	; MSDOS 3.3
 21872                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 21873                                  ;	lodsb
 21874                                  ;	cmp	al,0Dh
 21875                                  ;	jz	short GOTRESTR
 21876                                  ;	call	DELIM
 21877                                  ;	jz	short GOTRESTR
 21878                                  ;	cmp	al,[SWITCHAR]
 21879                                  ;	je	short GOTRESTR
 21880                                  ;	cmp	al,'"'
 21881                                  ;	jne	short NO_ABRACKET
 21882                                  ;	dec	ch
 21883                                  ;NO_ABRACKET:
 21884                                  ;	stosb
 21885                                  ;	jmp	short SETREOUTSTR_LOOP
 21886                                  
 21887                                  NOOUT:
 21888                                  	; 26/02/2023
 21889                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21890 00002A29 3C3C                    	cmp	al, '<' ; 3Ch
 21891                                  	;cmp	al,labracket	; MSDOS 6.0
 21892                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 21893 00002A2B 7523                    	jne	short CHKPIPE
 21894 00002A2D 89F3                    	mov	bx,si		; Save loc of "<"
 21895 00002A2F E8B4FB                  	call	scanoff
 21896                                  	; MSDOS 6.0
 21897 00002A32 3C3E                    	cmp	al,'>' ; 3Eh
 21898                                  	;cmp	al,rabracket	;AN040; was there no filename?
 21899 00002A34 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 21900                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21901 00002A36 3C0D                    	cmp	al,0Dh
 21902 00002A38 750B                    	jne	short GOTREIFIL
 21903                                  REIN_ERRSET:			;AN040; set up for error
 21904 00002A3A C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 21905 00002A3D C706[6B8A]0900          	mov	word [RE_INSTR],9 
 21906                                  				; Cause an error later
 21907 00002A43 EB58                    	jmp	short PRESCANEND
 21908                                  GOTREIFIL:
 21909 00002A45 57                      	push	di
 21910 00002A46 BF[6B8A]                	mov	di,RE_INSTR
 21911 00002A49 89FB                    	mov	bx,di
 21912 00002A4B 06                      	push	es
 21913 00002A4C 0E                      	push	cs
 21914 00002A4D 07                      	pop	es		; store in TRANGROUP
 21915                                  	; 26/04/2023
 21916                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 21917 00002A4E EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 21918                                  				; Get the input redirection name
 21919                                  CHKPIPE:
 21920 00002A50 88C4                    	mov	ah,al
 21921                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21922 00002A52 80FC7C                  	cmp	ah,'|' ; 7Ch
 21923                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 21924                                  	;je	short ISPIPE3
 21925                                  	;; MSDOS 6.0
 21926                                  	;cmp	ah,'|' ; 7Ch
 21927                                  	;;cmp	al,vbar ; 7Ch
 21928                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 21929 00002A55 7539                    	jne	short CONTPRESCAN
 21930                                  ISPIPE3:
 21931                                  ; Only push the echo flag if we are entering the pipe for the first time.
 21932                                  
 21933 00002A57 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21934 00002A5D 7505                    	jne	short NOECHOPUSH
 21935 00002A5F 26D026[A001]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 21936                                  NOECHOPUSH:
 21937 00002A64 26FE06[1802]            	inc	byte [es:PipeFlag]
 21938 00002A69 E87AFB                  	call	scanoff
 21939 00002A6C 3C0D                    	cmp	al,0Dh
 21940 00002A6E 7404                    	je	short PIPEERRSYNJ5
 21941                                  	; 26/02/2023
 21942 00002A70 3C7C                    	cmp	al,'|' ; 7Ch
 21943                                  	;cmp	al,ALTPIPECHR ; 7Ch
 21944                                  	;je	short PIPEERRSYNJ5
 21945                                  	;; MSDOS 6.0
 21946                                  	;cmp	al,'|' ; 7Ch
 21947                                  	;;cmp	al,vbar ; 7Ch
 21948                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 21949 00002A72 751C                    	jne	short CONTPRESCAN
 21950                                  
 21951                                  PIPEERRSYNJ5:
 21952 00002A74 06                      	push	es
 21953 00002A75 1F                      	pop	ds
 21954 00002A76 E9A502                  	jmp	PIPEERRSYN
 21955                                  
 21956                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 21957                                  ; than just a : in the redir string.
 21958                                  
 21959                                  GOTRESTR:
 21960 00002A79 86E0                    	xchg	ah,al
 21961 00002A7B B03A                    	mov	al,':' ; 3Ah
 21962 00002A7D 29FB                    	sub	bx,di		; compute negative of number of chars
 21963 00002A7F 83FBFF                  	cmp	bx,-1		; is there just a :?
 21964 00002A82 7407                    	je	short NOTRAILCOL ; yep, don't change
 21965 00002A84 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 21966 00002A88 7501                    	jne	short NOTRAILCOL
 21967 00002A8A 4F                      	dec	di		; Back up over trailing ':'
 21968                                  NOTRAILCOL:
 21969 00002A8B 30C0                    	xor	al,al
 21970 00002A8D AA                      	stosb			; NUL terminate the string
 21971 00002A8E 07                      	pop	es
 21972 00002A8F 5F                      	pop	di		; Remember the start
 21973                                  CONTPRESCAN:
 21974 00002A90 8825                    	mov	[di],ah		; "delete" the redirection string
 21975 00002A92 47                      	inc	di
 21976 00002A93 80FC0D                  	cmp	ah,0Dh
 21977 00002A96 7405                    	je	short PRESCANEND
 21978 00002A98 FEC1                    	inc	cl
 21979 00002A9A E90BFF                  	jmp	PRESCANLP
 21980                                  PRESCANEND:
 21981 00002A9D 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21982 00002AA3 7414                    	jz	short ISNOPIPE
 21983                                  
 21984                                  	; 26/02/2023
 21985                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 21986                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 21987                                  	;;			; (EndInit+160]
 21988                                  	;mov	di,offset RESGROUP:PIPESTR
 21989 00002AA5 BF[BA02]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 21990                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 21991                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 21992 00002AA8 26893E[B802]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 21993                                  	
 21994 00002AAD BE[2189]                	mov	si,COMBUF+2
 21995 00002AB0 E833FB                  	call	scanoff
 21996                                  PIPESETLP:			; Transfer the pipe into the resident
 21997 00002AB3 AC                      	lodsb			; pipe buffer
 21998 00002AB4 AA                      	stosb
 21999 00002AB5 3C0D                    	cmp	al,0Dh
 22000 00002AB7 75FA                    	jnz	short PIPESETLP
 22001                                  ISNOPIPE:
 22002 00002AB9 880E[2089]              	mov	[COMBUF+1],cl
 22003 00002ABD 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 22004 00002AC3 0E                      	push	cs
 22005 00002AC4 07                      	pop	es
 22006 00002AC5 C3                      	retn
 22007                                  
 22008                                  ; =============== S U B	R O U T	I N E =======================================
 22009                                  
 22010                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22011                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 22012                                  cmd_copy:
 22013 00002AC6 BE[2189]                	mov	si,COMBUF+2
 22014 00002AC9 E81AFB                  	call	scanoff		; advance past separators...
 22015 00002ACC 0336[1F8C]              	add	si,[PathPos]
 22016 00002AD0 BF8100                  	mov	di,81h
 22017 00002AD3 31C9                    	xor	cx,cx
 22018                                  cmdcopy:
 22019 00002AD5 AC                      	lodsb
 22020 00002AD6 AA                      	stosb
 22021 00002AD7 3C0D                    	cmp	al,0Dh
 22022 00002AD9 7403                    	je	short copy_done
 22023 00002ADB 41                      	inc	cx
 22024 00002ADC EBF7                    	jmp	short cmdcopy
 22025                                  copy_done:
 22026 00002ADE 880E8000                	mov	[80h],cl
 22027 00002AE2 C3                      	retn
 22028                                  
 22029                                  ; =============== S U B	R O U T	I N E =======================================
 22030                                  
 22031                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22032                                  test_append:
 22033 00002AE3 BB[1F89]                	mov	bx,COMBUF	; barry can address
 22034 00002AE6 BE[4A8B]                	mov	si,IDLEN	; address command name, DS already set 	
 22035 00002AE9 BAFFFF                  	mov	dx,-1
 22036 00002AEC B800AE                  	mov	ax,0AE00h
 22037 00002AEF CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 22038                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 22039                                  			; DX = FFFFh,[BX -> command line
 22040                                  			; Return: AL = FFh if this command is a TSR extension 
 22041                                  			;		   to COMMAND.COM
 22042                                  			; AL = 00h if the command should be executed as	usual
 22043                                  	;cmp	al,0
 22044 00002AF1 08C0                    	or	al,al ; 25/02/2023
 22045 00002AF3 C3                      	retn
 22046                                  
 22047                                  	; 25/02/2023
 22048                                  	; INT 2Fh
 22049                                  	; 	AX = AE00h
 22050                                  	; entry:
 22051                                  	; 	DX = magic value FFFFh
 22052                                  	; 	CH = FFh
 22053                                  	; 	CL = length of command line tail
 22054                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22055                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22056                                  	; return:
 22057                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 22058                                  	;	AL = 00h if the command should be executed as usual
 22059                                  	;
 22060                                  	; Format of COMMAND.COM command line buffer:
 22061                                  	;	Offset  Size    Description
 22062                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22063                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22064                                  	;	N BYTEs command line text, terminated by 0Dh
 22065                                  	;
 22066                                  	; Format of command name buffer:
 22067                                  	;	Offset  Size    Description
 22068                                  	;	00h     BYTE    length of command name
 22069                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22070                                  
 22071                                  ;============================================================================
 22072                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 22073                                  ;============================================================================
 22074                                  ; 05/10/2018 - Retro DOS v3.0
 22075                                  
 22076                                  ;	More misc routines
 22077                                  
 22078                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 22079                                  
 22080                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22081                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 22082                                  
 22083                                  ; =============== S U B	R O U T	I N E =======================================
 22084                                  
 22085                                  SETPATH:
 22086                                  
 22087                                  ; ENTRY PathPos = ptr to string
 22088                                  ;       PathCnt = length of string
 22089                                  ;
 22090                                  ; EXIT  PathPos = ptr to string after pathname
 22091                                  ;       PathCnt = length of rest of string
 22092                                  ;       DX = ptr to pathname in string, made ASCIIZ
 22093                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 22094                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 22095                                  ;
 22096                                  ;       A null character is dropped at the end of the pathname. If the
 22097                                  ;       character in that spot previously was CR, it is copied into the
 22098                                  ;       following byte. So there must be at least two two character 
 22099                                  ;       positions in the buffer following the pathname.
 22100                                  
 22101                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22102                                  	; MSDOS 6.0
 22103 00002AF4 A1[1D8C]                	mov	ax,[PathCnt]	;AC000; get length of string
 22104 00002AF7 8B36[1F8C]              	mov	si,[PathPos]	;AC000; get start of source buffer
 22105                                  
 22106                                  	; 26/02/2023
 22107                                  	; MSDOS 3.3
 22108                                  	;mov	si,80h
 22109                                  	;lodsb
 22110                                  	;xor	ah,ah
 22111                                  	;mov	[PATCNT],ax
 22112                                  	;mov	[PATHPOS],si
 22113                                  GETPATH:
 22114                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22115 00002AFB C606[CB8C]00            	mov	byte [DestInfo],0
 22116 00002B00 C606[C78C]00            	mov	byte [DestIsDir],0
 22117 00002B05 8B36[1F8C]              	mov	si,[PathPos]	; SI = ptr to string
 22118 00002B09 8B0E[1D8C]              	mov	cx,[PathCnt]	; CX = string length
 22119 00002B0D 89F2                    	mov	dx,si		; DX = ptr to string
 22120 00002B0F E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 22121 00002B11 51                      	push	cx		; save string length
 22122 00002B12 56                      	push	si		; save ptr to string
 22123 00002B13 E86EFC                  	call	SWITCH
 22124                                  
 22125                                  ;       After Switch, SI has been scanned past any switches, and
 22126                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22127                                  
 22128 00002B16 A3[218C]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22129 00002B19 5B                      	pop	bx		; BX = ptr to original string
 22130 00002B1A 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22131 00002B1C 59                      	pop	cx		; CX = string length
 22132 00002B1D 01D9                    	add	cx,bx		; CX = string length from current SI
 22133 00002B1F 89F2                    	mov	dx,si		; DX = ptr to current string
 22134                                  SKIPPATH:
 22135                                  	; 26/02/2023
 22136                                  	; MSDOS 6.0
 22137 00002B21 C606[4E8E]00            	mov	byte [KPARSE],0
 22138                                  SKIPPATH2:
 22139 00002B26 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22140 00002B28 49                      	dec	cx		; CX = length left after next char
 22141 00002B29 AC                      	lodsb			; AL = next char of string
 22142                                  				; SI = ptr to char after this one
 22143                                  	; 26/02/2023
 22144 00002B2A E897F8                  	call	testkanj
 22145 00002B2D 7408                    	jz	short TESTPPSEP
 22146 00002B2F 49                      	dec	cx
 22147 00002B30 46                      	inc	si
 22148 00002B31 FE06[4E8E]              	inc	byte [KPARSE]
 22149 00002B35 EBEF                    	jmp	short SKIPPATH2
 22150                                  TESTPPSEP:
 22151 00002B37 E83AFB                  	call	pathchrcmp	; compare AL to path delimiter char
 22152 00002B3A 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22153 00002B3C FE06[C78C]              	inc	byte [DestIsDir]
 22154                                  				; DestIsDir = 1, signalling path char
 22155                                  TESTPMETA:
 22156 00002B40 3C3F                    	cmp	al,'?'
 22157 00002B42 7505                    	jne	short TESTPSTAR	; char is not '?'
 22158 00002B44 800E[CB8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22159                                  TESTPSTAR:
 22160 00002B49 3C2A                    	cmp	al,'*'
 22161                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22162 00002B4B 7505                    	jne	short TESTPDELIM ; char is not '*'
 22163 00002B4D 800E[CB8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22164                                  TESTPDELIM:
 22165 00002B52 E899FA                  	call	DELIM		; compare AL to all delimiters
 22166 00002B55 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22167 00002B57 3A06[C48A]              	cmp	al,[SWITCHAR]
 22168 00002B5B 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22169                                  PATHDONEDEC:
 22170 00002B5D 4E                      	dec	si		; SI = ptr to char after pathname
 22171                                  PATHDONE:
 22172 00002B5E 30C0                    	xor	al,al		; AL = NULL
 22173 00002B60 8604                    	xchg	al,[si]		; place NULL after pathname
 22174 00002B62 46                      	inc	si		; SI = ptr to byte after NULL
 22175 00002B63 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22176 00002B65 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22177 00002B67 8804                    	mov	[si],al		; save EOL after NULL
 22178                                  NOPSTORE:
 22179 00002B69 8936[1F8C]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22180 00002B6D 890E[1D8C]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22181                                  SETPATH_RETN:
 22182 00002B71 C3                      	retn
 22183                                  
 22184                                  ; ---------------------------------------------------------------------------
 22185                                  
 22186                                  PGETARG:
 22187 00002B72 BE8000                  	mov	si,80h
 22188 00002B75 AC                      	lodsb
 22189 00002B76 08C0                    	or	al,al
 22190 00002B78 74F7                    	jz	short SETPATH_RETN
 22191 00002B7A E80300                  	call	PSCANOFF
 22192 00002B7D 3C0D                    	cmp	al,0Dh
 22193 00002B7F C3                      	retn
 22194                                  
 22195                                  ; ---------------------------------------------------------------------------
 22196                                  
 22197                                  PSCANOFF:
 22198 00002B80 AC                      	lodsb
 22199 00002B81 E86AFA                  	call	DELIM
 22200 00002B84 7504                    	jnz	short PSCANOFFD
 22201 00002B86 3C3B                    	cmp	al,';' ; 3Bh
 22202 00002B88 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22203                                  PSCANOFFD:
 22204 00002B8A 4E                      	dec	si		; Point to first non-delimiter
 22205 00002B8B C3                      	retn
 22206                                  
 22207                                  ; =============== S U B	R O U T	I N E =======================================
 22208                                  
 22209                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22210                                  IOSET:
 22211                                  	; ALL REGISTERS PRESERVED
 22212 00002B8C 1E                      	push	ds
 22213 00002B8D 52                      	push	dx
 22214 00002B8E 50                      	push	ax
 22215 00002B8F 53                      	push	bx
 22216 00002B90 51                      	push	cx
 22217 00002B91 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 22218 00002B96 803E[1802]00            	cmp	byte [PipeFlag],0
 22219 00002B9B 750D                    	jne	short NOREDIR
 22220 00002B9D F606[AB01]FF            	test	byte [IfFlag],0FFh
 22221 00002BA2 7506                    	jnz	short NOREDIR
 22222 00002BA4 E88E00                  	call	TESTDOREIN
 22223 00002BA7 E80600                  	call	TESTDOREOUT
 22224                                  NOREDIR:
 22225 00002BAA 59                      	pop	cx
 22226 00002BAB 5B                      	pop	bx
 22227 00002BAC 58                      	pop	ax
 22228 00002BAD 5A                      	pop	dx
 22229 00002BAE 1F                      	pop	ds
 22230 00002BAF C3                      	retn
 22231                                  
 22232                                  ; =============== S U B	R O U T	I N E =======================================
 22233                                  
 22234                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22235                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22236                                  TESTDOREOUT:
 22237 00002BB0 803E[C701]00            	cmp	byte [Re_OutStr],0
 22238                                  	;je	short NOREOUT  ; MSDOS 3.3
 22239                                  	; 26/02/2023
 22240 00002BB5 7502                    	jne	short REOUTEXISTS
 22241 00002BB7 EB7B                    	jmp	NOREOUT 
 22242                                  REOUTEXISTS:
 22243 00002BB9 803E[C601]00            	cmp	byte [Re_Out_App],0
 22244 00002BBE 745D                    	je	short REOUTCRT
 22245                                  
 22246 00002BC0 BA[C701]                	mov	dx,Re_OutStr
 22247                                  
 22248                                  	; 26/02/2023
 22249                                  	; MSDOS 6.0
 22250                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22251 00002BC3 B8023D                  	mov	ax,3D02h
 22252                                  	; MSDOS 3.3
 22253                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22254                                  	
 22255                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22256 00002BC6 50                      	push	ax
 22257 00002BC7 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22258                                  			; DS:DX	-> ASCIZ filename
 22259                                  			; AL = access mode
 22260                                  			; 1 - write
 22261 00002BC9 5B                      	pop	bx
 22262 00002BCA 724B                    	jc	short OpenWriteError
 22263                                  
 22264                                  	; 26/02/2023
 22265                                  	; MSDOS 6.0
 22266 00002BCC 89C3                    	mov	bx,ax
 22267                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22268 00002BCE B80044                  	mov	ax,4400h
 22269 00002BD1 CD21                    	int	21h			;AN035;
 22270                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22271                                  			; BX = file or device handle
 22272 00002BD3 F6C280                  	test	dl,80h
 22273                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22274 00002BD6 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22275                                  	
 22276                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22277 00002BD8 B80242                  	mov	ax,4202h
 22278 00002BDB B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22279 00002BDE 89CA                    	mov	dx,cx			;AC011;
 22280 00002BE0 CD21                    	int	21h
 22281                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22282                                  			; AL = method: offset from end of file
 22283 00002BE2 0E                      	push	cs			;AN011; Get transient seg to DS
 22284 00002BE3 1F                      	pop	ds			;AN011;
 22285                                  	
 22286                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22287 00002BE4 B8003F                  	mov	ax,3F00h
 22288 00002BE7 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22289 00002BEA BA[BF8C]                	mov	dx,One_Char_Val		;AN011;
 22290 00002BED CD21                    	int	21h			;AN011;
 22291                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22292                                  			; BX = file handle, CX = number of bytes to read
 22293                                  			; DS:DX -> buffer
 22294 00002BEF 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22295 00002BF1 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22296 00002BF3 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22297                                  	
 22298 00002BF5 803E[BF8C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22299 00002BFA 8E1E[C08A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22300 00002BFE 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22301                                  	
 22302                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22303 00002C00 B80142                  	mov	ax,4201h
 22304 00002C03 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22305                                  setreout_p:	; 26/02/2023
 22306 00002C06 89CA                    	mov	dx,cx			;AN011;
 22307 00002C08 CD21                    	int	21h			;AN011;
 22308 00002C0A EB20                    	jmp	short SET_REOUT
 22309                                  reout_0_length: 			;AN017; We have a 0 length file
 22310                                  	; ds = cs ; 26/02/2023
 22311                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22312                                  					;AN017; Get resident segment back
 22313                                  	; 26/02/2023
 22314 00002C0C 8E1E[C08A]              	mov	ds,[RESSEG]
 22315                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22316 00002C10 B80042                  	mov	ax,4200h
 22317 00002C13 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22318                                  	;mov	dx,cx			;AN017;
 22319                                  	;int	21h			;AN017;
 22320                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22321                                  	; 26/02/2023
 22322 00002C15 EBEF                    	jmp	short setreout_p
 22323                                  
 22324                                  	; 26/02/2023
 22325                                  	; MSDOS 3.3
 22326                                  	;xor	dx,dx
 22327                                  	;xor	cx,cx
 22328                                  	;mov	bx,ax
 22329                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22330                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22331                                  	;		; AL = method: offset from end of file
 22332                                  	;jmp	short SET_REOUT
 22333                                  		
 22334                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22335                                  OpenWriteError:	
 22336                                  	;cmp	ax,5
 22337 00002C17 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22338 00002C1A F9                      	stc
 22339                                  	;;je	short REDIRERR ; MSDOS 3.3
 22340                                  	; 26/02/2023
 22341                                  	;jnz	short REOUTCRT
 22342                                  	;jmp	REDIRERR
 22343 00002C1B 743B                    	je	short REDIRERR
 22344                                  
 22345                                  REOUTCRT:	
 22346 00002C1D BA[C701]                	mov	dx,Re_OutStr
 22347 00002C20 31C9                    	xor	cx,cx
 22348                                  	;mov	ah,CREAT ; 3Ch
 22349 00002C22 B43C                    	mov	ah,3Ch
 22350 00002C24 50                      	push	ax
 22351 00002C25 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22352                                  			; CX = attributes for file
 22353                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22354 00002C27 5B                      	pop	bx
 22355                                  	;jc	short REDIRERR ; MSDOS 3.3
 22356                                  	; 26/02/2023
 22357                                  	;jnc	short NOREDIRERR
 22358                                  	;jmp	REDIRERR
 22359 00002C28 722E                    	jc	short REDIRERR
 22360                                  	
 22361                                  NOREDIRERR:
 22362 00002C2A 89C3                    	mov	bx,ax
 22363                                  SET_REOUT:
 22364                                  
 22365                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22366                                  ; spot. We invalidate the new JFN we got.
 22367                                  
 22368 00002C2C B0FF                    	mov	al,0FFh
 22369                                  	;xchg	al,[bx+18h]
 22370 00002C2E 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22371 00002C31 A21900                  	mov	[PDB.JFN_TABLE+1],al
 22372                                  NOREOUT:
 22373                                  IOSET_RETN:	; 17/04/2023
 22374 00002C34 C3                      	retn
 22375                                  
 22376                                  ; =============== S U B	R O U T	I N E =======================================
 22377                                  
 22378                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22379                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22380                                  TESTDOREIN:
 22381 00002C35 2E803E[6B8A]00          	cmp	byte [cs:RE_INSTR],0
 22382 00002C3B 74F7                    	jz	short IOSET_RETN
 22383 00002C3D 1E                      	push	ds
 22384 00002C3E 0E                      	push	cs
 22385 00002C3F 1F                      	pop	ds
 22386 00002C40 BA[6B8A]                	mov	dx,RE_INSTR
 22387                                  	;mov	ax,OPEN*256 ; 3D00h
 22388 00002C43 B8003D                  	mov	ax,3D00h
 22389 00002C46 89C3                    	mov	bx,ax
 22390 00002C48 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22391                                  			; DS:DX	-> ASCIZ filename
 22392                                  			; AL = access mode
 22393                                  			; 0 - read
 22394 00002C4A 1F                      	pop	ds
 22395                                  
 22396 00002C4B 720B                    	jc	short REDIRERR
 22397                                  
 22398 00002C4D 89C3                    	mov	bx,ax
 22399 00002C4F B0FF                    	mov	al,0FFh
 22400                                  
 22401                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22402                                  ; spot. We invalidate the new JFN we got.
 22403                                  
 22404                                  	;xchg	al,[bx+18h]
 22405 00002C51 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22406 00002C54 A21800                  	mov	[PDB.JFN_TABLE],al
 22407 00002C57 C3                      	retn
 22408                                  
 22409                                  ; ---------------------------------------------------------------------------
 22410                                  
 22411                                  ; We had some kind of error on the redirection. Figure out what the
 22412                                  ; appropriate message should be; BX has the system call that failed
 22413                                  
 22414                                  REDIRERR:
 22415 00002C58 0E                      	push	cs
 22416 00002C59 1F                      	pop	ds
 22417 00002C5A E82E00                  	call	TriageError  ; MSDOS 6.0
 22418                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22419                                  
 22420                                  ; At this point, we have recognized the network-generated access denied error.
 22421                                  ; The correct message is in DX
 22422                                  
 22423 00002C5D 83F841                  	cmp	ax,65
 22424 00002C60 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22425 00002C62 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22426 00002C65 7406                    	je	short OpenError
 22427 00002C67 BA[6F7F]                	mov	dx,FULLDIR_PTR
 22428                                  _CERRORJ:
 22429 00002C6A E9EDFC                  	jmp	cerror
 22430                                  
 22431                                  OpenError:
 22432                                  ; The system call was an OPEN. Report either file not found or path not found.
 22433                                  
 22434                                  	; 26/02/2023
 22435                                  	; MSDOS 6.0
 22436                                  	;mov	byte [cs:msg_disp_class],1
 22437 00002C6D 2EC606[537F]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22438                                  				;AN000; set up extended error msg class
 22439 00002C73 BA[557F]                	mov	dx,extend_buf_ptr
 22440                                  				;AC000; get extended message pointer
 22441 00002C76 2EA3[557F]              	mov	[cs:extend_buf_ptr],ax
 22442                                  				;AN000; get message number in control block
 22443 00002C7A E9DDFC                  	jmp	cerror
 22444                                  
 22445                                  	; 26/02/2023
 22446                                  	; MSDOS 3.3
 22447                                  	;mov	dx,FNOTFOUNDPTR
 22448                                  	;;cmp	ax,2
 22449                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22450                                  	;je	short _CERRORJ
 22451                                  	;mov	dx,ACCDENPTR
 22452                                  	;;cmp	ax,5 ; Access denied error
 22453                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22454                                  	;je	short _CERRORJ
 22455                                  	;	; ERROR_PATH_NOT_FOUND
 22456                                  	;mov	dx,PNOTFOUNDPTR
 22457                                  	;jmp	CERROR
 22458                                  
 22459                                  ; =============== S U B	R O U T	I N E =======================================
 22460                                  
 22461                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22462                                  ; registers
 22463                                  
 22464                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22465                                  dstrlen:
 22466 00002C7D 50                      	push	ax
 22467 00002C7E 31C9                    	xor	cx,cx
 22468 00002C80 FC                      	cld
 22469                                  dloop:
 22470 00002C81 AC                      	lodsb
 22471 00002C82 41                      	inc	cx
 22472 00002C83 08C0                    	or	al,al
 22473 00002C85 75FA                    	jnz	short dloop
 22474 00002C87 29CE                    	sub	si,cx
 22475 00002C89 58                      	pop	ax
 22476                                  TRIAGEERR_RETN:
 22477 00002C8A C3                      	retn
 22478                                  
 22479                                  ; =============== S U B	R O U T	I N E =======================================
 22480                                  
 22481                                  ;Break	<Extended error support>
 22482                                  
 22483                                  TriageError:  ; MSDOS 6.0
 22484                                  
 22485                                  ; TriageError will examine the return from a carry-set system call and
 22486                                  ; return the correct error if applicable.
 22487                                  ;
 22488                                  ;   Inputs:	outputs from a carry-settable system call
 22489                                  ;		No system calls may be done in the interrim
 22490                                  ;   Outputs:	If carry was set on input
 22491                                  ;		   carry set on output
 22492                                  ;		   DX contains trangroup offset to printf message
 22493                                  ;		else
 22494                                  ;		   No registers changed
 22495                                  
 22496                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22497                                  
 22498                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22499                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22500                                  
 22501                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22502 00002C8B 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22503 00002C8D 9C                      	pushf
 22504 00002C8E 53                      	push	bx
 22505 00002C8F 51                      	push	cx
 22506 00002C90 56                      	push	si
 22507 00002C91 57                      	push	di
 22508 00002C92 55                      	push	bp
 22509 00002C93 06                      	push	es
 22510 00002C94 1E                      	push	ds
 22511 00002C95 50                      	push	ax
 22512 00002C96 52                      	push	dx
 22513 00002C97 B459                    	mov	ah,59h
 22514                                  	;mov	ah,GETEXTENDEDERROR
 22515 00002C99 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22516                                  			; BX = version code (0000h for DOS 3.x)
 22517 00002C9B 59                      	pop	cx
 22518 00002C9C 5B                      	pop	bx		; restore original AX
 22519 00002C9D BA[7B7F]                	mov	dx,ACCDEN_PTR
 22520 00002CA0 83F841                  	cmp	ax,65		; network access denied?
 22521 00002CA3 7404                    	je	short NoMove	; Yes, return it.
 22522 00002CA5 89D8                    	mov	ax,bx
 22523 00002CA7 89CA                    	mov	dx,cx
 22524                                  NoMove:
 22525 00002CA9 1F                      	pop	ds
 22526 00002CAA 07                      	pop	es
 22527 00002CAB 5D                      	pop	bp
 22528 00002CAC 5F                      	pop	di
 22529 00002CAD 5E                      	pop	si
 22530 00002CAE 59                      	pop	cx
 22531 00002CAF 5B                      	pop	bx
 22532 00002CB0 9D                      	popf
 22533 00002CB1 C3                      	retn
 22534                                  
 22535                                  ; =============== S U B	R O U T	I N E =======================================
 22536                                  
 22537                                  	; Far call from resident portion/segment of COMMAND.COM
 22538                                  
 22539                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22540                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22541                                  
 22542                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22543                                  Triage_Init:
 22544 00002CB2 E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22545                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22546 00002CB5 CB                      	retf
 22547                                  
 22548                                  ; =============== S U B	R O U T	I N E =======================================
 22549                                  
 22550                                  ; MSDOS 6.0
 22551                                  
 22552                                  ; ****************************************************************
 22553                                  ; *
 22554                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22555                                  ; *
 22556                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22557                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22558                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22559                                  ; *
 22560                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22561                                  ; *		 ES    points to TRANGROUP
 22562                                  ; *
 22563                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22564                                  ; *		 PATHCNT set to length of string
 22565                                  ; *		 PATHPOS set to start of SRCBUF
 22566                                  ; *		 CX,AX	 changed
 22567                                  ; *
 22568                                  ; ****************************************************************
 22569                                  
 22570                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22571                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22572                                  Move_To_SrcBuf:
 22573 00002CB6 56                      	push	si			;AN000;  save si,di
 22574 00002CB7 57                      	push	di			;AN000;
 22575 00002CB8 51                      	push	cx			;AN000;
 22576 00002CB9 BF[2F8D]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22577 00002CBC 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22578 00002CBE 89C8                    	mov	ax,cx			;AN000; clear ax
 22579 00002CC0 57                      	push	di			;AN000; save start of srcbuf
 22580 00002CC1 AC                      	lodsb				;AN000; get a character from DS:SI
 22581                                  mts_get_chars:				;AN000;
 22582                                  	;cmp	al,0			;AN000; was it a null char?
 22583 00002CC2 20C0                    	and 	al,al ; al = 0 ?
 22584 00002CC4 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22585 00002CC6 AA                      	stosb				;AN000; no - store it in srcbuf
 22586 00002CC7 41                      	inc	cx			;AN000; increment length count
 22587 00002CC8 AC                      	lodsb				;AN000; get a character from DS:SI
 22588 00002CC9 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22589                                  mts_end_string: 			;AN000; we've reached the end of line
 22590                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22591 00002CCB B00D                    	mov	al,0Dh
 22592 00002CCD AA                      	stosb				;AN000;
 22593 00002CCE 5F                      	pop	di			;AN000; restore start of srcbuf
 22594 00002CCF 0E                      	push	cs			;AN000; set DS to local segment
 22595 00002CD0 1F                      	pop	ds			;AN000;
 22596 00002CD1 890E[1D8C]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22597 00002CD5 893E[1F8C]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22598 00002CD9 59                      	pop	cx			;AN000; restore cx,di,si
 22599 00002CDA 5F                      	pop	di			;AN000;
 22600 00002CDB 5E                      	pop	si			;AN000;
 22601 00002CDC C3                      	retn				;AN000; exit
 22602                                  
 22603                                  ;============================================================================
 22604                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22605                                  ;============================================================================
 22606                                  ; 03/10/2018 - Retro DOS v3.0
 22607                                  
 22608                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22609                                  
 22610                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22611                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22612                                  
 22613                                  ; =============== S U B	R O U T	I N E =======================================
 22614                                  
 22615                                  	; 26/02/2023
 22616                                  SINGLETEST:
 22617 00002CDD 1E                      	push	ds
 22618 00002CDE 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 22619 00002CE3 833E[A601]00            	cmp	word [SingleCom],0
 22620 00002CE8 7406                    	jz	short TESTDONE
 22621 00002CEA 813E[A601]FFEF          	cmp	word [SingleCom],0EFFFh
 22622                                  TESTDONE:
 22623 00002CF0 1F                      	pop	ds
 22624 00002CF1 C3                      	retn
 22625                                  
 22626                                  ; =============== S U B	R O U T	I N E =======================================
 22627                                  
 22628                                  	; 26/02/2023
 22629                                  SetRest1:
 22630 00002CF2 B001                    	mov	al,1
 22631                                  
 22632                                  ; ---------------------------------------------------------------------------
 22633                                  
 22634                                  SETREST:
 22635 00002CF4 1E                      	push	ds
 22636 00002CF5 8E1E[C08A]              	mov	ds,[RESSEG]
 22637 00002CF9 A2[A401]                	mov	[RestDir],al
 22638 00002CFC 1F                      	pop	ds
 22639 00002CFD C3                      	retn
 22640                                  
 22641                                  ; =============== S U B	R O U T	I N E =======================================
 22642                                  
 22643                                  ; Note that we need to handle the same thing that RestDir handles: the
 22644                                  ; requirement that we try only once to restore the user's environment after
 22645                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22646                                  ; disappear, we just give up.
 22647                                  
 22648                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22649                                  PIPEDEL:
 22650 00002CFE 1E                      	push	ds
 22651 00002CFF 52                      	push	dx
 22652 00002D00 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 22653                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22654                                  			; Pipe1 = offset RESGROUP:EndInit
 22655 00002D05 BA[1A02]                	mov	dx,Pipe1	; Clean up in case ^C
 22656                                  	;mov	ah,Unlink ; 41h 
 22657 00002D08 B441                    	mov	ah,41h
 22658 00002D0A CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22659                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22660                                  			;		(no wildcards allowed)
 22661                                  
 22662                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22663                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22664 00002D0C BA[6902]                	mov	dx,Pipe2
 22665                                  	;mov	ah,Unlink ; 41h
 22666 00002D0F B441                    	mov	ah,41h
 22667 00002D11 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22668                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22669                                  			;		(no wildcards allowed)
 22670 00002D13 5A                      	pop	dx
 22671 00002D14 E86E02                  	call	PipeOff
 22672 00002D17 C606[1902]00            	mov	byte [PipeFiles],0
 22673 00002D1C 1F                      	pop	ds
 22674 00002D1D C3                      	retn
 22675                                  
 22676                                  ; ---------------------------------------------------------------------------
 22677                                  
 22678                                  	; 26/02/2023
 22679                                  PIPEERRSYN:
 22680 00002D1E BA[ED7F]                	mov	dx,SYNTMES_PTR
 22681 00002D21 E8DAFF                  	call	PIPEDEL
 22682 00002D24 0E                      	push	cs
 22683 00002D25 1F                      	pop	ds
 22684 00002D26 E931FC                  	jmp	cerror
 22685                                  
 22686                                  ; ---------------------------------------------------------------------------
 22687                                  
 22688                                  	; 26/02/2023
 22689                                  PIPERR:
 22690 00002D29 9C                      	pushf
 22691 00002D2A E85EFF                  	call    TriageError
 22692                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22693 00002D2D 50                      	push	ax		; Save results from TriageError
 22694 00002D2E 52                      	push	dx
 22695 00002D2F BA[B680]                	mov	dx,PIPEEMES_PTR
 22696 00002D32 E8C9FF                  	call	PIPEDEL
 22697 00002D35 0E                      	push	cs
 22698 00002D36 1F                      	pop	ds
 22699 00002D37 E8E120                  	call	std_eprintf
 22700 00002D3A 5A                      	pop	dx		; Restore results from TriageError
 22701 00002D3B 58                      	pop	ax
 22702 00002D3C 9D                      	popf
 22703 00002D3D 83F841                  	cmp	ax,65
 22704 00002D40 7503                    	jne	short TCOMMANDJ
 22705 00002D42 E915FC                  	jmp	cerror
 22706                                  
 22707                                  TCOMMANDJ:
 22708 00002D45 E9BCD3                  	jmp	TCOMMAND
 22709                                  
 22710                                  ; ---------------------------------------------------------------------------
 22711                                  
 22712                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22713                                  PIPEPROCSTRT:
 22714 00002D48 8E1E[C08A]              	mov	ds,[RESSEG]
 22715 00002D4C FE06[1902]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22716                                  
 22717                                  	; MSDOS 6.0
 22718 00002D50 06                      	push	es
 22719 00002D51 57                      	push	di
 22720 00002D52 1E                      	push	ds
 22721 00002D53 56                      	push	si
 22722                                  	
 22723 00002D54 1E                      	push	ds
 22724 00002D55 06                      	push	es
 22725 00002D56 1F                      	pop	ds			;ds = TRANGROUP
 22726 00002D57 BE[0586]                	mov	si,TempVarName		;ds:si = "TEMP="
 22727                                  
 22728                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22729                                  ;so the routine is not really general
 22730                                  
 22731 00002D5A E8BDF5                  	call	find_name_in_environment
 22732                                  					;es:di points at path
 22733 00002D5D 1F                      	pop	ds			;ds = DATARES again
 22734 00002D5E 721F                    	jc	short no_temp_path
 22735                                  	
 22736 00002D60 1E                      	push	ds
 22737 00002D61 06                      	push	es
 22738 00002D62 1F                      	pop	ds
 22739 00002D63 07                      	pop	es			;swap ds and es
 22740 00002D64 89FE                    	mov	si,di			;ds:si points at path
 22741                                  	
 22742 00002D66 E8B602                  	call	skip_white		;skip white space chars
 22743                                  
 22744                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22745                                  
 22746 00002D69 E8BF02                  	call	copy_pipe_path		;copy the pipe path
 22747                                  	
 22748                                  ;Check if the TEMP path is valid
 22749                                  
 22750 00002D6C 06                      	push	es
 22751 00002D6D 1F                      	pop	ds			;ds = DATARES
 22752                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 22753                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 22754 00002D6E BA[1A02]                	mov	dx,Pipe1
 22755                                  	;mov	ax,(CHMOD shl 8) or 0
 22756 00002D71 B80043                  	mov	ax,4300h
 22757 00002D74 CD21                    	int	21h
 22758 00002D76 7207                    	jc	short no_temp_path
 22759                                  	
 22760 00002D78 F7C11000                	test	cx,10h			;is it a directory?
 22761 00002D7C 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 22762                                  	
 22763 00002D7E F9                      	stc				;no, indicate fail
 22764                                  no_temp_path:
 22765 00002D7F 5E                      	pop	si
 22766 00002D80 1F                      	pop	ds
 22767 00002D81 5F                      	pop	di
 22768 00002D82 07                      	pop	es
 22769 00002D83 730B                    	jnc	short crt_temp		;path found, create tempfiles
 22770                                  
 22771                                  	; 27/02/2023
 22772                                  	; MSDOS 3.3
 22773                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 22774                                  	;				; Get current drive
 22775                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 22776                                  	;add	al,[cs:CAPITAL_A]
 22777                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 22778                                  	;mov	bx,PIPE1
 22779                                  	;mov	[bx],al
 22780                                  	;xor	ah,ah			; nul terminate path names
 22781                                  	;mov	byte [PIPE1+3],ah
 22782                                  	;mov	byte [PIPE2+3],ah
 22783                                  
 22784                                  	; MSDOS 6.0
 22785                                  ;SR;
 22786                                  ; We want to create temp files in the current directory rather than in the 
 22787                                  ;root of the drive. This is because the number of files that can be present
 22788                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 22789                                  
 22790                                  	;mov	ah,'.'
 22791                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 22792                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 22793                                  	;xor	ah,ah
 22794                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 22795                                  	;mov	[Pipe2+1],ah		;create files in current dir
 22796                                  	; 27/02/2023
 22797 00002D85 B92E00                  	mov	cx,002Eh
 22798 00002D88 890E[1A02]              	mov	[Pipe1],cx
 22799 00002D8C 890E[6902]              	mov	[Pipe2],cx
 22800                                  crt_temp:
 22801                                  	; MSDOS 6.0
 22802                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 22803                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 22804 00002D90 BA[1A02]                	mov	dx,Pipe1
 22805                                  	; MSDOS 3.3
 22806                                  	;mov	dx,bx
 22807                                  	
 22808                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22809 00002D93 31C9                    	xor	cx,cx
 22810                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22811 00002D95 B45A                    	mov	ah,5Ah
 22812 00002D97 CD21                    	int	21h
 22813                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22814                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22815                                  		; receive generated filename
 22816                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22817 00002D99 728E                    	jc	short PIPERR	; Couldn't create
 22818                                  
 22819 00002D9B 89C3                    	mov	bx,ax
 22820                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22821 00002D9D B43E                    	mov	ah,3Eh
 22822 00002D9F CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22823                                  			; BX = file handle
 22824                                  	;;mov	dx,PIPE2
 22825                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 22826 00002DA1 BA[6902]                	mov	dx,Pipe2
 22827                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22828 00002DA4 B45A                    	mov	ah,5Ah
 22829 00002DA6 CD21                    	int	21h
 22830                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22831                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22832                                  		; receive generated filename
 22833                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22834                                  	; 17/04/2023
 22835                                  	;jc	short PIPERR
 22836                                  	; 27/02/2023
 22837 00002DA8 7303                    	jnc	short pps1
 22838 00002DAA E97CFF                  	jmp	PIPERR
 22839                                  pps1:
 22840 00002DAD 89C3                    	mov	bx,ax
 22841 00002DAF B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22842 00002DB1 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22843                                  				; BX = file handle
 22844                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 22845 00002DB3 E87FFE                  	call	TESTDOREIN
 22846 00002DB6 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22847 00002DBA 833E[A601]FF            	cmp	word [SingleCom],-1
 22848 00002DBF 7506                    	jne	short NOSINGP
 22849 00002DC1 C706[A601]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 22850                                  NOSINGP:
 22851 00002DC7 EB29                    	jmp	short FIRSTPIPE
 22852                                  
 22853                                  ; ---------------------------------------------------------------------------
 22854                                  
 22855                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22856                                  PIPEPROC:
 22857 00002DC9 8026[A001]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 22858 00002DCE 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22859 00002DD2 AC                      	lodsb
 22860                                  	; 27/02/2023
 22861 00002DD3 3C7C                    	cmp	al,'|'		
 22862                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 22863                                  	;je	short ISPIPE1	; Yes
 22864                                  	;cmp	al,'|'
 22865                                  	;;cmp	al,[cs:VBAR]
 22866 00002DD5 7403                    	je	short ISPIPE1
 22867 00002DD7 E98400                  	jmp	PIPEEND		; Pipe done
 22868                                  ISPIPE1:
 22869 00002DDA 8B16[3B03]              	mov	dx,[InPipePtr]	; Get the input file name
 22870                                  	;mov	ax,OPEN*256 ; 3D00h
 22871 00002DDE B8003D                  	mov	ax,3D00h
 22872 00002DE1 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22873                                  			; DS:DX	-> ASCIZ filename
 22874                                  			; AL = access mode
 22875                                  			; 0 - read
 22876                                  PIPEERRJ:
 22877 00002DE3 7303                    	jnc	short NO_PIPEERR
 22878 00002DE5 E941FF                  	jmp	PIPERR		; Lost the pipe file
 22879                                  NO_PIPEERR:
 22880 00002DE8 89C3                    	mov	bx,ax
 22881 00002DEA B0FF                    	mov	al,0FFh
 22882                                  	;xchg	al,[bx+18h]
 22883 00002DEC 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22884 00002DEF A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 22885                                  FIRSTPIPE:
 22886 00002DF2 BF[2189]                	mov	di,COMBUF+2
 22887 00002DF5 31C9                    	xor	cx,cx
 22888 00002DF7 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 22889 00002DFA 7503                    	jne	short PIPEOK1
 22890                                  PIPEERRSYNJ:
 22891 00002DFC E91FFF                  	jmp	PIPEERRSYN
 22892                                  PIPEOK1:
 22893                                  	;;;mov	al,[cs:VBAR]
 22894                                  	; 27/02/2023
 22895                                  	;;mov	al,vbar
 22896                                  	;mov	al,'|'
 22897                                  	;cmp	[si],al		; '||'
 22898                                  	;je	short PIPEERRSYNJ
 22899 00002DFF 803C7C                  	cmp	byte [si],'|'
 22900                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 22901 00002E02 74F8                    	je	short PIPEERRSYNJ
 22902                                  PIPECOMLP:
 22903 00002E04 AC                      	lodsb
 22904 00002E05 AA                      	stosb
 22905                                  	; 27/02/2023
 22906 00002E06 E8BBF5                  	call	testkanj
 22907 00002E09 7405                    	jz	short NOTKANJ5
 22908 00002E0B A4                      	movsb
 22909                                  ;  Added following 2 commands to the fix pipe bug.
 22910 00002E0C 41                      	inc	cx		;AN000;  3/3/KK
 22911 00002E0D 41                      	inc	cx		;AN000;  3/3/KK
 22912 00002E0E EBF4                    	jmp	short PIPECOMLP
 22913                                  NOTKANJ5:
 22914 00002E10 3C0D                    	cmp	al,0Dh
 22915 00002E12 7438                    	je	short LASTPIPE
 22916 00002E14 41                      	inc	cx
 22917                                  	; 27/02/2023
 22918 00002E15 3C7C                    	cmp	al,'|'
 22919                                  	;cmp	al,ALTPIPECHR
 22920                                  	;je	short ISPIPE2
 22921                                  	;;cmp	al,[cs:VBAR]
 22922                                  	;cmp	al,vbar
 22923 00002E17 75EB                    	jne	short PIPECOMLP
 22924                                  ISPIPE2:
 22925 00002E19 26C645FF0D              	mov	byte [es:di-1],0Dh
 22926 00002E1E 49                      	dec	cx
 22927                                  	;mov	[cs:COMBUF+1],cl
 22928                                  	; 27/02/2023
 22929 00002E1F 26880E[2089]            	mov	[es:COMBUF+1],cl
 22930 00002E24 4E                      	dec	si
 22931                                  	;mov	[3BEh],si ;  MSDOS 5.0 COMMAND.COM
 22932 00002E25 8936[B802]              	mov	[PipePtr],si		; On to next pipe element
 22933                                  			; mov [EndInit+158], si
 22934 00002E29 8B16[3D03]              	mov	dx,[OutPipePtr]
 22935 00002E2D 51                      	push	cx
 22936 00002E2E 31C9                    	xor	cx,cx
 22937                                  	;mov	ax,CREAT*256 ; 3C00h
 22938 00002E30 B8003C                  	mov	ax,3C00h
 22939 00002E33 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22940                                  			; CX = attributes for file
 22941                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22942 00002E35 59                      	pop	cx
 22943 00002E36 72AB                    	jc	short PIPEERRJ		; Lost the file
 22944 00002E38 89C3                    	mov	bx,ax
 22945 00002E3A B0FF                    	mov	al,0FFh
 22946                                  	;xchg	al,[bx+18h]
 22947 00002E3C 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22948 00002E3F A21900                  	mov	[PDB.JFN_TABLE+1],al
 22949 00002E42 8716[3B03]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 22950 00002E46 8916[3D03]              	mov	[OutPipePtr],dx
 22951 00002E4A EB0D                    	jmp	short PIPECOM
 22952                                  LASTPIPE:
 22953                                  	;mov	[cs:COMBUF+1],cl 
 22954                                  	; 27/02/2023
 22955 00002E4C 26880E[2089]            	mov	[es:COMBUF+1],cl
 22956 00002E51 4E                      	dec	si
 22957                                  	;mov	[3BEh],si ;  MSDOS 5.0 COMMAND.COM
 22958 00002E52 8936[B802]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 22959                                  		; mov [EndInit+158], si
 22960 00002E56 E857FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 22961                                  PIPECOM:
 22962 00002E59 0E                      	push	cs
 22963 00002E5A 1F                      	pop	ds
 22964 00002E5B E984D4                  	jmp	NOPIPEPROC	; Process the pipe element
 22965                                  PIPEEND:
 22966 00002E5E E89DFE                  	call	PIPEDEL
 22967 00002E61 813E[A601]00F0          	cmp	word [SingleCom],0F000h
 22968 00002E67 7506                    	jnz	short NOSINGP2
 22969 00002E69 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 22970                                  NOSINGP2:
 22971 00002E6F E992D2                  	jmp	TCOMMAND
 22972                                  
 22973                                  ; =============== S U B	R O U T	I N E =======================================
 22974                                  
 22975                                  ; Date and time are set during initialization and use
 22976                                  ; this routines since they need to do a long return
 22977                                  
 22978                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22979                                  DATINIT:
 22980 00002E72 2E8C1E[C08A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 22981 00002E77 06                      	push	es
 22982 00002E78 1E                      	push	ds		; Going to use the previous stack
 22983 00002E79 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 22984 00002E7B 8EC0                    	mov	es,ax
 22985 00002E7D 8ED8                    	mov	ds,ax
 22986 00002E7F E88220                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 22987 00002E82 BA[9E95]                	mov	dx,INTERNATVARS
 22988 00002E85 B80038                  	mov	ax,3800h
 22989                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 22990 00002E88 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 22991                                  			; get current-country info
 22992                                  			; DS:DX	-> buffer for returned info
 22993                                  	; 20/10/2018
 22994 00002E8A C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 22995 00002E90 C606[1F89]80            	mov	byte [COMBUF],128 ; Init COMBUF
 22996 00002E95 C706[2089]010D          	mov	word [COMBUF+1],0D01h
 22997 00002E9B E80600                  	call	DATE
 22998 00002E9E E86800                  	call	CTIME
 22999 00002EA1 1F                      	pop	ds
 23000 00002EA2 07                      	pop	es
 23001 00002EA3 CB                      	retf	; far return
 23002                                  
 23003                                  ; =============== S U B	R O U T	I N E =======================================
 23004                                  
 23005                                  ; MSDOS 6.0
 23006                                  
 23007                                  ; ****************************************************************
 23008                                  ; *
 23009                                  ; * ROUTINE:	 DATE - Set system date
 23010                                  ; *
 23011                                  ; * FUNCTION:	 If a date is specified, set the system date,
 23012                                  ; *		 otherwise display the current system date and
 23013                                  ; *		 prompt the user for a new date.  If an invalid
 23014                                  ; *		 date is specified, issue an error message and
 23015                                  ; *		 prompt for a new date.  If the user enters
 23016                                  ; *		 nothing when prompted for a date, terminate.
 23017                                  ; *
 23018                                  ; * INPUT:	 command line at offset 81H
 23019                                  ; *
 23020                                  ; * OUTPUT:	 none
 23021                                  ; *
 23022                                  ; ****************************************************************
 23023                                  
 23024                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23025                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 23026                                  DATE:
 23027 00002EA4 BE8100                  	mov	si,81h			; Accepting argument for date inline
 23028 00002EA7 BF[0B85]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23029 00002EAA 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23030 00002EAC 31D2                    	xor	dx,dx			;AN000;
 23031 00002EAE E89F14                  	call	cmd_parse		;AC000; call parser
 23032                                  	; 27/02/2023
 23033 00002EB1 83F8FF                  	cmp	ax,-1
 23034                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23035 00002EB4 7429                    	je	short PRMTDAT 		;AC000; yes - go ask for date
 23036                                  	;cmp	ax,0
 23037                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23038                                  	;jne	short DATERR		;AN000; yes - go issue message
 23039                                  	; 26/04/2023
 23040 00002EB6 09C0                    	or	ax,ax ; ax = 0 ?
 23041 00002EB8 7544                    	jnz	short DATERR
 23042                                  	;jmp	short COMDAT		;AC000; we have a date
 23043                                  	; 27/02/2023
 23044                                  COMDAT:
 23045 00002EBA 8B0E[FB95]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 23046 00002EBE 8A36[FD95]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 23047 00002EC2 8A16[FE95]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 23048 00002EC6 51                      	push	cx			;AC000; save date
 23049 00002EC7 52                      	push	dx			;AC000;
 23050 00002EC8 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 23051 00002ECB 31D2                    	xor	dx,dx			;AN029;
 23052 00002ECD E88014                  	call	cmd_parse		;AN029; call parser
 23053 00002ED0 3CFF                    	cmp	al,0FFh ; -1
 23054                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23055 00002ED2 5A                      	pop	dx			;AC000; retrieve date
 23056 00002ED3 59                      	pop	cx			;AC000;
 23057 00002ED4 7528                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 23058                                  	; 26/04/2023
 23059                                  	;mov	ah,SET_DATE		;yes - set date
 23060 00002ED6 B42B                    	mov	ah,2Bh
 23061 00002ED8 CD21                    	int	21h
 23062                                  			; DOS - SET CURRENT DATE
 23063                                  			; DL = day, DH = month, CX = year
 23064                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 23065 00002EDA 08C0                    	or	al,al
 23066 00002EDC 7520                    	jnz	short DATERR
 23067                                  date_end:
 23068 00002EDE C3                      	retn
 23069                                  
 23070                                  PRMTDAT:
 23071                                  	; Print "Current date is
 23072                                  
 23073 00002EDF E83208                  	call	GetDate 		;AN000; get date for output
 23074 00002EE2 86F2                    	xchg	dh,dl			;AN000; switch month & day
 23075 00002EE4 890E[0380]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 23076 00002EE8 8916[0580]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 23077 00002EEC BA[F37F]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 23078 00002EEF E8311F                  	call	std_printf
 23079                                  
 23080                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 23081                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 23082                                  
 23083                                  GET_NEW_DATE:				;AN000;
 23084 00002EF2 E8C500                  	call	GETDAT			;AC000; prompt user for date
 23085 00002EF5 83F8FF                  	cmp	ax,0FFFFh ; -1
 23086                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23087 00002EF8 74E4                    	je	short date_end		;AC000; yes - exit
 23088                                  	; 26/04/2023
 23089                                  	;cmp	ax,0
 23090                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23091                                  	;;jnz	short DATERR		;AN000; yes - go issue message
 23092                                  	;; 27/02/2023
 23093                                  	;jz	short COMDAT
 23094                                  	; 26/04/2023
 23095 00002EFA 21C0                    	and	ax,ax ; 0 ?
 23096 00002EFC 74BC                    	jz	short COMDAT
 23097                                  ;COMDAT:
 23098                                  ;	....
 23099                                  DATERR:
 23100 00002EFE E8D8F6                  	call	CRLF2			;AN028; print out a blank line
 23101 00002F01 BA[F07F]                	mov	dx,BADDAT_PTR
 23102 00002F04 E81C1F                  	call	std_printf
 23103 00002F07 EBE9                    	jmp	short GET_NEW_DATE	;AC000; get date again
 23104                                  
 23105                                  ; =============== S U B	R O U T	I N E =======================================
 23106                                  
 23107                                  ; MSDOS 6.0
 23108                                  
 23109                                  ; TIME gets and sets the time
 23110                                  
 23111                                  ; ****************************************************************
 23112                                  ; *
 23113                                  ; * ROUTINE:	 TIME - Set system time
 23114                                  ; *
 23115                                  ; * FUNCTION:	 If a time is specified, set the system time,
 23116                                  ; *		 otherwise display the current system time and
 23117                                  ; *		 prompt the user for a new time.  If an invalid
 23118                                  ; *		 time is specified, issue an error message and
 23119                                  ; *		 prompt for a new time.  If the user enters
 23120                                  ; *		 nothing when prompted for a time, terminate.
 23121                                  ; *
 23122                                  ; * INPUT:	 command line at offset 81H
 23123                                  ; *
 23124                                  ; * OUTPUT:	 none
 23125                                  ; *
 23126                                  ; ****************************************************************
 23127                                  
 23128                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23129                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23130                                  CTIME:
 23131 00002F09 BE8100                  	mov	si,81h			; Accepting argument for time inline
 23132 00002F0C BF[1D85]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23133 00002F0F 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23134 00002F11 31D2                    	xor	dx,dx			;AN000;
 23135 00002F13 E83A14                  	call	cmd_parse		;AC000; call parser
 23136                                  	; 27/02/2023
 23137 00002F16 83F8FF                  	cmp	ax,-1
 23138                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23139 00002F19 742D                    	je	short PRMTTIM 		;AC000; yes - prompt for time
 23140                                  	;cmp	ax,0
 23141                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23142                                  	;jne	short TIMERR		;AN000; yes - go issue message
 23143 00002F1B 21C0                    	and	ax,ax ; ax = 0 ?
 23144 00002F1D 754B                    	jnz	short TIMERR
 23145                                  	;jmp	short COMTIM		;AC000; we have a time
 23146                                  	; 27/02/2023
 23147                                  COMTIM:
 23148 00002F1F 8A2E[0396]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23149 00002F23 8A0E[0496]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23150 00002F27 8A36[0596]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23151 00002F2B 8A16[0696]              	mov	dl,[TIME_FRACTION]	;AC000;
 23152 00002F2F 51                      	push	cx			;AC000; save time
 23153 00002F30 52                      	push	dx			;AC000;
 23154 00002F31 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23155 00002F34 31D2                    	xor	dx,dx			;AN029;
 23156 00002F36 E81714                  	call	cmd_parse		;AN029; call parser
 23157 00002F39 3CFF                    	cmp	al, -1
 23158                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23159 00002F3B 5A                      	pop	dx			;AC000; retieve time
 23160 00002F3C 59                      	pop	cx			;AC000;
 23161 00002F3D 752B                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23162                                  SAVTIM:
 23163                                  	;mov	ah,SET_TIME
 23164 00002F3F B42D                    	mov	ah,2Dh
 23165 00002F41 CD21                    	int	21h
 23166 00002F43 08C0                    	or	al,al
 23167 00002F45 7523                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23168                                  time_end:
 23169 00002F47 C3                      	retn
 23170                                  
 23171                                  PRMTTIM:
 23172                                  	;Printf "Current time is ... "
 23173                                  
 23174                                  	;mov	ah,Get_Time		;AC000; get the current time
 23175 00002F48 B42C                    	mov	ah,2Ch
 23176 00002F4A CD21                    	int	21h			;AC000;   Get time in CX:DX
 23177 00002F4C 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23178 00002F4E 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23179 00002F50 890E[2580]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23180 00002F54 8916[2780]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23181 00002F58 BA[2080]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23182 00002F5B E8C51E                  	call	std_printf
 23183                                  
 23184                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23185                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23186                                  
 23187                                  GET_NEW_TIME:
 23188 00002F5E E8B100                  	call	GETTIM			;AC000;
 23189 00002F61 83F8FF                  	cmp	ax,-1
 23190                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23191 00002F64 74E1                    	je	short time_end		;AC000;
 23192                                  	;cmp	ax,0
 23193                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23194                                  	;jne	short TIMERR		;AN000; yes - go issue message
 23195 00002F66 09C0                    	or	ax,ax  ; ax = 0 ?
 23196                                  	;jnz	short TIMERR
 23197                                  	; 27/02/2023
 23198 00002F68 74B5                    	jz	short COMTIM
 23199                                  ;COMTIM:
 23200                                  ;	....
 23201                                  TIMERR:
 23202 00002F6A E86CF6                  	call	CRLF2			;AN028; print out a blank line
 23203 00002F6D BA[1D80]                	mov	dx,BadTim_Ptr
 23204 00002F70 E8B01E                  	call	std_printf		; Print error message
 23205 00002F73 EBE9                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23206                                  
 23207                                  ; =============== S U B	R O U T	I N E =======================================
 23208                                  
 23209                                  ; MSDOS 6.0
 23210                                  
 23211                                  ; Set the special flag in the INIT flag to the value in CX.
 23212                                  
 23213                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23214                                  SetInitFlag:
 23215 00002F75 8E1E[C08A]              	mov	ds,[RESSEG]
 23216                                  
 23217 00002F79 8026[1702]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23218                                  	;and	byte [InitFlag],0FDh
 23219 00002F7E 080E[1702]              	or	byte [InitFlag],cl
 23220 00002F82 0E                      	push	cs
 23221 00002F83 1F                      	pop	ds
 23222 00002F84 C3                      	retn
 23223                                  
 23224                                  ; =============== S U B	R O U T	I N E =======================================
 23225                                  
 23226                                  ; MSDOS 6.0
 23227                                  
 23228                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23229                                  PipeOff:
 23230 00002F85 1E                      	push	ds
 23231 00002F86 50                      	push	ax
 23232 00002F87 2E8E1E[C08A]            	mov	ds,[cs:RESSEG]
 23233 00002F8C 30C0                    	xor	al,al
 23234 00002F8E 8606[1802]              	xchg	[PipeFlag],al
 23235 00002F92 08C0                    	or	al,al
 23236 00002F94 7404                    	jz	short PipeOffDone
 23237 00002F96 D02E[A001]              	shr	byte [EchoFlag],1
 23238                                  PipeOffDone:
 23239 00002F9A 58                      	pop	ax
 23240 00002F9B 1F                      	pop	ds
 23241 00002F9C C3                      	retn
 23242                                  
 23243                                  ; =============== S U B	R O U T	I N E =======================================
 23244                                  
 23245                                  ; MSDOS 6.0
 23246                                  
 23247                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23248                                  PRINT_TIME:
 23249                                  	;mov	ah,Get_Time
 23250 00002F9D B42C                    	mov	ah,2Ch
 23251 00002F9F CD21                    	int	21h			; Get time in CX:DX
 23252                                  
 23253 00002FA1 06                      	push	es
 23254 00002FA2 0E                      	push	cs
 23255 00002FA3 07                      	pop	es
 23256 00002FA4 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23257 00002FA6 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23258 00002FA8 2E890E[5E81]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23259 00002FAD 2E8916[6081]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23260 00002FB2 BA[5981]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23261 00002FB5 E86B1E                  	call	std_printf
 23262                                  
 23263                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23264                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23265                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23266                                  					;AC000;  pointers in control block
 23267 00002FB8 07                      	pop	es
 23268 00002FB9 C3                      	retn
 23269                                  
 23270                                  ; =============== S U B	R O U T	I N E =======================================
 23271                                  
 23272                                  ; MSDOS 6.0
 23273                                  
 23274                                  ; ****************************************************************
 23275                                  ; *
 23276                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23277                                  ; *
 23278                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23279                                  ; *		 INFORMATION and issues the "Enter new date"
 23280                                  ; *		 message with the proper date format. COMBUF
 23281                                  ; *		 is reset to get a date from the command line.
 23282                                  ; *		 The PARSE_DATE blocks are then reset and the
 23283                                  ; *		 PARSE function call is issued.
 23284                                  ; *
 23285                                  ; * INPUT:	 NONE
 23286                                  ; *
 23287                                  ; * OUTPUT:	 COMBUF
 23288                                  ; *		 PARSER RETURN CODES
 23289                                  ; *
 23290                                  ; ****************************************************************
 23291                                  
 23292                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23293                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23294                                  GETDAT:
 23295                                  	;mov	ax,(International SHL 8)
 23296 00002FBA B80038                  	mov	ax,3800h
 23297                                  					; Determine what format the date
 23298 00002FBD BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23299 00002FC0 CD21                    	int	21h			;  print a message describing it
 23300                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23301                                  			; get current-country info
 23302                                  			; DS:DX -> buffer for returned info
 23303 00002FC2 89D6                    	mov	si,dx
 23304 00002FC4 AD                      	lodsw
 23305 00002FC5 2E8B16[3781]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23306 00002FCA 48                      	dec	ax
 23307 00002FCB 780C                    	js	short printformat
 23308 00002FCD 2E8B16[3A81]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23309 00002FD2 7405                    	jz	short printformat
 23310 00002FD4 2E8B16[3D81]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23311                                  printformat:
 23312 00002FD9 89D0                    	mov	ax,dx			;AN000; get message number of format
 23313                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23314 00002FDB B6FF                    	mov	dh,-1 ; 0FFh
 23315 00002FDD E82A1F                  	call	TSYSGETMSG		;AN000; get the address of the message
 23316 00002FE0 2E8936[1480]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23317 00002FE5 BA[0F80]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23318 00002FE8 E8381E                  	call	std_printf
 23319                                  	;mov	word [cs:NewDat_Format],no_subst
 23320                                  					;AN000; reset subst block
 23321 00002FEB 2EC706[1480]0000        	mov	word [cs:NewDat_Format],0
 23322                                  
 23323                                  	; 28/02/2023
 23324 00002FF2 BF[0B85]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23325                                  ; 28/02/2023
 23326                                  gettim_p:	
 23327                                  	;mov	ah,Std_Con_String_Input
 23328 00002FF5 B40A                    	mov	ah,0Ah
 23329 00002FF7 BA[1F89]                	mov	dx,COMBUF
 23330 00002FFA B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23331 00002FFD E875FF                  	call	SetInitFlag		;  prompting for date.
 23332 00003000 CD21                    	int	21h			; Get input line
 23333 00003002 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23334 00003004 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23335 00003007 E8CFF5                  	call	CRLF2
 23336                                  	; 28/02/2023
 23337                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23338                                  ;gettim_p: ; 28/02/2023
 23339 0000300A BE[2189]                	mov	si,COMBUF+2
 23340                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23341 0000300D 31D2                    	xor	dx,dx			;AN000;
 23342                                  	;call	cmd_parse		;AC000; call parser
 23343                                  	;retn
 23344                                  	; 28/02/2023
 23345 0000300F E93E13                  	jmp	cmd_parse
 23346                                  
 23347                                  ; =============== S U B	R O U T	I N E =======================================
 23348                                  
 23349                                  ; MSDOS 6.0
 23350                                  
 23351                                  ; ****************************************************************
 23352                                  ; *
 23353                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23354                                  ; *
 23355                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23356                                  ; *		 INFORMATION and issues the "Enter new time"
 23357                                  ; *		 message. COMBUF is reset to get a time from the
 23358                                  ; *		 command line. The PARSE_TIME blocks are then
 23359                                  ; *		 reset and the PARSE function call is issued.
 23360                                  ; *
 23361                                  ; * INPUT:	 NONE
 23362                                  ; *
 23363                                  ; * OUTPUT:	 COMBUF
 23364                                  ; *		 PARSER RETURN CODES
 23365                                  ; *
 23366                                  ; ****************************************************************
 23367                                  
 23368                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23369                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23370                                  GETTIM:
 23371 00003012 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23372 00003014 BA[2E80]                	mov	dx,NewTim_Ptr
 23373 00003017 E8091E                  	call	std_printf
 23374                                  
 23375                                  	; 28/02/2023
 23376 0000301A BF[1D85]                	mov	di,PARSE_TIME
 23377 0000301D EBD6                    	jmp	short gettim_p
 23378                                  
 23379                                  ; 28/02/2023
 23380                                  ;	;mov	ah,Std_Con_String_Input
 23381                                  ;	mov	ah,0Ah
 23382                                  ;	mov	dx,COMBUF
 23383                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23384                                  ;	call	SetInitFlag		;  prompting for time.
 23385                                  ;	int	21h			; Get input line
 23386                                  ;	; 28/02/2023
 23387                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23388                                  ;	call	SetInitFlag		;  prompting for time.
 23389                                  ;	call	CRLF2
 23390                                  ;	; 28/02/2023
 23391                                  ;	;mov	si,COMBUF+2
 23392                                  ;	; 28/02/2023
 23393                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23394                                  ;	; 28/02/2023
 23395                                  ;	jmp	short gettim_p	
 23396                                  ;	; 28/02/2023
 23397                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23398                                  ;	;xor	dx,dx			;AN000;
 23399                                  ;	;call	cmd_parse		;AC000; call parser
 23400                                  ;	;retn
 23401                                  
 23402                                  
 23403                                  ; =============== S U B	R O U T	I N E =======================================
 23404                                  
 23405                                  ; MSDOS 6.0
 23406                                  
 23407                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23408                                  ;the '=' sign in the environment variable before the actual path.
 23409                                  ;
 23410                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23411                                  ;
 23412                                  ;	EXIT:	ds:si = start of the path
 23413                                  ;
 23414                                  ;	REGISTERS AFFECTED: ax
 23415                                  
 23416                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23417                                  skip_white:
 23418 0000301F FC                      	cld
 23419                                  skw_lp:
 23420 00003020 AC                      	lodsb
 23421 00003021 3C20                    	cmp	al,' '			;blank char?
 23422 00003023 74FB                    	jz	short skw_lp		;yes, skip it
 23423 00003025 3C09                    	cmp	al,9			;tab char?
 23424 00003027 74F7                    	jz	short skw_lp		;yes, skip it
 23425 00003029 4E                      	dec	si			;point at first non-white
 23426 0000302A C3                      	retn
 23427                                  
 23428                                  ; =============== S U B	R O U T	I N E =======================================
 23429                                  
 23430                                  ; MSDOS 6.0
 23431                                  
 23432                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23433                                  ;variable into the path buffers Pipe1 & Pipe2.
 23434                                  ;
 23435                                  ;	ENTRY:	ds:si = path to be copied
 23436                                  ;		es = RESGROUP
 23437                                  ;
 23438                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23439                                  ;
 23440                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23441                                  
 23442                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23443                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23444                                  
 23445                                  copy_pipe_path:
 23446 0000302B B9FFFF                  	mov	cx,0FFFFh ; 65535
 23447 0000302E 30C0                    	xor	al,al
 23448                                  
 23449 00003030 89F7                    	mov	di,si
 23450 00003032 06                      	push	es			;save es
 23451 00003033 1E                      	push	ds
 23452 00003034 07                      	pop	es			;es:di = path to be copied
 23453                                  	
 23454 00003035 FC                      	cld
 23455 00003036 57                      	push	di
 23456 00003037 F2AE                    	repnz	scasb			;look for the null char
 23457 00003039 5F                      	pop	di
 23458                                  
 23459 0000303A 07                      	pop	es			;es = RESGROUP again
 23460                                  
 23461 0000303B F7D1                    	not	cx			;length including the null
 23462                                  
 23463                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23464                                  	;mov	di,offset DATARES:Pipe1
 23465 0000303D BF[1A02]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23466 00003040 57                      	push	di
 23467 00003041 51                      	push	cx			
 23468 00003042 F3A4                    	rep	movsb			;copy path into Pipe1
 23469 00003044 59                      	pop	cx
 23470 00003045 5F                      	pop	di
 23471                                  
 23472 00003046 1E                      	push	ds
 23473 00003047 06                      	push	es
 23474 00003048 1F                      	pop	ds			;ds:si = Pipe1
 23475 00003049 89FE                    	mov	si,di
 23476                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23477                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23478 0000304B BF[6902]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23479 0000304E F3A4                    	rep	movsb			;copy path into Pipe2
 23480 00003050 1F                      	pop	ds
 23481 00003051 C3                      	retn
 23482                                  
 23483                                  ; 28/02/2023
 23484                                  %if 0
 23485                                  
 23486                                  ;============================================================================
 23487                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23488                                  ;============================================================================
 23489                                  ; 05/10/2018 - Retro DOS v3.0
 23490                                  
 23491                                  ; DATE - Gets and sets the time
 23492                                  
 23493                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23494                                  
 23495                                  ; =============== S U B	R O U T	I N E =======================================
 23496                                  
 23497                                  DATE_CXDX:
 23498                                  	mov	bx,cx
 23499                                  
 23500                                  ; =============== S U B	R O U T	I N E =======================================
 23501                                  
 23502                                  P_DATE:
 23503                                  	mov	ax,bx
 23504                                  	mov	cx,dx
 23505                                  	mov	dl,100
 23506                                  	div	dl
 23507                                  	xchg	al,ah
 23508                                  	xchg	ax,dx
 23509                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23510                                  	;mov	ax,[INTERNATVARS]
 23511                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23512                                  	or	ax,ax
 23513                                  	jz	short USPDAT
 23514                                  	dec	ax
 23515                                  	jz	short EUPDAT
 23516                                  	mov	bh,0	 ; Disable leading zero suppression	
 23517                                  	call	P_YR
 23518                                  	call	P_DSEP
 23519                                  	call	P_MON
 23520                                  	call	P_DSEP
 23521                                  	call	P_DAY
 23522                                  	retn
 23523                                  
 23524                                  USPDAT:
 23525                                  	call	P_MON
 23526                                  	call	P_DSEP
 23527                                  	call	P_DAY
 23528                                  PLST:
 23529                                  	call	P_DSEP
 23530                                  	call	P_YR
 23531                                  	retn
 23532                                  
 23533                                  EUPDAT:
 23534                                  	call	P_DAY
 23535                                  	call	P_DSEP
 23536                                  	call	P_MON
 23537                                  	jmp	short PLST
 23538                                  
 23539                                  ; ---------------------------------------------------------------------------
 23540                                  
 23541                                  P_MON:
 23542                                  	mov	al,ch
 23543                                  	call	OUT2
 23544                                  	retn
 23545                                  
 23546                                  ; ---------------------------------------------------------------------------
 23547                                  
 23548                                  P_DSEP:
 23549                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23550                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23551                                  	stosb
 23552                                  	retn
 23553                                  
 23554                                  ; ---------------------------------------------------------------------------
 23555                                  
 23556                                  P_DAY:
 23557                                  	mov	al,cl
 23558                                  	call	OUT2
 23559                                  	retn
 23560                                  
 23561                                  ; ---------------------------------------------------------------------------
 23562                                  
 23563                                  P_YR:
 23564                                  	mov	al,dh
 23565                                  	or	al,al
 23566                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23567                                  	call	OUT2
 23568                                  TWODIGYR:
 23569                                  	mov	al,dl
 23570                                  	call	OUT2
 23571                                  DATE_RETN:
 23572                                  	retn
 23573                                  
 23574                                  ; =============== S U B	R O U T	I N E =======================================
 23575                                  
 23576                                  DATE:				 ; Accepting argument for date inline
 23577                                  	mov	si,81h
 23578                                  	call	SCANOFF
 23579                                  	cmp	al,0Dh
 23580                                  	jz	short PRMTDAT
 23581                                  	jmp	short COMDAT
 23582                                  
 23583                                  	;nop
 23584                                  PRMTDAT:
 23585                                  	; MSDOS 3.3
 23586                                  	mov	dx,CURDATPTR
 23587                                  	call	STD_PRINTF	; Print "Current date is "	
 23588                                  	call	PRINT_DATE
 23589                                  GETDAT:	
 23590                                  	mov	dx,NEWDATPTR
 23591                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23592                                  
 23593                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23594                                  				; Determine what format the date
 23595                                  	mov	dx,5Ch		;  should be entered in and
 23596                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23597                                  			; get current-country info
 23598                                  			; DS:DX	-> buffer for returned info
 23599                                  	mov	si,dx		;  print a message describing it
 23600                                  	lodsw
 23601                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23602                                  	dec	ax
 23603                                  	js	short PRINTFORMAT
 23604                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23605                                  	jz	short PRINTFORMAT
 23606                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23607                                  PRINTFORMAT:
 23608                                  	call	STD_PRINTF
 23609                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23610                                  	mov	dx,COMBUF
 23611                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23612                                  	call	SETINITFLAG	;  prompting for date.
 23613                                  	int	21h		; Get input line
 23614                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23615                                  	call	SETINITFLAG	;  prompting for date.
 23616                                  	call	CRLF2
 23617                                  	mov	si,COMBUF+2
 23618                                  	cmp	byte [si],0Dh
 23619                                  	jz	short DATE_RETN
 23620                                  COMDAT:
 23621                                  	;mov	ax,[INTERNATVARS]
 23622                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23623                                  	or	ax,ax
 23624                                  	jz	short USSDAT
 23625                                  	dec	ax
 23626                                  	jz	short EUSDAT
 23627                                  	call	GET_YR
 23628                                  	jc	short DATERRJ
 23629                                  	call	GET_DSEP
 23630                                  	jc	short DATERRJ
 23631                                  	call	GET_MON
 23632                                  	jc	short DATERRJ
 23633                                  	call	GET_DSEP
 23634                                  	jc	short DATERRJ
 23635                                  	call	GET_DAY
 23636                                  DAT_SET:
 23637                                  	jnc	short DATSET
 23638                                  	jmp	DATERR
 23639                                  
 23640                                  ; ---------------------------------------------------------------------------
 23641                                  
 23642                                  DATSET:
 23643                                  	lodsb
 23644                                  	cmp	al,' '
 23645                                  	jz	short DATSET
 23646                                  	cmp	al,9
 23647                                  	jz	short DATSET
 23648                                  	cmp	al,0Dh
 23649                                  	jnz	short DATERR
 23650                                  	mov	ah,SET_DATE ; 2Bh
 23651                                  	int	21h	; DOS -	SET CURRENT DATE
 23652                                  			; DL = day,DH = month,	CX = year
 23653                                  			; Return: AL = 00h if no error 
 23654                                  			; 	     = FFh if bad value sent to routine
 23655                                  	or	al,al
 23656                                  	jnz	short DATERR
 23657                                  DAT_SET_RETN:
 23658                                  	retn
 23659                                  
 23660                                  ; ---------------------------------------------------------------------------
 23661                                  
 23662                                  USSDAT:
 23663                                  	call	GET_MON
 23664                                  	jb	short DATERR
 23665                                  	call	GET_DSEP
 23666                                  DATERRJ:
 23667                                  	jc	short DATERR
 23668                                  	call	GET_DAY
 23669                                  TGET:
 23670                                  	jc	short DATERR
 23671                                  	call	GET_DSEP
 23672                                  	jc	short DATERR
 23673                                  	call	GET_YR
 23674                                  	jmp	short DAT_SET
 23675                                  
 23676                                  ; ---------------------------------------------------------------------------
 23677                                  
 23678                                  EUSDAT:
 23679                                  	call	GET_DAY
 23680                                  	jc	short DATERR
 23681                                  	call	GET_DSEP
 23682                                  	jc	short DATERR
 23683                                  	call	GET_MON
 23684                                  	jmp	short TGET
 23685                                  
 23686                                  ; =============== S U B	R O U T	I N E =======================================
 23687                                  
 23688                                  GET_MON:
 23689                                  	call	GETNUM		; Get one or two digit number
 23690                                  	jc	short DAT_SET_RETN
 23691                                  	mov	dh,ah		; Put in position
 23692                                  	retn
 23693                                  
 23694                                  
 23695                                  ; =============== S U B	R O U T	I N E =======================================
 23696                                  
 23697                                  GET_DAY:
 23698                                  		call	GETNUM
 23699                                  		mov	dl,ah		; Put in position
 23700                                  GET_DAY_RETN:
 23701                                  		retn
 23702                                  
 23703                                  ; =============== S U B	R O U T	I N E =======================================
 23704                                  
 23705                                  GET_YR:
 23706                                  	call	GETNUM
 23707                                  	jc	short GET_DAY_RETN
 23708                                  	mov	cx,1900
 23709                                  	call	GET_DSEP
 23710                                  	pushf
 23711                                  	dec	si
 23712                                  	popf
 23713                                  	jz	short BIAS
 23714                                  	cmp	byte [si],0Dh
 23715                                  	je	short BIAS
 23716                                  	cmp	byte [si],' '
 23717                                  	je	short BIAS
 23718                                  	cmp	byte [si],9
 23719                                  	je	short BIAS
 23720                                  	push	bx
 23721                                  	mov	bl,100
 23722                                  	mov	al,ah
 23723                                  	mul	bl
 23724                                  	pop	bx
 23725                                  	mov	cx,ax
 23726                                  	call	GETNUM
 23727                                  	jc	short GET_DAY_RETN
 23728                                  BIAS:
 23729                                  	mov	al,ah
 23730                                  	mov	ah,0
 23731                                  	add	cx,ax
 23732                                  BIAS_RETN:
 23733                                  	retn
 23734                                  
 23735                                  ; ---------------------------------------------------------------------------
 23736                                  
 23737                                  DATERR:
 23738                                  	mov	dx,BADDATPTR
 23739                                  	call	STD_PRINTF
 23740                                  	jmp	GETDAT
 23741                                  
 23742                                  ; =============== S U B	R O U T	I N E =======================================
 23743                                  
 23744                                  GET_DSEP:
 23745                                  	lodsb
 23746                                  	cmp	al,'/'
 23747                                  	je	short BIAS_RETN
 23748                                  	;cmp	al,'.'
 23749                                  	cmp	al,[DOT_CHR]
 23750                                  	je	short BIAS_RETN
 23751                                  	;cmp	al,'-'
 23752                                  	cmp	al,[CHAR_SUB]
 23753                                  	je	short BIAS_RETN
 23754                                  	stc
 23755                                  	retn
 23756                                  
 23757                                  ; =============== S U B	R O U T	I N E =======================================
 23758                                  
 23759                                  ; TIME gets and sets the time
 23760                                  
 23761                                  CTIME:
 23762                                  	mov	si,81h		; Accepting argument for time inline
 23763                                  	call	SCANOFF
 23764                                  	cmp	al,0Dh
 23765                                  	je	short PRMTTIM
 23766                                  	mov	bx,2E3Ah ; ":."
 23767                                  	call	INLINE
 23768                                  	jmp	COMTIM
 23769                                  
 23770                                  ; =============== S U B	R O U T	I N E =======================================
 23771                                  
 23772                                  PRINT_TIME:
 23773                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 23774                                  	int	21h	; DOS -	GET CURRENT TIME
 23775                                  			; Return: CH = hours,CL = minutes,DH = seconds
 23776                                  			; DL = hundredths of seconds
 23777                                  	push	di
 23778                                  	push	es
 23779                                  	push	cs
 23780                                  	pop	es
 23781                                  	mov	di,CHARBUF
 23782                                  	mov	bl,1	; Always 24 hour time
 23783                                  	call	P_TIME
 23784                                  	xor	ax,ax
 23785                                  	stosb
 23786                                  	mov	dx,CHARBUF
 23787                                  	mov	[STRING_PTR_2],dx
 23788                                  	mov	dx,STRINGBUF2PTR
 23789                                  	call	STD_PRINTF
 23790                                  	pop	es
 23791                                  	pop	di
 23792                                  P_TIME_RETN:
 23793                                  	retn
 23794                                  
 23795                                  ; =============== S U B	R O U T	I N E =======================================
 23796                                  
 23797                                  P_TIME:
 23798                                  	mov	al,ch	
 23799                                  	test	bl,7Fh		; Ignore high bit
 23800                                  	jnz	short T24	; 24 hr time?
 23801                                  	mov	bh,'a'		; Assume A.M.
 23802                                  	cmp	al,12		; In the afternoon?
 23803                                  	jb	short MORN
 23804                                  	mov	bh,'p'
 23805                                  	jz	short MORN
 23806                                  	sub	al,12		; Keep it to 12 hours or less
 23807                                  MORN:
 23808                                  	or	al,al		; Before 1 am?
 23809                                  	jnz	short T24
 23810                                  	mov	al,12
 23811                                  T24:
 23812                                  	push	bx
 23813                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 23814                                  	call	OUT2
 23815                                  	call	P_TSEP
 23816                                  	mov	al,cl
 23817                                  	call	OUT2
 23818                                  	pop	bx
 23819                                  	push	bx
 23820                                  	test	bl,80h
 23821                                  	jnz	short PAP	; If from DIR, go directly to am pm
 23822                                  	mov	bh,0		; Disable leading zero suppression
 23823                                  	call	P_TSEP
 23824                                  	mov	al,dh
 23825                                  	call	OUT2
 23826                                  	;mov	al,'.'
 23827                                  	mov	al,[DECIMAL_SEP]
 23828                                  	stosb
 23829                                  	mov	al,dl
 23830                                  	call	OUT2
 23831                                  PAP:
 23832                                  	pop	bx
 23833                                  	test	bl,7Fh		; Ignore high bit
 23834                                  	jnz	short P_TIME_RETN
 23835                                  	mov	al,bh
 23836                                  	stosb
 23837                                  	retn
 23838                                  
 23839                                  ; =============== S U B	R O U T	I N E =======================================
 23840                                  
 23841                                  P_TSEP:
 23842                                  	;mov	al,[TIME_SEP]
 23843                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 23844                                  	stosb
 23845                                  P_TSEP_RETN:
 23846                                  	retn
 23847                                  
 23848                                  ; ---------------------------------------------------------------------------
 23849                                  
 23850                                  PRMTTIM:
 23851                                  	mov	dx,CURTIMPTR
 23852                                  	call	STD_PRINTF	; Print "Current time is "
 23853                                  	call	PRINT_TIME
 23854                                  GETTIM:
 23855                                  	xor	cx,cx		; Initialize hours and minutes to zero
 23856                                  	mov	dx,NEWTIMPTR
 23857                                  	call	STD_PRINTF
 23858                                  	;mov	bx,':.'
 23859                                  	mov	bx,[TIMECHARS] 
 23860                                  	call	GETBUF
 23861                                  COMTIM:
 23862                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 23863                                  	jc	short TIMEERR
 23864                                  	mov	cx,dx
 23865                                  	xor	dx,dx
 23866                                  	lodsb
 23867                                  	cmp	al,0Dh
 23868                                  	je	short SAVTIM
 23869                                  	cmp	al,' '
 23870                                  	je	short GOTSEC2
 23871                                  	cmp	al,9
 23872                                  	je	short GOTSEC2
 23873                                  	cmp	al,bl
 23874                                  	je	short GOTSEC
 23875                                  	cmp	al,bh
 23876                                  	jne	short TIMEERR
 23877                                  GOTSEC:
 23878                                  	call	GETNUM
 23879                                  	jc	short TIMEERR
 23880                                  	mov	dh,ah		; Position seconds
 23881                                  	lodsb
 23882                                  	cmp	al,0Dh
 23883                                  	je	short SAVTIM
 23884                                  	cmp	al,' '
 23885                                  	je	short GOTSEC2
 23886                                  	cmp	al,9
 23887                                  	je	short GOTSEC2
 23888                                  	;cmp	al,'.'
 23889                                  	cmp	al,[DECIMAL_SEP]
 23890                                  	jne	short TIMEERR
 23891                                  	call	GETNUM
 23892                                  	jc	short TIMEERR
 23893                                  	mov	dl,ah
 23894                                  GOTSEC2:
 23895                                  	lodsb
 23896                                  	cmp	al,' '
 23897                                  	je	short GOTSEC2
 23898                                  	cmp	al,9
 23899                                  	je	short GOTSEC2
 23900                                  	cmp	al,0Dh
 23901                                  	jne	short TIMEERR
 23902                                  SAVTIM:
 23903                                  	mov	ah,SET_TIME ; 2Dh
 23904                                  	int	21h	; DOS -	SET CURRENT TIME
 23905                                  			; CH = hours,CL = minutes,DH = seconds,
 23906                                  			;		DL = hundredths of seconds
 23907                                  			; Return: AL = 00h if no error 
 23908                                  			;	     = FFh if bad value sent to routine
 23909                                  	or	al,al
 23910                                  P_TSEP_JRETN:
 23911                                  	jz	short P_TSEP_RETN ; Error in time?
 23912                                  TIMEERR:
 23913                                  	mov	dx,BADTIMPTR
 23914                                  	call	STD_PRINTF	; Print "Enter new time: "
 23915                                  	jmp	short GETTIM
 23916                                  
 23917                                  ; =============== S U B	R O U T	I N E =======================================
 23918                                  
 23919                                  GETBUF:
 23920                                  	mov	ah,Std_Con_String_Input ; 0Ah
 23921                                  	mov	dx,COMBUF
 23922                                  	mov	cx,2
 23923                                  	call	SETINITFLAG
 23924                                  	int	21h		; Get input line
 23925                                  	xor	cx,cx
 23926                                  	call	SETINITFLAG
 23927                                  	call	CRLF2
 23928                                  	mov	si,COMBUF+2
 23929                                  	cmp	byte [si],0Dh	; Check if new time entered
 23930                                  	jz	short P_TSEP_JRETN
 23931                                  
 23932                                  ; =============== S U B	R O U T	I N E =======================================
 23933                                  
 23934                                  INLINE:
 23935                                  	call	GETNUM		; Get one or two digit number
 23936                                  	jnb	short INLINE1
 23937                                  	retn
 23938                                  INLINE1:
 23939                                  	mov	dh,ah		; Put in position
 23940                                  	lodsb
 23941                                  	cmp	al,bl
 23942                                  	jz	short NEXT
 23943                                  	cmp	al,bh
 23944                                  	jz	short NEXT
 23945                                  	dec	si		; Clears zero flag
 23946                                  	clc
 23947                                  	mov	dl,0
 23948                                  	retn			; Time may have only an hour specified
 23949                                  NEXT:
 23950                                  	call	GETNUM
 23951                                  	mov	dl,ah		; Put in position
 23952                                  INLINE_RETN:
 23953                                  	retn
 23954                                  
 23955                                  ;============================================================================
 23956                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23957                                  ;============================================================================
 23958                                  ; 05/10/2018 - Retro DOS v3.0
 23959                                  
 23960                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 23961                                  
 23962                                  ; =============== S U B	R O U T	I N E =======================================
 23963                                  
 23964                                  GETNUM:
 23965                                  	call	INDIG
 23966                                  	jb	short INLINE_RETN
 23967                                  	mov	ah,al		; Save first digit
 23968                                  	call	INDIG		; Another digit?
 23969                                  	jb	short OKRET
 23970                                  	aad			; Convert unpacked BCD to decimal
 23971                                  	mov	ah,al
 23972                                  OKRET:
 23973                                  	or	al,1
 23974                                  GETNUM_RETN:
 23975                                  	retn
 23976                                  
 23977                                  ; =============== S U B	R O U T	I N E =======================================
 23978                                  
 23979                                  INDIG:
 23980                                  	mov	al,[si]
 23981                                  	sub	al,'0'
 23982                                  	jc	short GETNUM_RETN
 23983                                  	cmp	al,10
 23984                                  	cmc
 23985                                  	jc	short GETNUM_RETN
 23986                                  	inc	si
 23987                                  	retn
 23988                                  
 23989                                  ; =============== S U B	R O U T	I N E =======================================
 23990                                  
 23991                                  OUT2:				; Output binary number as two ASCII digits
 23992                                  	aam			; Convert binary to unpacked BCD
 23993                                  	xchg	al,ah
 23994                                  	or	ax,3030h	; Add "0" bias to both digits
 23995                                  	cmp	al,'0'		; Is MSD zero?
 23996                                  	jnz	short NOSUP
 23997                                  	sub	al,bh		; Suppress leading zero if enabled
 23998                                  NOSUP:
 23999                                  	mov	bh,0		; Disable zero suppression
 24000                                  	stosw
 24001                                  	retn
 24002                                  
 24003                                  ; ---------------------------------------------------------------------------
 24004                                  	;stosb
 24005                                  	;retn
 24006                                  
 24007                                  ;============================================================================
 24008                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 24009                                  ;============================================================================
 24010                                  ; 03/10/2018 - Retro DOS v3.0
 24011                                  
 24012                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 24013                                  
 24014                                  ; =============== S U B	R O U T	I N E =======================================
 24015                                  
 24016                                  ; Set the special flag in the INIT flag to the value in CX.
 24017                                  
 24018                                  SETINITFLAG:
 24019                                  	mov	ds,[RESSEG]
 24020                                  	;and	byte [INITFLAG],0FDh
 24021                                  	and	byte [INITFLAG],~INITSPECIAL
 24022                                  	or	byte [INITFLAG],cl
 24023                                  	push	cs
 24024                                  	pop	ds
 24025                                  	retn
 24026                                  
 24027                                  ; =============== S U B	R O U T	I N E =======================================
 24028                                  
 24029                                  PIPEOFF:
 24030                                  	push	ds
 24031                                  	push	ax
 24032                                  	mov	ds,[cs:RESSEG]
 24033                                  	xor	al,al
 24034                                  	xchg	al,byte [PIPEFLAG]
 24035                                  	or	al,al
 24036                                  	jz	short PIPEOFFDONE
 24037                                  	shr	byte [ECHOFLAG],1
 24038                                  PIPEOFFDONE:
 24039                                  	pop	ax
 24040                                  	pop	ds
 24041                                  	retn
 24042                                  
 24043                                  ; ---------------------------------------------------------------------------
 24044                                  	;db    0,0,0,0,0
 24045                                  	;times 5 db 0
 24046                                  
 24047                                  align 16
 24048                                  
 24049                                  %endif
 24050                                  
 24051                                  ;============================================================================
 24052                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24053                                  ;============================================================================
 24054                                  ; 03/10/2018 - Retro DOS v3.0
 24055                                  
 24056                                  ;----------------------------------------------------------------------------
 24057                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24058                                  ; argv[argvcnt] array. The most important difference between this array and
 24059                                  ; the tradition UNIX format is the extra cparse information included with
 24060                                  ; each argument element.
 24061                                  ;---------------
 24062                                  ; ENTRY:
 24063                                  ;	BL	     special delimiter for cparse -- not implemented)
 24064                                  ;---------------
 24065                                  ; EXIT:
 24066                                  ;	CF	    set if error
 24067                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24068                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24069                                  ;	argvcnt     argument count
 24070                                  ;---------------
 24071                                  ; NOTE(S):
 24072                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24073                                  ;	*   Parseflags record contains cparse flags, as follows:
 24074                                  ;		sw_flag 	--	was this arg a switch?
 24075                                  ;		wildcard	--	whether or not it contained a * or ?
 24076                                  ;		path_sep	--	maybe it was a pathname
 24077                                  ;		unused		--	for future expansion
 24078                                  ;		special_delim	--	was there an initial special delimiter?
 24079                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24080                                  ;	*   Relationship between input, cparse output, and comtail can be
 24081                                  ;	    found in the following chart. Despite the claim of the cparse
 24082                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24083                                  ;	    tokens", such is not the case (see column two, row two).
 24084                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24085                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24086                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24087                                  ;	    documentation error.
 24088                                  ;	*   cparse also returns a switch code in BP for each switch it
 24089                                  ;	    recognizes on the command line.
 24090                                  ;	*   arglen for each token does NOT include the terminating null.
 24091                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24092                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24093                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24094                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24095                                  ;	    line parsing may result in slightly different behavior than
 24096                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24097                                  ;
 24098                                  ;	    Input		    Cparse		Command Line (80H)
 24099                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24100                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24101                                  ;	foo.bat 		foo.bat 		foo.bat
 24102                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24103                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24104                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24105                                  
 24106                                  ; =============== S U B	R O U T	I N E =======================================
 24107                                  
 24108                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24109                                  
 24110                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24111                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24112                                  
 24113                                  PARSELINE:
 24114 00003052 50                      	push	ax			; most of these are clobbered
 24115 00003053 53                      	push	bx			; by cparse...
 24116 00003054 51                      	push	cx
 24117 00003055 52                      	push	dx
 24118 00003056 57                      	push	di
 24119 00003057 56                      	push	si
 24120 00003058 9C                      	pushf
 24121 00003059 C606[B48C]00            	mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24122 0000305E C706[1594]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24123 00003064 31C0                    	xor	ax,ax
 24124                                  	;mov	cx,1348
 24125 00003066 B94405                  	mov	cx,ARG_UNIT.SIZE
 24126 00003069 BF[4F8E]                	mov	di,ARG
 24127 0000306C F3AA                    	rep	stosb
 24128                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24129 0000306E C706[9393][1391]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24130                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24131 00003074 C706[1191]0000          	mov	word [ARG+ARG_UNIT.argswinfo],0
 24132                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24133 0000307A C706[0F91]0000          	mov	word [ARG+ARG_UNIT.argvcnt],0
 24134 00003080 BE[2189]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24135                                  
 24136                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24137                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24138                                  ; otherwise. This is done so that commands can get arg pointers into their
 24139                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24140                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24141                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24142                                  ; the command to be repeated or the transient part of command has been
 24143                                  ; reloaded.
 24144                                  
 24145 00003083 1E                      	push	ds
 24146 00003084 8E1E[C08A]              	mov	ds,[RESSEG]
 24147 00003088 803E[AC01]00            	cmp	byte [ForFlag],0
 24148 0000308D 1F                      	pop	ds
 24149 0000308E 7510                    	jnz	short PCONT
 24150                                  	;mov	di,ARG_ARGFORCOMBUF
 24151 00003090 BF[1393]                	mov	di,ARG+ARG_UNIT.argforcombuf 
 24152 00003093 30ED                    	xor	ch,ch
 24153 00003095 8A0E[2089]              	mov	cl,[COMBUF+1]
 24154 00003099 FEC1                    	inc	cl
 24155 0000309B F3A4                    	rep	movsb
 24156                                  	;mov	si,ARG_ARGFORCOMBUF
 24157 0000309D BE[1393]                	mov	si,ARG+ARG_UNIT.argforcombuf 
 24158                                  PCONT:
 24159 000030A0 BF[9593]                	mov	di,TPBUF	; destination is temporary token buffer	
 24160 000030A3 B320                    	mov	bl,' '		; no special delimiter, for now
 24161                                  PARSELOOP:
 24162 000030A5 8936[1794]              	mov	[COMPTR],si	; save ptr into original command buffer
 24163 000030A9 31ED                    	xor	bp,bp		; switch information put here by cparse
 24164 000030AB C606[318E]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24165 000030B0 E833F5                  	call	scanoff		; skip leading blanks...
 24166 000030B3 E8D510                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24167 000030B6 730B                    	jnb	short MORE_PRSE
 24168 000030B8 09ED                    	or	bp,bp		; Check for trailing switch character
 24169 000030BA 7403                    	jz	short PARSEDONE
 24170 000030BC E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24171                                  				;   typical cause of this is that a
 24172                                  				;   switch char IMMEDIATELY preceeds
 24173                                  				;   the CR. We have an argument, but it
 24174                                  				;   is sort of an error.
 24175                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24176                                  	; 01/03/2023
 24177                                  PARSEDONE:
 24178 000030BF 9D                      	popf
 24179 000030C0 F8                      	clc
 24180 000030C1 EB0C                    	jmp	short PARSE_EXIT
 24181                                  
 24182                                  MORE_PRSE:
 24183 000030C3 C606[B48C]02            	mov	byte [cpyflag],2
 24184                                  				; tell CPARSE that 1st token is done
 24185 000030C8 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24186 000030CB 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24187                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24188                                  	; 01/03/2023
 24189                                  ;PARSEDONE:
 24190                                  	;popf
 24191                                  	;clc
 24192                                  	;jmp	short PARSE_EXIT
 24193                                  
 24194                                  PARSE_ERROR:			; error entry (er, exit) point
 24195 000030CD 9D                      	popf
 24196 000030CE F9                      	stc
 24197                                  PARSE_EXIT:			; depend on not changing CF
 24198 000030CF 5E                      	pop	si
 24199 000030D0 5F                      	pop	di
 24200 000030D1 5A                      	pop	dx
 24201 000030D2 59                      	pop	cx
 24202 000030D3 5B                      	pop	bx
 24203 000030D4 58                      	pop	ax
 24204 000030D5 C3                      	retn
 24205                                  
 24206                                  ; =============== S U B	R O U T	I N E =======================================
 24207                                  
 24208                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24209                                  ;
 24210                                  ; ENTRY:
 24211                                  ;   BH			argflags
 24212                                  ;   CX			character count in argstring
 24213                                  ;   DI			pointer to argstring
 24214                                  ;   comptr		ptr to starting loc of current token in original command
 24215                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24216                                  ; EXIT:
 24217                                  ;   argbufptr		points to next free section of argbuffer
 24218                                  ;   arg.argbuf		contains null-terminated argument strings
 24219                                  ;   arg.argvcnt 	argument count
 24220                                  ;   arg.argv[]		array of flags and pointers
 24221                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24222                                  ;   CF			set if error
 24223                                  ;   AL			carry set:  error code; otherwise, zero
 24224                                  
 24225                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24226                                  newarg:
 24227 000030D6 53                      	push	bx
 24228 000030D7 51                      	push	cx
 24229 000030D8 52                      	push	dx
 24230 000030D9 57                      	push	di
 24231 000030DA 56                      	push	si
 24232 000030DB 9C                      	pushf
 24233 000030DC E86600                  	call	arg_switch		; if it's a switch, record switch info
 24234                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24235                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24236                                  
 24237                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24238 000030DF 833E[0F91]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24239 000030E4 7D4F                    	jge	short to_many_args	; exceeded array limits
 24240 000030E6 88FE                    	mov	dh,bh			
 24241                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24242 000030E8 8B1E[0F91]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24243                                  	;inc	word [ARG_ARGVCNT]
 24244 000030EC FF06[0F91]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24245                                  	;mov	ax,ARG_ARGV
 24246 000030F0 B8[4F8E]                	mov	ax,ARG+ARG_UNIT.argv
 24247 000030F3 E88200                  	call	argv_calc		; convert offset to pointer
 24248                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24249                                  	;mov	word [bx+7],0
 24250 000030F6 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24251                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24252                                  	;mov	[bx+5],cx
 24253 000030FB 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24254                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24255                                  	;mov	[bx+2],dh
 24256 000030FE 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24257 00003101 8B36[9393]              	mov	si,[ARGBUF_PTR]
 24258                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24259                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24260 00003105 8937                    	mov	[bx],si			
 24261 00003107 0336[F68D]              	add	si,[STARTEL]		; save startel from new location
 24262 0000310B 29FE                    	sub	si,di			; form pointer into argbuf
 24263                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24264                                  	;mov	[bx+3],si
 24265 0000310D 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24266 00003110 8B36[1794]              	mov	si,[COMPTR]
 24267                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24268                                  	;mov	[bx+9],si
 24269 00003114 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24270 00003117 89FE                    	mov	si,di			; now save argstring in argbuffer
 24271 00003119 8B3E[9393]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24272 0000311D 01CF                    	add	di,cx			; sure we're not about to run off
 24273                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24274                                  	;cmp	di,ARG_ARGBUF+255
 24275 0000311F 81FF[1292]              	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24276 00003123 7D15                    	jge	short buf_oflow		; the end of the buffer (plus null byte)	
 24277 00003125 29CF                    	sub	di,cx
 24278 00003127 FC                      	cld
 24279 00003128 F3A4                    	rep	movsb
 24280 0000312A B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24281 0000312C AA                      	stosb
 24282 0000312D 893E[9393]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24283                                  newarg_done:
 24284 00003131 9D                      	popf
 24285 00003132 F8                      	clc
 24286 00003133 EB0A                    	jmp	short newarg_exit
 24287                                  to_many_args:
 24288 00003135 B80100                  	mov	ax,1
 24289 00003138 EB03                    	jmp	short newarg_error
 24290                                  buf_oflow:
 24291 0000313A B80200                  	mov	ax,2
 24292                                  newarg_error:
 24293 0000313D 9D                      	popf
 24294 0000313E F9                      	stc
 24295                                  newarg_exit:
 24296 0000313F 5E                      	pop	si
 24297 00003140 5F                      	pop	di
 24298 00003141 5A                      	pop	dx
 24299 00003142 59                      	pop	cx
 24300 00003143 5B                      	pop	bx
 24301 00003144 C3                      	retn
 24302                                  
 24303                                  ; =============== S U B	R O U T	I N E =======================================
 24304                                  
 24305                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24306                                  ; event that it is, and we can recognize
 24307                                  ;
 24308                                  ; ENTRY:
 24309                                  ;   As in <newarg>.
 24310                                  ; EXIT:
 24311                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24312                                  ; NOTE(S):
 24313                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24314                                  ;	on the order of definition in the <switch_list> variable and the
 24315                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24316                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24317                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24318                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24319                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24320                                  ;   *	An ugly routine.
 24321                                  
 24322                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24323                                  arg_switch:
 24324 00003145 50                      	push	ax
 24325 00003146 53                      	push	bx
 24326 00003147 51                      	push	cx
 24327 00003148 57                      	push	di
 24328 00003149 9C                      	pushf
 24329 0000314A F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24330 0000314D 741C                    	jz	short arg_no_switch0
 24331 0000314F 833E[1594]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24332 00003154 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24333 00003156 8B1E[1594]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24334                                  	;mov	ax,offset TRANGROUP:arg.argv
 24335                                  	;mov	ax,ARG_ARGV
 24336 0000315A B8[4F8E]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24337 0000315D E81800                  	call	argv_calc
 24338                                  	;or	[BX].argsw_word,BP
 24339                                  	;or	[bx+7],bp
 24340 00003160 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24341                                  	;or	arg.argswinfo,BP
 24342                                  	;or	[ARG_ARGSWINFO],bp
 24343 00003163 092E[1191]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24344                                  arg_yes_switch:
 24345 00003167 9D                      	popf
 24346 00003168 F9                      	stc
 24347 00003169 EB08                    	jmp	short arg_switch_exit
 24348                                  
 24349                                  arg_no_switch0:
 24350                                  	;mov	ax,[ARG_ARGVCNT]
 24351 0000316B A1[0F91]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24352 0000316E A3[1594]                	mov	[LASTARG],ax
 24353                                  arg_no_switch1:
 24354 00003171 9D                      	popf
 24355 00003172 F8                      	clc
 24356                                  arg_switch_exit:
 24357 00003173 5F                      	pop	di
 24358 00003174 59                      	pop	cx
 24359 00003175 5B                      	pop	bx
 24360 00003176 58                      	pop	ax
 24361 00003177 C3                      	retn
 24362                                  
 24363                                  ; =============== S U B	R O U T	I N E =======================================
 24364                                  
 24365                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24366                                  ; the supplied array.  Method used for computing the address is:
 24367                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24368                                  ; ENTRY:
 24369                                  ;   AX	    --	    base of array
 24370                                  ;   BX	    --	    array index
 24371                                  ; EXIT:
 24372                                  ;   BX	    --	    byte offset
 24373                                  
 24374                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24375                                  argv_calc:
 24376 00003178 50                      	push	ax		; Save base
 24377 00003179 88D8                    	mov	al,bl		; al = array index
 24378                                  	;mov	bl,11
 24379 0000317B B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24380 0000317D F6E3                    	mul	bl		; ax = base offset
 24381 0000317F 5B                      	pop	bx		; Get base
 24382 00003180 01D8                    	add	ax,bx		; Add in base offset
 24383 00003182 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24384 00003183 C3                      	retn
 24385                                  
 24386                                  ; ---------------------------------------------------------------------------
 24387                                  	
 24388                                  	;db 0Ah dup(0)
 24389                                  	;times 10 db 0
 24390                                  
 24391 00003184 90<rep Ch>              align 16
 24392                                  
 24393                                  ;============================================================================
 24394                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24395                                  ;============================================================================
 24396                                  ; 03/10/2018 - Retro DOS v3.0
 24397                                  
 24398                                  ;----------------------------------------------------------------------------
 24399                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24400                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24401                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24402                                  ;    file on disk. Directories specified in the user's search path will be
 24403                                  ;    searched for a matching file, if a match is not found in the current
 24404                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24405                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24406                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24407                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24408                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24409                                  ;    (easily) modified to make no assumptions about where its input is found.
 24410                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24411                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24412                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24413                                  ;    else that wants to save the whole shebang and then process other command
 24414                                  ;    lines.
 24415                                  ;
 24416                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24417                                  ;
 24418                                  ; ENTRY:
 24419                                  ;   <Path_Search>:	    argv[0].
 24420                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24421                                  ; EXIT:
 24422                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24423                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24424                                  ; NOTE(S):
 24425                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24426                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24427                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24428                                  ;	does not function as specified; see <Parseline> for more details.
 24429                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24430                                  ;	need to know about. This extra information is stored in a switch_flag
 24431                                  ;	word with each command-line argument; the switches themselves will not
 24432                                  ;	appear in the resulting arg structure.
 24433                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24434                                  ;----------------------------------------------------------------------------
 24435                                  
 24436                                  ; =============== S U B	R O U T	I N E =======================================
 24437                                  
 24438                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24439                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24440                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24441                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24442                                  ; have a match, either in the current working directory if we were handed
 24443                                  ; a filename, or in the specified directory, given a pathname. If this call
 24444                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24445                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24446                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24447                                  ; either the first invocation of search or on one of the succeeding calls
 24448                                  ; sets up the appropriate information for copying the successful pathname
 24449                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24450                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24451                                  ;
 24452                                  ; ENTRY:
 24453                                  ;   argv[0]		--	command name and associated information
 24454                                  ; EXIT:
 24455                                  ;   AX			--	non-zero indicates type of file found
 24456                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24457                                  ; NOTE(S):
 24458                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24459                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24460                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24461                                  ;	if search returns an .exe or .bat.
 24462                                  ;   5)	Clobbers dma address.
 24463                                  
 24464                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24465                                  PATH_SEP_CHAR	EQU	';'
 24466                                  
 24467                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24468                                  
 24469                                  	;special_delim equ 128
 24470                                  	;path_sep equ 4
 24471                                  	;wildcard equ 2
 24472                                  	;sw_flag  equ 1
 24473                                  
 24474                                  ;----------------------------------------------------------------------------
 24475                                  
 24476                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24477                                  
 24478                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24479                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24480                                  
 24481                                  path_search:
 24482 00003190 53                      	push	bx
 24483 00003191 51                      	push	cx
 24484 00003192 52                      	push	dx		; could use a "stack 'em" instruction
 24485 00003193 56                      	push	si
 24486 00003194 57                      	push	di
 24487 00003195 55                      	push	bp
 24488 00003196 9C                      	pushf
 24489                                  
 24490                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24491                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24492 00003197 F606[518E]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24493 0000319C 7403                    	jz	short path_search_ok
 24494                                  path_failure_jmp:
 24495 0000319E E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24496                                  
 24497                                  path_search_ok:
 24498 000031A1 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24499 000031A4 BA[1994]                	mov	dx,FBUF		; clobber old dma value with
 24500 000031A7 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24501 000031AA CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24502                                  			; DS:DX	-> disk	transfer buffer
 24503 000031AC 06                      	push	es
 24504 000031AD E862F1                  	call	find_path	; get a handle (ES:DI) on user path
 24505 000031B0 8C06[4494]              	mov	[pathinfo+0],es	; and squirrel it away
 24506 000031B4 893E[4694]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24507 000031B8 893E[4894]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24508 000031BC 07                      	pop	es
 24509                                  	
 24510 000031BD BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24511 000031C0 BE[E889]                	mov	si,EXECPATH
 24512 000031C3 E88002                  	call	STRIP
 24513 000031C6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24514                                  		
 24515 000031C8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24516 000031CA C706[9994][B17F]        	mov	word [search_error],baddrv_ptr
 24517 000031D0 E89F01                  	call	PSEARCH		; must do at least one search
 24518 000031D3 09C0                    	or	ax,ax		; find anything?
 24519 000031D5 7469                    	jz	short path_noinit
 24520                                  				; failure ... search farther	
 24521 000031D7 89C5                    	mov	bp,ax		; success... save filetype code	
 24522 000031D9 BF[E889]                	mov	di,EXECPATH
 24523                                  	;mov	si,ds:arg.argv[0].argpointer
 24524                                  	;mov	si,[ARG_ARGV]
 24525 000031DC 8B36[4F8E]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24526                                  	;mov	cx,ds:arg.argv[0].argstartel
 24527                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24528 000031E0 8B0E[528E]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24529 000031E4 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24530                                  
 24531                                  ; We have the number of bytes in the prefix (up to the final component).
 24532                                  ; We need to form the complete pathname including leading drive and current
 24533                                  ; directory.
 24534                                  ;
 24535                                  ; Is there a drive letter present?
 24536                                  
 24537 000031E6 B43A                    	mov	ah,':'
 24538 000031E8 83F902                  	cmp	cx,2		; room for drive letter?
 24539 000031EB 7205                    	jb	short adddrive	; no, stick it in
 24540 000031ED 386401                  	cmp	[si+1],	ah	; colon present?
 24541 000031F0 7408                    	je	short movedrive	; yes, just move it
 24542                                  adddrive:
 24543 000031F2 A0[D48A]                	mov	al,[CURDRV]	; get current drive
 24544 000031F5 0441                    	add	al,'A'		; convert to uppercase letter
 24545 000031F7 AB                      	stosw			; store d:
 24546 000031F8 EB05                    	jmp	short checkpath
 24547                                  
 24548                                  movedrive:
 24549 000031FA AD                      	lodsw			; move d:
 24550 000031FB AB                      	stosw
 24551 000031FC 83E902                  	sub	cx,2		; 2 bytes less to move
 24552                                  checkpath:
 24553 000031FF 0C20                    	or	al,20h
 24554 00003201 88C2                    	mov	dl,al		
 24555                                  	;sub	dl,60h
 24556 00003203 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24557                                  
 24558                                  ; Stick in beginning path char
 24559                                  
 24560 00003206 A0[4A94]                	mov	al,[psep_char]
 24561 00003209 AA                      	stosb
 24562                                  
 24563                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24564                                  ; Otherwise, get current dir for DL.
 24565                                  
 24566 0000320A 83F901                  	cmp	cx,1		; is there room for path char?
 24567 0000320D 720A                    	jb	short addpath	; no, go add path
 24568 0000320F AC                      	lodsb
 24569 00003210 49                      	dec	cx
 24570 00003211 3A06[4A94]              	cmp	al,[psep_char]	; is there a path separator?
 24571 00003215 741C                    	je	short movepath	; yes, go move remainder of path
 24572 00003217 41                      	inc	cx
 24573 00003218 4E                      	dec	si		; undo the lodsb
 24574                                  addpath:
 24575 00003219 56                      	push	si
 24576 0000321A 89FE                    	mov	si,di		; remainder of buffer
 24577 0000321C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24578 0000321F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24579                                  			; DL = drive (0=default,1=A,etc.)
 24580                                  			; DS:SI	points to 64-byte buffer area
 24581                                  
 24582                                  ; The previous current dir will succeed a previous find_first already worked.
 24583                                  ;
 24584                                  ; Find end of string.
 24585                                  
 24586 00003221 89F7                    	mov	di,si
 24587 00003223 5E                      	pop	si
 24588 00003224 A0[4A94]                	mov	al,[psep_char]
 24589 00003227 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24590 0000322A 7407                    	jz	short movepath	; yes, no need for path char
 24591                                  scanend:
 24592                                  	;cmp	byte [di],0	; end of string?
 24593                                  	;jz	short foundend
 24594                                  	;inc	di
 24595                                  	;jmp	short scanend
 24596                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24597 0000322C 47                      	inc	di
 24598 0000322D 803D00                  	cmp	byte [di],0
 24599 00003230 75FA                    	jnz	short scanend
 24600                                  
 24601                                  ; Stick in a trailing path char.
 24602                                  
 24603                                  foundend:
 24604 00003232 AA                      	stosb
 24605                                  
 24606                                  ; Move remaining part of path. Skip leading path char if present.
 24607                                  
 24608                                  movepath:
 24609 00003233 3804                    	cmp	[si],al		; first char a path char?
 24610 00003235 7502                    	jne	short copypath
 24611                                  	; 26/04/2023
 24612 00003237 46                      	inc	si		; move past leading char
 24613 00003238 49                      	dec	cx		; drop from count
 24614                                  copypath:
 24615 00003239 E302                    	jcxz	_copydone	; no chars to move!	
 24616 0000323B F3A4                    	rep	movsb
 24617                                  _copydone:
 24618 0000323D E9A100                  	jmp	path_success
 24619                                  				; run off and form complete pathname
 24620                                  path_noinit:
 24621                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24622                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24623 00003240 F606[518E]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24624 00003245 751B                    	jnz	short path_failure
 24625                                  				; complete pathname specified ==> fail
 24626                                  	;mov	bh,';'
 24627 00003247 B73B                    	mov	bh,PATH_SEP_CHAR
 24628                                  				; semicolon terminates pathstring
 24629                                  	;mov	dx,ds:arg.argv[0].argstartel
 24630                                  				; this is where the last element starts
 24631                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24632 00003249 8B16[528E]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24633                                  	;sub	dx,ds:arg.argv[0].argpointer
 24634                                  				; form pointer into EXECPATH,
 24635                                  	;sub	dx,[ARG_ARGV]
 24636 0000324D 2B16[4F8E]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24637 00003251 81C2[E889]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24638                                  path_loop:
 24639 00003255 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24640 00003258 89C5                    	mov	bp,ax		; save filetype code
 24641 0000325A 9F                      	lahf			; save flags, just in case
 24642 0000325B 09ED                    	or	bp,bp		; did path_crunch find anything?		
 24643 0000325D 7508                    	jnz	short path_found 
 24644 0000325F 9E                      	sahf			; see? needed those flags, after all!
 24645 00003260 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24646                                  path_failure:
 24647 00003262 31C0                    	xor	ax,ax
 24648 00003264 E98700                  	jmp	path_exit
 24649                                  
 24650                                  path_found:				; pathinfo[] points to winner
 24651 00003267 BF[E889]                	mov	di,EXECPATH
 24652                                  	;mov	cx,pathinfo[4] 
 24653 0000326A 8B0E[4894]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24654                                  	;mov	si,pathinfo[2]
 24655 0000326E 8B36[4694]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24656                                  
 24657                                  ;	BAS Nov 20/84
 24658                                  ;   Look at the pathname and expand . and .. if they are the first element
 24659                                  ;   in the pathname (after the drive letter)
 24660                                  
 24661 00003272 06                      	push	es
 24662                                  	;push	pathinfo[0]
 24663 00003273 FF36[4494]              	push	word [pathinfo+0]
 24664 00003277 07                      	pop	es
 24665                                  ;SR;
 24666                                  ; Oops! Gets fooled if path= \;..
 24667                                  ; We should also check if a drive letter is really present
 24668                                  ;
 24669 00003278 26807C022E              	cmp	byte [es:si+2],'.'
 24670                                  				; Look for Current dir at start of path
 24671 0000327D 7534                    	jne	short path_cpy
 24672                                  
 24673                                  	; 18/03/2023
 24674                                  	; MSDOS 6.0
 24675 0000327F 26807C013A              	cmp	byte [es:si+1],':'
 24676                                  				; does path have drive letter?
 24677 00003284 752D                    	jne	short path_cpy	; no, copy the path string
 24678                                  
 24679 00003286 51                      	push	cx		; Save pointer to end of string
 24680                                  	;mov	al,[es:si]
 24681                                  	;mov	[di],al		; Copy drive letter, :, and root char
 24682                                  	;mov	al,[es:si+1]	; to EXECPATH
 24683                                  	;mov	[di+1],al
 24684                                  	; 05/05/2023
 24685 00003287 268B04                  	mov	ax,[es:si]
 24686 0000328A 8905                    	mov	[di],ax
 24687 0000328C A0[4A94]                	mov	al,[psep_char]
 24688 0000328F 884502                  	mov	[di+2],al
 24689 00003292 56                      	push	si		; Save pointer to begining of string
 24690 00003293 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 24691 00003296 80CA20                  	or	dl,20h
 24692                                  	;sub	dl,60h
 24693 00003299 80EA60                  	sub	dl,'a'-1
 24694 0000329C 89FE                    	mov	si,di		; pointer to EXECPATH
 24695 0000329E 83C603                  	add	si,3		; Don't wipe out drive and root info
 24696 000032A1 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24697 000032A4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24698                                  			; DL = drive (0=default,1=A,etc.)
 24699                                  			; DS:SI	points to 64-byte buffer area
 24700 000032A6 E8D4F9                  	call	dstrlen		; Determine length of present info
 24701 000032A9 01CE                    	add	si,cx		; Don't copy over drive and root info
 24702 000032AB 4E                      	dec	si
 24703 000032AC 89F7                    	mov	di,si		; Point to end of target string
 24704 000032AE 5E                      	pop	si		; Restore pointer to begining of string
 24705 000032AF 83C603                  	add	si,3		; Point past drive letter, :, .
 24706 000032B2 59                      	pop	cx		; Restore pointer to end of string
 24707                                  path_cpy:
 24708 000032B3 07                      	pop	es
 24709 000032B4 29F1                    	sub	cx,si		; yields character count
 24710 000032B6 1E                      	push	ds		; time to switch segments
 24711 000032B7 FF36[4494]              	push	word [pathinfo+0]
 24712                                  				; string lives in this segment
 24713 000032BB 1F                      	pop	ds
 24714 000032BC FC                      	cld
 24715                                  
 24716                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24717                                  	; MSDOS 5.0 (& MSDOS 5.0)
 24718                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 24719                                  kloop:
 24720 000032BD AC                      	lodsb			;AN000;  3/3/KK
 24721 000032BE AA                      	stosb			;AN000;  3/3/KK
 24722 000032BF E802F1                  	call	testkanj	;AN000;  3/3/KK
 24723 000032C2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 24724 000032C4 49                      	dec	cx		;AN000;  3/3/KK
 24725 000032C5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 24726 000032C7 A4                      	movsb			;AN000;  3/3/KK
 24727 000032C8 49                      	dec	cx		;AN000;  3/3/KK
 24728 000032C9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 24729 000032CC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 24730                                  popdone:			;AN000;  3/3/KK
 24731 000032CE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 24732 000032CF A0[4A94]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 24733 000032D2 EB0C                    	jmp	short path_store
 24734                                  				;AN000;  3/3/KK
 24735                                  _notkanj1:
 24736                                  	; 26/04/2023
 24737 000032D4 E2E7                    	loop	kloop
 24738 000032D6 1F                      	pop	ds		; return to our segment
 24739 000032D7 4F                      	dec	di		; overwrite terminator
 24740 000032D8 A0[4A94]                	mov	al,[psep_char]	; with a pathname separator
 24741 000032DB 3A45FF                  	cmp	al,[di-1]
 24742 000032DE 7401                    	je	short path_success
 24743                                  path_store:
 24744 000032E0 AA                      	stosb
 24745                                  path_success:
 24746 000032E1 BE[4C94]                	mov	si,search_best_buf
 24747 000032E4 31C9                    	xor	cx,cx
 24748                                  path_succ_loop:
 24749 000032E6 AC                      	lodsb			; append winning filename to path
 24750 000032E7 AA                      	stosb			; (including terminating null)	
 24751 000032E8 08C0                    	or	al,al
 24752 000032EA 75FA                    	jnz	short path_succ_loop
 24753 000032EC 89E8                    	mov	ax,bp		; retrieve filetype code
 24754                                  path_exit:
 24755 000032EE 9D                      	popf
 24756 000032EF 5D                      	pop	bp
 24757 000032F0 5F                      	pop	di
 24758 000032F1 5E                      	pop	si		; chill out...
 24759 000032F2 5A                      	pop	dx
 24760 000032F3 59                      	pop	cx
 24761 000032F4 5B                      	pop	bx
 24762 000032F5 C3                      	retn
 24763                                  
 24764                                  ; =============== S U B	R O U T	I N E =======================================
 24765                                  
 24766                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 24767                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 24768                                  ;
 24769                                  ; ENTRY:
 24770                                  ; EXIT:
 24771                                  ; NOTE(S):
 24772                                  ;   *	Uses <psep_char>, defined in <path_search>.
 24773                                  
 24774                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24775                                  STORE_PCHAR:
 24776 000032F6 50                      	push	ax
 24777 000032F7 B02F                    	mov	al,'/'		; is the pathname-element separator
 24778 000032F9 E878F3                  	call	pathchrcmp	; a regular slash?
 24779 000032FC 7402                    	jz	short STORE_SLASH
 24780                                  				; if yes, remember slash
 24781 000032FE B05C                    	mov	al,'\'
 24782                                  	; 18/03/2023
 24783                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 24784                                  	;pop	ax
 24785                                  	;retn
 24786                                  STORE_SLASH:
 24787 00003300 A2[4A94]                	mov	[psep_char],al
 24788 00003303 58                      	pop	ax
 24789 00003304 C3                      	retn
 24790                                  
 24791                                  ; =============== S U B	R O U T	I N E =======================================
 24792                                  
 24793                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 24794                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 24795                                  ; additional separator to use for breaking up the path-string. Null is the
 24796                                  ; default. Once the user-string has been formed, search is invoked to see
 24797                                  ; what's out there.
 24798                                  ;
 24799                                  ; ENTRY:
 24800                                  ;   BH			--	additional terminator character
 24801                                  ;   SI			--	pointer into pathstring to be dissected
 24802                                  ;   DX			--	pointer to stripped filename
 24803                                  ; EXIT:
 24804                                  ;   AX			--	non-zero (file type), zero (nothing found)
 24805                                  ;   SI			--	moves along pathstring from call to call
 24806                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 24807                                  ;   [tpbuf]		--	clobbered
 24808                                  ; NOTE(S):
 24809                                  ;   *	Implicit in this code is the ability to specify when to search
 24810                                  ;	the current directory (if at all) through the PATH defined by
 24811                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 24812                                  ;	current directory before the bin and etc directories of drive c).
 24813                                  
 24814                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24815                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 24816                                  	
 24817                                  path_crunch:
 24818 00003305 53                      	push	bx
 24819 00003306 51                      	push	cx
 24820 00003307 52                      	push	dx
 24821 00003308 57                      	push	di
 24822 00003309 56                      	push	si
 24823                                  	;pushf	; ** ; 18/03/2023
 24824 0000330A E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 24825 0000330D BF[9593]                	mov	di,TPBUF	; destination of concatenated string
 24826 00003310 8B36[4894]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 24827 00003314 8936[4694]              	mov	[pathinfo+2],si	; becomes "old" pointer
 24828 00003318 1E                      	push	ds		; save old segment pointer
 24829 00003319 FF36[4494]              	push	word [pathinfo+0]
 24830                                  				; replace with pointer to userpath's
 24831 0000331D 1F                      	pop	ds		; segment
 24832                                  	; 26/04/2023
 24833 0000331E 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK	
 24834                                  path_cr_copy:
 24835 00003320 AC                      	lodsb			; get a pathname byte
 24836 00003321 08C0                    	or	al,al		; check for terminator(s)
 24837 00003323 7414                    	jz	short path_seg	; null terminates segment & pathstring
 24838 00003325 38F8                    	cmp	al,bh
 24839 00003327 7410                    	je	short path_seg	; BH terminates a pathstring segment
 24840                                  	;
 24841                                  	; 18/03/2023
 24842                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 24843 00003329 E898F0                  	call	testkanj	;AN000; 3/3/KK
 24844 0000332C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 24845 0000332E AA                      	stosb			;AN000; 3/3/KK
 24846 0000332F A4                      	movsb			;AN000; 3/3/KK
 24847 00003330 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK	
 24848 00003332 EBEC                    	jmp	short path_cr_copy
 24849                                  _notkanj2:
 24850 00003334 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 24851                                  	;
 24852 00003336 AA                      	stosb
 24853 00003337 EBE7                    	jmp	short path_cr_copy
 24854                                  
 24855                                  path_seg:
 24856 00003339 1F                      	pop	ds		; restore old data segment
 24857 0000333A 8936[4894]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 24858 0000333E 88C3                    	mov	bl,al		; remember if we saw null or not...
 24859                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 24860 00003340 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 24861 00003342 81FF[9593]              	cmp	di,TPBUF	; was there really anything in pathstr?		
 24862 00003346 7421                    	je	short path_cr_leave
 24863                                  				; if nothing was copied, pathstr empty
 24864                                  path_cr_look:
 24865 00003348 A0[4A94]                	mov	al,[psep_char]	; form complete pathname
 24866                                  	;
 24867                                  	; 18/03/2023
 24868                                  	; MSDOS 6.0
 24869 0000334B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 24870 0000334D 7505                    	jnz	short path_cr_store
 24871                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 24872                                  	;
 24873 0000334F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 24874 00003352 7401                    	je	short path_cr_l1
 24875                                  path_cr_store:
 24876 00003354 AA                      	stosb
 24877                                  path_cr_l1:
 24878 00003355 89D6                    	mov	si,dx
 24879                                  path_cr_l2:
 24880 00003357 AC                      	lodsb			; tack the stripped filename onto
 24881 00003358 AA                      	stosb			; the end of the path, up to and
 24882 00003359 08C0                    	or	al,al		; including the terminating null
 24883 0000335B 75FA                    	jnz	short path_cr_l2
 24884 0000335D BA[9593]                	mov	dx,TPBUF	; and look for an appropriate file...	
 24885 00003360 C706[9994][AD80]        	mov	word [search_error],BADPMES_PTR
 24886                                  	;invoke search
 24887 00003366 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 24888                                  
 24889                                  	; 18/03/2023
 24890                                  ;path_cr_leave:
 24891                                  	;or	bl,bl		; did we finish off the pathstring?
 24892                                  	;jz	short path_cr_empty
 24893                                  	;			; null in BL means all gone...
 24894                                  	;popf	; **		; otherwise, plenty left
 24895                                  	;clc
 24896                                  	;jmp	short path_cr_exit
 24897                                  ;path_cr_empty:
 24898                                  	;popf	; **
 24899                                  	;stc
 24900                                  ;path_cr_exit:
 24901                                  
 24902                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24903                                  path_cr_leave:
 24904                                  	;popf ; ** ; 18/03/2023
 24905 00003369 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 24906                                  	
 24907                                  path_cr_exit:
 24908 0000336C 5E                      	pop	si
 24909 0000336D 5F                      	pop	di
 24910 0000336E 5A                      	pop	dx
 24911 0000336F 59                      	pop	cx
 24912 00003370 5B                      	pop	bx
 24913 00003371 C3                      	retn
 24914                                  
 24915                                  ;============================================================================
 24916                                  ; PATH2.ASM, MSDOS 6.0, 1991
 24917                                  ;============================================================================
 24918                                  ; 02/10/2018 - Retro DOS v3.0
 24919                                  
 24920                                  ;----------------------------------------------------------------------------
 24921                                  ;   SEARCH, when given a pathname, attempts to find a file with
 24922                                  ; one of the following extensions: .com, .exe, .bat (highest to
 24923                                  ; lowest priority). Where conflicts arise, the extension with
 24924                                  ; the highest priority is favored.
 24925                                  ; ENTRY:
 24926                                  ;   DX		--	pointer to null-terminated pathname
 24927                                  ;   fbuf	--	dma buffer for findfirst/next
 24928                                  ; EXIT:
 24929                                  ;   AX		--	8)  file found with .com extension
 24930                                  ;			4)  file found with .exe extension
 24931                                  ;			2)  file found with .bat extension
 24932                                  ;			0)  no such file to be found
 24933                                  ;   (if AX is non-zero:)
 24934                                  ;   [search_best]	identical to AX
 24935                                  ;   [search_best_buf]	null-terminated filename
 24936                                  ; NOTES:
 24937                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 24938                                  ;---------------
 24939                                  ; CONSTANTS:
 24940                                  ;---------------
 24941                                  SEARCH_FILE_NOT_FOUND	EQU	0
 24942                                  SEARCH_COM		EQU	8
 24943                                  SEARCH_EXE		EQU	4
 24944                                  SEARCH_BAT		EQU	2
 24945                                  FNAME_LEN		EQU	8
 24946                                  FNAME_MAX_LEN		EQU	13
 24947                                  DOT			EQU	'.'
 24948                                  WILDCHAR		EQU	'?'
 24949                                  
 24950                                  
 24951                                  ; =============== S U B	R O U T	I N E =======================================
 24952                                  
 24953                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 24954                                  
 24955                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24956                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 24957                                  	
 24958                                  PSEARCH:
 24959 00003372 51                      	push	cx
 24960 00003373 52                      	push	dx
 24961 00003374 57                      	push	di
 24962 00003375 56                      	push	si
 24963                                  	;pushf	; ** ; 18/03/2023
 24964 00003376 52                      	push	dx		; check drivespec (save pname ptr)
 24965 00003377 89D7                    	mov	di,dx		; working copy of pathname
 24966 00003379 BE[5994]                	mov	si,search_curdir_buf
 24967 0000337C 31D2                    	xor	dx,dx		; zero means current drive
 24968 0000337E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 24969 00003382 7508                    	jne	short SEARCH_DIR_CHECK
 24970 00003384 8A15                    	mov	dl,[di]		; get the drive byte
 24971 00003386 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 24972 00003389 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 24973                                  SEARCH_DIR_CHECK:
 24974 0000338C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24975 0000338F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24976                                  			; DL = drive (0=default,1=A,etc.)
 24977                                  			; DS:SI	points to 64-byte buffer area
 24978 00003391 5A                      	pop	dx		; directory? If we can't we'll		
 24979 00003392 724C                    	jc	short SEARCH_INVALID_DRIVE
 24980                                  				; assume it's a bad drive...
 24981 00003394 B91300                  	mov	cx,search_attr	; 13h
 24982                                  				; filetypes to search for
 24983 00003397 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 24984 0000339A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 24985                                  			; CX = search attributes
 24986                                  			; DS:DX	-> ASCIZ filespec
 24987                                  			; (drive,path, and wildcards allowed)
 24988 0000339C 7249                    	jc	short SEARCH_NO_FILE
 24989 0000339E C606[4B94]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 24990 000033A3 C606[4C94]00            	mov	byte [search_best_buf],ANULL
 24991                                  				; 0 ; nothing's been found, yet
 24992                                  SEARCH_LOOP:
 24993 000033A8 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 24994 000033AB 3A06[4B94]              	cmp	al,[search_best]
 24995                                  				; better than what we've found so far?
 24996 000033AF 7E13                    	jle	short SEARCH_NEXT
 24997                                  				; no, look for another	
 24998 000033B1 A2[4B94]                	mov	[search_best],al
 24999                                  				; found something... save its code	
 25000                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25001                                  	;mov	si,FBUF_PNAME
 25002 000033B4 BE[3794]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25003 000033B7 BF[4C94]                	mov	di,search_best_buf
 25004 000033BA B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25005 000033BD FC                      	cld
 25006 000033BE F3A4                    	rep	movsb		; save complete pathname representation
 25007 000033C0 3C08                    	cmp	al,SEARCH_COM	; 8
 25008                                  				; have we found the best of all?	
 25009 000033C2 740A                    	je	short SEARCH_DONE
 25010                                  SEARCH_NEXT:			; keep on looking
 25011 000033C4 B91300                  	mov	cx,search_attr ; 13h
 25012 000033C7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25013 000033CA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25014                                  			; [DTA]	= data block from
 25015                                  			; last AH = 4Eh/4Fh call
 25016 000033CC 73DA                    	jnc	short SEARCH_LOOP
 25017                                  SEARCH_DONE:			; it's all over with...
 25018 000033CE A0[4B94]                	mov	al,[search_best]
 25019                                  				; pick best to return with
 25020                                  	; 18/03/2023
 25021                                  	; MSDOS 6.0
 25022 000033D1 803E[058E]01            	cmp	byte [ext_entered],1
 25023                                  				;AN005; Did user request a specific ext?
 25024 000033D6 7411                    	je	short SEARCH_EXIT
 25025                                  				;AN005; no - exit
 25026 000033D8 A0[058E]                	mov	al,[ext_entered]
 25027                                  				;AN005; yes - get the real file type back
 25028 000033DB A2[4B94]                	mov	[search_best],al
 25029                                  				;AN005; save the real file type
 25030                                  	;
 25031 000033DE EB09                    	jmp	short SEARCH_EXIT
 25032                                  
 25033                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25034 000033E0 8B16[9994]              	mov	dx,[search_error]
 25035                                  				; appropriate error message
 25036 000033E4 E83C1A                  	call	std_printf	; and pretend no file found
 25037                                  
 25038                                  SEARCH_NO_FILE:			; couldn't find a match
 25039                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25040                                  	; 18/03/2023
 25041 000033E7 31C0                    	xor	ax,ax
 25042                                  SEARCH_EXIT:
 25043                                  	;popf	; ** ; 18/03/2023
 25044 000033E9 5E                      	pop	si
 25045 000033EA 5F                      	pop	di
 25046 000033EB 5A                      	pop	dx
 25047 000033EC 59                      	pop	cx
 25048 000033ED C3                      	retn
 25049                                  
 25050                                  ; =============== S U B	R O U T	I N E =======================================
 25051                                  
 25052                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25053                                  ;
 25054                                  ; ENTRY:
 25055                                  ;   fbuf    --	dma buffer containing filename
 25056                                  ; EXIT:
 25057                                  ;   AX	    --	file code, as given in search header
 25058                                  ; NOTE(S):
 25059                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25060                                  
 25061                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25062                                  
 25063                                  SEARCH_FTYPE:
 25064 000033EE 57                      	push	di
 25065 000033EF 56                      	push	si
 25066                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25067                                  	; 18/02/2023
 25068 000033F0 31C0                    	xor	ax,ax ; ax = 0		
 25069                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25070                                  	;mov	di,FBUF_PNAME
 25071 000033F2 BF[3794]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25072 000033F5 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25073 000033F8 FC                      	cld
 25074 000033F9 F2AE                    	repnz	scasb		; search for the terminating null
 25075 000033FB 7535                    	jnz	short FTYPE_EXIT
 25076                                  				; weird... no null byte at end
 25077 000033FD 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25078                                  
 25079                                  	; Compare .COM
 25080                                  
 25081 00003400 BE[7F84]                	mov	si,comext ; ".COM"
 25082 00003403 89F8                    	mov	ax,di
 25083 00003405 A7                      	cmpsw
 25084 00003406 7508                    	jnz	short FTYPE_EXE
 25085 00003408 A7                      	cmpsw
 25086 00003409 7505                    	jnz	short FTYPE_EXE
 25087                                  	;mov	ax,8
 25088 0000340B B80800                  	mov	ax,SEARCH_COM	; success!
 25089 0000340E EB22                    	jmp	short FTYPE_EXIT
 25090                                  
 25091                                  	; Compare .EXE
 25092                                  FTYPE_EXE:			; still looking... now for '.exe'
 25093 00003410 89C7                    	mov	di,ax
 25094 00003412 BE[8384]                	mov	si,exeext ; ".EXE"
 25095 00003415 A7                      	cmpsw
 25096 00003416 7508                    	jnz	short FTYPE_BAT
 25097 00003418 A7                      	cmpsw
 25098 00003419 7505                    	jnz	short FTYPE_BAT
 25099                                  	;mov	ax,4
 25100 0000341B B80400                  	mov	ax,SEARCH_EXE	; success!
 25101 0000341E EB12                    	jmp	short FTYPE_EXIT
 25102                                  
 25103                                  	; Compare .BAT
 25104                                  FTYPE_BAT:			; still looking... now for '.bat'
 25105 00003420 89C7                    	mov	di,ax
 25106 00003422 BE[8784]                	mov	si,batext ; ".BAT"
 25107 00003425 A7                      	cmpsw
 25108 00003426 7508                    	jnz	short FTYPE_FAIL
 25109 00003428 A7                      	cmpsw
 25110 00003429 7505                    	jnz	short FTYPE_FAIL
 25111                                  	;mov	ax,2
 25112 0000342B B80200                  	mov	ax,SEARCH_BAT	; success!
 25113 0000342E EB02                    	jmp	short FTYPE_EXIT
 25114                                  
 25115                                  FTYPE_FAIL:			; file doesn't match what we need
 25116                                  	;mov	ax,ANULL ; 0
 25117                                  	; 18/03/2023
 25118 00003430 29C0                    	sub	ax,ax  ; ax = 0
 25119                                  FTYPE_EXIT:
 25120                                  	; 18/03/2023
 25121                                  	; MSDOS 6.0
 25122 00003432 803E[058E]01            	cmp	byte [ext_entered],1
 25123                                  				;AN005; was an extension entered?
 25124 00003437 740A                    	jz	short FTYPE_DONE
 25125                                  				;AN005; no - exit
 25126                                  	;cmp	ax,ANULL	;AN005; was any match found
 25127 00003439 21C0                    	and	ax,ax  ; ax = 0 ?
 25128 0000343B 7406                    	jz	short FTYPE_DONE
 25129                                  				;AN005; no - exit
 25130 0000343D A2[058E]                	mov	[ext_entered],al
 25131                                  				;AN005; save the match type found
 25132 00003440 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25133                                  FTYPE_DONE:
 25134 00003443 5E                      	pop	si
 25135 00003444 5F                      	pop	di
 25136 00003445 C3                      	retn
 25137                                  
 25138                                  ; =============== S U B	R O U T	I N E =======================================
 25139                                  
 25140                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25141                                  ; replacing any extension with wildcards.
 25142                                  ;
 25143                                  ; ENTRY:
 25144                                  ;	BX	--	maximum length of destination buffer
 25145                                  ;	DS:SI	--	address of destination buffer
 25146                                  ;	argv[0] --	command name to be stripped
 25147                                  ; EXIT:
 25148                                  ;	CF	--	set if failure, clear if successful
 25149                                  ; NOTE(S):
 25150                                  
 25151                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25152                                  
 25153                                  STRIP:
 25154 00003446 50                      	push	ax
 25155 00003447 53                      	push	bx
 25156 00003448 51                      	push	cx
 25157 00003449 52                      	push	dx
 25158 0000344A 57                      	push	di
 25159 0000344B 56                      	push	si
 25160                                  	;pushf	; ** ; 18/03/2023
 25161                                  		
 25162                                  	; 05/05/2023
 25163                                  	; MSDOS 6.0
 25164 0000344C C606[058E]01            	mov	byte [ext_entered],1
 25165                                  				;AN005; assume no extension on file name
 25166                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25167                                  	;mov	dx,[ARG_ARGV]
 25168                                  	;mov	dx,ds:arg.argv[0].argpointer
 25169                                  				; save pointer to beginning of argstring
 25170                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25171 00003451 8B16[4F8E]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25172                                  	;mov	di,ds:arg.argv[0].argstartel
 25173                                  				; beginning of last pathname element
 25174                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25175 00003455 8B3E[528E]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25176 00003459 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25177 0000345C 743D                    	je	short STRIP_ERROR
 25178 0000345E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25179                                  	;add	cx,ds:arg.argv[0].arglen
 25180                                  	;add	cx,[ARGV0_ARGLEN]
 25181 00003460 030E[548E]              	add	cx,[ARG+ARGV_ELE.arglen]
 25182 00003464 29F9                    	sub	cx,di		; and then find length of last element
 25183 00003466 41                      	inc	cx		; include null as well
 25184 00003467 B02E                    	mov	al,'.'
 25185                                  	;mov	al,DOT		; let's find the filetype extension
 25186 00003469 FC                      	cld
 25187 0000346A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25188                                  
 25189                                  	; 18/03/2023
 25190                                  	; MSDOS 6.0
 25191 0000346C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25192 0000346E B000                    	mov	al,0 ; 18/03/2023
 25193                                  	;mov	byte [ext_entered],0
 25194 00003470 A2[058E]                	mov	[ext_entered],al
 25195                                  				;AN005; we found an extension
 25196                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25197                                  	;mov	al,0
 25198 00003473 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25199                                  PROCESS_EXT:
 25200                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25201 00003475 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25202 00003477 29D1                    	sub	cx,dx		; number of bytes to be copied
 25203 00003479 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25204 0000347C 39D9                    	cmp	cx,bx
 25205 0000347E 7F1B                    	jg	short STRIP_ERROR
 25206                                  				; if not, we must have a bad pathname
 25207 00003480 89F7                    	mov	di,si		; destination buffer
 25208 00003482 89D6                    	mov	si,dx		; source is beginning of pathname
 25209 00003484 FC                      	cld
 25210 00003485 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25211                                  
 25212                                  	; 18/03/2023
 25213                                  	; MSDOS 6.0
 25214 00003487 803E[058E]01            	cmp	byte [ext_entered],1
 25215                                  				;AN005; if an extension was entered
 25216 0000348C 750A                    	jne	short SKIP_WILDS
 25217                                  				;AN005;    don't set up wildcard ext.
 25218                                  
 25219                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25220 0000348E 4F                      	dec	di		; overwrite null or dot
 25221 0000348F AA                      	stosb			; with a dot
 25222 00003490 B03F                    	mov	al,'?'
 25223                                  	;mov	al,WILDCHAR	; now add wildcards
 25224 00003492 AA                      	stosb
 25225 00003493 AA                      	stosb
 25226 00003494 AA                      	stosb
 25227 00003495 B000                    	mov	al,0
 25228                                  	;mov	al,ANULL	; and a terminating null	
 25229 00003497 AA                      	stosb
 25230                                  SKIP_WILDS:
 25231                                  	;popf	; ** ; 18/03/2023
 25232 00003498 F8                      	clc
 25233 00003499 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25234                                  
 25235                                  STRIP_ERROR:
 25236                                  	;popf	; ** ; 18/03/2023
 25237 0000349B F9                      	stc
 25238                                  STRIP_EXIT:
 25239 0000349C 5E                      	pop	si
 25240 0000349D 5F                      	pop	di
 25241 0000349E 5A                      	pop	dx
 25242 0000349F 59                      	pop	cx
 25243 000034A0 5B                      	pop	bx
 25244 000034A1 58                      	pop	ax
 25245 000034A2 C3                      	retn
 25246                                  
 25247                                  ; =============== S U B	R O U T	I N E =======================================
 25248                                  
 25249                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25250                                  ;
 25251                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25252                                  ; beginning of this area. The caller indicates how much extra space is
 25253                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25254                                  ; an offset into that area, indicating where the caller may preserve its own
 25255                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25256                                  ; ENTRY:
 25257                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25258                                  ; EXIT:
 25259                                  ;   AX	    --	segment of new area.
 25260                                  ;   CF	    --	set if unable to save a copy.
 25261                                  ; NOTE(S):
 25262                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25263                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25264                                  ;	paragraphs.
 25265                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25266                                  ;	as the caller of Save_Args requests.
 25267                                  ;   3)	AX is undefined if CF indicates an error.
 25268                                  
 25269                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25270                                  
 25271                                  SAVE_ARGS:
 25272 000034A3 53                      	push	bx
 25273 000034A4 51                      	push	cx
 25274 000034A5 52                      	push	dx
 25275 000034A6 57                      	push	di
 25276 000034A7 56                      	push	si
 25277 000034A8 55                      	push	bp
 25278                                  	; 01/05/2023
 25279                                  	; 26/04/2023
 25280                                  	;pushf ; **
 25281                                  	;add	bx,1363		; space for arg structure, round up
 25282 000034A9 81C35305                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25283 000034AD B104                    	mov	cl,4		; to paragraph size and convert
 25284 000034AF D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25285 000034B1 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25286 000034B4 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25287                                  			; BX = number of 16-byte paragraphs desired
 25288 000034B6 7242                    	jc	short SAVE_ERROR ; ***
 25289 000034B8 89C5                    	mov	bp,ax		; save segment id
 25290 000034BA 06                      	push	es		; save TRANGROUP address
 25291 000034BB 8EC0                    	mov	es,ax		; switch to new memory segment
 25292                                  	; assume es:nothing
 25293                                  	;mov	cx,1348		; get back structure size
 25294 000034BD B94405                  	mov	cx,ARG_UNIT.SIZE
 25295 000034C0 31FF                    	xor	di,di		; destination is new memory area
 25296                                  	;mov	si,ARG_ARGV
 25297 000034C2 BE[4F8E]                	mov	si,ARG		; source is arg structure
 25298 000034C5 F3A4                    	rep	movsb		; move that sucker!
 25299                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25300                                  	;mov	cx,[ARG_ARGVCNT]
 25301 000034C7 8B0E[0F91]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25302 000034CB 31C0                    	xor	ax,ax		; base address for argv_calc
 25303                                  
 25304                                  ;	Bugbug:	What did they mean by this?
 25305                                  ;	Note that the replacement line produces exactly the same code.
 25306                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25307                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25308                                  
 25309                                  	;mov	si,ARG_ARGV
 25310 000034CD BE[4F8E]                	mov	si,ARG	
 25311                                  SAVE_PTR_LOOP:
 25312 000034D0 49                      	dec	cx		; exhausted all args?
 25313 000034D1 7C24                    	jl	short SAVE_DONE
 25314 000034D3 89CB                    	mov	bx,cx		; get arg index and
 25315 000034D5 E8A0FC                  	call	argv_calc	; convert to a pointer
 25316                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25317                                  	;mov	dx,[ARG_ARGV+bx]
 25318 000034D8 8B97[4F8E]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25319 000034DC 29F2                    	sub	dx,si		; adjust argpointer
 25320                                  	;mov	es:argv[BX].argpointer,dx
 25321                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25322 000034DE 268917                  	mov	[es:bx],dx
 25323                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25324                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25325 000034E1 8B97[528E]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25326 000034E5 29F2                    	sub	dx,si		; and adjust argstartel
 25327                                  	;mov	es:argv[bx].argstartel,dx
 25328                                  	;mov	[es:bx+3],dx
 25329 000034E7 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25330                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25331                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25332 000034EB 8B97[588E]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25333 000034EF 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25334                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25335                                  	;mov	[es:bx+9],dx
 25336 000034F1 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25337 000034F5 EBD9                    	jmp	short SAVE_PTR_LOOP
 25338                                  SAVE_DONE:
 25339 000034F7 07                      	pop	es		; back we go to TRANGROUP
 25340                                  	; assume es:nothing
 25341 000034F8 89E8                    	mov	ax,bp		; restore segment id
 25342                                  	; 26/04/2023
 25343                                  	; cf = 0 ; *
 25344                                  	;jmp	short SAVE_OK
 25345                                  
 25346                                  	; 26/04/2023
 25347                                  ;SAVE_ERROR:
 25348                                  ;	; 26/04/2023
 25349                                  ;	;popf ; **
 25350                                  ;	stc
 25351                                  ;	jmp	short SAVE_EXIT
 25352                                  
 25353                                  SAVE_OK:
 25354                                  	; 26/04/2023
 25355                                  	;popf ; **
 25356                                  	; 26/04/2023
 25357                                  	; cf = 0 ; *
 25358                                  	;clc
 25359                                  SAVE_EXIT:
 25360                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25361 000034FA 5D                      	pop	bp
 25362 000034FB 5E                      	pop	si
 25363 000034FC 5F                      	pop	di
 25364 000034FD 5A                      	pop	dx
 25365 000034FE 59                      	pop	cx
 25366 000034FF 5B                      	pop	bx
 25367                                  answ_no:	; 26/04/2023
 25368 00003500 C3                      	retn
 25369                                  
 25370                                  ;============================================================================
 25371                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25372                                  ;============================================================================
 25373                                  ; 02/10/2018 - Retro DOS v3.0
 25374                                  
 25375                                  ; Title	COMMAND Language midifiable Code Transient
 25376                                  
 25377                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25378                                  
 25379                                  ; =============== S U B	R O U T	I N E =======================================
 25380                                  
 25381                                  ; ****************************************************************
 25382                                  ; *
 25383                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25384                                  ; *
 25385                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25386                                  ; *		 user for Y/N if necessary. If an error occurs,
 25387                                  ; *		 set up an error message and go to CERROR.
 25388                                  ; *
 25389                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25390                                  ; *		 Current directory set to entered directory
 25391                                  ; *
 25392                                  ; * OUTPUT:	 none
 25393                                  ; *
 25394                                  ; ****************************************************************
 25395                                  ;
 25396                                  ; ARE YOU SURE prompt when deleting *.*
 25397                                  
 25398                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25399                                  
 25400                                  notest2:
 25401 00003501 B90B00                  	mov	cx,11
 25402 00003504 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25403                                  ambspec:
 25404 00003507 AC                      	lodsb
 25405 00003508 3C3F                    	cmp	al,'?'
 25406 0000350A 7502                    	jne	short allfil
 25407 0000350C E2F9                    	loop	ambspec
 25408                                  allfil:
 25409                                  	; 19/03/2023
 25410                                  	;cmp	cx,0
 25411 0000350E 09C9                    	or	cx,cx
 25412 00003510 752E                    	jnz	short noprmpt
 25413                                  askagn:	
 25414 00003512 BA[3480]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25415 00003515 E80B19                  	call	std_printf
 25416 00003518 BE8000                  	mov	si,80h
 25417 0000351B 89F2                    	mov	dx,si
 25418 0000351D C7047800                	mov	word [si],120	; zero length
 25419                                  	;mov	ax,0C0Ah
 25420 00003521 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25421 00003524 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25422                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25423 00003526 AD                      	lodsw
 25424 00003527 08E4                    	or	ah,ah
 25425 00003529 74E7                    	jz	short askagn
 25426 0000352B E8B8F0                  	call	scanoff
 25427                                  	; 19/03/2023
 25428                                  	; MSDOS 6.0
 25429 0000352E E80C02                  	call	char_in_xlat	; Convert to upper case
 25430                                  	;retc			; return if function not supported
 25431                                  	; 19/03/2023
 25432                                  	;jnc	short check_yn
 25433                                  ;answ_no:
 25434                                  	;retn
 25435 00003531 72CD                    	jc	short answ_no
 25436                                  
 25437                                  	; 19/03/2023
 25438                                  	; AL = 0 if it was (country depended) NO character
 25439                                  	; AL = 1 if it was (country depenced) YES character
 25440                                  
 25441                                  	; MSDOS 3.3
 25442                                  	;call	UPCONV
 25443                                  
 25444                                  	; 19/03/2023	
 25445                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25446                                  	;cmp	al,[CAPITAL_N]
 25447                                  	;jne	short CHECK_Y
 25448                                  	;retn
 25449                                  ;CHECK_Y:
 25450                                  	;cmp	al,[CAPITAL_Y]
 25451                                  	;pushf
 25452                                  	;call	CRLF2
 25453                                  	;popf
 25454                                  	;jne	short ASKAGN
 25455                                  
 25456                                  check_yn:
 25457                                  	; 19/03/2023
 25458                                  	;cmp	al,0	; NO character
 25459 00003533 08C0                    	or	al,al
 25460 00003535 74C9                    	jz	short answ_no
 25461                                  	;cmp	al,1	 ;YES character
 25462 00003537 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25463 00003539 9C                      	pushf
 25464 0000353A E89CF0                  	call	CRLF2
 25465 0000353D 9D                      	popf
 25466 0000353E 75D2                    	jnz	short askagn
 25467                                  noprmpt:
 25468 00003540 B413                    	mov	ah,FCB_Delete ; 13h
 25469 00003542 BA5C00                  	mov	dx,FCB ; 5Ch
 25470 00003545 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25471                                  			; DS:DX	-> FCB with filename field filled with
 25472                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25473                                  			; Return: AL = 00h file	found,FFh file	not found
 25474 00003547 FEC0                    	inc	al
 25475 00003549 7403                    	jz	short eraerr
 25476                                  	; 26/04/2023
 25477                                  	;call	RestUDir
 25478                                  ;answ_no:
 25479                                  	;retn
 25480 0000354B E945EF                  	jmp	RestUDir ; 26/04/2023
 25481                                  
 25482                                  	; 19/03/2023
 25483                                  	; MSDOS 6.0
 25484                                  eraerr:
 25485                                  	;invoke	set_ext_error_msg
 25486                                  				;AN022; set up the extended error
 25487 0000354E E8A1E7                  	call	Set_Ext_Error_Msg
 25488 00003551 52                      	push	dx		;AN022; save message
 25489                                  	;invoke	RESTUDIR
 25490 00003552 E83EEF                  	call	RestUDir
 25491 00003555 5A                      	pop	dx		;AN022; restore message
 25492                                  	
 25493 00003556 833E[557F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25494                                  				;AN022; convert no more files to
 25495 0000355B 7506                    	jne	short cerrorj2	;AN022;  file not found
 25496 0000355D C706[557F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25497                                  				;AN000; get message number in control block
 25498                                  cerrorj2:
 25499 00003563 E9F4F3                  	jmp	cerror
 25500                                  	
 25501                                  	; 19/03/2023
 25502                                  	; MSDOS 3.3
 25503                                  ;ERAERR:	
 25504                                  	;mov	ah,Set_DMA ; 1Ah
 25505                                  	;mov	dx,FCB ; 5Ch
 25506                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25507                                  	;			; DS:DX	-> disk	transfer buffer
 25508                                  	;mov	ah,Dir_Search_First ; 11h
 25509                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25510                                  	;			; DS:DX	-> FCB
 25511                                  	;push	ax
 25512                                  	;call	RESTUDIR
 25513                                  	;pop	ax
 25514                                  	;mov	dx,FNOTFOUNDPTR
 25515                                  	;inc	al
 25516                                  	;jz	short CERRORJ
 25517                                  	;mov	dx,ACCDENPTR
 25518                                  	;jmp	CERROR
 25519                                  
 25520                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25521                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25522                                  
 25523                                  ; ****************************************************************
 25524                                  ; *
 25525                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25526                                  ; *
 25527                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25528                                  ; *		 user for Y/N where necessary. If an error occurs
 25529                                  ; *		 set up and error message and transfer control
 25530                                  ; *		 to CERROR.
 25531                                  ; *
 25532                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25533                                  ; *		 Current directory set to entered directory
 25534                                  ; *
 25535                                  ; * OUTPUT:	 none
 25536                                  ; *
 25537                                  ; ****************************************************************
 25538                                  
 25539                                  	; 19/03/2023
 25540                                  slashp_erase:				;AN000; entry point
 25541                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25542 00003566 E8E2E8                  	call	build_dir_string
 25543                                  
 25544 00003569 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25545                                  	;mov	dx,offset trangroup:destdir
 25546 0000356B BA[868B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25547 0000356E CD21                    	int	21h			;AN000;
 25548                                  
 25549                                  	;mov	ah,11h
 25550 00003570 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25551 00003572 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25552 00003575 CD21                    	int	21h			;AN000;
 25553 00003577 FEC0                    	inc	al			;AN000; did an error occur
 25554                                  	;jz	short eraerr		;AN022; go to error exit
 25555                                  	; 26/04/2023
 25556 00003579 7502                    	jnz	short delete_prompt_loop
 25557                                  
 25558                                  	; 26/04/2023
 25559                                  stop_del:
 25560 0000357B EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25561                                  
 25562                                  delete_prompt_loop:			;AN000;
 25563                                  	;mov	si,offset trangroup:destdir+1
 25564 0000357D BE[878B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25565                                  	;mov	di,offset trangroup:dest
 25566 00003580 BF[568B]                	mov	di,DEST			;AN000; set up dest as target
 25567 00003583 A0[C58A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25568 00003586 AA                      	stosb				;AN000;   of DEST
 25569                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25570 00003587 E87BF0                  	call	FCB_TO_ASCZ
 25571                                  
 25572                                  slashp_askagn:				;AN000;
 25573 0000358A E84CF0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25574                                  	;mov	dx,offset trangroup:bwdbuf
 25575 0000358D BA[C98B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25576 00003590 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25577 00003592 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25578                                  					;AN000; see if only D:\,0
 25579 00003596 7504                    	jnz	short not_del_root	;AN000; no continue
 25580 00003598 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25581                                  					;AN000; yes, get rid of \ ;
 25582                                  not_del_root:				;AN000;
 25583 0000359C 8916[B08C]              	mov	[string_ptr_2],dx 	;AN000;
 25584                                  	;mov	dx,offset trangroup:string_buf_ptr
 25585 000035A0 BA[1C81]                	mov	dx,string_buf_ptr	;AN000;
 25586                                  	;invoke	std_printf		;AN000;
 25587 000035A3 E87D18                  	call	std_printf
 25588                                  	;mov	dx,offset trangroup:dest
 25589 000035A6 BA[568B]                	mov	dx,DEST			;AN000; print out file name string
 25590 000035A9 8916[B08C]              	mov	[string_ptr_2],dx 	;AN000;
 25591                                  	;mov	dx,offset trangroup:string_buf_ptr
 25592 000035AD BA[1C81]                	mov	dx,string_buf_ptr	;AN000;
 25593                                  	;invoke	std_printf		;AN000;
 25594 000035B0 E87018                  	call	std_printf
 25595                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25596 000035B3 BA[3180]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25597                                  	;invoke	std_printf		;AN000;
 25598 000035B6 E86A18                  	call	std_printf
 25599                                  
 25600                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25601                                  ;;M029	mov	dx,si			;AN000;
 25602                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25603                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25604                                  ;;M029	int	21h			;AN000; get input from the user
 25605                                  ;;M029	lodsw				;AN000;
 25606                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25607                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25608                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25609                                  
 25610                                  ;	Get a single character input.
 25611                                  
 25612                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25613                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25614 000035B9 B8010C                  	mov	ax,0C01h
 25615 000035BC CD21                    	int	21h			;M029
 25616                                  
 25617 000035BE E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25618                                  	;retc				;AN000; return if function not supported
 25619                                  	; 19/03/2023
 25620 000035C1 7301                    	jnc	short slashp_check_yn
 25621                                  slashp_ans_no:
 25622 000035C3 C3                      	retn
 25623                                  
 25624                                  slashp_check_yn:
 25625                                  	; 19/03/2023
 25626                                  	; AL = 0 if it was (country depended) NO character
 25627                                  	; AL = 1 if it was (country depenced) YES character
 25628                                  
 25629                                  	;cmp	al,capital_n		;AN000; was it no?
 25630                                  	;cmp	al,0
 25631 000035C4 20C0                    	and	al,al ; 0
 25632 000035C6 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25633                                  	;cmp	al,capital_y		;AN000; was it yes?
 25634                                  	;cmp	al,1
 25635 000035C8 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25636                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25637                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25638                                  	; 19/03/2023
 25639 000035CA 75BE                    	jnz	short slashp_askagn
 25640                                  
 25641                                  delete_this_file:			;AN000;
 25642 000035CC B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25643                                  	;mov	dx,offset trangroup:destdir
 25644 000035CE BA[868B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25645 000035D1 CD21                    	int	21h			;AN000;
 25646 000035D3 FEC0                    	inc	al			;AN000; did an error occur?
 25647 000035D5 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25648                                  ;
 25649                                  ;M041; Begin changes
 25650                                  ; We got an error deleting the file. If this is access denied, we can go on
 25651                                  ;to the next file after printing an error message.
 25652                                  ;
 25653                                  	;invoke	Get_ext_error_number	;see what error we got
 25654 000035D7 E828E7                  	call	get_ext_error_number
 25655 000035DA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25656                                  					;is it access denied?
 25657 000035DD 759C                    	jne	short stop_del		;no, some other error
 25658                                  	;invoke	CrLf2			;print a CR-LF
 25659 000035DF E8F7EF                  	call	CRLF2
 25660                                  	;invoke set_ext_error_msg	;error message
 25661 000035E2 E80DE7                  	call	Set_Ext_Error_Msg
 25662                                  	;invoke	std_eprintf		;"Access denied"
 25663 000035E5 E83318                  	call	std_eprintf
 25664                                  	; 26/04/2023
 25665                                  	;jmp	short next_del_file	;try next file
 25666                                  	; 26/04/2023
 25667                                  ;stop_del:
 25668                                  ;;
 25669                                  ;;M041; End changes
 25670                                  ;;
 25671                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 25672                                  
 25673                                  next_del_file:				;AN000;
 25674                                  ;
 25675                                  ; M050 - begin
 25676                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 25677                                  ;       with /protect+ and /light+ makes it intercept all
 25678                                  ;       deletes. This hook does not save and restore the DTA correctly.
 25679                                  ;       They save the DWORD in a WORD by mistake! They save both the
 25680                                  ;       segment and the offset in the SAME variable (WORD)!!!
 25681                                  ;
 25682 000035E8 B41A                    	mov	ah,Set_DMA ; 1Ah
 25683                                  	;mov	dx,offset trangroup:destdir
 25684 000035EA BA[868B]                	mov	dx,DESTDIR
 25685 000035ED CD21                    	int	21h
 25686                                  ;
 25687                                  ; M050 - end
 25688                                  
 25689 000035EF B412                    	mov	ah,Dir_Search_Next ; 12h
 25690                                  					;AN000; search for another file
 25691 000035F1 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 25692 000035F4 CD21                    	int	21h			;AN000;
 25693 000035F6 FEC0                    	inc	al			;AN000; was a file found?
 25694                                  	;jz	short slash_p_exit	;AN000; no - exit
 25695                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 25696                                  	; 26/04/2023
 25697 000035F8 7583                    	jnz	short delete_prompt_loop
 25698                                  
 25699                                  slash_p_exit:
 25700                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 25701 000035FA E805E7                  	call	get_ext_error_number
 25702 000035FD 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 25703 00003600 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 25704 00003602 E93DE4                  	jmp	extend_setup		;AN022; go issue error message
 25705                                  
 25706                                  good_erase_exit:
 25707                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 25708 00003605 E88BEE                  	call	RestUDir
 25709                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 25710                                  	;retn				;AN000; exit
 25711                                  	; 19/03/2023
 25712 00003608 E9CEEF                  	jmp	CRLF2
 25713                                  
 25714                                  ; =============== S U B	R O U T	I N E =======================================
 25715                                  
 25716                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 25717                                  
 25718                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25719                                  _ECHO:
 25720 0000360B E89900                  	call	ON_OFF
 25721 0000360E 7212                    	jb	short DOEMES
 25722 00003610 8E1E[C08A]              	mov	ds,[RESSEG]
 25723 00003614 7506                    	jnz	short ECH_OFF
 25724 00003616 800E[A001]01            	or	byte [EchoFlag],1
 25725 0000361B C3                      	retn
 25726                                  
 25727                                  ECH_OFF:
 25728 0000361C 8026[A001]FE            	and	byte [EchoFlag],0FEh
 25729 00003621 C3                      	retn
 25730                                  
 25731                                  	; 19/03/2023
 25732                                  	; MSDOS 6.0 (& MSDOS 5.0)
 25733                                  ;CERRORJ:
 25734                                  	;jmp	cerror
 25735                                  
 25736                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 25737                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 25738                                  
 25739                                  DOEMES:
 25740                                  	; 19/03/2023
 25741                                  	; MSDOS 6.0
 25742                                  	;cmp	cl,0		;AC000; was anything on the line?
 25743 00003622 20C9                    	and	cl,cl
 25744 00003624 7409                    	jz	short PECHO	; just display current state.
 25745 00003626 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 25746 00003629 E806F0                  	call	CRPRINT
 25747 0000362C E9AAEF                  	jmp	CRLF2
 25748                                  
 25749                                  	; 19/03/2023
 25750                                  	; MSDOS 3.3
 25751                                  	;call	MOVE_TO_FIRST_ARG
 25752                                  	;jz	short PECHO
 25753                                  	;mov	dx,82h
 25754                                  	;call	CRPRINT
 25755                                  	;jmp	CRLF2
 25756                                  
 25757                                  PECHO:
 25758                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25759 0000362F 8E1E[C08A]              	mov	ds,[RESSEG]
 25760 00003633 8A1E[A001]              	mov	bl,[EchoFlag]
 25761 00003637 0E                      	push	cs
 25762 00003638 1F                      	pop	ds
 25763 00003639 80E301                  	and	bl,1
 25764 0000363C BA[D880]                	mov	dx,EchoMes_Ptr
 25765 0000363F EB24                    	jmp	short PYN
 25766                                  
 25767                                  ; ---------------------------------------------------------------------------
 25768                                  
 25769                                  	; 19/03/2023
 25770                                  	; MSDOS 3.3
 25771                                  CERRORJ:
 25772 00003641 E916F3                  	jmp	cerror
 25773                                  
 25774                                  ; =============== S U B	R O U T	I N E =======================================
 25775                                  
 25776                                  	; 19/03/2023
 25777                                  	; MSDOS 3.3
 25778                                  ;MOVE_TO_FIRST_ARG:
 25779                                  	;mov	si,81h
 25780                                  	;call	SCANOFF
 25781                                  	;cmp	al,0Dh
 25782                                  	;retn
 25783                                  
 25784                                  ; =============== S U B	R O U T	I N E =======================================
 25785                                  
 25786                                  CNTRLC:
 25787 00003644 E86000                  	call	ON_OFF
 25788 00003647 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 25789 0000364A 720C                    	jc	short PCNTRLC
 25790 0000364C 7505                    	jnz	short CNTRLC_OFF
 25791 0000364E B201                    	mov	dl,1
 25792 00003650 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 25793                                  			; AL = 00h get state / 01h set state / 02h set AND get
 25794                                  			; DL = 00h for OFF or 01h for ON
 25795 00003652 C3                      	retn
 25796                                  
 25797                                  ; ---------------------------------------------------------------------------
 25798                                  
 25799                                  CNTRLC_OFF:
 25800 00003653 30D2                    	xor	dl,dl
 25801 00003655 CD21                    	int	21h		; Turn off ^C check
 25802 00003657 C3                      	retn
 25803                                  
 25804                                  ; ---------------------------------------------------------------------------
 25805                                  
 25806                                  PCNTRLC:
 25807                                  	; 19/03/2023
 25808                                  	; MSDOS 6.0
 25809                                  	;cmp	cl,0		;AC000; rest of line blank?
 25810 00003658 08C9                    	or	cl,cl
 25811 0000365A 75E5                    	jnz	short CERRORJ 	; no, oops!
 25812                                  
 25813                                  	; 19/03/2023
 25814                                  	; MSDOS 3.3
 25815                                  	;call	MOVE_TO_FIRST_ARG
 25816                                  	;jnz	short CERRORJ
 25817                                  ;pccont:
 25818                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25819 0000365C 30C0                    	xor	al,al
 25820 0000365E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 25821 00003660 88D3                    	mov	bl,dl
 25822 00003662 BA[BC80]                	mov	dx,CtrlcMes_Ptr
 25823                                  
 25824                                  ; ---------------------------------------------------------------------------
 25825                                  
 25826                                  PYN:	; write "ON" or "OFF" state 
 25827                                  
 25828                                  	; 26/04/2023
 25829                                  	; 19/03/2023
 25830                                  	; MSDOS 3.3
 25831                                  	;call	STD_PRINTF
 25832                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 25833                                  	;or	bl,bl
 25834                                  	;jnz	short PRINTVAL
 25835                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 25836                                  	
 25837                                  	; 26/04/2023
 25838                                  	; 19/03/2023
 25839                                  	; MSDOS 6.0
 25840 00003665 BE[E980]                	mov	si,ONMES_PTR
 25841 00003668 08DB                    	or	bl,bl
 25842 0000366A 7503                    	jnz	short PRINTVAL
 25843 0000366C BE[E680]                	mov	si,OFFMES_PTR
 25844                                  PRINTVAL:
 25845                                  	; 19/03/2023
 25846                                  	; MSDOS 3.3
 25847                                  	;jmp	STD_PRINTF
 25848                                  
 25849                                  	; 19/03/2023
 25850                                  	; MSDOS 6.0
 25851 0000366F 52                      	push	dx		;AN000; save offset of message block
 25852 00003670 89D3                    	mov	bx,dx		;AN000; save offset value
 25853 00003672 AD                      	lodsw			;AN000; get message number of on or off
 25854 00003673 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 25855                                  				;AN000; this is a utility message
 25856 00003675 E89218                  	call	TSYSGETMSG	;AN000; get the address of the message
 25857                                  	;add	bx,5
 25858 00003678 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 25859                                  	
 25860 0000367B 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 25861 0000367D 5A                      	pop	dx		;AN000; get message back
 25862 0000367E E8A217                  	call	std_printf	;AC000; go print message
 25863 00003681 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 25864 00003685 C3                      	retn			;AN000; exit
 25865                                  
 25866                                  ; =============== S U B	R O U T	I N E =======================================
 25867                                  
 25868                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 25869                                  VERIFY:
 25870 00003686 E81E00                  	call	ON_OFF
 25871 00003689 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 25872 0000368C 720A                    	jc	short PVERIFY
 25873 0000368E 7503                    	jnz	short VER_OFF
 25874 00003690 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 25875                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 25876 00003692 C3                      	retn
 25877                                  
 25878                                  ; ---------------------------------------------------------------------------
 25879                                  
 25880                                  VER_OFF:
 25881 00003693 FEC8                    	dec	al
 25882 00003695 CD21                    	int	21h		; Turn off verify after write
 25883 00003697 C3                      	retn
 25884                                  
 25885                                  ; ---------------------------------------------------------------------------
 25886                                  
 25887                                  PVERIFY:
 25888                                  	; 19/03/2023
 25889                                  	; MSDOS 6.0
 25890                                  	;cmp	cl,0		;AC000; is rest of line blank?
 25891 00003698 20C9                    	and	cl,cl
 25892 0000369A 75A5                    	jnz	short CERRORJ 	; nope...
 25893                                  
 25894                                  	 ;19/03/2023
 25895                                  	; MSDOS 3.3
 25896                                  	;call	MOVE_TO_FIRST_ARG
 25897                                  	;jnz	short CERRORJ
 25898                                  
 25899 0000369C B454                    	mov	ah,Get_Verify_On_Write ; 54h
 25900 0000369E CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 25901                                  				; Return: AL = 00h if flag OFF
 25902                                  				; AL = 01h if flag ON
 25903 000036A0 88C3                    	mov	bl,al
 25904 000036A2 BA[CA80]                	mov	dx,VeriMes_Ptr
 25905 000036A5 EBBE                    	jmp	short PYN
 25906                                  
 25907                                  ; =============== S U B	R O U T	I N E =======================================
 25908                                  
 25909                                  ; ****************************************************************
 25910                                  ; *
 25911                                  ; * ROUTINE:	 ON_OFF
 25912                                  ; *
 25913                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 25914                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 25915                                  ; *		 routines.
 25916                                  ; *
 25917                                  ; * INPUT:	 command line at offset 81H
 25918                                  ; *		 PARSE_BREAK control block
 25919                                  ; *
 25920                                  ; * OUTPUT:	 If carry is clear
 25921                                  ; *		    If ON is found
 25922                                  ; *		       Zero flag set
 25923                                  ; *		    If OFF is found
 25924                                  ; *		       Zero flag clear
 25925                                  ; *		 If carry set
 25926                                  ; *		    If nothing on command line
 25927                                  ; *		       CL set to zero
 25928                                  ; *		    If error
 25929                                  ; *		       CL contains error value from parse
 25930                                  ; *
 25931                                  ; ****************************************************************
 25932                                  
 25933                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25934                                  ON_OFF:
 25935 000036A7 BE8100                  	mov	si,81h
 25936                                  
 25937                                  	; 19/03/2023
 25938                                  	; MSDOS 3.3
 25939                                  	;call	SCANOFF		; scan off leading blanks & equal
 25940                                  	;cmp	al,0Dh		; are we at end of line?
 25941                                  	;je	short BAD_ONF	; yes, return error
 25942                                  	;lodsw
 25943                                  	;or	ax,2020h	; convert to lowercase
 25944                                  	;cmp	ax,6E6Fh ;'on'
 25945                                  	;je	short ON_CHECK
 25946                                  	;cmp	ax,666Fh ;'of'
 25947                                  	;jne	short BAD_ONF
 25948                                  	;lodsb
 25949                                  	;or	al,20h		; convert to lowercase		
 25950                                  	;cmp	al,66h	 ; 'f'
 25951                                  	;jne	short BAD_ONF	
 25952                                  	;or	al,66h ; or al,'f'
 25953                                  	;jmp	short OFF_CHECK
 25954                                  ;ON_CHECK:
 25955                                  	;xor	al,al
 25956                                  ;OFF_CHECK:
 25957                                  	;lahf
 25958                                  	;mov	bx,ax
 25959                                  	;call	SCANOFF		; scan off leading blanks & equal
 25960                                  	;cmp	al,0Dh		; are we at end of line?	
 25961                                  	;jne	short BAD_ONF	; no, return error
 25962                                  	;mov	ax,bx
 25963                                  	;sahf
 25964                                  	;clc
 25965                                  	;retn
 25966                                  
 25967                                  	; 19/03/2023
 25968                                  	; MSDOS 6.0
 25969                                  scan_on_off:			;AN032; scan off leading blanks & equal
 25970 000036AA AC                      	lodsb			;AN032; get a char
 25971                                  	;cmp	al,blank	;AN032; if whitespace
 25972 000036AB 3C20                    	cmp	al,20h
 25973 000036AD 74FB                    	je	short scan_on_off
 25974                                  				;AN032;    keep scanning
 25975 000036AF 3C09                    	cmp	al,tab_chr	;AN032; if tab
 25976                                  	;cmp	al,09h
 25977 000036B1 74F7                    	je	short scan_on_off
 25978                                  				;AN032;    keep scanning
 25979                                  	;cmp	al,equal_chr	;AN032; if equal char
 25980 000036B3 3C3D                    	cmp	al,'=' ; 3Dh
 25981 000036B5 7401                    	je	short parse_on_off
 25982                                  				;AN032;    start parsing
 25983 000036B7 4E                      	dec	si		;AN032; if none of above - back up
 25984                                  
 25985                                  parse_on_off:			;AN032;    and start parsing
 25986 000036B8 BF[C984]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 25987 000036BB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 25988 000036BD 31D2                    	xor	dx,dx		;AN000;
 25989 000036BF E88E0C                  	call	cmd_parse	;AC000; call parser
 25990                                  	;cmp	ax,-1 ; 0FFFFh
 25991 000036C2 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 25992 000036C5 742E                    	je	short BADONF	;AC000; yes, return error
 25993                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 25994                                  	;cmp	ax,0
 25995 000036C7 21C0                    	and	ax,ax ; ax = 0 ?
 25996 000036C9 7404                    	jz	short on_off_there
 25997                                  				;AN000; no - continue
 25998 000036CB 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 25999 000036CD EB26                    	jmp	short BADONF	;AN000; return error
 26000                                  
 26001                                  on_off_there:
 26002 000036CF 803E[F095]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26003                                  				;AN014; was a valid positional present?
 26004 000036D4 7505                    	jnz	short good_on_off
 26005                                  				;AN014; yes - continue
 26006 000036D6 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26007                                  	;mov	cx,10 ; 0Ah
 26008 000036D9 EB1A                    	jmp	short BADONF	;AN014; return error
 26009                                  
 26010                                  good_on_off:				;AN014;
 26011 000036DB 31C0                    	xor	ax,ax		;AC000; set up return code for
 26012 000036DD 0A06[F095]              	or	al,[PARSE1_CODE]
 26013                                  				;AC000;    ON or OFF in AX
 26014 000036E1 9C                      	pushf			;AN000; save flags
 26015 000036E2 BF[C984]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26016 000036E5 31D2                    	xor	dx,dx		;AN000;
 26017 000036E7 E8660C                  	call	cmd_parse	;AN000; call parser
 26018 000036EA 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26019                                  	;cmp	ax,-1 ; 0FFFFh
 26020 000036ED 7503                    	jne	short BADONF_flags
 26021                                  				;AN000; NO, return error
 26022 000036EF 9D                      	popf			;AN000; restore flags
 26023 000036F0 F8                      	clc			;AC000; no error
 26024                                  	;jmp	short on_off_end
 26025                                  				;AN000; return to caller
 26026                                  	; 26/04/2023
 26027 000036F1 C3                      	retn
 26028                                  
 26029                                  BADONF_flags:
 26030 000036F2 89C1                    	mov	cx,ax
 26031 000036F4 9D                      	popf
 26032                                  
 26033                                  ; ---------------------------------------------------------------------------
 26034                                  
 26035                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26036                                  ; and return the error
 26037                                  
 26038                                  BADONF:
 26039 000036F5 BA[9980]                	mov	dx,bad_on_off_ptr
 26040 000036F8 F9                      	stc
 26041                                  on_off_end:
 26042 000036F9 C3                      	retn
 26043                                  
 26044                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26045                                  %if 0
 26046                                  
 26047                                  ;============================================================================
 26048                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 26049                                  ;============================================================================
 26050                                  ; 02/10/2018 - Retro DOS v3.0
 26051                                  
 26052                                  ; Print volume ID info
 26053                                  
 26054                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 26055                                  
 26056                                  ; ---------------------------------------------------------------------------
 26057                                  
 26058                                  PRINTVOL:
 26059                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 26060                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 26061                                  	add	al,'@'
 26062                                  	cmp	al,'@'
 26063                                  	jnz	short DRVOK
 26064                                  	mov	al,[CURDRV]
 26065                                  	add	al,[CAPITAL_A]
 26066                                  DRVOK:
 26067                                  	mov	[VOL_DRV],al	; get drive letter into argument
 26068                                  	pop	ax		; get return code back
 26069                                  	mov	dx,NOVOL ; "has	no label" 
 26070                                  	or	al,al		; volume label found?
 26071                                  	jnz	short PRINTVOL2	; print no volume message
 26072                                  GOODVOL:
 26073                                  	; MSDOS 3.3
 26074                                  	mov	di,CHARBUF
 26075                                  	mov	dx,di
 26076                                  	mov	si,IS	; "is "
 26077                                  	call	STRCPY
 26078                                  	dec	di
 26079                                  	mov	si,DIRBUF+8
 26080                                  	mov	cx,11
 26081                                  	rep	movsb
 26082                                  	xor	ax,ax
 26083                                  	;xor	al,al  ; MSDOS 6.0
 26084                                  	stosb			; store a zero to terminate the string
 26085                                  PRINTVOL2:
 26086                                  	mov	[VOLNAME_ADDR],dx
 26087                                  	mov	dx,VOLMESPTR
 26088                                  	jmp	PRINTF_CRLF
 26089                                  
 26090                                  	; MSDOS 6.0
 26091                                  ;drvok:
 26092                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 26093                                  ;	pop	ax		;AC000; get return code back
 26094                                  ;	or	al,al		;AC000; volume label found?
 26095                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 26096                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 26097                                  ;				;AC000; set up no volume message
 26098                                  ;	jmp	short print_serial ;AC000; go print it
 26099                                  ;
 26100                                  ;Get_vol_name:
 26101                                  ;	mov	di,offset trangroup:charbuf
 26102                                  ;	mov	dx,di
 26103                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 26104                                  ;	mov	cx,11				;AN000;  3/3/KK
 26105                                  ;	rep	movsb				;AN000;  3/3/KK
 26106                                  ;
 26107                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 26108                                  ;	stosb
 26109                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 26110                                  ;
 26111                                  ;PRINT_SERIAL:
 26112                                  ;
 26113                                  ;; Attempt to get the volume serial number from the disk.  If an error
 26114                                  ;; occurs, do not print volume serial number.
 26115                                  ;
 26116                                  ;	push	dx		;AN000; save message offset
 26117                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 26118                                  ;				;AC036; Get the volume serial info
 26119                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 26120                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 26121                                  ;	int	21h		;AN000; do the call
 26122                                  ;	pop	dx		;AN000; get message offset back
 26123                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26124                                  ;	call	std_printf	;AC000; go print volume message
 26125                                  ;	mov	al,blank	;AN051; Print out a blank
 26126                                  ;	invoke	print_char	;AN051;   before volume message
 26127                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26128                                  ;				;AN000; get serial number message
 26129                                  ;printvol_end:
 26130                                  ;	jmp	std_printf	;AC000; go print and exit
 26131                                  
 26132                                  %endif
 26133                                  
 26134                                  ;============================================================================
 26135                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26136                                  ;============================================================================
 26137                                  ; 02/10/2018 - Retro DOS v3.0
 26138                                  
 26139                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26140                                  
 26141                                  ; =============== S U B	R O U T	I N E =======================================
 26142                                  
 26143                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26144                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26145                                  	
 26146                                  PRINT_DATE:
 26147                                  	; 20/03/2023
 26148                                  	; MSDOS 3.3
 26149                                  	;push	es
 26150                                  	;push	di
 26151                                  	;push	cs
 26152                                  	;pop	es
 26153                                  	;mov	di,ARG_BUF
 26154                                  	;mov	ah,Get_Date ; 2Ah
 26155                                  	;int	21h	; DOS -	GET CURRENT DATE
 26156                                  	;		; Return: DL = day,DH = month,	CX = year
 26157                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26158                                  	;cbw
 26159                                  	;call	GETDATE
 26160                                  	;call	P_DATE
 26161                                  	;xor	al,al
 26162                                  	;stosb
 26163                                  	;mov	dx,ARG_BUF_PTR
 26164                                  	;call	STD_PRINTF
 26165                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26166                                  	;pop	es ; !!??!! 
 26167                                  	;pop	di
 26168                                  	;retn
 26169                                  
 26170                                  	; 20/03/2023
 26171                                  	; MSDOS 6.0
 26172 000036FA 06                      	push	es
 26173 000036FB 57                      	push	di
 26174 000036FC 0E                      	push	cs
 26175 000036FD 07                      	pop	es
 26176 000036FE E81300                  	call	GetDate 		; get date
 26177 00003701 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26178 00003703 890E[5081]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26179 00003707 8916[5281]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26180 0000370B BA[4081]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26181 0000370E E81217                  	call	std_printf
 26182                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26183                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26184 00003711 5F                      	pop	di			;AC000; restore di,es
 26185 00003712 07                      	pop	es			;AC000;
 26186 00003713 C3                      	retn
 26187                                  
 26188                                  ; ---------------------------------------------------------------------------
 26189                                  
 26190                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26191                                  
 26192                                  ;GETDATE:
 26193                                  	; 21/03/2023
 26194                                  	; MSDOS 3.3
 26195                                  	;mov	si,ax
 26196                                  	;shl	si,1
 26197                                  	;add	si,ax
 26198                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26199                                  	;mov	bx,cx
 26200                                  	;mov	cx,3
 26201                                  	;rep	movsb
 26202                                  	;mov	al,' '
 26203                                  	;stosb
 26204                                  	;retn
 26205                                  
 26206                                  	; 21/03/2023
 26207                                  	; MSDOS 6.0
 26208                                  
 26209                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26210                                  ; for output. Date will be returned in CX,DX.
 26211                                  
 26212                                  GetDate:
 26213 00003714 BF[2C8C]                	mov	di,Arg_Buf		;AC000; target for day of week
 26214 00003717 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26215 00003719 CD21                    	int	21h			;AC000; Get date in CX:DX
 26216 0000371B 98                      	cbw				;AC000;
 26217 0000371C 51                      	push	cx			;AN000; save date returned in
 26218 0000371D 52                      	push	dx			;AN000;  CX:DX
 26219 0000371E 89C6                    	mov	si,ax
 26220 00003720 D1E6                    	shl	si,1
 26221 00003722 01C6                    	add	si,ax			; SI=AX*3
 26222 00003724 89F1                    	mov	cx,si			;AN000; save si
 26223 00003726 A1[0C80]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26224 00003729 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26225 0000372B 57                      	push	di			;AN000; save argument buffer
 26226 0000372C E8DB17                  	call	TSYSGETMSG		;AN000; get the address of the message
 26227 0000372F 5F                      	pop	di			;AN000; retrieve argument buffer
 26228 00003730 01CE                    	add	si,cx			;AC000; get day of week
 26229 00003732 B90300                  	mov	cx,3
 26230 00003735 F3A4                      	rep	movsb
 26231 00003737 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26232 00003739 AA                      	stosb
 26233 0000373A 5A                      	pop	dx			;AN000; get back date
 26234 0000373B 59                      	pop	cx			;AN000;
 26235 0000373C C3                      	retn
 26236                                  
 26237                                  ; =============== S U B	R O U T	I N E =======================================
 26238                                  
 26239                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26240                                  
 26241                                  	; MSDOS 6.0
 26242                                  
 26243                                  ; This routine determines whether the character in AL is a
 26244                                  ; Yes or No character. On return, if AL=0, the character is
 26245                                  ; No, if AL=1, the character is Yes.
 26246                                  
 26247                                  ;	assume	ds:trangroup
 26248                                  
 26249                                  char_in_xlat:	; proc	near
 26250                                  	; 21/03/2023
 26251 0000373D 88C2                    	mov	dl,al			;AC000; get character into DX
 26252 0000373F 30F6                    	xor	dh,dh			;AC000;
 26253                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26254 00003741 B82365                  	mov	ax,6523h
 26255 00003744 CD21                    	int	21h			;AC000;
 26256 00003746 C3                      	retn
 26257                                  
 26258                                  ;char_in_xlat	endp
 26259                                  
 26260                                  ;============================================================================
 26261                                  ; TENV.ASM, MSDOS 6.0, 1991
 26262                                  ;============================================================================
 26263                                  ; 02/10/2018 - Retro DOS v3.0
 26264                                  
 26265                                  ;	Environment utilities and misc. routines
 26266                                  
 26267                                  ; MSDOS 6.0
 26268                                  ; ****************************************************************
 26269                                  ; *
 26270                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26271                                  ; *
 26272                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26273                                  ; *		 the character in AL from the file upper case table
 26274                                  ; *		 in DOS if character if above  ascii 128, else
 26275                                  ; *		 subtracts 20H if between "a" and "z".
 26276                                  ; *
 26277                                  ; * INPUT:	 AL	      char to be upper cased
 26278                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26279                                  ; *
 26280                                  ; * OUTPUT:	 AL	      upper cased character
 26281                                  ; *
 26282                                  ; ****************************************************************
 26283                                  ;
 26284                                  ;assume	ds:trangroup				;AN000;
 26285                                  ;
 26286                                  ;upconv	proc	near				;AN000;
 26287                                  ;
 26288                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26289                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26290                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26291                                  ;	push	ds				;AN000;
 26292                                  ;	push	bx				;AN000;
 26293                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26294                                  ;assume	ds:resgroup				;AN000;
 26295                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26296                                  ;	add	bx,2				;AN000;  skip over first word
 26297                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26298                                  ;	pop	bx				;AN000;
 26299                                  ;	pop	ds				;AN000;
 26300                                  ;assume	ds:trangroup				;AN000;
 26301                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26302                                  ;
 26303                                  ;oth_fucase:					;AN000;
 26304                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26305                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26306                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26307                                  ;	ja	upconv_end			;AC000;
 26308                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26309                                  ;
 26310                                  ;upconv_end:					;AN000;
 26311                                  ;	ret
 26312                                  ;
 26313                                  ;upconv	endp					;AN000;
 26314                                  
 26315                                  
 26316                                  ; =============== S U B	R O U T	I N E =======================================
 26317                                  
 26318                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26319                                  
 26320                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26321                                  %if 0
 26322                                  
 26323                                  UPCONV:
 26324                                  	cmp	al,80h
 26325                                  	jb	short OTH_UCASE
 26326                                  	sub	al,80h
 26327                                  	push	ds
 26328                                  	push	bx
 26329                                  	mov	ds,[RESSEG]
 26330                                  	lds	bx,[UPPERCASETBL]
 26331                                  	add	bx,2
 26332                                  	xlat
 26333                                  	pop	bx
 26334                                  	pop	ds
 26335                                  	jmp	short UPCONV_RETN
 26336                                  
 26337                                  OTH_UCASE:
 26338                                  	cmp	al,'a'
 26339                                  	jb	short UPCONV_RETN
 26340                                  	cmp	al,'z'
 26341                                  	ja	short UPCONV_RETN
 26342                                  	sub	al,20h
 26343                                  
 26344                                  UPCONV_RETN:
 26345                                  	retn
 26346                                  
 26347                                  %endif
 26348                                  
 26349                                  ;============================================================================
 26350                                  ; COPY.ASM, MSDOS 6.0, 1991
 26351                                  ;============================================================================
 26352                                  ; 01/10/2018 - Retro DOS v3.0
 26353                                  
 26354                                  ;	title	COMMAND COPY routines.
 26355                                  
 26356                                  ;/*
 26357                                  ; *                      Microsoft Confidential
 26358                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26359                                  ; *                      All Rights Reserved.
 26360                                  ; */
 26361                                  
 26362                                  ;***	COPY.ASM
 26363                                  
 26364                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26365                                  
 26366                                  
 26367                                  ;***	MODIFICATION HISTORY
 26368                                  
 26369                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26370                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26371                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26372                                  ;	     to tokens which begin with path characters so that PARSELINE
 26373                                  ;	     will work correctly.
 26374                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26375                                  ;	     individual tokens. That distinction is no longer needed for
 26376                                  ;	     FOR loop processing.
 26377                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26378                                  ;	     1 when Cparse is called from COPY.
 26379                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26380                                  ;	     mod. It now is conditional on flag like previous mod.
 26381                                  ;11/21/83 NP  Added printf
 26382                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26383                                  ;	     be added to a token.
 26384                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26385                                  ;	     NOTE: DestHand is the destination handle. There are two
 26386                                  ;	     special values: -1 meaning destination was never opened and
 26387                                  ;	     0 which means that the destination has been openned and
 26388                                  ;	     closed.
 26389                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26390                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26391                                  ;	     lost on large and multiple file (wildcard) copies.
 26392                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26393                                  ;	     destination are not equal.
 26394                                  ;
 26395                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26396                                  ;	     first source file AND we run out of disk space before
 26397                                  ;	     completing the concatenation, restore the first source
 26398                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26399                                  ;
 26400                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26401                                  ;		instead of compatibility mode. This gives lesser sharing
 26402                                  ;		violations when files are opened for read on a copy.
 26403                                  
 26404                                  ; ---------------------------------------------------------------------------
 26405                                  ;***	COPY CODE
 26406                                  ; ---------------------------------------------------------------------------
 26407                                  
 26408                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26409                                  
 26410                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26411                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26412                                  
 26413                                  COPY:
 26414                                  	; 	Initialize internal variables.
 26415                                  
 26416 00003747 31C0                    	xor	ax,ax		; AX = 0
 26417 00003749 A3[B28C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26418 0000374C A3[E08D]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26419 0000374F A3[2C8D]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26420 00003752 A2[DF8A]                	mov	[CFLAG],al	; 'destination file created' = false
 26421 00003755 A3[E38A]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26422 00003758 A3[DB8A]                	mov	[DestSwitch],ax	; destination switches = none
 26423 0000375B A3[F68D]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26424 0000375E A3[C98C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26425 00003761 A2[E08A]                	mov	[DestClosed],al	; 'destination file closed' = false
 26426 00003764 A2[C88C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26427 00003767 A2[2B8D]                	mov	[SrcSiz],al	; length of source pathname = 0
 26428 0000376A A2[CB8C]                	mov	[DestInfo],al	; destination pathname flags = none
 26429 0000376D A2[2E8D]                	mov	[SrcInfo],al	; source pathname flags = none
 26430 00003770 A2[E28D]                	mov	[INEXACT],al	; 'inexact copy' = false
 26431 00003773 A2[C78C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26432 00003776 A2[2A8D]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26433 00003779 A2[A289]                	mov	[USERDIR1],al	; saved working directory = null
 26434 0000377C A2[E38D]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26435 0000377F A2[D38A]                	mov	[RDEOF],al	; 'read end of file' = false
 26436 00003782 A3[868D]                	mov	[SRCHAND],ax	; source handle = 0
 26437 00003785 A3[EB8D]                	mov	[CPDATE],ax	; copy date = 0
 26438 00003788 A3[ED8D]                	mov	[CPTIME],ax	; copy time = 0
 26439 0000378B A2[888D]                	mov	[SRCISDEV],al	; 'source is device' = false
 26440                                  	; 23/03/2023
 26441                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26442 0000378E A2[F38D]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26443 00003791 A3[EF8D]                	mov	[OFilePtr_Lo],ax
 26444 00003794 A3[F18D]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26445 00003797 A2[E78D]                	mov	[TERMREAD],al	; 'terminate read' = false
 26446 0000379A A2[258C]                	mov	[comma],al	; '"+,," found' = false
 26447 0000379D A2[268C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26448 000037A0 A2[328E]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26449 000037A3 A3[DD8A]                	mov	[AllSwitch],ax	; all switches = none
 26450 000037A6 A2[D68A]                	mov	[ArgC],al	; source/dest argument count = 0
 26451 000037A9 A2[E98D]                	mov	[PLUS],al	; '"+" in command line' = false
 26452 000037AC A2[E48D]                	mov	[BINARY],al	; 'binary copy' = false
 26453 000037AF A2[E88D]                	mov	[ASCII],al	; 'ascii copy' = false
 26454 000037B2 A3[EC8A]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26455 000037B5 A3[E58D]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26456 000037B8 A2[D58A]                	mov	[Concat],al	; 'concatenating' = false
 26457 000037BB A2[278D]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26458 000037BE A3[288D]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 26459                                  
 26460                                  	;	Initialize buffers with double-nulls.
 26461                                  
 26462 000037C1 A3[898D]                	mov	[ScanBuf],ax
 26463 000037C4 A3[CC8C]                	mov	[DestBuf],ax
 26464 000037C7 A3[2F8D]                	mov	[SrcBuf],ax
 26465 000037CA A3[0F8C]                	mov	[SDIRBUF],ax
 26466 000037CD A3[C98B]                	mov	[DIRBUF],ax
 26467 000037D0 A3[868B]                	mov	[DestFcb],ax
 26468                                  
 26469 000037D3 A2[EA8D]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26470                                  		
 26471 000037D6 48                      	dec	ax ; -1		; AX = 0FFFFh
 26472 000037D7 A3[238D]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26473 000037DA A2[E58A]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26474 000037DD A2[268D]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26475 000037E0 A2[C78C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26476                                  		
 26477 000037E3 BE8100                  	mov	si,81h		; SI = ptr to command line
 26478                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26479                                  	; 23/03/2023
 26480 000037E6 B32B                    	mov	bl,'+'
 26481 000037E8 FE06[318E]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26482 000037EC C606[B48C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26483                                  
 26484                                  	;*	Scan the command line for destination information.
 26485                                  
 26486                                  DESTSCAN:
 26487 000037F1 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26488 000037F3 BF[898D]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26489                                  	; 23/03/2023
 26490 000037F6 8936[288C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26491 000037FA E88E09                  	call	cparse			; parse next object
 26492 000037FD 9C                      	pushf				; save CParse flags
 26493 000037FE FE06[EA8D]              	inc	byte [objcnt]		; count object
 26494 00003802 F6C780                  	test	bh,80h
 26495 00003805 7405                    	jz	short NOCOPY		; no "+" delimiter
 26496 00003807 C606[E98D]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26497                                  NOCOPY:
 26498 0000380C F6C701                  	test	bh,1
 26499 0000380F 742E                    	jz	short TESTP2		; not a switch
 26500                                  
 26501                                  	;	Found a switch.
 26502                                  
 26503                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26504                                  	; MSDOS 6.0
 26505 00003811 F7C51000                	test	bp,10h
 26506                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26507 00003815 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26508 00003817 F606[DD8A]10            	test	byte [AllSwitch],10h
 26509                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26510 0000381C 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26511                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26512                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26513 0000381E 81CD0040                	or	bp,4000h
 26514                                  NOT_SLASHV:
 26515 00003822 092E[DB8A]              	or	[DestSwitch],bp		; assume destination
 26516 00003826 092E[DD8A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26517                                  
 26518                                  	; 2303/2023
 26519                                  	; MSDOS 6.0
 26520                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26521 0000382A F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26522 0000382E 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26523 00003830 9D                      	popf				;AN018; fix up stack
 26524 00003831 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26525 00003834 E896E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26526 00003837 E920F1                  	jmp	cerror			;AC018; exit
 26527                                  NOT_BAD_SWITCH:
 26528 0000383A 9D                      	popf				; restore CParse flags
 26529 0000383B 7233                    	jc	short CHECKDONE		; found CR
 26530 0000383D EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26531                                  TESTP2:
 26532 0000383F 9D                      	popf				; restore CParse flags
 26533 00003840 722E                    	jc	short CHECKDONE		; found CR
 26534 00003842 F6C780                  	test	bh,80h
 26535 00003845 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26536 00003847 FE06[D68A]              	inc	byte [ArgC]		; count independent pathname args
 26537                                  GOTPLUS:
 26538 0000384B 56                      	push	si			; save cmd line ptr
 26539 0000384C A1[F68D]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26540 0000384F BE[898D]                	mov	si,ScanBuf		; SI = ptr to path string
 26541 00003852 29F0                    	sub	ax,si			; AX = offset of last element
 26542 00003854 BF[CC8C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26543 00003857 01F8                    	add	ax,di			; AX = ptr to last element in
 26544                                  					;  destination path buffer
 26545 00003859 A3[C98C]                	mov	[DestTail],ax		; save ptr to last element
 26546 0000385C 880E[C88C]              	mov	[DestSiz],cl		; save path string length
 26547 00003860 41                      	inc	cx			; CX = mov length (incl null)
 26548 00003861 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26549 00003863 883E[CB8C]              	mov	[DestInfo],bh		; save CParse info flags
 26550 00003867 C706[DB8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26551 0000386D 5E                      	pop	si			; SI = ptr into cmd line again
 26552 0000386E EB81                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26553                                  
 26554                                  CHECKDONE:
 26555                                  	;	We reached the CR. The destination scan is finished.
 26556                                  
 26557                                  	;	Disallow "copy file1+" as file overwriting itself.
 26558                                  	;
 26559                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26560                                  	;	equivalent to "copy file1+file2".)
 26561                                  
 26562                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26563                                  	;	through this check, since the switch would count
 26564                                  	;	as another object in ObjCnt.
 26565                                  
 26566 00003870 803E[E98D]01            	cmp	byte [PLUS],1		; "+" with
 26567 00003875 7514                    	jnz	short CDCONT
 26568 00003877 803E[D68A]01            	cmp	byte [ArgC],1		; one arg,
 26569 0000387C 750D                    	jnz	short CDCONT
 26570 0000387E 803E[EA8D]02            	cmp	byte [objcnt],2		; two objects..
 26571 00003883 7506                    	jnz	short CDCONT
 26572 00003885 BA[7E7F]                	mov	dx,OVERWR_PTR
 26573 00003888 E91A06                  	jmp	COPYERR			; is file overwrite
 26574                                  
 26575                                  CDCONT:
 26576 0000388B A0[E98D]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26577 0000388E A2[D58A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26578 00003891 D0E0                    	shl	al,1
 26579 00003893 D0E0                    	shl	al,1
 26580 00003895 A2[E28D]                	mov	[INEXACT],al		; therefore making an inexact copy
 26581                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26582 00003898 A0[D68A]                	mov	al,[ArgC]		; AL = # independent arguments
 26583                                  
 26584                                  	; 23/03/2023
 26585                                  	; MSDOS 3.3		
 26586                                  	;or	al,al
 26587                                  	;jz	short CERROR4J
 26588                                  	; MSDOS 6.0
 26589 0000389B 08C0                    	or	al,al
 26590 0000389D 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26591                                  		
 26592 0000389F BA[557F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26593 000038A2 C706[557F]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26594                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26595 000038A8 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26596                                  
 26597                                  	; more than 0 args; check if too many
 26598                                  TRY_TOO_MANY:
 26599 000038AA 3C02                    	cmp	al,2
 26600 000038AC 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26601                                  
 26602                                  	; 23/03/2023
 26603                                  	; MSDOS 6.0
 26604 000038AE BA[557F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26605 000038B1 C706[557F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26606                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26607                                  CERROR_PARSEJ:
 26608 000038B7 C606[537F]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26609                                  					; parse error message	
 26610                                  CERROR4J:
 26611 000038BC E99BF0                  	jmp	cerror
 26612                                  
 26613                                  ACOUNTOK:
 26614 000038BF BD[C78C]                	mov	bp,DestVars		; BP = base of dest variables
 26615                                  
 26616 000038C2 3C01                    	cmp	al,1
 26617 000038C4 7520                    	jnz	short GOT2ARGS
 26618                                  
 26619                                  	;	Only one independent pathname argument on command line.
 26620                                  	;	Set destination to d:*.*, where d: is current drive.
 26621                                  
 26622                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26623                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26624                                  
 26625 000038C6 A0[D48A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26626                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26627                                  	; 23/03/2023
 26628 000038C9 0441                    	add	al,'A'
 26629 000038CB B43A                    	mov	ah,':'			; AX = "d:"
 26630                                  	;mov	byte [bp+1],2
 26631 000038CD C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26632                                  
 26633 000038D1 BF[CC8C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26634 000038D4 AB                      	stosw				; store "d:"
 26635                                  		
 26636 000038D5 C706[DB8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26637                                  	;mov	byte [bp+4],2		
 26638 000038DB C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26639                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26640                                  	;mov	byte [bp+0],0		
 26641 000038DF C6460000                	mov	byte [bp],0
 26642 000038E3 E87608                  	call	SETSTARS		; add wildcards
 26643                                  GOT2ARGS:
 26644                                  	;	If destination pathname is "d:", add full wildcard filename
 26645                                  
 26646                                  	;cmp	byte [bp+1],2
 26647 000038E6 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26648 000038EA 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26649 000038EC B03A                    	mov	al,':'  ; 3Ah
 26650 000038EE 3806[CD8C]              	cmp	byte [DestBuf+1],al
 26651 000038F2 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26652                                  	;or	byte [bp+4],2
 26653 000038F4 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26654 000038F8 BF[CE8C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26655                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26656                                  	;mov	byte [bp+0],0		
 26657 000038FB C6460000                	mov	byte [bp],0
 26658 000038FF E85A08                  	call	SETSTARS		; add wildcards
 26659                                  NOTSHORTDEST:
 26660                                  	;	If destination pathname ends with "\", try to make
 26661                                  	;	sure it's "d:\".
 26662                                  
 26663                                  	;mov	di,[bp+2]
 26664 00003902 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 26665 00003905 803D00                  	cmp	byte [di],0
 26666 00003908 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 26667                                  
 26668 0000390A BA[9080]                	mov	dx,badcd_ptr
 26669 0000390D B03A                    	mov	al,':'
 26670 0000390F 3845FE                  	cmp	[di-2],al
 26671 00003912 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 26672                                  	;mov	byte [bp+0],2
 26673                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 26674 00003914 C6460002                	mov	byte [bp],2
 26675                                  	;or	byte [bp+4],6
 26676 00003918 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 26677                                  					  ;  path character
 26678 0000391C E83D08                  	call	SETSTARS		; add wildcards
 26679                                  CHKSWTCHES:
 26680                                  	;	We have enough information about the destination for now.
 26681                                  
 26682                                  	;	Turn on verify if requested. Save the current verify flag.
 26683                                  
 26684                                  	; 23/03/2023
 26685                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 26686                                  	;mov	dx,BADPARMPTR
 26687                                  	
 26688 0000391F A1[DD8A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 26689                                  
 26690                                  	; 23/03/2023
 26691                                  	; MSDOS 3.3
 26692                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 26693                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 26694                                  	;jnz	short CERROR4J
 26695                                  	
 26696                                  	; 23/03/2023
 26697                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26698                                  	;test	ax,SwitchV ; 10h
 26699                                  	; 18/04/2023
 26700                                  	;test	ax,10h
 26701 00003922 A810                    	test	al,10h  ; test al,SwitchV
 26702 00003924 7414                    	jz	short NOVERIF		; no /v, no verify
 26703                                  
 26704 00003926 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26705 00003928 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26706                                  				; Return: AL = 00h if flag OFF
 26707                                  				; AL = 01h if flag ON
 26708 0000392A 1E                      	push	ds
 26709 0000392B 8E1E[C08A]              	mov	ds,[RESSEG]
 26710 0000392F 30E4                    	xor	ah,ah
 26711 00003931 A3[A801]                	mov	[VerVal],ax		; save current verify flag
 26712 00003934 1F                      	pop	ds
 26713 00003935 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26714 00003938 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 26715                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26716                                  NOVERIF:
 26717                                  	;*	Scan for first source.
 26718                                  
 26719 0000393A 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26720 0000393C BE8100                  	mov	si,81h			; SI = ptr into command line
 26721                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 26722                                  	; 23/03/2023
 26723 0000393F B32B                    	mov	bl,'+' ; 2Bh
 26724                                  SCANFSRC:
 26725 00003941 BF[898D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26726 00003944 E84408                  	call	cparse			; parse first source pathname
 26727 00003947 F6C701                  	test	bh,1			; switch?
 26728 0000394A 75F5                    	jnz	short SCANFSRC		; yes, try again
 26729 0000394C 092E[DB8A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 26730                                  
 26731                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 26732                                  
 26733                                  	; 23/03/2023
 26734 00003950 F7C50800                	test	bp,8
 26735                                  	;test	bp,SWITCHB
 26736 00003954 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 26737 00003956 803E[D58A]00            	cmp	byte [Concat],0
 26738 0000395B 7405                    	jz	short NOSETCASC		; we're not concatenating
 26739 0000395D C606[E88D]04            	mov	byte [ASCII],4
 26740                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 26741                                  NOSETCASC:
 26742 00003962 E8B503                  	call	SOURCE_SET		; set source variables
 26743 00003965 E84400                  	call	FRSTSRC			; set up first source copy
 26744 00003968 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 26745                                  
 26746                                  ; ---------------------------------------------------------------------------
 26747                                  
 26748                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26749                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 26750                                  ENDCOPY:
 26751                                  	;*	End of the road. Close destination, display # files
 26752                                  	;	copied (meaning # destinations), and go back to main
 26753                                  	;	transient COMMAND code.
 26754                                  
 26755 0000396B E8C102                  	call	CLOSEDEST
 26756                                  ENDCOPY2:
 26757 0000396E BA[877F]                	mov	dx,copied_ptr
 26758 00003971 8B36[EC8A]              	mov	si,[FileCnt]
 26759 00003975 8936[B28C]              	mov	[Copy_num],si
 26760 00003979 E8A714                  	call	std_printf
 26761 0000397C E985C7                  	jmp	TCOMMAND		; stack could be messed up
 26762                                  
 26763                                  ; ---------------------------------------------------------------------------
 26764                                  
 26765                                  SRCNONEXIST:
 26766                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 26767                                  	;	Otherwise, say 'file not found' and quit.
 26768                                  
 26769 0000397F 803E[D58A]00            	cmp	byte [Concat],0
 26770 00003984 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 26771                                  
 26772                                  	; 24/03/2023
 26773                                  	; MSDOS 3.3
 26774                                  	;mov	dx,SRCBUF
 26775                                  	;mov	[STRING_PTR_1],dx
 26776                                  	;mov	dx,STRINGBUF1PTR
 26777                                  	;call	STD_PRINTF
 26778                                  	;mov	dx,FNOTFOUNDPTR
 26779                                  	;jmp	COPYERR
 26780                                  
 26781                                  	; 24/*03/2023
 26782                                  	; MSDOS 6.0
 26783                                  	;	Set up error message.
 26784 00003986 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 26785                                  				  	; extended error msg
 26786 0000398B BA[557F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26787 0000398E C706[557F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 26788                                  					; 'file not found' msg#
 26789 00003994 C706[B08C][2F8D]        	mov	word [string_ptr_2],SrcBuf
 26790                                  					; point at bad pathname
 26791 0000399A C606[577F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 26792                                  					; 1 substitution
 26793 0000399F E90305                  	jmp	COPYERR			; print msg and clean up
 26794                                  
 26795                                  ; ---------------------------------------------------------------------------
 26796                                  
 26797                                  SOURCEPROC:
 26798                                  
 26799                                  	;*	Preparatory processing for each source file.
 26800                                  	;	Called at FrstSrc for first source file.
 26801                                  
 26802 000039A2 E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 26803 000039A5 803E[D58A]00            	cmp	byte [Concat],0
 26804 000039AA 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 26805                                  
 26806                                  ; ---------------------------------------------------------------------------
 26807                                  
 26808                                  FRSTSRC:
 26809 000039AC 31C0                    	xor	ax,ax
 26810 000039AE A2[DF8A]                	mov	[CFLAG],al		; 'destination not created'
 26811 000039B1 A3[E38A]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 26812 000039B4 A2[E08A]                	mov	[DestClosed],al		; 'destination not closed'
 26813                                  
 26814                                  LEAVECFLAG:
 26815 000039B7 8936[E08D]              	mov	[SRCPT],si		; save cmd-line ptr
 26816 000039BB BF[A289]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 26817                                  						;   current dir
 26818 000039BE BD[2A8D]                	mov	bp,SrcVars		; BP = base of source variables
 26819 000039C1 E84606                  	call	BUILDPATH		; cd to source dir, figure
 26820                                  						;   out stuff about source
 26821 000039C4 8B36[2C8D]              	mov	si,[SrcTail]		; SI = ptr to source filename
 26822 000039C8 C3                      	retn
 26823                                  
 26824                                  ; ---------------------------------------------------------------------------
 26825                                  
 26826                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26827                                  NEXTSRC:
 26828                                  	;*	Next source. Come here after handling each pathname.
 26829                                  	;	We're done unless there are additional source pathnames
 26830                                  	;	to be appended.
 26831                                  	;
 26832                                  	;	Note that all files matching an ambiguous pathname
 26833                                  	;	are processed before coming here.
 26834                                  
 26835 000039C9 803E[E98D]00            	cmp	byte [PLUS],0
 26836                                  	;jne	short MORECP		; copying "+" sources - keep going
 26837                                  	; 26/04/2023
 26838                                  ;ENDCOPYJ2:
 26839                                  	;jmp	short ENDCOPY
 26840 000039CE 749B                    	je	short ENDCOPY
 26841                                  MORECP:
 26842 000039D0 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26843 000039D2 8B36[E08D]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 26844                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 26845 000039D6 B32B                    	mov	bl,'+' ; 2Bh
 26846                                  SCANSRC:
 26847 000039D8 BF[898D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26848 000039DB E8AD07                  	call	cparse			; parse first source name
 26849                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 26850                                  	; 26/04/2023
 26851 000039DE 728B                    	jb	short ENDCOPY
 26852                                  
 26853 000039E0 F6C780                  	test	bh,80h
 26854                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 26855                                  	; 26/04/2023
 26856 000039E3 7486                    	jz	short ENDCOPY
 26857                                  
 26858 000039E5 F6C701                  	test	bh,1
 26859 000039E8 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 26860                                  
 26861                                  	;	ScanBuf contains the next source pathname.
 26862                                  
 26863 000039EA E8B5FF                  	call	SOURCEPROC		; prepare this source
 26864 000039ED 803E[258C]01            	cmp	byte [comma],1		; was +,, found last time?
 26865 000039F2 7507                    	jnz	short NOSTAMP		;  no - try for a file
 26866 000039F4 C606[268C]01            	mov	byte [plus_comma],1	; yes - set flag
 26867 000039F9 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 26868                                  
 26869                                  NOSTAMP:
 26870 000039FB C606[268C]00            	mov	byte [plus_comma],0	; reset +,, flag
 26871                                  
 26872                                  ; ---------------------------------------------------------------------------
 26873                                  
 26874                                  FIRSTENT:
 26875                                  
 26876                                  ;M047
 26877                                  ; The only case we need to worry about is when the source is wildcarded and
 26878                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 26879                                  ;concatenation. We check for this case.
 26880                                  ;
 26881                                  ;NB: This change has been backed out and replaced by M048. This is not the
 26882                                  ;right place to do this check.
 26883                                  
 26884                                  	;	This is where we enter the loop with the first source.
 26885                                  
 26886 00003A00 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 26887 00003A03 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 26888 00003A06 CD21                    	int	21h		; DOS -	PARSE FILENAME
 26889                                  				; DS:SI	-> string to parse
 26890                                  				; ES:DI	-> buffer to fill with unopened	FCB
 26891                                  				; AL = bit mask	to control parsing
 26892 00003A08 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 26893 00003A0B 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 26894 00003A0D A1[2F8D]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 26895 00003A10 80FC3A                  	cmp	ah,':'
 26896 00003A13 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 26897 00003A15 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 26898                                  DRVSPEC1:
 26899 00003A17 0C20                    	or	al,20h			; AL = lowercase drive letter
 26900 00003A19 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 26901                                  	;mov	[5Ch],al
 26902 00003A1B A25C00                  	mov	[FCB],al		; put drive id in FCB
 26903                                  
 26904                                  	;	FCB contains drive and filename to search.
 26905                                  		
 26906 00003A1E B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 26907 00003A20 E8FC00                  	call	SEARCH
 26908                                  SRCHDONE:
 26909 00003A23 9C                      	pushf				; save flags from Search
 26910 00003A24 E85FEA                  	call	RestUDir1		; restore users current directory
 26911 00003A27 9D                      	popf				; restore flags from search
 26912 00003A28 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 26913 00003A2A E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 26914                                  
 26915                                  NEXTAMBIG0:
 26916 00003A2D 30C0                    	xor	al,al
 26917 00003A2F 8606[E58A]              	xchg	al,[FRSTSRCH]
 26918 00003A33 08C0                    	or	al,al
 26919 00003A35 740B                    	jz	short NEXTAMBIG
 26920                                  SETNMEL:
 26921 00003A37 B90C00                  	mov	cx,12
 26922 00003A3A BF[0F8C]                	mov	di,SDIRBUF
 26923 00003A3D BE[C98B]                	mov	si,DIRBUF
 26924 00003A40 F3A4                    	rep	movsb			; save very first source name
 26925                                  NEXTAMBIG:
 26926 00003A42 30C0                    	xor	al,al
 26927 00003A44 A2[E38D]                	mov	[NOWRITE],al		; turn off nowrite
 26928 00003A47 8B3E[2C8D]              	mov	di,[SrcTail]
 26929 00003A4B BE[CA8B]                	mov	si,DIRBUF+1
 26930 00003A4E E8B4EB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 26931                                  MELDO:
 26932 00003A51 803E[D58A]00            	cmp	byte [Concat],0
 26933 00003A56 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 26934 00003A58 F606[2E8D]02            	test	byte [SrcInfo],2	; wildcard - show name
 26935 00003A5D 7409                    	jz	short DOREAD
 26936                                  SHOWCPNAM:
 26937                                  	; 25/03/2023
 26938                                  	; MSDOS 3.3
 26939                                  	;mov	dx,SRCBUF
 26940                                  	;mov	[STRING_PTR_2],dx
 26941                                  	;mov	dx,STRINGBUF2PTR
 26942                                  	;call	STD_PRINTF
 26943                                  	;call	CRLF2
 26944                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 26945                                  	; MSDOS 6.0 (& MSDOS 5.0
 26946 00003A5F BA[0081]                	mov	dx,file_name_ptr
 26947 00003A62 E8BE13                  	call	std_printf
 26948 00003A65 E871EB                  	call	CRLF2
 26949                                  DOREAD:
 26950 00003A68 E8C500                  	call	DOCOPY
 26951 00003A6B 803E[D58A]00            	cmp	byte [Concat],0
 26952 00003A70 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 26953                                  
 26954 00003A72 E8BA01                  	call	CLOSEDEST		; close current destination
 26955 00003A75 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 26956                                  
 26957 00003A77 C606[DF8A]00            	mov	byte [CFLAG],0		; 'destination not created'
 26958                                  NODCLOSE:
 26959 00003A7C 803E[D58A]00            	cmp	byte [Concat],0		
 26960 00003A81 740A                    	jz	short NOFLUSH
 26961                                  
 26962                                  ;	Concatenating - flush output between source files so LostErr
 26963                                  ;	stuff works correctly.
 26964                                  
 26965                                  	;invoke	FlshFil  ; MSDOS 6.0
 26966                                  	; 25/03/2023
 26967 00003A83 E8E202                  	call	FlshFil
 26968                                  	;call	FLUSHFIL ; MSDOS 3.3
 26969                                  
 26970 00003A86 F606[278D]FF            	test	byte [MELCOPY],0FFh
 26971                                  	;jz	short NOFLUSH
 26972                                  	;jmp	short DOMELCOPY
 26973                                  	; 25/03/2023
 26974 00003A8B 750C                    	jnz	short DOMELCOPY
 26975                                  NOFLUSH:
 26976 00003A8D E88300                  	call	SEARCHNEXT		; try next match
 26977 00003A90 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 26978                                  					;   this source spec
 26979 00003A92 C606[E08A]00            	mov	byte [DestClosed],0	; 'destination not closed'
 26980 00003A97 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 26981                                  
 26982                                  DOMELCOPY:
 26983 00003A99 803E[278D]FF            	cmp	byte [MELCOPY],0FFh
 26984 00003A9E 740D                    	je	short CONTMEL
 26985 00003AA0 8B36[E08D]              	mov	si,[SRCPT]
 26986 00003AA4 8936[288D]              	mov	[MELSTART],si
 26987 00003AA8 C606[278D]FF            	mov	byte [MELCOPY],0FFh
 26988                                  
 26989                                  CONTMEL:
 26990 00003AAD 31ED                    	xor	bp,bp
 26991 00003AAF 8B36[E08D]              	mov	si,[SRCPT]
 26992                                  	;mov	bl,[PLUS_CHR]
 26993                                  	; 25/03/2023
 26994 00003AB3 B32B                    	mov	bl,'+'
 26995                                  SCANSRC2:
 26996 00003AB5 BF[898D]                	mov	di,ScanBuf
 26997 00003AB8 E8D006                  	call	cparse
 26998 00003ABB F6C780                  	test	bh,80h
 26999 00003ABE 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 27000 00003AC0 F6C701                  	test	bh,1
 27001 00003AC3 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27002 00003AC5 E8DAFE                  	call	SOURCEPROC
 27003 00003AC8 E8BBE9                  	call	RestUDir1
 27004 00003ACB BF[4A8B]                	mov	di,DESTFCB2
 27005 00003ACE B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27006 00003AD1 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27007                                  				; DS:SI	-> string to parse
 27008                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27009                                  				; AL = bit mask	to control parsing
 27010 00003AD3 BB[108C]                	mov	bx,SDIRBUF+1
 27011 00003AD6 BE[4B8B]                	mov	si,DESTFCB2+1
 27012 00003AD9 8B3E[2C8D]              	mov	di,[SrcTail]
 27013                                  
 27014 00003ADD E8FB04                  	call	BUILDNAME
 27015                                  
 27016 00003AE0 803E[D58A]00            	cmp	byte [Concat],0
 27017 00003AE5 7405                    	je	short MELDOJ		; not concatenating - continue
 27018                                  
 27019                                  	;	Yes, turn off nowrite because this part of the code 
 27020                                  	;	is only reached after the first file has been dealt with.
 27021                                  
 27022 00003AE7 C606[E38D]00            	mov	byte [NOWRITE],0
 27023                                  MELDOJ:
 27024 00003AEC E962FF                  	jmp	MELDO
 27025                                  NEXTSRCJ:
 27026 00003AEF E9D7FE                  	jmp	NEXTSRC
 27027                                  
 27028                                  NEXTMEL:
 27029 00003AF2 E83A01                  	call	CLOSEDEST
 27030 00003AF5 31C0                    	xor	ax,ax
 27031 00003AF7 A2[DF8A]                	mov	[CFLAG],al
 27032 00003AFA A3[E38A]                	mov	[NXTADD],ax
 27033 00003AFD A2[E08A]                	mov	[SPECDRV],al
 27034 00003B00 8B36[288D]              	mov	si,[MELSTART]
 27035 00003B04 8936[E08D]              	mov	[SRCPT],si
 27036 00003B08 E80800                  	call	SEARCHNEXT
 27037 00003B0B 7403                    	jz	short SETNMELJ
 27038 00003B0D E95EFE                  	jmp	ENDCOPY2
 27039                                  SETNMELJ:
 27040 00003B10 E924FF                  	jmp	SETNMEL
 27041                                  
 27042                                  ; ---------------------------------------------------------------------------
 27043                                  
 27044                                  SEARCHNEXT:
 27045 00003B13 B412                    	mov	ah,Dir_Search_Next ; 12h
 27046 00003B15 F606[2E8D]02            	test	byte [SrcInfo],2
 27047 00003B1A 7503                    	jnz	short SEARCH		; do search-next if ambig
 27048 00003B1C 08E4                    	or	ah,ah			; reset zero flag
 27049 00003B1E C3                      	retn
 27050                                  
 27051                                  ; ---------------------------------------------------------------------------
 27052                                  
 27053                                  SEARCH:
 27054 00003B1F 50                      	push	ax
 27055 00003B20 B41A                    	mov	ah,Set_DMA ; 1Ah
 27056 00003B22 BA[C98B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27057 00003B25 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27058                                  			; DS:DX	-> disk	transfer buffer
 27059 00003B27 58                      	pop	ax		; restore search first/next command
 27060 00003B28 BA5C00                  	mov	dx,FCB ; 5Ch
 27061 00003B2B CD21                    	int	21h		; Do the search
 27062 00003B2D 08C0                    	or	al,al
 27063 00003B2F C3                      	retn
 27064                                  
 27065                                  ; ---------------------------------------------------------------------------
 27066                                  
 27067                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27068                                  DOCOPY:
 27069 00003B30 BE[2F8D]                	mov	si,SrcBuf	; do name translate of source
 27070 00003B33 BF[EE87]                	mov	di,SRCXNAME	; save for name comparison
 27071 00003B36 B460                    	mov	ah,xNameTrans ; 60h
 27072 00003B38 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27073                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27074                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27075 00003B3A C606[D38A]00            	mov	byte [RDEOF],0	; no EOF yet
 27076                                  
 27077                                  	; MSDOS 6.0
 27078                                  	;mov	ax,ExtOpen shl 8	; open the file
 27079                                  	; 26/03/2023
 27080 00003B3F B8006C                  	mov	ax,6C00h
 27081                                  ;M046
 27082                                  ; For reads, the sharing mode should be deny none so that any process can
 27083                                  ;open this file again in any other sharing mode. This is mainly to allow
 27084                                  ;multiple command.com's to access the same file without getting sharing
 27085                                  ;violations
 27086                                  ;
 27087                                  	;mov	bx,deny_none|read_open_mode
 27088 00003B42 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27089 00003B45 31C9                    	xor	cx,cx			; no special files
 27090                                  	;mov	dx,read_open_flag	; set up open flags
 27091 00003B47 BA0101                  	mov	dx,101h
 27092 00003B4A CD21                    	int	21h
 27093                                  	; 26/03/2023
 27094 00003B4C 7230                    	jc	short Error_On_Source
 27095                                  	;jnc	short OPENOK
 27096                                  
 27097                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27098                                  	;	They asked for it...
 27099                                  
 27100                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27101                                  
 27102                                  	; 26/03/2023
 27103                                  	; MSDOS 3.3
 27104                                  	;mov	dx,SRCBUF
 27105                                  	;mov	ax,OPEN*256 ; 3D00h
 27106                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27107                                  	;			; DS:DX	-> ASCIZ filename
 27108                                  	;			; AL = access mode
 27109                                  	;			; 0 - read
 27110                                  	;jnc	short OPENOK
 27111                                  	;call	GET_EXT_ERR_NUMBER
 27112                                  	;pushf
 27113                                  	;cmp	ax,65
 27114                                  	;jnz	short DOCOPY_ERR
 27115                                  	;mov	dx,ACCDENPTR
 27116                                  	;call	STD_PRINTF
 27117                                  ;DOCOPY_ERR:
 27118                                  	;popf
 27119                                  	;retn
 27120                                  
 27121                                  	; 26/03/2023
 27122                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27123                                  OPENOK:
 27124 00003B4E 89C3                    	mov	bx,ax
 27125 00003B50 891E[868D]              	mov	[SRCHAND],bx		; save handle
 27126 00003B54 B80057                  	mov	ax,File_Times*256 ; 5700h
 27127 00003B57 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27128                                  				; BX = file handle
 27129                                  
 27130 00003B59 7223                    	jc	short Error_On_Source  ; MSDOS 6.0
 27131                                  
 27132 00003B5B 8916[EB8D]              	mov	[CPDATE],dx		; save date
 27133 00003B5F 890E[ED8D]              	mov	[CPTIME],cx		; save time
 27134                                  
 27135                                  	; MSDOS 6.0
 27136                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27137                                  	; 26/04/2023
 27138                                  No_Copy_Xa:
 27139                                  	; 26/03/2023
 27140                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27141                                  
 27142                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27143 00003B63 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27144 00003B66 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27145                                  				; BX = file or device handle
 27146                                  	;and	dl,devid_ISDEV ; 80h
 27147                                  	; 18/04/2023
 27148 00003B68 80E280                  	and	dl,80h ; devid_ISDEV
 27149 00003B6B 8816[888D]              	mov	[SRCISDEV],dl		; set source info
 27150 00003B6F 7436                    	jz	short COPYLP		; source not a device
 27151 00003B71 803E[E48D]00            	cmp	byte [BINARY],0
 27152 00003B76 742F                    	je	short COPYLP		; ascii device ok
 27153 00003B78 BA[B980]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27154 00003B7B E92703                  	jmp	COPYERR
 27155                                  
 27156                                  Error_On_Source:			;AN022; we have a BAD error
 27157 00003B7E E871E1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27158 00003B81 C706[B08C][2F8D]        	mov	word [string_ptr_2],SrcBuf
 27159                                  				;AN022; get address of failed string
 27160 00003B87 C606[577F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27161                                  				;AN022; put number of subst in control block
 27162 00003B8C E88C12                  	call	std_eprintf		;AN022; print it
 27163                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27164 00003B8F 8B1E[868D]              	mov	bx,[SRCHAND]
 27165                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27166                                  	;je	short No_Close_Src	;AN022; no - don't close
 27167 00003B93 09DB                    	or	bx,bx
 27168 00003B95 7403                    	jz	short No_Close_Src
 27169                                  	;call	CLOSESRC		;AN022; clean up
 27170                                  	; 26/03/2023
 27171 00003B97 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27172                                  No_Close_Src:				;AN022;
 27173 00003B9A 803E[DF8A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27174 00003B9F 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27175 00003BA1 E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27176                                  EndCopyJ3:				;AN022;
 27177 00003BA4 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27178                                  
 27179                                  	; 26/04/2023
 27180                                  ;No_Copy_Xa:
 27181                                  ;	; 26/03/2023
 27182                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27183                                  ;
 27184                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27185                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27186                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27187                                  ;				; BX = file or device handle
 27188                                  ;	;and	dl,devid_ISDEV ; 80h
 27189                                  ;	; 18/04/2023
 27190                                  ;	and	dl,80h ; devid_ISDEV
 27191                                  ;	mov	[SRCISDEV],dl		; set source info
 27192                                  ;	jz	short COPYLP		; source not a device
 27193                                  ;	cmp	byte [BINARY],0
 27194                                  ;	je	short COPYLP		; ascii device ok
 27195                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27196                                  ;	jmp	COPYERR
 27197                                  
 27198                                  COPYLP:
 27199                                  	; 26/03/2023
 27200 00003BA7 8B1E[868D]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27201 00003BAB 8B0E[E18A]              	mov	cx,[BYTCNT]
 27202 00003BAF 8B16[E38A]              	mov	dx,[NXTADD]
 27203 00003BB3 29D1                    	sub	cx,dx			; compute available space
 27204 00003BB5 750E                    	jnz	short GOTROOM
 27205 00003BB7 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27206                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27207 00003BBA 803E[E78D]00            	cmp	byte [TERMREAD],0
 27208 00003BBF 7565                    	jne	short CLOSESRC		; give up
 27209 00003BC1 8B0E[E18A]              	mov	cx,[BYTCNT]
 27210                                  GOTROOM:
 27211 00003BC5 1E                      	push	ds
 27212 00003BC6 8E1E[C28A]              	mov	ds,[TPA]
 27213 00003BCA B43F                    	mov	ah,READ ; 3Fh
 27214 00003BCC CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27215                                  				; BX = file handle,CX = number of bytes to read
 27216                                  				; DS:DX	-> buffer
 27217 00003BCE 1F                      	pop	ds
 27218                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27219                                  	; 26/03/2023
 27220 00003BCF 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27221 00003BD1 89C1                    	mov	cx,ax			; get count
 27222 00003BD3 E351                    	jcxz	CLOSESRC		; no more to read
 27223 00003BD5 803E[888D]00            	cmp	byte [SRCISDEV],0
 27224 00003BDA 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27225 00003BDC 803E[E88D]00            	cmp	byte [ASCII],0
 27226 00003BE1 741B                    	je	short BINREAD
 27227                                  NOTESTA:
 27228 00003BE3 89CA                    	mov	dx,cx
 27229 00003BE5 8B3E[E38A]              	mov	di,[NXTADD]
 27230 00003BE9 B01A                    	mov	al,1Ah
 27231 00003BEB 06                      	push	es
 27232 00003BEC 8E06[C28A]              	mov	es,[TPA]		; scan for EOF
 27233 00003BF0 F2AE                    	repne	scasb
 27234 00003BF2 07                      	pop	es
 27235 00003BF3 7505                    	jnz	short USEALL
 27236 00003BF5 FE06[D38A]              	inc	byte [RDEOF]
 27237 00003BF9 41                      	inc	cx
 27238                                  USEALL:
 27239 00003BFA 29CA                    	sub	dx,cx
 27240 00003BFC 89D1                    	mov	cx,dx
 27241                                  BINREAD:
 27242 00003BFE 030E[E38A]              	add	cx,[NXTADD]
 27243 00003C02 890E[E38A]              	mov	[NXTADD],cx
 27244 00003C06 3B0E[E18A]              	cmp	cx,[BYTCNT]		; is buffer full?
 27245 00003C0A 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27246                                  	; 26/03/2023
 27247 00003C0C E85901                  	call	FlshFil
 27248                                  	;call	FLUSHFIL
 27249 00003C0F 803E[E78D]00            	cmp	byte [TERMREAD],0
 27250 00003C14 7510                    	jne	short CLOSESRC		; give up
 27251 00003C16 EB8F                    	jmp	short COPYLP
 27252                                  TESTDEV:
 27253 00003C18 803E[888D]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27254 00003C1D 7407                    	je	short CLOSESRC
 27255 00003C1F 803E[D38A]00            	cmp	byte [RDEOF],0
 27256 00003C24 7481                    	je	short COPYLP		; on device, go till ^Z
 27257                                  CLOSESRC:
 27258 00003C26 8B1E[868D]              	mov	bx,[SRCHAND]
 27259                                  CLOSESRC2:
 27260 00003C2A B43E                    	mov	ah,CLOSE ; 3Eh
 27261 00003C2C CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27262                                  				; BX = file handle
 27263                                  CLOSESRCDEST_RETN:
 27264 00003C2E C3                      	retn
 27265                                  
 27266                                  ; ---------------------------------------------------------------------------
 27267                                  
 27268                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27269                                  CLOSEDEST:
 27270                                  
 27271                                  	;	We are called to close the destination.
 27272                                  	;	We need to note whether or not there is any internal data left
 27273                                  	;	to be flushed out.
 27274                                  
 27275 00003C2F 803E[E08A]00            	cmp	byte [DestClosed],0
 27276 00003C34 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27277 00003C36 A0[DB8A]                	mov	al,[DestSwitch]
 27278 00003C39 E8C502                  	call	SETASC			; check for b or a switch
 27279 00003C3C 742E                    	jz	short BINCLOS		;   on destination
 27280 00003C3E 8B1E[E38A]              	mov	bx,[NXTADD]
 27281                                  ;
 27282                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27283                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27284                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27285                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27286                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27287                                  ;performance overhead on single ASCII file copies which now always involve
 27288                                  ;2 writes instead of 1 before. Is this really that important?
 27289                                  ;
 27290                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27291                                  ;M048;	jne	short PutZ
 27292                                  
 27293                                  	; 26/03/2023
 27294                                  	; MSDOS 3.3
 27295                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27296                                  	;jne	short PUTZ
 27297                                  
 27298                                  	; 26/03/2023
 27299 00003C42 E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27300 00003C45 7402                    	jz	short NOCONC
 27301                                  CONCHNG:
 27302 00003C47 F9                      	stc
 27303 00003C48 C3                      	retn
 27304                                  
 27305                                  NOCONC:	
 27306 00003C49 31DB                    	xor	bx,bx
 27307                                  PUTZ:
 27308 00003C4B 1E                      	push	ds
 27309 00003C4C 8E1E[C28A]              	mov	ds,[TPA]
 27310 00003C50 C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27311 00003C54 1F                      	pop	ds
 27312 00003C55 FF06[E38A]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27313 00003C59 C606[E38D]00            	mov	byte [NOWRITE],0
 27314 00003C5E A1[E58D]                	mov	ax,[WRITTEN]
 27315 00003C61 0306[E38A]              	add	ax,[NXTADD]
 27316 00003C65 7205                    	jc	short BINCLOS	; > 1
 27317 00003C67 83F801                  	cmp	ax,1
 27318 00003C6A 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27319                                  BINCLOS:
 27320 00003C6C E8EC00                  	call	TRYFLUSH
 27321 00003C6F 75D6                    	jnz	short CONCHNG
 27322                                  
 27323                                  	; 26/04/2023
 27324 00003C71 833E[E58D]00            	cmp	word [WRITTEN],0
 27325                                  	; 26/03/2023
 27326 00003C76 7503                    	jnz	short NO_FORGET
 27327                                  FORGETITJ:
 27328                                  	;jz	short FORGETIT	; never wrote nothing
 27329                                  	; 26/03/2023
 27330 00003C78 E98500                  	jmp	FORGETIT ; 18/04/2023
 27331                                  NO_FORGET:			; wrote something
 27332 00003C7B 8B1E[238D]              	mov	bx,[DESTHAND]
 27333 00003C7F 8B0E[ED8D]              	mov	cx,[CPTIME]
 27334 00003C83 8B16[EB8D]              	mov	dx,[CPDATE]
 27335 00003C87 803E[E28D]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27336 00003C8C 7431                    	je	short DODCLOSE	; if no, copy date & time
 27337 00003C8E B42C                    	mov	ah,Get_Time ; 2Ch
 27338 00003C90 CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27339                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27340                                  				; DL = hundredths of seconds
 27341 00003C92 D0E1                    	shl	cl,1
 27342 00003C94 D0E1                    	shl	cl,1		; left justify min in cl
 27343 00003C96 D1E1                    	shl	cx,1
 27344 00003C98 D1E1                    	shl	cx,1
 27345 00003C9A D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27346 00003C9C D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27347 00003C9E 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27348 00003CA0 51                      	push	cx		; save packed time
 27349 00003CA1 B42A                    	mov	ah,Get_Date ; 2Ah
 27350 00003CA3 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27351                                  				; Return: DL = day,DH = month,	CX = year
 27352                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27353 00003CA5 81E9BC07                	sub	cx,1980
 27354 00003CA9 86E9                    	xchg	ch,cl
 27355 00003CAB D1E1                    	shl	cx,1		; year to high 7 bits
 27356 00003CAD D0E6                    	shl	dh,1		; month to high 3 bits
 27357 00003CAF D0E6                    	shl	dh,1
 27358 00003CB1 D0E6                    	shl	dh,1
 27359 00003CB3 D0E6                    	shl	dh,1
 27360 00003CB5 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27361 00003CB7 80D500                  	adc	ch,0		; put that bit next to year
 27362 00003CBA 08F2                    	or	dl,dh		; or low three of month into day
 27363 00003CBC 88EE                    	mov	dh,ch		; get year and high bit of month
 27364 00003CBE 59                      	pop	cx
 27365                                  DODCLOSE:
 27366 00003CBF 83FB00                  	cmp	bx,0
 27367 00003CC2 7E36                    	jle	short CLOSEDONE
 27368 00003CC4 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27369 00003CC7 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27370                                  				; BX = file handle,CX = time to be set
 27371                                  				; DX = date to be set
 27372                                  	; 26/03/2023
 27373                                  	; MSDOS 6.0
 27374 00003CC9 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27375                                  
 27376                                  	;	See if the destination has *anything* in it.
 27377                                  	;	If not, just close and delete it.
 27378                                  
 27379 00003CCB B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27380 00003CCE 31D2                    	xor	dx,dx
 27381 00003CD0 89D1                    	mov	cx,dx
 27382 00003CD2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27383                                  			; AL = method: offset from end of file
 27384                                  	;	DX:AX is file size
 27385                                  
 27386 00003CD4 09C2                    	or	dx,ax
 27387 00003CD6 9C                      	pushf
 27388 00003CD7 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27389 00003CDA CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27390                                  			; BX = file or device handle
 27391 00003CDC 52                      	push	dx		; save them away
 27392 00003CDD B43E                    	mov	ah,CLOSE ; 3Eh
 27393 00003CDF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27394                                  			; BX = file handle
 27395 00003CE1 5A                      	pop	dx
 27396                                  
 27397                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27398                                  	; MSDOS 6.0
 27399 00003CE2 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27400 00003CE4 9D                      	popf			;AN022; get the flags back
 27401                                  Cleanup_Err: 			;AN022;
 27402 00003CE5 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27403                                  	; 26/03/2023
 27404                                  	;call	DestDelete	;AN022; attempt to delete the target
 27405                                  	;jmp	short FILECLOSED
 27406                                  	;			;AN022; close the file
 27407                                  	; 26/03/2023
 27408                                  DestDel_fclosed:
 27409 00003CE8 E82700                  	call	DestDelete
 27410                                  FILECLOSED:
 27411 00003CEB FE06[E08A]              	inc	byte [DestClosed]
 27412                                  RET50:
 27413 00003CEF F8                      	clc
 27414 00003CF0 C3                      	retn
 27415                                  	
 27416                                  Close_Cont:			;AN022; no error - co
 27417                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27418 00003CF1 9D                      	popf
 27419 00003CF2 7506                    	jnz	short CLOSEDONE
 27420 00003CF4 F7C28000                	test	dx,80h		; is the destination a device?
 27421                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27422                                  	;call	DestDelete
 27423                                  	;jmp	short FILECLOSED
 27424                                  	; 26/03/2023
 27425 00003CF8 74EE                    	jz	short DestDel_fclosed
 27426                                  CLOSEDONE:
 27427 00003CFA FF06[EC8A]              	inc	word [FileCnt]
 27428                                  	; 26/03/2023
 27429 00003CFE EBEB                    	jmp	short FILECLOSED
 27430                                  	
 27431                                  ;FILECLOSED:
 27432                                  ;	inc	byte [DestClosed]
 27433                                  ;RET50:
 27434                                  	;clc
 27435                                  	;retn
 27436                                  
 27437                                  FORGETIT:
 27438 00003D00 8B1E[238D]              	mov	bx,[DESTHAND]
 27439 00003D04 E8B8FF                  	call	DODCLOSE	 ; close the dest	
 27440 00003D07 E80800                  	call	DestDelete
 27441 00003D0A C706[EC8A]0000          	mov	word [FileCnt],0 ; no files transferred
 27442 00003D10 EBDD                    	jmp	short RET50
 27443                                  
 27444                                  ; ---------------------------------------------------------------------------
 27445                                  
 27446                                  	; 26/03/2023
 27447                                  DestDelete:
 27448 00003D12 BA[CC8C]                	mov	dx,DestBuf
 27449 00003D15 B441                    	mov	ah,Unlink ; 41h
 27450 00003D17 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27451                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27452                                  			;		(no wildcards allowed)
 27453 00003D19 C3                      	retn
 27454                                  
 27455                                  ; ---------------------------------------------------------------------------
 27456                                  
 27457                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27458                                  SOURCE_SET:
 27459 00003D1A 56                      	push	si
 27460 00003D1B A1[F68D]                	mov	ax,[STARTEL]
 27461 00003D1E BE[898D]                	mov	si,ScanBuf	; adjust to copy
 27462 00003D21 29F0                    	sub	ax,si
 27463 00003D23 BF[2F8D]                	mov	di,SrcBuf
 27464 00003D26 01F8                    	add	ax,di
 27465 00003D28 A3[2C8D]                	mov	[SrcTail],ax
 27466 00003D2B 880E[2B8D]              	mov	[SrcSiz],cl	; save its size
 27467 00003D2F 41                      	inc	cx		; include the nul
 27468 00003D30 F3A4                    	rep	movsb		; save this source
 27469 00003D32 883E[2E8D]              	mov	[SrcInfo],bh	; save info about it
 27470 00003D36 5E                      	pop	si
 27471 00003D37 89E8                    	mov	ax,bp		; switches so far
 27472 00003D39 E8C501                  	call	SETASC		; set a,b switches accordingly
 27473 00003D3C E845EA                  	call	SWITCH		; get any more switches on this arg
 27474                                  	;call	SETASC		; set
 27475                                  	;retn
 27476                                  	; 26/03/2023
 27477 00003D3F E9BF01                  	jmp	SETASC
 27478                                  
 27479                                  ; =============== S U B	R O U T	I N E =======================================
 27480                                  
 27481                                  ; MSDOS 6.0
 27482                                  
 27483                                  ;****************************************************************
 27484                                  ;*
 27485                                  ;* ROUTINE:	CleanupErr
 27486                                  ;*
 27487                                  ;* FUNCTION:	Issues extended error message for destination
 27488                                  ;*		if not alreay issued
 27489                                  ;*
 27490                                  ;* INPUT:	return from INT 21
 27491                                  ;*
 27492                                  ;* OUTPUT:	none
 27493                                  ;*
 27494                                  ;****************************************************************
 27495                                  
 27496                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27497                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27498                                  CleanUpErr:	; proc	near		;AN022;
 27499                                  
 27500 00003D42 803E[328E]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27501 00003D47 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27502 00003D49 E8A6DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27503 00003D4C C706[B08C][CC8C]        	mov	word [string_ptr_2],DestBuf 
 27504                                  					;AN022; get address of failed string
 27505 00003D52 C606[577F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27506                                  					;AN022; put number of subst in control block
 27507 00003D57 E8C110                  	call	std_eprintf		;AN022; issue the error message
 27508                                  CleanupErr_Cont:			;AN022;
 27509 00003D5A C3                      	retn				;AN022; return to caller
 27510                                  
 27511                                  ;CleanUpErr	endp			;AN022;
 27512                                  
 27513                                  ;============================================================================
 27514                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27515                                  ;============================================================================
 27516                                  ; 01/10/2018 - Retro DOS v3.0
 27517                                  
 27518                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27519                                  
 27520                                  ; =============== S U B	R O U T	I N E =======================================
 27521                                  
 27522                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27523                                  ;
 27524                                  ;	EXIT	ZR set if concatenate flag unchanged
 27525                                  
 27526                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27527                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27528                                  TRYFLUSH:
 27529 00003D5B A0[D58A]                	mov	al,[Concat]
 27530 00003D5E 50                      	push	ax
 27531                                  	;call	FLUSHFIL
 27532 00003D5F E80600                  	call	FlshFil
 27533 00003D62 58                      	pop	ax
 27534 00003D63 3A06[D58A]              	cmp	al,[Concat]
 27535 00003D67 C3                      	retn
 27536                                  
 27537                                  ; =============== S U B	R O U T	I N E =======================================
 27538                                  
 27539                                  	; 26/03/2023
 27540                                  	; MSDOS 3.3
 27541                                  ;FLUSHFIL:
 27542                                  	;mov	al,[BINARY]
 27543                                  	;mov	ah,[ASCII]
 27544                                  	;push	ax
 27545                                  	;call	FLSHFIL
 27546                                  	;pop	ax
 27547                                  	;mov	[ASCII],ah
 27548                                  	;mov	[BINARY],al
 27549                                  	;retn
 27550                                  
 27551                                  ; =============== S U B	R O U T	I N E =======================================
 27552                                  
 27553                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27554                                  ;
 27555                                  ;	Inputs:
 27556                                  ;	  [NXTADD] = No. of bytes to write
 27557                                  ;	  [CFLAG] <> 0 if file has been created
 27558                                  ;	Outputs:
 27559                                  ;	  [NXTADD] = 0
 27560                                  
 27561                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27562                                  FlshFil:
 27563 00003D68 C606[E78D]00            	mov	byte [TERMREAD],0
 27564 00003D6D 803E[DF8A]00            	cmp	byte [CFLAG],0
 27565 00003D72 7403                    	jz	short NotExists
 27566 00003D74 E99600                  	jmp	Exists
 27567                                  NotExists:
 27568 00003D77 E8A101                  	call	BUILDDEST		; find out all about the destination
 27569 00003D7A E8FB03                  	call	COMPNAME		; source and dest. the same?
 27570 00003D7D 7519                    	jnz	short ProcDest		; if not, go ahead
 27571 00003D7F 803E[888D]00            	cmp	byte [SRCISDEV],0
 27572 00003D84 7512                    	jnz	short ProcDest		; same name on device ok
 27573 00003D86 803E[D58A]00            	cmp	byte [Concat],0		; concatenation?
 27574 00003D8B BA[7E7F]                	mov	dx,OVERWR_PTR
 27575                                  	;je	short COPERR		; not concatenating - overwrite error
 27576                                  	; 26/03/2023
 27577 00003D8E 7503                    	jne	short No_Concat_Err
 27578 00003D90 E91201                  	jmp	COPYERR
 27579                                  	
 27580                                  No_Concat_Err:	; concatenating
 27581 00003D93 C606[E38D]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27582                                  ProcDest:
 27583                                  	; MSDOS 6.0
 27584                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27585                                  	; 26/03/2023
 27586 00003D98 B8006C                  	mov	ax,6C00h
 27587 00003D9B BE[CC8C]                	mov	si,DestBuf		; get file name
 27588                                  ;M046
 27589                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27590                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27591                                  ;writing to the same file. Also, because we opened the source file with
 27592                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27593                                  ;would happen when we append to an existing file.
 27594                                  
 27595                                  	; 26/03/2023
 27596                                  	;mov	bx,deny_write|write_open_mode
 27597 00003D9E BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27598 00003DA1 31C9                    	xor	cx,cx			; no special files
 27599                                  	;mov	dx,write_open_flag	; set up open flags
 27600 00003DA3 BA0101                  	mov	dx,101h	
 27601                                  
 27602 00003DA6 803E[E38D]00            	cmp	byte [NOWRITE],0
 27603 00003DAB 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27604                                  	;mov	dx,creat_open_flag	; set up create flags
 27605 00003DAD BA1201                  	mov	dx,112h
 27606                                  
 27607                                  	; 26/03/2023
 27608                                  	; MSDOS 3.3
 27609                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27610                                  	;cmp	byte [NOWRITE],0
 27611                                  	;jne	short DODESTOPEN
 27612                                  	;mov	ah,CREAT ; 3Ch
 27613                                  	;xor	cx,cx
 27614                                  ;DODESTOPEN:
 27615                                  	;mov	dx,DESTBUF
 27616                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27617                                  	;		; CX = attributes for file
 27618                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27619                                  
 27620                                  ; 26/03/2023
 27621                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27622                                  ;	;mov	dx,FULDIRPTR
 27623                                  ;	;call	GET_EXT_ERR_NUMBER
 27624                                  ;	;jc	short COPERR
 27625                                  ;
 27626                                  ;	; 01/10/2018
 27627                                  ;	;jnc	short DEST_OPEN_OKAY
 27628                                  ;		
 27629                                  ;	;mov	dx,FULDIRPTR
 27630                                  ;	;call	GET_EXT_ERR_NUMBER
 27631                                  ;	;jmp	short COPERR
 27632                                  ;
 27633                                  ;	jc	short DEST_OPEN_ERROR
 27634                                  
 27635                                  	; 26/03/2023
 27636                                  DoDestOpen:
 27637 00003DB0 CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27638                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27639                                  			; BH = flags
 27640                                  			; CX = create attribute
 27641                                  			; DL = action if file exists/does not exists
 27642                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27643                                  
 27644                                  ;	We assume that the error is normal.
 27645                                  ;	TriageError will correct the DX value appropriately.
 27646                                  	
 27647 00003DB2 7311                    	jnc	short Dest_Open_Okay
 27648                                  Xa_Set_Error:				;AN030; error occurred on XA
 27649 00003DB4 E83BDF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27650                                  
 27651                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27652                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27653                                  Ext_Err_Set:				;AN030;
 27654 00003DB7 C706[B08C][CC8C]        	mov	word [string_ptr_2],DestBuf
 27655                                  					;AN000; get address of failed string
 27656 00003DBD C606[577F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27657                                  					;AN030; put number of subst in control block
 27658                                  CopErrJ2:				;AN030;
 27659 00003DC2 E9E000                  	jmp	COPYERR			;AN030; go issue message
 27660                                  
 27661                                  ;DEST_OPEN_OKAY:
 27662                                  	; 26/03/2023
 27663                                  Dest_Open_Okay:
 27664 00003DC5 A3[238D]                	mov	[DESTHAND],ax		; save handle
 27665 00003DC8 C606[DF8A]01            	mov	byte [CFLAG],1		; destination now exists
 27666 00003DCD 89C3                    	mov	bx,ax
 27667 00003DCF B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 27668 00003DD2 CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 27669                                  			   	; BX = file or device handle
 27670                                  
 27671 00003DD4 8816[258D]              	mov	[DESTISDEV],dl		; set dest info
 27672                                  	; 18/04/2023
 27673 00003DD8 F6C280                  	test	dl,80h
 27674                                  	;test	dl,devid_ISDEV
 27675 00003DDB 7430                    	jz	short Exists		; Dest not a device
 27676                                  
 27677                                  ;	Destination is device.
 27678                                  
 27679 00003DDD A0[DB8A]                	mov	al,byte [DestSwitch]
 27680                                  	; 26/03/2023
 27681 00003DE0 240C                    	and	al,0Ch
 27682                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 27683 00003DE2 7509                    	jnz	short TestBoth
 27684 00003DE4 A0[E88D]                	mov	al,[ASCII]		; neither set, use current setting
 27685 00003DE7 0A06[E48D]              	or	al,[BINARY]
 27686 00003DEB 7416                    	jz	short ExSetA		; neither set, default to ascii
 27687                                  TestBoth:
 27688 00003DED 7A1E                    	jpe	short Exists		; both are set, ignore
 27689 00003DEF A808                    	test	al,8
 27690                                  	;test	al,SWITCHB
 27691 00003DF1 741A                    	jz	short Exists
 27692                                  	;mov	ax,(IOCTL shl 8) or 1
 27693 00003DF3 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 27694 00003DF6 30F6                    	xor	dh,dh
 27695                                  	; 18/04/2023
 27696 00003DF8 80CA20                  	or	dl,20h
 27697                                  	;or	dl,devid_RAW
 27698 00003DFB 8816[258D]              	mov	[DESTISDEV],dl
 27699 00003DFF CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 27700                                  			; BX = device handle,DH = 0
 27701                                  			; DL = device information to set (bits 0-7 from	function 0)
 27702 00003E01 EB0A                    	jmp	short Exists
 27703                                  
 27704                                  	; 26/03/2023
 27705                                  	; 01/10/2018 - Retro DOS v3.0 modification
 27706                                  ;DEST_OPEN_ERROR:
 27707                                  	;mov	dx,FULDIRPTR
 27708                                  	;call	GET_EXT_ERR_NUMBER
 27709                                  ;COPERR:
 27710                                  	; 26/03/2023
 27711                                  ;CopyErrj:
 27712                                  	;jmp	short COPYERR
 27713                                  
 27714                                  ExSetA:
 27715                                  ;	What we read in may have been in binary mode, flag zapped write OK
 27716                                  
 27717 00003E03 C606[E88D]04            	mov	byte [ASCII],4
 27718                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 27719 00003E08 800E[E28D]04            	or	byte [INEXACT],4
 27720                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 27721                                  Exists:
 27722 00003E0D 803E[E38D]00            	cmp	byte [NOWRITE],0
 27723 00003E12 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 27724 00003E14 803E[268C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 27725 00003E19 741D                    	jz	short NoChecking
 27726 00003E1B E85A03                  	call	COMPNAME		; source and dest. the same?
 27727 00003E1E 7518                    	jnz	short NoChecking	; if not, go ahead
 27728 00003E20 803E[888D]00            	cmp	byte [SRCISDEV],0
 27729 00003E25 7511                    	jne	short NoChecking	; same name on device ok
 27730                                  
 27731                                  ;	At this point we know in append (would have gotten overwrite error
 27732                                  ;	on first destination create otherwise), and user trying to specify
 27733                                  ;	destination which has been scribbled already (if dest had been named
 27734                                  ;	first, NoWrite would be set).
 27735                                  
 27736 00003E27 BA[817F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 27737                                  	;invoke	Std_EprintF		;ac022;
 27738                                  	; 26/03/2023
 27739 00003E2A E8EE0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 27740                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 27741 00003E2D C706[E38A]0000          	mov	word [NXTADD],0		; set return
 27742 00003E33 FE06[E78D]              	inc	byte [TERMREAD]		; tell read to give up
 27743                                  Ret60:
 27744 00003E37 C3                      	retn
 27745                                  
 27746                                  NoChecking:
 27747 00003E38 8B1E[238D]              	mov	bx,[DESTHAND]		; get handle
 27748 00003E3C 31C9                    	xor	cx,cx
 27749 00003E3E 870E[E38A]              	xchg	cx,[NXTADD]
 27750 00003E42 E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 27751 00003E44 FF06[E58D]              	inc	word [WRITTEN]		; flag that we wrote something
 27752 00003E48 803E[E38D]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 27753 00003E4D 7514                    	jnz	short SeekEnd
 27754 00003E4F 31D2                    	xor	dx,dx
 27755 00003E51 1E                      	push	ds
 27756 00003E52 8E1E[C28A]              	mov	ds,[TPA]
 27757 00003E56 B440                    	mov	ah,Write ; 40h
 27758 00003E58 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27759                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27760 00003E5A 1F                      	pop	ds
 27761 00003E5B BA[697F]                	mov	dx,NOSPACE_PTR
 27762                                  	;jc	short COPERRP		; failure
 27763                                  	; 26/03/2023
 27764                                  	; MSDOS 6.0
 27765 00003E5E 7326                    	jnc	short NoChecking2
 27766 00003E60 E951FF                  	jmp	Xa_Set_Error
 27767                                  
 27768                                  	; 18/04/2023
 27769                                  	; 26/03/2023
 27770                                  SeekEnd:
 27771 00003E63 31D2                    	xor	dx,dx
 27772 00003E65 87D1                    	xchg	dx,cx
 27773                                  	;mov	ax,(LSEEK shl 8) or 1
 27774 00003E67 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 27775 00003E6A CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27776                                  				; AL = method: offset from present location
 27777                                  
 27778                                  	; 26/03/2023
 27779                                  	; MSDOS 6.0
 27780                                  
 27781                                  ;	Save the file pointer in DX:AX to restore the file
 27782                                  ;	with in case the copy should fail.
 27783                                  
 27784 00003E6C A3[EF8D]                	mov	[OFilePtr_Lo],ax
 27785 00003E6F 8916[F18D]              	mov	[OFilePtr_Hi],dx
 27786                                  
 27787                                  	; 26/03/2023
 27788                                  	; MSDOS 3.3  MSDOS 6.0
 27789                                  
 27790 00003E73 803E[D38A]00            	cmp	byte [RDEOF],0
 27791 00003E78 740B                    	jz	short Retz60
 27792                                  
 27793                                  ;	^Z has been read - we must set the file size to the current
 27794                                  ;	file pointer location
 27795                                  
 27796 00003E7A B440                    	mov	ah,Write ; 40h
 27797 00003E7C CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27798                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27799                                  
 27800                                  	; 26/03/2023
 27801                                  	; MSDOS 6.0
 27802 00003E7E 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 27803                                  
 27804                                  ;	Make note that ^Z was removed, in case the
 27805                                  ;	copy should fail and we need to restore the file.
 27806                                  
 27807 00003E80 C606[F38D]1A            	mov	byte [OCtrlZ],1Ah
 27808                                  Retz60:
 27809 00003E85 C3                      	retn
 27810                                  
 27811                                  NoChecking2:
 27812 00003E86 29C1                    	sub	cx,ax
 27813 00003E88 74AD                    	jz	short Ret60		; wrote all supposed to
 27814                                  	; 18/04/2023
 27815 00003E8A F606[258D]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 27816                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 27817 00003E8F 7414                    	jz	short COPYERR		; is a file, error
 27818 00003E91 F606[258D]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 27819                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 27820 00003E96 750A                    	jnz	short DevWrtErr	; is a raw device, error
 27821 00003E98 803E[E28D]00            	cmp	byte [INEXACT],0
 27822 00003E9D 7598                    	jnz	short Ret60		; inexact so ok
 27823 00003E9F 49                      	dec	cx
 27824                                  ;Retz60:
 27825 00003EA0 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 27826                                  
 27827                                  DevWrtErr:
 27828 00003EA2 BA[EC80]                	mov	dx,DEVWMES_PTR
 27829                                  	; 26/03/2023
 27830                                  COPYERR:
 27831                                  	;invoke	Std_EPrintF		;AC022;
 27832 00003EA5 E8730F                  	call	std_eprintf  ; MSDOS 6.0
 27833                                  	;call	STD_PRINTF   ; MSDOS 3.3
 27834                                  CopErrP:
 27835 00003EA8 FE06[E08A]              	inc	byte [DestClosed]
 27836 00003EAC 803E[DF8A]00            	cmp	byte [CFLAG],0
 27837 00003EB1 7448                    	jz	short EndCopyJ		; never actually got it open
 27838 00003EB3 8B1E[238D]              	mov	bx,[DESTHAND]
 27839 00003EB7 83FB00                  	cmp	bx,0
 27840 00003EBA 7E33                    	jle	short NoClose
 27841                                  
 27842                                  ;	Check to see if we should save part of the destination file.
 27843                                  
 27844                                  	; 26/03/2023
 27845                                  	; MSDOS 6.0
 27846 00003EBC 8B0E[F18D]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 27847 00003EC0 8B16[EF8D]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 27848                                  			
 27849 00003EC4 89C8                    	mov	ax,cx
 27850 00003EC6 09D0                    	or	ax,dx
 27851 00003EC8 7421                    	jz	short ceClose		; null file ptr means nothing to save
 27852                                  
 27853                                  ;	Destination was also the first source. Do the best we can to
 27854                                  ;	restore it. Truncate it back to the size we took from it (which
 27855                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 27856                                  ;	file). If a Ctrl-Z was originally read, put it back.
 27857                                  
 27858 00003ECA B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 27859 00003ECD CD21                    	int	21h
 27860                                  
 27861 00003ECF 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 27862 00003ED1 B440                    	mov	ah,Write ; 40h
 27863 00003ED3 CD21                    	int	21h			; truncate file
 27864                                  
 27865 00003ED5 803E[F38D]00            	cmp	byte [OCtrlZ],0
 27866 00003EDA 7408                    	je	short ceClose0		; no ctrl-z removed from original
 27867 00003EDC 41                      	inc	cx			; CX = # bytes to write = 1
 27868 00003EDD BA[F38D]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 27869 00003EE0 B440                    	mov	ah,Write ; 40h
 27870 00003EE2 CD21                    	int	21h			; write ctrl-z
 27871                                  ceClose0:
 27872 00003EE4 B43E                    	mov	ah,CLOSE ; 3Eh
 27873 00003EE6 CD21                    	int	21h			; close it
 27874                                  ;;	;mov	byte [CFLAG],0
 27875 00003EE8 E980FA                  	jmp	ENDCOPY			; and go home
 27876                                  
 27877                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27878                                  ceClose:
 27879 00003EEB B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 27880 00003EED CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27881                                  				; BX = file handle
 27882                                  NoClose:
 27883 00003EEF BA[CC8C]                	mov	dx,DestBuf
 27884 00003EF2 B441                    	mov	ah,Unlink ; 41h 	; and delete it
 27885 00003EF4 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 27886                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 27887 00003EF6 C606[DF8A]00            	mov	byte [CFLAG],0
 27888                                  EndCopyJ:
 27889 00003EFB E96DFA                  	jmp	ENDCOPY
 27890                                  
 27891                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 27892 00003EFE E9B3FE                  	jmp	Xa_Set_Error
 27893                                  
 27894                                  ;============================================================================
 27895                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 27896                                  ;============================================================================
 27897                                  ; 01/10/2018 - Retro DOS v3.0
 27898                                  
 27899                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 27900                                  
 27901                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27902                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 27903                                  
 27904                                  ; =============== S U B	R O U T	I N E =======================================
 27905                                  
 27906                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 27907                                  ;
 27908                                  ;	Given switch vector in AX,
 27909                                  ;	  Set Ascii flag if /a is set
 27910                                  ;	  Clear Ascii flag if /b is set
 27911                                  ;	  Binary set if /b specified
 27912                                  ;	  Leave Ascii unchanged if neither or both are set
 27913                                  ; 	Also sets Inexact if Ascii is ever set. 
 27914                                  ;	AL = Ascii on exit, flags set
 27915                                  
 27916                                  	; 26/03/2023
 27917                                  SETASC:
 27918                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 27919 00003F01 240C                    	and	al,0Ch ; 4+8
 27920 00003F03 7A10                    	jpe	short LOADSW	; even parity - both or neither
 27921 00003F05 50                      	push	ax
 27922                                  	;and	al,SWITCHB  ; 8
 27923 00003F06 2408                    	and	al,8
 27924 00003F08 A2[E48D]                	mov	[BINARY],al
 27925 00003F0B 58                      	pop	ax
 27926                                  	;and	al,SWITCHA
 27927 00003F0C 2404                    	and	al,4	
 27928 00003F0E A2[E88D]                	mov	[ASCII],al
 27929 00003F11 0806[E28D]              	or	[INEXACT],al
 27930                                  LOADSW:
 27931 00003F15 A0[E88D]                	mov	al,[ASCII]
 27932 00003F18 08C0                    	or	al,al
 27933 00003F1A C3                      	retn
 27934                                  
 27935                                  ; =============== S U B	R O U T	I N E =======================================
 27936                                  
 27937                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27938                                  BUILDDEST:
 27939 00003F1B 803E[C78C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 27940 00003F20 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 27941 00003F22 BF[A289]                	mov	di,USERDIR1
 27942 00003F25 BD[C78C]                	mov	bp,DestVars
 27943 00003F28 E8DF00                  	call	BUILDPATH
 27944 00003F2B E858E5                  	call	RestUDir1
 27945                                  
 27946                                  ;	We now know all about the destination
 27947                                  
 27948                                  KNOWABOUTDEST:
 27949 00003F2E 30C0                    	xor	al,al
 27950 00003F30 8606[268D]              	xchg	al,[FIRSTDEST]
 27951 00003F34 08C0                    	or	al,al
 27952 00003F36 7503                    	jnz	short FIRSTDST
 27953 00003F38 E98C00                  	jmp	NOFIRSTDEST
 27954                                  
 27955                                  FIRSTDST:
 27956                                  ;	Create an fcb of the original dest.
 27957                                  
 27958 00003F3B 8B36[C98C]              	mov	si,[DestTail]
 27959 00003F3F BF[868B]                	mov	di,DestFcb
 27960 00003F42 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27961 00003F45 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27962                                  				; DS:SI	-> string to parse
 27963                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27964                                  				; AL = bit mask	to control parsing
 27965 00003F47 803C00                  	cmp	byte [si],0
 27966 00003F4A 7406                    	jz	short GOODPARSE
 27967                                  
 27968                                  	; 27/03/2023	
 27969                                  	; MSDOS 6.0
 27970                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 27971                                  	
 27972 00003F4C BA[6F7F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 27973 00003F4F E953FF                  	jmp	COPYERR			;AN052;
 27974                                  GOODPARSE:
 27975 00003F52 A1[CC8C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 27976 00003F55 80FC3A                  	cmp	ah,':'
 27977 00003F58 7402                    	jz	short DRVSPEC4
 27978 00003F5A B040                    	mov	al,'@'  ; 40h
 27979                                  DRVSPEC4:
 27980                                  ;	AX = "d:" for following FCB drive computation
 27981                                  
 27982 00003F5C 8A0E[E88D]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 27983 00003F60 0C20                    	or	al,20h
 27984 00003F62 2C60                    	sub	al,60h
 27985 00003F64 A2[868B]                	mov	[DestFcb],al		; store drive # in FCB
 27986                                  
 27987                                  ;*	Figure out what copy mode we're in.
 27988                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 27989                                  ;	+n stands for additional sources delimited by +'s.
 27990                                  ;
 27991                                  ;	copy a b	not concatenating
 27992                                  ;	copy a *	not concatenating
 27993                                  ;	copy * a	concatenating
 27994                                  ;	copy * *	not concatenating
 27995                                  ;	copy a+n b	concatenating
 27996                                  ;	copy *+n a	concatenating
 27997                                  ;	copy *+n *	concatenating, Mel Hallerman style
 27998                                  
 27999                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28000                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28001                                  
 28002 00003F67 A0[CB8C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28003 00003F6A 8A26[2E8D]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28004 00003F6E 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28005 00003F71 08C0                    	or	al,al
 28006 00003F73 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28007                                  
 28008                                  ;	Destination is wildcarded.
 28009                                  	
 28010 00003F75 38E0                    	cmp	al,ah
 28011 00003F77 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28012                                  
 28013                                  ;	Source and destination are both wildcarded.
 28014                                  
 28015 00003F79 803E[E98D]00            	cmp	byte [PLUS],0
 28016 00003F7E 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28017                                  
 28018                                  ;	Source and destination are wildcarded, and source includes +'s.
 28019                                  ;	It's Mel Hallorman copy time.
 28020                                  
 28021 00003F80 FE06[278D]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28022 00003F84 30C0                    	xor	al,al
 28023 00003F86 EB06                    	jmp	short SETCONC
 28024                                  
 28025                                  NOTMELCOPY:
 28026 00003F88 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28027 00003F8A 20E0                    	and	al,ah
 28028 00003F8C D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28029                                  					;   (implies concatenation)
 28030                                  SETCONC:
 28031 00003F8E 0A06[E98D]              	or	al,[PLUS]		; "+" always infers concatenation
 28032                                  
 28033                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28034                                  
 28035 00003F92 A2[D58A]                	mov	[Concat],al
 28036 00003F95 D0E0                    	shl	al,1
 28037 00003F97 D0E0                    	shl	al,1
 28038 00003F99 A2[E28D]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28039 00003F9C 803E[E48D]00            	cmp	byte [BINARY],0
 28040 00003FA1 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 28041                                  
 28042 00003FA3 A2[E88D]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode	
 28043 00003FA6 08C9                    	or	cl,cl
 28044 00003FA8 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 28045 00003FAA 08C0                    	or	al,al
 28046 00003FAC 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28047                                  
 28048                                  ;	At this point there may already be binary read data in the read
 28049                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28050                                  ;	amount of data in the buffer correctly.
 28051                                  
 28052 00003FAE 8B0E[E38A]              	mov	cx,[NXTADD]
 28053 00003FB2 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28054 00003FB4 B01A                    	mov	al,1Ah
 28055 00003FB6 06                      	push	es
 28056 00003FB7 31FF                    	xor	di,di
 28057 00003FB9 8E06[C28A]              	mov	es,[TPA]
 28058 00003FBD F2AE                    	repne	scasb			; scan for EOF
 28059 00003FBF 07                      	pop	es
 28060 00003FC0 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28061 00003FC2 4F                      	dec	di			; point at ^z
 28062 00003FC3 893E[E38A]              	mov	[NXTADD],di		; new buffer length
 28063                                  
 28064                                  NOFIRSTDEST:
 28065 00003FC7 BB[CA8B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28066 00003FCA 803E[D58A]00            	cmp	byte [Concat],0
 28067 00003FCF 7403                    	jz	short GOTCHRSRC		; Not a concat
 28068 00003FD1 BB[108C]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28069                                  GOTCHRSRC:
 28070 00003FD4 BE[878B]                	mov	si,DestFcb+1		; Original dest name
 28071 00003FD7 8B3E[C98C]              	mov	di,[DestTail]		; Where to put result
 28072                                  
 28073                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28074                                  
 28075                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28076                                  BUILDNAME:
 28077 00003FDB B90800                  	mov	cx,8
 28078                                  BUILDMAIN:
 28079 00003FDE AC                      	lodsb
 28080 00003FDF 3C3F                    	cmp	al,'?'
 28081 00003FE1 7502                    	jne	short NOTAMBIG
 28082 00003FE3 8A07                    	mov	al,[bx]
 28083                                  NOTAMBIG:
 28084 00003FE5 3C20                    	cmp	al,' '
 28085 00003FE7 7401                    	je	short NOSTORE
 28086 00003FE9 AA                      	stosb
 28087                                  NOSTORE:
 28088 00003FEA 43                      	inc	bx
 28089 00003FEB E2F1                    	loop	BUILDMAIN
 28090 00003FED B103                    	mov	cl,3
 28091                                  	;mov	al,' ' ; 20h
 28092                                  	;cmp	[si],al
 28093                                  	; 27/03/2023
 28094 00003FEF 803C20                  	cmp	byte [si],20h ; ' '
 28095 00003FF2 7412                    	je	short ENDDEST		; No extension
 28096                                  	;mov	al,[DOT_CHR]
 28097                                  	; 27/03/2023
 28098 00003FF4 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28099 00003FF6 AA                      	stosb
 28100                                  BUILDEXT:
 28101 00003FF7 AC                      	lodsb
 28102 00003FF8 3C3F                    	cmp	al,'?'
 28103 00003FFA 7502                    	jne	short NOTAMBIGE
 28104 00003FFC 8A07                    	mov	al,[bx]
 28105                                  NOTAMBIGE:
 28106 00003FFE 3C20                    	cmp	al,' '
 28107 00004000 7401                    	je	short NOSTOREE
 28108 00004002 AA                      	stosb
 28109                                  NOSTOREE:
 28110 00004003 43                      	inc	bx
 28111 00004004 E2F1                    	loop	BUILDEXT
 28112                                  ENDDEST:
 28113 00004006 30C0                    	xor	al,al
 28114 00004008 AA                      	stosb				; NUL terminate
 28115 00004009 C3                      	retn
 28116                                  
 28117                                  ; =============== S U B	R O U T	I N E =======================================
 28118                                  	
 28119                                  	; 28/03/2023
 28120                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28121                                  BUILDPATH:
 28122 0000400A F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 28123 0000400E 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28124 00004010 89EA                    	mov	dx,bp			; Set DX to spec
 28125 00004012 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28126                                  
 28127                                  	; 27/03/2023
 28128                                  	; MSDOS 6.0
 28129 00004015 57                      	push	di			;AN000;
 28130 00004016 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28131                                  	;mov	bx,deny_none|read_open_mode
 28132 00004019 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28133 0000401C 31C9                    	xor	cx,cx			;AN000; no special files
 28134 0000401E 89D6                    	mov	si,dx			;AN030; get file name offset
 28135                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28136 00004020 BA0101                  	mov	dx,101h
 28137 00004023 CD21                    	INT	21h
 28138 00004025 5F                      	pop	di			;AN000;
 28139 00004026 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28140 00004028 E8D7DC                  	call	get_ext_error_number	;AN022; get the extended error
 28141                                  	;cmp	ax,2
 28142 0000402B 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28143 0000402E 7423                    	jz	short NOTPFILE		;AN022;
 28144                                  	;cmp	ax,3
 28145 00004030 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28146 00004033 741E                    	jz	short NOTPFILE		;AN022;
 28147                                  	;cmp	ax,5
 28148 00004035 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28149 00004038 7419                    	jz	short NOTPFILE		;AN022;
 28150 0000403A E905DA                  	jmp	extend_setup		;AN022; exit with error
 28151                                  
 28152                                  	; 27/03/2023
 28153                                  	; MSDOS 3.3
 28154                                  	;mov	ax,OPEN*256 ; 3D00h
 28155                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28156                                  	;			; DS:DX	-> ASCIZ filename
 28157                                  	;			; AL = access mode
 28158                                  	;			; 0 - read
 28159                                  	;jc	short NOTPFILE
 28160                                  
 28161                                  PURE_FILE:
 28162 0000403D 89C3                    	mov	bx,ax
 28163 0000403F B80044                  	mov	ax,IOCTL*256 ; 4400h
 28164 00004042 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28165                                  				; BX = file or device handle
 28166 00004044 B43E                    	mov	ah,CLOSE ;3Eh
 28167 00004046 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28168                                  				; BX = file handle
 28169                                  	; 18/04/2023
 28170 00004048 F6C280                  	test	dl,80h
 28171                                  	;test	dl,devid_ISDEV ; test dl,80h
 28172 0000404B 7553                    	jnz	short ISADEV
 28173 0000404D F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28174 00004051 744D                    	jz	short ISADEV
 28175                                  NOTPFILE:
 28176 00004053 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28177                                  	
 28178                                  	; 27/03/2023	
 28179                                  	; MSDOS 6.0
 28180 00004056 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28181 00004059 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28182                                  
 28183 0000405B 80FE3A                  	cmp	dh,':'
 28184 0000405E 7402                    	je	short DRVSPEC5
 28185                                  SET_DRIVE_SPEC:
 28186 00004060 B240                    	mov	dl,'@' ; 40h
 28187                                  DRVSPEC5:
 28188 00004062 80CA20                  	or	dl,20h
 28189 00004065 80EA60                  	sub	dl,60h		; A = 1
 28190 00004068 E84BE5                  	call	SAVUDIR1
 28191                                  	
 28192                                  	; 27/03/2023
 28193                                  	; MSDOS 6.0
 28194 0000406B 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28195 0000406D E892DC                  	call	get_ext_error_number	;AN022; get the extended error
 28196 00004070 E9CFD9                  	jmp	extend_setup		;AN022; exit with error
 28197                                  
 28198                                  CURDIR_OK:
 28199 00004073 89EA                    	mov	dx,bp
 28200                                  	;add	dx,5
 28201 00004075 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28202                                  	;mov	bh,[bp+4]
 28203 00004078 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28204 0000407B 80E706                  	and	bh,6
 28205 0000407E 80FF06                  	cmp	bh,6			; Ambig and path ?
 28206 00004081 7518                    	jne	short CHECKAMB		; jmp if no
 28207                                  	;mov	si,[bp+2]
 28208 00004083 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28209 00004086 B33A                    	mov	bl,':'
 28210 00004088 385CFE                  	cmp	[si-2],bl
 28211 0000408B 7506                    	jne	short KNOWNOTSPEC
 28212                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28213                                  					; Know is d:/file
 28214                                  	;mov	byte [bp+0],2
 28215 0000408D C6460002                	mov	byte [bp],2
 28216 00004091 EB05                    	jmp	short DOPCDJ
 28217                                  KNOWNOTSPEC:
 28218                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28219                                  					; Know is path/file
 28220                                  	;mov	byte [bp+0],1		
 28221 00004093 C6460001                	mov	byte [bp],1
 28222 00004097 4E                      	dec	si
 28223                                  DOPCDJ:
 28224 00004098 E98500                  	jmp	DOPCD
 28225                                  CHECKAMB:
 28226 0000409B 80FF02                  	cmp	bh,2
 28227 0000409E 7505                    	jnz	short CHECKCD
 28228                                  ISSIMPFILE:
 28229                                  ISADEV:
 28230                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28231                                  	;mov	byte [bp+0],0		
 28232 000040A0 C6460000                	mov	byte [bp],0
 28233 000040A4 C3                      	retn
 28234                                  CHECKCD:
 28235 000040A5 E84AEC                  	call	SetRest1
 28236 000040A8 B43B                    	mov	ah,CHDir ; 3Bh
 28237 000040AA CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28238                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28239 000040AC 723B                    	jb	short NOTPDIR
 28240 000040AE 89D7                    	mov	di,dx
 28241 000040B0 31C0                    	xor	ax,ax
 28242 000040B2 89C1                    	mov	cx,ax
 28243 000040B4 49                      	dec	cx
 28244 000040B5 F2AE                    	repne	scasb
 28245                                  
 28246                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28247                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28248                                  	; MSDOS 6.0
 28249                                  Kloop:					;AN000;  3/3/KK
 28250 000040B7 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28251 000040BA 47                      	inc	di			;AN000;  3/3/KK
 28252 000040BB 08C0                    	or	al,al			;AN000;  3/3/KK
 28253 000040BD 740C                    	jz	short DONE		;AN000;  3/3/KK
 28254 000040BF 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28255 000040C1 E800E3                  	call	testkanj		;AN000;  3/3/KK
 28256 000040C4 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28257 000040C6 47                      	inc	di			;AN000;  3/3/KK
 28258 000040C7 FEC4                    	inc	ah			;AN000;  3/3/KK
 28259 000040C9 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28260                                  DONE:
 28261 000040CB 4F                      	dec	di
 28262 000040CC A0[C58A]                	mov	al,[DIRCHAR]
 28263                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28264                                  	;mov	byte [bp+0],2
 28265 000040CF C6460002                	mov	byte [bp],2
 28266                                  	; 27/03/2023
 28267                                  	; MSDOS 6.0
 28268 000040D3 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28269 000040D5 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 28270                                  	;
 28271 000040D7 3A45FF                  	cmp	al,[di-1]
 28272 000040DA 7405                    	jz	short GOTSRCSLSH
 28273                                  _STORE_PCHAR:
 28274 000040DC AA                      	stosb
 28275                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28276                                  	;mov	byte [bp+0],1
 28277 000040DD C6460001                	mov	byte [bp],1
 28278                                  GOTSRCSLSH:
 28279                                  	;or	byte [bp+4],6
 28280 000040E1 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 28281 000040E5 E87400                  	call	SETSTARS
 28282                                  NOTPDIR_RETN:
 28283 000040E8 C3                      	retn
 28284                                  
 28285                                  	; 28/03/2023
 28286                                  NOTPDIR:
 28287                                  	; MSDOS 6.0
 28288 000040E9 E816DC                  	call	get_ext_error_number	;AN022; get the extended error
 28289                                  	;cmp	ax,3
 28290 000040EC 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28291 000040EF 7405                    	je	short NOTPDIR_TRY	;AN022;
 28292                                  	;cmp	ax,5
 28293 000040F1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28294 000040F4 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28295                                  NOTPDIR_TRY:
 28296                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28297                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28298                                  	;mov	byte [bp+0],0
 28299 000040F6 C6460000                	mov	byte [bp],0
 28300                                  	;mov	bh,[bp+4]
 28301 000040FA 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28302 000040FD F6C704                  	test	bh,4
 28303 00004100 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28304                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28305                                  	;mov	byte [bp+0],2		
 28306 00004102 C6460002                	mov	byte [bp],2
 28307                                  	;mov	si,[bp+2]
 28308 00004106 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28309 00004109 803C00                  	cmp	byte [si],0
 28310 0000410C 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 28311                                  	;mov	bl,[DOT_CHR]
 28312                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28313                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28314 0000410E B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28315 00004110 381C                    	cmp	[si],bl
 28316 00004112 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28317 00004114 B33A                    	mov	bl,':'  ; 3Ah
 28318 00004116 385CFE                  	cmp	[si-2],bl
 28319 00004119 7405                    	je	short DOPCD		; Know d:/file
 28320                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 28321                                  					; Know path/file
 28322                                  	;mov	byte [bp+0],1
 28323 0000411B C6460001                	mov	byte [bp],1
 28324 0000411F 4E                      	dec	si			; Point at last '/'
 28325                                  DOPCD:
 28326 00004120 30DB                    	xor	bl,bl
 28327 00004122 861C                    	xchg	bl,[si]			; Stick in a NUL
 28328 00004124 E8CBEB                  	call	SetRest1
 28329                                  
 28330                                  	; 28/03/2023
 28331                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28332 00004127 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28333 00004129 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28334 0000412B 56                      	push	si			;AN000;  3/3/KK
 28335 0000412C 51                      	push	cx			;AN000;  3/3/KK
 28336 0000412D 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28337 0000412F 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28338                                  Kloop2: 				;AN000;  3/3/KK
 28339 00004131 AC                      	lodsb				;AN000;  3/3/KK
 28340 00004132 E88FE2                  	call	testkanj		;AN000;  3/3/KK
 28341 00004135 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28342 00004137 AC                      	lodsb				;AN000;  3/3/KK
 28343 00004138 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28344 0000413A 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28345 0000413C 59                      	pop	cx			;AN000;  3/3/KK
 28346 0000413D 5E                      	pop	si			;AN000;  3/3/KK
 28347 0000413E EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28348                                  					;		 trailing path sep
 28349                                  NotKanj4:				;AN000;  3/3/KK
 28350 00004140 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28351 00004142 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28352 00004144 59                      	pop	cx			;AN000;  3/3/KK
 28353 00004145 5E                      	pop	si			;AN000;  3/3/KK
 28354                                  LookBack:				;AN000;  3/3/KK
 28355                                  	; 28/03/2023
 28356                                  	; MSDOS 3.3 & MSDOS 6.0
 28357 00004146 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28358 00004149 740E                    	je	short BADCDERRJ2
 28359                                  DoCdr:
 28360 0000414B B43B                    	mov	ah,CHDir ; 3Bh
 28361 0000414D CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28362                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28363 0000414F 861C                    	xchg	bl,[si]
 28364 00004151 7395                    	jnc	short NOTPDIR_RETN
 28365                                  	
 28366                                  	; 28/03/2023
 28367                                  	; MSDOS 3.3
 28368                                  ;BADCDERRJ2:
 28369                                  	;stc
 28370                                  	;jmp	BADCDERR
 28371                                  
 28372                                  	; 28/03/2023
 28373                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28374 00004153 E8ACDB                  	call	get_ext_error_number	;AN022; get the extended error
 28375                                  EXTEND_SETUPJ:					;AN022;
 28376 00004156 E9E9D8                  	jmp	extend_setup		;AN022; go issue the error message
 28377                                  BADCDERRJ2:
 28378 00004159 E9E3D8                  	jmp	badpath_err		;AC022; go issue path not found message
 28379                                  
 28380                                  ; =============== S U B	R O U T	I N E =======================================
 28381                                  
 28382                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28383                                  SETSTARS:
 28384                                  	;mov	[bp+2],di
 28385 0000415C 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28386                                  	;add	byte [bp+1],12
 28387 0000415F 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28388                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28389                                  	; 28/03/2023
 28390                                  	; MSDOS 6.0
 28391 00004163 B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28392                                  	;mov	ax,'?.' ; dot_qmark
 28393                                  
 28394 00004166 B90800                  	mov	cx,8
 28395 00004169 F3AA                    	rep	stosb
 28396 0000416B 86C4                    	xchg	al,ah
 28397 0000416D AA                      	stosb
 28398 0000416E 86C4                    	xchg	al,ah
 28399 00004170 B103                    	mov	cl,3
 28400 00004172 F3AA                    	rep	stosb
 28401 00004174 30C0                    	xor	al,al
 28402 00004176 AA                      	stosb
 28403 00004177 C3                      	retn
 28404                                  
 28405                                  ; =============== S U B	R O U T	I N E =======================================
 28406                                  
 28407                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28408                                  COMPNAME:
 28409 00004178 BE[CC8C]                	mov	si,DestBuf	; do name translate of target
 28410 0000417B BF[4588]                	mov	di,TRGXNAME	; save for name comparison
 28411 0000417E B460                    	mov	ah,xNameTrans ; 60h
 28412 00004180 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28413                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28414                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28415 00004182 BE[EE87]                	mov	si,SRCXNAME	; get name translate of source
 28416 00004185 BF[4588]                	mov	di,TRGXNAME	; get name translate of target
 28417                                  	;call	STRCOMP
 28418                                  	;retn
 28419                                  	; 28/03/2023
 28420 00004188 E99DE4                  	jmp	STRCOMP
 28421                                  
 28422                                  ;============================================================================
 28423                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28424                                  ;============================================================================
 28425                                  ; 30/09/2018 - Retro DOS v3.0
 28426                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28427                                  
 28428                                  ;-----------------------------------------------------------------------;
 28429                                  ; ENTRY:								;
 28430                                  ;	DS:SI	Points input buffer					;
 28431                                  ;	ES:DI	Points to the token buffer				;
 28432                                  ;	BL	Special delimiter for this call 			;
 28433                                  ;		    Always checked last 				;
 28434                                  ;		    set it to space if there is no special delimiter	;
 28435                                  ; EXIT: 								;
 28436                                  ;	DS:SI	Points to next char in the input buffer 		;
 28437                                  ;	ES:DI	Points to the token buffer				;
 28438                                  ;	[STARTEL] Points to start of last element of path in token	;
 28439                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28440                                  ;	CX	Character count 					;
 28441                                  ;	BH	Condition Code						;
 28442                                  ;			Bit 1H of BH set if switch character		;
 28443                                  ;				Token buffer contains char after	;
 28444                                  ;				switch character			;
 28445                                  ;				BP has switch bits set (ORing only)	;
 28446                                  ;			Bit 2H of BH set if ? or * in token		;
 28447                                  ;				if * found element ? filled		;
 28448                                  ;			Bit 4H of BH set if path sep in token		;
 28449                                  ;			Bit 80H of BH set if the special delimiter	;
 28450                                  ;			   was skipped at the start of this token	;
 28451                                  ;		Token buffer always starts d: for non switch tokens	;
 28452                                  ;	CARRY SET							;
 28453                                  ;	    if CR on input						;
 28454                                  ;		token buffer not altered				;
 28455                                  ;									;
 28456                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28457                                  ; MODIFIES:								;
 28458                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28459                                  ;									;
 28460                                  ;-----------------------------------------------------------------------;
 28461                                  
 28462                                  ; Modifications to cparse: recognition of right and left parentheses
 28463                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28464                                  ;
 28465                                  ; Both modifications were installed in the course of adding a coherent
 28466                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28467                                  ; structure for command-line arguments. This parser relies on cparse to
 28468                                  ; recognize individual tokens.
 28469                                  ;
 28470                                  ; To process for-loops correctly, parentheses must therefore be
 28471                                  ; recognized as tokens. The upper-case conversion code was removed so
 28472                                  ; that commands (such as for and echo) would be able to use the "original"
 28473                                  ; text of the command line.
 28474                                  ;
 28475                                  ; Note also the modification to prevent the automatic conversion of colons
 28476                                  ; into spaces WITHIN THE SOURCE TEXT!
 28477                                  ;
 28478                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28479                                  ; on the command line.
 28480                                  ;
 28481                                  ; Alan L, OS/MSDOS				    14 August 1983
 28482                                  
 28483                                  ; ---------------------------------------------------------------------------
 28484                                  
 28485                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28486                                  
 28487                                  ;FSWITCH	EQU	8000h
 28488                                  ;FBADSWITCH	EQU	4000h
 28489                                  
 28490                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28491                                  
 28492                                  ; =============== S U B	R O U T	I N E =======================================
 28493                                  		
 28494                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28495                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28496                                  
 28497                                  cparse:
 28498 0000418B 31C0                    	xor	ax,ax
 28499 0000418D 893E[F68D]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28500 00004191 A2[F98D]                	mov	[ELPOS],al		; Start in 8 char prefix
 28501                                  	; MSDOS 3.3
 28502                                  	;mov	[SOURCE],al		
 28503                                  	; MSDOS 6.0
 28504 00004194 A2[FA8D]                	mov	[SKPDEL], al		; No skip delimiter yet
 28505 00004197 88C7                    	mov	bh,al			; Init nothing
 28506 00004199 9C                      	pushf				; save flags
 28507 0000419A 57                      	push	di			; save the token buffer addrss
 28508 0000419B 31C9                    	xor	cx,cx			; no chars in token buffer
 28509 0000419D 880E[258C]              	mov	[comma],cl		; reset comma flag
 28510                                  moredelim:
 28511 000041A1 AC                      	lodsb
 28512 000041A2 E849E4                  	call	DELIM
 28513 000041A5 751D                    	jnz	short SCANCDONE
 28514 000041A7 3C20                    	cmp	al,' '
 28515 000041A9 74F6                    	jz	short moredelim
 28516 000041AB 3C09                    	cmp	al,9
 28517 000041AD 74F2                    	jz	short moredelim
 28518                                  	;xchg	al,[SOURCE]
 28519                                  	; 28/03/2023
 28520 000041AF 8606[FA8D]              	xchg	al,[SKPDEL]
 28521 000041B3 08C0                    	or	al,al
 28522 000041B5 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28523 000041B7 F6C780                  	test	bh,80h			; has a special char been found?
 28524 000041BA 7405                    	jz	short no_comma		; no - just exit
 28525 000041BC C606[258C]01            	mov	byte [comma],1		; set comma flag
 28526                                  no_comma:
 28527 000041C1 E92A01                  	jmp	x_done			; Nul argument
 28528                                  
 28529                                  SCANCDONE:
 28530                                  	; 28/03/2023
 28531                                  	; MSDOS 6.0
 28532                                  	; -----------------------------------
 28533                                  	; Mod to avoid upper-case conversion.
 28534                                  	; -----------------------------------
 28535                                  	; MSDOS 3.3
 28536                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28537                                  	;jnz	short cpcont1		; 3/3/KK
 28538                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28539                                  cpcont1:
 28540                                  	; -----------------------------------
 28541                                  	; 28/03/2023
 28542 000041C4 38D8                    	cmp	al,bl			; Special delimiter?
 28543 000041C6 7505                    	jne	short nospec
 28544 000041C8 80CF80                  	or	bh,80h
 28545 000041CB EBD4                    	jmp	short moredelim
 28546                                  nospec:
 28547 000041CD 3C0D                    	cmp	al,0Dh			; a CR?
 28548 000041CF 7503                    	jne	short ncperror
 28549 000041D1 E91501                  	jmp	cperror
 28550                                  ncperror:
 28551 000041D4 3A06[C48A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28552 000041D8 7503                    	jne	short na_switch		; yes, process...
 28553 000041DA E91401                  	jmp	a_switch
 28554                                  na_switch:
 28555 000041DD B23A                    	mov	dl,':'
 28556 000041DF 3814                    	cmp	[si],dl
 28557 000041E1 751D                    	jne	short anum_chard	; Drive not specified
 28558                                  	; 28/03/2023
 28559                                  	; MSDOS 6.0 
 28560 000041E3 803E[B48C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28561 000041E8 7503                    	jne	short cpcont2		; 3/3/KK
 28562 000041EA E801E2                  	call	UPCONV			; 3/3/KK
 28563                                  cpcont2:
 28564 000041ED E85901                  	call	move_char
 28565 000041F0 AC                      	lodsb				; Get the ':'
 28566 000041F1 E85501                  	call	move_char
 28567 000041F4 893E[F68D]              	mov	[STARTEL],di
 28568 000041F8 C606[F88D]00            	mov	byte [ELCNT],0
 28569 000041FD E9B300                  	jmp	anum_test
 28570                                  anum_chard:
 28571 00004200 893E[F68D]              	mov	[STARTEL],di
 28572 00004204 C606[F88D]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28573 00004209 803E[B48C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28574 0000420E 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28575 00004210 E861E4                  	call	pathchrcmp		; Starts with a pathchar?
 28576 00004213 7518                    	jnz	short anum_char		; no
 28577 00004215 50                      	push	ax
 28578 00004216 A0[D48A]                	mov	al,[CURDRV]		; Insert drive spec
 28579                                  	;add	al,[CAPITAL_A]
 28580                                  	; 28/03/2023
 28581                                  	; MSDOS 6.0
 28582 00004219 0441                    	add	al,'A' ; 41h
 28583 0000421B E82B01                  	call	move_char
 28584 0000421E B03A                    	mov	al,':' ; 3Ah
 28585 00004220 E82601                  	call	move_char
 28586 00004223 58                      	pop	ax
 28587 00004224 893E[F68D]              	mov	[STARTEL],di
 28588 00004228 C606[F88D]00            	mov	byte [ELCNT],0
 28589                                  anum_char:
 28590                                  	; 28/03/2023
 28591                                  	; MSDOS 6.0
 28592 0000422D E894E1                  	call	testkanj		;AC048			
 28593 00004230 7406                    	jz	short NOTKANJ		;AC048;
 28594 00004232 E81401                  	call	move_char
 28595 00004235 AC                      	lodsb
 28596 00004236 EB78                    	jmp	short notspecial
 28597                                  
 28598                                  NOTKANJ:				;AN048; If not kanji
 28599 00004238 803E[B48C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28600 0000423D 7503                    	jne	short TESTDOT 		;AN048;
 28601 0000423F E8ACE1                  	call	UPCONV			;AN048; upper case the char
 28602                                  TESTDOT:
 28603                                  	; 28/03/2023
 28604                                  	;cmp	al,dot_chr  ; 2Eh
 28605 00004242 3C2E                    	cmp	al,'.'
 28606 00004244 7509                    	jne	short testquest
 28607 00004246 FE06[F98D]              	inc	byte [ELPOS] 		; flag in extension
 28608 0000424A C606[F88D]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28609                                  testquest:
 28610 0000424F 3C3F                    	cmp	al,'?'  ; 3Fh
 28611 00004251 7503                    	jnz	short testsplat
 28612 00004253 80CF02                  	or	bh,2
 28613                                  testsplat:
 28614                                  	;cmp	al,[STAR]
 28615 00004256 3C2A                    	cmp	al,star	; 2Ah
 28616                                  	; 27/04/2023
 28617                                  	;cmp	al,'*' 
 28618 00004258 7530                    	jne	short testpath
 28619 0000425A 80CF02                  	or	bh,2
 28620 0000425D 803E[318E]00            	cmp	byte [expand_star],0
 28621 00004262 7504                    	jne	short expand_filename
 28622 00004264 EB24                    	jmp	short testpath
 28623                                  
 28624                                  BADPERR2J:
 28625                                  	;jmp	BADPERR2
 28626                                  	; 28/03/2023
 28627                                  	; MSDOS 6.0
 28628 00004266 EB75                    	jmp	short BADPERR2
 28629                                  
 28630                                  expand_filename:
 28631 00004268 B407                    	mov	ah,7
 28632 0000426A 803E[F98D]00            	cmp	byte [ELPOS],0
 28633 0000426F 7402                    	jz	short gotelcnt
 28634 00004271 B402                    	mov	ah,2
 28635                                  gotelcnt:
 28636 00004273 B03F                    	mov	al,'?'
 28637 00004275 2A26[F88D]              	sub	ah,[ELCNT]
 28638 00004279 72EB                    	jb	short BADPERR2J
 28639 0000427B 86E1                    	xchg	ah,cl
 28640 0000427D E309                    	jcxz	testpathx
 28641                                  qmove:
 28642 0000427F 86E1                    	xchg	ah,cl
 28643 00004281 E8C500                  	call	move_char
 28644 00004284 86E1                    	xchg	ah,cl
 28645 00004286 E2F7                    	loop	qmove
 28646                                  testpathx:
 28647 00004288 86E1                    	xchg	ah,cl
 28648                                  testpath:
 28649 0000428A E8E7E3                  	call	pathchrcmp
 28650 0000428D 7521                    	jnz	short notspecial
 28651 0000428F 80CF04                  	or	bh,4
 28652 00004292 803E[318E]00            	cmp	byte [expand_star],0
 28653 00004297 7405                    	jz	short no_err_check
 28654 00004299 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28655 0000429C 7545                    	jnz	short BADPERR
 28656                                  no_err_check:
 28657 0000429E 893E[F68D]              	mov	[STARTEL],di	  	; New element
 28658 000042A2 FF06[F68D]              	inc	word [STARTEL]	  	; Point to char after /
 28659 000042A6 C606[F88D]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 28660 000042AB C606[F98D]00            	mov	byte [ELPOS],0
 28661                                  notspecial:
 28662 000042B0 E89600                  	call	move_char		; just an alphanum string
 28663                                  anum_test:
 28664 000042B3 AC                      	lodsb
 28665                                  
 28666                                  	; 28/03/2023
 28667                                  	; MSDOS 6.0
 28668                                  	; -----------------------------------
 28669                                  	; Mod to avoid upper-case conversion.
 28670                                  	; -----------------------------------
 28671                                  	; MSDOS 3.3
 28672                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28673                                  	;jnz	short cpcont3		; 3/3/KK
 28674                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28675                                  cpcont3:
 28676                                  	; -----------------------------------
 28677                                  
 28678 000042B4 E837E3                  	call	DELIM
 28679 000042B7 7435                    	jz	short x_done
 28680 000042B9 3C0D                    	cmp	al,0Dh
 28681 000042BB 7431                    	je	short x_done
 28682 000042BD 3A06[C48A]              	cmp	al,[SWITCHAR]
 28683 000042C1 742B                    	je	short x_done
 28684 000042C3 38D8                    	cmp	al,bl
 28685 000042C5 7427                    	je	short x_done
 28686 000042C7 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 28687                                  	; 28/03/2023
 28688                                  	; MSDOS 3.3
 28689                                  	;jnz	short ANUM_CHARJ 
 28690                                  	; MSDOS 6.0
 28691 000042C9 7403                    	je	short FOO15
 28692 000042CB E95FFF                  	jmp	anum_char
 28693                                  
 28694                                  ; Modification made for parseline.
 28695                                  ; Why would it be necessary to change colons to spaces? In this
 28696                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 28697                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 28698                                  
 28699                                  FOO15:
 28700 000042CE 803E[B48C]02            	cmp	byte [cpyflag],2
 28701 000042D3 7505                    	jnz	short cpcont4
 28702 000042D5 E87100                  	call	move_char
 28703 000042D8 EBD9                    	jmp	short anum_test
 28704                                  cpcont4:
 28705 000042DA 46                      	inc	si			; Skip the ':'
 28706 000042DB EB11                    	jmp	short x_done
 28707                                  
 28708                                  	; 28/03/2023
 28709                                  ;ANUM_CHARJ:
 28710                                  	;jmp	anum_char
 28711                                  
 28712                                  BADPERR2:
 28713 000042DD BA[667F]                	mov	dx,BADCPMES_PTR
 28714 000042E0 E977E6                  	jmp	cerror
 28715                                  
 28716                                  BADPERR:
 28717                                  	; 28/03/2023
 28718                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 28719                                  BADCDERR:
 28720                                  	; MSDOS 6.0
 28721 000042E3 BA[9080]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 28722 000042E6 E971E6                  	jmp	cerror			;AC022;  message
 28723                                  	
 28724                                  cperror:
 28725 000042E9 4E                      	dec	si			; adjust the pointer
 28726 000042EA 5F                      	pop	di			; retrive token buffer address
 28727 000042EB 9D                      	popf				; restore flags
 28728 000042EC F9                      	stc				; set the carry bit
 28729 000042ED C3                      	retn
 28730                                  
 28731                                  x_done:
 28732 000042EE 4E                      	dec	si			; adjust for next round
 28733                                  
 28734                                  ; Mod to recognize right and left parens as integral tokens.
 28735                                  ;x_done2:
 28736 000042EF EB51                    	jmp	short out_token
 28737                                  
 28738                                  a_switch:
 28739 000042F1 80CF01                  	or	bh,1			; Indicate switch
 28740                                  	;or	bp,FSWITCH ; 8000h
 28741                                  	; 28/03/2023
 28742 000042F4 81CD0080                	or	bp,8000h
 28743 000042F8 E8EBE2                  	call	scanoff
 28744 000042FB 46                      	inc	si
 28745                                  	; 28/03/2023
 28746                                  	; MSDOS 6.0
 28747 000042FC E8C5E0                  	call	testkanj		;AN057; See if DBCS lead byte
 28748 000042FF 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 28749 00004301 E84500                  	call	move_char		;AN057; DBCS - store first byte
 28750 00004304 AC                      	lodsb				;AN057; get second byte
 28751 00004305 E84100                  	call	move_char		;AN057; store second byte
 28752                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 28753 00004308 81CD0040                	or	bp,4000h
 28754 0000430C EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 28755                                  a_switch_notkanj:			;AN057;
 28756 0000430E 3C0D                    	cmp	al,0Dh
 28757 00004310 7509                    	jne	short Store_swt
 28758 00004312 B000                    	mov	al,0
 28759 00004314 AA                      	stosb
 28760                                  	;or	bp,FBADSWITCH ; 4000h
 28761 00004315 81CD0040                	or	bp,4000h
 28762 00004319 EBCE                    	jmp	short cperror		; Trailing switch character error
 28763                                  					;   BP = fSwitch but no switch
 28764                                  					;   bit is set (unknown switch)
 28765                                  Store_swt:
 28766 0000431B E82B00                  	call	move_char		; store the character
 28767                                  
 28768                                  ; This upconv call must stay. It is used to identify copy-switches
 28769                                  ; on the command line, and won't store anything into the output buffer.
 28770                                  
 28771                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 28772                                  	; 28/03/2023
 28773 0000431E E8CDE0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 28774                                  	
 28775 00004321 06                      	push	es
 28776 00004322 57                      	push	di
 28777 00004323 51                      	push	cx
 28778 00004324 0E                      	push	cs
 28779 00004325 07                      	pop	es
 28780                                  	; 28/03/2023
 28781                                  	; MSDOS 3.3
 28782                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 28783                                  	; MSDOS 6.0
 28784 00004326 BF[8B84]                	mov	di,switch_list ; "?VBAPW"
 28785                                  	; MSDOS 3.3
 28786                                  	;mov	cx,SWCOUNT ; 5
 28787                                  	; MSDOS 6.0
 28788 00004329 B90600                  	mov	cx,6  ; SWCOUNT = 6
 28789                                  	;or	bp,FBADSWITCH  ; 4000h
 28790 0000432C 81CD0040                	or	bp,4000h
 28791 00004330 F2AE                    	repne	scasb
 28792 00004332 750B                    	jnz	short out_tokenp
 28793                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 28794 00004334 81E5FFBF                	and	bp,0BFFFh
 28795 00004338 B80100                  	mov	ax,1
 28796 0000433B D3E0                    	shl	ax,cl
 28797 0000433D 09C5                    	or	bp,ax
 28798                                  out_tokenp:
 28799 0000433F 59                      	pop	cx
 28800 00004340 5F                      	pop	di
 28801 00004341 07                      	pop	es
 28802                                  out_token:
 28803 00004342 B000                    	mov	al,0			; null at the end
 28804 00004344 AA                      	stosb
 28805 00004345 5F                      	pop	di			; restore token buffer pointer	
 28806 00004346 9D                      	popf
 28807 00004347 F8                      	clc				; clear carry flag
 28808 00004348 C3                      	retn
 28809                                  
 28810                                  ; =============== S U B	R O U T	I N E =======================================
 28811                                  
 28812                                  	; 28/03/2023
 28813                                  move_char:
 28814 00004349 AA                      	stosb				; store char in token buffer
 28815 0000434A 41                      	inc	cx			; increment char count
 28816 0000434B FE06[F88D]              	inc	byte [ELCNT]		; increment element count for * substi
 28817 0000434F C3                      	retn
 28818                                  
 28819                                  ;============================================================================
 28820                                  ; PARSE.ASM, MSDOS 6.0, 1991
 28821                                  ;============================================================================
 28822                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28823                                  
 28824                                  ; -----------------------------
 28825                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 28826                                  ; -----------------------------
 28827                                  
 28828                                  ;**** Equation field
 28829                                  ;-------- Character code definition
 28830                                  
 28831                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 28832                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 28833                                  $P_Period	   equ	"."             ;AN020;
 28834                                  $P_Slash	   equ	"/"             ;AN020;
 28835                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 28836                                  $P_Comma	   equ	","             ;AN000;
 28837                                  $P_Switch	   equ	"/"             ;AN000;
 28838                                  $P_Keyword	   equ	"="             ;AN000;
 28839                                  $P_Colon	   equ	":"             ;AN000;
 28840                                  $P_Plus 	   equ	"+"             ;AN000;
 28841                                  $P_Minus	   equ	"-"             ;AN000;
 28842                                  $P_Rparen	   equ	")"             ;AN000;
 28843                                  $P_Lparen	   equ	"("             ;AN000;
 28844                                  ;(deleted ;AN025;) $P_SQuote	      equ  "'"
 28845                                  $P_DQuote	   equ	'"'             ;AN000;
 28846                                  $P_NULL 	   equ	0		;AN000;
 28847                                  $P_TAB		   equ	9		;AN000;
 28848                                  $P_CR		   equ	0Dh		;AN000;
 28849                                  $P_LF		   equ	0Ah		;AN000;
 28850                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 28851                                  
 28852                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 28853                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 28854                                  
 28855                                  $P_error_filespec  equ  1
 28856                                  
 28857                                  ;----------------------------------------------------------------------------
 28858                                  ; PARMS LABEL	BYTE
 28859                                  ;	DW	PARMSX
 28860                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 28861                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28862                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 28863                                  ;				; TYPICAL ARE ";", "="
 28864                                  ;				; "," & WHITESPACE ALWAYS
 28865                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28866                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 28867                                  ;----------------------------------------------------------------------------
 28868                                  
 28869                                  struc $P_PARMS_BLK			;AN000;
 28870 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 28871 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 28872 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 28873                                  endstruc 				;AN000;
 28874                                  
 28875                                  $P_Len_PARMS	   equ	4		;AN000;
 28876                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 28877                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 28878                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 28879                                  
 28880                                  ;----------------------------------------------------------------------------
 28881                                  ; PARMSX LABEL	BYTE
 28882                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 28883                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 28884                                  ;	:				; REPEATS maxp-1 TIMES
 28885                                  ;	DB	maxs			; # OF SWITCHES
 28886                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 28887                                  ;	:				; REPEATS maxs-1 TIMES
 28888                                  ;	DB	maxk			; # OF KEYWORD
 28889                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 28890                                  ;	:				; REPEATS maxk-1 TIMES
 28891                                  ;----------------------------------------------------------------------------
 28892                                  
 28893                                  struc $P_PARMSX_BLK			;AN000;
 28894 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 28895 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 28896 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 28897                                  endstruc				;AN000;
 28898                                  
 28899                                  ; 31/03/2023
 28900                                  ;----------------------------------------------------------------------------
 28901                                  ; << Control field definition >>
 28902                                  ;
 28903                                  ;CONTROL   LABEL   BYTE
 28904                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 28905                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 28906                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 28907                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 28908                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 28909                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 28910                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 28911                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 28912                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 28913                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 28914                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 28915                                  ;				; 0002H=REPEATS ALLOWED
 28916                                  ;				; 0001H=OPTIONAL
 28917                                  ;	   DW FUNCTION_FLAGS
 28918                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 28919                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 28920                                  ;				; 0010H=REMOVE ":" AT END
 28921                                  ; (tm10)			; 0020H=colon is not necessary for switch
 28922                                  ;
 28923                                  ;	   DW RESULT		; RESULT BUFFER
 28924                                  ;	   DW VALUES		; VALUE LISTS
 28925                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 28926                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 28927                                  ;	   :
 28928                                  ;
 28929                                  ;Note:
 28930                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 28931                                  ;      DATE bit simalteniously.
 28932                                  ;
 28933                                  ;      The parser examins each bit along with the following priority.
 28934                                  ;
 28935                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 28936                                  ;      FILE SPEC -> SIMPLE STRING.
 28937                                  ;
 28938                                  ;
 28939                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 28940                                  ;      in the result buffer is capitalized.
 28941                                  ;
 28942                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 28943                                  ;
 28944                                  ;
 28945                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 28946                                  ;      switch, for example, '/A', then STRING points to;
 28947                                  ;
 28948                                  ;		DB    1 	; number of following synonyms
 28949                                  ;		DB   '/A',0
 28950                                  ;
 28951                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 28952                                  ;
 28953                                  ;		DB    1 	; number of following synonyms
 28954                                  ;		DB   'CODEPAGE=',0
 28955                                  ;
 28956                                  ;
 28957                                  ;    - "..." must consist of upper case characters only because the parser
 28958                                  ;      performs pattern matching after converting input to upper case (by
 28959                                  ;      using the current country upper case table)
 28960                                  ;
 28961                                  ;
 28962                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 28963                                  ;      example /A and /B, the format will be;
 28964                                  ;
 28965                                  ;		DB    2 	; number of following synonyms
 28966                                  ;		DB    '/A',0
 28967                                  ;		DB    '/B',0
 28968                                  ;----------------------------------------------------------------------------
 28969                                  
 28970                                  ;**** Match_Flags
 28971                                  
 28972                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 28973                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 28974                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 28975                                  $P_Date_S	   equ	1000h		;AN000; Date string
 28976                                  $P_Time_S	   equ	0800h		;AN000; Time string
 28977                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 28978                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 28979                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 28980                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 28981                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 28982                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 28983                                  $P_Optional	   equ	0001h		;AN000; Optional
 28984                                  
 28985                                  ;**** Function flags
 28986                                  
 28987                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 28988                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 28989                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 28990                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 28991                                  
 28992                                  ;-------------------------------- Control block structure
 28993                                  struc $P_CONTROL_BLK
 28994 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 28995 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 28996 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 28997 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 28998 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 28999 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29000                                  endstruc
 29001                                  
 29002                                  ; 31/03/2023
 29003                                  ;----------------------------------------------------------------------------
 29004                                  ;
 29005                                  ;VALUES LABEL	BYTE
 29006                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29007                                  ;	+-
 29008                                  ;	| DB	nrng		; NUMBER OF RANGES
 29009                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29010                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29011                                  ;	|	:
 29012                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29013                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29014                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29015                                  ;	|	:
 29016                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29017                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29018                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29019                                  ;	+-	:
 29020                                  ;
 29021                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29022                                  ;
 29023                                  ;Note:
 29024                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29025                                  ;      when no choice lists are provided.
 29026                                  ;
 29027                                  ;    - STRING must consist of upper case characters only because the parser
 29028                                  ;      performs pattern matching after converting input to upper case (by
 29029                                  ;      using the current country upper case table)
 29030                                  ;----------------------------------------------------------------------------
 29031                                  
 29032                                  $P_nval_None	equ 0		;AN000; no value list ID
 29033                                  $P_nval_Range	equ 1		;AN000; range list ID
 29034                                  $P_nval_Value	equ 2		;AN000; value list ID
 29035                                  $P_nval_String	equ 3		;AN000; string list ID
 29036                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29037                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29038                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29039                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29040                                  
 29041                                  struc $P_VAL_LIST
 29042 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29043 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29044 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29045 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29046 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29047                                  endstruc
 29048                                  
 29049                                  ; 31/03/2023
 29050                                  ;----------------------------------------------------------------------------
 29051                                  ;
 29052                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29053                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29054                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29055                                  ;					;	3=STRING, 4=COMPLEX,
 29056                                  ;					;	5=FILESPEC, 6=DRIVE
 29057                                  ;					;	7=DATE, 8=TIME
 29058                                  ;					;	9=QUOTED STRING
 29059                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29060                                  ;
 29061                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29062                                  ;
 29063                                  ;       +-
 29064                                  ;       | DD	n			; VALUE IF NUMBER
 29065                                  ;       | or
 29066                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29067                                  ;       |				; (ES presents Segment address)
 29068                                  ;       | or
 29069                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29070                                  ;       | or
 29071                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29072                                  ;       | or
 29073                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29074                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29075                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29076                                  ;       | or
 29077                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29078                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29079                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29080                                  ;       |	DB HUNDREDTHS ;(0-99)
 29081                                  ;       +-
 29082                                  ;
 29083                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29084                                  ;      list.
 29085                                  ;
 29086                                  ;      YEAR: If the input value for the year is less than 100, parser
 29087                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 29088                                  ;	     the year value, he returns 1987.
 29089                                  ;----------------------------------------------------------------------------
 29090                                  
 29091                                  ;-------------------------------- Result block structure
 29092                                  struc $P_RESULT_BLK;
 29093 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 29094 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 29095 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 29096 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 29097                                  endstruc
 29098                                  
 29099                                  ;**** values for the type field in the result block
 29100                                  
 29101                                  $P_EOL		 equ 0		;AN000; End of line
 29102                                  $P_Number	 equ 1		;AN000; Number
 29103                                  $P_List_Idx	 equ 2		;AN000; List Index
 29104                                  $P_String	 equ 3		;AN000; String
 29105                                  $P_Complex	 equ 4		;AN000; Complex
 29106                                  $P_File_Spec	 equ 5		;AN000; File Spec
 29107                                  $P_Drive	 equ 6		;AN000; Drive
 29108                                  $P_Date_F	 equ 7		;AN000; Date
 29109                                  $P_Time_F	 equ 8		;AN000; Time
 29110                                  $P_Quoted_String equ 9		;AN000; Quoted String
 29111                                  
 29112                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 29113                                  
 29114                                  ;**** Return code
 29115                                  ;
 29116                                  ; following return code will be returned in the AX register.
 29117                                  
 29118                                  $P_No_Error	 equ 0		;AN000; No error
 29119                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 29120                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 29121                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 29122                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 29123                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29124                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29125                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29126                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29127                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29128                                  
 29129                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29130                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29131                                  $P_Neg		 equ 02h	;AN000; Negative value
 29132                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29133                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29134                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29135                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29136                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29137                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29138                                  
 29139                                  ;-------- Masks
 29140                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29141                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29142                                  
 29143                                  ;-------------
 29144                                  
 29145                                  struc $P_DOS_TBL
 29146 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29147 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29148 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29149                                  endstruc
 29150                                  
 29151                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29152                                  				;AN000; following parameters are set
 29153                                  				;AN000; to get casemap table.
 29154                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29155                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29156                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29157                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29158                                  				; By this call following information
 29159                                  				; is returned.
 29160                                  
 29161                                  ; 03/04/2023
 29162                                  ;-------------------------------- country dependent information
 29163                                  
 29164                                  $P_DOS_Get_CDI	equ 3800h
 29165                                  
 29166                                  struc $P_CDI
 29167 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29168 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29169 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29170 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29171 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29172 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29173 0000000E ??                      		resb 1		;AN000;
 29174 0000000F ??                      		resb 1		;AN000;
 29175 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29176 00000011 ????????                		resw 2		;AN000;
 29177 00000015 ????                    		resb 2		;AN000;
 29178 00000017 <res Ah>                		resw 5		;AN000;
 29179                                  endstruc
 29180                                  
 29181                                  $P_Date_MDY	equ 0		;AN000;
 29182                                  $P_Date_DMY	equ 1		;AN000;
 29183                                  $P_Date_YMD	equ 2		;AN000;
 29184                                  
 29185                                  ; ----------------------------
 29186                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29187                                  ; ----------------------------
 29188                                  
 29189                                  ;***********************************************************************
 29190                                  ; SysParse;
 29191                                  ;
 29192                                  ;  Function : Parser Entry
 29193                                  ;
 29194                                  ;  Input: DS:SI -> command line
 29195                                  ;	  ES:DI -> parameter block
 29196                                  ;	  psdata_seg -> psdata.inc
 29197                                  ;	  CX = operand ordinal
 29198                                  ;
 29199                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29200                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29201                                  ;		 is in DS.
 29202                                  ;
 29203                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29204                                  ;		    invalid value list. But this parser does NOT implement
 29205                                  ;		    this feature. Therefore CY always zero.
 29206                                  ;
 29207                                  ;	   CY = 0   AX = return code
 29208                                  ;		    BL = terminated delimiter code
 29209                                  ;		    CX = new operand ordinal
 29210                                  ;		    SI = set past scaned operand
 29211                                  ;		    DX = selected result buffer
 29212                                  ;
 29213                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29214                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29215                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29216                                  ;
 29217                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29218                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29219                                  ;
 29220                                  ;-------- Modification History -----------------------------------------
 29221                                  ;
 29222                                  ;  4/04/87 : Created by K. K,
 29223                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29224                                  ;	   : JMP SHORT assemble error (tm02)
 29225                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29226                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29227                                  ;	     DateSW equ 1)	      (tm04)
 29228                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29229                                  ;				      (tm05) in PSDATA.INC
 29230                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29231                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29232                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29233                                  ;	     value-list block	      (tm07)
 29234                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29235                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29236                                  ;	     (tm08)
 29237                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29238                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29239                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29240                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29241                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29242                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29243                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29244                                  ;					  (tm12)
 29245                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29246                                  ;					  (tm13)
 29247                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29248                                  ;					  (tm14)
 29249                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29250                                  ;					  (tm15)
 29251                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29252                                  ;
 29253                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29254                                  ;
 29255                                  ;  7/28/87 : Kerry S (;AN018;)
 29256                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29257                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29258                                  ;	     affected: $P_Chk_SW_Control.
 29259                                  ;
 29260                                  ;  7/29/87 : Kerry S (;AN019;)
 29261                                  ;	     Now allow the optional bit in match flags for switches.  This
 29262                                  ;	     allows the switch to be encountered with a value or without a
 29263                                  ;	     value and no error is returned.
 29264                                  ;
 29265                                  ;
 29266                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29267                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29268                                  ;	     within a date response, instead of checking just for the one
 29269                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29270                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29271                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29272                                  ;
 29273                                  ;  9/1/87  : Kerry S (;AN021)
 29274                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29275                                  ;	     the command line with the string in the control block the
 29276                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29277                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29278                                  ;	     string on the command line than in the synonym list in the control
 29279                                  ;	     block.  I put in a test for a null in the control block so the
 29280                                  ;	     string in the control block must be the same length as the string
 29281                                  ;	     preceeding the colon or equal on the command line.
 29282                                  ;
 29283                                  ;  8/28/87 : Kerry S (;AN022;)
 29284                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29285                                  ;	     problems for people who included it themselves in a segment other
 29286                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29287                                  ;	     segment.
 29288                                  ;
 29289                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29290                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29291                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29292                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29293                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29294                                  ;	     BL be used if TIME is being parsed.
 29295                                  ;
 29296                                  ;  9/24/87 : Ed K
 29297                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29298                                  ;	     invocations with their normally expanded code; made comments
 29299                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29300                                  ;
 29301                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29302                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29303                                  ;	     pointed to by non-existant CONTROL.
 29304                                  ;
 29305                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29306                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29307                                  ;	     support to frame quoted text string with single quote.
 29308                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29309                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29310                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29311                                  ;
 29312                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29313                                  ;	     quote chars within a quoted string is supposed to be reported as
 29314                                  ;	     one quote character, but is reported as two quotes.  This changed
 29315                                  ;	     two instructions in PROC $P_Quoted_Str.
 29316                                  ;
 29317                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29318                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29319                                  ;
 29320                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29321                                  ;
 29322                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29323                                  ;	     psdata buffer should have psdata_seg.
 29324                                  ;
 29325                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29326                                  ;	     positional missing.
 29327                                  ;
 29328                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29329                                  ;	     as a line delimiter, should use carriage return.
 29330                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29331                                  ;
 29332                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29333                                  ;
 29334                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29335                                  ;	     endless loop since SI is returned still pointing to start
 29336                                  ;	     of that parm.
 29337                                  ;
 29338                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29339                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29340                                  ;	     when tried to fix it on previous version, changed similar
 29341                                  ;	     but wrong place.
 29342                                  ;
 29343                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29344                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29345                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29346                                  ;
 29347                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29348                                  ;	     in a filespec, then flag an error.
 29349                                  ;
 29350                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29351                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29352                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29353                                  ;  -->	     local parser data. Why were some references to local data changed
 29354                                  ;	     to do this before, but not all ?????
 29355                                  ;
 29356                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29357                                  ;
 29358                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29359                                  ;
 29360                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29361                                  ;
 29362                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29363                                  ;
 29364                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29365                                  ;	     separator in TIME before hundredths field.
 29366                                  ;
 29367                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29368                                  ;			strings as keywords.
 29369                                  ;
 29370                                  ;***********************************************************************
 29371                                  
 29372                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29373                                  cmd_parse:
 29374                                  	;call	sysparse
 29375                                  	;retn
 29376                                  
 29377                                  ; -----------------------------------
 29378                                  
 29379                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29380                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29381                                  
 29382                                  sysparse:
 29383 00004350 2EC706[1886]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29384 00004357 2E890E[A286]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29385 0000435C 2E8926[A486]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29386 00004361 2E8936[A686]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29387                                  $P_Redo_Time:				;AN039; try to parse time again
 29388 00004366 FC                      	cld				;AN000; confirm forward direction
 29389 00004367 2E890E[0B86]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29390                                  	;mov	word [cs:$P_RC],$P_No_Error
 29391 0000436C 2EC706[0D86]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29392 00004373 2EC706[2086]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29393                                  					;AC034; initalize synonym pointer
 29394 0000437A 2EC706[1186]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29395                                  
 29396                                  ;M029 -- Begin changes
 29397                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29398                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29399                                  ;corrupts this table but does not corrupt the checksum region will leave
 29400                                  ;command.com parsing in an inconsistent state.
 29401                                  ; NB: The special characters string has been hardcoded here. If any change
 29402                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29403                                  
 29404 00004381 2EC706[DD86]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29405 00004388 2EC706[DF86]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29406 0000438F 2EC706[E186]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29407 00004396 2EC706[E386]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29408                                  
 29409                                  ;M029 -- End of changes
 29410                                  
 29411 0000439D E83809                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29412 000043A0 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29413                                  
 29414                                  ;--------------------------- End of Line
 29415                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29416 000043A2 B8FFFF                  	mov	ax,0FFFFh
 29417 000043A5 53                      	push	bx			;AN000;
 29418                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29419 000043A6 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29420                                  	
 29421                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29422 000043A9 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29423 000043AC 7304                    	jae	short $P_Fin		;AN000; positional found.
 29424                                  
 29425                                  	;mov	ax,2
 29426 000043AE B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29427                                  	; 27/04/2023
 29428 000043B1 F8                      	clc
 29429                                  $P_Fin: 				;AN000;
 29430 000043B2 5B                      	pop	bx			;AN000;
 29431                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29432                                  	; 27/04/2023
 29433                                  	; cf = 0
 29434                                  	;clc
 29435 000043B3 C3                      	retn
 29436                                  
 29437                                  ;---------------------------
 29438                                  $P_Start:				;AN000;
 29439 000043B4 2E8936[1A86]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 29440 000043B9 53                      	push	bx			;AN000; quoted string or file spec.
 29441 000043BA 57                      	push	di			;AN000;
 29442 000043BB 55                      	push	bp			;AN000;
 29443 000043BC 8D1E[2286]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29444 000043C0 2EF606[1986]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29445                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29446 000043C6 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29447                                  $P_Pack_Loop:				;AN000;
 29448 000043C8 AC                      	lodsb				;AN000; Pick a operand from buffer
 29449 000043C9 E8C109                  	call	$P_Chk_Switch		;AN000; Check switch character
 29450 000043CC 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29451                                  
 29452 000043CE E82909                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29453 000043D1 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29454                                  
 29455 000043D3 E85609                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29456 000043D6 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29457                                  
 29458 000043D8 2EF606[1986]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29459                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29460 000043DE 7505                    	jnz	short $P_Pack_End_backup_si
 29461                                  					;AN000; (tm08)
 29462 000043E0 E8F508                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29463 000043E3 EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29464                                  
 29465                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29466 000043E5 2EF606[1986]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29467                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29468 000043EB 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29469                                  
 29470 000043ED 4E                      	dec	si			;AN000; (tm08)
 29471 000043EE EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29472                                  $P_PL01:				;AN000;
 29473 000043F0 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29474                                  	;cmp	al,'='
 29475 000043F3 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29476 000043F5 7506                    	jne	short $P_PL00 		;AN000; then
 29477                                  
 29478 000043F7 2E800E[1986]01          	or	byte [cs:$P_Flags2],$P_equ
 29479                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29480                                  $P_PL00:				;AN000;
 29481 000043FD 43                      	inc	bx			;AN000; ready to see next byte
 29482 000043FE E8B709                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29483 00004401 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29484                                  
 29485 00004403 AC                      	lodsb				;AN000; if yes, store
 29486 00004404 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29487 00004407 43                      	inc	bx			;AN000; update pointer
 29488 00004408 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29489                                  
 29490                                  $P_Pack_End_BY_EOL:			;AN000;
 29491 0000440A 4E                      	dec	si			;AN000; backup si pointer
 29492                                  $P_Pack_End:				;AN000;
 29493 0000440B 2E8936[0F86]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29494                                  	;mov	byte [cs:bx],0
 29495 00004410 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29496 00004414 2E891E[1E86]            	mov	[cs:$P_Save_EOB],bx
 29497                                  					;AC034; 3/17/87 keep the address for later use of complex
 29498                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29499 00004419 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29500 0000441C 8D36[2286]              	lea	si,$P_STRING_BUF	;AC034;
 29501                                  	;cmp	byte [cs:si],'/'
 29502 00004420 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29503 00004424 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29504                                  
 29505 00004426 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29506 0000442A 7408                    	je	short $P_Positional_Manager
 29507                                  					;M005;if so, process as one!
 29508 0000442C 2EF606[1986]01          	test	byte [cs:$P_Flags2],$P_equ
 29509                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29510 00004432 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29511                                  
 29512                                  $P_Positional_Manager:			;AN000; else process as positional
 29513                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29514 00004434 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29515 00004438 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29516 0000443A 2E3906[0B86]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29517 0000443F 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29518                                  
 29519 00004441 2EA1[0B86]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29520 00004445 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29521 00004447 43                      	inc	bx			;AC035; add '2' to
 29522 00004448 43                      	inc	bx			;AC035;  BX reg
 29523                                  					;AN000; now bx points to 1st CONTROL
 29524 00004449 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29525 0000444B 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29526 0000444E E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29527 00004451 EB69                    	jmp	short $P_Return_to_Caller
 29528                                  					;AN000; and return to the caller
 29529                                  $P_Too_Many_Error:			;AN000;
 29530                                  	;mov	word [cs:$P_RC],1
 29531 00004453 2EC706[0D86]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29532                                  					;AC034; set exit code
 29533 0000445A EB60                    	jmp	short $P_Return_to_Caller
 29534                                  					;AN000; and return to the caller
 29535                                  $P_SW_Manager:				;AN000;
 29536                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29537 0000445C 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29538 00004460 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29539 00004462 40                      	inc	ax			;AN000;
 29540 00004463 D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29541 00004465 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29542 00004467 268A0F                  	mov	cl,[es:bx]		;AN000;
 29543 0000446A 30ED                    	xor	ch,ch			;AN000; cx = maxs
 29544 0000446C 09C9                    	or	cx,cx			;AN000; at least one switch ?
 29545 0000446E 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 29546 00004470 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 29547                                  $P_SW_Mgr_Loop: 			;AN000;
 29548 00004471 53                      	push	bx			;AN000;
 29549 00004472 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29550 00004475 E8C300                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29551 00004478 5B                      	pop	bx			;AN000;
 29552 00004479 7341                    	jnc	short $P_Return_to_Caller
 29553                                  					;AN000; if the CONTROL is for the switch, exit
 29554 0000447B 43                      	inc	bx			;AC035; add '2' to
 29555 0000447C 43                      	inc	bx			;AC035;  BX reg
 29556                                  					;AN000; else bx points to the next CONTROL
 29557 0000447D E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29558                                  $P_SW_Not_Found:			;AN000;
 29559                                  	;mov	word [cs:$P_RC],3
 29560 0000447F 2EC706[0D86]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29561                                  					;AC034; here no CONTROL for the switch has
 29562 00004486 EB34                    	jmp	short $P_Return_to_Caller0
 29563                                  					;AN000; not been found, means error.
 29564                                  $P_Key_Manager: 			;AN000;
 29565                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29566 00004488 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29567 0000448C 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29568 0000448E 40                      	inc	ax			;AN000;
 29569 0000448F D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29570 00004491 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29571 00004493 268A07                  	mov	al,[es:bx]		;AN000;
 29572 00004496 30E4                    	xor	ah,ah			;AN000; ax = maxs
 29573 00004498 D1E0                    	shl	ax,1			;AN000;
 29574 0000449A 40                      	inc	ax			;AN000; ax = ax*2+1
 29575 0000449B 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 29576 0000449D 268A0F                  	mov	cl,[es:bx]		;AN000;
 29577 000044A0 30ED                    	xor	ch,ch			;AN000; cx = maxk
 29578 000044A2 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 29579 000044A4 740F                    	jz	short $P_Key_Not_Found	;AN000;
 29580 000044A6 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 29581                                  $P_Key_Mgr_Loop:			;AN000;
 29582 000044A7 53                      	push	bx			;AN000;
 29583 000044A8 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29584 000044AB E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29585 000044AE 5B                      	pop	bx			;AN000;
 29586 000044AF 730B                    	jnc	short $P_Return_to_Caller
 29587                                  					;AN000; if the CONTROL is for the keyword, exit
 29588 000044B1 43                      	inc	bx			;AC035; add '2' to
 29589 000044B2 43                      	inc	bx			;AC035;  BX reg
 29590                                  					;AN000; else bx points to the next CONTROL
 29591 000044B3 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29592                                  $P_Key_Not_Found:			;AN000;
 29593                                  	;mov	word [cs:$P_RC],4
 29594 000044B5 2EC706[0D86]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29595                                  					;AC034; here no CONTROL for the keyword has
 29596                                  $P_Return_to_Caller0:
 29597                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29598 000044BC 5D                      	pop	bp			;AN000;
 29599 000044BD 5F                      	pop	di			;AN000;
 29600 000044BE 5B                      	pop	bx			;AN000;
 29601 000044BF 2E8B0E[0B86]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29602 000044C4 2EA1[0D86]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29603 000044C8 2E8B36[0F86]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29604 000044CD 2E8B16[1186]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29605 000044D2 2E8A1E[1386]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29606                                  $P_Single_Exit: 			;AN000;
 29607 000044D7 F8                      	clc				;AN000;
 29608 000044D8 C3                      	retn				;AN000;
 29609                                  
 29610                                  ;***********************************************************************
 29611                                  ; $P_Chk_Pos_Control
 29612                                  ;
 29613                                  ; Function: Parse CONTROL block for a positional
 29614                                  ;
 29615                                  ; Input:     ES:BX -> CONTROL block
 29616                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29617                                  ;
 29618                                  ; Output:    None
 29619                                  ;
 29620                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 29621                                  ;
 29622                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 29623                                  ;***********************************************************************
 29624                                  
 29625                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29626                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 29627                                  
 29628                                  $P_Chk_Pos_Control:
 29629 000044D9 50                      	push	ax			;AN000;
 29630                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29631 000044DA 268B07                  	mov	ax,[es:bx]		;AN000;
 29632                                  	;test	ax,2
 29633 000044DD A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 29634 000044E0 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 29635                                  
 29636 000044E2 2EFF06[0B86]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 29637                                  $P_CPC00:				;AN000;
 29638                                  	;cmp	byte [cs:si],0
 29639 000044E7 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 29640 000044EB 7516                    	jne	short $P_CPC01		;AN000;
 29641                                  
 29642                                  	;test	ax,1
 29643 000044ED A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 29644 000044F0 7509                    	jnz	short $P_CPC02		;AN000;
 29645                                  
 29646 000044F2 2EC706[0D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29647                                  					;AC034; no, then error	 3/17/87
 29648 000044F9 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 29649                                  $P_CPC02:				;AN000;
 29650                                  	; 27/04/2023
 29651                                  	;push	ax ; *			;AN000;
 29652                                  	;
 29653                                  	;;mov	al,3
 29654                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 29655                                  	;;mov	ah,0FFh
 29656                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 29657                                  	;31/03/2023
 29658 000044FB B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29659 000044FE E89700                  	call	$P_Fill_Result		;AN000;
 29660                                  	; 27/04/2023
 29661                                  	;pop	ax ; *			;AN000;
 29662 00004501 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 29663                                  $P_CPC01:				;AN000;
 29664 00004503 E81301                  	call	$P_Check_Match_Flags	;AN000;
 29665                                  $P_CPC_Exit:				;AN000;
 29666 00004506 58                      	pop	ax			;AN000;
 29667 00004507 C3                      	retn				;AN000;
 29668                                  
 29669                                  ;***********************************************************************
 29670                                  ; $P_Chk_Key_Control
 29671                                  ;
 29672                                  ; Function: Parse CONTROL block for a keyword
 29673                                  ;
 29674                                  ; Input:     ES:BX -> CONTROL block
 29675                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29676                                  ;
 29677                                  ; Output:    CY = 1 : not match
 29678                                  ;
 29679                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29680                                  ;
 29681                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29682                                  ;***********************************************************************
 29683                                  
 29684                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29685                                  $P_Chk_Key_Control:			;AN000;
 29686 00004508 F9                      	stc				;AN000;this logic works when the KeySW
 29687 00004509 C3                      	retn				;AN000;is reset.
 29688                                  
 29689                                  ;***********************************************************************
 29690                                  ; $P_Search_KEYorSW:
 29691                                  ;
 29692                                  ; Function: Seach specified keyword or switch from CONTROL
 29693                                  ;
 29694                                  ; Input:     ES:BX -> CONTROL block
 29695                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29696                                  ;
 29697                                  ; Output:    CY = 1 : not match
 29698                                  ;
 29699                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 29700                                  ;***********************************************************************
 29701                                  
 29702                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29703                                  
 29704                                  $P_Search_KEYorSW:
 29705 0000450A 55                      	push	bp			;AN000;
 29706 0000450B 51                      	push	cx			;AN000;
 29707 0000450C 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 29708                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 29709 00004510 30ED                    	xor	ch,ch			;AN000; and set it to cx
 29710 00004512 09C9                    	or	cx,cx			;AN000; No synonyms specified ?
 29711 00004514 740E                    	jz	short $P_KEYorSW_Not_Found
 29712                                  					;AN000; then indicate not found by CY
 29713 00004516 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 29714                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 29715                                  $P_KEYorSW_Loop:			;AN000;
 29716 0000451A E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 29717 0000451D 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 29718 0000451F E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 29719 00004522 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 29720                                  $P_KEYorSW_Not_Found:			;AN000;
 29721 00004524 F9                      	stc				;AN000; indicate not found in synonym list
 29722 00004525 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 29723                                  $P_KEYorSW_Found:			;AN000;
 29724 00004527 2E892E[2086]            	mov	[cs:$P_Found_SYNONYM],bp
 29725                                  					;AC034; set synonym pointer
 29726                                  	; 27/04/2023
 29727                                  	; cf = 0
 29728                                  	;clc				;AN000; indicate found
 29729                                  $P_KEYorSW_Exit:			;AN000;
 29730 0000452C 59                      	pop	cx			;AN000;
 29731 0000452D 5D                      	pop	bp			;AN000;
 29732 0000452E C3                      	retn				;AN000;
 29733                                  
 29734                                  ;***********************************************************************
 29735                                  ; $P_MoveBP_NUL
 29736                                  ;***********************************************************************
 29737                                  
 29738                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29739                                  
 29740                                  $P_MoveBP_NUL:
 29741                                  $P_MBP_Loop:				;AN000;
 29742                                  	;cmp	byte [es:bp+0],0
 29743 0000452F 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 29744 00004534 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 29745 00004536 45                      	inc	bp			;AN000; until
 29746 00004537 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 29747                                  $P_MBP_Exit:				;AN000;
 29748 00004539 45                      	inc	bp			;AN000; bp points to next to NULL
 29749 0000453A C3                      	retn				;AN000;
 29750                                  
 29751                                  ;***********************************************************************
 29752                                  ; $P_Chk_SW_Control
 29753                                  ;
 29754                                  ; Function: Parse CONTROL block for a switch
 29755                                  ;
 29756                                  ; Input:     ES:BX -> CONTROL block
 29757                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29758                                  ;
 29759                                  ; Output:    CY = 1 : not match
 29760                                  ;
 29761                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29762                                  ;
 29763                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29764                                  ;***********************************************************************
 29765                                  
 29766                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29767                                  
 29768                                  $P_Chk_SW_Control:
 29769 0000453B 2E800E[1986]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 29770                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 29771 00004541 E8C6FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 29772 00004544 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 29773                                  
 29774 00004546 2E8026[1986]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 29775                                  	;and	byte [cs:$P_Flags2],0EFh
 29776                                  					;AC034; reset the indicator previously set
 29777 0000454C 50                      	push	ax			;AN000;       /switch:
 29778 0000454D 2EA1[1C86]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 29779 00004551 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 29780 00004553 2E0106[1A86]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 29781 00004558 58                      	pop	ax			;AN000;
 29782                                  
 29783 00004559 2E8B36[1C86]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 29784                                  	;cmp	byte [cs:si],0
 29785 0000455E 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 29786 00004562 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 29787                                  
 29788                                  	;cmp	byte [cs:si],':'
 29789 00004564 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 29790                                  					;AN000; if no, the switch terminated by colon ?
 29791 00004569 7509                    	jne	short $P_Chk_if_data_required
 29792                                  					;AN000; if yes,
 29793                                  
 29794 0000456B 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 29795                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 29796 00004572 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 29797                                  
 29798                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 29799                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 29800                                  	; 27/04/2023
 29801 00004574 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 29802 00004578 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 29803                                  
 29804                                  	;;test	word [es:bx],1 ; $P_Optional
 29805                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 29806 0000457A 26F60701                	test	byte [es:bx],$P_Optional
 29807                                  					;AN019; see if no value is valid
 29808 0000457E 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 29809                                  
 29810 00004580 2EC706[0D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29811                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 29812 00004587 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 29813                                  
 29814                                  $P_CSW00:				;AN000;
 29815 00004589 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 29816 0000458C F8                      	clc				;AN000; indicate match
 29817                                  	;jmp	short $P_Chk_SW_Single_Exit
 29818 0000458D C3                      	retn	; 31/03/2023		;AN000;
 29819                                  	; 31/03/2023
 29820                                  ;$P_Chk_SW_Err0: 			;AN000;
 29821                                  ;	stc				;AN000; not found in switch synonym list
 29822                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 29823                                  ;	retn	; 31/03/2023		;AN000;
 29824                                  	
 29825                                  $P_Chk_SW_Exit: 			;AN000;
 29826 0000458E 50                      	push	ax			;AN000;
 29827                                  	; 31/03/2023
 29828 0000458F B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29829                                  	;;mov	al,3
 29830                                  	;;mov	ah,0FFh
 29831                                  	;mov	al,$P_String		;AN000; set
 29832                                  	;mov	ah,$P_No_Tag		;AN000;    result
 29833 00004592 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 29834 00004595 58                      	pop	ax			;AN000;
 29835 00004596 F8                      	clc				;AN000;
 29836                                  	; 31/03/2023
 29837                                  $P_Chk_SW_Err0:
 29838                                  $P_Chk_SW_Single_Exit:			;AN000;
 29839 00004597 C3                      	retn				;AN000;
 29840                                  
 29841                                  ;***********************************************************************
 29842                                  ; $P_Fill_Result
 29843                                  ;
 29844                                  ; Function: Fill the result buffer
 29845                                  ;
 29846                                  ; Input:    AH = Item tag
 29847                                  ;	    AL = type
 29848                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 29849                                  ;		  AL = 2: DX has index(offset) into value list
 29850                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 29851                                  ;		  AL = 7: DX has year, CL has month and CH has date
 29852                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 29853                                  ;			  amd CH has hundredths
 29854                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 29855                                  ;	    ES:BX -> CONTROL block
 29856                                  ;
 29857                                  ; Output:   None
 29858                                  ;
 29859                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 29860                                  ;
 29861                                  ; Vars: $P_DX(W)
 29862                                  ;***********************************************************************
 29863                                  
 29864                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29865                                  
 29866                                  $P_Fill_Result:
 29867 00004598 57                      	push	di			;AN000;
 29868 00004599 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 29869                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 29870 0000459D 2E893E[1186]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 29871                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 29872                                  	;;mov	[es:di],al		;AN000; store type
 29873                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 29874                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 29875                                  	; 31/03/2023
 29876 000045A2 268905                  	mov	[es:di],ax
 29877 000045A5 50                      	push	ax			;AN000;
 29878 000045A6 2EA1[2086]              	mov	ax,[cs:$P_Found_SYNONYM]
 29879                                  					;AC034; if yes,
 29880 000045AA 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 29881                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 29882 000045AE 58                      	pop	ax			;AN000;
 29883                                  $P_RLT04:				;AN000;
 29884                                  	;cmp	al,1
 29885 000045AF 3C01                    	cmp	al,$P_Number		;AN000; if number
 29886 000045B1 750A                    	jne	short $P_RLT00		;AN000;
 29887                                  $P_RLT02:				;AN000;
 29888 000045B3 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29889                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 29890 000045B7 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 29891                                  	;mov	[es:di+6],cx		;AN000;	number
 29892 000045BB EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 29893                                  $P_RLT00:				;AN000;
 29894                                  	;cmp	al,2
 29895 000045BD 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 29896 000045BF 7506                    	jne	short $P_RLT01		;AN000;
 29897 000045C1 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29898                                  	;mov	[es:di+4],dx		;AN000; then store list index
 29899 000045C5 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 29900                                  $P_RLT01:				;AN000;
 29901                                  	;cmp	al,7
 29902 000045C7 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 29903 000045C9 74E8                    	je	short $P_RLT02		;AN000;
 29904                                  	;cmp	al,8
 29905 000045CB 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 29906 000045CD 74E4                    	je	short $P_RLT02		;AN000;
 29907                                  	;cmp	al,6
 29908 000045CF 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 29909 000045D1 7506                    	jne	short $P_RLT03		;AN000;
 29910                                  
 29911 000045D3 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 29912                                  	;mov	[es:di+4],dl		;AN000; store drive number
 29913 000045D7 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 29914                                  
 29915                                  $P_RLT03:				;AN000;
 29916                                  	;cmp	al,4
 29917 000045D9 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 29918 000045DB 750F                    	jne	short $P_RLT05		;AN000;
 29919                                  
 29920 000045DD 2EA1[1A86]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 29921 000045E1 40                      	inc	ax			;AN000; skip left Parentheses
 29922 000045E2 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 29923                                  	;mov	[es:di+4],ax		;AN000; store offset
 29924 000045E6 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 29925                                  	;mov	[es:di+6],ds		;AN000; store segment
 29926 000045EA EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 29927                                  
 29928                                  $P_RLT05:				;AN000;
 29929                                  ;------------------------  AL = 3, 5, or 9
 29930 000045EC 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 29931                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 29932 000045F0 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 29933                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 29934                                  
 29935 000045F4 50                      	push	ax			;AN000;
 29936 000045F5 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 29937                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 29938 000045FA 7404                    	jz	short $P_RLT_CAP00	;AN000;
 29939                                  
 29940                                  	;mov	al,4
 29941 000045FC B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 29942 000045FE EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 29943                                  
 29944                                  $P_RLT_CAP00:				;AN000;
 29945 00004600 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 29946                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 29947 00004605 7405                    	jz	short $P_RLT_CAP01	;AN000;
 29948                                  
 29949                                  	;mov	al,2
 29950 00004607 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 29951                                  $P_RLT_CAP02:				;AN000;
 29952 00004609 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 29953                                  $P_RLT_CAP01:				;AN000;
 29954 0000460C 58                      	pop	ax			;AN000;
 29955 0000460D 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 29956                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 29957 00004612 7403                    	jz	short $P_RLT_Exit	;AN000;
 29958                                  
 29959 00004614 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 29960                                  $P_RLT_Exit:				;AN000;
 29961 00004617 5F                      	pop	di			;AN000;
 29962 00004618 C3                      	retn				;AN000;
 29963                                  
 29964                                  ;***********************************************************************
 29965                                  ; $P_Check_Match_Flags
 29966                                  ;
 29967                                  ; Function:  Check the mutch_flags and make the exit code and set the
 29968                                  ;	     result buffer
 29969                                  ;
 29970                                  ;	    Check for types in this order:
 29971                                  ;		Complex
 29972                                  ;		Date
 29973                                  ;		Time
 29974                                  ;		Drive
 29975                                  ;		Filespec
 29976                                  ;		Quoted String
 29977                                  ;		Simple String
 29978                                  ;
 29979                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 29980                                  ;	     ES:BX -> CONTROL block
 29981                                  ;
 29982                                  ; Output:    None
 29983                                  ;
 29984                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 29985                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 29986                                  ;	     $P_Drive_Format
 29987                                  ;***********************************************************************
 29988                                  
 29989                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29990                                  
 29991                                  $P_Check_Match_Flags:
 29992 00004619 2EC606[E686]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 29993                                  					;AN033;AC034;; clear filespec error flag.
 29994 0000461F 50                      	push	ax			;AN000;
 29995                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29996 00004620 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 29997 00004623 09C0                    	or	ax,ax			;AC035; test ax for zero
 29998 00004625 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 29999 00004627 50                      	push	ax			;AN000; (tm12)
 30000 00004628 53                      	push	bx			;AN000; (tm12)
 30001 00004629 52                      	push	dx			;AN000; (tm12)
 30002 0000462A 57                      	push	di			;AN000; (tm12)
 30003 0000462B 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 30004                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30005                                  	; 31/03/2023
 30006 00004632 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30007                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30008                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30009 00004635 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30010 00004638 5F                      	pop	di			;AN000; (tm12)
 30011 00004639 5A                      	pop	dx			;AN000; (tm12)
 30012 0000463A 5B                      	pop	bx			;AN000; (tm12)
 30013 0000463B 58                      	pop	ax			;AN000; (tm12)
 30014                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30015                                  	; 31/03/2023
 30016                                  $P_Bridge:	; 18/04/2023		;AN000;
 30017 0000463C E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30018                                  $P_Mat: 				;AN000; (tm12)
 30019                                  $P_Match01:				;AN000;
 30020                                  	;test	ax,1000h
 30021 0000463F A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30022 00004642 7412                    	jz	short $P_Match02	;AN000;
 30023 00004644 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30024                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30025 0000464B E86503                  	call	$P_Date_Format		;AN000; do process
 30026 0000464E 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30027                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30028                                  	; 18/04/2023
 30029 00004654 75E6                    	jne	short $P_Bridge		;AN000;
 30030                                  $P_Match02:				;AN000;
 30031                                  	;test	ax,800h
 30032 00004656 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30033 00004659 7412                    	jz	short $P_Match03	;AN000;
 30034 0000465B 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30035                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30036 00004662 E86004                  	call	$P_Time_Format		;AN000; do process
 30037 00004665 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30038                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30039                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30040                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30041                                  	; 31/03/2023
 30042 0000466B 756E                    	jne	short $P_Match_Exit
 30043                                  ;$P_Bridge:				;AN000;
 30044                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30045                                  $P_Match03:				;AN000;
 30046                                  	;test	ax,8000h
 30047 0000466D A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30048 00004670 7412                    	jz	short $P_Match04	;AN000;
 30049 00004672 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30050                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30051 00004679 E82C01                  	call	$P_Value		;AN000; do process
 30052 0000467C 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30053                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30054 00004682 7557                    	jne	short $P_Match_Exit	;AN000;
 30055                                  $P_Match04:				;AN000;
 30056                                  	;test	ax,4000h
 30057 00004684 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30058 00004687 7412                    	jz	short $P_Match05	;AN000;
 30059 00004689 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30060                                  					;AC034; assume no error
 30061 00004690 E8F100                  	call	$P_SValue		;AN000; do process
 30062 00004693 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30063                                  					;AC034; if error, examine the next type
 30064 00004699 7540                    	jne	short $P_Match_Exit	;AN000;
 30065                                  $P_Match05:				;AN000;
 30066                                  	;test	ax,100h
 30067 0000469B A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30068 0000469E 7415                    	jz	short $P_Match06	;AN000;
 30069 000046A0 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30070                                  					;AC034; assume no error
 30071 000046A7 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 30072 000046AA E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30073 000046AD 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30074                                  					;AC034; if error, examinee the next type
 30075 000046B3 7526                    	jne	short $P_Match_Exit	;AN000;
 30076                                  $P_Match06:				;AN000;
 30077                                  	;test	ax,200h
 30078 000046B5 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 30079 000046B8 7412                    	jz	short $P_Match07	;AN000;
 30080 000046BA 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30081                                  					;AC034; assume no error
 30082 000046C1 E84E05                  	call	$P_File_Format		;AN000; do process
 30083 000046C4 2E833E[0D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 30084                                  					;AC034; if error, examine the next type
 30085 000046CA 750F                    	jne	short $P_Match_Exit	;AN000;
 30086                                  $P_Match07:				;AN000;
 30087                                  $P_Match08:				;AN000;
 30088                                  	;test	ax,2000h
 30089 000046CC A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 30090 000046CF 740A                    	jz	short $P_Match09	;AN000;
 30091 000046D1 2EC706[0D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 30092                                  					;AC034; assume no error
 30093 000046D8 E8D601                  	call	$P_Simple_String	;AN000; do process
 30094                                  $P_Match09:				;AN000;
 30095                                  $P_Match_Exit:				;AN000;
 30096 000046DB 2E833E[E686]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 30097                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 30098 000046E1 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30099 000046E3 2E833E[0D86]00          	cmp	word [cs:$P_RC],$P_No_Error
 30100                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 30101 000046E9 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30102 000046EB 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 30103                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 30104                                  $P_Match2_Exit: 			;AN033;
 30105 000046F2 58                      	pop	ax			;AN000;
 30106 000046F3 C3                      	retn
 30107                                  
 30108                                  ;***********************************************************************
 30109                                  ; $P_Remove_Colon;
 30110                                  ;
 30111                                  ; Function: Remove colon at end
 30112                                  ;
 30113                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 30114                                  ;
 30115                                  ; Output:   None
 30116                                  ;
 30117                                  ; Use:	$P_Chk_DBCS
 30118                                  ;***********************************************************************
 30119                                  
 30120                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30121                                  
 30122                                  $P_Remove_Colon:
 30123 000046F4 50                      	push	ax			;AN000;
 30124 000046F5 56                      	push	si			;AN000;
 30125                                  $P_RCOL_Loop:				;AN000;
 30126 000046F6 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30127 000046F9 08C0                    	or	al,al			;AN000; end of string ?
 30128 000046FB 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30129                                  
 30130 000046FD 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30131 000046FF 750E                    	jne	short $P_RCOL00		;AN000;
 30132                                  
 30133                                  	;cmp	byte [cs:si+1],0
 30134 00004701 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30135 00004706 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30136                                  
 30137 00004708 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30138                                  	; 31/03/2023
 30139                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30140                                  $P_RCOL_Exit:
 30141 0000470C 5E                      	pop	si
 30142 0000470D 58                      	pop	ax
 30143 0000470E C3                      	retn
 30144                                  
 30145                                  $P_RCOL00:				;AN000;
 30146 0000470F E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30147 00004712 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30148                                  
 30149 00004714 46                      	inc	si			;AN000; if yes, skip trailing byte
 30150                                  $P_RCOL01:				;AN000;
 30151 00004715 46                      	inc	si			;AN000; si points to next byte
 30152 00004716 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30153                                  
 30154                                  	; 31/03/2023
 30155                                  ;$P_RCOL_Exit:				;AN000;
 30156                                  	;pop	si			;AN000;
 30157                                  	;pop	ax			;AN000;
 30158                                  	;retn
 30159                                  
 30160                                  ;***********************************************************************
 30161                                  ; $P_Do_CAPS_String;
 30162                                  ;
 30163                                  ; Function: Perform capitalization along with the file case map table
 30164                                  ;	    or character case map table.
 30165                                  ;
 30166                                  ; Input:    AL = 2 : Use character table
 30167                                  ;	    AL = 4 : Use file table
 30168                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30169                                  ;
 30170                                  ; Output:   None
 30171                                  ;
 30172                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30173                                  ;***********************************************************************
 30174                                  
 30175                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30176                                  
 30177                                  $P_Do_CAPS_String:
 30178 00004718 56                      	push	si			;AN000;
 30179 00004719 52                      	push	dx			;AN000;
 30180 0000471A 88C2                    	mov	dl,al			;AN000; save info id
 30181                                  $P_DCS_Loop:				;AN000;
 30182 0000471C 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30183 0000471F E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30184 00004722 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30185                                  
 30186 00004724 08C0                    	or	al,al			;AN000; end of string ?
 30187 00004726 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30188                                  
 30189 00004728 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30190 0000472B 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30191 0000472E EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30192                                  $P_DCS00:				;AN000;
 30193 00004730 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30194                                  $P_DCS01:				;AN000;
 30195 00004731 46                      	inc	si			;AN000; si point to next byte
 30196 00004732 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30197                                  $P_DCS_Exit:				;AN000;
 30198 00004734 5A                      	pop	dx			;AN000;
 30199 00004735 5E                      	pop	si			;AN000;
 30200 00004736 C3                      	retn
 30201                                  
 30202                                  ;***********************************************************************
 30203                                  ; $P_Do_CAPS_Char;
 30204                                  ;
 30205                                  ; Function: Perform capitalization along with the file case map table
 30206                                  ;	    or character case map table.
 30207                                  ;
 30208                                  ; Input:    DL = 2 : Use character table
 30209                                  ;	    DL = 4 : Use file table
 30210                                  ;	    AL = character to be capitalized
 30211                                  ;
 30212                                  ; Output:   None
 30213                                  ;
 30214                                  ; Use:	INT 21h /w AH=65h
 30215                                  ;***********************************************************************
 30216                                  
 30217                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30218                                  
 30219                                  $P_Do_CAPS_Char:
 30220 00004737 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30221 00004739 730B                    	jae	short $P_DCC_Go		;AN000;
 30222                                  
 30223 0000473B 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30224 0000473D 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30225                                  
 30226 0000473F 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30227 00004741 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30228                                  
 30229 00004743 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30230                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30231                                  	; 18/04/2023
 30232 00004745 C3                      	retn
 30233                                  
 30234                                  $P_DCC_Go:				;AN000;
 30235 00004746 53                      	push	bx			;AN000;
 30236 00004747 06                      	push	es			;AN000;
 30237 00004748 57                      	push	di			;AN000;
 30238                                  	; 18/04/2023
 30239 00004749 8D3E[D886]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30240 0000474D 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30241 00004750 7404                    	je	short $P_DCC00		;AN000;
 30242                                  	; 27/04/2023
 30243 00004752 8D3E[D386]              	lea	di,[$P_Char_CAP_Ptr]	;AC034; or use char CAPS table ?
 30244                                  $P_DCC00:				;AN000;
 30245 00004756 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30246 00004759 7417                    	je	short $P_DCC01		;AN000; if no,
 30247                                  
 30248                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30249                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30250                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30251                                  
 30252 0000475B 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30253 0000475C 51                      	push	cx			;AN000;
 30254 0000475D 52                      	push	dx			;AN000;
 30255 0000475E 0E                      	push	cs			;AC036; pass current base seg into
 30256                                  					;(Note: this used to push CS. BUG...
 30257 0000475F 07                      	pop	es			;AN000;   ES reg, required for
 30258                                  					;get extended country information
 30259                                  	; 31/03/2023
 30260 00004760 B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30261                                  	;mov	ah,65h
 30262 00004762 88D0                    	mov	al,dl			;AN000; upper case table
 30263                                  	;mov	bx,-1 ; 0FFFFh
 30264                                  	;mov	cx,5
 30265                                  	;mov	dx,-1
 30266 00004764 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30267 00004767 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30268 0000476A BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30269                                  					;DI already set to point to buffer
 30270 0000476D CD21                    	int	21h			;AN000; es:di point to buffer that
 30271                                  					;now has been filled in with info
 30272 0000476F 5A                      	pop	dx			;AN000;
 30273 00004770 59                      	pop	cx			;AN000;
 30274 00004771 58                      	pop	ax			;AN000;
 30275                                  
 30276                                  $P_DCC01:				;AN000;
 30277                                  
 30278                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30279                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30280                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30281                                  
 30282 00004772 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30283                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 30284 00004776 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30285                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 30286 0000477A 43                      	inc	bx			;AC035; add '2' to
 30287 0000477B 43                      	inc	bx			;AC035;  BX reg
 30288                                  					;AN000; skip length field
 30289 0000477C 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30290                                  	;xlat	es:[bx] 		;AN000; perform case map
 30291                                  	; 31/03/2023
 30292 0000477E 26D7                    	es	xlat
 30293                                  
 30294 00004780 5F                      	pop	di			;AN000;
 30295 00004781 07                      	pop	es			;AN000;
 30296 00004782 5B                      	pop	bx			;AN000;
 30297                                  $P_CAPS_Ret:				;AN000;
 30298 00004783 C3                      	retn
 30299                                  
 30300                                  ;***********************************************************************
 30301                                  ; $P_Value / $P_SValue
 30302                                  ;
 30303                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30304                                  ;	     and make result buffer.
 30305                                  ;	     $P_SValue is an entry point for the signed value
 30306                                  ;	     and this will simply call $P_Value after the handling
 30307                                  ;	     of the sign character, "+" or "-"
 30308                                  ;
 30309                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30310                                  ;	     ES:BX -> CONTROL block
 30311                                  ;
 30312                                  ; Output:    None
 30313                                  ;
 30314                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30315                                  ;
 30316                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30317                                  ;***********************************************************************
 30318                                  
 30319                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30320                                  $P_SValue:
 30321 00004784 50                      	push	ax			;AN000;
 30322                                  	;or	byte [cs:$P_Flags2],80h
 30323 00004785 2E800E[1986]80          	or	byte [cs:$P_Flags2],$P_Signed
 30324                                  					;AC034; indicate a signed numeric
 30325                                  	;and	byte [cs:$P_Flags2],0FDh
 30326 0000478B 2E8026[1986]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30327                                  					;AC034; assume positive value
 30328 00004791 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30329 00004794 3C2B                    	cmp	al,'+' ; 2Bh
 30330                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30331 00004796 740A                    	je	short $P_SVal00		;AN000;
 30332                                  
 30333 00004798 3C2D                    	cmp	al,'-' ; 2Dh
 30334                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30335 0000479A 7507                    	jne	short $P_Sval01		;AN000; else
 30336                                  
 30337 0000479C 2E800E[1986]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30338                                  					;AC034; set this is negative value
 30339                                  $P_SVal00:				;AN000;
 30340 000047A2 46                      	inc	si			;AN000; skip sign char
 30341                                  $P_Sval01:				;AN000;
 30342 000047A3 E80200                  	call	$P_Value		;AN000; and process value
 30343 000047A6 58                      	pop	ax			;AN000;
 30344 000047A7 C3                      	retn				;AN000;
 30345                                  
 30346                                  ;***********************************************************************
 30347                                  
 30348                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30349                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30350                                  
 30351                                  $P_Value:
 30352 000047A8 50                      	push	ax			;AN000;
 30353 000047A9 51                      	push	cx			;AN000;
 30354 000047AA 52                      	push	dx			;AN000;
 30355 000047AB 56                      	push	si			;AN000;
 30356 000047AC 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30357 000047AE 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30358 000047B0 53                      	push	bx			;AN000; save control pointer
 30359                                  $P_Value_Loop:				;AN000;
 30360 000047B1 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30361 000047B4 08C0                    	or	al,al			;AN000; end of line ?
 30362 000047B6 7442                    	jz	short $P_Value00	;AN000;
 30363                                  
 30364 000047B8 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30365 000047BB 7239                    	jc	short $P_Value_Err0	;AN000;
 30366                                  
 30367 000047BD 30E4                    	xor	ah,ah			;AN000;
 30368 000047BF 89C5                    	mov	bp,ax			;AN000; save binary number
 30369 000047C1 D1E2                    	shl	dx,1			;AN000; to have 2*x
 30370 000047C3 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30371 000047C5 E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30372 000047C8 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30373                                  
 30374 000047CA 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 30375 000047CC 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 30376 000047CE D1E2                    	shl	dx,1			;AN000; to have 4*x
 30377 000047D0 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30378 000047D2 E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30379 000047D5 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30380                                  
 30381 000047D7 D1E2                    	shl	dx,1			;AN000; to have 8*x
 30382 000047D9 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30383 000047DB E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30384 000047DE 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30385                                  
 30386 000047E0 01DA                    	add	dx,bx			;AN000; now have 10*x
 30387 000047E2 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 30388 000047E4 E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30389 000047E7 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30390                                  
 30391 000047E9 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 30392 000047EB 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30393 000047EE E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30394 000047F1 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30395                                  
 30396 000047F3 46                      	inc	si			;AN000; update pointer
 30397 000047F4 EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30398                                  
 30399                                  $P_Value_Err0:				;AN000;
 30400 000047F6 5B                      	pop	bx			;AN000;
 30401 000047F7 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30402                                  
 30403                                  $P_Value00:				;AN000;
 30404 000047FA 5B                      	pop	bx			;AN000; restore control pointer
 30405 000047FB 2EF606[1986]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30406                                  					;AC034; here cx,dx = 32bit value
 30407 00004801 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30408                                  
 30409 00004803 F7D1                    	not	cx			;AN000; +
 30410 00004805 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30411 00004807 83C201                  	add	dx,1			;AN000; |
 30412 0000480A 83D100                  	adc	cx,0			;AN000; +
 30413                                  $P_Value01:				;AN000; / nval =0
 30414 0000480D 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30415                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30416 00004811 268A04                  	mov	al,[es:si]		;AN000; get nval
 30417 00004814 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30418 00004816 7505                    	jne	short $P_Value02	;AN000;
 30419                                  
 30420                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30421                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30422                                  	; 31/03/2023
 30423 00004818 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30424 0000481B EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30425                                  
 30426                                  $P_Value02:				;AN000; / nval = 1
 30427 0000481D 46                      	inc	si			;AN000;
 30428 0000481E 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30429 00004821 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30430 00004823 745D                    	je	short $P_Value03	;AN000; (tm07)
 30431                                  
 30432 00004825 46                      	inc	si			;AN000; si points to 1st item_tag
 30433                                  $P_Val02_Loop:				;AN000;
 30434 00004826 2EF606[1986]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30435                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30436 0000482C 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30437                                  
 30438 0000482E 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30439                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30440 00004832 723B                    	jb	short $P_Val02_Next	;AN000;
 30441 00004834 7706                    	ja	short $P_Val_In		;AN000;
 30442                                  
 30443 00004836 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30444                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30445 0000483A 7233                    	jb	short $P_Val02_Next	;AN000;
 30446                                  
 30447                                  $P_Val_In:				;AN000;
 30448 0000483C 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30449                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30450 00004840 772D                    	ja	short $P_Val02_Next	;AN000;
 30451 00004842 7224                    	jb	short $P_Val_Found	;AN000;
 30452                                  
 30453 00004844 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30454                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30455 00004848 7725                    	ja	short $P_Val02_Next	;AN000;
 30456                                  
 30457 0000484A EB1C                    	jmp	short $P_Val_Found	;AN000;
 30458                                  
 30459                                  $P_Val02_Sign:				;AN000;
 30460 0000484C 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30461                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30462 00004850 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30463 00004852 7F06                    	jg	short $P_SVal_In	;AN000;
 30464                                  
 30465 00004854 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30466                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30467 00004858 7C15                    	jl	short $P_Val02_Next	;AN000;
 30468                                  
 30469                                  $P_SVal_In:				;AN000;
 30470 0000485A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30471                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30472 0000485E 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30473 00004860 7C06                    	jl	short $P_Val_Found	;AN000;
 30474                                  
 30475 00004862 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30476                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30477 00004866 7F07                    	jg	short $P_Val02_Next	;AN000;
 30478                                  
 30479                                  	;jmp	short $P_Val_Found	;AN000;
 30480                                  	; 27/04/2023
 30481                                  $P_Val_Found:				;AN000;
 30482 00004868 B001                    	mov	al,$P_Number ; 1	;AN000;
 30483 0000486A 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30484 0000486D EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30485                                  
 30486                                  $P_Val02_Next:				;AN000;
 30487 0000486F 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30488 00004872 FEC8                    	dec	al			;AN000; loop nrng times in AL
 30489 00004874 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30490                                  					; / Not found
 30491 00004876 2EC706[0D86]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30492                                  	;mov	word [cs:$P_RC],6	;AC034;
 30493                                  	
 30494                                  	;mov	al,$P_Number ; 1	;AN000;
 30495                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30496                                  	; 31/03/2023
 30497 0000487D B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30498 00004880 EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30499                                  
 30500                                  	; 27/04/2023
 30501                                  ;$P_Val_Found:				;AN000;
 30502                                  	;mov	al,$P_Number ; 1	;AN000;
 30503                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30504                                  	;jmp	short $P_Value_Exit	;AN000;
 30505                                  
 30506                                  $P_Value03:				;AN000; / nval = 2
 30507                                  $P_Value04:				;AN000; / nval = 3 or else
 30508                                  $P_Value_Err:				;AN000;
 30509 00004882 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30510                                  					;AC034;
 30511                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30512                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30513                                  	; 31/03/2023
 30514 00004889 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30515                                  $P_Value_Exit:				;AN000;
 30516 0000488C E809FD                  	call	$P_Fill_Result		;AN000;
 30517 0000488F 5E                      	pop	si			;AN000;
 30518 00004890 5A                      	pop	dx			;AN000;
 30519 00004891 59                      	pop	cx			;AN000;
 30520 00004892 58                      	pop	ax			;AN000;
 30521 00004893 C3                      	retn				;AN000;
 30522                                  
 30523                                  ;***********************************************************************
 30524                                  ; $P_Check_OVF
 30525                                  ;
 30526                                  ; Function:  Check if overflow is occurred with consideration of
 30527                                  ;	     signed or un-signed numeric value
 30528                                  ;
 30529                                  ; Input:     Flag register
 30530                                  ;
 30531                                  ; Output:    CY = 1  :	Overflow
 30532                                  ;
 30533                                  ; Vars:     $P_Flags(R)
 30534                                  ;***********************************************************************
 30535                                  
 30536                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30537                                  $P_Check_OVF:
 30538 00004894 9C                      	pushf				;AN000;
 30539 00004895 2EF606[1986]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30540                                  					;AC034; is it negative value ?
 30541 0000489B 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30542 0000489D 9D                      	popf				;AN000; by the CY bit
 30543 0000489E C3                      	retn				;AN000;
 30544                                  $P_COVF:				;AN000;
 30545 0000489F 9D                      	popf				;AN000; else,
 30546 000048A0 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30547 000048A2 F8                      	clc				;AN000; indicate it with CY bit
 30548 000048A3 C3                      	retn				;AN000; CY=0 means no overflow
 30549                                  $P_0099Err:	; 31/03/2023
 30550                                  $P_COVF00:				;AN000;
 30551 000048A4 F9                      	stc				;AN000; and CY=1 means overflow
 30552                                  $P_0099Err2:	; 31/03/2023
 30553 000048A5 C3                      	retn				;AN000;
 30554                                  
 30555                                  ;***********************************************************************
 30556                                  ; $P_0099;
 30557                                  ;
 30558                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30559                                  ;
 30560                                  ; Input:     AL = character code
 30561                                  ;
 30562                                  ; Output:    CY = 1 : AL is not number
 30563                                  ;	     CY = 0 : AL contains binary value
 30564                                  ;***********************************************************************
 30565                                  
 30566                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30567                                  $P_0099:
 30568 000048A6 3C30                    	cmp	al,"0"                  ;AN000;
 30569                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30570                                  	; 31/03/2023
 30571 000048A8 72FB                    	jb	short $P_0099Err2
 30572                                  
 30573 000048AA 3C39                    	cmp	al,"9"                  ;AN000;
 30574 000048AC 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30575                                  
 30576 000048AE 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 30577                                  	; 31/03/2023
 30578                                  	;clc				;AN000; indicate no error
 30579 000048B0 C3                      	retn				;AN000;
 30580                                  	 ;31/03/2023
 30581                                  ;$P_0099Err:				;AN000;
 30582                                  ;	stc				;AN000; indicate error
 30583                                  ;	retn				;AN000;
 30584                                  
 30585                                  ;***********************************************************************
 30586                                  ; $P_Simple_String
 30587                                  ;
 30588                                  ; Function:  See value list for the simple string
 30589                                  ;	     and make result buffer.
 30590                                  ;
 30591                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30592                                  ;	     ES:BX -> CONTROL block
 30593                                  ;
 30594                                  ; Output:    None
 30595                                  ;
 30596                                  ; Use:	$P_Fill_Result, $P_String_Comp
 30597                                  ;
 30598                                  ; Vars: $P_RC(W)
 30599                                  ;***********************************************************************
 30600                                  
 30601                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30602                                  
 30603                                  $P_Simple_String:
 30604 000048B1 50                      	push	ax			;AN000;
 30605 000048B2 53                      	push	bx			;AN000;
 30606 000048B3 52                      	push	dx			;AN000;
 30607 000048B4 57                      	push	di			;AN000;
 30608 000048B5 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30609                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 30610 000048B9 268A05                  	mov	al,[es:di]		;AN000; get nval
 30611 000048BC 08C0                    	or	al,al			;AN000; no value list ?
 30612 000048BE 7502                    	jnz	short $P_Sim00		;AN000; then
 30613                                  	; 31/03/2023
 30614                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30615 000048C0 EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 30616                                  $P_Sim00:				;AN000;
 30617 000048C2 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 30618 000048C4 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 30619                                  
 30620 000048C6 47                      	inc	di			;AN000;
 30621 000048C7 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 30622 000048CA B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 30623 000048CC F6E4                    	mul	ah			;AN000;  Skip nrng field
 30624 000048CE 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 30625 000048CF 01C7                    	add	di,ax			;AN000; di points to nnval
 30626 000048D1 268A05                  	mov	al,[es:di]		;AN000; get nnval
 30627 000048D4 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 30628 000048D6 F6E4                    	mul	ah			;AN000; Skip nnval field
 30629 000048D8 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 30630 000048D9 01C7                    	add	di,ax			;AN000; di points to nstrval
 30631 000048DB 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 30632 000048DE 47                      	inc	di			;AC035; add '2' to
 30633 000048DF 47                      	inc	di			;AC035;  DI reg
 30634                                  					;AN000; di points to 1st string in list
 30635                                  $P_Sim_Loop:				;AN000;
 30636 000048E0 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 30637 000048E3 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 30638 000048E6 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 30639                                  
 30640 000048E8 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 30641 000048EB FEC8                    	dec	al			;AN000; loop nstval times in AL
 30642 000048ED 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 30643                                  					;AN000; / Not found
 30644 000048EF 2EC706[0D86]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 30645                                  	;mov	[cs:$P_RC],8		;AC034;
 30646                                  	; 31/03/2023
 30647                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30648 000048F6 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 30649                                  $P_Sim_Found:				;AN000;
 30650 000048F8 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 30651 000048FC B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 30652 000048FE 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 30653 00004901 EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 30654                                  $P_Sim01:				;AN000;
 30655 00004903 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 30656                                  	;mov	word [cs:$P_RC],9	;AC034;
 30657                                  $P_Sim_Exit:
 30658                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30659                                  ;$P_Sim_Exit:				;AN000;
 30660                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30661                                  	; 31/03/2023
 30662 0000490A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30663                                  $P_Sim_Exit0:				;AN000;
 30664 0000490D E888FC                  	call	$P_Fill_Result		;AN000;
 30665 00004910 5F                      	pop	di			;AN000;
 30666 00004911 5A                      	pop	dx			;AN000;
 30667 00004912 5B                      	pop	bx			;AN000;
 30668 00004913 58                      	pop	ax			;AN000;
 30669 00004914 C3                      	retn				;AN000;
 30670                                  
 30671                                  ;***********************************************************************
 30672                                  ; $P_String_Comp:
 30673                                  ;
 30674                                  ; Function:  Compare two string
 30675                                  ;
 30676                                  ; Input:     psdata_seg:SI -> 1st string
 30677                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 30678                                  ;	     ES:BX -> CONTROL block
 30679                                  ;
 30680                                  ; Output:    CY = 1 if not match
 30681                                  ;
 30682                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 30683                                  ;
 30684                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 30685                                  ;***********************************************************************
 30686                                  
 30687                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30688                                  
 30689                                  $P_String_Comp:
 30690 00004915 50                      	push	ax			;AN000;
 30691 00004916 55                      	push	bp			;AN000;
 30692 00004917 52                      	push	dx			;AN000;
 30693 00004918 56                      	push	si			;AN000;
 30694 00004919 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 30695                                  $P_SCOM_Loop:				;AN000;
 30696 0000491B 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 30697 0000491E E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 30698 00004921 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 30699                                  
 30700 00004923 E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 30701                                  	
 30702 00004926 2EF606[1986]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 30703                                  					;AC034; keyword search ?
 30704 0000492C 740D                    	jz	short $P_SCOM04		;AN000;
 30705                                  
 30706                                  	;cmp	al,'=' ; 3Dh
 30707 0000492E 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 30708 00004930 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 30709                                  
 30710 00004932 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 30711 00004937 7562                    	jne	short $P_SCOM_Differ	;AN021;
 30712                                  
 30713 00004939 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 30714                                  
 30715                                  $P_SCOM04:				;AN000;
 30716 0000493B 2EF606[1986]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 30717                                  					;AC034; switch search ?
 30718 00004941 740E                    	jz	short $P_SCOM03		;AN000;
 30719                                  
 30720 00004943 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 30721 00004945 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 30722                                  
 30723 00004947 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 30724 0000494C 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 30725                                  
 30726                                  $P_SCOM05:				;AN000;   found a match
 30727 0000494E 46                      	inc	si			;AN000; si points to just after "=" or ":"
 30728 0000494F EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 30729                                  
 30730                                  $P_SCOM03:				;AN000;
 30731 00004951 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 30732 00004955 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 30733                                  
 30734 00004957 08C0                    	or	al,al			;AN000; end of line
 30735 00004959 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 30736                                  
 30737 0000495B 46                      	inc	si			;AN000; update operand pointer
 30738 0000495C 45                      	inc	bp			;AN000;    and synonym pointer
 30739 0000495D EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 30740                                  
 30741                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 30742 0000495F 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 30743 00004963 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 30744                                  
 30745 00004965 46                      	inc	si			;AN000; else, load next byte
 30746 00004966 2E8A04                  	mov	al,[cs:si]		;AN000; and
 30747 00004969 45                      	inc	bp			;AN000;
 30748 0000496A 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 30749 0000496E 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 30750                                  
 30751 00004970 46                      	inc	si			;AN000; else update operand pointer
 30752 00004971 45                      	inc	bp			;AN000; 	and synonym pointer
 30753                                  $P_SCOM01:				;AN000;
 30754 00004972 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 30755                                  
 30756                                  $P_SCOM_Differ0:			;AN000;
 30757 00004974 2EF606[1986]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 30758                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 30759 0000497A 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 30760                                  
 30761                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 30762                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 30763                                  	; 03/04/2023
 30764 0000497C 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 30765 00004981 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 30766                                  
 30767 00004983 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 30768 00004988 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 30769                                  
 30770                                  $P_not_applicable:			;AN000;(tm10)
 30771                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30772                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 30773                                  	; 03/04/2023
 30774 0000498A 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30775 0000498E 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 30776                                  
 30777 00004990 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 30778 00004992 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 30779                                  
 30780 00004994 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 30781                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 30782                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 30783                                  	; 01/04/2023
 30784 00004999 740E                    	je	short $P_SCOM_Same
 30785                                  $P_SCOM_Differ:
 30786 0000499B F9                      	stc
 30787 0000499C EB10                    	jmp	short $P_SCOM_Exit
 30788                                  
 30789                                  $P_SCOM02:				;AN000;
 30790 0000499E 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 30791 000049A0 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 30792                                  
 30793                                  	;cmp	byte [es:bp],':'
 30794 000049A2 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 30795                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 30796                                  	; 01/04/2023
 30797 000049A7 75F2                    	jne	short $P_SCOM_Differ
 30798                                  ;$P_SCOM_Differ: 			;AN000;
 30799                                  	;stc				;AN000; indicate not found
 30800                                  	;jmp	short $P_SCOM_Exit	;AN000;
 30801                                  
 30802                                  $P_SCOM_Same:				;AN000;
 30803 000049A9 2E8936[1C86]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 30804                                  	; 01/04/2023
 30805                                  	;clc
 30806                                  	; cf = 0			;AN000; indicate found
 30807                                  $P_SCOM_Exit:				;AN000;
 30808 000049AE 5E                      	pop	si			;AN000;
 30809 000049AF 5A                      	pop	dx			;AN000;
 30810 000049B0 5D                      	pop	bp			;AN000;
 30811 000049B1 58                      	pop	ax			;AN000;
 30812 000049B2 C3                      	retn				;AN000;
 30813                                  
 30814                                  ;***********************************************************************
 30815                                  ; $P_Date_Format
 30816                                  ;
 30817                                  ; Function:  Convert a date string to DOS date format for int 21h
 30818                                  ;	     with format validation.
 30819                                  ;
 30820                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30821                                  ;	     ES:BX -> CONTROL block
 30822                                  ;
 30823                                  ; Output:    None
 30824                                  ;
 30825                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 30826                                  ;
 30827                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 30828                                  ;***********************************************************************
 30829                                  
 30830                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30831                                  
 30832                                  $P_Date_Format:
 30833 000049B3 50                      	push	ax			;AN000;
 30834 000049B4 51                      	push	cx			;AN000;
 30835 000049B5 52                      	push	dx			;AN000;
 30836 000049B6 56                      	push	si			;AN000;
 30837 000049B7 53                      	push	bx			;AN000;
 30838 000049B8 56                      	push	si			;AN000;
 30839 000049B9 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 30840                                  	; 03/04/2023
 30841                                  	;pop	si			;AN000;
 30842                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 30843                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 30844                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 30845 000049BC 31F6                    	xor	si,si
 30846 000049BE 2E8936[CB86]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 30847 000049C3 2E8936[CD86]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 30848                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 30849 000049C8 5E                      	pop	si
 30850 000049C9 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 30851 000049CC 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 30852 000049CE 2EA3[CB86]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 30853 000049D2 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30854 000049D4 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30855 000049D6 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 30856 000049D9 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 30857 000049DB 2EA3[CD86]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 30858 000049DF 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30859 000049E1 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30860 000049E3 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 30861                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 30862 000049E6 7260                    	jc	short $P_DateF_Error	;AN000;
 30863 000049E8 2EA3[CF86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 30864 000049EC 08DB                    	or	bl,bl			;AN000; end of line ?
 30865 000049EE 7558                    	jnz	short $P_DateF_Error	;AN000;
 30866                                  $P_DateF_YMD:				;AN000;
 30867 000049F0 2E8B1E[A986]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 30868                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 30869 000049F5 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 30870 000049F8 7422                    	je	short $P_DateF00	;AN000;
 30871 000049FA 2EA1[CB86]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 30872 000049FE 08E4                    	or	ah,ah			;AN000;
 30873 00004A00 7546                    	jnz	short $P_DateF_Error	;AN000;
 30874 00004A02 88C1                    	mov	cl,al			;AN000; set month
 30875 00004A04 2EA1[CD86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30876 00004A08 08E4                    	or	ah,ah			;AN000; if overflow, error.
 30877 00004A0A 753C                    	jnz	short $P_DateF_Error	;AN000;
 30878 00004A0C 88C5                    	mov	ch,al			;AN000; set date
 30879 00004A0E 2E8B16[CF86]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 30880 00004A13 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 30881 00004A16 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 30882 00004A18 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 30883                                  $P_DateF01:				;AN000;
 30884 00004A1A EB19                    	jmp	short $P_DateF02	;AN000;
 30885                                  $P_DateF00:				;AN000; / here format = YMD
 30886 00004A1C 2E8B16[CB86]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 30887 00004A21 2EA1[CD86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30888 00004A25 08E4                    	or	ah,ah			;AN000; if overflow, error
 30889 00004A27 751F                    	jnz	short $P_DateF_Error	;AN000;
 30890                                  
 30891 00004A29 88C1                    	mov	cl,al			;AN000; set month
 30892 00004A2B 2EA1[CF86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 30893 00004A2F 08E4                    	or	ah,ah			;AN000; if overflow, error
 30894 00004A31 7515                    	jnz	short $P_DateF_Error	;AN000;
 30895 00004A33 88C5                    	mov	ch,al			;AN000; set date
 30896                                  $P_DateF02:				;AN000;
 30897 00004A35 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 30898 00004A38 7304                    	jae	short $P_DateF03	;AN000;
 30899 00004A3A 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 30900                                  $P_DateF03:				;AN000;
 30901 00004A3E 5B                      	pop	bx			;AN000; recover CONTROL block
 30902 00004A3F 5E                      	pop	si			;AN000; recover string pointer
 30903                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 30904                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 30905                                  	; 03/04/2023
 30906 00004A40 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 30907 00004A43 E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 30908 00004A46 EB0F                    	jmp	short $P_Date_Format_Exit
 30909                                  					;AN000;	to Date
 30910                                  $P_DateF_Error: 			;AN000;
 30911 00004A48 5B                      	pop	bx			;AN000; recover CONTROL block
 30912 00004A49 5E                      	pop	si			;AN000; recover string pointer
 30913                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 30914                                  	;mov	al,$P_String ; 3	;AN000;   result
 30915                                  	; 03/04/2023
 30916 00004A4A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30917 00004A4D E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 30918                                  					;AN000; to string
 30919 00004A50 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30920                                  					;AC034; indicate syntax error
 30921                                  $P_Date_Format_Exit:			;AN000;
 30922 00004A57 5A                      	pop	dx			;AN000;
 30923 00004A58 59                      	pop	cx			;AN000;
 30924 00004A59 58                      	pop	ax			;AN000;
 30925 00004A5A C3                      	retn				;AN000;
 30926                                  
 30927                                  ;***********************************************************************
 30928                                  ; $P_Set_CDI:
 30929                                  ;
 30930                                  ; Function: Read CDI from DOS if it has not been read yet
 30931                                  ;
 30932                                  ; Input:    None
 30933                                  ;
 30934                                  ; Output:   psdata_seg:SI -> CDI
 30935                                  ;
 30936                                  ; Use:	INT 21h w/ AH = 38h
 30937                                  ;***********************************************************************
 30938                                  
 30939                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30940                                  $P_Set_CDI:
 30941                                  	; 18/04/2023
 30942 00004A5B 8D36[A986]              	lea	si,$P_Country_Info	;AC034;
 30943                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 30944 00004A5F 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 30945                                  					;AN000; already read ?
 30946                                  	;je	short $P_Read_CDI	;AN000;
 30947                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 30948                                  	; 03/04/2023
 30949 00004A63 750F                    	jne	short $P_Set_CDI_Exit
 30950                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 30951 00004A65 1E                      	push	ds			;AN000;
 30952 00004A66 52                      	push	dx			;AN000;
 30953 00004A67 50                      	push	ax			;AN000;
 30954 00004A68 0E                      	push	cs			;AC023;
 30955 00004A69 1F                      	pop	ds			;AN000; set segment register
 30956                                  	;mov	ax,3800h
 30957 00004A6A B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 30958 00004A6D 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 30959 00004A6F CD21                    	int	21h			;AN000;
 30960 00004A71 58                      	pop	ax			;AN000;
 30961 00004A72 5A                      	pop	dx			;AN000;
 30962 00004A73 1F                      	pop	ds			;AN000;
 30963                                  $P_Set_CDI_Exit:			;AN000;
 30964 00004A74 C3                      	retn				;AN000;
 30965                                  
 30966                                  ;***********************************************************************
 30967                                  ; $P_Get_DecNum:
 30968                                  ;
 30969                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 30970                                  ;	     or NULL encountered. And make a decimal number.
 30971                                  ;
 30972                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30973                                  ;
 30974                                  ; Output:    BL = delimiter code or NULL
 30975                                  ;	     AX = Decimal number
 30976                                  ;	     SI advanced to the next number
 30977                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 30978                                  ;
 30979                                  ; Use:	$P_0099
 30980                                  ;***********************************************************************
 30981                                  
 30982                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30983                                  $P_Get_DecNum:
 30984 00004A75 51                      	push	cx			;AN000;
 30985 00004A76 52                      	push	dx			;AN000;
 30986 00004A77 31C9                    	xor	cx,cx			;AN000; cx will have final value
 30987                                  $P_GetNum_Loop: 			;AN000;
 30988 00004A79 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 30989 00004A7C 08C0                    	or	al,al			;AN000; end of line ?
 30990 00004A7E 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 30991 00004A80 2E803E[A886]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 30992 00004A86 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 30993                                  
 30994                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 30995                                  	;cmp	bl,$P_colon_period
 30996 00004A88 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 30997 00004A8B 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 30998                                  
 30999 00004A8D 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31000 00004A8F 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31001                                  
 31002                                  	; 03/04/2023
 31003 00004A91 EB08                    	jmp	short $P_Do_Time_Delim1
 31004                                  ;$P_Do_Time_Delim1:			;AN000;
 31005                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31006                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31007                                  	;
 31008                                  	;jmp	short $P_Neither_Delims ;AN023;
 31009                                  
 31010                                  $P_Do_Date_Delims:			;AN000;
 31011                                  ;Regardless of the date delimiter character specified in the country
 31012                                  ;dependent information, check for the presence of any one of these
 31013                                  ;three field delimiters: "-", "/", or ".".
 31014 00004A93 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31015 00004A95 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31016                                  
 31017 00004A97 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31018 00004A99 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31019                                  
 31020                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31021 00004A9B 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31022 00004A9D 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31023                                  
 31024                                  $P_Neither_Delims:			;AN023;
 31025 00004A9F E804FE                  	call	$P_0099 		;AN000; convert it to binary
 31026 00004AA2 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31027                                  
 31028 00004AA4 B400                    	mov	ah,0			;AN000;
 31029 00004AA6 91                      	xchg	ax,cx			;AN000;
 31030 00004AA7 BA0A00                  	mov	dx,10			;AN000;
 31031 00004AAA F7E2                    	mul	dx			;AN000; ax = ax * 10
 31032 00004AAC 09D2                    	or	dx,dx			;AN000; overflow
 31033 00004AAE 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31034                                  
 31035 00004AB0 01C8                    	add	ax,cx			;AN000;
 31036 00004AB2 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31037                                  
 31038 00004AB4 91                      	xchg	ax,cx			;AN000;
 31039 00004AB5 46                      	inc	si			;AN000;
 31040 00004AB6 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31041                                  
 31042                                  $P_GetNum00:				;AN000;
 31043 00004AB8 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31044                                  	;03/04/2023
 31045                                  	; cf=0
 31046                                  	;clc				;AN000; indicate no error
 31047 00004ABA EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31048                                  
 31049                                  $P_GetNum01:				;AN000;
 31050 00004ABC 46                      	inc	si			;AN000; si points to next number
 31051                                  	;03/04/2023
 31052                                  	; cf=0
 31053                                  	;clc				;AN000; indicate no error
 31054 00004ABD EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31055                                  
 31056                                  $P_GetNum02:				;AN000;
 31057 00004ABF F9                      	stc				;AN000; indicate error
 31058                                  $P_GetNum_Exit: 			;AN000;
 31059 00004AC0 89C8                    	mov	ax,cx			;AN000;return value
 31060 00004AC2 5A                      	pop	dx			;AN000;
 31061 00004AC3 59                      	pop	cx			;AN000;
 31062 00004AC4 C3                      	retn				;AN000;
 31063                                  
 31064                                  ;***********************************************************************
 31065                                  ; $P_Time_Format
 31066                                  ;
 31067                                  ; Function:  Convert a time string to DOS time format for int 21h
 31068                                  ;	     with format validation.
 31069                                  ;
 31070                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31071                                  ;	     ES:BX -> CONTROL block
 31072                                  ;
 31073                                  ; Output:    None
 31074                                  ;
 31075                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 31076                                  ;
 31077                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 31078                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 31079                                  ;***********************************************************************
 31080                                  
 31081                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31082                                  
 31083                                  $P_Time_Format:				;AN000;
 31084 00004AC5 50                      	push	ax			;AN000;
 31085 00004AC6 51                      	push	cx			;AN000;
 31086 00004AC7 52                      	push	dx			;AN000;
 31087 00004AC8 56                      	push	si			;AN000;
 31088 00004AC9 53                      	push	bx			;AN000;
 31089 00004ACA 56                      	push	si			;AN000;
 31090 00004ACB E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 31091                                  					; information before process
 31092                                  	;test	byte [cs:si+11h], 1
 31093 00004ACE 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 31094                                  					;AN000; 24 hour system
 31095 00004AD3 5E                      	pop	si			;AN000;
 31096 00004AD4 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 31097 00004AD6 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 31098                                  $P_TimeF00:				;AN000;
 31099                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31100                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31101                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31102                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 31103                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 31104                                  	; 03/04/2023
 31105 00004AD9 31DB                    	xor	bx,bx
 31106 00004ADB 2E891E[CB86]            	mov	[cs:$P_1st_Val],bx ; 0
 31107 00004AE0 2E891E[CD86]            	mov	[cs:$P_2nd_Val],bx ; 0
 31108 00004AE5 2E891E[CF86]            	mov	[cs:$P_3rd_Val],bx ; 0
 31109 00004AEA 2E891E[D186]            	mov	[cs:$P_4th_Val],bx ; 0
 31110                                  	;inc	bl
 31111                                  	;mov	[cs:$P_Got_Time],bl ; 1
 31112                                  
 31113                                  	;mov	bl,$P_colon_period
 31114                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 31115                                  					; delimiters between hours,
 31116                                  					;  minutes,seconds
 31117                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 31118 00004AEF FEC3                    	inc	bl ; bl = 1
 31119 00004AF1 2E881E[A886]            	mov	[cs:$P_Got_Time],bl ; 1
 31120                                  	;
 31121 00004AF6 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 31122 00004AF9 725D                    	jc	short $P_TimeF_Err0	;AN000;
 31123 00004AFB 2EA3[CB86]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31124 00004AFF 08DB                    	or	bl,bl			;AN000; end of line ?
 31125 00004B01 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 31126 00004B03 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31127 00004B06 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 31128 00004B08 2EA3[CD86]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31129 00004B0C 08DB                    	or	bl,bl			;AN000; end of line ?
 31130 00004B0E 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 31131 00004B10 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31132 00004B12 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31133 00004B15 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31134 00004B17 2EA3[CF86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31135 00004B1B 08DB                    	or	bl,bl			;AN000; end of line ?
 31136 00004B1D 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31137                                  					;AN039;   GO TO 4TH NUMBER
 31138                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31139 00004B1F 2EF606[1886]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31140                                  					;AN039;    BEEN REPEATED?
 31141 00004B25 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31142                                  					;AN039;   the end of line
 31143                                  					;AN039; no, time has not been repeated
 31144 00004B27 2E8B36[0F86]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31145                                  					;AN039;   in command line
 31146 00004B2C 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31147                                  					;AN039; look at delimiter
 31148                                  					;AN039;   from command line
 31149 00004B30 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31150                                  					;AN039;  really end of line
 31151                                  					;AN039; is comma before hundredths,
 31152                                  					;AN039;   redo TIME
 31153 00004B32 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31154                                  					;AN039; change that ambiguous
 31155                                  					;AN039;    comma to a decimal point
 31156                                  					;AN039;     parse can understand
 31157 00004B36 2EC706[1886]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31158                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31159 00004B3D 2E800E[1886]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31160                                  					;AN039; is being repeated
 31161 00004B43 2E8B0E[A286]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31162 00004B48 2E8B26[A486]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31163                                  					;AN039;   OF STACK FROM SP
 31164 00004B4D 2E8B36[A686]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31165                                  					;AN039;   PARSE POINTER FROM SI
 31166 00004B52 E911F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31167                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31168 00004B55 E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31169                                  $P_TimeF_Err0:				;AN000; Bridge
 31170 00004B58 725E                    	jc	short $P_TimeF_Error	;AN000;
 31171                                  	;
 31172 00004B5A 2EA3[D186]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31173 00004B5E 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31174 00004B60 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31175                                  $P_TimeF_Rlt:				;AN000;
 31176 00004B62 2EA1[CB86]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31177 00004B66 08E4                    	or	ah,ah			;AN000; if overflow then error
 31178 00004B68 754E                    	jnz	short $P_TimeF_Err	;AN000;
 31179                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31180 00004B6A 2EF606[1886]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31181 00004B70 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31182                                  					;since "AM" was specified,
 31183 00004B72 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31184 00004B74 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31185 00004B76 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31186 00004B78 30C0                    	xor	al,al			;AN038; set hour = zero
 31187                                  $P_Time_notAM:				;AN038;
 31188                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31189 00004B7A 2EF606[1986]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31190 00004B80 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31191 00004B82 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31192 00004B84 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31193 00004B86 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31194 00004B88 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31195 00004B8A 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31196 00004B8C 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31197                                  $P_TimeSkip00:				;AN000;
 31198 00004B8E 88C2                    	mov	dl,al			;AN000; set hour
 31199 00004B90 2EA1[CD86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31200 00004B94 08E4                    	or	ah,ah			;AN000; if overflow then error
 31201 00004B96 7520                    	jnz	short $P_TimeF_Err	;AN000;
 31202 00004B98 88C6                    	mov	dh,al			;AN000; set minute
 31203 00004B9A 2EA1[CF86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31204 00004B9E 08E4                    	or	ah,ah			;AN000; if overflow then error
 31205 00004BA0 7516                    	jnz	short $P_TimeF_Err	;AN000;
 31206 00004BA2 88C1                    	mov	cl,al			;AN000; set second
 31207 00004BA4 2EA1[D186]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31208 00004BA8 08E4                    	or	ah,ah			;AN000; if overflow then error
 31209 00004BAA 750C                    	jnz	short $P_TimeF_Err	;AN000;
 31210 00004BAC 88C5                    	mov	ch,al			;AN000; set hundredth
 31211 00004BAE 5B                      	pop	bx			;AN000; recover CONTROL block
 31212 00004BAF 5E                      	pop	si			;AN000; recover string pointer
 31213                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31214                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31215                                  	; 03/04/2023
 31216 00004BB0 B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31217 00004BB3 E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 31218 00004BB6 EB0F                    	jmp	short $P_Time_Format_Exit
 31219                                  					;AN000; to time
 31220                                  $P_TimeF_Error: 			;AN000;
 31221                                  $P_TimeF_Err:				;AN000;
 31222 00004BB8 5B                      	pop	bx			;AN000; recover CONTROL block
 31223 00004BB9 5E                      	pop	si			;AN000; recover string pointer
 31224                                  	;mov	ah,$P_No_Tag		;AN000; set
 31225                                  	;mov	al,$P_String		;AN000;     result
 31226                                  	; 03/04/2023
 31227 00004BBA B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31228 00004BBD E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 31229                                  					;AN000; to string
 31230 00004BC0 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31231                                  					;AC034; return syntax error
 31232                                  $P_Time_Format_Exit:			;AN000;
 31233 00004BC7 2EC606[A886]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31234 00004BCD 5A                      	pop	dx			;AN000;
 31235 00004BCE 59                      	pop	cx			;AN000;
 31236 00004BCF 58                      	pop	ax			;AN000;
 31237 00004BD0 C3                      	retn
 31238                                  
 31239                                  ;***********************************************************************
 31240                                  ; $P_Time_2412:
 31241                                  ;
 31242                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31243                                  ;
 31244                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31245                                  ;
 31246                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31247                                  ;	     or "pm"
 31248                                  ;
 31249                                  ; Vars:  $P_Flags(W)
 31250                                  ;***********************************************************************
 31251                                  
 31252                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31253                                  
 31254                                  $P_Time_2412:				;AN000;
 31255 00004BD1 50                      	push	ax			;AN000;
 31256 00004BD2 56                      	push	si			;AN000;
 31257                                  $P_T12_Loop:				;AN000;
 31258 00004BD3 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31259 00004BD6 46                      	inc	si			;AN000;     si
 31260 00004BD7 08C0                    	or	al,al			;AN000;       to
 31261 00004BD9 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31262                                  
 31263 00004BDB 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31264                                  	;or	al,20h
 31265 00004BDF 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31266 00004BE1 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31267 00004BE3 7425                    	je	short $P_T1200		;AN000;
 31268                                  
 31269 00004BE5 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31270 00004BE7 7413                    	je	short $P_T1201		;AN000;
 31271                                  
 31272 00004BE9 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31273 00004BEB 751A                    	jne	short $P_T12_Exit	;AN000;
 31274                                  
 31275 00004BED 4E                      	dec	si			;AN000;
 31276 00004BEE 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31277                                  	;or	al,20h
 31278 00004BF2 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31279 00004BF4 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31280 00004BF6 7412                    	je	short $P_T1200		;AN000;
 31281                                  
 31282 00004BF8 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31283                                  	;je	short $P_T1201		;AN000; go process "a"
 31284                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31285                                  	; 05/04/2023
 31286 00004BFA 750B                    	jne	short $P_T12_Exit
 31287                                  
 31288                                  ;$P_T1200:				;AN000; "P" found
 31289                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31290                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31291                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31292                                  
 31293                                  $P_T1201:				;AN000; "A" found
 31294                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31295 00004BFC 2E800E[1886]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31296                                  $P_Tclr_chr:				;AN038;
 31297 00004C02 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31298                                  $P_T12_Exit:				;AN000;
 31299 00004C07 5E                      	pop	si			;AN000;
 31300 00004C08 58                      	pop	ax			;AN000;
 31301 00004C09 C3                      	retn				;AN000;
 31302                                  
 31303                                  	; 05/04/2023
 31304                                  $P_T1200:				;AN000; "P" found
 31305                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31306 00004C0A 2E800E[1986]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31307 00004C10 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31308                                  
 31309                                  ;***********************************************************************
 31310                                  ; $P_File_Format;
 31311                                  ;
 31312                                  ; Function:  Check if the input string is valid file spec format.
 31313                                  ;	     And set the result buffer.
 31314                                  ;
 31315                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31316                                  ;	     ES:BX -> CONTROL block
 31317                                  ;
 31318                                  ; Output:    None
 31319                                  ;
 31320                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31321                                  ;
 31322                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31323                                  ;	$P_SaveSI_Cmpx(R)
 31324                                  ;***********************************************************************
 31325                                  
 31326                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31327                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31328                                  $P_File_Format:
 31329 00004C12 50                      	push	ax			;AN000;
 31330 00004C13 57                      	push	di			;AN000;
 31331 00004C14 56                      	push	si			;AN000;
 31332 00004C15 2E8B3E[1A86]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31333 00004C1A 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31334 00004C1D 08C0                    	or	al,al			;AN000; end of line ?
 31335 00004C1F 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31336 00004C21 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31337 00004C24 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31338 00004C26 2EC606[E686]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31339                                  					;AN033;AC034;; set error flag- bad char.
 31340 00004C2C 5E                      	pop	si			;AN033;
 31341 00004C2D 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31342 00004C31 5F                      	pop	di			;AN033;
 31343 00004C32 EB3E                    	jmp	short $P_FileF02	;AN033;
 31344                                  $P_FileF_Err:				;AN000;
 31345 00004C34 5E                      	pop	si			;AN000;
 31346 00004C35 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31347 00004C39 5F                      	pop	di			;AN000;
 31348                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31349                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31350 00004C3A 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31351 00004C3E 7532                    	jnz	short $P_FileF02	;AN000;
 31352 00004C40 2EC706[0D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31353                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31354 00004C47 EB29                    	jmp	short $P_FileF02	;AN000;
 31355                                  $P_FileF03:				;AN000;
 31356 00004C49 58                      	pop	ax			;AN000; discard save si
 31357 00004C4A 56                      	push	si			;AN000; save new si
 31358                                  $P_FileF_Loop1: 			;AN000;
 31359 00004C4B 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31360 00004C4E 08C0                    	or	al,al			;AN000; end of line ?
 31361 00004C50 741E                    	jz	short $P_FileF_RLT	;AN000;
 31362 00004C52 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31363 00004C55 740B                    	jz	short $P_FileF00	;AN000;
 31364 00004C57 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31365 00004C5A 7302                    	jnc	short $P_FileF01	;AN000;
 31366 00004C5C 47                      	inc	di			;AN000; if yes, skip next byte
 31367 00004C5D 46                      	inc	si			;AN000;
 31368                                  $P_FileF01:				;AN000;
 31369 00004C5E 47                      	inc	di			;AN000;
 31370 00004C5F 46                      	inc	si			;AN000;
 31371 00004C60 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31372                                  $P_FileF00:				;AN000;
 31373 00004C62 2EA2[1386]              	mov	[cs:$P_Terminator],al	;AC034;
 31374 00004C66 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31375 00004C6A 47                      	inc	di			;AN000;
 31376 00004C6B 2E893E[0F86]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31377                                  $P_FileF_RLT:				;AN000;
 31378 00004C70 5E                      	pop	si			;AN000;
 31379 00004C71 5F                      	pop	di			;AN000;
 31380                                  $P_FileF02:				;AN000;
 31381 00004C72 58                      	pop	ax			;AN000; (tm14)
 31382                                  	;;test	ax,200h
 31383                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31384                                  	; 05/04/2023
 31385 00004C73 F6C402                  	test	ah,($P_File_Spc>>8)
 31386 00004C76 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31387 00004C78 50                      	push	ax			;AN000; (tm14)
 31388                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31389                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31390                                  	; 05/04/2023
 31391 00004C79 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31392 00004C7C E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31393 00004C7F 58                      	pop	ax			;AN000;
 31394                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31395 00004C80 C3                      	retn				;AN000;
 31396                                  
 31397                                  ;***********************************************************************
 31398                                  ; $P_FileSp_Chk
 31399                                  ;
 31400                                  ; Function:  Check if the input byte is one of file special characters
 31401                                  ;
 31402                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31403                                  ;	     AL = character code to be examineed
 31404                                  ;
 31405                                  ; Output:    ZF = 1 , AL is one of special characters
 31406                                  ;***********************************************************************
 31407                                  
 31408                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31409                                  $P_FileSp_Chk:
 31410 00004C81 53                      	push	bx			;AN000;
 31411 00004C82 51                      	push	cx			;AN000;
 31412                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31413 00004C83 8D1E[DD86]              	lea	bx,$P_FileSp_Char
 31414 00004C87 B90900                  	mov	cx,$P_FileSp_Len ; 9
 31415                                  	;mov	cx,9			;AN000; load length of it
 31416                                  $P_FileSp_Loop: 			;AN000;
 31417 00004C8A 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31418 00004C8D 7404                    	je	short $P_FileSp_Exit	;AN000;
 31419 00004C8F 43                      	inc	bx			;AN000;
 31420 00004C90 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31421 00004C92 41                      	inc	cx			;AN000; reset ZF
 31422                                  $P_FileSp_Exit: 			;AN000;
 31423 00004C93 59                      	pop	cx			;AN000;
 31424 00004C94 5B                      	pop	bx			;AN000;
 31425 00004C95 C3                      	retn				;AN000;
 31426                                  
 31427                                  ;***********************************************************************
 31428                                  ; $P_Drive_Format;
 31429                                  ;
 31430                                  ; Function:  Check if the input string is valid drive only format.
 31431                                  ;	     And set the result buffer.
 31432                                  ;
 31433                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31434                                  ;	     ES:BX -> CONTROL block
 31435                                  ;
 31436                                  ; Output:    None
 31437                                  ;
 31438                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31439                                  ;
 31440                                  ; Vars: $P_RC(W)
 31441                                  ;***********************************************************************
 31442                                  
 31443                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31444                                  $P_Drive_Format:
 31445 00004C96 50                      	push	ax			;AN000;
 31446 00004C97 52                      	push	dx			;AN000;
 31447 00004C98 2E8A04                  	mov	al,[cs:si]		;AN000;
 31448 00004C9B 08C0                    	or	al,al			;AN000; if null string
 31449 00004C9D 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31450 00004C9F E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31451 00004CA2 722A                    	jc	short $P_Drv_Err	;AN000;
 31452                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31453 00004CA4 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31454 00004CA9 740D                    	je	short $P_DrvF00		;AN000;
 31455                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31456                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31457 00004CAB 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31458 00004CAF 741D                    	jz	short $P_Drv_Err	;AN000;
 31459 00004CB1 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31460 00004CB6 7516                    	jne	short $P_Drv_Err	;AN000;
 31461                                  $P_DrvF00:				;AN000;
 31462 00004CB8 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31463 00004CBA 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31464 00004CBC 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31465 00004CBE 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31466 00004CC0 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31467 00004CC2 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31468 00004CC4 88C2                    	mov	dl,al			;AN000; set
 31469                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31470                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31471                                  	; 05/04/2023
 31472 00004CC6 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31473 00004CC9 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31474 00004CCC EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31475                                  $P_Drv_Err:				;AN000;
 31476 00004CCE 2EC706[0D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 31477                                  	;mov	word [cs:$P_RC],9	;AC034;
 31478                                  $P_Drv_Exit:				;AN000;
 31479 00004CD5 5A                      	pop	dx			;AN000;
 31480 00004CD6 58                      	pop	ax			;AN000;
 31481 00004CD7 C3                      	retn				;AN000;
 31482                                  
 31483                                  ;***********************************************************************
 31484                                  ; $P_Skip_Delim;
 31485                                  ;
 31486                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31487                                  ;	    and comma.
 31488                                  ;
 31489                                  ; Input:    DS:SI -> Command String
 31490                                  ;	    ES:DI -> Parameter List
 31491                                  ;
 31492                                  ; Output:   CY = 1 if the end of line encounterd
 31493                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31494                                  ;	    AL = Last examineed character
 31495                                  ;
 31496                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31497                                  ;
 31498                                  ; Vars:     $P_Flags(R)
 31499                                  ;***********************************************************************
 31500                                  
 31501                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31502                                  
 31503                                  $P_Skip_Delim:				;AN000;
 31504                                  $P_Skip_Delim_Loop:			;AN000;
 31505 00004CD8 AC                      	lodsb				;AN000;
 31506 00004CD9 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31507 00004CDC 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31508                                  
 31509 00004CDE E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31510 00004CE1 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31511                                  
 31512 00004CE3 2EF606[1986]20          	test	byte [cs:$P_Flags2],$P_Extra
 31513                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31514 00004CE9 74ED                    	jz	short $P_Skip_Delim_Loop
 31515                                  					;AN000; if no, loop
 31516 00004CEB 2EF606[1986]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31517                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31518                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31519                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31520                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31521                                  	; 05/04/2023
 31522 00004CF1 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31523                                  $P_Exit_At_Extra:			;AN000;
 31524                                  	; cf = 0
 31525                                  	;clc				;AN000; indicate extra delim
 31526 00004CF3 C3                      	retn				;AN000;
 31527                                  
 31528                                  $P_Skip_Delim_CY:			;AN000;
 31529 00004CF4 F9                      	stc				;AN000; indicate EOL
 31530 00004CF5 EB01                    	jmp	short $P_Skip_Delim_Exit
 31531                                  					;AN000;
 31532                                  $P_Skip_Delim_NCY:			;AN000;
 31533 00004CF7 F8                      	clc				;AN000; indicate non delim
 31534                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31535 00004CF8 4E                      	dec	si ; *			;AN000;  backup index pointer
 31536 00004CF9 C3                      	retn				;AN000;
 31537                                  	; 05/04/2023
 31538                                  ;$P_Exit_At_Extra:			;AN000;
 31539                                  	;clc				;AN000; indicate extra delim
 31540                                  	;retn				;AN000;
 31541                                  
 31542                                  ;***********************************************************************
 31543                                  ; $P_Chk_EOL;
 31544                                  ;
 31545                                  ; Function: Check if AL is one of End of Line characters.
 31546                                  ;
 31547                                  ; Input:    AL = character code
 31548                                  ;	    ES:DI -> Parameter List
 31549                                  ;
 31550                                  ; Output:   ZF = 1 if one of End of Line characters
 31551                                  ;***********************************************************************
 31552                                  
 31553                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31554                                  
 31555                                  $P_Chk_EOL:
 31556 00004CFA 53                      	push	bx			;AN000;
 31557 00004CFB 51                      	push	cx			;AN000;
 31558 00004CFC 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31559 00004CFE 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31560 00004D00 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 31561 00004D02 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31562 00004D04 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 31563                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 31564 00004D09 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 31565 00004D0B 31DB                    	xor	bx,bx			;AN000;
 31566 00004D0D 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31567                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 31568 00004D11 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 31569 00004D14 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 31570                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 31571 00004D18 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 31572 00004D1A 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 31573 00004D1C 268A09                  	mov	cl,[es:bx+di]		;AN000;
 31574                                  $P_Chk_EOL_Loop:			;AN000;
 31575 00004D1F 43                      	inc	bx			;AN000;
 31576 00004D20 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 31577 00004D23 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31578 00004D25 E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 31579                                  $P_Chk_EOL_NZ:				;AN000;
 31580 00004D27 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 31581                                  $P_Chk_EOL_Exit:			;AN000;
 31582 00004D29 59                      	pop	cx			;AN000;
 31583 00004D2A 5B                      	pop	bx			;AN000;
 31584 00004D2B C3                      	retn				;AN000;
 31585                                  
 31586                                  ;***********************************************************************
 31587                                  ; $P_Chk_Delim;
 31588                                  ;
 31589                                  ; Function: Check if AL is one of delimiter characters.
 31590                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 31591                                  ;	    blanks.
 31592                                  ;
 31593                                  ; Input:    AL = character code
 31594                                  ;	    DS:SI -> Next Character
 31595                                  ;	    ES:DI -> Parameter List
 31596                                  ;
 31597                                  ; Output:   ZF = 1 if one of delimiter characters
 31598                                  ;	    SI points to the next character
 31599                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 31600                                  ;***********************************************************************
 31601                                  
 31602                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31603                                  
 31604                                  $P_Chk_Delim:
 31605 00004D2C 53                      	push	bx			;AN000;
 31606 00004D2D 51                      	push	cx			;AN000;
 31607 00004D2E 2EC606[1386]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 31608                                  					;AC034; Assume terminated by space
 31609 00004D34 2E8026[1986]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 31610                                  					;AC034;
 31611 00004D3A 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 31612 00004D3C 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 31613                                  
 31614 00004D3E 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 31615 00004D40 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 31616                                  
 31617 00004D42 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 31618 00004D44 7431                    	je	short $P_Chk_Delim_Exit0
 31619                                  					;AN000;
 31620                                  $P_Chk_Delim00: 			;AN000;
 31621 00004D46 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 31622 00004D48 750C                    	jne	short $P_Chk_Delim01	;AN000;
 31623 00004D4A 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 31624                                  					;AN000; 2nd byte of DBCS Space ?
 31625 00004D4D 7507                    	jne	short $P_Chk_Delim01	;AN000;
 31626 00004D4F B020                    	mov	al,$P_Space ; 20h	;AN000;
 31627 00004D51 46                      	inc	si			;AN000; make si point to next character
 31628 00004D52 38C0                    	cmp	al,al			;AN000; Set ZF
 31629 00004D54 EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31630                                  
 31631                                  $P_Chk_Delim01: 			;AN000;
 31632                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 31633 00004D56 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 31634                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 31635 00004D5B 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 31636                                  
 31637 00004D5D 31C9                    	xor	cx,cx			;AN000;
 31638 00004D5F 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31639                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 31640 00004D63 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 31641 00004D65 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 31642                                  
 31643 00004D67 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 31644                                  $P_Chk_Delim_Loop:			;AN000;
 31645 00004D6A 43                      	inc	bx			;AN000;
 31646 00004D6B 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 31647 00004D6E 7407                    	je	short $P_Chk_Delim_Exit0
 31648                                  					;AN000;
 31649 00004D70 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 31650                                  
 31651                                  $P_Chk_Delim_NZ:			;AN000;
 31652 00004D72 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 31653                                  $P_Chk_Delim_Exit:			;AN000;
 31654 00004D74 59                      	pop	cx			;AN000;
 31655 00004D75 5B                      	pop	bx			;AN000;
 31656 00004D76 C3                      	retn				;AN000;
 31657                                  
 31658                                  $P_Chk_Delim_Exit0:			;AN000;
 31659 00004D77 2EA2[1386]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 31660 00004D7B 2EF606[1986]01          	test	byte [cs:$P_Flags2],$P_equ
 31661                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 31662 00004D81 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 31663                                  
 31664 00004D83 2E800E[1986]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 31665                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 31666                                  $P_No_Set_Extra:			;AN027;
 31667 00004D89 38C0                    	cmp	al,al			;AN000; set ZF
 31668 00004D8B EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31669                                  
 31670                                  ;***********************************************************************
 31671                                  ; $P_Chk_Switch;
 31672                                  ;
 31673                                  ; Function: Check if AL is the switch character not in first position of
 31674                                  ;	    $P_STRING_BUF
 31675                                  ;
 31676                                  ; Input:    AL = character code
 31677                                  ;	    BX = current pointer within $P_String_Buf
 31678                                  ;	    SI =>next char on command line (following the one in AL)
 31679                                  ;
 31680                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 31681                                  ;		 position, and has no chance of being part of a date string,
 31682                                  ;		 i.e. should be treated as a delimiter.
 31683                                  ;
 31684                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 31685                                  ;		 position, or is a slash but may be part of a date string, i.e.
 31686                                  ;		 should not be treated as a delimiter.
 31687                                  ;
 31688                                  ; Vars:  $P_Terminator(W)
 31689                                  ;
 31690                                  ; Use:	 $P_0099
 31691                                  ;***********************************************************************
 31692                                  
 31693                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31694                                  
 31695                                  $P_Chk_Switch:
 31696                                  	; 18/04/2023
 31697 00004D8D 8D2E[2286]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 31698                                  
 31699 00004D91 39EB                    	cmp	bx,bp			;AN000;
 31700 00004D93 7418                    	je	short $P_STRUC_L2	;AN000;
 31701                                  
 31702 00004D95 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31703 00004D97 7512                    	jne	short $P_STRUC_L5	;AN000;
 31704                                  
 31705 00004D99 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 31706 00004D9A 50                      	push	ax			;AN020;save input char
 31707 00004D9B 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 31708 00004D9F E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 31709 00004DA2 7205                    	jc	short $P_STRUC_L7	;AN000;
 31710                                  
 31711 00004DA4 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 31712 00004DA6 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 31713                                  $P_STRUC_L7:				;AN000;
 31714 00004DA9 58                      	pop	ax			;AN020;restore AL to input char
 31715                                  	;jmp	short $P_STRUC_L1	;AN000;
 31716                                  	; 18/04/2023
 31717 00004DAA C3                      	retn
 31718                                  
 31719                                  $P_STRUC_L5:				;AN000;
 31720 00004DAB F8                      	clc				;AN020;not a slash
 31721                                  	;jmp	short $P_STRUC_L1	;AN000;
 31722                                  	 ;18/04/2023
 31723 00004DAC C3                      	retn
 31724                                  
 31725                                  $P_STRUC_L2:				;AN000;
 31726 00004DAD 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31727                                  	;jne	short $P_STRUC_L12	;AN000;
 31728                                  	; 18/04/2023
 31729 00004DAF 75FA                    	jne	short $P_STRUC_L5
 31730                                  
 31731 00004DB1 2E800E[1986]40          	or	byte [cs:$P_Flags2],$P_SW
 31732                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 31733                                  	; 18/04/2023
 31734                                  ;$P_STRUC_L12:				;AN000;
 31735                                  	;clc				;AN020;CF=0 indicating first char
 31736                                  $P_STRUC_L1:				;AN000;
 31737 00004DB7 C3                      	retn				;AN000;
 31738                                  
 31739                                  ;**************************************************************************
 31740                                  ; $P_Chk_DBCS:
 31741                                  ;
 31742                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 31743                                  ;
 31744                                  ;  Input:
 31745                                  ;	  AL	= Code to be examineed
 31746                                  ;
 31747                                  ;  Output:
 31748                                  ;	  If CF is on then a lead byte of DBCS
 31749                                  ;
 31750                                  ; Use: INT 21h w/AH=63
 31751                                  ;
 31752                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 31753                                  ;***************************************************************************
 31754                                  
 31755                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31756                                  
 31757                                  $P_Chk_DBCS:
 31758 00004DB8 1E                      	push	ds			;AN000;
 31759 00004DB9 56                      	push	si			;AN000;
 31760 00004DBA 53                      	push	bx			;AN000; (tm11)
 31761 00004DBB 2E833E[1686]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 31762                                  					;AC034; ALREADY SET ?
 31763 00004DC1 7527                    	jne	short $P_DBCS00		;AN000;
 31764 00004DC3 50                      	push	ax			;AN000;
 31765 00004DC4 1E                      	push	ds			;AN000; (tm11)
 31766 00004DC5 51                      	push	cx			;AN000;
 31767 00004DC6 52                      	push	dx			;AN000;
 31768 00004DC7 57                      	push	di			;AN000;
 31769 00004DC8 55                      	push	bp			;AN000;
 31770 00004DC9 06                      	push	es			;AN000;
 31771 00004DCA 31F6                    	xor	si,si			;AN000;
 31772 00004DCC 8EDE                    	mov	ds,si			;AN000;
 31773                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 31774 00004DCE B80063                  	mov	ax,6300h
 31775 00004DD1 CD21                    	int	21h			;AN000;
 31776 00004DD3 8CDB                    	mov	bx,ds			;AN000; (tm11)
 31777 00004DD5 09DB                    	or	bx,bx			;AN000; (tm11)
 31778 00004DD7 07                      	pop	es			;AN000;
 31779 00004DD8 5D                      	pop	bp			;AN000;
 31780 00004DD9 5F                      	pop	di			;AN000;
 31781 00004DDA 5A                      	pop	dx			;AN000;
 31782 00004DDB 59                      	pop	cx			;AN000;
 31783 00004DDC 1F                      	pop	ds			;AN000; (tm11)
 31784 00004DDD 58                      	pop	ax			;AN000;
 31785 00004DDE 7429                    	jz	short $P_NON_DBCS	;AN000;
 31786                                  $P_DBCS02:				;AN000;
 31787 00004DE0 2E8936[1486]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 31788 00004DE5 2E891E[1686]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 31789                                  $P_DBCS00:				;AN000;
 31790 00004DEA 2E8B36[1486]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 31791 00004DEF 2E8E1E[1686]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 31792                                  $P_DBCS_LOOP:				;AN000;
 31793 00004DF4 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 31794 00004DF7 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 31795 00004DF9 3A04                    	cmp	al,[si] 		;AN000;
 31796 00004DFB 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 31797 00004DFD 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 31798 00004E00 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 31799 00004E02 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 31800 00004E03 EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 31801                                  $P_DBCS01:				;AN000;
 31802 00004E05 46                      	inc	si			;AC035; add '2' to
 31803 00004E06 46                      	inc	si			;AC035;  SI reg
 31804                                  					;AN000; get next vector
 31805 00004E07 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 31806                                  
 31807                                  $P_NON_DBCS:				;AN000;
 31808                                  	; 18/04/2023
 31809                                  	; cf=0
 31810                                  	;clc				;AN000; indicate SBCS
 31811                                  $P_DBCS_EXIT:				;AN000;
 31812 00004E09 5B                      	pop	bx			;AN000; (tm11)
 31813 00004E0A 5E                      	pop	si			;AN000;
 31814 00004E0B 1F                      	pop	ds			;AN000;
 31815 00004E0C C3                      	retn				;AN000;
 31816                                  
 31817                                  ;============================================================================
 31818                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 31819                                  ;============================================================================
 31820                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31821                                  
 31822                                  ; ****************************************************************
 31823                                  ; *
 31824                                  ; * ROUTINE:	 CMD_PARSE
 31825                                  ; *
 31826                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 31827                                  ; *		 SYSPARSE.
 31828                                  ; *
 31829                                  ; * INPUT:	 inputs to SYSPARSE
 31830                                  ; *
 31831                                  ; * OUTPUT:	 outputs from SYSPARSE
 31832                                  ; *
 31833                                  ; ****************************************************************
 31834                                  
 31835                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31836                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 31837                                  ;cmd_parse:
 31838                                  	;call	sysparse		;AN000;
 31839                                  	;retn				;AN000;
 31840                                  	; 06/04/2023
 31841                                  	;jmp	sysparse
 31842                                  
 31843                                  append_parse:
 31844 00004E0D E840F5                  	call	sysparse		;AN010;
 31845 00004E10 CB                      	retf				;AN010;
 31846                                  
 31847                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31848                                  %if 0
 31849                                  
 31850                                  ;============================================================================
 31851                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 31852                                  ;============================================================================
 31853                                  ; 30/09/2018 - Retro DOS v3.0
 31854                                  
 31855                                  ; BREAK	<Message Printing Routine>
 31856                                  
 31857                                  ;
 31858                                  ;	MSDOS V3.00 PRINT
 31859                                  ;
 31860                                  ;	Message Printing Routine
 31861                                  ;
 31862                                  
 31863                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 31864                                  ;
 31865                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 31866                                  ;
 31867                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 31868                                  ;
 31869                                  ; Characters are output to PFHandle according to the
 31870                                  ; specifications contained in the Control String.
 31871                                  ;
 31872                                  ; The conversion characters are as follow:
 31873                                  ;
 31874                                  ;               %c - output the next argument as a character
 31875                                  ;               %s - output the next argument as a string
 31876                                  ;               %x - output the next argument as a hexidecimal number
 31877                                  ;                    using abcedf
 31878                                  ;               %X - output the next argument as a hexidecimal number
 31879                                  ;                    using ABCDEF
 31880                                  ;               %d - output the next argument as a decimal number
 31881                                  ;
 31882                                  ;
 31883                                  ; Other format specifiers that may precede the conversion character are:
 31884                                  ;
 31885                                  ;               - (minus sign) - causes the field to be left-adjusted
 31886                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 31887                                  ;               n - digit specifing the minimum field width (default to 1)
 31888                                  ;               L - specifing a long integer
 31889                                  ;
 31890                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 31891                                  ;   to an argument list.
 31892                                  ;
 31893                                  ;   ____________________
 31894                                  ;   |   Ret Addr       |      <= SP
 31895                                  ;   --------------------
 31896                                  ;   |  Ptr to Arg List |
 31897                                  ;   --------------------
 31898                                  ;
 31899                                  ;   And the argument list contains the following:
 31900                                  ;
 31901                                  ;       String_ptr                  (a pointer to the control string)
 31902                                  ;       Arg 1
 31903                                  ;       Arg 2
 31904                                  ;         .
 31905                                  ;         .
 31906                                  ;         .
 31907                                  ;       Arg n-1
 31908                                  ;       Arg n
 31909                                  ;
 31910                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 31911                                  ;   or character.
 31912                                  ;
 31913                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 31914                                  
 31915                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 31916                                  
 31917                                  ; =============== S U B	R O U T	I N E =======================================
 31918                                  
 31919                                  PRINTF_INIT:
 31920                                  	call	STD_PRINTF
 31921                                  	retf
 31922                                  
 31923                                  ; =============== S U B	R O U T	I N E =======================================
 31924                                  
 31925                                  PRINTF_CRLF:
 31926                                  	call	STD_PRINTF
 31927                                  	;call	CRLF2
 31928                                  	;retn
 31929                                  	; 07/04/2023
 31930                                  	jmp	CRLF2
 31931                                  
 31932                                  ; =============== S U B	R O U T	I N E =======================================
 31933                                  
 31934                                  STD_EPRINTF:
 31935                                  	mov	word [cs:PRINTF_HANDLE],2
 31936                                  	jmp	short new_printf
 31937                                  
 31938                                  ; =============== S U B	R O U T	I N E =======================================
 31939                                  
 31940                                  STD_PRINTF:
 31941                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 31942                                  
 31943                                  	mov	word [cs:PRINTF_HANDLE],1
 31944                                  NEW_PRINTF:				;Save the callers' registers
 31945                                  	cld
 31946                                  	push	dx
 31947                                  	push	bp
 31948                                  	mov	bp,sp
 31949                                  	push	cx
 31950                                  	push	bx
 31951                                  	push	ax
 31952                                  	push	di
 31953                                  	push	si
 31954                                  	push	es
 31955                                  	push	ds
 31956                                  	push	cs
 31957                                  	pop	es		;ES points to Printf segment
 31958                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 31959                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 31960                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 31961                                  	mov	si,[ds:bp] ; bp
 31962                                  	add	bp,2
 31963                                  	xor	bx,bx
 31964                                  	call	CLEAR_FLAGS	; initialize the world
 31965                                  
 31966                                  GET_CHAR:
 31967                                  	lodsb			;Get a character
 31968                                  	cmp	al,'%'		;Is it a conversion specifier?
 31969                                  	jz	short CONV_CHAR	;Yes - find out which one
 31970                                  	or	al,al		;Is it the end of the control string?
 31971                                  	jz	short PRINTF_DONE ;Yes - then we're done
 31972                                  PRINTF_PERCENT:				
 31973                                  	call	OUTCHR		;Otherwise store the character
 31974                                  	jmp	short GET_CHAR	;And go get another
 31975                                  
 31976                                  PRINTF_DONE:
 31977                                  	call	FLUSH
 31978                                  	pop	ds
 31979                                  	pop	es
 31980                                  	pop	si
 31981                                  	pop	di
 31982                                  	pop	ax
 31983                                  	pop	bx
 31984                                  	pop	cx
 31985                                  	pop	bp
 31986                                  	pop	dx
 31987                                  	retn
 31988                                  
 31989                                  CONV_CHAR:
 31990                                  	mov	byte [cs:PRINTF_LEFT],0
 31991                                  
 31992                                  NXT_CONV_CHAR:	
 31993                                  	;Look for any format specifiers preceeding the conversion character
 31994                                  	lodsb
 31995                                  	cmp	al,'%'			;Just print the %
 31996                                  	jz	short PRINTF_PERCENT
 31997                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 31998                                  	jz	short LEFT_ADJ
 31999                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 32000                                  	jz	short CONV_CHAR
 32001                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 32002                                  	jz	short LONG_INT
 32003                                  	cmp	al,[cs:char_l]	 ; "l"		
 32004                                  	jz	short LONG_INT
 32005                                  	cmp	al,'0'			;Is it a precision specification
 32006                                  	jb	short LOOK_CONV_CHAR
 32007                                  	cmp	al,'9'
 32008                                  	ja	short LOOK_CONV_CHAR
 32009                                  	cmp	al,'0'
 32010                                  	jnz	short NOT_PAD
 32011                                  	cmp	word [cs:PRINTF_WIDTH],0
 32012                                  	jnz	short NOT_PAD
 32013                                  	mov	ah,'0'
 32014                                  	mov	[cs:PAD_CHAR],ah
 32015                                  NOT_PAD:					;Adjust decimal place on precision
 32016                                  	push	ax
 32017                                  	mov	ax,[cs:PRINTF_WIDTH]
 32018                                  	mov	cx,10
 32019                                  	mul	cx
 32020                                  	pop	dx
 32021                                  	xor	dh,dh
 32022                                  	sub	dl,'0'
 32023                                  	add	ax,dx
 32024                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 32025                                  	jmp	short NXT_CONV_CHAR
 32026                                  
 32027                                  LEFT_ADJ:
 32028                                  	mov	byte [cs:PRINTF_LEFT],1
 32029                                  	jmp	short NXT_CONV_CHAR
 32030                                  
 32031                                  LONG_INT:
 32032                                  	or	byte [cs:PRINTF_LONG],1
 32033                                  	jmp	short NXT_CONV_CHAR
 32034                                  
 32035                                  LOOK_CONV_CHAR:
 32036                                  	and	al,0DFh
 32037                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 32038                                  	jz	short HEX_UP
 32039                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 32040                                  	jz	short DECIMAL
 32041                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 32042                                  	jz	short C_PUT_CHAR
 32043                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 32044                                  	jz	short S_PUT_STRG
 32045                                  	call	CLEAR_FLAGS
 32046                                  	jmp	GET_CHAR
 32047                                  
 32048                                  HEX_UP:
 32049                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 32050                                  	jmp	short CONV_TO_NUM
 32051                                  DECIMAL:
 32052                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 32053                                  	jmp	short CONV_TO_NUM
 32054                                  
 32055                                  C_PUT_CHAR:
 32056                                  	call	NEXT_CHRS
 32057                                  	mov	al,dl
 32058                                  	call	OUTCHR
 32059                                  	call	CLEAR_FLAGS
 32060                                  	jmp	GET_CHAR
 32061                                  
 32062                                  S_PUT_STRG:
 32063                                  	push	si			;Save pointer to control string
 32064                                  	call	NEXT_CHRS
 32065                                  	mov	si,dx
 32066                                  S_PUT_1:
 32067                                  	mov	cx,[cs:PRINTF_WIDTH]
 32068                                  	or	cx,cx
 32069                                  	jz	short S_PUT_2
 32070                                  	cmp	byte [cs:PRINTF_LEFT],0
 32071                                  	jnz	short S_PUT_2
 32072                                  	call	PAD_STRING
 32073                                  S_PUT_2:
 32074                                  	push	si
 32075                                  S_PUT_3:
 32076                                  	lodsb
 32077                                  	or	al,al
 32078                                  	jz	short S_PUT_4
 32079                                  	call	OUTCHR			;Put it into our buffer
 32080                                  	jmp	short S_PUT_3
 32081                                  S_PUT_4:
 32082                                  	pop	si
 32083                                  	cmp	byte [cs:PRINTF_LEFT],0
 32084                                  	jz	short C_S_END
 32085                                  	mov	cx,[cs:PRINTF_WIDTH]
 32086                                  	or	cx,cx
 32087                                  	jz	short C_S_END
 32088                                  	call	PAD_STRING
 32089                                  C_S_END:
 32090                                  	pop	si			;Restore control string pointer
 32091                                  	call	CLEAR_FLAGS
 32092                                  	jmp	GET_CHAR		;Go get another character	
 32093                                  
 32094                                  
 32095                                  ; =============== S U B	R O U T	I N E =======================================
 32096                                  
 32097                                  PAD_STRING:
 32098                                  	xor	dx,dx
 32099                                  	push	si
 32100                                  
 32101                                  COUNT_LOOP:
 32102                                  	lodsb
 32103                                  	or	al,al
 32104                                  	jz	short COUNT_DONE
 32105                                  	inc	dx
 32106                                  	jmp	short COUNT_LOOP
 32107                                  
 32108                                  COUNT_DONE:
 32109                                  	pop	si
 32110                                  	sub	cx,dx
 32111                                  	jbe	short COUNT_RET
 32112                                  	call	PAD
 32113                                  
 32114                                  COUNT_RET:
 32115                                  	retn
 32116                                  
 32117                                  ; ---------------------------------------------------------------------------
 32118                                  
 32119                                  CONV_TO_NUM:
 32120                                  	call	NEXT_CHRS
 32121                                  	mov	ax,dx
 32122                                  	xor	dx,dx
 32123                                  	cmp	byte [cs:PRINTF_LONG],0 
 32124                                  			;Is this is a short or long integer?
 32125                                  	jz	short NOT_LONG_INT
 32126                                  	call	NEXT_CHRS
 32127                                  
 32128                                  NOT_LONG_INT:
 32129                                  	push	bx
 32130                                  	push	si
 32131                                  	mov	si,[cs:PRINTF_BASE]
 32132                                  	mov	cx,[cs:PRINTF_WIDTH]
 32133                                  	call	PNUM
 32134                                  	pop	si
 32135                                  	pop	bx
 32136                                  	call	PAD
 32137                                  	call	CLEAR_FLAGS
 32138                                  	jmp	GET_CHAR
 32139                                  
 32140                                  
 32141                                  ; =============== S U B	R O U T	I N E =======================================
 32142                                  
 32143                                  PNUM:
 32144                                  	dec	cx
 32145                                  	push	ax
 32146                                  	mov	ax,dx
 32147                                  	xor	dx,dx
 32148                                  	div	si
 32149                                  	mov	bx,ax
 32150                                  	pop	ax
 32151                                  	div	si
 32152                                  	xchg	bx,dx
 32153                                  	push	ax
 32154                                  	or	ax,dx
 32155                                  	pop	ax
 32156                                  	jz	short DO_PAD
 32157                                  	push	bx
 32158                                  	call	PNUM
 32159                                  	pop	bx
 32160                                  	jmp	short REM
 32161                                  
 32162                                  DO_PAD:
 32163                                  	cmp	byte [cs:PRINTF_LEFT],0
 32164                                  	jnz	short REM
 32165                                  	call	PAD
 32166                                  REM:
 32167                                  	cmp	bl,10
 32168                                  	jb	short NOT_HEX
 32169                                  	add	bx,6
 32170                                  NOT_HEX:
 32171                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32172                                  	push	cx
 32173                                  	call	OUTCHR
 32174                                  	pop	cx
 32175                                  	retn
 32176                                  
 32177                                  ; =============== S U B	R O U T	I N E =======================================
 32178                                  
 32179                                  PAD:
 32180                                  	or	cx,cx
 32181                                  	jle	short PAD_DONE
 32182                                  	mov	al,[cs:PAD_CHAR]
 32183                                  PAD_LOOP:
 32184                                  	push	cx
 32185                                  	call	OUTCHR
 32186                                  	pop	cx
 32187                                  	loop	PAD_LOOP
 32188                                  PAD_DONE:
 32189                                  	retn
 32190                                  
 32191                                  ; =============== S U B	R O U T	I N E =======================================
 32192                                  
 32193                                  OUTCHR:
 32194                                  	stosb
 32195                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32196                                  	je	short FLUSH
 32197                                  OUTCHR_RETN:
 32198                                  	retn
 32199                                  
 32200                                  ; =============== S U B	R O U T	I N E =======================================
 32201                                  
 32202                                  FLUSH:
 32203                                  	mov	cx,PRINTF_BUF
 32204                                  	xchg	cx,di
 32205                                  	sub	cx,di
 32206                                  	jz	short OUTCHR_RETN
 32207                                  WRITE_CHARS:
 32208                                  	push	bx
 32209                                  	mov	bx,[cs:PRINTF_HANDLE]
 32210                                  	push	ds
 32211                                  	push	cs
 32212                                  	pop	ds
 32213                                  	mov	dx,PRINTF_BUF
 32214                                  	mov	ah,Write ; 40h
 32215                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32216                                  				; BX = file handle, CX = number	of bytes to write,
 32217                                  				; DS:DX -> buffer
 32218                                  	jnb	short FOOB2_1
 32219                                  	call	GET_EXT_ERR_NUMBER
 32220                                  	cmp	ax,6
 32221                                  	jz	short FOOB2_4
 32222                                  	jmp	short FOOB2_2
 32223                                  
 32224                                  FOOB2_1:
 32225                                  	cmp	cx,ax
 32226                                  	jz	short FOOB2_4
 32227                                  FOOB2_2:
 32228                                  	mov	bx,dx
 32229                                  	add	bx,ax
 32230                                  	cmp	byte [bx],1Ah
 32231                                  	jz	short FOOB2_4
 32232                                  	pop	ds
 32233                                  	pop	bx
 32234                                  	mov	es,[cs:RESSEG]
 32235                                  	mov	dx,NOSPACEPTR
 32236                                  	test	byte [es:PIPEFLAG],0FFh
 32237                                  	jz	short PRINT_ERR_EXIT
 32238                                  	call	PIPEOFF
 32239                                  	mov	dx,PIPEEMESPTR
 32240                                  PRINT_ERR_EXIT:	
 32241                                  	jmp	CERROR
 32242                                  
 32243                                  FOOB2_4:
 32244                                  	pop	ds
 32245                                  	pop	bx
 32246                                  	retn
 32247                                  
 32248                                  ; =============== S U B	R O U T	I N E =======================================
 32249                                  
 32250                                  NEXT_CHRS:
 32251                                  	push	si		;Save pointer to control string
 32252                                  	mov	si,bx		;Get index into argument list
 32253                                  	add	bx,2		;Increment the index
 32254                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32255                                  	mov	dx,[si]		; Get (address of the) next argument			
 32256                                  	pop	si
 32257                                  	retn
 32258                                  
 32259                                  ; =============== S U B	R O U T	I N E =======================================
 32260                                  
 32261                                  CLEAR_FLAGS:
 32262                                  	xor	ax,ax
 32263                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32264                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32265                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32266                                  	mov	al,' '			
 32267                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32268                                  	retn
 32269                                  
 32270                                  ; ---------------------------------------------------------------------------
 32271                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32272                                  
 32273                                  	; times 7 db 0
 32274                                  
 32275                                  %endif
 32276                                  
 32277                                  ;============================================================================
 32278                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32279                                  ;============================================================================
 32280                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32281                                  
 32282                                  ; ----------------------------
 32283                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32284                                  ; ----------------------------
 32285                                  
 32286                                  ;; Replacable parameters are described by a sublist structure
 32287                                  
 32288                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32289 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32290 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32291 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32292 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32293 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32294 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32295 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32296 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32297                                  endstruc
 32298                                  
 32299                                  ; ---------------------------------------------------------------------------
 32300                                  ; ---------------------------------------------------------------------------
 32301                                  
 32302                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32303                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32304                                  
 32305                                  Printf_Init:
 32306 00004E11 E80F00                  	call	std_printf
 32307 00004E14 CB                      	retf
 32308                                  
 32309                                  Printf_Crlf:
 32310 00004E15 E80B00                  	call	std_printf
 32311                                  	;call	CRLF2
 32312                                  	;retn
 32313                                  	; 07/04/2023
 32314 00004E18 E9BED7                  	jmp	CRLF2
 32315                                  
 32316                                  
 32317                                  ;****************************************************************
 32318                                  ;*
 32319                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32320                                  ;*
 32321                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32322                                  ;*		Set up substitutions if utility message.  Make
 32323                                  ;*		sure any changes to message variables in TDATA
 32324                                  ;*		are reset to avoid reloading the transient.
 32325                                  ;*
 32326                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32327                                  ;*		Msg_Cont_Flag	-  set to control flags
 32328                                  ;*		DS	points to transient segment
 32329                                  ;*
 32330                                  ;*		if utility message:
 32331                                  ;*		DX	points to a block with message number
 32332                                  ;*			(word), number of substitutions (byte),
 32333                                  ;*			followed by substitution list if there
 32334                                  ;*			are substitutions.  If substitutions
 32335                                  ;*			are not in transient segment they must
 32336                                  ;*			be set.
 32337                                  ;*		else
 32338                                  ;*		AX	set to message number
 32339                                  ;*
 32340                                  ;* OUTPUT:	none
 32341                                  ;*
 32342                                  ;****************************************************************
 32343                                  
 32344                                  std_eprintf:
 32345 00004E1B C706[EC87]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32346 00004E21 EB06                    	jmp	short new_printf		;AC000;
 32347                                  
 32348                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32349                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32350                                  
 32351                                  std_printf:
 32352 00004E23 C706[EC87]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32353                                  
 32354                                  new_printf:
 32355 00004E29 50                      	push	ax				;AN000;save registers
 32356 00004E2A 53                      	push	bx				;AN000;
 32357 00004E2B 51                      	push	cx				;AN000;
 32358 00004E2C 06                      	push	es				;AN000;get local ES
 32359 00004E2D 1E                      	push	ds				;AN000;
 32360 00004E2E 07                      	pop	es				;AN000;
 32361 00004E2F 57                      	push	di				;AN000;
 32362 00004E30 56                      	push	si				;AN000;
 32363 00004E31 52                      	push	dx				;AN000;
 32364                                  
 32365                                  	; 07/04/2023
 32366                                  	;mov	word [print_err_flag],0		;AN000;
 32367 00004E32 31C9                    	xor	cx,cx
 32368 00004E34 890E[368E]              	mov	[print_err_flag],cx ; 0
 32369                                  
 32370 00004E38 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32371 00004E3A AD                      	lodsw					;AN000;load message number
 32372 00004E3B 50                      	push	ax				;AN000;save it
 32373 00004E3C AC                      	lodsb					;AN000;get number of substitutions
 32374 00004E3D 88C1                    	mov	cl,al				;AN000;set up CX as # of subst
 32375                                  	; 07/04/2023
 32376                                  	;xor	ch,ch				;AN000;SI now points to subst list
 32377 00004E3F 58                      	pop	ax				;AN000;get message number back
 32378                                  	;cmp	cx,0				;AN000;Any substitutions?
 32379                                  	; 07/04/2023
 32380 00004E40 21C9                    	and	cx,cx
 32381 00004E42 745C                    	jz	short ready_to_print		;AN000;No - continue
 32382                                  
 32383 00004E44 BF[388E]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32384 00004E47 57                      	push	di				;AN061; save it
 32385 00004E48 51                      	push	cx				;AN061; save number of subst
 32386                                  
 32387                                  move_subst:
 32388 00004E49 51                      	push	cx				;AN061;save number of subst
 32389 00004E4A 89F3                    	mov	bx,si				;AN061;save start of sublist
 32390                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32391                                  	; 07/04/2023
 32392 00004E4C B10B                    	mov	cl,parm_block_size ; 11
 32393 00004E4E F3A4                    	rep	movsb				;AN061;move sublist
 32394                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32395 00004E50 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32396                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32397 00004E54 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32398                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32399                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32400 00004E56 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32401                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32402                                  	;mov	word [bx+4],0			;AN061;
 32403 00004E59 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32404                                  
 32405                                  move_subst_cont:				;AN061;
 32406 00004E5C 59                      	pop	cx				;AN061;get number of subst back
 32407 00004E5D E2EA                    	loop	move_subst			;AN061;move cx sublists
 32408                                  
 32409 00004E5F 59                      	pop	cx				;AN061;get number of subst
 32410 00004E60 50                      	push	ax				;AN061;save message number
 32411 00004E61 803E[537F]FF            	cmp	byte [msg_disp_class],util_msg_class
 32412                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32413 00004E66 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32414                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32415 00004E68 C606[328E]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32416 00004E6D BF[557F]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32417 00004E70 31C0                    	xor	ax,ax				;AN061;clear ax register
 32418 00004E72 AB                      	stosw					;AN061;clear out message number
 32419 00004E73 AA                      	stosb					;AN061;clear out subst count
 32420                                  
 32421                                  check_fix:					;AN061;
 32422 00004E74 58                      	pop	ax				;AN061;get message number back
 32423 00004E75 5F                      	pop	di				;AN061;get start of sublists
 32424 00004E76 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32425 00004E78 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32426 00004E7A 51                      	push	cx				;AN061;save number of subst
 32427                                  
 32428                                  set_subst:					;AN061;store the segment of the subst
 32429 00004E7B 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32430                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32431 00004E7F 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32432 00004E81 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32433                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32434                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32435 00004E85 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32436 00004E87 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32437                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32438                                  
 32439                                  subst_seg_set:					;AN061;
 32440 00004E8A 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32441 00004E8D E2EC                    	loop	set_subst			;AN061;loop CX times
 32442 00004E8F 59                      	pop	cx				;AN061;get number of subst back
 32443                                  
 32444 00004E90 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32445 00004E92 817F02[B08C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32446                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32447 00004E97 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32448                                  	; 01/05/2023
 32449 00004E99 8B16[B08C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32450 00004E9D 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32451                                  						;AN061;put it into the subst block
 32452                                  	;mov	[bx+2],dx
 32453                                  
 32454                                  ready_to_print:
 32455 00004EA0 8B1E[EC87]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32456 00004EA4 8A16[547F]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32457 00004EA8 8A36[537F]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32458 00004EAC C606[547F]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32459                                  						;AN061;reset flags to avoid
 32460 00004EB1 C606[537F]FF            	mov	byte [msg_disp_class],util_msg_class
 32461                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32462                                  
 32463 00004EB6 1E                      	push	ds				;AN026;
 32464 00004EB7 06                      	push	es				;AN026;
 32465                                  
 32466 00004EB8 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32467                                  
 32468 00004EBB 07                      	pop	es				;AN026; restore registers
 32469 00004EBC 1F                      	pop	ds				;AN026;
 32470                                  
 32471 00004EBD 7303                    	jnc	short print_success		;AN000; everything went okay
 32472 00004EBF A3[368E]                	mov	[print_err_flag],ax		;AN000;
 32473                                  
 32474                                  print_success:
 32475 00004EC2 5A                      	pop	dx				;AN061;restore dx
 32476 00004EC3 5E                      	pop	si				;AN000;restore registers
 32477 00004EC4 5F                      	pop	di				;AN000;
 32478 00004EC5 07                      	pop	es				;AN000;restore registers
 32479 00004EC6 59                      	pop	cx				;AN000;
 32480 00004EC7 5B                      	pop	bx				;AN000;
 32481 00004EC8 58                      	pop	ax				;AN000;
 32482 00004EC9 833E[368E]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32483 00004ECE 7501                    	jnz	short print_err			;AN000;
 32484                                  
 32485 00004ED0 C3                      	retn					;AC000;
 32486                                  
 32487                                  print_err:
 32488 00004ED1 0E                      	push	cs
 32489 00004ED2 07                      	pop	es
 32490 00004ED3 833E[EC87]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32491 00004ED8 7503                    	jne	short not_stderr		;AN026;no - continue
 32492 00004EDA E927B2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32493                                  
 32494                                  not_stderr:
 32495 00004EDD A1[368E]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32496 00004EE0 8E06[C08A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32497                                  						;  right error msg, and jmp to cerror.
 32498 00004EE4 26F606[1802]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32499 00004EEA 7408                    	jz	short _go_to_error
 32500 00004EEC E896E0                  	call	PipeOff
 32501 00004EEF BA[B680]                	mov	dx,PIPEEMES_PTR
 32502 00004EF2 EB0B                    	jmp	short print_err_exit			;AC000;
 32503                                  
 32504                                  _go_to_error:
 32505 00004EF4 C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class
 32506                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32507 00004EF9 BA[557F]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32508 00004EFC A3[557F]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32509                                  
 32510                                  print_err_exit: 				;AC000;
 32511 00004EFF 0E                      	push	cs
 32512 00004F00 07                      	pop	es
 32513 00004F01 E956DA                  	jmp	cerror
 32514                                  
 32515                                  ;****************************************************************
 32516                                  ;*
 32517                                  ;* ROUTINE:	TSYSLOADMSG
 32518                                  ;*
 32519                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32520                                  ;*		names since these routines are also used in the
 32521                                  ;*		resident.
 32522                                  ;*
 32523                                  ;* INPUT:	Inputs to SYSLOADMSG
 32524                                  ;*
 32525                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32526                                  ;*
 32527                                  ;****************************************************************
 32528                                  
 32529                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32530                                  TSYSLOADMSG:
 32531 00004F04 53                      	push	bx				;AN000;
 32532 00004F05 E80800                  	call	SYSLOADMSG			;AN000; call routine
 32533 00004F08 5B                      	pop	bx				;AN000;
 32534 00004F09 C3                      	retn					;AN000; exit
 32535                                  
 32536                                  ;****************************************************************
 32537                                  ;*
 32538                                  ;* ROUTINE:	TSYSGETMSG
 32539                                  ;*
 32540                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32541                                  ;*		names since these routines are also used in the
 32542                                  ;*		resident.
 32543                                  ;*
 32544                                  ;* INPUT:	Inputs to SYSGETMSG
 32545                                  ;*
 32546                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32547                                  ;*
 32548                                  ;****************************************************************
 32549                                  
 32550                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32551                                  TSYSGETMSG:
 32552 00004F0A 51                      	push	cx				;AN000;
 32553 00004F0B E8B500                  	call	SYSGETMSG			;AN000; call routine
 32554 00004F0E 59                      	pop	cx				;AN000;
 32555 00004F0F C3                      	retn					;AN000; exit
 32556                                  
 32557                                  ;============================================================================
 32558                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 32559                                  ;============================================================================
 32560                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32561                                  
 32562                                  ; ---------------------------------------------------------------------------
 32563                                  ; MODULE NAME: MSGSERV.SAL
 32564                                  ;
 32565                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 32566                                  ;
 32567                                  ; FUNCTION: This module incorporates all the messages services and
 32568                                  ;	    is called upon at build time to INCLUDE the code requested
 32569                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 32570                                  ;
 32571                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 32572                                  ;	    requested procedure.
 32573                                  ;
 32574                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 32575                                  ;	    function requested.
 32576                                  ;
 32577                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 32578                                  ;
 32579                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 32580                                  ;
 32581                                  ; INTERNAL REFERENCES: (list of included subroutines)
 32582                                  ;
 32583                                  ;	- SYSLOADMSG
 32584                                  ;	- SYSDISPMSG
 32585                                  ;	- SYSGETMSG
 32586                                  ;
 32587                                  ; EXTERNAL REFERENCES: None
 32588                                  ;
 32589                                  ; NOTES: At build time, some modules must be included. These are only included
 32590                                  ;	 once using assembler switches. Other logic is included at the request
 32591                                  ;	 of the utility.
 32592                                  ;
 32593                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 32594                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 32595                                  ;	 storage and multiple EQUates.
 32596                                  ;
 32597                                  ; REVISION HISTORY: Created MAY 1987
 32598                                  ;
 32599                                  ;     Label: DOS - - Message Retriever
 32600                                  ;	     (c) Copyright 1988 Microsoft
 32601                                  ; ---------------------------------------------------------------------------
 32602                                  
 32603                                  ;	Revision History
 32604                                  ;	================
 32605                                  ;
 32606                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 32607                                  ;				$M_DISPLAY_H_STRING to properly
 32608                                  ;				handle Ctrl-Z being passed
 32609                                  ;
 32610                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 32611                                  ;				these routines are no longer assembled.
 32612                                  ;
 32613                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 32614                                  ;				CR-LF string also gets reinitialized
 32615                                  ;				on every cycle.
 32616                                  ;
 32617                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 32618                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 32619                                  
 32620                                  ; ---------------------------------------------------------------------------
 32621                                  
 32622                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32623                                  
 32624                                  ;;; Replacable parameters are described by a sublist structure
 32625                                  ;
 32626                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 32627                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32628                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32629                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32630                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 32631                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32632                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32633                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32634                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32635                                  ;endstruc
 32636                                  
 32637                                  ;; Each class will be defined by this structure.
 32638                                  
 32639                                  struc $M_CLASS_ID		;;AN000;;
 32640 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 32641 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 32642 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 32643                                   .size:
 32644                                  endstruc
 32645                                  
 32646                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 32647                                  
 32648                                  ;; Each message will be defined by this structure.
 32649                                  
 32650                                  struc $M_ID			;;AN000;;
 32651 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 32652 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 32653                                   .size:	
 32654                                  endstruc
 32655                                  
 32656                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 32657                                  
 32658                                  ; ---------------------------
 32659                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 32660                                  ; ---------------------------
 32661                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 32662                                  
 32663                                  ; --------------------------- 
 32664                                  
 32665                                  ; 07/04/2023
 32666                                  $M_NUM_CLS equ 3
 32667                                  
 32668                                  ;; Resident data area definition of variables
 32669                                  
 32670                                  struc $M_RES_ADDRS			;;AN000;;
 32671 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 32672 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 32673 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 32674 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 32675 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 32676 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 32677 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 32678 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 32679 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 32680 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 32681 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 32682 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 32683 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 32684 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 32685 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 32686 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 32687 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 32688 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 32689 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 32690 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 32691 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 32692 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 32693 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 32694                                   .size:
 32695                                  endstruc				;;AN000;;
 32696                                  
 32697                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 32698                                  
 32699                                  ;; Important fields of the Get Country Information call
 32700                                  
 32701                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 32702 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 32703                                  					;;AN000;; Go past first part of struc
 32704 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 32705 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 32706 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 32707 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 32708 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 32709 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 32710 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 32711 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 32712 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 32713                                  endstruc				;;AN000;;
 32714                                  
 32715                                  ; ---------------------------------------------------------------------------
 32716                                  
 32717                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32718                                  ;;
 32719                                  ;;	PROC NAME: SYSLOADMSG
 32720                                  ;;
 32721                                  ;;	FUNCTION:
 32722                                  ;;	INPUTS:
 32723                                  ;;
 32724                                  ;;	OUTPUTS:
 32725                                  ;;
 32726                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32727                                  
 32728                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32729                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 32730                                  
 32731                                  SYSLOADMSG:
 32732 00004F10 50                      	push	ax				;;AN000;
 32733 00004F11 53                      	push	bx				;;AN000;
 32734 00004F12 52                      	push	dx				;;AN000;
 32735 00004F13 06                      	push	es				;;AN000;
 32736 00004F14 57                      	push	di				;;AN000;
 32737 00004F15 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 32738 00004F17 8EC1                    	mov	es,cx				;;AN000;
 32739 00004F19 31FF                    	xor	di,di				;;AN000;
 32740 00004F1B B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32741 00004F1E B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 32742 00004F20 CD2F                    	int	2Fh				;;AN000;; Private interface
 32743                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32744                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 32745                                  		; Return: ES:DI -> error table
 32746                                  	
 32747 00004F22 8C06[F186]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 32748                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 32749 00004F26 893E[EF86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 32750                                  	;mov	[$M_RT+8],di			;;AN000;;
 32751                                  
 32752 00004F2A B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32753 00004F2D B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 32754 00004F2F CD2F                    	int	2Fh				;;AN000;; Private interface
 32755                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32756                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 32757                                  		; ES:DI -> error table
 32758                                  
 32759 00004F31 8C06[F986]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 32760                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 32761 00004F35 893E[F786]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 32762                                  	;mov	[$M_RT+16],di			;;AN000;;
 32763                                  
 32764 00004F39 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32765 00004F3C B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 32766 00004F3E CD2F                    	int	2Fh				;;AN000;; Private interface
 32767                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32768                                  		; DL = subfunction - get ??? error table
 32769                                  		; ES:DI -> error table
 32770                                  
 32771 00004F40 8C06[0987]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 32772                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 32773 00004F44 893E[0787]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 32774                                  	;mov	[$M_RT+32],di			;;AN000;;
 32775                                  
 32776 00004F48 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32777 00004F4B B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 32778 00004F4D CD2F                    	int	2Fh					     ;;AN001;; Private interface
 32779                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32780                                  		; DL = subfunction - get ??? error table
 32781                                  		; ES:DI -> error table
 32782                                  
 32783 00004F4F 8C06[ED86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 32784                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 32785 00004F53 893E[EB86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 32786                                  	;mov	[$M_RT+4],di			;;AN001;;
 32787                                  
 32788 00004F57 E8D42F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 32789                                  						;;AN000;;
 32790 00004F5A 8C06[E986]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 32791                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 32792 00004F5E 893E[E786]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 32793                                  	;mov	[$M_RT+0],di			;;AN000;;
 32794 00004F62 8C06[0587]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 32795                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 32796 00004F66 893E[0387]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 32797                                  	;mov	[$M_RT+28],di			;;AN000;;
 32798                                  
 32799 00004F6A E8DF2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 32800                                  
 32801 00004F6D 8C06[FD86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 32802                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 32803 00004F71 893E[FB86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 32804                                  	;mov	[$M_RT+20],di			;;AN000;;
 32805                                  
 32806 00004F75 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32807 00004F78 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 32808 00004F7A CD2F                    	int	2Fh				;;AN001;; Private interface
 32809                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32810                                  		; DL = subfunction - get ??? error table
 32811                                  		; ES:DI -> error table
 32812                                  
 32813 00004F7C 8C06[1187]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 32814                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 32815 00004F80 893E[0F87]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 32816                                  	;mov	[$M_RT+40],di			;;AN001;;
 32817                                  
 32818                                  ;M016; M020
 32819                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 32820                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 32821                                  
 32822 00004F84 C706[2A87]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 32823                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 32824 00004F8A C606[7387]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 32825                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 32826 00004F8F C706[2F87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 32827                                  	;mov	word [$M_RT+72],0		; M020
 32828 00004F95 C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 32829                                  	;mov	word [$M_RT+74],10		; M020
 32830                                  
 32831                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 32832                                  	; --------------------------
 32833                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 32834                                  	; --------------------------
 32835                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 32836                                  
 32837                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 32838 00004F9B E8312F                  	call    $M_CLS_3			; Get addressibility to class F
 32839 00004F9E 893E[1387]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 32840                                  	;mov	[$M_RT+44],di
 32841                                  	
 32842 00004FA2 E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 32843                                  
 32844                                  	; 15/04/2023
 32845                                  	;clc					;;AN000;; Make sure carry is clear
 32846                                  	;jc	short $MIF20
 32847                                  	
 32848 00004FA5 5F                      	pop	di				;;AN000;; Restore REGS
 32849 00004FA6 07                      	pop	es				;;AN000;;
 32850 00004FA7 5A                      	pop	dx				;;AN000;;
 32851 00004FA8 5B                      	pop	bx				;;AN000;;
 32852 00004FA9 58                      	pop	ax				;;AN000;;
 32853                                  	;jmp	short $MEN20
 32854                                  	; 15/04/2023
 32855 00004FAA C3                      	retn
 32856                                  
 32857                                  	; 15/04/2023
 32858                                  ;$MIF20:
 32859                                  	;add	sp,10				;;AN000;;
 32860                                  	;stc					;;AN000;; Reset carry flag
 32861                                  ;$MEN20:
 32862                                  	;retn					;;AN000;;
 32863                                  
 32864                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32865                                  ;;
 32866                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 32867                                  ;;
 32868                                  ;;  Function:	Get the DBCS vector and save it for later use
 32869                                  ;;
 32870                                  ;;  Inputs:	None
 32871                                  ;;
 32872                                  ;;  Outputs:	None
 32873                                  ;;
 32874                                  ;;  Regs Changed:
 32875                                  ;;
 32876                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32877                                  
 32878                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32879                                  
 32880                                  $M_GET_DBCS_VEC:
 32881 00004FAB 50                      	push	ax				;;AN000;; Save character to check
 32882 00004FAC 56                      	push	si				;;AN000;;
 32883 00004FAD 1E                      	push	ds				;;AN000;;
 32884 00004FAE B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 32885 00004FB1 CD21                    	int	21h				;;AN000;; Get environment pointer
 32886 00004FB3 1E                      	push	ds				;;AN000;; Get environment pointer
 32887 00004FB4 07                      	pop	es				;;AN000;; Get environment pointer
 32888 00004FB5 1F                      	pop	ds				;;AN000;; Get environment pointer
 32889 00004FB6 7208                    	jc	short $MIF23
 32890                                  	
 32891 00004FB8 8936[2387]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 32892                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 32893 00004FBC 8C06[2587]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 32894                                  	;mov	word [$M_RT+62],es		;;AN000;;
 32895                                  $MIF23:
 32896 00004FC0 5E                      	pop	si				;;AN000;;
 32897 00004FC1 58                      	pop	ax				;;AN000;; Retrieve character to check
 32898 00004FC2 C3                      	retn					;;AN000;; Return
 32899                                  
 32900                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32901                                  ;;
 32902                                  ;;  Proc Name:	SYSGETMSG
 32903                                  ;;
 32904                                  ;;  Function:	The GET service returns the segment, offset and size of the
 32905                                  ;;		message text to the caller based on a message number.
 32906                                  ;;		The GET function will not display the message thus assumes
 32907                                  ;;		caller will handle replaceable parameters.
 32908                                  ;;
 32909                                  ;;  Inputs:
 32910                                  ;;
 32911                                  ;;  Outputs:
 32912                                  ;;
 32913                                  ;;  Psuedocode:
 32914                                  ;;		Call $M_GET_MSG_ADDRESS
 32915                                  ;;		IF MSG_NUM exists THEN
 32916                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 32917                                  ;;		   CARRY_FLAG = 0
 32918                                  ;;		ELSE
 32919                                  ;;		   CARRY_FLAG = 1
 32920                                  ;;		ENDIF
 32921                                  ;;
 32922                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32923                                  
 32924                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32925                                  
 32926                                  	utility_msg_class equ 0FFh ; 18/04/2023
 32927                                  
 32928                                  SYSGETMSG:
 32929                                  	;; Save registers needed later
 32930 00004FC3 50                      	push	ax				;;AN000;; Save changed regs
 32931 00004FC4 06                      	push	es				;;AN000;;
 32932 00004FC5 57                      	push	di				;;AN000;;
 32933 00004FC6 55                      	push	bp				;;AN000;;
 32934                                  
 32935 00004FC7 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 32936 00004FCA 720D                    	jc	short $MIF31
 32937                                  	
 32938 00004FCC 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 32939 00004FCF F8                      	clc					;;AN000;;
 32940 00004FD0 7403                    	je	short $MIF32			;;AN000;;
 32941                                  
 32942 00004FD2 06                      	push	es				;;AN000;;
 32943                                  	;pop	ds				;;AN000;;
 32944 00004FD3 EB01                    	jmp	short $MEN32
 32945                                  $MIF32:
 32946 00004FD5 0E                      	push	cs				;;AN000;;			
 32947                                  	;pop	ds				;;AN000;;
 32948                                  $MEN32:
 32949                                  	; 07/04/2023
 32950 00004FD6 1F                      	pop	ds
 32951 00004FD7 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 32952                                  $MIF31:
 32953 00004FD9 5D                      	pop	bp				;;AN000;; Restore changed regs
 32954 00004FDA 5F                      	pop	di				;;AN000;;
 32955 00004FDB 07                      	pop	es				;;AN000;;
 32956 00004FDC 58                      	pop	ax				;;AN000;;
 32957 00004FDD C3                      	retn					;;AN000;; Return
 32958                                  
 32959                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32960                                  ;;
 32961                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 32962                                  ;;
 32963                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 32964                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 32965                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 32966                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 32967                                  ;;	REGS CHANGED: ES,DI,CX
 32968                                  ;;
 32969                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32970                                  
 32971                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32972                                  
 32973                                  $M_GET_MSG_ADDRESS:
 32974 00004FDE 56                      	push	si				;;AN000;;
 32975 00004FDF 53                      	push	bx				;;AN000;;
 32976 00004FE0 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 32977 00004FE2 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 32978                                  $MDO36:
 32979 00004FE4 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 32980 00004FE7 7508                    	jne	short $MIF37			;;AN000;; No			
 32981                                  	
 32982                                  	; 07/04/2023
 32983                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32984 00004FE9 8BBC[1387]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 32985                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 32986 00004FED 89FB                    	mov	bx,di				;;AN000;;
 32987 00004FEF EB21                    	jmp	short $MEN37
 32988                                  $MIF37:
 32989 00004FF1 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 32990 00004FF4 7406                    	jz	short $MIF39
 32991                                  	
 32992                                  	; 07/04/2023
 32993                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32994 00004FF6 C4BC[F786]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 32995                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 32996                                  	
 32997                                  	; 07/04/2023
 32998                                  	;mov	bx,es ; *			;;AN000;;
 32999 00004FFA EB14                    	jmp	short $MEN39
 33000                                  $MIF39:
 33001 00004FFC 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33002 00004FFF 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33003                                  
 33004 00005001 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33005 00005004 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33006                                  
 33007                                  	; 07/04/2023
 33008                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33009 00005006 C4BC[0387]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33010                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33011                                  	
 33012                                  	; 07/04/2023
 33013                                  	;mov	bx,es ; *			;;AN000;;
 33014 0000500A EB04                    	jmp	short $MEN41
 33015                                  $MIF41:
 33016                                  	; 07/04/2023
 33017                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33018 0000500C C4BC[E786]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33019                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33020                                  	
 33021                                  	; 07/04/2023
 33022                                  	;mov	bx,es ; *			;;AN000;;
 33023                                  $MEN41:
 33024                                  $MEN39:
 33025                                  	; 07/04/2023
 33026 00005010 8CC3                    	mov	bx,es ; *
 33027                                  $MEN37:						;;AN000;;
 33028 00005012 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33029 00005015 7515                    	jne	short $MIF46			;;AN000;; No
 33030                                  
 33031 00005017 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33032 0000501A 7503                    	jne	short $MIF47			;;AN000;; No
 33033 0000501C F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33034                                  	; 07/04/2023
 33035                                  	;jmp	short $MEN47 ; **-
 33036 0000501D EB1B                    	jmp	short $MEN36 ; **-
 33037                                  $MIF47:
 33038 0000501F A3[2F87]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 33039                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33040 00005022 B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33041 00005025 BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33042 00005028 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33043                                  	; 28/04/2023
 33044                                  	; 07/04/2023
 33045                                  	;clc	; **+				;;AN000;;
 33046                                  ;$MEN47:
 33047                                  	;jmp	short $MEN46 ; ***
 33048 0000502A EB0A                    	jmp	short $MEN47 ; ***
 33049                                  $MIF46:
 33050                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33051 0000502C 21DB                    	and	bx,bx ; 0 ?
 33052 0000502E 7403                    	jz	short $MIF51			;;AN000;; No
 33053                                  	
 33054 00005030 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33055                                  $MIF51:
 33056 00005033 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33057                                  	; 07/04/2023
 33058                                  	;clc					;;AN000;;
 33059                                  ;$MEN46:
 33060                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33061                                  $MEN47:	; 07/04/2023	; **+
 33062 00005036 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33063                                  	;jnz	short $MXL2			;;AN000;; Yes
 33064                                  	;jmp	short $MDO36
 33065                                  	; 07/04/2023
 33066 00005038 74AA                    	jz	short $MDO36	
 33067                                  $MXL2:
 33068                                  $MEN36:
 33069 0000503A 9C                      	pushf 					;;AN006;; Save the flag state
 33070                                  	
 33071 0000503B 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33072                                  	;jne	short $MIF56			;;AN006;; No
 33073                                  	; 28/04/2023
 33074 0000503E 752A                    	jne	short $M_MYRET	
 33075                                  
 33076 00005040 52                      	push	dx				;;AN006;; Save all needed registers
 33077 00005041 55                      	push	bp				;;AN006;;
 33078 00005042 51                      	push	cx				;;AN006;;
 33079 00005043 06                      	push	es				;;AN006;;
 33080 00005044 57                      	push	di				;;AN006;;
 33081 00005045 50                      	push	ax				;;AN006;;
 33082                                  
 33083 00005046 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33084 00005049 CD2F                    	int	2Fh				;;AN006;;
 33085                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33086                                  		; Return: AL = 00h not installed, OK to install
 33087                                  		; 01h not installed, can't install
 33088                                  		; FFh installed
 33089                                  
 33090 0000504B 3CFF                    	cmp	al, 0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33091 0000504D 58                      	pop	ax				;;AN006;; Restore msg number
 33092 0000504E 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33093                                  
 33094 00005050 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33095 00005052 B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33096 00005055 CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33097                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33098                                  
 33099                                  	;jmp	short $MEN57			;;AN006;;
 33100                                  	; 28/04/2023
 33101 00005057 720B                    	jc	short $MEN57
 33102                                  $MIF60:
 33103 00005059 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33104 0000505C E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33105                                  $MEN60:
 33106 0000505F 5D                      	pop	bp				;;AN006;; Restore other Regs
 33107 00005060 5A                      	pop	dx				;;AN006;;
 33108                                  $MIF56:
 33109                                  	; 07/04/2023
 33110                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33111 00005061 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33112                                  
 33113                                  $MIF57:
 33114 00005063 F9                      	stc					;;AN006;; Carry conditon
 33115                                  $MEN57:
 33116                                  	; 28/04/2023
 33117                                  	;jnc	short $MIF60			;;AN006;;
 33118                                  
 33119 00005064 5F                      	pop	di				;;AN006;;
 33120 00005065 07                      	pop	es				;;AN006;; Restore old pointer
 33121 00005066 59                      	pop	cx				;;AN006;;
 33122 00005067 EBF6                    	jmp	short $MEN60
 33123                                  
 33124                                  ;$MIF60:
 33125                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33126                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33127                                  ;$MEN60:
 33128                                  ;	pop	bp				;;AN006;; Restore other Regs
 33129                                  ;	pop	dx				;;AN006;;
 33130                                  ;$MIF56:
 33131                                  ;	; 07/04/2023
 33132                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33133                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33134                                  
 33135                                  ; 07/04/2023
 33136                                  ; ---------------------------
 33137                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33138                                  ; ---------------------------
 33139                                  	; $M_POPF macro
 33140                                  	;jmp	short $+3
 33141                                  m_popf_iret:
 33142 00005069 CF                      	iret
 33143                                  $M_MYRET:
 33144 0000506A 0E                      	push	cs
 33145 0000506B E8FBFF                  	call	m_popf_iret
 33146                                  	;;; end macro	
 33147                                  ; ---------------------------
 33148                                  
 33149 0000506E 5B                      	pop	bx				;;AN000;;
 33150 0000506F 5E                      	pop	si				;;AN000;;
 33151 00005070 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33152                                  
 33153                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33154                                  
 33155                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33156                                  $M_SET_LEN_IN_CX:			
 33157 00005071 57                      	push	di				;;AN006;; Save position
 33158 00005072 50                      	push	ax				;;AN006;;
 33159 00005073 B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33160 00005076 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33161 00005078 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33162 0000507A F7D1                    	not	cx				;;AN006;; Change decrement into number
 33163 0000507C 49                      	dec	cx				;;AN006;; Don't include the zero
 33164 0000507D 58                      	pop	ax				;;AN006;;
 33165 0000507E 5F                      	pop	di				;;AN006;; Restore position
 33166 0000507F C3                      	retn					;;AN006;;
 33167                                  
 33168                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33169                                  ;;
 33170                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33171                                  ;;
 33172                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33173                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33174                                  ;;		   CX contains the number of messages in class
 33175                                  ;;		   DH contains the message class
 33176                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33177                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33178                                  ;;
 33179                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33180                                  
 33181                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33182                                  
 33183                                  $M_FIND_SPECIFIED_MSG:
 33184 00005080 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33185 00005083 751F                    	jne	short $MIF64
 33186 00005085 833E[0F87]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33187                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33188 0000508A 7518                    	jne	short $MIF64
 33189                                  
 33190 0000508C 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33191 0000508F 750B                    	jne	short $MIF65
 33192                                  	
 33193 00005091 50                      	push	ax				;;AN004;; Reset the special message number
 33194 00005092 A1[2F87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33195                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33196 00005095 FF1E[0F87]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33197                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33198 00005099 58                      	pop	ax				;;AN004;; Reset the special message number
 33199                                  	; 28/04/2023
 33200 0000509A EB04                    	jmp	short $MEN65
 33201                                  	; 18/04/2023
 33202                                  	;jmp	short $MEN64
 33203                                  $MIF65:
 33204 0000509C FF1E[0F87]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33205                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33206                                  $MEN65:
 33207                                  	; 28/04/2023
 33208 000050A0 7344                    	jnc	short $MIF75
 33209                                  	;
 33210 000050A2 EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33211                                  $MIF64:
 33212 000050A4 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33213 000050A6 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33214 000050A9 7406                    	je	short $MIF69
 33215                                  	
 33216 000050AB 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33217                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33218 000050AF EB09                    	jmp	short $MEN69
 33219                                  $MIF69:
 33220                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33221                                  	;cmp	[cs:di+0],dh
 33222 000050B1 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33223 000050B4 7504                    	jne	short $MIF71
 33224                                  
 33225 000050B6 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33226                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33227                                  $MIF71:						;;AN001;;
 33228                                  $MEN69:
 33229 000050BA 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33230                                  	; 02/05/2023
 33231                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33232                                  $MEN64:
 33233                                  	;jnc	short $MIF75
 33234                                  	; 28/04/2023
 33235                                  	; (or instruction clears carry flag)
 33236                                  	;clc					;;AN004;; No, reset carry
 33237                                  $MDO76:
 33238 000050BD 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33239 000050BF 7417                    	jz	short $MEN76
 33240                                  
 33241 000050C1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33242 000050C4 7405                    	je	short $MIF78
 33243                                  
 33244                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33245 000050C6 263B05                  	cmp	ax,[es:di]
 33246 000050C9 EB03                    	jmp	short $MEN78
 33247                                  $MIF78:
 33248                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33249 000050CB 2E3B05                  	cmp	ax,[cs:di]
 33250                                  $MEN78:
 33251                                  	;jne	short $MIF76
 33252                                  	;jmp	short $MSR76
 33253                                  	; 07/04/2023
 33254 000050CE 740B                    	je	short $MSR76 ; *
 33255                                  $MIF76:
 33256 000050D0 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33257 000050D1 7405                    	jz	short $MEN76
 33258                                  
 33259 000050D3 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33260 000050D6 EBE5                    	jmp	short $MDO76			;;AN000;;
 33261                                  $MEN76:
 33262 000050D8 F9                      	stc					;;AN000;;
 33263                                  ;$MSR76:	; 07/04/2023
 33264                                  	;jc	short $MIF86			;;AN000;;
 33265                                  	; 07/04/2023
 33266                                  	;jc	short $MIF91
 33267 000050D9 EB11                    	jmp	short $MIF91 ;*
 33268                                  $MSR76:	; 07/04/2023 ; *	
 33269 000050DB 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33270                                  	; 07/04/2023
 33271                                  	;clc					;;AN001;;
 33272 000050DE 7502                    	jne	short $MIF87
 33273                                  
 33274 000050E0 0E                      	push	cs				;;AN000;;
 33275 000050E1 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33276                                  $MIF87:
 33277                                  	;add	di,[es:di+2]
 33278 000050E2 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33279                                  $MIF86:
 33280                                  ;$MIF75:
 33281                                  	; 02/05/2023
 33282                                  	;jc	short $MIF91
 33283                                  $MIF75:	; 28/04/2023
 33284 000050E6 30ED                    	xor	ch,ch				;;AN000;;
 33285 000050E8 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33286 000050EB 47                      	inc	di				;;AN000;; Increment past length
 33287                                  $MIF91:
 33288 000050EC C606[2987]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33289                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33290 000050F1 C3                      	retn					;;AN000;; Return
 33291                                  
 33292                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33293                                  ;;
 33294                                  ;;  Proc Name:	SYSDISPMSG
 33295                                  ;;
 33296                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33297                                  ;;		requested by the caller. It also provides function to display
 33298                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33299                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33300                                  ;;		defined previous to entry.
 33301                                  ;;
 33302                                  ;;		It is assumes that a PRELOAD function has already determined
 33303                                  ;;		the addressibilty internally to the message retriever services.
 33304                                  ;;  Inputs:
 33305                                  ;;
 33306                                  ;;  Outputs:
 33307                                  ;;
 33308                                  ;;  Psuedocode:
 33309                                  ;;		Save registers needed later
 33310                                  ;;		Get address of the message requested
 33311                                  ;;		IF Message number exists THEN
 33312                                  ;;		  IF replacable parameters were specified THEN
 33313                                  ;;		     Display message with replacable parms
 33314                                  ;;		  ELSE
 33315                                  ;;		     Display string without replacable parms
 33316                                  ;;		  ENDIF
 33317                                  ;;		  IF character input was requested THEN
 33318                                  ;;		     Wait for character input
 33319                                  ;;		  ENDIF
 33320                                  ;;		  Clear CARRY FLAG
 33321                                  ;;		ELSE
 33322                                  ;;		   Set CARRY FLAG
 33323                                  ;;		ENDIF
 33324                                  ;;		Return
 33325                                  ;;
 33326                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33327                                  
 33328                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33329                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33330                                  
 33331                                  SYSDISPMSG:
 33332                                  	;; Save registers and values needed later
 33333 000050F2 50                      	push	ax				;;AN000;; Save changed REGs
 33334 000050F3 53                      	push	bx				;;AN000;;
 33335 000050F4 51                      	push	cx				;;AN000;;
 33336 000050F5 55                      	push	bp				;;AN000;;
 33337 000050F6 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33338 000050F7 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33339 000050F8 52                      	push	dx				;;AN000;; Save Input/Class request
 33340                                  
 33341 000050F9 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33342 000050FB 891E[2787]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33343                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33344 000050FF 8836[2C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33345                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33346                                  
 33347                                  	;; Get address of the message requested
 33348 00005103 E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33349 00005106 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33350 00005108 7420                    	jz	short $MIF93
 33351                                  						;;AN000;; Yes, Message address in ES:DI
 33352                                  	
 33353                                  	;; Test if replacable parameters were specified
 33354 0000510A 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33355 0000510C 7505                    	jnz	short $MIF94
 33356                                  
 33357                                  	;; Display string without replacable parms
 33358 0000510E E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33359 00005111 EB03                    	jmp	short $MEN94
 33360                                  $MIF94:
 33361                                  	;; Display message with replacable parms
 33362 00005113 E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33363                                  $MEN94:
 33364 00005116 720D                    	jc	short $MIF97
 33365 00005118 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33366 00005119 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33367 0000511C 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33368 0000511D 5F                      	pop	di				;;AN000;;
 33369                                  	;jmp	short $MEN97 ; ***
 33370                                  	; 08/04/2023
 33371                                  	;jmp	short $MEN93 ; **
 33372                                  
 33373                                  	; 08/04/2023
 33374                                  ;$MEN93:
 33375 0000511E 720D                    	jc	short $MIF104
 33376                                  ;$MEN97:
 33377 00005120 5D                      	pop	bp				;;AN000;;
 33378 00005121 59                      	pop	cx				;;AN000;;
 33379 00005122 5B                      	pop	bx				;;AN000;;
 33380 00005123 58                      	pop	ax				;;AN000;;
 33381 00005124 C3                      	retn
 33382                                   
 33383                                  $MIF97:
 33384                                  	; 08/04/2023
 33385                                  	;add	sp,6				;;AN000;;
 33386                                  	;stc					;;AN000;; Reset carry flag
 33387                                  ;$MEN97: ; ***
 33388                                  	;jmp	short $MEN93
 33389                                  	; 08/04/2023
 33390                                  	;jmp	short $MIF104
 33391                                  	; 08/04/2023
 33392 00005125 83C40E                  	add	sp,14 ; 6+8
 33393 00005128 F9                      	stc
 33394 00005129 C3                      	retn
 33395                                  $MIF93:
 33396                                  	; 08/04/2023
 33397                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33398                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33399 0000512A 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33400 0000512B 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33401 0000512C 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33402                                  	;stc	; * 				;;AN000;; Set carry flag
 33403                                  	; 08/04/2023
 33404                                  	;jmp short $MIF104 ; *
 33405                                  
 33406                                  ;$MEN93: ; **
 33407                                  ;	jc	short $MIF104
 33408                                  ;$MEN97: ; 08/04/2023
 33409                                  ;	pop	bp				;;AN000;;
 33410                                  ;	pop	cx				;;AN000;;
 33411                                  ;	pop	bx				;;AN000;;
 33412                                  ;	pop	ax				;;AN000;;
 33413                                  ;	;jmp	short $MEN104
 33414                                  ;	; 08/04/2023
 33415                                  ;	retn
 33416                                  
 33417                                  $MIF104: ; *
 33418 0000512D 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33419 00005130 F9                      	stc					;;AN000;;
 33420                                  $MEN104:
 33421 00005131 C3                      	retn					;;AN000;; Return
 33422                                  
 33423                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33424                                  ;;
 33425                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33426                                  ;;
 33427                                  ;;	FUNCTION:  Will display or write string
 33428                                  ;;	INPUTS:    ES:DI points to beginning of message
 33429                                  ;;		   CX contains the length of string to write (if applicable)
 33430                                  ;;	OUTPUTS:   None
 33431                                  ;;	REGS Revised: None
 33432                                  ;;
 33433                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33434                                  
 33435                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33436                                  
 33437                                  $M_DISPLAY_STRING:
 33438 00005132 50                      	push	ax				;;AN000;;
 33439 00005133 53                      	push	bx				;;AN000;;
 33440 00005134 52                      	push	dx				;;AN000;;
 33441 00005135 8B1E[2787]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33442                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33443                                  	
 33444 00005139 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33445 0000513C 7505                    	jne	short $MIF107
 33446                                  
 33447 0000513E E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33448 00005141 EB03                    	jmp	short $MEN107
 33449                                  $MIF107:
 33450 00005143 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33451                                  $MEN107:
 33452 00005146 730D                    	jnc	short $MIF110
 33453                                  	
 33454 00005148 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33455                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33456                                  	; 08/04/2023
 33457 0000514A 31DB                    	xor	bx,bx
 33458 0000514C CD21                    	int	21h				;;AN000;;
 33459                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33460                                  		; BX = version code (0000h for DOS 3.x)
 33461 0000514E 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33462                                  $MEN110: ; 08/04/2023 ; ***
 33463 00005150 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33464 00005153 F9                      	stc					;;AN000;; Flag that there was an error
 33465                                  	;jmp	short $MEN110 ; ****
 33466                                  	; 08/04/2023
 33467 00005154 C3                      	retn
 33468                                  $MIF110:
 33469                                  	;cmp	bx,$M_NO_HANDLE
 33470 00005155 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33471 00005158 7409                    	je	short $MIF112 ; *  ; cf = 0
 33472 0000515A 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33473 0000515C 7405                    	je	short $MIF113 ; ** ; cf = 0
 33474 0000515E E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33475                                  	;add	sp,6				;;AN001;; Clean up stack
 33476                                  	;stc					;;AN001;; Flag that there was an error
 33477                                  	; 08/04/2023
 33478 00005161 EBED                    	jmp	short $MEN110 ; ***
 33479                                  	; 08/04/2023
 33480                                  ;$MIF112:
 33481                                  ;$MEN110: ; ****
 33482                                  	;jc	short $MIF117
 33483                                  $MIF112: ; 08/04/2023	; *
 33484                                  $MIF113:	; **
 33485 00005163 5A                      	pop	dx				;;AN000;; Restore regs
 33486 00005164 5B                      	pop	bx				;;AN000;;
 33487 00005165 58                      	pop	ax				;;AN000;;
 33488                                  $MIF117:
 33489 00005166 C3                      	retn
 33490                                  
 33491                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33492                                  ;;
 33493                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33494                                  ;;
 33495                                  ;;	FUNCTION:  Will display a $ terminated string
 33496                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33497                                  ;;	OUTPUTS:   None
 33498                                  ;;	REGS USED: AX,DX
 33499                                  ;;
 33500                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33501                                  
 33502                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33503                                  
 33504                                  $M_DISPLAY_$_STRING:
 33505 00005167 1E                      	push	ds				;;AN000;;
 33506 00005168 06                      	push	es				;;AN000;;
 33507 00005169 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33508                                  
 33509                                  	; 08/04/2023
 33510 0000516A B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33511                                  
 33512                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33513 0000516C 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33514 0000516F 7518                    	jne	short $MIF119			;;AN000;; No
 33515                                  	
 33516                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33517 00005171 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33518 00005174 CD21                    	int	21h				;;AN000;; Write character
 33519                                  		; DOS - DISPLAY OUTPUT
 33520                                  		; DL = character to send to standard output
 33521 00005176 1F                      	pop	ds				;;AN000;;
 33522 00005177 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33523 00005179 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33524 0000517C 1E                      	push	ds				;;AN000;;
 33525 0000517D 06                      	push	es				;;AN000;;
 33526 0000517E 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33527 0000517F 7316                    	jnc	short $MIF120 ; *
 33528                                  
 33529 00005181 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33530 00005185 CD21                    	int	21h				;;AN000;; Write character
 33531                                  		; DOS - DISPLAY OUTPUT
 33532                                  		; DL = character to send to standard output
 33533                                  	; 08/04/2023
 33534                                  	;clc					;;AN000;; Clear the DBCS indicator
 33535                                  ;$MIF120:
 33536 00005187 EB0D                    	jmp	short $MEN119
 33537                                  $MIF119:
 33538                                  	; 08/04/2023
 33539                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33540                                  ;$MDO123:
 33541 00005189 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33542                                  	;jz	short $MEN123
 33543                                  	; 18/04/2023
 33544 0000518B 740A                    	jz	short $MIF120 ; cf = 0
 33545                                  $MDO123: ; 08/04/2023
 33546 0000518D 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 33547 00005190 CD21                    	int	21h				;;AN002;; Display the character
 33548                                  		; DOS - DISPLAY OUTPUT
 33549                                  		; DL = character to send to standard output
 33550 00005192 47                      	inc	di				;;AN002;; Set pointer to next character
 33551 00005193 49                      	dec	cx				;;AN002;; Count this character
 33552 00005194 75F7                    	jnz	short $MDO123
 33553                                  ;$MEN123:
 33554                                  $MEN119:
 33555 00005196 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 33556                                  $MIF120: ; 08/04/2023 ; *
 33557 00005197 1F                      	pop	ds				;;AN000;;
 33558 00005198 C3                      	retn
 33559                                  
 33560                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33561                                  ;;
 33562                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 33563                                  ;; truncates it at the Ctrl-Z if any present.
 33564                                  ;;
 33565                                  ;;	ENTRY:	ds:dx = String to be displayed
 33566                                  ;;		cx = number of chars to be displayed
 33567                                  ;;
 33568                                  ;;	EXIT:	cx = number of chars to be displayed
 33569                                  ;;
 33570                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33571                                  
 33572                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33573                                  scan_ctrlz:
 33574 00005199 57                      	push	di
 33575 0000519A 50                      	push	ax
 33576 0000519B 06                      	push	es
 33577 0000519C 53                      	push	bx
 33578                                  
 33579 0000519D 89D7                    	mov	di,dx
 33580 0000519F 1E                      	push	ds
 33581 000051A0 07                      	pop	es   			;es:di points at string
 33582                                  
 33583 000051A1 89CB                    	mov	bx,cx			;save current count
 33584                                  
 33585 000051A3 B01A                    	mov	al,1Ah	; Ctrl-Z
 33586 000051A5 FC                      	cld
 33587 000051A6 F2AE                    	repne	scasb			;find first Ctrl-Z
 33588 000051A8 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 33589                                  
 33590 000051AA 29CB                    	sub	bx,cx
 33591 000051AC 4B                      	dec	bx			;bx = new count to display
 33592                                  noCtrlZ:
 33593 000051AD 89D9                    	mov	cx,bx			;cx = actual display count
 33594                                  
 33595 000051AF 5B                      	pop	bx
 33596 000051B0 07                      	pop	es
 33597 000051B1 58                      	pop	ax
 33598 000051B2 5F                      	pop	di
 33599                                  $MIF127:	; 08/04/2023
 33600 000051B3 C3                      	retn
 33601                                  
 33602                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33603                                  ;;
 33604                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 33605                                  ;;
 33606                                  ;;	FUNCTION:  Will display a string to a specified handle
 33607                                  ;;	INPUTS:    ES:DI points to beginning of message
 33608                                  ;;		   CX contains the number of bytes to write
 33609                                  ;;		   BX contains the handle to write to
 33610                                  ;;	OUPUTS:    None
 33611                                  ;;	REGS USED: AX,DX
 33612                                  ;;
 33613                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33614                                  
 33615                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33616                                  
 33617                                  $M_DISPLAY_H_STRING:
 33618 000051B4 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 33619 000051B6 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 33620 000051B8 74F9                    	jz	short $MIF127
 33621                                  	
 33622 000051BA 1E                      	push	ds			;;AN000;;
 33623 000051BB 06                      	push	es			;;AN000;;
 33624 000051BC 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33625                                  	
 33626 000051BD B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33627 000051BF 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 33628                                  
 33629 000051C1 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 33630 000051C4 7528                    	jne	short $MIF128		;;AN000;; No
 33631                                  
 33632 000051C6 CD21                    	int	21h			;;AN000;; Write character
 33633                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33634                                  		; BX = file handle, CX = number of bytes to writ
 33635                                  
 33636 000051C8 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33637 000051C9 50                      	push	ax			;;AN000;;
 33638 000051CA 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 33639 000051CD E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 33640 000051D0 58                      	pop	ax			;;AN000;;
 33641 000051D1 1E                      	push	ds			;;AN000;;
 33642 000051D2 06                      	push	es			;;AN000;;
 33643 000051D3 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33644 000051D4 7306                    	jnc	short $MIF129
 33645                                  	
 33646 000051D6 F8                      	clc				;;AN000;; Clear the DBCS indicator
 33647 000051D7 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33648 000051D9 42                      	inc	dx			;;AN000;; Point to next character
 33649 000051DA CD21                    	int	21h			;;AN000;; Write character
 33650                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33651                                  		; BX = file handle, CX = number of bytes to write, 
 33652                                  $MIF129:
 33653                                  ;SR;
 33654                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 33655                                  ;0 chars written making the caller think there was an error writing. To 
 33656                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 33657                                  ;the char was written, thus fooling the caller.
 33658                                  
 33659 000051DC 9C                      	pushf				;save flags
 33660 000051DD 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 33661 000051E1 7502                    	jne	short m_popf_j		;no, continue
 33662                                  
 33663 000051E3 89C8                    	mov	ax,cx			;yes, fake as if it was written
 33664                                  m_popf_j:
 33665                                  	; 08/04/2023
 33666                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33667 000051E5 EB01                    	jmp	short m_popf		;restore flags
 33668                                  
 33669                                  ; 07/04/2023
 33670                                  ; ---------------------------
 33671                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33672                                  ; ---------------------------
 33673                                  	; $M_POPF macro
 33674                                  	;jmp	short $+3
 33675                                  intret:
 33676 000051E7 CF                      	iret
 33677                                  m_popf:
 33678 000051E8 0E                      	push	cs
 33679 000051E9 E8FBFF                  	call	intret
 33680                                  	;;; end macro	
 33681                                  ; ---------------------------
 33682                                  
 33683 000051EC EB18                    	jmp	short $MEN128
 33684                                  
 33685                                  $MIF128:
 33686                                  ;SR;
 33687                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 33688                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 33689                                  
 33690 000051EE 55                      	push	bp			; M007
 33691 000051EF 51                      	push	cx
 33692 000051F0 E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 33693 000051F3 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 33694 000051F5 59                      	pop	cx			;get old count back ;M007
 33695                                  	
 33696 000051F6 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 33697                                  	;jnc	short chk_count		;no error, adjust return count
 33698                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 33699                                  	; 08/04/2023
 33700 000051F8 720B                    	jc	short m_cnt_ok 
 33701                                  ;M007
 33702                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 33703                                  ;return count will be much less and if this returns to the caller we can get
 33704                                  ;spurious error messages. We check here if the count returned is same as
 33705                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 33706                                  ;case, we fake it as if all bytes have been written. If the return count
 33707                                  ;does not match either count, then we had some other disk error (such as
 33708                                  ;insufficient disk space) and we pass it through
 33709                                  
 33710                                  chk_count:
 33711 000051FA 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 33712 000051FC 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 33713 000051FE 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 33714 00005200 F8                      	clc				;no error either way ;M007
 33715 00005201 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 33716 00005203 89C8                    	mov	ax,cx			;return old count ;M007
 33717                                  m_cnt_ok:				; M007
 33718 00005205 5D                      	pop	bp			; M007
 33719                                  $MEN128:
 33720 00005206 1F                      	pop	ds			;;AN000;;
 33721                                  ;$MIF127: ; 08/04/2023
 33722 00005207 C3                      	retn
 33723                                  
 33724                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33725                                  ;;
 33726                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 33727                                  ;;
 33728                                  ;;	FUNCTION:  Will set registers for extended error #39
 33729                                  ;;	INPUTS:    None
 33730                                  ;;	OUPUTS:    AX,BX,CX set
 33731                                  ;;	REGS USED:
 33732                                  ;;
 33733                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33734                                  
 33735                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33736                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 33737                                  $M_GET_EXT_ERR_39:
 33738 00005208 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 33739                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 33740 0000520B BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 33741                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 33742 0000520E B501                    	mov	ch,1			;AN001;
 33743 00005210 C3                      	retn				;AN001;
 33744                                  
 33745                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33746                                  ;;
 33747                                  ;;	PROC NAME: $M_ADD_CRLF
 33748                                  ;;
 33749                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 33750                                  ;;	INPUTS:    DX contains the Input/Class requested
 33751                                  ;;	OUTPUTS:   None
 33752                                  ;;	REGS Revised: CX,ES,DI
 33753                                  ;;
 33754                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33755                                  
 33756                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33757                                  
 33758                                  $M_ADD_CRLF:
 33759                                  	;cmp	dh,0FFh
 33760 00005211 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 33761 00005214 7411                    	je	short $MIF134		;;AN004;; Yes
 33762 00005216 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 33763 00005219 750C                    	jnz	short $MIF135
 33764                                  					;;AN004;; No	
 33765 0000521B 1E                      	push	ds			;;AN004;;
 33766 0000521C 07                      	pop	es			;;AN004;; Set ES to data segment
 33767 0000521D 8D3E[2A87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 33768                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 33769 00005221 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 33770 00005224 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 33771                                  $MIF135:
 33772                                  $MIF134:
 33773 00005227 C3                      	retn				;;AN004;; Return
 33774                                  
 33775                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33776                                  ;;
 33777                                  ;;	PROC NAME: $M_IS_IT_DBCS
 33778                                  ;;
 33779                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 33780                                  ;;	INPUTS:    AL contains the byte to be checked
 33781                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 33782                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 33783                                  ;;	REGS USED: All restored
 33784                                  ;;
 33785                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33786                                  
 33787                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33788                                  
 33789                                  $M_IS_IT_DBCS:
 33790 00005228 06                      	push	es			;;AN000;; Save Extra Segment register
 33791 00005229 57                      	push	di			;;AN000;; Save DI register
 33792                                  
 33793 0000522A C43E[2387]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 33794                                  	;les	di,[$M_RT+60]		;;AN000;;
 33795 0000522E 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 33796 00005230 7417                    	jz	short $MIF138		;;AN000;; No
 33797                                  $MDO139:
 33798 00005232 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 33799                                  					;;AN000;; Is this the terminating flag?
 33800 00005236 F8                      	clc				;;AN000;;
 33801 00005237 7410                    	jz	short $MEN139
 33802                                  					;;AN000;; No
 33803 00005239 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 33804 0000523C 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 33805 0000523E 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 33806 00005242 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 33807                                  					;;AN000;; Yes
 33808 00005244 F9                      	stc				;;AN000;; Set carry flag
 33809                                  $MIF141:
 33810 00005245 47                      	inc	di			;;AN000;;
 33811 00005246 47                      	inc	di			;;AN000;;
 33812 00005247 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 33813                                  $MEN139:
 33814                                  $MIF138:
 33815 00005249 5F                      	pop	di			;;AN000;; Restore DI register
 33816 0000524A 07                      	pop	es			;;AN000;; Restore Extra Segment register
 33817 0000524B C3                      	retn				;;AN000;; Return
 33818                                  
 33819                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33820                                  ;;
 33821                                  ;;	PROC NAME: $M_CONVERT2ASC
 33822                                  ;;
 33823                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 33824                                  ;;	INPUTS: DX:AX contains the number to be converted
 33825                                  ;;		$M_RT_DIVISOR contains the divisor
 33826                                  ;;	OUTPUTS: CX contains the number of characters
 33827                                  ;;		Top of stack  --> Last character
 33828                                  ;;				     . . .
 33829                                  ;;		Bot of stack  --> First character
 33830                                  ;;	REGS USED:
 33831                                  ;;
 33832                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33833                                  
 33834                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33835                                  
 33836                                  $M_CONVERT2ASC:
 33837 0000524C 8F06[2D87]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 33838                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 33839                                  	
 33840 00005250 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 33841 00005252 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 33842 00005253 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 33843                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 33844 00005254 F736[3187]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33845                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 33846 00005258 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 33847                                  						;;AN000;;  and save reduced High Word in BX
 33848 00005259 F736[3187]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33849                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 33850                                  
 33851 0000525D 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 33852 00005260 7605                    	jna	short $MIF146			;;AN000;; 0-9
 33853 00005262 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 33854 00005265 EB03                    	jmp	short $MEN146
 33855                                  $MIF146:
 33856 00005267 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 33857                                  $MEN146:
 33858 0000526A 52                      	push	dx				;;AN000;; Save the digit on the stack
 33859 0000526B 41                      	inc	cx				;;AN000;; Count that digit
 33860 0000526C 09C0                    	or	ax,ax				;;AN000;; Are we done?
 33861 0000526E 7504                    	jnz	short $MLL149			;;AN000;; No
 33862 00005270 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 33863 00005272 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 33864                                  $MLL149:
 33865 00005274 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 33866                                  ; 28/04/2023
 33867 00005277 740A                    	je	short $MIF153
 33868                                  ;	jne	short $MIF150			;;AN000;; No
 33869                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33870                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33871                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33872                                  ;	;jne	short $MIF151
 33873                                  ;	; 09/04/2023
 33874                                  ;	jne	short $MEN150
 33875                                  ;						;;AN000;; Yes
 33876                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33877                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33878                                  ;	inc	cx				;;AN000;;
 33879                                  ;$MIF151:
 33880                                  ;	jmp	short $MEN150
 33881                                  
 33882                                  $MIF150:
 33883 00005279 83F906                  	cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 33884                                  ; 28/04/2023
 33885 0000527C 7405                    	je	short $MIF153
 33886                                  ;	jne	short $MIF154			;;AN000;; No
 33887                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33888                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33889                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33890                                  ;	;jne	short $MIF155			;;AN000;; No
 33891                                  ;	; 09/04/2023
 33892                                  ;	jne	short $MEN154
 33893                                  ;						;;AN000;; Yes				
 33894                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33895                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33896                                  ;	inc	cx				;;AN000;;
 33897                                  ;$MIF155:
 33898                                  ;	jmp	short $MEN154
 33899                                  
 33900                                  $MIF154:
 33901 0000527E 83F909                  	cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 33902 00005281 750B                    	jne	short $MIF158			;;AN000;; No  
 33903                                  ; 28/04/2023
 33904                                  $MIF153:
 33905                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33906 00005283 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33907                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33908 00005287 7505                    	jne	short $MIF159			;;AN000;; No
 33909                                  						;;AN000;; Yes
 33910 00005289 FF36[3A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33911                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33912 0000528D 41                      	inc	cx				;;AN000;;
 33913                                  $MIF159:
 33914                                  $MIF158:
 33915                                  $MEN154:
 33916                                  $MEN150:					;;AN000;;
 33917 0000528E 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 33918                                  						;;AN000;;  and Revised Low Word
 33919 0000528F 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 33920                                  	; 28/04/2023
 33921 00005291 EBC1                    	jmp	short $MDO145
 33922                                  ;$MEN145:
 33923                                  	; 28/04/2023
 33924                                  	;xor	ax,ax				;;AN000;; Reset remainder
 33925                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 33926 00005293 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 33927 00005295 FF36[2D87]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 33928                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 33929 00005299 C3                      	retn					;;AN000;; Return
 33930                                  
 33931                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33932                                  ;;
 33933                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 33934                                  ;;
 33935                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 33936                                  ;;	INPUTS:    ES:DI points to beginning of message
 33937                                  ;;		   DS:SI points to first sublist structure in chain
 33938                                  ;;		   BX contains the handle to write to (if applicable)
 33939                                  ;;		   CX contains the length of string to write (before substitutions)
 33940                                  ;;		   BP contains the count of replacables
 33941                                  ;;
 33942                                  ;;	OUTPUTS:
 33943                                  ;;	REGS USED: All
 33944                                  ;;
 33945                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33946                                  
 33947                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33948                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 33949                                  
 33950                                  $M_DISPLAY_MESSAGE:
 33951                                  ; $DO						;;AN000;; Note: DS:SI -> message
 33952                                  $MDO165:
 33953 0000529A 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 33954 0000529C 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 33955                                  ;; $IF NZ					;;AN000;; No
 33956 0000529E 7421                    	jz	short $MIF166			;;AN000;; Yes
 33957 000052A0 B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 33958 000052A2 B000                    	mov	al,0				;;AN004;;
 33959                                  ;; $DO						;;AN000;; Scan through string until %
 33960                                  $MDO167:
 33961 000052A4 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 33962                                  ;; $LEAVE E,AND					;;AN000;; No
 33963 000052A7 750A                    	jne	short $MLL168
 33964 000052A9 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 33965                                  ;; $LEAVE NE,AND				;;AN000;; No
 33966 000052AD 7404                    	je	short $MLL168
 33967                                  
 33968 000052AF 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 33969                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 33970 000052B1 750E                    	jne	short MEN167
 33971                                  $MLL168:
 33972 000052B3 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 33973 000052B6 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 33974                                  ;;; $IF C					;;AN004;; Yes
 33975 000052B9 7301                    	jnc	short $MIF169
 33976 000052BB 47                      	inc	di				;;AN004;; Increment past second part
 33977                                  ;;; $ENDIF					;;AN004;;
 33978                                  $MIF169:
 33979 000052BC 47                      	inc	di				;;AN000;; Next character in string
 33980 000052BD 42                      	inc	dx				;;AN000;; Size = Size + 1
 33981 000052BE 49                      	dec	cx				;;AN000;; Decrement total size
 33982                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 33983 000052BF 75E3                    	jnz	short $MDO167
 33984                                  $MEN167:
 33985                                  ;; $ENDIF					;;AN000;;
 33986                                  $MIF166:
 33987 000052C1 56                      	push	si				;;AN000;; Save beginning of sublists
 33988 000052C2 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 33989 000052C4 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 33990                                  ;; $IF NZ					;;AN000;; Yes
 33991 000052C6 7431                    	jz	short $MIF173
 33992 000052C8 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 33993                                  
 33994                                  ;; Search through sublists to find applicable one
 33995                                  
 33996 000052C9 833E[2F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33997                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 33998                                  ;;; $IF E					;;AN000;; No
 33999 000052CE 7529                    	jne	short $MIF174
 34000                                  ;;; $SEARCH					;;AN000;;
 34001                                  $MDO175:
 34002                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34003 000052D0 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34004                                  	;mov	al,[si+6]
 34005 000052D3 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34006                                  	; 28/04/2023					
 34007 000052D5 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34008                                  ;;; $EXITIF E					;;AN000;;
 34009                                  	;jne	short $MIF175
 34010                                  ;;; $ORELSE					;;AN000;; No
 34011                                  	;jmp	short $MSR175
 34012                                  	; 28/04/2023
 34013 000052D9 741E                    	je	short $MSR175
 34014                                  $MIF175:
 34015 000052DB 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34016                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34017 000052DD 7504                    	jne	short $MLL178
 34018 000052DF 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34019                                  ;;; $LEAVE Z					;;AN000;; No
 34020 000052E1 7404                    	jz	short $MEN175
 34021                                  $MLL178:
 34022                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34023                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34024                                  	;;add	si,[si+0]
 34025 000052E3 0334                    	add	si,[si]
 34026                                  ;;; ENDLOOP					;;AN000;; Yes
 34027 000052E5 EBE9                    	jmp	short $MDO175
 34028                                  $MEN175:
 34029 000052E7 803E[2C87]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34030                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34031                                  ;;;; $IF E					;;AN004;; Yes
 34032 000052EC 7508                    	jne	short $MIF180
 34033 000052EE 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34034 000052EF 42                      	inc	dx				;;AN000;;  at the end of the message
 34035 000052F0 49                      	dec	cx				;;AN000;; Adjust message length
 34036 000052F1 49                      	dec	cx				;;AN000;;
 34037 000052F2 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34038 000052F3 4F                      	dec	di				;;AN000;;
 34039                                  ;;;; $ELSE					;;AN004;; No
 34040 000052F4 EB03                    	jmp	short $MEN180
 34041                                  $MIF180:
 34042 000052F6 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34043                                  ;;;; $ENDIF					;;AN004;;
 34044                                  $MEN180:
 34045                                  ;;; $ENDSRCH					;;AN000;;
 34046                                  $MSR175:
 34047                                  ;; $ENDIF					;;AN000;;
 34048                                  $MIF174:
 34049                                  ; $ENDIF					;;AN000;;
 34050                                  $MIF173:
 34051                                  ;; Prepare and display this part of message
 34052                                  
 34053 000052F9 57                      	push	di				;;AN000;; Save pointer to replace number
 34054 000052FA 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34055 000052FC E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34056 000052FF 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34057 00005300 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34058                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34059                                  	;jnc	short $MXL3
 34060                                  	;jmp	$MEN165
 34061                                  	; 02/05/2023
 34062 00005301 7214                    	jc	short $MEN165
 34063                                  $MXL3:
 34064 00005303 51                      	push	cx				;;AN000;;
 34065                                  
 34066                                  ;; Save and reset pointer registers
 34067                                  
 34068 00005304 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34069                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34070 00005306 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34071                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34072                                  ; $IF NE					;;AN000;; No
 34073 0000530A 7412                    	je	short $MIF187			;;AN000;; Yes			
 34074 0000530C 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34075                                  ;; $IF NZ					;;AN000;; No
 34076 0000530E 7406                    	jz	short $MIF188			;;AN000;; Yes
 34077 00005310 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34078 00005311 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34079 00005312 47                      	inc	di				;;AN000;; Go past %
 34080 00005313 47                      	inc	di				;;AN000;; Go past replace number
 34081                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34082                                  	;jmp	short $MEN188
 34083                                  	; 28/04/2023
 34084 00005314 EB15                    	jmp	short $MEN187
 34085                                  $MIF188:
 34086 00005316 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34087                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34088                                  $MEN188:
 34089                                  ; $ELSE 					;;AN000;;
 34090                                  	;jmp	short $MEN187
 34091                                  	; 28/04/2023
 34092                                  	; zf = 1
 34093                                  	;jmp	short $MEN165 
 34094                                  
 34095                                  ; 28/04/2023
 34096                                  $MXL4:
 34097                                  $MLL214:
 34098                                  $MEN165:
 34099 00005317 C706[2F87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34100                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34101                                  						;;AN000;; Reset message number to null
 34102 0000531D C3                      	retn					;;AN000;; Return
 34103                                  
 34104                                  $MIF187:
 34105 0000531E 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34106                                  ;; $IF Z					;;AN004;; No
 34107                                  	;jnz	short $MIF192
 34108                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34109                                  ;; $ELSE					;;AN000;; No
 34110                                  	;jmp	short $MEN192
 34111                                  	; 28/04/2023
 34112 00005320 74F4                    	jz	short $MIF188
 34113                                  $MIF192:
 34114 00005322 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34115                                  ;;; $IF Z					;;AN004;; No
 34116 00005325 7502                    	jnz	short $MIF194
 34117 00005327 31C9                    	xor	cx,cx				;;AN004;;
 34118                                  ;;; $ENDIF					;;AN000;;
 34119                                  $MIF194:
 34120 00005329 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34121                                  ;; $ENDIF					;;AN000;;
 34122                                  $MEN192:
 34123                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34124                                  $MEN187:
 34125                                  ; $LEAVE Z					;;AN000;;
 34126 0000532B 74EA                    	jz	short $MEN165
 34127                                  	;
 34128 0000532D 55                      	push	bp				;;AN000;; Save the replace count
 34129 0000532E 57                      	push	di				;;AN000;; Save location to complete message
 34130 0000532F 06                      	push	es				;;AN000;;
 34131 00005330 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34132 00005331 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34133                                  
 34134                                  ;; Determine what action is required on parameter
 34135                                  
 34136 00005333 833E[2F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34137                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34138                                  ; $IF E						;;AN000;;
 34139 00005338 753B                    	jne	short $MIF199
 34140                                  
 34141                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34142 0000533A F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34143                                  	;test	byte [si+7],0Fh			;;AN000;;
 34144                                  ;; $IF Z					;;AN000;;
 34145 0000533E 7508                    	jnz	short $MIF200
 34146                                  
 34147                                  ;; Character type requested
 34148                                  
 34149                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34150 00005340 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34151                                  	;les	di,[si+2]
 34152 00005343 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34153                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34154 00005346 EB28                    	jmp	short $MEN200
 34155                                  $MIF200:
 34156                                  ;; ENDIF					;;AN000;;
 34157                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34158 00005348 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34159                                  	;test	byte [si+7],0Dh			;;AN000;;
 34160                                  ;; $IF Z,OR					;;AN000;;
 34161 0000534C 740C                    	jz	short $MLL202
 34162                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34163 0000534E F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34164                                  	;test	byte [si+7],0Eh			;;AN000;;
 34165                                  ;;; $IF Z,OR					;;AN000;;
 34166 00005352 7406                    	jz	short $MLL202
 34167                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34168 00005354 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34169                                  	;test	byte [si+7],0Ch			;;AN000;;
 34170                                  ;;;; $IF Z 					;;AN000;;
 34171 00005358 7508                    	jnz	short $MIF202
 34172                                  $MLL202:
 34173                                  
 34174                                  ;; Numeric type requested
 34175                                  
 34176                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34177 0000535A C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34178 0000535D E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34179                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34180 00005360 EB0E                    	jmp	short $MEN202
 34181                                  $MIF202:
 34182                                  ;;;; ENDIF					;;AN000;;
 34183                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34184 00005362 F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34185                                  	;test	byte [si+7],0Bh			;;AN000;;
 34186                                  ;;;; $IF E					;;AN000;;
 34187 00005366 7505                    	jnz	short $MIF204
 34188                                  
 34189                                  ;; Date type requested
 34190                                  
 34191 00005368 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34192                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34193 0000536B EB03                    	jmp	short $MEN204
 34194                                  $MIF204:					;;AN000;;
 34195                                  
 34196                                  ;; Time type requested (Default if we have not matched until here)
 34197                                  
 34198 0000536D E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34199                                  
 34200                                  ;;;; $ENDIF					;;AN000;;
 34201                                  $MEN204:
 34202                                  ;;; $ENDIF					;;AN000;;
 34203                                  $MEN202:
 34204                                  ;; $ENDIF					;;AN000;;
 34205                                  $MEN200:
 34206                                  
 34207                                  ;; With the replace information of the Stack, display the replaceable field
 34208                                  
 34209 00005370 E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34210                                  
 34211                                  ;; None of the above - Extended/Parse replace
 34212                                  ; $ELSE 					;;AN000;;
 34213 00005373 EB03                    	jmp	short $MEN199
 34214                                  $MIF199:
 34215 00005375 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34216                                  ; $ENDIF					;;AN000;;
 34217                                  $MEN199:
 34218                                  
 34219                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34220                                  
 34221                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34222 00005378 7207                    	jc	short $MIF211
 34223                                  	;
 34224 0000537A 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34225 0000537B 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34226 0000537C 5F                      	pop	di				;;AN000;;
 34227 0000537D 5D                      	pop	bp				;;AN000;; Get replacment count
 34228 0000537E 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34229                                  ; $ELSE						;;AN000;;
 34230 0000537F EB03                    	jmp	short $MEN211
 34231                                  $MIF211:
 34232 00005381 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34233                                  	; 28/04/2023
 34234                                  	;stc					;;AN000;;
 34235                                  ; $ENDIF					;;AN000;;
 34236                                  $MEN211:
 34237 00005384 833E[2F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34238                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34239                                  ; $ENDDO NE,OR					;;AN000;;
 34240 00005389 758C                    	jne	short $MLL214
 34241                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34242                                  	; 10/04/2023
 34243                                  	;jc	short $MXL4
 34244 0000538B E90CFF                  	jmp	$MDO165
 34245                                  
 34246                                  ; 28/04/2023
 34247                                  ;$MXL4:
 34248                                  ;$MLL214:
 34249                                  ;$MEN165:
 34250                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34251                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34252                                  ;						;;AN000;; Reset message number to null
 34253                                  ;	retn					;;AN000;; Return
 34254                                  
 34255                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34256                                  ;;
 34257                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34258                                  ;;
 34259                                  ;;	FUNCTION:
 34260                                  ;;	INPUTS:
 34261                                  ;;	OUPUTS:
 34262                                  ;;
 34263                                  ;;	REGS USED:
 34264                                  ;;
 34265                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34266                                  
 34267                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34268                                  
 34269                                  $M_EXT_PAR_REPLACE:
 34270 0000538E 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34271 00005390 A1[2F87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34272                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34273 00005393 C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34274                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34275 00005399 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34276                                  $MDO215:
 34277 0000539C 58                      	pop	ax				;;AN000;; Get character in register
 34278 0000539D 8887[3387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34279                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34280 000053A1 43                      	inc	bx				;;AN000;; Increase buffer count
 34281 000053A2 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34282 000053A5 7503                    	jne	short $MIF216			;;AN000;; No
 34283 000053A7 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34284                                  $MIF216:
 34285 000053AA FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34286 000053AC 75EE                    	jnz	short $MDO215
 34287                                  
 34288 000053AE B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34289 000053B1 8987[3387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34290                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34291 000053B5 43                      	inc	bx				;;AN000;; Increase buffer count
 34292 000053B6 43                      	inc	bx				;;AN000;; Increase buffer count
 34293                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34294                                  	;retn					;;AN000::
 34295                                  	; 11/04/2023
 34296                                  	;jmp	$M_FLUSH_BUF
 34297                                  
 34298                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34299                                  ;;
 34300                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34301                                  ;;
 34302                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34303                                  ;;	INPUTS: DI contains the number of bytes to display
 34304                                  ;;	OUTPUTS: BX reset to zero
 34305                                  ;;
 34306                                  ;;	REGS USED:
 34307                                  ;;
 34308                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34309                                  	
 34310                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34311                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34312                                  
 34313                                  $M_FLUSH_BUF:
 34314 000053B7 51                      	push	cx				;;AN000;; Save changed regs
 34315 000053B8 06                      	push	es				;;AN000;;
 34316 000053B9 57                      	push	di				;;AN000;;
 34317 000053BA 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34318 000053BB 07                      	pop	es				;;AN000;;
 34319 000053BC 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34320 000053BE 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34321 000053C0 8D3E[3387]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34322                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34323 000053C4 E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34324 000053C7 7204                    	jc	short $MIF314
 34325 000053C9 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34326 000053CA 07                      	pop	es				;;AN000;;
 34327 000053CB 59                      	pop	cx				;;AN000;;
 34328                                  	;jmp	short $MEN314
 34329                                  	; 11/04/2023
 34330 000053CC C3                      	retn
 34331                                  $MIF314:
 34332 000053CD 83C406                  	add	sp,6				;;AN000;; Fix stack
 34333 000053D0 F9                      	stc					;;AN000;;
 34334                                  $MEN314:
 34335 000053D1 C3                      	retn					;;AN000;; Return
 34336                                  
 34337                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34338                                  ;;
 34339                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34340                                  
 34341                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34342                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34343                                  
 34344                                  $M_DISPLAY_REPLACE:
 34345 000053D2 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34346                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34347 000053D4 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34348                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34349 000053D8 7511                    	jne	short $MIF276
 34350                                  	
 34351 000053DA C787[3387]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34352                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34353                                  	
 34354 000053E0 43                      	inc	bx				;;AN000;; Increment count
 34355 000053E1 43                      	inc	bx				;;AN000;; Increment count
 34356                                  	
 34357 000053E2 C687[3387]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34358                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34359                                  	
 34360 000053E7 43                      	inc	bx				;;AN000;; Increment count
 34361 000053E8 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34362                                  $MIF276:
 34363 000053EB 5D                      	pop	bp				;;AN000;; Remember the return address
 34364 000053EC 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34365 000053EE 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34366                                  
 34367 000053F0 880E[2987]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34368                                  	;mov	[$M_RT+66],cl
 34369                                  	
 34370                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34371 000053F4 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34372                                  	;mov	al,[si+9]
 34373                                  	
 34374 000053F7 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34375 000053F9 761E                    	jna	short $MIF278
 34376 000053FB 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34377 000053FD 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34378                                  	
 34379                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34380 000053FF F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34381                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34382 00005403 7414                    	jz	short $MIF279			;;AN000;; No
 34383                                  $MDO280:
 34384                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34385 00005405 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34386                                  	;mov	al,[si+0Ah]
 34387 00005408 8887[3387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34388                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34389                                  	
 34390 0000540C 43                      	inc	bx				;;AN000;;
 34391 0000540D 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34392 00005410 7503                    	jne	short $MIF281
 34393 00005412 E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34394                                  $MIF281:
 34395 00005415 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34396 00005417 75EC                    	jnz	short $MDO280
 34397                                  $MIF279:
 34398                                  $MIF278:
 34399                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34400 00005419 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34401                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34402 0000541D 740C                    	je	short $MIF286
 34403                                  	
 34404                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34405 0000541F 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34406                                  	;;cmp	byte [si+8],cl
 34407 00005422 7307                    	jnb	short $MIF287
 34408                                  
 34409                                  	; 03/05/2023
 34410                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34411                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34412                                  	;;sub	cl,[si+8]
 34413 00005424 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34414                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34415                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34416                                  	;;mov	cl,[si+8]
 34417                                  	; 03/05/2023
 34418 00005426 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34419 00005429 28CA                    	sub	dl,cl
 34420                                  $MIF287:
 34421                                  $MIF286:
 34422 0000542B 09C9                    	or	cx,cx				;;AN000;;
 34423 0000542D 7424                    	jz	short $MIF290			;;AN000;;
 34424                                  $MDO291:
 34425                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34426 0000542F F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34427                                  	;test	byte [si+7],0Fh			;;AN000;;
 34428 00005433 750C                    	jnz	short $MIF292
 34429                                  
 34430                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34431 00005435 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34432                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34433 00005439 7406                    	jz	short $MIF292			;;AN000;; No
 34434                                  
 34435 0000543B 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34436 0000543E 47                      	inc	di				;;AN000;; Next character in string
 34437 0000543F EB01                    	jmp	short $MEN292
 34438                                  $MIF292:
 34439 00005441 58                      	pop	ax				;;AN000;; Get character in register
 34440                                  $MEN292:
 34441                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34442 00005442 8887[3387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34443                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34444                                  	; 03/05/2023
 34445 00005446 43                      	inc	bx				;;AN000;; Increase buffer count
 34446 00005447 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34447 0000544A 7503                    	jne	short $MIF295			;;AN000;;
 34448 0000544C E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34449                                  $MIF295:
 34450 0000544F FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34451 00005451 75DC                    	jnz	short $MDO291
 34452                                  $MIF290:
 34453                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34454 00005453 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34455                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34456 00005457 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34457 00005459 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34458 0000545B 7414                    	jz	short $MIF300
 34459                                  $MDO301:
 34460                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34461 0000545D 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34462                                  	;mov	al,[si+0Ah]
 34463                                  
 34464                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34465 00005460 8887[3387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34466                                  	; 03/05/2023
 34467                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34468                                  
 34469 00005464 43                      	inc	bx				;;AN000;;
 34470 00005465 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34471 00005468 7503                    	jne	short $MIF302			;;AN000;; No
 34472                                  						;;AN000;; Yes
 34473 0000546A E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34474                                  $MIF302:
 34475 0000546D FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34476 0000546F 75EC                    	jnz	short $MDO301			;;AN000;;
 34477                                  $MIF300:
 34478                                  $MIF299:
 34479                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34480 00005471 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34481                                  	;test	byte [si+7],0Fh			;;AN000;;
 34482 00005475 7506                    	jnz	short $MIF307
 34483                                  	
 34484                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34485 00005477 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34486                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34487                                  	; 11/04/2023
 34488                                  	;jz	short $MIF307			;;AN000;;
 34489                                  	;jmp	short $MEN307			;;AN000;;
 34490 0000547B 750C                    	jnz	short $MEN307
 34491                                  $MIF307:
 34492 0000547D 08D2                    	or	dl,dl				;;AN000;;
 34493 0000547F 7408                    	jz	short $MIF309			;;AN000;;
 34494                                  $MDO310:
 34495 00005481 8F06[2D87]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34496                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34497 00005485 FECA                    	dec	dl				;;AN000;; Are we done?
 34498 00005487 75F8                    	jnz	short $MDO310
 34499                                  $MIF309:
 34500                                  $MEN307:
 34501 00005489 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34502 0000548C 55                      	push	bp				;;AN000;; Restore the return address
 34503 0000548D C3                      	retn					;;AN000;;
 34504                                  
 34505                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34506                                  ;;
 34507                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34508                                  ;;
 34509                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34510                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34511                                  ;;		ES:DI contains the VALUE from SUBLIST
 34512                                  ;;	OUTPUTS: CX contains number of characters on stack
 34513                                  ;;		 Top of stack  --> Last character
 34514                                  ;;					. . .
 34515                                  ;;		 Bot of stack  --> First character
 34516                                  ;;
 34517                                  ;;	OTHER REGS Revised: AX
 34518                                  ;;
 34519                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34520                                  
 34521                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34522                                  
 34523                                  $M_CHAR_REPLACE:
 34524 0000548E 5D                      	pop	bp				;;AN000;; Save return address
 34525                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 34526 0000548F F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 34527                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 34528 00005493 7512                    	jnz	short $MIF317			;;AN000;; No
 34529 00005495 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34530 00005498 50                      	push	ax				;;AN000;; Put it on the stack
 34531 00005499 41                      	inc	cx				;;AN000;; Increase the count
 34532 0000549A E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 34533 0000549D 7306                    	jnc	short $MIF318
 34534 0000549F 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 34535 000054A3 50                      	push	ax				;;AN000;; Put it on the stack
 34536 000054A4 F8                      	clc					;;AN000;; Clear the carry
 34537                                  $MIF318:
 34538 000054A5 EB0D                    	jmp	short $MEN317
 34539                                  $MIF317:
 34540                                  $MDO321:
 34541 000054A7 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34542 000054AA 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 34543 000054AC 7404                    	jz	short $MEN321			;;AN000;; Yes
 34544 000054AE 47                      	inc	di				;;AN000;; Next character
 34545 000054AF 41                      	inc	cx				;;AN000;; Increment the count
 34546 000054B0 EBF5                    	jmp	short $MDO321
 34547                                  $MEN321:
 34548 000054B2 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 34549                                  $MEN317:
 34550 000054B4 55                      	push	bp				;;AN000;; Restore return address
 34551 000054B5 C3                      	retn					;;AN000;;	
 34552                                  
 34553                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34554                                  ;;
 34555                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 34556                                  ;;
 34557                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 34558                                  ;;		  and prepare to display
 34559                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34560                                  ;;		ES:DI contains the VALUE from SUBLIST
 34561                                  ;;	OUTPUTS: CX contains number of characters on stack
 34562                                  ;;		 Top of stack  --> Last character
 34563                                  ;;					. . .
 34564                                  ;;		 Bot of stack  --> First character
 34565                                  ;;	OTHER REGS Revised: BX,DX,AX
 34566                                  ;;
 34567                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34568                                  
 34569                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34570                                  
 34571                                  $M_BIN2ASC_REPLACE:
 34572 000054B6 5D                      	pop	bp				;;AN000;; Save return address
 34573 000054B7 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34574 000054B9 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 34575 000054BB C706[3187]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 34576                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 34577                                  
 34578 000054C1 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 34579                                  
 34580                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 34581 000054C3 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34582                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 34583 000054C7 7511                    	jnz	short $MIF325			;;AN000;; No
 34584                                  	
 34585 000054C9 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 34586                                  
 34587                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34588 000054CC F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34589                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 34590 000054D0 753D                    	jnz	short $MIF326			;;AN000;; No
 34591                                  			 
 34592 000054D2 A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 34593 000054D4 7433                    	jz	short $MIF327			;;AN000;; No
 34594                                  						;;AN000;; Yes				
 34595                                  	; 12/04/2023
 34596                                  	;inc	bx				;;AN000;; Remember that it was negative
 34597 000054D6 247F                    	and	al,01111111b			;;AN000;; Make it positive
 34598                                  
 34599                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 34600                                  	;jmp	short $MIF327
 34601 000054D8 EB2E                    	jmp	short $MIF350 ; inc bx
 34602                                  
 34603                                  ; 12/04/2023
 34604                                  %if 0
 34605                                  
 34606                                  $MIF327:
 34607                                  $MIF335:	; 12/04/2023
 34608                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34609                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34610                                  $MIF326:
 34611                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34612                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34613                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34614                                  	jnz	short $MIF330			;;AN000;; No
 34615                                  						;;AN000;; Yes
 34616                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34617                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34618                                  $MIF330:
 34619                                  	jmp	short $MEN325
 34620                                  
 34621                                  %endif
 34622                                  
 34623                                  $MIF325:
 34624                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 34625 000054DA F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34626                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 34627 000054DE 7513                    	jnz	short $MIF333			;;AN000;; No
 34628                                  						;;AN000;; Yes
 34629 000054E0 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 34630                                  
 34631                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34632 000054E3 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34633                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34634 000054E7 7526                    	jnz	short $MIF334			;;AN000;; No
 34635                                  						;;AN000;; Yes
 34636 000054E9 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 34637 000054EC 741B                    	jz	short $MIF335			;;AN000;; No
 34638                                  						;;AN000;; Yes
 34639                                  	; 12/04/2023
 34640                                  	;inc	bx				;;AN000;; Remember that it was negative
 34641 000054EE 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 34642                                  
 34643                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34644                                  	;jmp	short $MIF335
 34645 000054F1 EB15                    	jmp	short $MIF350 ; inc bx
 34646                                  
 34647                                  ; 12/04/2023
 34648                                  %if 0
 34649                                  
 34650                                  $MIF335:
 34651                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34652                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34653                                  $MIF334:
 34654                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 34655                                  	jnz	short $MIF338
 34656                                  
 34657                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34658                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34659                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34660                                  	jnz	short $MIF338			;;AN000;; No
 34661                                  						;;AN000;; Yes
 34662                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34663                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34664                                  $MIF338:
 34665                                  	jmp	short $MEN333			;;AN000;;
 34666                                  %endif
 34667                                  
 34668                                  $MIF333:
 34669 000054F3 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 34670 000054F6 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 34671                                  
 34672                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34673 000054FA F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34674                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34675 000054FE 750F                    	jnz	short $MIF341			;;AN000;; No
 34676                                  						;;AN000;; Yes
 34677 00005500 F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 34678 00005503 7404                    	jz	short $MIF342			;;AN000;; No
 34679                                  						;;AN000;; Yes
 34680                                  	; 12/04/2023
 34681                                  	;inc	bx				;;AN000;; Remember that it was negative
 34682 00005505 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 34683                                  	
 34684                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34685                                  $MIF350:
 34686 00005508 43                      	inc	bx
 34687                                  $MIF342:
 34688                                  	; 12/04/2023
 34689                                  $MIF327:
 34690                                  $MIF335:
 34691 00005509 C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34692                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34693                                  $MIF341:
 34694                                  $MIF326:
 34695                                  	; 18/04/2023
 34696                                  $MIF334:
 34697                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34698 0000550F F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34699                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34700 00005513 7506                    	jnz	short $MIF345			;;AN000;; No
 34701                                  						;;AN000;; Yes
 34702 00005515 C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34703                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34704                                  $MIF345:
 34705                                  $MEN333:
 34706                                  $MEN325:
 34707 0000551B E82EFD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 34708                                  
 34709 0000551E 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 34710 00005520 7405                    	jz	short $MIF349			;;AN000;; No
 34711                                  						;;AN000;; Yes
 34712 00005522 31D2                    	xor	dx,dx				;;AN000;;
 34713 00005524 B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 34714 00005526 52                      	push	dx				;;AN000;;
 34715                                  $MIF349:
 34716 00005527 55                      	push	bp				;;AN000;; Restore return address
 34717 00005528 C3                      	retn					;;AN000;; Return
 34718                                  
 34719                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34720                                  ;;
 34721                                  ;;	PROC NAME: $M_DATE_REPLACE
 34722                                  ;;
 34723                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 34724                                  ;;		  country format and prepare to display
 34725                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34726                                  ;;		ES:DI points at VALUE from SUBLIST
 34727                                  ;;	OUTPUTS: CX contains number of characters on stack
 34728                                  ;;		 Top of stack  --> Last character
 34729                                  ;;					. . .
 34730                                  ;;		 Bot of stack  --> First character
 34731                                  ;;	OTHER REGS Revised: DX,AX
 34732                                  ;;
 34733                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34734                                  
 34735                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34736                                  $M_DATE_REPLACE:
 34737 00005529 5D                      	pop	bp				;;AN000;; Save return address
 34738                                  
 34739 0000552A C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34740                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 34741                                  	
 34742 00005530 E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 34743                                  						;;AN000;; All O.K.?
 34744 00005533 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 34745                                  	; 12/04/2023
 34746                                  	;xor	ax,ax				;;AN000;; Reset AX value
 34747                                  	
 34748                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 34749                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 34750                                  	;jne	short $MIF351
 34751                                  	; 12/04/2023
 34752 00005535 A1[3387]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34753 00005538 09C0                    	or	ax,ax
 34754 0000553A 751D                    	jnz	short $MIF351
 34755                                  
 34756 0000553C E87200                  	call	$M_YEAR				;;AN000;; Get Year
 34757 0000553F E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34758                                  
 34759 00005542 FF36[3E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34760                                  	;push	word [$M_RT+87]			;;AN000;;
 34761                                  	
 34762 00005546 41                      	inc	cx				;;AN000;; Increment count
 34763 00005547 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 34764                                  
 34765 00005549 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34766                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34767 0000554C E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34768                                  	
 34769 0000554F FF36[3E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34770                                  	;push	word [$M_RT+87]			;;AN000;;
 34771                                  
 34772 00005553 41                      	inc	cx				;;AN000;; Increment count
 34773 00005554 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34774                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34775                                  	; 12/04/2023
 34776                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34777 00005557 EB3C                    	jmp	short $MIF354 ; **
 34778                                  $MIF351:
 34779                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 34780                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 34781                                  	;jne	short $MIF353
 34782                                  	; 12/04/2023
 34783                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34784 00005559 48                      	dec	ax 
 34785 0000555A 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 34786                                  
 34787 0000555C E85200                  	call	$M_YEAR				;;AN000;; Get Year
 34788 0000555F E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34789                                  
 34790 00005562 FF36[3E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34791                                  	;push	word [$M_RT+87]			;;AN000;;
 34792                                  	
 34793 00005566 41                      	inc	cx				;;AN000;; Increment count
 34794 00005567 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 34795                                  
 34796 00005569 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34797                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34798 0000556C E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34799                                  
 34800 0000556F FF36[3E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34801                                  	;push	word [$M_RT+87]			;;AN000;;
 34802                                  
 34803 00005573 41                      	inc	cx				;;AN000;;
 34804                                  	      
 34805 00005574 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34806                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34807                                  
 34808                                  	; 12/04/2023
 34809                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34810 00005577 EB1C                    	jmp	short $MIF354 ; **
 34811                                  	; 12/04/2023
 34812                                  $MIF352:
 34813                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 34814 00005579 48                      	dec	ax
 34815                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 34816                                  	;xor	ax,ax
 34817                                  	;jmp	short $MIF355
 34818                                  	; 12/04/2023
 34819 0000557A 751C                    	jnz	short $MIF355
 34820                                  $MIF353:
 34821                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 34822                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 34823                                  	;jne	short $MIF355
 34824                                  
 34825 0000557C 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34826                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34827 0000557F E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34828                                  	
 34829 00005582 FF36[3E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34830                                  	;push	word [$M_RT+87]			;;AN000;;
 34831                                  
 34832 00005586 41                      	inc	cx				;;AN000;;
 34833                                  
 34834 00005587 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34835                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34836 0000558A E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34837                                  	
 34838 0000558D FF36[3E87]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34839                                  	;push	word [$M_RT+87]			;;AN000;;
 34840                                  	
 34841 00005591 41                      	inc	cx				;;AN000;;
 34842                                  
 34843 00005592 E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 34844                                  	; 12/04/2023
 34845                                  $MIF354:
 34846 00005595 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 34847                                  $MIF355:
 34848 00005598 55                      	push	bp				;;AN000;; Restore return address
 34849 00005599 C3                      	retn					;;AN000;; Return
 34850                                  
 34851                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34852                                  ;;
 34853                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34854                                  
 34855                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34856                                  $M_GET_DATE:
 34857                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 34858                                  	;mov	al,0 				;;AN000;; Get current country info
 34859                                  	; 12/04/2023
 34860 0000559A B80038                  	mov	ax,3800h
 34861                                  	;
 34862 0000559D 8D16[3387]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34863                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 34864 000055A1 CD21                    	int	21h				;;AN000;;
 34865 000055A3 730B                    	jnc	short $MIF357
 34866                                  	;
 34867 000055A5 C706[3387]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 34868                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 34869 000055AB C606[3E87]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 34870                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 34871                                  $MIF357:
 34872 000055B0 C3                      	retn					;;AN000;;
 34873                                  
 34874                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34875                                  ;;
 34876                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34877                                  
 34878                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34879                                  $M_YEAR:
 34880 000055B1 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34881                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 34882                                  
 34883                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 34884 000055B4 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34885                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 34886 000055B8 7508                    	jnz	short $MIF359			;;AN000;; No
 34887                                  						;;AN000;; Yes
 34888 000055BA 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34889 000055BD 7603                    	jna	short $MIF360			;;AN000;;
 34890 000055BF B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34891                                  $MIF360:
 34892                                  $MIF359:
 34893 000055C2 C3                      	retn					;;AN000;;
 34894                                  
 34895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34896                                  ;;
 34897                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34898                                  
 34899                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34900                                  $M_CONVERTDATE:
 34901                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 34902 000055C3 8F06[3387]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34903                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 34904 000055C7 880E[2987]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 34905                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 34906 000055CB E87EFC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 34907 000055CE 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 34908 000055CF 3A0E[2987]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 34909 000055D3 7505                    	jne	short $MIF363			;;AN000;; No
 34910 000055D5 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 34911 000055D8 50                      	push	ax				;;AN000;; Save it
 34912 000055D9 41                      	inc	cx				;;AN000;; Count it
 34913                                  $MIF363:
 34914 000055DA 41                      	inc	cx				;;AN000;; Restore CX
 34915 000055DB FF36[3387]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34916                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 34917 000055DF C3                      	retn
 34918                                  
 34919                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34920                                  ;;
 34921                                  ;;	PROC NAME: $M_TIME_REPLACE
 34922                                  ;;
 34923                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 34924                                  ;;		  and prepare to display
 34925                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34926                                  ;;		ES:DI points at VALUE from SUBLIST
 34927                                  ;;	OUTPUTS: CX contains number of characters on stack
 34928                                  ;;		 Top of stack  --> Last character
 34929                                  ;;					. . .
 34930                                  ;;		 Bot of stack  --> First character
 34931                                  ;;	REGS USED: BP,CX,AX
 34932                                  ;;
 34933                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34934                                  
 34935                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM							     ;;
 34936                                  $M_TIME_REPLACE:
 34937 000055E0 5D                      	pop	bp				;;AN000;; Save return address
 34938                                  
 34939 000055E1 C706[3187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34940                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 34941                                  
 34942 000055E7 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 34943                                  
 34944                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 34945 000055EA F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 34946                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 34947 000055EE 741A                    	jz	short $MIF365			;;AN000;; No
 34948                                  						;;AN000;; Yes
 34949 000055F0 803E[4487]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 34950                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 34951 000055F5 7513                    	jne	short $MIF366			;;AN000;; No
 34952                                  						;;AN000;; Yes
 34953 000055F7 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34954                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 34955 000055FA 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 34956 000055FC 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 34957 000055FE 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 34958 00005600 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 34959                                  $MLL367:
 34960 00005602 B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 34961                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 34962                                  	;inc	cx				;;AN000;;
 34963                                  	;jmp	short $MEN367			;;AN000;;
 34964                                  	; 12/04/2023
 34965 00005604 EB02                    	jmp	short $MEN367 ; *
 34966                                  $MIF367:
 34967 00005606 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 34968                                  $MEN367:	; * ; 12/04/2023
 34969 00005608 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 34970 00005609 41                      	inc	cx				;;AN000;;
 34971                                  ;$MEN367:
 34972                                  $MIF366:
 34973                                  $MIF365:					;;AN000;;
 34974 0000560A 31C0                    	xor	ax,ax				;;AN000;;
 34975 0000560C 31D2                    	xor	dx,dx				;;AN000;;
 34976                                  	
 34977                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 34978 0000560E F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34979                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 34980 00005612 740B                    	jz	short $MIF372			;;AN000;;
 34981                                  
 34982 00005614 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34983                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 34984 00005617 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 34985                                  
 34986 0000561A FF36[3C87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 34987                                  	;push	word [$M_RT+85]			;;AN000;;
 34988 0000561E 41                      	inc	cx				;;AN000;;
 34989                                  $MIF372:
 34990                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 34991 0000561F F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34992                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 34993 00005623 7506                    	jnz	short $MLL374			;;AN000;; No
 34994                                  
 34995                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 34996 00005625 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34997                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 34998 00005629 740B                    	jz	short $MIF374			;;AN000;; No
 34999                                  $MLL374:
 35000 0000562B 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35001                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35002 0000562E E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 35003                                  
 35004 00005631 FF36[4087]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35005                                  	;push	word [$M_RT+89]			;;AN000;;
 35006 00005635 41                      	inc	cx				;;AN000;;
 35007                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35008 00005636 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35009                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35010 00005639 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 35011                                  
 35012 0000563C FF36[4087]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35013                                  	;push	word [$M_RT+89]			;;AN000;;
 35014 00005640 41                      	inc	cx				;;AN000;;
 35015                                  
 35016 00005641 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35017                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35018                                  
 35019                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35020 00005644 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35021                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35022 00005648 7413                    	jz	short $MIF376			;;AN000;; No
 35023                                  
 35024 0000564A 803E[4487]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35025                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35026 0000564F 750C                    	jne	short $MIF377			;;AN000;; No
 35027                                  
 35028 00005651 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35029 00005653 7C02                    	jnge	short $MIF378 ; jl
 35030 00005655 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35031                                  $MIF378:
 35032                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35033                                  	;jne	short $MIF380			;;AN000;; No
 35034                                  	; 12/04/2023
 35035 00005657 20C0                    	and	al,al
 35036 00005659 7502                    	jnz	short $MIF380	
 35037 0000565B B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35038                                  $MIF380:
 35039                                  $MIF377:
 35040                                  $MIF376:
 35041 0000565D E8ECFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35042 00005660 55                      	push	bp				;;AN000;; Restore return address
 35043 00005661 C3                      	retn					;;AN000;; Return
 35044                                  
 35045                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35046                                  ;;
 35047                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35048                                  
 35049                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35050                                  $M_GET_TIME:
 35051                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35052                                  	;mov	al,0 				;;AN000;; Get current country info
 35053                                  	; 12/04/2023
 35054 00005662 B80038                  	mov	ax,3800h
 35055                                  	;
 35056 00005665 8D16[3387]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35057                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35058 00005669 CD21                    	int	21h				;;AN000;;
 35059 0000566B 7310                    	jnc	short $MIF384
 35060                                  
 35061 0000566D C706[4487]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35062                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35063 00005673 C606[4087]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35064                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35065 00005678 C606[3C87]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35066                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35067                                  $MIF384:
 35068 0000567D C3                      	retn					;;AN000;;
 35069                                  
 35070                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35071                                  ;;
 35072                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35073                                  
 35074                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35075                                  
 35076                                  ; 12/04/2023 
 35077                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35078                                  %if 0
 35079                                  $M_CONVERTTIME:
 35080                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35081                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35082                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35083                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35084                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35085                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35086                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35087                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35088                                  	jne	short $MIF386			;;AN000;; No
 35089                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35090                                  	push	ax				;;AN000;; Save it
 35091                                  	inc	cx				;;AN000;; Count itount it
 35092                                  $MIF386:
 35093                                  	inc	cx				;;AN000;; Restore CX
 35094                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35095                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35096                                  	retn
 35097                                  %endif
 35098                                  
 35099                                  ; ----------------------------
 35100                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35101                                  ; ----------------------------
 35102                                  ; include msgdcl.inc
 35103                                  ; ----------------------------
 35104                                  
 35105                                  ;============================================================================
 35106                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 35107                                  ;============================================================================
 35108                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35109                                  
 35110                                  ; This is a new module added to support loading programs into UMBs provided
 35111                                  ; by DOS 5.0. 
 35112                                  ; ---------------------------------------------------------------------------
 35113                                  ; Usage:
 35114                                  ;
 35115                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 35116                                  ;
 35117                                  ; <filespec> has to be a filename that is not wildcarded.
 35118                                  
 35119                                  ; ---------------------------------------------------------------------------
 35120                                  ;
 35121                                  ;	Revision History
 35122                                  ;	================
 35123                                  ;
 35124                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35125                                  ;				loading and high and also remember
 35126                                  ;				current UMB state.
 35127                                  ;
 35128                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35129                                  ;				to loadhigh batch files and invalid
 35130                                  ;				filename on Loadhigh command line.
 35131                                  ;
 35132                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35133                                  ;				after the program name also as part
 35134                                  ;				of the command line being passed to
 35135                                  ;				the program to be invoked.
 35136                                  ;
 35137                                  ; ---------------------------------------------------------------------------
 35138                                  
 35139                                  ; ---------------------------------------------------------------------------
 35140                                  ;
 35141                                  ;	include highload.inc		; Grab code for ParseVar and such
 35142                                  
 35143                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35144                                  
 35145                                  ;
 35146                                  ; ---------------------------------------------------------------------------
 35147                                  
 35148                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35149                                  ;
 35150                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35151                                  ;		CS = DS = SS = TRANGROUP
 35152                                  ;
 35153                                  ;	EXIT	None
 35154                                  ;
 35155                                  ;	USED	ax, bx, cx, dx, si, di, es
 35156                                  ;
 35157                                  ;	ERROR EXITS
 35158                                  ;		Message pointers are setup at the error locations and then
 35159                                  ;	we jump back to CERROR which is the transient error recycle point.
 35160                                  ;	Apart from parse errors, the other errors handled are too many
 35161                                  ;	switches anf invalid filenames.
 35162                                  ;
 35163                                  ;	EFFECTS
 35164                                  ;		The allocation strategy and the state of the arena chain are
 35165                                  ;	put in the requested state according to the given options. If a 
 35166                                  ;	filename is also given, it is executed as well.
 35167                                  ; ---------------------------------------------------------------------------
 35168                                  
 35169                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35170                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35171                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35172                                  LoadHigh:
 35173 0000567E 1E                      	push	ds
 35174 0000567F 07                      	pop	es
 35175                                  
 35176 00005680 E86B00                  	call	SkipLhDelims
 35177                                  
 35178                                  ;Get command tail to be passed to the program. This includes any whitespace
 35179                                  ;chars between the program name and its parameters as well.
 35180                                  ;On return, ds:si points at the start of the command tail.
 35181                                  
 35182 00005683 56                      	push	si
 35183 00005684 E81400                  	call	ParseLhCmd
 35184 00005687 5E                      	pop	si
 35185 00005688 720E                    	jc	short LhErr
 35186                                  	
 35187 0000568A E87900                  	call	SetupCmdLine		;setup pgm's command line
 35188                                  
 35189 0000568D E8CC00                  	call	SetupPath		;setup path for file
 35190 00005690 7206                    	jc	short LhErr		;file not found
 35191                                  
 35192                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35193                                  ;be reset after return from the Exec
 35194                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35195                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35196                                  
 35197 00005692 E8AA00                  	call	HideUMBs		;prepare upper-memory for load
 35198                                  
 35199 00005695 E96FD2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35200                                  
 35201                                  LhErr:
 35202                                  ;The error message has been setup at this stage
 35203                                  
 35204 00005698 E9BFD2                  	jmp	cerror			;print error message and recycle 
 35205                                  
 35206                                  ; ---------------------------------------------------------------------------
 35207                                  					
 35208                                  ;*** 	ParseLhCmd - parses any command-line options
 35209                                  ;
 35210                                  ;	ENTRY	None
 35211                                  ;
 35212                                  ;	EXIT	Carry clear -- command line parsed successfully
 35213                                  ;		Carry set -- appropriate error message setup
 35214                                  ;
 35215                                  ;	USED	ax, si
 35216                                  ;
 35217                                  ;	EFFECTS
 35218                                  ;		Options set up (see highvar.inc)
 35219                                  ;		Filename to be executed setup
 35220                                  ;
 35221                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35222                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35223                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35224                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35225                                  ;	prepare the command-line for that program.
 35226                                  ; ---------------------------------------------------------------------------
 35227                                  
 35228                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35229                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35230                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35231                                  ParseLhCmd:
 35232                                  	;mov	si,81h
 35233 0000569B BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35234                                  
 35235 0000569E C706[D78A]0000          	mov	word [COMSW],0
 35236 000056A4 BF[FC85]                	mov	di,Parse_LoadHi
 35237 000056A7 31C9                    	xor	cx,cx
 35238 000056A9 E812CB                  	call	Parse_With_Msg
 35239 000056AC 83F8FF                  	cmp	ax,0FFFFh ; -1
 35240 000056AF 740A                    	jz	short PLhCmd2
 35241 000056B1 83F800                  	cmp	ax,0
 35242 000056B4 7504                    	jnz	short PLhCmd1
 35243 000056B6 89D3                    	mov	bx,dx
 35244                                  	; 14/04/2023
 35245                                  	;call	LhCopyFilename
 35246                                  	;; 13/04/2023
 35247                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35248                                  	;;jmp	short PLhCmd2
 35249                                  	;retn
 35250                                  	; 14/04/2023
 35251 000056B8 EB02                    	jmp	short LhCopyFilename
 35252                                  PLhCmd1:
 35253 000056BA F9                      	stc
 35254                                  PLhCmd2:
 35255 000056BB C3                      	retn
 35256                                  
 35257                                  ; ---------------------------------------------------------------------------
 35258                                  
 35259                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35260                                  
 35261                                  ; ---------------------------------------------------------------------------
 35262                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35263                                  ; ---------------------------------------------------------------------------
 35264                                  
 35265                                  	; 13/04/2023
 35266                                  	; MSDOS 5.0 COMMAND.COM only !
 35267                                  	; (Procedure names are not from original Microsoft source code!)
 35268                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35269                                  ;set_strategy:
 35270                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35271                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35272                                  	;		; AL = function code: get allocation strategy
 35273                                  	;mov	bx,ax
 35274                                  	;or	bx,80h
 35275                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35276                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35277                                  	;		; AL = function code: set allocation strategy
 35278                                  	;retn
 35279                                  
 35280                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35281                                  ;set_umblink:
 35282                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35283                                  	;mov	bx,1
 35284                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35285                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35286                                  	;retn
 35287                                  
 35288                                  ; ---------------------------------------------------------------------------
 35289                                  
 35290                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35291                                  ;
 35292                                  ;	ENTRY	ds:si points at primary argument (filename)
 35293                                  ;
 35294                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35295                                  ;				already contain an appropriate error number.
 35296                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35297                                  ;				points to first character (most likely space)
 35298                                  ;				after filename.
 35299                                  ;
 35300                                  ;	USED	ax, si
 35301                                  ;
 35302                                  ;	EFFECTS
 35303                                  ;		ExecPath contains the filename
 35304                                  ;
 35305                                  ; If there are any wildcards in the filename, then we have an error
 35306                                  ; ---------------------------------------------------------------------------
 35307                                  
 35308                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35309                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35310                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35311                                  LhCopyFilename:
 35312 000056BC 1E                      	push	ds
 35313 000056BD 56                      	push	si
 35314 000056BE 57                      	push	di
 35315 000056BF C57704                  	lds	si,[bx+4]
 35316 000056C2 BF[E889]                	mov	di,EXECPATH
 35317                                  lhcpfn1:
 35318 000056C5 AC                      	lodsb
 35319 000056C6 3C2A                    	cmp	al,2Ah ; '*'
 35320 000056C8 740D                    	jz	short lhfilerr
 35321 000056CA 3C3F                    	cmp	al,3Fh ; '?'
 35322 000056CC 7409                    	jz	short lhfilerr
 35323 000056CE AA                      	stosb
 35324 000056CF 08C0                    	or	al,al
 35325 000056D1 75F2                    	jnz	short lhcpfn1
 35326                                  	; 14/04/2023
 35327                                  	; cf = 0
 35328                                  	;clc
 35329                                  lhfilerr2:
 35330 000056D3 5F                      	pop	di
 35331 000056D4 5E                      	pop	si
 35332 000056D5 1F                      	pop	ds
 35333 000056D6 C3                      	retn
 35334                                  lhfilerr:
 35335 000056D7 BA[BF81]                	mov	dx,LhInvFil_Ptr
 35336 000056DA F9                      	stc
 35337 000056DB EBF6                    	jmp	short lhfilerr2
 35338                                  
 35339                                  ; ---------------------------------------------------------------------------
 35340                                  	
 35341                                  	; 14/04/2023
 35342                                  	; 13/04/2023
 35343                                  	; MSDOS 5.0 COMMAND.COM only !
 35344                                  	; (Procedure name is not from original Microsoft source code!)
 35345                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35346                                  set_strategy:
 35347 000056DD B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35348 000056E0 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35349                                  			; AL = function code: get allocation strategy
 35350 000056E2 89C3                    	mov	bx,ax
 35351 000056E4 81CB8000                	or	bx,80h
 35352 000056E8 B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35353 000056EB CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35354                                  			; AL = function code: set allocation strategy
 35355 000056ED C3                      	retn
 35356                                  
 35357                                  ; ---------------------------------------------------------------------------
 35358                                  
 35359                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35360                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35361                                  	; MSDOS 5.0 COMMAND.COM only !
 35362                                  	; (Procedure name is not from original Microsoft source code!)
 35363                                  SkipLhDelims:
 35364 000056EE BE8100                  	mov	si,81h
 35365 000056F1 E8F2CE                  	call	scanoff
 35366                                  stfn1:
 35367 000056F4 AC                      	lodsb
 35368 000056F5 E8F6CE                  	call	DELIM
 35369 000056F8 740A                    	jz	short stfn2
 35370 000056FA 3C0D                    	cmp	al,0Dh
 35371 000056FC 7406                    	jz	short stfn2
 35372 000056FE 3A06[C48A]              	cmp	al,[SWITCHAR]
 35373 00005702 75F0                    	jnz	short stfn1
 35374                                  stfn2:
 35375 00005704 4E                      	dec	si
 35376 00005705 C3                      	retn
 35377                                  
 35378                                  ; ---------------------------------------------------------------------------
 35379                                  
 35380                                  ;***	SetupCmdLine -- prepare command line for the program
 35381                                  ;
 35382                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35383                                  ;
 35384                                  ;	EXIT	None
 35385                                  ;
 35386                                  ;	USED
 35387                                  ;
 35388                                  ;	EFFECTS		
 35389                                  ;		The rest of the command line following the pgm name is 
 35390                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35391                                  ;	and a new command line length is put in
 35392                                  ; ---------------------------------------------------------------------------
 35393                                  
 35394                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35395                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35396                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35397                                  SetupCmdLine:
 35398                                  	;mov	di,81h
 35399 00005706 BF8100                  	mov	di,iCmdLine
 35400 00005709 30C9                    	xor	cl,cl
 35401 0000570B FEC9                    	dec	cl			;just CR means count = 0
 35402                                  SetCmdL1:
 35403 0000570D AC                      	lodsb
 35404 0000570E AA                      	stosb
 35405 0000570F FEC1                    	inc	cl			;update count
 35406                                  	; 14/04/2023
 35407                                  	; * ; MSDOS 6.0 only !
 35408                                  	;or	al, al	; *
 35409                                  	;jz	short SetCmdL2 ; *
 35410 00005711 3C0D                    	cmp	al,0Dh			;carriage return?
 35411 00005713 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35412                                  SetCmdL2:
 35413 00005715 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35414 0000571A C3                      	retn
 35415                                  
 35416                                  ; ---------------------------------------------------------------------------
 35417                                  
 35418                                  ;***	LhSetupErrMsg -- Sets up error messages
 35419                                  ;
 35420                                  ;	ENTRY	ax = error message number
 35421                                  ;
 35422                                  ;	EXIT	None
 35423                                  ;
 35424                                  ;	USED	dx
 35425                                  ;
 35426                                  ;	EFFECTS
 35427                                  ;		Everything setup to display error message
 35428                                  ; ---------------------------------------------------------------------------
 35429                                  	
 35430                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35431                                  LhSetupErrMsg:
 35432 0000571B C606[537F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35433 00005720 BA[557F]                	mov	dx,extend_buf_ptr
 35434 00005723 A3[557F]                	mov	[extend_buf_ptr],ax
 35435 00005726 C3                      	retn
 35436                                  
 35437                                  ; ---------------------------------------------------------------------------
 35438                                  
 35439                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35440                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35441                                  	; MSDOS 5.0 COMMAND.COM only !
 35442                                  	; (Procedure name is not from original Microsoft source code!)
 35443                                  check_umblink:
 35444 00005727 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35445 0000572A CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35446                                  			 ; AL = function code: get allocation strategy
 35447 0000572C 88C3                    	mov	bl,al
 35448 0000572E B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35449 00005731 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35450                                  			; AL = function code: (DOS 5beta) get UMB link state
 35451 00005733 88C7                    	mov	bh,al
 35452 00005735 93                      	xchg	ax,bx
 35453 00005736 D0C0                    	rol	al,1
 35454 00005738 2401                    	and	al,1
 35455 0000573A D0E4                    	shl	ah,1
 35456 0000573C 08E0                    	or	al,ah
 35457 0000573E C3                      	retn
 35458                                  
 35459                                  ; ---------------------------------------------------------------------------
 35460                                  
 35461                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35462                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35463                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35464                                  HideUMBs:
 35465 0000573F 1E                      	push	ds
 35466 00005740 E8E4FF                  	call	check_umblink
 35467 00005743 8E1E[C08A]              	mov	ds,[RESSEG]
 35468 00005747 A2[3A04]                	mov	[fInHigh],al
 35469 0000574A 800E[3A04]80            	or	byte [fInHigh],80h
 35470 0000574F 1F                      	pop	ds
 35471 00005750 E88AFF                  	call	set_strategy
 35472                                  	;call	set_umblink
 35473                                  	;retn
 35474                                  	; 14/04/023
 35475                                  	;jmp	short set_ubmlink
 35476                                  
 35477                                  ; ---------------------------------------------------------------------------
 35478                                  
 35479                                  	; 14/04/2023
 35480                                  	; 13/04/2023
 35481                                  	; MSDOS 5.0 COMMAND.COM only !
 35482                                  	; (Procedure name is not from original Microsoft source code!)
 35483                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35484                                  set_umblink:
 35485 00005753 B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35486 00005756 BB0100                  	mov	bx,1
 35487 00005759 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35488                                  			; AL = function code: (DOS 5beta) set UMB link state
 35489 0000575B C3                      	retn
 35490                                  
 35491                                  ; ---------------------------------------------------------------------------
 35492                                  
 35493                                  ;***	SetupPath -- Do path search for the file to be executed
 35494                                  ;
 35495                                  ;	ENTRY	None
 35496                                  ;
 35497                                  ;	EXIT	Carry set if file not found or not executable file
 35498                                  ;
 35499                                  ;	EFFECTS
 35500                                  ;		ExecPath contains the full path of the file to be executed
 35501                                  ; ---------------------------------------------------------------------------
 35502                                  
 35503                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35504                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35505                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35506                                  SetupPath:
 35507                                  
 35508                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35509                                  ;because the path search routine that we are about to invoke expects the
 35510                                  ;filename to search for to be argv[0].
 35511                                  ;
 35512                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 35513                                  ;over it by doing the whole move again (smaller, of course, this time).
 35514                                  
 35515                                  
 35516                                  	;mov	ax,arg.argvcnt		;total number of arguments
 35517                                  	; 14/04/2023
 35518                                  	;mov	ax,[ARG_ARGVCNT]
 35519 0000575C A1[0F91]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 35520                                  
 35521 0000575F 48                      	dec	ax			;less one - skip "LoadHigh"
 35522                                  	;mov	bx,SIZE Argv_ele
 35523 00005760 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 35524                                  	;mov	bx,11
 35525 00005763 F7E3                    	mul	bx			;dx:ax = size of argument lists
 35526                                  
 35527                                  	; 14/04/2023
 35528 00005765 89C1                    	mov	cx,ax			;size to move
 35529                                  
 35530                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 35531                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 35532 00005767 BF[4F8E]                	mov	di,ARG	
 35533 0000576A 89FE                    	mov	si,di			;
 35534                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 35535 0000576C 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 35536                                  	
 35537                                  	; 14/04/2023
 35538                                  	;mov	cx,ax
 35539                                  
 35540 0000576F FC                      	cld
 35541 00005770 F3A4                    	rep	movsb			;Move the argument list
 35542                                  	
 35543                                  	;dec	arg.argvcnt		;Fake one less argument, and
 35544                                  	;dec	word [ARG_ARGVCNT]
 35545 00005772 FF0E[0F91]              	dec	word [ARG+ARG_UNIT.argvcnt]
 35546                                  	
 35547                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 35548                                  
 35549 00005776 E817DA                  	call	path_search		;look in the path
 35550                                  
 35551                                  ;ax = 0, no file found
 35552                                  ;ax < 4, batch file found -- cant be executed
 35553                                  ;ax = 4,8 => .com or .exe file found
 35554                                  
 35555 00005779 09C0                    	or	ax,ax			;any file found?
 35556 0000577B 740B                    	jz	short no_exec_file	;no, error
 35557                                  
 35558 0000577D 83F804                  	cmp	ax,4			;executable file?
 35559                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 35560                                  	;clc
 35561                                  	;retn
 35562                                  	; 14/04/2023
 35563 00005780 7201                    	jb	short no_exec_bat
 35564 00005782 C3                      	retn 
 35565                                  
 35566                                  no_exec_bat:
 35567 00005783 BA[BC81]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 35568 00005786 EB06                    	jmp	short lhsp_errret	;return error; M016
 35569                                  
 35570                                  no_exec_file:
 35571 00005788 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 35572 0000578B E88DFF                  	call	LhSetupErrMsg		;setup error message
 35573                                  lhsp_errret:				; M016
 35574 0000578E F9                      	stc
 35575 0000578F C3                      	retn
 35576                                  
 35577                                  ;============================================================================
 35578                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 35579                                  ;============================================================================
 35580                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35581                                  
 35582                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 35583                                  
 35584                                  ; ---------------------------------------------------------------------------
 35585                                  ; Class 3 message table/structure
 35586                                  ; ---------------------------------------------------------------------------
 35587                                  
 35588                                  $M_CLASS_3_STRUC:
 35589 00005790 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 35590 00005791 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 35591 00005793 A2                      	db 162			; Total number of messages
 35592                                  $M_ID_3_1:
 35593                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 35594 00005794 FC03                    	dw 1020			; Message Number = 1020
 35595 00005796 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 35596                                  $M_ID_3_2:
 35597 00005798 F703                    	dw 1015			; Message Number = 1015
 35598 0000579A 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 35599                                  $M_ID_3_3:	; 26/04/2023
 35600 0000579C EC03B402                	dw 1004,MSG_1004-$ ; 692
 35601 000057A0 0204CA02                	dw 1026,MSG_1026-$ ; 714
 35602 000057A4 0704DA02                	dw 1031,MSG_1031-$ ; 730
 35603 000057A8 0B04E502                	dw 1035,MSG_1035-$ ; 741
 35604 000057AC 2604F002                	dw 1062,MSG_1062-$ ; 752
 35605 000057B0 0404FB02                	dw 1028,MSG_1028-$ ; 763
 35606 000057B4 15041903                	dw 1045,MSG_1045-$ ; 793
 35607 000057B8 11043203                	dw 1041,MSG_1041-$ ; 818
 35608 000057BC 12045003                	dw 1042,MSG_1042-$ ; 848
 35609                                  $M_ID_3_12:
 35610 000057C0 13046703                	dw 1043,MSG_1043-$ ; 871
 35611 000057C4 EA038303                	dw 1002,MSG_1002-$ ; 899
 35612 000057C8 EB03A703                	dw 1003,MSG_1003-$ ; 935
 35613 000057CC EF03BF03                	dw 1007,MSG_1007-$ ; 959
 35614 000057D0 F003D603                	dw 1008,MSG_1008-$ ; 982
 35615 000057D4 F103E803                	dw 1009,MSG_1009-$ ; 1000
 35616 000057D8 F203F903                	dw 1010,MSG_1010-$ ; 1017
 35617 000057DC F3031504                	dw 1011,MSG_1011-$ ; 1045
 35618 000057E0 F6032C04                	dw 1014,MSG_1014-$ ; 1068
 35619 000057E4 F8033904                	dw 1016,MSG_1016-$ ; 1081
 35620 000057E8 F9035F04                	dw 1017,MSG_1017-$ ; 1119
 35621 000057EC FA038004                	dw 1018,MSG_1018-$ ; 1152
 35622                                  $M_ID_3_24:
 35623 000057F0 FB039004                	dw 1019,MSG_1019-$ ; 1168
 35624 000057F4 FD039804                	dw 1021,MSG_1021-$ ; 1176
 35625 000057F8 FE03B204                	dw 1022,MSG_1022-$ ; 1202
 35626 000057FC FF03D504                	dw 1023,MSG_1023-$ ; 1237
 35627 00005800 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 35628 00005804 01041005                	dw 1025,MSG_1025-$ ; 1296
 35629 00005808 03042405                	dw 1027,MSG_1027-$ ; 1316
 35630 0000580C 05044105                	dw 1029,MSG_1029-$ ; 1345
 35631 00005810 06044F05                	dw 1030,MSG_1030-$ ; 1359
 35632 00005814 08045A05                	dw 1032,MSG_1032-$ ; 1370
 35633 00005818 09046E05                	dw 1033,MSG_1033-$ ; 1390
 35634 0000581C 0A048005                	dw 1034,MSG_1034-$ ; 1408
 35635 00005820 0C049205                	dw 1036,MSG_1036-$ ; 1426
 35636 00005824 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 35637 00005828 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 35638 0000582C 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 35639                                  $M_ID_3_40:
 35640 00005830 1004F805                	dw 1040,MSG_1040-$ ; 1528
 35641 00005834 14040906                	dw 1044,MSG_1044-$ ; 1545
 35642 00005838 16041906                	dw 1046,MSG_1046-$ ; 1561
 35643 0000583C 17044C06                	dw 1047,MSG_1047-$ ; 1612
 35644 00005840 18046106                	dw 1048,MSG_1048-$ ; 1633
 35645 00005844 19046F06                	dw 1049,MSG_1049-$ ; 1647
 35646 00005848 1A047506                	dw 1050,MSG_1050-$ ; 1653
 35647 0000584C 1B049006                	dw 1051,MSG_1051-$ ; 1680
 35648 00005850 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 35649 00005854 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 35650 00005858 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 35651                                  $M_ID_3_51:
 35652 0000585C 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 35653 00005860 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 35654 00005864 21040A07                	dw 1057,MSG_1057-$ ; 1802
 35655 00005868 23041307                	dw 1059,MSG_1059-$ ; 1811
 35656 0000586C 24041407                	dw 1060,MSG_1060-$ ; 1812
 35657 00005870 25041407                	dw 1061,MSG_1061-$ ; 1812
 35658 00005874 27042A07                	dw 1063,MSG_1063-$ ; 1834
 35659 00005878 28042907                	dw 1064,MSG_1064-$ ; 1833
 35660 0000587C 29042807                	dw 1065,MSG_1065-$ ; 1832
 35661 00005880 2A042707                	dw 1066,MSG_1066-$ ; 1831
 35662 00005884 2B042607                	dw 1067,MSG_1067-$ ; 1830
 35663 00005888 2C042407                	dw 1068,MSG_1068-$ ; 1828
 35664 0000588C 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 35665 00005890 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 35666 00005894 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 35667 00005898 30042907                	dw 1072,MSG_1072-$ ; 1833
 35668                                  $M_ID_3_67:
 35669 0000589C 31042E07                	dw 1073,MSG_1073-$ ; 1838
 35670 000058A0 32043307                	dw 1074,MSG_1074-$ ; 1843
 35671 000058A4 33043807                	dw 1075,MSG_1075-$ ; 1848
 35672 000058A8 34043A07                	dw 1076,MSG_1076-$ ; 1850
 35673 000058AC 35043907                	dw 1077,MSG_1077-$ ; 1849
 35674 000058B0 36043D07                	dw 1078,MSG_1078-$ ; 1853
 35675 000058B4 37045407                	dw 1079,MSG_1079-$ ; 1876
 35676 000058B8 38045B07                	dw 1080,MSG_1080-$ ; 1883
 35677 000058BC 39046D07                	dw 1081,MSG_1081-$ ; 1901
 35678 000058C0 3C049407                	dw 1084,MSG_1084-$ ; 1940
 35679 000058C4 4204A007                	dw 1090,MSG_1090-$ ; 1952
 35680 000058C8 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 35681 000058CC 4404B407                	dw 1092,MSG_1092-$ ; 1972
 35682 000058D0 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 35683 000058D4 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 35684 000058D8 4704E807                	dw 1095,MSG_1095-$ ; 2024
 35685 000058DC 48040108                	dw 1096,MSG_1096-$ ; 2049
 35686                                  $M_ID_3_84:
 35687 000058E0 B0042E08                	dw 1200,MSG_1200-$ ; 2094
 35688 000058E4 14052B08                	dw 1300,MSG_1300-$ ; 2091
 35689 000058E8 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 35690 000058EC 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 35691 000058F0 3C055709                	dw 1340,MSG_1340-$ ; 2391
 35692 000058F4 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 35693 000058F8 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 35694 000058FC 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 35695 00005900 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 35696 00005904 7905420B                	dw 1401,MSG_1401-$ ; 2882
 35697 00005908 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 35698 0000590C 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 35699 00005910 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 35700 00005914 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 35701 00005918 A005630D                	dw 1440,MSG_1440-$ ; 3427
 35702 0000591C A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 35703                                  $M_ID_3_100:
 35704 00005920 B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 35705 00005924 B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 35706 00005928 B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 35707 0000592C C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 35708 00005930 C905D90F                	dw 1481,MSG_1481-$ ; 4057
 35709 00005934 CA053310                	dw 1482,MSG_1482-$ ; 4147
 35710 00005938 CB059110                	dw 1483,MSG_1483-$ ; 4241
 35711 0000593C CC050811                	dw 1484,MSG_1484-$ ; 4360
 35712 00005940 CD05C411                	dw 1485,MSG_1485-$ ; 4548
 35713 00005944 CE055C12                	dw 1486,MSG_1486-$ ; 4700
 35714 00005948 CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 35715 0000594C D0055213                	dw 1488,MSG_1488-$ ; 4946
 35716                                  $M_ID_3_112:
 35717 00005950 DC05E113                	dw 1500,MSG_1500-$ ; 5089
 35718 00005954 F0051C14                	dw 1520,MSG_1520-$ ; 5148
 35719 00005958 04065614                	dw 1540,MSG_1540-$ ; 5206
 35720 0000595C 0506B014                	dw 1541,MSG_1541-$ ; 5296
 35721 00005960 06061815                	dw 1542,MSG_1542-$ ; 5400
 35722 00005964 18065015                	dw 1560,MSG_1560-$ ; 5456
 35723 00005968 19068415                	dw 1561,MSG_1561-$ ; 5508
 35724 0000596C 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 35725 00005970 1B062916                	dw 1563,MSG_1563-$ ; 5673
 35726 00005974 1C065016                	dw 1564,MSG_1564-$ ; 5712
 35727 00005978 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 35728 0000597C 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 35729 00005980 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 35730 00005984 20065A17                	dw 1568,MSG_1568-$ ; 5978
 35731 00005988 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 35732                                  $M_ID_3_127:
 35733 0000598C 4006E717                	dw 1600,MSG_1600-$ ; 6119
 35734 00005990 41060018                	dw 1601,MSG_1601-$ ; 6144
 35735 00005994 42065018                	dw 1602,MSG_1602-$ ; 6224
 35736 00005998 54069A18                	dw 1620,MSG_1620-$ ; 6298
 35737 0000599C 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 35738 000059A0 56066C19                	dw 1622,MSG_1622-$ ; 6508
 35739 000059A4 6806B419                	dw 1640,MSG_1640-$ ; 6580
 35740 000059A8 6906E519                	dw 1641,MSG_1641-$ ; 6629
 35741 000059AC 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 35742 000059B0 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 35743 000059B4 A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 35744 000059B8 B806781B                	dw 1720,MSG_1720-$ ; 7032
 35745 000059BC CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 35746 000059C0 CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 35747 000059C4 E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 35748 000059C8 F406D71C                	dw 1780,MSG_1780-$ ; 7383
 35749                                  $M_ID_3_143:
 35750 000059CC 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 35751 000059D0 0907891D                	dw 1801,MSG_1801-$ ; 7561
 35752 000059D4 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 35753 000059D8 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 35754 000059DC 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 35755 000059E0 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 35756 000059E4 4507461F                	dw 1861,MSG_1861-$ ; 8006
 35757 000059E8 4607891F                	dw 1862,MSG_1862-$ ; 8073
 35758 000059EC 47070320                	dw 1863,MSG_1863-$ ; 8195
 35759 000059F0 4807A220                	dw 1864,MSG_1864-$ ; 8354
 35760 000059F4 49070521                	dw 1865,MSG_1865-$ ; 8453
 35761 000059F8 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 35762 000059FC 5807D021                	dw 1880,MSG_1880-$ ; 8656
 35763 00005A00 59074422                	dw 1881,MSG_1881-$ ; 8772
 35764 00005A04 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 35765 00005A08 5B071123                	dw 1883,MSG_1883-$ ; 8977
 35766 00005A0C 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 35767 00005A10 8007C423                	dw 1920,MSG_1920-$ ; 9156
 35768 00005A14 8107F023                	dw 1921,MSG_1921-$ ; 9200
 35769                                  $M_ID_3_162:
 35770 00005A18 8207                    	dw 1922			; Message Number = 1922
 35771 00005A1A 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 35772                                  
 35773                                  ; ---------------------------------------------------------------------------
 35774                                  ; Class 3 messages
 35775                                  ; ---------------------------------------------------------------------------
 35776                                  	
 35777                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35778                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 35779                                  
 35780                                  MSG_1020:	; COMMON4
 35781 00005A1C 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 35782 00005A1D 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 35782 00005A26 667265650D0A       
 35783                                  MSG_1015:	; COMMON18
 35784 00005A2C 23                      	db 35
 35785 00005A2D 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 35785 00005A36 6F7420626520636F70-
 35785 00005A3F 696564206F6E746F20-
 35785 00005A48 697473656C660D0A   
 35786                                  MSG_1004:	; COMMON20
 35787 00005A50 19                      	db 25
 35788 00005A51 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 35788 00005A5A 656E74206469736B20-
 35788 00005A63 73706163650D0A     
 35789                                  MSG_1026:	; COMMON22
 35790 00005A6A 13                      	db 19
 35791 00005A6B 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 35791 00005A74 6F646520706167650D-
 35791 00005A7D 0A                 
 35792                                  MSG_1031:	; COMMON23
 35793 00005A7E 0E                      	db 14
 35794 00005A7F 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 35794 00005A88 6174650D0A         
 35795                                  MSG_1035:	; COMMON24
 35796 00005A8D 0E                      	db 14
 35797 00005A8E 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 35797 00005A97 696D650D0A         
 35798                                  MSG_1062:	; COMMON25
 35799 00005A9C 0E                      	db 14
 35800 00005A9D 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 35800 00005AA6 6174680D0A         
 35801                                  MSG_1028:	; COMMON28
 35802 00005AAB 21                      	db 33
 35803 00005AAC 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 35803 00005AB5 206B657920746F2063-
 35803 00005ABE 6F6E74696E7565202E-
 35803 00005AC7 202E202E0D0A       
 35804                                  MSG_1045:	; COMMON32
 35805 00005ACD 1C                      	db 28
 35806 00005ACE 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 35806 00005AD7 206372656174652064-
 35806 00005AE0 69726563746F72790D-
 35806 00005AE9 0A                 
 35807                                  MSG_1041:	; COMMON33
 35808 00005AEA 21                      	db 33
 35809 00005AEB 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 35809 00005AF4 206472697665202531-
 35809 00005AFD 20686173206E6F206C-
 35809 00005B06 6162656C0D0A       
 35810                                  MSG_1042:	; COMMON34
 35811 00005B0C 1A                      	db 26
 35812 00005B0D 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 35812 00005B16 206472697665202531-
 35812 00005B1F 2069732025320D0A   
 35813                                  MSG_1043:	; COMMON36
 35814 00005B27 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 35815 00005B28 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 35815 00005B31 7269616C204E756D62-
 35815 00005B3A 65722069732025312D-
 35815 00005B43 25320D0A           
 35816                                  MSG_1002:
 35817 00005B47 27                              db 39
 35818 00005B48 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 35818 00005B51 2066696C65206E616D-
 35818 00005B5A 65206F722066696C65-
 35818 00005B63 206E6F7420666F756E-
 35818 00005B6C 640D0A             
 35819                                  MSG_1003:
 35820 00005B6F 1B                      	db 27
 35821 00005B70 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 35821 00005B79 617468206F72206669-
 35821 00005B82 6C65206E616D650D0A 
 35822                                  MSG_1007:
 35823 00005B8B 1A                      	db 26
 35824 00005B8C 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 35824 00005B95 7669726F6E6D656E74-
 35824 00005B9E 2073706163650D0A   
 35825                                  MSG_1008:
 35826 00005BA6 15                      	db 21
 35827 00005BA7 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 35827 00005BB0 74696F6E206572726F-
 35827 00005BB9 720D0A             
 35828                                  MSG_1009:
 35829 00005BBC 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 35830 00005BBD 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 35830 00005BC6 65206D697373696E67-
 35830 00005BCF 0D0A               
 35831                                  MSG_1010:
 35832 00005BD1 1F                      	db 31
 35833 00005BD2 0D0A                    	db 0Dh,0Ah
 35834 00005BD4 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 35834 00005BDD 736B20776974682062-
 35834 00005BE6 617463682066696C65-
 35834 00005BEF 0D0A               
 35835                                  MSG_1011:
 35836 00005BF1 1A                      	db 26
 35837 00005BF2 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 35837 00005BFB 6E64206F722066696C-
 35837 00005C04 65206E616D650D0A   
 35838                                  MSG_1014:	; EXTEND5
 35839 00005C0C 10                      	db 16
 35840 00005C0D 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 35840 00005C16 6E696564200D0A     
 35841                                  MSG_1016:
 35842 00005C1D 29                      	db 41
 35843 00005C1E 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 35843 00005C27 662064657374696E61-
 35843 00005C30 74696F6E206C6F7374-
 35843 00005C39 206265666F72652063-
 35843 00005C42 6F70790D0A         
 35844                                  MSG_1017:
 35845 00005C47 24                      	db 36
 35846 00005C48 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 35846 00005C51 696C656E616D65206F-
 35846 00005C5A 722066696C65206E6F-
 35846 00005C63 7420666F756E640D0A 
 35847                                  MSG_1018:
 35848 00005C6C 13                      	db 19
 35849 00005C6D 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 35849 00005C76 2920636F706965640D-
 35849 00005C7F 0A                 
 35850                                  MSG_1019:
 35851 00005C80 0B                      	db 11
 35852 00005C81 25312066696C652873-     	db '%1 file(s) '
 35852 00005C8A 2920               
 35853                                  MSG_1021:	; EXTEND15
 35854 00005C8C 1D                      	db 29
 35855 00005C8D 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 35855 00005C96 726976652073706563-
 35855 00005C9F 696669636174696F6E-
 35855 00005CA8 0D0A               
 35856                                  MSG_1022:
 35857 00005CAA 26                      	db 38
 35858 00005CAB 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 35858 00005CB4 202531206E6F742070-
 35858 00005CBD 726570617265642066-
 35858 00005CC6 6F722073797374656D-
 35858 00005CCF 0D0A               
 35859                                  MSG_1023:
 35860 00005CD1 2B                      	db 43
 35861 00005CD2 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 35861 00005CDB 202531206E6F742070-
 35861 00005CE4 726570617265642066-
 35861 00005CED 6F7220616C6C206465-
 35861 00005CF6 76696365730D0A     
 35862                                  MSG_1024:
 35863 00005CFD 16                      	db 22
 35864 00005CFE 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 35864 00005D07 646520706167653A20-
 35864 00005D10 25310D0A           
 35865                                  MSG_1025:
 35866 00005D14 17                      	db 23
 35867 00005D15 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 35867 00005D1E 6F7420696E7374616C-
 35867 00005D27 6C65640D0A         
 35868                                  MSG_1027:
 35869 00005D2C 20                      	db 32
 35870 00005D2D 43757272656E742064-     	db 'Current drive is no longer valid'
 35870 00005D36 72697665206973206E-
 35870 00005D3F 6F206C6F6E67657220-
 35870 00005D48 76616C6964         
 35871                                  MSG_1029:
 35872 00005D4D 11                      	db 17
 35873 00005D4E 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 35873 00005D57 20666F756E640D0A   
 35874                                  MSG_1030:
 35875 00005D5F 0E                      	db 14
 35876 00005D60 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 35876 00005D69 726F720D0A         
 35877                                  MSG_1032:
 35878 00005D6E 17                      	db 23
 35879 00005D6F 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 35879 00005D78 617465206973202531-
 35879 00005D81 2025320D0A         
 35880                                  MSG_1033:
 35881 00005D86 15                      	db 21
 35882 00005D87 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 35882 00005D90 576564546875467269-
 35882 00005D99 536174             
 35883                                  MSG_1034:
 35884 00005D9C 15                      	db 21
 35885 00005D9D 456E746572206E6577-     	db 'Enter new date (%1): '
 35885 00005DA6 206461746520282531-
 35885 00005DAF 293A20             
 35886                                  MSG_1036:
 35887 00005DB2 14                      	db 20
 35888 00005DB3 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 35888 00005DBC 696D65206973202531-
 35888 00005DC5 0D0A               
 35889                                  MSG_1037:
 35890 00005DC7 10                      	db 16
 35891 00005DC8 456E746572206E6577-     	db 'Enter new time: '
 35891 00005DD1 2074696D653A20     
 35892                                  MSG_1038:
 35893 00005DD8 12                              db 18
 35894 00005DD9 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 35894 00005DE2 74652028592F4E293F 
 35895                                  MSG_1039:
 35896 00005DEB 3C                              db 60
 35897 00005DEC 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 35897 00005DF5 20696E206469726563-
 35897 00005DFE 746F72792077696C6C-
 35897 00005E07 2062652064656C6574-
 35897 00005E10 6564210D0A         
 35898 00005E15 41726520796F752073-     	db 'Are you sure (Y/N)?'
 35898 00005E1E 7572652028592F4E29-
 35898 00005E27 3F                 
 35899                                  MSG_1040:
 35900 00005E28 14                      	db 20
 35901 00005E29 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 35901 00005E32 7273696F6E2025312E-
 35901 00005E3B 2532               
 35902                                  MSG_1044:
 35903 00005E3D 13                      	db 19
 35904 00005E3E 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 35904 00005E47 69726563746F72790D-
 35904 00005E50 0A                 
 35905                                  MSG_1046:
 35906 00005E51 36                      	db 54
 35907 00005E52 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 35907 00005E5B 6174682C206E6F7420-
 35907 00005E64 6469726563746F7279-
 35907 00005E6D 2C0D0A             
 35908 00005E70 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 35908 00005E79 6F7279206E6F742065-
 35908 00005E82 6D7074790D0A       
 35909                                  MSG_1047:
 35910 00005E88 18                      	db 24
 35911 00005E89 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 35911 00005E92 696679204F4E206F72-
 35911 00005E9B 204F46460D0A       
 35912                                  MSG_1048:
 35913 00005EA1 11                      	db 17
 35914 00005EA2 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 35914 00005EAB 206F662025310D0A   
 35915                                  MSG_1049:
 35916 00005EB3 09                      	db 9
 35917 00005EB4 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 35918                                  MSG_1050:
 35919 00005EBD 1E                      	db 30
 35920 00005EBE 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 35920 00005EC7 7269766520696E2073-
 35920 00005ED0 656172636820706174-
 35920 00005ED9 680D0A             
 35921                                  MSG_1051:
 35922 00005EDC 10                      	db 16
 35923 00005EDD 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 35923 00005EE6 65766963650D0A     
 35924                                  MSG_1052:
 35925 00005EED 16                      	db 22
 35926 00005EEE 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 35926 00005EF7 74206265206E657374-
 35926 00005F00 65640D0A           
 35927                                  MSG_1053:
 35928 00005F04 25                      	db 37
 35929 00005F05 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 35929 00005F0E 6174652066696C6520-
 35929 00005F17 6572726F7220647572-
 35929 00005F20 696E6720706970650D-
 35929 00005F29 0A                 
 35930                                  MSG_1054:
 35931 00005F2A 26                      	db 38
 35932 00005F2B 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 35932 00005F34 2062696E6172792072-
 35932 00005F3D 656164732066726F6D-
 35932 00005F46 206120646576696365-
 35932 00005F4F 0D0A               
 35933                                  
 35934                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 35935                                  MSG_1055:
 35936 00005F51 0D                      	db 13
 35937 00005F52 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 35937 00005F5B 25310D0A           
 35938                                  MSG_1056:
 35939 00005F5F 0E                      	db 14
 35940 00005F60 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 35940 00005F69 2025310D0A         
 35941                                  MSG_1057:
 35942 00005F6E 0C                      	db 12
 35943 00005F6F 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 35943 00005F78 310D0A             
 35944                                  MSG_1059:
 35945 00005F7B 04                      	db 4
 35946 00005F7C 6F666600                	db 'off',0
 35947                                  MSG_1060:
 35948 00005F80 03                      	db 3
 35949 00005F81 6F6E00                  	db 'on',0
 35950                                  MSG_1061:
 35951 00005F84 19                      	db 25
 35952 00005F85 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 35952 00005F8E 74696E6720746F2064-
 35952 00005F97 65766963650D0A     
 35953                                  MSG_1063:
 35954 00005F9E 02                      	db 2
 35955 00005F9F 2531                    	db '%1'
 35956                                  MSG_1064:
 35957 00005FA1 02                      	db 2
 35958 00005FA2 2531                    	db '%1'
 35959                                  MSG_1065:
 35960 00005FA4 02                      	db 2
 35961 00005FA5 2531                    	db '%1'
 35962                                  MSG_1066:
 35963 00005FA7 02                      	db 2
 35964 00005FA8 2531                    	db '%1'
 35965                                  MSG_1067:
 35966 00005FAA 01                      	db 1
 35967 00005FAB 09                      	db 9
 35968                                  MSG_1068:
 35969 00005FAC 0A                      	db 10
 35970 00005FAD 203C4449523E202020-     	db ' <DIR>    '
 35970 00005FB6 20                 
 35971                                  MSG_1069:
 35972 00005FB7 03                      	db 3
 35973 00005FB8 082008                  	db 8, 20h, 8
 35974                                  MSG_1070:	; CRLF		
 35975 00005FBB 02                      	db 2
 35976 00005FBC 0D                      	db 0Dh
 35977 00005FBD 0A                      	db 0Ah
 35978                                  MSG_1071:
 35979 00005FBE 02                      	db 2
 35980 00005FBF 2531                    	db '%1'
 35981                                  MSG_1072:
 35982 00005FC1 08                      	db 8
 35983 00005FC2 6D6D2D64642D7979        	db 'mm-dd-yy'
 35984                                  MSG_1073:
 35985 00005FCA 08                      	db 8
 35986 00005FCB 64642D6D6D2D7979        	db 'dd-mm-yy'
 35987                                  MSG_1074:
 35988 00005FD3 08                      	db 8
 35989 00005FD4 79792D6D6D2D6464        	db 'yy-mm-dd'
 35990                                  MSG_1075:
 35991 00005FDC 05                      	db 5
 35992 00005FDD 2531202532              	db '%1 %2'
 35993                                  MSG_1076:
 35994 00005FE2 02                      	db 2
 35995 00005FE3 2531                    	db '%1'
 35996                                  MSG_1077:
 35997 00005FE5 07                      	db 7
 35998 00005FE6 20253120202532          	db ' %1  %2'
 35999                                  MSG_1078:
 36000 00005FED 1A                      	db 26
 36001 00005FEE 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 36001 00005FF7 20616C726561647920-
 36001 00006000 6578697374730D0A   
 36002                                  MSG_1079:
 36003 00006008 0A                      	db 10
 36004 00006009 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 36004 00006012 0A                 
 36005                                  MSG_1080:
 36006 00006013 15                      	db 21
 36007 00006014 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 36007 0000601D 6573206C6973746564-
 36007 00006026 3A0D0A             
 36008                                  MSG_1081:
 36009 00006029 2A                      	db 42
 36010 0000602A 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 36010 00006033 63757272656420696E-
 36010 0000603C 20656E7669726F6E6D-
 36010 00006045 656E74207661726961-
 36010 0000604E 626C65290D0A       
 36011                                  MSG_1084:
 36012 00006054 0F                      	db 15
 36013 00006055 28636F6E74696E7569-     	db '(continuing %1)'
 36013 0000605E 6E6720253129       
 36014                                  MSG_1090:
 36015 00006064 0D                      	db 13
 36016 00006065 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 36016 0000606E 25310D0A           
 36017                                  MSG_1091:
 36018 00006072 0D                      	db 13
 36019 00006073 444F5320697320696E-     	db 'DOS is in ROM'
 36019 0000607C 20524F4D           
 36020                                  MSG_1092:
 36021 00006080 0D                      	db 13
 36022 00006081 444F5320697320696E-     	db 'DOS is in HMA'
 36022 0000608A 20484D41           
 36023                                  MSG_1093:
 36024 0000608E 14                      	db 20
 36025 0000608F 444F5320697320696E-     	db 'DOS is in low memory'
 36025 00006098 206C6F77206D656D6F-
 36025 000060A1 7279               
 36026                                  MSG_1094:
 36027 000060A3 1C                      	db 28
 36028 000060A4 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 36028 000060AD 616468696768206261-
 36028 000060B6 7463682066696C650D-
 36028 000060BF 0A                 
 36029                                  MSG_1095:
 36030 000060C0 1C                      	db 28
 36031 000060C1 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 36031 000060CA 20496E76616C696420-
 36031 000060D3 66696C656E616D650D-
 36031 000060DC 0A                 
 36032                                  MSG_1096:
 36033 000060DD 30                      	db 48
 36034 000060DE 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 36034 000060E7 656E20737065636966-
 36034 000060F0 69656420636F756E74-
 36034 000060F9 727920696E666F726D-
 36034 00006102 6174696F6E2066696C-
 36034 0000610B 650D0A             
 36035                                  
 36036                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 36037                                  MSG_1200:
 36038 0000610E 00                      	db 0	; /? unimplemented
 36039                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 36040                                  MSG_1300:
 36041 0000610F 86                      	db 134
 36042 00006110 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 36042 00006119 6C6561727320657874-
 36042 00006122 656E64656420435452-
 36042 0000612B 4C2B4320636865636B-
 36042 00006134 696E672E0D0A       
 36043 0000613A 0D0A                    	db 0Dh,0Ah
 36044 0000613C 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 36044 00006145 207C204F46465D0D0A 
 36045 0000614E 0D0A                    	db 0Dh,0Ah
 36046 00006150 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 36046 00006159 4B20776974686F7574-
 36046 00006162 206120706172616D65-
 36046 0000616B 74657220746F206469-
 36046 00006174 73706C617920746865-
 36046 0000617D 2063757272656E7420-
 36046 00006186 425245414B20736574-
 36046 0000618F 74696E672E0D0A     
 36047                                  MSG_1320:
 36048 00006196 3F                      	db 63
 36049 00006197 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 36049 000061A0 6F7220736574732074-
 36049 000061A9 686520616374697665-
 36049 000061B2 20636F646520706167-
 36049 000061BB 65206E756D6265722E-
 36049 000061C4 0D0A               
 36050 000061C6 0D0A                    	db 0Dh,0Ah
 36051 000061C8 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 36051 000061D1 5D0D0A             
 36052 000061D4 0D0A                    	db 0Dh,0Ah
 36053                                  MSG_1321:
 36054 000061D6 70                      	db 112
 36055 000061D7 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 36055 000061E0 706563696669657320-
 36055 000061E9 6120636F6465207061-
 36055 000061F2 6765206E756D626572-
 36055 000061FB 2E0D0A             
 36056 000061FE 0D0A                    	db 0Dh,0Ah
 36057 00006200 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 36057 00006209 20776974686F757420-
 36057 00006212 6120706172616D6574-
 36057 0000621B 657220746F20646973-
 36057 00006224 706C61792074686520-
 36057 0000622D 61637469766520636F-
 36057 00006236 64652070616765206E-
 36057 0000623F 756D6265722E0D0A   
 36058                                  MSG_1340:
 36059 00006247 5B                      	db 91
 36060 00006248 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 36060 00006251 746865206E616D6520-
 36060 0000625A 6F66206F7220636861-
 36060 00006263 6E6765732074686520-
 36060 0000626C 63757272656E742064-
 36060 00006275 69726563746F72792E-
 36060 0000627E 0D0A               
 36061 00006280 0D0A                    	db 0Dh,0Ah
 36062 00006282 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 36062 0000628B 6976653A5D5B706174-
 36062 00006294 685D0D0A           
 36063 00006298 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 36063 000062A1 0D0A               
 36064                                  MSG_1341:
 36065 000062A3 62                      	db 98
 36066 000062A4 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 36066 000062AD 3A5D5B706174685D0D-
 36066 000062B6 0A                 
 36067 000062B7 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 36068 000062BF 0D0A                    	db 0Dh,0Ah
 36069 000062C1 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 36069 000062CA 656369666965732074-
 36069 000062D3 68617420796F752077-
 36069 000062DC 616E7420746F206368-
 36069 000062E5 616E676520746F2074-
 36069 000062EE 686520706172656E74-
 36069 000062F7 206469726563746F72-
 36069 00006300 792E               
 36070 00006302 0D0A                    	db 0Dh,0Ah
 36071 00006304 0D0A                    	db 0Dh,0Ah
 36072                                  MSG_1342:
 36073 00006306 91                      	db 145
 36074 00006307 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 36074 00006310 726976653A20746F20-
 36074 00006319 646973706C61792074-
 36074 00006322 68652063757272656E-
 36074 0000632B 74206469726563746F-
 36074 00006334 727920696E20746865-
 36074 0000633D 207370656369666965-
 36074 00006346 6420               
 36075 00006348 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 36076 00006350 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 36076 00006359 6974686F7574207061-
 36076 00006362 72616D657465727320-
 36076 0000636B 746F20646973706C61-
 36076 00006374 792074686520637572-
 36076 0000637D 72656E742064726976-
 36076 00006386 6520616E6420646972-
 36076 0000638F 6563746F72792E0D0A 
 36077                                  MSG_1360:
 36078 00006398 1B                      	db 27
 36079 00006399 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 36079 000063A2 652073637265656E2E-
 36079 000063AB 0D0A               
 36080 000063AD 0D0A                    	db 0Dh,0Ah
 36081 000063AF 434C530D0A              	db 'CLS',0Dh,0Ah
 36082                                  MSG_1400:
 36083 000063B4 91                      	db 145
 36084 000063B5 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 36084 000063BE 65206F72206D6F7265-
 36084 000063C7 2066696C657320746F-
 36084 000063D0 20616E6F7468657220-
 36084 000063D9 6C6F636174696F6E2E-
 36084 000063E2 0D0A               
 36085 000063E4 0D0A                    	db 0Dh,0Ah
 36086 000063E6 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 36086 000063EF 7C202F425D20736F75-
 36086 000063F8 726365205B2F41207C-
 36086 00006401 202F425D205B2B2073-
 36086 0000640A 6F75726365205B2F41-
 36086 00006413 207C202F425D205B2B-
 36086 0000641C 202E2E2E5D5D205B64-
 36086 00006425 657374696E6174696F-
 36086 0000642E 6E0D0A             
 36087 00006431 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 36087 0000643A 425D5D205B2F565D0D-
 36087 00006443 0A                 
 36088 00006444 0D0A                    	db 0Dh,0Ah
 36089                                  MSG_1401:
 36090 00006446 68                      	db 104
 36091 00006447 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 36091 00006450 202020202020537065-
 36091 00006459 636966696573207468-
 36091 00006462 652066696C65206F72-
 36091 0000646B 2066696C657320746F-
 36091 00006474 20626520636F706965-
 36091 0000647D 642E0D0A           
 36092 00006481 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 36092 0000648A 202020202020496E64-
 36092 00006493 69636174657320616E-
 36092 0000649C 204153434949207465-
 36092 000064A5 78742066696C652E0D-
 36092 000064AE 0A                 
 36093                                  MSG_1402:
 36094 000064AF 76                      	db 118
 36095 000064B0 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 36095 000064B9 202020202020496E64-
 36095 000064C2 696361746573206120-
 36095 000064CB 62696E617279206669-
 36095 000064D4 6C652E0D0A         
 36096 000064D9 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 36096 000064E2 74696F6E2020537065-
 36096 000064EB 636966696573207468-
 36096 000064F4 65206469726563746F-
 36096 000064FD 727920616E642F6F72-
 36096 00006506 2066696C656E616D65-
 36096 0000650F 20666F722074686520-
 36096 00006518 6E65772066696C6528-
 36096 00006521 73292E0D0A         
 36097                                  MSG_1403:	
 36098 00006526 41                      	db 65
 36099 00006527 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 36099 00006530 202020202020566572-
 36099 00006539 696669657320746861-
 36099 00006542 74206E65772066696C-
 36099 0000654B 657320617265207772-
 36099 00006554 697474656E20636F72-
 36099 0000655D 726563746C792E0D0A 
 36100 00006566 0D0A                    	db 0Dh,0Ah
 36101                                  MSG_1404:
 36102 00006568 87                      	db 135
 36103 00006569 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 36103 00006572 2066696C65732C2073-
 36103 0000657B 706563696679206120-
 36103 00006584 73696E676C65206669-
 36103 0000658D 6C6520666F72206465-
 36103 00006596 7374696E6174696F6E-
 36103 0000659F 2C20627574206D756C-
 36103 000065A8 7469706C652066696C-
 36103 000065B1 65730D0A           
 36104 000065B5 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 36104 000065BE 6520287573696E6720-
 36104 000065C7 77696C646361726473-
 36104 000065D0 206F722066696C6531-
 36104 000065D9 2B66696C65322B6669-
 36104 000065E2 6C653320666F726D61-
 36104 000065EB 74292E0D0A         
 36105                                  MSG_1420:
 36106 000065F0 8A                      	db 138
 36107 000065F1 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 36107 000065FA 6865207465726D696E-
 36107 00006603 616C20646576696365-
 36107 0000660C 207573656420746F20-
 36107 00006615 636F6E74726F6C2079-
 36107 0000661E 6F7572207379737465-
 36107 00006627 6D2E0D0A           
 36108 0000662B 0D0A                    	db 0Dh,0Ah
 36109 0000662D 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 36109 00006636 63650D0A           
 36110 0000663A 0D0A                    	db 0Dh,0Ah
 36111 0000663C 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 36111 00006645 202054686520746572-
 36111 0000664E 6D696E616C20646576-
 36111 00006657 69636520796F752077-
 36111 00006660 616E7420746F207573-
 36111 00006669 652C20737563682061-
 36111 00006672 7320434F4D312E0D0A 
 36112                                  MSG_1440:
 36113 0000667B 2D                      	db 45
 36114 0000667C 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 36114 00006685 6F7220736574732074-
 36114 0000668E 686520646174652E0D-
 36114 00006697 0A                 
 36115 00006698 0D0A                    	db 0Dh,0Ah
 36116 0000669A 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 36116 000066A3 655D0D0A           
 36117 000066A7 0D0A                    	db 0Dh,0Ah
 36118                                  MSG_1441:
 36119 000066A9 83                      	db 131
 36120 000066AA 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 36120 000066B3 20776974686F757420-
 36120 000066BC 706172616D65746572-
 36120 000066C5 7320746F2064697370-
 36120 000066CE 6C6179207468652063-
 36120 000066D7 757272656E74206461-
 36120 000066E0 74652073657474696E-
 36120 000066E9 6720616E640D0A     
 36121 000066F0 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 36121 000066F9 666F722061206E6577-
 36121 00006702 206F6E652E20205072-
 36121 0000670B 65737320454E544552-
 36121 00006714 20746F206B65657020-
 36121 0000671D 7468652073616D6520-
 36121 00006726 646174652E0D0A     
 36122                                  MSG_1460:	
 36123 0000672D 64                      	db 100
 36124 0000672E 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36124 00006737 6E65206F72206D6F72-
 36124 00006740 652066696C65732E0D-
 36124 00006749 0A                 
 36125 0000674A 0D0A                    	db 0Dh,0Ah
 36126 0000674C 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36126 00006755 653A5D5B706174685D-
 36126 0000675E 66696C656E616D6520-
 36126 00006767 5B2F505D0D0A       
 36127 0000676D 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36127 00006776 6976653A5D5B706174-
 36127 0000677F 685D66696C656E616D-
 36127 00006788 65205B2F505D0D0A   
 36128 00006790 0D0A                    	db 0Dh,0Ah
 36129                                  MSG_1461:
 36130 00006792 83                      	db 131
 36131 00006793 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36131 0000679C 5D5B706174685D6669-
 36131 000067A5 6C656E616D65202053-
 36131 000067AE 706563696669657320-
 36131 000067B7 7468652066696C6528-
 36131 000067C0 732920746F2064656C-
 36131 000067C9 6574652E2020537065-
 36131 000067D2 63696679206D756C74-
 36131 000067DB 69706C650D0A       
 36132 000067E1 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36132 000067EA 202020202020202020-
 36132 000067F3 202020202020202066-
 36132 000067FC 696C65732062792075-
 36132 00006805 73696E672077696C64-
 36132 0000680E 63617264732E0D0A   
 36133                                  MSG_1462:
 36134 00006816 4F                      	db 79
 36135 00006817 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36135 00006820 202020202020202020-
 36135 00006829 202020202020202050-
 36135 00006832 726F6D70747320666F-
 36135 0000683B 7220636F6E6669726D-
 36135 00006844 6174696F6E20626566-
 36135 0000684D 6F72652064656C6574-
 36135 00006856 696E67206561636820-
 36135 0000685F 66696C652E0D0A     
 36136                                  MSG_1480:
 36137 00006866 A2                      	db 162
 36138 00006867 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36138 00006870 61206C697374206F66-
 36138 00006879 2066696C657320616E-
 36138 00006882 642073756264697265-
 36138 0000688B 63746F726965732069-
 36138 00006894 6E2061206469726563-
 36138 0000689D 746F72792E0D0A     
 36139 000068A4 0D0A                    	db 0Dh,0Ah
 36140 000068A6 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36140 000068AF 653A5D5B706174685D-
 36140 000068B8 5B66696C656E616D65-
 36140 000068C1 5D205B2F505D205B2F-
 36140 000068CA 575D205B2F415B5B3A-
 36140 000068D3 5D6174747269627574-
 36140 000068DC 65735D5D0D0A       
 36141 000068E2 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36141 000068EB 736F72746F72646572-
 36141 000068F4 5D5D205B2F535D205B-
 36141 000068FD 2F425D205B2F4C5D0D-
 36141 00006906 0A                 
 36142 00006907 0D0A                    	db 0Dh,0Ah
 36143                                  MSG_1481:
 36144 00006909 5D                      	db 93
 36145 0000690A 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36145 00006913 5D5B706174685D5B66-
 36145 0000691C 696C656E616D655D0D-
 36145 00006925 0A                 
 36146 00006926 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36146 0000692F 202020202053706563-
 36146 00006938 696669657320647269-
 36146 00006941 76652C206469726563-
 36146 0000694A 746F72792C20616E64-
 36146 00006953 2F6F722066696C6573-
 36146 0000695C 20746F206C6973742E-
 36146 00006965 0D0A               
 36147                                  MSG_1482:
 36148 00006967 61                      	db 97
 36149 00006968 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36149 00006971 202020202050617573-
 36149 0000697A 657320616674657220-
 36149 00006983 656163682073637265-
 36149 0000698C 656E66756C206F6620-
 36149 00006995 696E666F726D617469-
 36149 0000699E 6F6E2E0D0A         
 36150 000069A3 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36150 000069AC 202020202055736573-
 36150 000069B5 2077696465206C6973-
 36150 000069BE 7420666F726D61742E-
 36150 000069C7 0D0A               
 36151                                  MSG_1483:	
 36152 000069C9 7A                      	db 122
 36153 000069CA 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36153 000069D3 202020202044697370-
 36153 000069DC 6C6179732066696C65-
 36153 000069E5 732077697468207370-
 36153 000069EE 656369666965642061-
 36153 000069F7 747472696275746573-
 36153 00006A00 2E0D0A             
 36154 00006A03 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36154 00006A0C 746573202020442020-
 36154 00006A15 4469726563746F7269-
 36154 00006A1E 657320202020202020-
 36154 00006A27 202020202020202020-
 36154 00006A30 522020526561642D6F-
 36154 00006A39 6E6C792066696C6573-
 36154 00006A42 0D0A               
 36155                                  MSG_1484:
 36156 00006A44 BF                      	db 191
 36157 00006A45 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36157 00006A4E 202020202020482020-
 36157 00006A57 48696464656E206669-
 36157 00006A60 6C6573202020202020-
 36157 00006A69 202020202020202020-
 36157 00006A72 41202046696C657320-
 36157 00006A7B 726561647920666F72-
 36157 00006A84 20617263686976696E-
 36157 00006A8D 670D0A             
 36158 00006A90 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36158 00006A99 202020202020532020-
 36158 00006AA2 53797374656D206669-
 36158 00006AAB 6C6573202020202020-
 36158 00006AB4 202020202020202020-
 36158 00006ABD 2D2020507265666978-
 36158 00006AC6 206D65616E696E6720-
 36158 00006ACF 226E6F74220D0A     
 36159 00006AD6 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36159 00006ADF 20202020204C697374-
 36159 00006AE8 2062792066696C6573-
 36159 00006AF1 20696E20736F727465-
 36159 00006AFA 64206F726465722E0D-
 36159 00006B03 0A                 
 36160                                  MSG_1485:
 36161 00006B04 9B                      	db 155
 36162 00006B05 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36162 00006B0E 6572202020204E2020-
 36162 00006B17 4279206E616D652028-
 36162 00006B20 616C70686162657469-
 36162 00006B29 632920202020202020-
 36162 00006B32 53202042792073697A-
 36162 00006B3B 652028736D616C6C65-
 36162 00006B44 737420666972737429-
 36162 00006B4D 0D0A               
 36163 00006B4F 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36163 00006B58 202020202020452020-
 36163 00006B61 427920657874656E73-
 36163 00006B6A 696F6E2028616C7068-
 36163 00006B73 616265746963292020-
 36163 00006B7C 442020427920646174-
 36163 00006B85 6520262074696D6520-
 36163 00006B8E 286561726C69657374-
 36163 00006B97 206669727374290D0A 
 36164                                  MSG_1486:
 36165 00006BA0 96                      	db 150
 36166 00006BA1 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36166 00006BAA 202020202020472020-
 36166 00006BB3 47726F757020646972-
 36166 00006BBC 6563746F7269657320-
 36166 00006BC5 666972737420202020-
 36166 00006BCE 2D2020507265666978-
 36166 00006BD7 20746F207265766572-
 36166 00006BE0 7365206F726465720D-
 36166 00006BE9 0A                 
 36167 00006BEA 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36167 00006BF3 202020202044697370-
 36167 00006BFC 6C6179732066696C65-
 36167 00006C05 7320696E2073706563-
 36167 00006C0E 696669656420646972-
 36167 00006C17 6563746F727920616E-
 36167 00006C20 6420616C6C20737562-
 36167 00006C29 6469726563746F7269-
 36167 00006C32 65732E0D0A         
 36168                                  MSG_1487:
 36169 00006C37 66                      	db 102
 36170 00006C38 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36170 00006C41 202020202055736573-
 36170 00006C4A 206261726520666F72-
 36170 00006C53 6D617420286E6F2068-
 36170 00006C5C 656164696E6720696E-
 36170 00006C65 666F726D6174696F6E-
 36170 00006C6E 206F722073756D6D61-
 36170 00006C77 7279292E0D0A       
 36171 00006C7D 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36171 00006C86 202020202055736573-
 36171 00006C8F 206C6F776572636173-
 36171 00006C98 652E0D0A           
 36172 00006C9C 0D0A                    	db 0Dh,0Ah
 36173                                  MSG_1488:
 36174 00006C9E 92                      	db 146
 36175 00006C9F 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36175 00006CA8 6D6179206265207072-
 36175 00006CB1 6573657420696E2074-
 36175 00006CBA 686520444952434D44-
 36175 00006CC3 20656E7669726F6E6D-
 36175 00006CCC 656E74207661726961-
 36175 00006CD5 626C652E20204F7665-
 36175 00006CDE 72726964650D0A     
 36176 00006CE5 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36176 00006CEE 697463686573206279-
 36176 00006CF7 20707265666978696E-
 36176 00006D00 6720616E7920737769-
 36176 00006D09 746368207769746820-
 36176 00006D12 2D202868797068656E-
 36176 00006D1B 292D2D666F72206578-
 36176 00006D24 616D706C652C202F2D-
 36176 00006D2D 572E0D0A           
 36177                                  MSG_1500:
 36178 00006D31 3E                      	db 62
 36179 00006D32 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36179 00006D3B 20434F4D4D414E442E-
 36179 00006D44 434F4D2070726F6772-
 36179 00006D4D 616D2028636F6D6D61-
 36179 00006D56 6E6420696E74657270-
 36179 00006D5F 7265746572292E0D0A 
 36180 00006D68 0D0A                    	db 0Dh,0Ah
 36181 00006D6A 455849540D0A            	db 'EXIT',0Dh,0Ah
 36182                                  MSG_1520:
 36183 00006D70 3D                      	db 61
 36184 00006D71 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36184 00006D7A 206469726563746F72-
 36184 00006D83 792E0D0A           
 36185 00006D87 0D0A                    	db 0Dh,0Ah
 36186 00006D89 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36186 00006D92 6976653A5D70617468-
 36186 00006D9B 0D0A               
 36187 00006D9D 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36187 00006DA6 3A5D706174680D0A   
 36188                                  MSG_1540:
 36189 00006DAE 5D                      	db 93
 36190 00006DAF 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36190 00006DB8 6F7220736574732061-
 36190 00006DC1 207365617263682070-
 36190 00006DCA 61746820666F722065-
 36190 00006DD3 786563757461626C65-
 36190 00006DDC 2066696C65732E0D0A 
 36191 00006DE5 0D0A                    	db 0Dh,0Ah
 36192 00006DE7 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36192 00006DF0 6976653A5D70617468-
 36192 00006DF9 5B3B2E2E2E5D5D0D0A 
 36193 00006E02 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36194 00006E0A 0D0A                    	db 0Dh,0Ah
 36195                                  MSG_1541:
 36196 00006E0C 6B                      	db 107
 36197 00006E0D 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36197 00006E16 203B20746F20636C65-
 36197 00006E1F 617220616C6C207365-
 36197 00006E28 617263682D70617468-
 36197 00006E31 2073657474696E6773-
 36197 00006E3A 20616E642064697265-
 36197 00006E43 6374204D532D444F53-
 36197 00006E4C 20746F207365617263-
 36197 00006E55 680D0A             
 36198 00006E58 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36198 00006E61 68652063757272656E-
 36198 00006E6A 74206469726563746F-
 36198 00006E73 72792E0D0A         
 36199                                  MSG_1542:	
 36200 00006E78 3B                      	db 59
 36201 00006E79 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36201 00006E82 20776974686F757420-
 36201 00006E8B 706172616D65746572-
 36201 00006E94 7320746F2064697370-
 36201 00006E9D 6C6179207468652063-
 36201 00006EA6 757272656E74207061-
 36201 00006EAF 74682E0D0A         
 36202                                  MSG_1560:
 36203 00006EB4 37                      	db 55
 36204 00006EB5 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36204 00006EBE 6865204D532D444F53-
 36204 00006EC7 20636F6D6D616E6420-
 36204 00006ED0 70726F6D70742E0D0A 
 36205 00006ED9 0D0A                    	db 0Dh,0Ah
 36206 00006EDB 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36206 00006EE4 6578745D0D0A       
 36207 00006EEA 0D0A                    	db 0Dh,0Ah
 36208                                  MSG_1561:	
 36209 00006EEC 7C                      	db 124
 36210 00006EED 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36210 00006EF6 205370656369666965-
 36210 00006EFF 732061206E65772063-
 36210 00006F08 6F6D6D616E64207072-
 36210 00006F11 6F6D70742E0D0A     
 36211 00006F18 0D0A                    	db 0Dh,0Ah
 36212 00006F1A 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36212 00006F23 6E206265206D616465-
 36212 00006F2C 207570206F66206E6F-
 36212 00006F35 726D616C2063686172-
 36212 00006F3E 61637465727320616E-
 36212 00006F47 642074686520666F6C-
 36212 00006F50 6C6F77696E67207370-
 36212 00006F59 656369616C20636F64-
 36212 00006F62 65733A0D0A         
 36213 00006F67 0D0A                    	db 0Dh,0Ah
 36214                                  MSG_1562:
 36215 00006F69 2F                      	db 47
 36216 00006F6A 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36216 00006F73 28657175616C207369-
 36216 00006F7C 676E290D0A         
 36217 00006F81 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36217 00006F8A 28646F6C6C61722073-
 36217 00006F93 69676E290D0A       
 36218                                  MSG_1563:
 36219 00006F99 2A                      	db 42
 36220 00006F9A 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36220 00006FA3 7272656E742074696D-
 36220 00006FAC 650D0A             
 36221 00006FAF 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36221 00006FB8 7272656E7420646174-
 36221 00006FC1 650D0A             
 36222                                  MSG_1564:
 36223 00006FC4 3D                      	db 61
 36224 00006FC5 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36224 00006FCE 7272656E7420647269-
 36224 00006FD7 766520616E64207061-
 36224 00006FE0 74680D0A           
 36225 00006FE4 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36225 00006FED 2D444F532076657273-
 36225 00006FF6 696F6E206E756D6265-
 36225 00006FFF 720D0A             
 36226                                  MSG_1565:
 36227 00007002 34                      	db 52
 36228 00007003 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36228 0000700C 7272656E7420647269-
 36228 00007015 76650D0A           
 36229 00007019 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36229 00007022 28677265617465722D-
 36229 0000702B 7468616E207369676E-
 36229 00007034 290D0A             
 36230                                  MSG_1566:
 36231 00007037 2C                      	db 44
 36232 00007038 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36232 00007041 286C6573732D746861-
 36232 0000704A 6E207369676E290D0A 
 36233 00007053 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36233 0000705C 2870697065290D0A   
 36234                                  MSG_1567:
 36235 00007064 79                      	db 121
 36236 00007065 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36236 0000706E 636B73706163652028-
 36236 00007077 657261736573207072-
 36236 00007080 6576696F7573206368-
 36236 00007089 61726163746572290D-
 36236 00007092 0A                 
 36237 00007093 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36237 0000709C 6361706520636F6465-
 36237 000070A5 202841534349492063-
 36237 000070AE 6F6465203237290D0A 
 36238 000070B7 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36238 000070C0 727269616765207265-
 36238 000070C9 7475726E20616E6420-
 36238 000070D2 6C696E65666565640D-
 36238 000070DB 0A                 
 36239 000070DC 0D0A                    	db 0Dh,0Ah
 36240                                  MSG_1568:
 36241 000070DE 4C                      	db 76
 36242 000070DF 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36242 000070E8 505420776974686F75-
 36242 000070F1 7420706172616D6574-
 36242 000070FA 65727320746F207265-
 36242 00007103 736574207468652070-
 36242 0000710C 726F6D707420746F20-
 36242 00007115 746865206465666175-
 36242 0000711E 6C742073657474696E-
 36242 00007127 672E0D0A           
 36243                                  MSG_1580:
 36244 0000712B 47                      	db 71
 36245 0000712C 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36245 00007135 64656C657465732920-
 36245 0000713E 61206469726563746F-
 36245 00007147 72792E0D0A         
 36246 0000714C 0D0A                    	db 0Dh,0Ah
 36247 0000714E 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36247 00007157 6976653A5D70617468-
 36247 00007160 0D0A               
 36248 00007162 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36248 0000716B 3A5D706174680D0A   
 36249                                  MSG_1600:
 36250 00007173 1C                      	db 28
 36251 00007174 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36251 0000717D 2066696C65206F7220-
 36251 00007186 66696C65732E0D0A   
 36252 0000718E 0D0A                    	db 0Dh,0Ah
 36253                                  MSG_1601:
 36254 00007190 53                      	db 83
 36255 00007191 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36255 0000719A 726976653A5D5B7061-
 36255 000071A3 74685D66696C656E61-
 36255 000071AC 6D65312066696C656E-
 36255 000071B5 616D65320D0A       
 36256 000071BB 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36256 000071C4 653A5D5B706174685D-
 36256 000071CD 66696C656E616D6531-
 36256 000071D6 2066696C656E616D65-
 36256 000071DF 320D0A             
 36257 000071E2 0D0A                    	db 0Dh,0Ah
 36258                                  MSG_1602:
 36259 000071E4 4D                      	db 77
 36260 000071E5 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36260 000071EE 20796F752063616E6E-
 36260 000071F7 6F7420737065636966-
 36260 00007200 792061206E65772064-
 36260 00007209 72697665206F722070-
 36260 00007212 61746820666F722079-
 36260 0000721B 6F7572206465737469-
 36260 00007224 6E6174696F6E206669-
 36260 0000722D 6C652E0D0A         
 36261                                  MSG_1620:
 36262 00007232 57                      	db 87
 36263 00007233 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36263 0000723C 20736574732C206F72-
 36263 00007245 2072656D6F76657320-
 36263 0000724E 4D532D444F5320656E-
 36263 00007257 7669726F6E6D656E74-
 36263 00007260 207661726961626C65-
 36263 00007269 732E0D0A           
 36264 0000726D 0D0A                    	db 0Dh,0Ah
 36265 0000726F 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36265 00007278 61626C653D5B737472-
 36265 00007281 696E675D5D0D0A     
 36266 00007288 0D0A                    	db 0Dh,0Ah
 36267                                  MSG_1621:
 36268 0000728A 81                      	db 129
 36269 0000728B 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36269 00007294 652020537065636966-
 36269 0000729D 696573207468652065-
 36269 000072A6 6E7669726F6E6D656E-
 36269 000072AF 742D7661726961626C-
 36269 000072B8 65206E616D652E0D0A 
 36270 000072C1 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36270 000072CA 202020537065636966-
 36270 000072D3 696573206120736572-
 36270 000072DC 696573206F66206368-
 36270 000072E5 617261637465727320-
 36270 000072EE 746F2061737369676E-
 36270 000072F7 20746F207468652076-
 36270 00007300 61726961626C652E0D-
 36270 00007309 0A                 
 36271 0000730A 0D0A                    	db 0Dh,0Ah
 36272                                  MSG_1622:
 36273 0000730C 4B                      	db 75
 36274 0000730D 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36274 00007316 776974686F75742070-
 36274 0000731F 6172616D6574657273-
 36274 00007328 20746F20646973706C-
 36274 00007331 617920746865206375-
 36274 0000733A 7272656E7420656E76-
 36274 00007343 69726F6E6D656E7420-
 36274 0000734C 7661726961626C6573-
 36274 00007355 2E0D0A             
 36275                                  MSG_1640:
 36276 00007358 34                      	db 52
 36277 00007359 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36277 00007362 6F7220736574732074-
 36277 0000736B 68652073797374656D-
 36277 00007374 2074696D652E0D0A   
 36278 0000737C 0D0A                    	db 0Dh,0Ah
 36279 0000737E 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36279 00007387 655D0D0A           
 36280 0000738B 0D0A                    	db 0Dh,0Ah
 36281                                  MSG_1641:
 36282 0000738D 83                      	db 131
 36283 0000738E 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36283 00007397 2077697468206E6F20-
 36283 000073A0 706172616D65746572-
 36283 000073A9 7320746F2064697370-
 36283 000073B2 6C6179207468652063-
 36283 000073BB 757272656E74207469-
 36283 000073C4 6D652073657474696E-
 36283 000073CD 6720616E6420612070-
 36283 000073D6 726F6D70740D0A     
 36284 000073DD 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36284 000073E6 206F6E652E20205072-
 36284 000073EF 65737320454E544552-
 36284 000073F8 20746F206B65657020-
 36284 00007401 7468652073616D6520-
 36284 0000740A 74696D652E0D0A     
 36285                                  MSG_1660:
 36286 00007411 46                      	db 70
 36287 00007412 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36287 0000741B 74686520636F6E7465-
 36287 00007424 6E7473206F66206120-
 36287 0000742D 746578742066696C65-
 36287 00007436 2E0D0A             
 36288 00007439 0D0A                    	db 0Dh,0Ah
 36289 0000743B 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36289 00007444 76653A5D5B70617468-
 36289 0000744D 5D66696C656E616D65-
 36289 00007456 0D0A               
 36290                                  MSG_1680:
 36291 00007458 25                      	db 37
 36292 00007459 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36292 00007462 746865204D532D444F-
 36292 0000746B 532076657273696F6E-
 36292 00007474 2E0D0A             
 36293 00007477 0D0A                    	db 0Dh,0Ah
 36294 00007479 5645520D0A              	db 'VER',0Dh,0Ah
 36295                                  MSG_1700:
 36296 0000747E B1                      	db 177
 36297 0000747F 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36297 00007488 444F53207768657468-
 36297 00007491 657220746F20766572-
 36297 0000749A 696679207468617420-
 36297 000074A3 796F75722066696C65-
 36297 000074AC 732061726520777269-
 36297 000074B5 7474656E20636F7272-
 36297 000074BE 6563746C7920746F20-
 36297 000074C7 610D0A             
 36298 000074CA 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36299 000074D1 0D0A                    	db 0Dh,0Ah
 36300 000074D3 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36300 000074DC 4E207C204F46465D0D-
 36300 000074E5 0A                 
 36301 000074E6 0D0A                    	db 0Dh,0Ah
 36302 000074E8 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36302 000074F1 465920776974686F75-
 36302 000074FA 74206120706172616D-
 36302 00007503 6574657220746F2064-
 36302 0000750C 6973706C6179207468-
 36302 00007515 652063757272656E74-
 36302 0000751E 205645524946592073-
 36302 00007527 657474696E672E0D0A 
 36303                                  MSG_1720:              
 36304 00007530 52                      	db 82
 36305 00007531 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36305 0000753A 746865206469736B20-
 36305 00007543 766F6C756D65206C61-
 36305 0000754C 62656C20616E642073-
 36305 00007555 657269616C206E756D-
 36305 0000755E 6265722C2069662074-
 36305 00007567 686579206578697374-
 36305 00007570 2E0D0A             
 36306 00007573 0D0A                    	db 0Dh,0Ah
 36307 00007575 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36307 0000757E 653A5D0D0A         
 36308                                  MSG_1740:
 36309 00007583 5B                      	db 91
 36310 00007584 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36310 0000758D 206261746368207072-
 36310 00007596 6F6772616D2066726F-
 36310 0000759F 6D20616E6F74686572-
 36310 000075A8 2E0D0A             
 36311 000075AB 0D0A                    	db 0Dh,0Ah
 36312 000075AD 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36312 000075B6 76653A5D5B70617468-
 36312 000075BF 5D66696C656E616D65-
 36312 000075C8 205B62617463682D70-
 36312 000075D1 6172616D6574657273-
 36312 000075DA 5D0D0A             
 36313 000075DD 0D0A                    	db 0Dh,0Ah
 36314                                  MSG_1741:
 36315 000075DF 72                      	db 114
 36316 000075E0 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36316 000075E9 6172616D6574657273-
 36316 000075F2 202020537065636966-
 36316 000075FB 69657320616E792063-
 36316 00007604 6F6D6D616E642D6C69-
 36316 0000760D 6E6520696E666F726D-
 36316 00007616 6174696F6E20726571-
 36316 0000761F 756972656420627920-
 36316 00007628 7468650D0A         
 36317 0000762D 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36317 00007636 202020202020202020-
 36317 0000763F 202020626174636820-
 36317 00007648 70726F6772616D2E0D-
 36317 00007651 0A                 
 36318                                  MSG_1760:	
 36319 00007652 4C                      	db 76
 36320 00007653 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36320 0000765C 6F6D6D656E74732028-
 36320 00007665 72656D61726B732920-
 36320 0000766E 696E20612062617463-
 36320 00007677 682066696C65206F72-
 36320 00007680 20434F4E4649472E53-
 36320 00007689 59532E0D0A         
 36321 0000768E 0D0A                    	db 0Dh,0Ah
 36322 00007690 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36322 00007699 656E745D0D0A       
 36323                                  MSG_1780:
 36324 0000769F 6B                      	db 107
 36325 000076A0 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36325 000076A9 70726F63657373696E-
 36325 000076B2 67206F662061206261-
 36325 000076BB 7463682070726F6772-
 36325 000076C4 616D20616E64206469-
 36325 000076CD 73706C617973207468-
 36325 000076D6 65206D657373616765-
 36325 000076DF 2022               
 36326 000076E1 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36326 000076EA 0D0A               
 36327 000076EC 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36327 000076F5 6E74696E75652E2E2E-
 36327 000076FE 2E220D0A           
 36328 00007702 0D0A                    	db 0Dh,0Ah
 36329 00007704 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36330                                  MSG_1800:
 36331 0000770B 4D                      	db 77
 36332 0000770C 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36332 00007715 6D657373616765732C-
 36332 0000771E 206F72207475726E73-
 36332 00007727 20636F6D6D616E642D-
 36332 00007730 6563686F696E67206F-
 36332 00007739 6E206F72206F66662E-
 36332 00007742 0D0A               
 36333 00007744 0D0A                    	db 0Dh,0Ah
 36334 00007746 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36334 0000774F 4E207C204F46465D0D-
 36334 00007758 0A                 
 36335                                  MSG_1801:
 36336 00007759 57                      	db 87
 36337 0000775A 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36337 00007763 6573736167655D0D0A 
 36338 0000776C 0D0A                    	db 0Dh,0Ah
 36339 0000776E 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36339 00007777 20776974686F757420-
 36339 00007780 706172616D65746572-
 36339 00007789 7320746F2064697370-
 36339 00007792 6C6179207468652063-
 36339 0000779B 757272656E74206563-
 36339 000077A4 686F2073657474696E-
 36339 000077AD 672E               
 36340 000077AF 0D0A                    	db 0Dh,0Ah
 36341                                  MSG_1820:
 36342 000077B1 47                      	db 71
 36343 000077B2 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36343 000077BB 532D444F5320746F20-
 36343 000077C4 61206C6162656C6C65-
 36343 000077CD 64206C696E6520696E-
 36343 000077D6 206120626174636820-
 36343 000077DF 70726F6772616D2E0D-
 36343 000077E8 0A                 
 36344 000077E9 0D0A                    	db 0Dh,0Ah
 36345 000077EB 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36345 000077F4 6C0D0A             
 36346 000077F7 0D0A                    	db 0Dh,0Ah
 36347                                  MSG_1821:
 36348 000077F9 8A                      	db 138
 36349 000077FA 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36349 00007803 205370656369666965-
 36349 0000780C 732061207465787420-
 36349 00007815 737472696E67207573-
 36349 0000781E 656420696E20746865-
 36349 00007827 206261746368207072-
 36349 00007830 6F6772616D20617320-
 36349 00007839 61206C6162656C2E0D-
 36349 00007842 0A                 
 36350 00007843 0D0A                    	db 0Dh,0Ah
 36351 00007845 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36351 0000784E 61206C6162656C206F-
 36351 00007857 6E2061206C696E6520-
 36351 00007860 627920697473656C66-
 36351 00007869 2C20626567696E6E69-
 36351 00007872 6E6720776974682061-
 36351 0000787B 20636F6C6F6E2E0D0A 
 36352                                  MSG_1840:
 36353 00007884 4A                      	db 74
 36354 00007885 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36354 0000788E 686520706F73697469-
 36354 00007897 6F6E206F6620726570-
 36354 000078A0 6C61636561626C6520-
 36354 000078A9 706172616D65746572-
 36354 000078B2 7320696E2061206261-
 36354 000078BB 7463682066696C652E-
 36354 000078C4 0D0A               
 36355 000078C6 0D0A                    	db 0Dh,0Ah
 36356 000078C8 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36357                                  MSG_1860:
 36358 000078CF 5A                      	db 90
 36359 000078D0 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36359 000078D9 636F6E646974696F6E-
 36359 000078E2 616C2070726F636573-
 36359 000078EB 73696E6720696E2062-
 36359 000078F4 617463682070726F67-
 36359 000078FD 72616D732E0D0A     
 36360 00007904 0D0A                    	db 0Dh,0Ah
 36361 00007906 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36361 0000790F 4552524F524C455645-
 36361 00007918 4C206E756D62657220-
 36361 00007921 636F6D6D616E640D0A 
 36362                                  MSG_1861:
 36363 0000792A 46                      	db 70
 36364 0000792B 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36364 00007934 737472696E67313D3D-
 36364 0000793D 737472696E67322063-
 36364 00007946 6F6D6D616E640D0A   
 36365 0000794E 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36365 00007957 45584953542066696C-
 36365 00007960 656E616D6520636F6D-
 36365 00007969 6D616E640D0A       
 36366 0000796F 0D0A                    	db 0Dh,0Ah
 36367                                  MSG_1862:
 36368 00007971 7D                      	db 125
 36369 00007972 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36369 0000797B 202020202020202020-
 36369 00007984 202053706563696669-
 36369 0000798D 65732074686174204D-
 36369 00007996 532D444F532073686F-
 36369 0000799F 756C64206361727279-
 36369 000079A8 206F75742074686520-
 36369 000079B1 636F6D6D616E64206F-
 36369 000079BA 6E6C790D0A         
 36370 000079BF 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36370 000079C8 202020202020202020-
 36370 000079D1 202069662074686520-
 36370 000079DA 636F6E646974696F6E-
 36370 000079E3 2069732066616C7365-
 36370 000079EC 2E0D0A             
 36371                                  MSG_1863:
 36372 000079EF A2                      	db 162
 36373 000079F0 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36373 000079F9 56454C206E756D6265-
 36373 00007A02 722053706563696669-
 36373 00007A0B 657320612074727565-
 36373 00007A14 20636F6E646974696F-
 36373 00007A1D 6E2069662074686520-
 36373 00007A26 6C6173742070726F67-
 36373 00007A2F 72616D2072756E2072-
 36373 00007A38 657475726E65640D0A 
 36374 00007A41 202020202020202020-     	db '                    '
 36374 00007A4A 202020202020202020-
 36374 00007A53 2020               
 36375 00007A55 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36375 00007A5E 6F646520657175616C-
 36375 00007A67 20746F206F72206772-
 36375 00007A70 656174657220746861-
 36375 00007A79 6E20746865206E756D-
 36375 00007A82 626572207370656369-
 36375 00007A8B 666965642E0D0A     
 36376                                  MSG_1864:
 36377 00007A92 66                      	db 102
 36378 00007A93 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36378 00007A9C 202020202020202020-
 36378 00007AA5 202053706563696669-
 36378 00007AAE 65732074686520636F-
 36378 00007AB7 6D6D616E6420746F20-
 36378 00007AC0 6361727279206F7574-
 36378 00007AC9 206966207468652063-
 36378 00007AD2 6F6E646974696F6E20-
 36378 00007ADB 69730D0A           
 36379 00007ADF 202020202020202020-     	db '                    met.',0Dh,0Ah
 36379 00007AE8 202020202020202020-
 36379 00007AF1 20206D65742E0D0A   
 36380                                  MSG_1865:
 36381 00007AF9 6A                      	db 106
 36382 00007AFA 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36382 00007B03 3D3D737472696E6732-
 36382 00007B0C 202053706563696669-
 36382 00007B15 657320612074727565-
 36382 00007B1E 20636F6E646974696F-
 36382 00007B27 6E2069662074686520-
 36382 00007B30 737065636966696564-
 36382 00007B39 207465787420737472-
 36382 00007B42 696E67730D0A       
 36383 00007B48 202020202020202020-     	db '                    match.',0Dh,0Ah
 36383 00007B51 202020202020202020-
 36383 00007B5A 20206D617463682E0D-
 36383 00007B63 0A                 
 36384                                  MSG_1866:
 36385 00007B64 67                      	db 103
 36386 00007B65 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36386 00007B6E 696C656E616D652020-
 36386 00007B77 202053706563696669-
 36386 00007B80 657320612074727565-
 36386 00007B89 20636F6E646974696F-
 36386 00007B92 6E2069662074686520-
 36386 00007B9B 737065636966696564-
 36386 00007BA4 2066696C656E616D65-
 36386 00007BAD 0D0A               
 36387 00007BAF 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36387 00007BB8 202020202020202020-
 36387 00007BC1 20206578697374732E-
 36387 00007BCA 0D0A               
 36388                                  MSG_1880:
 36389 00007BCC 77                      	db 119
 36390 00007BCD 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36390 00007BD6 656369666965642063-
 36390 00007BDF 6F6D6D616E6420666F-
 36390 00007BE8 722065616368206669-
 36390 00007BF1 6C6520696E20612073-
 36390 00007BFA 6574206F662066696C-
 36390 00007C03 65732E0D0A         
 36391 00007C08 0D0A                    	db 0Dh,0Ah
 36392 00007C0A 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36392 00007C13 61626C6520494E2028-
 36392 00007C1C 7365742920444F2063-
 36392 00007C25 6F6D6D616E64205B63-
 36392 00007C2E 6F6D6D616E642D7061-
 36392 00007C37 72616D65746572735D-
 36392 00007C40 0D0A               
 36393 00007C42 0D0A                    	db 0Dh,0Ah
 36394                                  MSG_1881:
 36395 00007C44 7D                      	db 125
 36396 00007C45 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36396 00007C4E 6C6520205370656369-
 36396 00007C57 666965732061207265-
 36396 00007C60 706C61636561626C65-
 36396 00007C69 20706172616D657465-
 36396 00007C72 722E0D0A           
 36397 00007C76 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36397 00007C7F 202020205370656369-
 36397 00007C88 666965732061207365-
 36397 00007C91 74206F66206F6E6520-
 36397 00007C9A 6F72206D6F72652066-
 36397 00007CA3 696C65732E20205769-
 36397 00007CAC 6C646361726473206D-
 36397 00007CB5 617920626520757365-
 36397 00007CBE 642E0D0A           
 36398                                  MSG_1882:
 36399 00007CC2 56                      	db 86
 36400 00007CC3 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36400 00007CCC 202020205370656369-
 36400 00007CD5 666965732074686520-
 36400 00007CDE 636F6D6D616E642074-
 36400 00007CE7 6F206361727279206F-
 36400 00007CF0 757420666F72206561-
 36400 00007CF9 63682066696C652E0D-
 36400 00007D02 0A                 
 36401 00007D03 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36401 00007D0C 2D706172616D657465-
 36401 00007D15 72730D0A           
 36402                                  MSG_1883:
 36403 00007D19 A2                      	db 162
 36404 00007D1A 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36404 00007D23 202020205370656369-
 36404 00007D2C 666965732070617261-
 36404 00007D35 6D6574657273206F72-
 36404 00007D3E 207377697463686573-
 36404 00007D47 20666F722074686520-
 36404 00007D50 737065636966696564-
 36404 00007D59 20636F6D6D616E642E-
 36404 00007D62 0D0A               
 36405 00007D64 0D0A                    	db 0Dh,0Ah
 36406 00007D66 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36406 00007D6F 6520464F5220636F6D-
 36406 00007D78 6D616E6420696E2061-
 36406 00007D81 206261746368207072-
 36406 00007D8A 6F6772616D2C207370-
 36406 00007D93 656369667920252576-
 36406 00007D9C 61726961626C652069-
 36406 00007DA5 6E7374656164206F66-
 36406 00007DAE 0D0A               
 36407 00007DB0 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36407 00007DB9 2E0D0A             
 36408                                  MSG_1900:
 36409 00007DBC 17                      	db 23
 36410 00007DBD 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36410 00007DC6 636F6D6D616E64206E-
 36410 00007DCF 616D650D0A         
 36411                                  MSG_1920:
 36412 00007DD4 2F                      	db 47
 36413 00007DD5 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36413 00007DDE 726F6772616D20696E-
 36413 00007DE7 746F20746865207570-
 36413 00007DF0 706572206D656D6F72-
 36413 00007DF9 7920617265612E0D0A 
 36414 00007E02 0D0A                    	db 0Dh,0Ah
 36415                                  MSG_1921:
 36416 00007E04 58                      	db 88
 36417 00007E05 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36417 00007E0E 5B64726976653A5D5B-
 36417 00007E17 706174685D66696C65-
 36417 00007E20 6E616D65205B706172-
 36417 00007E29 616D65746572735D0D-
 36417 00007E32 0A                 
 36418 00007E33 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36418 00007E3C 3A5D5B706174685D66-
 36418 00007E45 696C656E616D65205B-
 36418 00007E4E 706172616D65746572-
 36418 00007E57 735D0D0A           
 36419 00007E5B 0D0A                    	db 0Dh,0Ah
 36420                                  MSG_1922:
 36421 00007E5D 71                      	db 113
 36422 00007E5E 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36422 00007E67 657273202020537065-
 36422 00007E70 63696669657320616E-
 36422 00007E79 7920636F6D6D616E64-
 36422 00007E82 2D6C696E6520696E66-
 36422 00007E8B 6F726D6174696F6E20-
 36422 00007E94 726571756972656420-
 36422 00007E9D 6279207468650D0A   
 36423 00007EA5 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36423 00007EAE 20202020202070726F-
 36423 00007EB7 6772616D20796F7520-
 36423 00007EC0 77616E7420746F206C-
 36423 00007EC9 6F61642E0D0A       
 36424                                  
 36425                                  ; ---------------------------------------------------------------------------
 36426                                  
 36427                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36428                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36429                                  
 36430                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36431                                  
 36432                                  $M_CLS_3:
 36433 00007ECF 0E                      	push	cs		; CLASS_F
 36434 00007ED0 07                      	pop	es
 36435 00007ED1 8D3E[9057]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36436                                  	; 15/04/2023
 36437                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36438 00007ED5 C3                      	retn
 36439                                  
 36440                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36441                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36442                                  
 36443                                  ; ---------------------------------------------------------------------------
 36444                                  ; Class 1 messages
 36445                                  ; ---------------------------------------------------------------------------
 36446                                  	
 36447                                  $M_CLASS_1_STRUC:
 36448 00007ED6 01                      	db 1			; $M_CLASS_ID
 36449 00007ED7 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36450 00007ED9 04                      	db 4			; Class_1_MessageCount
 36451                                  $M_ID_1_1:
 36452 00007EDA 0200                    	dw 2			; Message Number = 2
 36453 00007EDC 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36454                                  $M_ID_1_2:
 36455 00007EDE 0300                    	dw 3			; Message Number = 3
 36456 00007EE0 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36457                                  $M_ID_1_3:
 36458 00007EE2 0800                    	dw 8			; Message Number = 8
 36459 00007EE4 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36460                                  $M_ID_1_4:
 36461 00007EE6 FFFF                    	dw 0FFFFh		; Message Number = -1
 36462 00007EE8 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36463                                  
 36464                                  ; ---------------------------------------------------------------------------
 36465                                  
 36466                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36467                                  EXTEND2:
 36468 00007EEA 0E                      	db 14
 36469 00007EEB 46696C65206E6F7420-     	db 'File not found'
 36469 00007EF4 666F756E64         
 36470                                  EXTEND3:
 36471 00007EF9 0E                      	db 14
 36472 00007EFA 50617468206E6F7420-     	db 'Path not found'
 36472 00007F03 666F756E64         
 36473                                  EXTEND8:
 36474 00007F08 13                      	db 19
 36475 00007F09 496E73756666696369-     	db 'Insufficient memory'
 36475 00007F12 656E74206D656D6F72-
 36475 00007F1B 79                 
 36476                                  EXTEND999:
 36477 00007F1C 11                      	db 17
 36478 00007F1D 457874656E64656420-     	db 'Extended Error %1'
 36478 00007F26 4572726F72202531   
 36479                                  
 36480                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36481                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36482                                  
 36483                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36484                                  $M_MSGSERV_1:
 36485 00007F2E 0E                      	push	cs
 36486 00007F2F 07                      	pop	es
 36487 00007F30 8D3E[D67E]              	lea	di,$M_CLASS_1_STRUC
 36488                                  	; 15/04/2023
 36489                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36490 00007F34 C3                      	retn
 36491                                  
 36492                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36493                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36494                                  
 36495                                  ; ---------------------------------------------------------------------------
 36496                                  ; Class 2 messages
 36497                                  ; ---------------------------------------------------------------------------
 36498                                  	
 36499                                  $M_CLASS_2_STRUC:
 36500 00007F35 02                      	db 2			; $M_CLASS_ID
 36501 00007F36 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36502 00007F38 01                      	db 1			; Class_2_MessageCount
 36503                                  $M_ID_2_1:
 36504 00007F39 FFFF                    	dw 0FFFFh		; Message Number = -1
 36505 00007F3B 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36506                                  ; ---------------------------------------------------------------------------
 36507                                  
 36508                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36509                                  PARSE999:
 36510 00007F3D 0E                      	db 14
 36511 00007F3E 506172736520457272-     	db 'Parse Error %1'
 36511 00007F47 6F72202531         
 36512                                  
 36513                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36514                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 36515                                  
 36516                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36517                                  $M_MSGSERV_2:
 36518 00007F4C 0E                      	push	cs
 36519 00007F4D 07                      	pop	es
 36520 00007F4E 8D3E[357F]              	lea	di,$M_CLASS_2_STRUC
 36521                                  	; 15/04/2023
 36522                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 36523 00007F52 C3                      	retn
 36524                                  
 36525                                  ;============================================================================
 36526                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 36527                                  ;============================================================================
 36528                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36529                                  
 36530                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 36531                                  
 36532                                  ;****************************************************
 36533                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 36534                                  ;****************************************************
 36535                                  
 36536                                  msg_disp_class:
 36537 00007F53 FF                      	db	util_msg_class ; 0FFh
 36538                                  msg_cont_flag:
 36539 00007F54 00                      	db	no_cont_flag ; 0
 36540                                  
 36541                                  ;  extended error string output
 36542                                  extend_buf_ptr:
 36543 00007F55 0000                    	dw	0			;AN000;set to no message
 36544                                  extend_buf_sub:
 36545 00007F57 00                      	db	0			;AN000;set to no substitutions
 36546 00007F58 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36547 00007F59 00                      	db	0			;AN000;reserved
 36548                                  extend_buf_off:
 36549 00007F5A [B08C]                  	dw	string_ptr_2		;AN000;offset of arg
 36550                                  extend_buf_seg:
 36551 00007F5C 0000                    	dw	0			;AN000;segment of arg
 36552 00007F5E 00                      	db	0			;AN000;first subst
 36553 00007F5F 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36554 00007F60 80                      	db	128			;AN000;maximum width
 36555 00007F61 00                      	db	0			;AN000;minimum width
 36556 00007F62 20                      	db	blank ; 20h		;AN000;pad character
 36557                                  
 36558                                  ;  "Duplicate file name or file not found"
 36559                                  RENERR_PTR:
 36560 00007F63 EA03                    	dw	1002			;AN000;message number
 36561 00007F65 00                      	db	no_subst ; 0		;AN000;number of subst
 36562                                  
 36563                                  ;  "Invalid path or file name"
 36564                                  BADCPMES_PTR:
 36565 00007F66 EB03                    	dw	1003			;AN000;message number
 36566 00007F68 00                      	db	no_subst ; 0		;AN000;number of subst
 36567                                  
 36568                                  ;  "Insufficient disk space"
 36569                                  NOSPACE_PTR:
 36570 00007F69 EC03                    	dw	1004			;AN000;message number
 36571 00007F6B 00                      	db	no_subst ; 0		;AN000;number of subst
 36572                                  
 36573                                  ;  "Out of environment space"
 36574                                  ENVERR_PTR:
 36575 00007F6C EF03                    	dw	1007			;AN000;message number
 36576 00007F6E 00                      	db	no_subst ; 0		;AN000;number of subst
 36577                                  
 36578                                  ;  "File creation error"
 36579                                  FULLDIR_PTR:
 36580 00007F6F F003                    	dw	1008			;AN000;message number
 36581 00007F71 00                      	db	no_subst ; 0		;AN000;number of subst
 36582                                  
 36583                                  ;  "Batch file missing",13,10
 36584                                  BADBAT_PTR:
 36585 00007F72 F103                    	dw	1009			;AN000;message number
 36586 00007F74 00                      	db	no_subst ; 0		;AN000;number of subst
 36587                                  
 36588                                  ;  "Insert disk with batch file",13,10
 36589                                  NEEDBAT_PTR:
 36590 00007F75 F203                    	dw	1010			;AN000;message number
 36591 00007F77 00                      	db	no_subst ; 0		;AN000;number of subst
 36592                                  
 36593                                  ;  "Bad command or file name",13,10
 36594                                  BADNAM_PTR:
 36595 00007F78 F303                    	dw	1011			;AN000;message number
 36596 00007F7A 00                      	db	no_subst ; 0		;AN000;number of subst
 36597                                  
 36598                                  ;  "Access denied",13,10
 36599                                  ACCDEN_PTR:
 36600 00007F7B F603                    	dw	1014			;AN000;message number
 36601 00007F7D 00                      	db	no_subst ; 0		;AN000;number of subst
 36602                                  
 36603                                  ;  "File cannot be copied onto itself",13,10
 36604                                  OVERWR_PTR:
 36605 00007F7E F703                    	dw	1015			;AN000;message number
 36606 00007F80 00                      	db	no_subst ; 0		;AN000;number of subst
 36607                                  
 36608                                  ;  "Content of destination lost before copy",13,10
 36609                                  LOSTERR_PTR:
 36610 00007F81 F803                    	dw	1016			;AN000;message number
 36611 00007F83 00                      	db	no_subst ; 0		;AN000;number of subst
 36612                                  
 36613                                  ;  "Invalid filename or file not found",13,10
 36614                                  INORNOT_PTR:
 36615 00007F84 F903                    	dw	1017			;AN000;message number
 36616 00007F86 00                      	db	no_subst		;AN000;number of subst
 36617                                  
 36618                                  ;  "%1 File(s) copied",13,10
 36619                                  copied_ptr:
 36620 00007F87 FA03                    	dw	1018			;AN000;message number
 36621 00007F89 01                      	db	1			;AN000;number of subst
 36622 00007F8A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36623 00007F8B 00                      	db	0			;AN000;reserved
 36624 00007F8C [B28C]                  	dw	Copy_num		;AN000;offset of arg
 36625 00007F8E 0000                    	dw	0			;AN000;segment of arg
 36626 00007F90 01                      	db	1			;AN000;first subst
 36627 00007F91 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36628                                  					;AN000;binary to decimal
 36629 00007F92 09                      	db	9			;AN000;maximum width
 36630 00007F93 09                      	db	9			;AN000;minimum width
 36631 00007F94 20                      	db	blank ; 20h		;AN000;pad character
 36632                                  
 36633                                  ;  "%1 File(s) "
 36634                                  dirmes_ptr:
 36635 00007F95 FB03                    	dw	1019			;AN000;message number
 36636 00007F97 01                      	db	1			;AN000;number of subst
 36637 00007F98 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36638 00007F99 00                      	db	0			;AN000;reserved
 36639 00007F9A [B58C]                  	dw	Dir_Num			;AN000;offset of arg
 36640 00007F9C 0000                    	dw	0			;AN000;segment of arg
 36641 00007F9E 01                      	db	1			;AN000;first subst
 36642 00007F9F A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36643                                  					;AN000;binary to decimal
 36644 00007FA0 09                      	db	9			;AN000;maximum width
 36645 00007FA1 09                      	db	9			;AN000;minimum width
 36646 00007FA2 20                      	db	blank ; 20h		;AN000;pad character
 36647                                  
 36648                                  ;  "%1 bytes free",13,10
 36649                                  bytmes_ptr:
 36650 00007FA3 FC03                    	dw	1020			;AN000;message number
 36651 00007FA5 01                      	db	1			;AN000;number of subst
 36652 00007FA6 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36653 00007FA7 00                      	db	0			;AN000;reserved
 36654 00007FA8 [B78C]                  	dw	Bytes_Free		;AN000;offset of arg
 36655 00007FAA 0000                    	dw	0			;AN000;segment of arg
 36656 00007FAC 01                      	db	1			;AN000;first subst
 36657 00007FAD B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 36658                                  					;AN000;long binary to decimal
 36659 00007FAE 1C                      	db	28			;AN000;maximum width
 36660 00007FAF 1C                      	db	28			;AN000;minimum width
 36661 00007FB0 20                      	db	blank ; 20h		;AN000;pad character
 36662                                  
 36663                                  ;  "Invalid drive specification",13,10
 36664                                  baddrv_ptr:
 36665 00007FB1 FD03                    	dw	1021			;AN000;message number
 36666 00007FB3 00                      	db	no_subst ; 0		;AN000;number of subst
 36667                                  
 36668                                  ;  "Code page %1 not prepared for system",13,10
 36669                                  cp_not_set_ptr:
 36670 00007FB4 FE03                    	dw	1022			;AN000;message number
 36671 00007FB6 01                      	db	1			;AN000;number of subst
 36672 00007FB7 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36673 00007FB8 00                      	db	0			;AN000;reserved
 36674 00007FB9 [2A8C]                  	dw	system_cpage		;AN000;offset of arg
 36675 00007FBB 0000                    	dw	0			;AN000;segment of arg
 36676 00007FBD 01                      	db	1			;AN000;first subst
 36677 00007FBE A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36678                                  					;AN000;binary to decimal
 36679 00007FBF 05                      	db	5			;AN000;maximum width
 36680 00007FC0 01                      	db	1			;AN000;minimum width
 36681 00007FC1 20                      	db	blank ; 20h		;AN000;pad character
 36682                                  
 36683                                  ;  "Code page %1 not prepared for all devices",13,10
 36684                                  cp_not_all_ptr:
 36685 00007FC2 FF03                    	dw	1023			;AN000;message number
 36686 00007FC4 01                      	db	1			;AN000;number of subst
 36687 00007FC5 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36688 00007FC6 00                      	db	0			;AN000;reserved
 36689 00007FC7 [2A8C]                  	dw	system_cpage		;AN000;offset of arg
 36690 00007FC9 0000                    	dw	0			;AN000;segment of arg
 36691 00007FCB 01                      	db	1			;AN000;first subst
 36692 00007FCC A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36693                                  					;AN000;binary to decimal
 36694 00007FCD 05                      	db	5			;AN000;maximum width
 36695 00007FCE 01                      	db	1			;AN000;minimum width
 36696 00007FCF 20                      	db	blank ; 20h		;AN000;pad character
 36697                                  
 36698                                  ;  "Active code page: %1",13,10
 36699                                  cp_active_ptr:
 36700 00007FD0 0004                    	dw	1024			;AN000;message number
 36701 00007FD2 01                      	db	1			;AN000;number of subst
 36702 00007FD3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36703 00007FD4 00                      	db	0			;AN000;reserved
 36704 00007FD5 [2A8C]                  	dw	system_cpage		;AN000;offset of arg
 36705 00007FD7 0000                    	dw	0			;AN000;segment of arg
 36706 00007FD9 01                      	db	1			;AN000;first subst
 36707 00007FDA A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36708                                  					;AN000;binary to decimal
 36709 00007FDB 05                      	db	5			;AN000;maximum width
 36710 00007FDC 01                      	db	1			;AN000;minimum width
 36711 00007FDD 20                      	db	blank ; 20h		;AN000;pad character
 36712                                  
 36713                                  ;  "NLSFUNC not installed",13,10
 36714                                  NLSFUNC_PTR:
 36715 00007FDE 0104                    	dw	1025			;AN000;message number
 36716 00007FE0 00                      	db	no_subst ; 0		;AN000;number of subst
 36717                                  
 36718                                  ;  "Invalid code page",13,10
 36719                                  INV_CODE_PAGE:
 36720 00007FE1 0204                    	dw	1026			;AN000;message number
 36721 00007FE3 00                      	db	no_subst ; 0		;AN000;number of subst
 36722                                  
 36723                                  ;  "Current drive is no longer valid"
 36724                                  BADCURDRV:
 36725 00007FE4 0304                    	dw	1027			;AN000;message number
 36726 00007FE6 00                      	db	no_subst ; 0		;AN000;number of subst
 36727                                  
 36728                                  ;  "Press any key to continue"
 36729                                  PAUSEMES_PTR:
 36730 00007FE7 0404                    	dw	1028			;AN000;message number
 36731 00007FE9 00                      	db	no_subst ; 0		;AN000;number of subst
 36732                                  
 36733                                  ;  "Label not found",13,10
 36734                                  BADLAB_PTR:
 36735 00007FEA 0504                    	dw	1029			;AN000;message number
 36736 00007FEC 00                      	db	no_subst ; 0		;AN000;number of subst
 36737                                  
 36738                                  ;  "Syntax error",13,10
 36739                                  SYNTMES_PTR:
 36740 00007FED 0604                    	dw	1030			;AN000;message number
 36741 00007FEF 00                      	db	no_subst ; 0		;AN000;number of subst
 36742                                  
 36743                                  ;  "Invalid date",13,10
 36744                                  BADDAT_PTR:
 36745 00007FF0 0704                    	dw	1031			;AN000;message number
 36746 00007FF2 00                      	db	no_subst ; 0		;AN000;number of subst
 36747                                  
 36748                                  ;  "Current date is %1 %2",13,10
 36749                                  CurDat_Ptr:
 36750 00007FF3 0804                    	dw	1032			;AN000;message number
 36751 00007FF5 02                      	db	2			;AN000;number of subst
 36752 00007FF6 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36753 00007FF7 00                      	db	0			;AN000;reserved
 36754 00007FF8 [2C8C]                  	dw	Arg_Buf			;AN000;offset of arg
 36755 00007FFA 0000                    	dw	0			;AN000;segment of arg
 36756 00007FFC 01                      	db	1			;AN000;first subst
 36757 00007FFD 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36758 00007FFE 03                      	db	3			;AN000;maximum width
 36759 00007FFF 03                      	db	3			;AN000;minimum width
 36760 00008000 20                       	db	blank ; 20h		;AN000;pad character
 36761 00008001 0B                      	db	parm_block_size 	;AN000;size of sublist
 36762 00008002 00                      	db	0			;AN000;reserved
 36763                                  CurDat_yr:
 36764 00008003 0000                    	dw	0			;AN000;year
 36765                                  CurDat_mo_day:
 36766 00008005 0000                    	dw	0			;AN000;month,day
 36767 00008007 02                      	db	2			;AN000;second subst
 36768 00008008 34                      	db	34h ; DATE_MDY_4	;AN000;date
 36769 00008009 0A                      	db	10			;AN000;maximum width
 36770 0000800A 0A                      	db	10			;AN000;minimum width
 36771 0000800B 20                      	db	blank ; 20h		;AN000;pad character
 36772                                  
 36773                                  ;  "SunMonTueWedThuFriSat"
 36774                                  WeekTab:
 36775 0000800C 0904                    	dw	1033			;AN000;message number
 36776 0000800E 00                      	db	no_subst ; 0		;AN000;number of subst
 36777                                  
 36778                                  ;  "Enter new date (%1):"
 36779                                  
 36780                                  NewDat_Ptr:
 36781 0000800F 0A04                    	dw	1034			;AN000;message number
 36782 00008011 01                      	db	1			;AN000;number of subst
 36783 00008012 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36784 00008013 00                      	db	0			;AN000;reserved
 36785                                  NewDat_Format:
 36786 00008014 0000                    	dw	0			;AN000;offset of replacement
 36787 00008016 0000                    	dw	0			;AN000;segment of arg
 36788 00008018 01                      	db	1			;AN000;first subst
 36789 00008019 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36790 0000801A 08                      	db	8			;AN000;maximum width
 36791 0000801B 08                      	db	8			;AN000;minimum width
 36792 0000801C 20                      	db	blank ; 20h		;AN000;pad character
 36793                                  
 36794                                  ;  "Invalid time",13,10
 36795                                  
 36796                                  BadTim_Ptr:
 36797 0000801D 0B04                    	dw	1035			;AN000;message number
 36798 0000801F 00                      	db	no_subst ; 0		;AN000;number of subst
 36799                                  
 36800                                  ;  "Current time is %1",13,10
 36801                                  CurTim_Ptr:
 36802 00008020 0C04                    	dw	1036			;AN000;message number
 36803 00008022 01                      	db	1			;AN000;number of subst
 36804 00008023 0B                      	db	parm_block_size 	;AN000;size of sublist
 36805 00008024 00                      	db	0			;AN000;reserved
 36806                                  CurTim_hr_min:
 36807 00008025 0000                    	dw	0			;AN000;hours,minutes
 36808                                  CurTim_Sec_hn:
 36809 00008027 0000                    	dw	0			;AN000;seconds,hundredths
 36810 00008029 01                      	db	1			;AN000;first subst
 36811 0000802A A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 36812                                  					;AC059;time
 36813 0000802B 0C                      	db	12			;AC059;maximum width
 36814 0000802C 0C                      	db	12			;AC059;minimum width
 36815 0000802D 20                      	db	blank ; 20h		;AN000;pad character
 36816                                  
 36817                                  ;  "Enter new time:"
 36818                                  NewTim_Ptr:
 36819 0000802E 0D04                    	dw	1037			;AN000;message number
 36820 00008030 00                      	db	no_subst ; 0		;AN000;number of subst
 36821                                  
 36822                                  ;  ",    Delete (Y/N)?",13,10
 36823                                  Del_Y_N_Ptr:
 36824 00008031 0E04                    	dw	1038			;AN000;message number
 36825 00008033 00                      	db	no_subst ; 0		;AN000;number of subst
 36826                                  
 36827                                  ;  "All files in directory will be deleted!",13,10
 36828                                  ;  "Are you sure (Y/N)?",13,10
 36829                                  SureMes_Ptr:
 36830 00008034 0F04                    	dw	1039			;AN000;message number
 36831 00008036 00                      	db	no_subst ; 0		;AN000;number of subst
 36832                                  
 36833                                  ;  "Microsoft DOS Version %1.%2",13,10
 36834                                  VerMes_Ptr:
 36835 00008037 1004                    	dw	1040			;AN000;message number
 36836 00008039 02                      	db	2			;AN000;number of subst
 36837 0000803A 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36838 0000803B 00                      	db	0			;AN000;reserved
 36839 0000803C [BB8C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 36840 0000803E 0000                    	dw	0			;AN000;segment of arg
 36841 00008040 01                      	db	1			;AN000;first subst
 36842 00008041 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36843                                  					;AN000;binary to decimal
 36844 00008042 01                      	db	1			;AN000;maximum width
 36845 00008043 01                      	db	1			;AN000;minimum width
 36846 00008044 20                      	db	blank ; 20h		;AN000;pad character
 36847 00008045 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36848 00008046 00                      	db	0			;AN000;reserved
 36849 00008047 [BD8C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 36850 00008049 0000                    	dw	0			;AN000;segment of arg
 36851 0000804B 02                      	db	2			;AN000;second subst
 36852 0000804C A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36853                                  					;AN000;binary to decimal
 36854 0000804D 02                      	db	2			;AN000;maximum width
 36855 0000804E 02                      	db	2			;AN000;minimum width
 36856 0000804F 30                      	db	'0' ; 30h		;AN000;pad character
 36857                                  
 36858                                  ;  "Volume in drive %1 has no label",13,10
 36859                                  VolMes_Ptr_2:
 36860 00008050 1104                    	dw	1041			;AN000;message number
 36861 00008052 01                      	db	1			;AN000;number of subst
 36862 00008053 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 36863 00008054 00                      	db	0			;AN000;reserved
 36864 00008055 [C18C]                  	dw	vol_drv			;AN000;offset of drive
 36865 00008057 0000                    	dw	0			;AN000;segment of arg
 36866 00008059 01                      	db	1			;AN000;first subst
 36867 0000805A 00                      	db	0 ; Char_field_Char 	;AN000;character
 36868 0000805B 80                      	db	128			;AN000;maximum width
 36869 0000805C 01                      	db	1			;AN000;minimum width
 36870 0000805D 20                      	db	blank ; 20h		;AN000;pad character
 36871                                  
 36872                                  ;  "Volume in drive %1 is %2",13,10
 36873                                  VolMes_Ptr:
 36874 0000805E 1204                    	dw	1042			;AN000;message number
 36875 00008060 02                      	db	2			;AN000;number of subst
 36876 00008061 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36877 00008062 00                      	db	0			;AN000;reserved
 36878 00008063 [C18C]                  	dw	vol_drv			;AN000;offset of drive
 36879 00008065 0000                    	dw	0			;AN000;segment of arg
 36880 00008067 01                      	db	1			;AN000;first subst
 36881 00008068 00                      	db	00000000b		;AN000;character
 36882 00008069 80                      	db	128			;AN000;maximum width
 36883 0000806A 01                      	db	1			;AN000;minimum width
 36884 0000806B 20                      	db	blank ; 20h		;AN000;pad character
 36885 0000806C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36886 0000806D 00                      	db	0			;AN000;reserved
 36887 0000806E [FA8A]                  	dw	CHARBUF			;AN000;offset of string
 36888 00008070 0000                    	dw	0			;AN000;segment of arg
 36889 00008072 02                      	db	2			;AN000;second subst
 36890 00008073 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36891 00008074 80                      	db	128			;AN000;maximum width
 36892 00008075 01                      	db	1			;AN000;minimum width
 36893 00008076 20                      	db	blank ; 20h		;AN000;pad character
 36894                                  
 36895                                  ;  "Volume Serial Number is %1-%2",13,10
 36896                                  VolSerMes_Ptr:
 36897 00008077 1304                    	dw	1043			;AN000;message number
 36898 00008079 02                      	db	2			;AN000;number of subst
 36899 0000807A 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 36900 0000807B 00                      	db	0			;AN000;reserved
 36901 0000807C [1C8E]                  	dw	vol_serial+2		;AN000;offset of serial
 36902 0000807E 0000                    	dw	0			;AN000;segment of arg
 36903 00008080 01                      	db	1			;AN000;first subst
 36904 00008081 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 36905                                  					;AN000;binary to hex
 36906 00008082 04                      	db	4			;AN000;maximum width
 36907 00008083 04                      	db	4			;AN000;minimum width
 36908 00008084 30                      	db	'0' ; 30h		;AN000;pad character
 36909 00008085 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36910 00008086 00                      	db	0			;AN000;reserved
 36911 00008087 [1A8E]                  	dw	vol_serial		;AN000;offset of serial
 36912 00008089 0000                    	dw	0			;AN000;segment of arg
 36913 0000808B 02                      	db	2			;AN000;second subst
 36914 0000808C A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 36915                                  					;AN000;binary to hex
 36916 0000808D 04                      	db	4			;AN000;maximum width
 36917 0000808E 04                      	db	4			;AN000;minimum width
 36918 0000808F 30                      	db	'0' ; 30h		;AN000;pad character
 36919                                  
 36920                                  ;  "Invalid directory",13,10
 36921                                  badcd_ptr:
 36922 00008090 1404                    	dw	1044			;AN000;message number
 36923 00008092 00                      	db	no_subst ; 0		;AN000;number of subst
 36924                                  
 36925                                  ;  "Unable to create directory",13,10
 36926                                  badmkd_ptr:
 36927 00008093 1504                    	dw	1045			;AN000;message number
 36928 00008095 00                      	db	no_subst ; 0		;AN000;number of subst
 36929                                  
 36930                                  ;  "Invalid path, not directory,",13,10
 36931                                  ;  "or directory not empty",13,10
 36932                                  badrmd_ptr:
 36933 00008096 1604                    	dw	1046			;AN000;message number
 36934 00008098 00                      	db	no_subst ; 0		;AN000;number of subst
 36935                                  
 36936                                  ;  "Must specify ON or OFF",13,10
 36937                                  bad_on_off_ptr:
 36938 00008099 1704                    	dw	1047			;AN000;message number
 36939 0000809B 00                      	db	no_subst ; 0		;AN000;number of subst
 36940                                  
 36941                                  ;  "Directory of %1",13,10
 36942                                  dirhead_ptr:
 36943 0000809C 1804                    	dw	1048			;AN000;message number
 36944 0000809E 01                      	db	1			;AN000;number of subst
 36945 0000809F 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36946 000080A0 00                      	db	0			;AN000;reserved
 36947 000080A1 [C98B]                  	dw	BWDBUF			;AN000;offset of arg
 36948 000080A3 0000                    	dw	0			;AN000;segment of arg
 36949 000080A5 01                      	db	1			;AN000;first subst
 36950 000080A6 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36951 000080A7 80                      	db	128			;AN000;maximum width
 36952 000080A8 00                      	db	0			;AN000;minimum width
 36953 000080A9 20                      	db	blank ; 20h		;AN000;pad character
 36954                                  
 36955                                  ;  "No Path",13,10
 36956                                  NULLPATH_PTR:
 36957 000080AA 1904                    	dw	1049			;AN000;message number
 36958 000080AC 00                      	db	no_subst ; 0		;AN000;number of subst
 36959                                  
 36960                                  ;  "Invalid drive in search path",13,10
 36961                                  BADPMES_PTR:
 36962 000080AD 1A04                    	dw	1050			;AN000;message number
 36963 000080AF 00                      	db	no_subst ; 0		;AN000;number of subst
 36964                                  
 36965                                  ;  "Invalid device",13,10
 36966                                  BADDEV_PTR:
 36967 000080B0 1B04                    	dw	1051			;AN000;message number
 36968 000080B2 00                      	db	no_subst ; 0		;AN000;number of subst
 36969                                  
 36970                                  ;  "FOR cannot be nested",13,10
 36971                                  FORNESTMES_PTR:
 36972 000080B3 1C04                    	dw	1052			;AN000;message number
 36973 000080B5 00                      	db	no_subst ; 0		;AN000;number of subst
 36974                                  
 36975                                  ;  "Intermediate file error during pipe",13,10
 36976                                  PIPEEMES_PTR:
 36977 000080B6 1D04                    	dw	1053			;AN000;message number
 36978 000080B8 00                      	db	no_subst ; 0		;AN000;number of subst
 36979                                  
 36980                                  ;  "Cannot do binary reads from a device",13,10
 36981                                  INBDEV_PTR:
 36982 000080B9 1E04                    	dw	1054			;AN000;message number
 36983 000080BB 00                      	db	no_subst ; 0		;AN000;number of subst
 36984                                  
 36985                                  ;  "BREAK is %1",13,10
 36986                                  CtrlcMes_Ptr:
 36987 000080BC 1F04                    	dw	1055			;AN000;message number
 36988 000080BE 01                      	db	1			;AN000;number of subst
 36989 000080BF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36990 000080C0 00                      	db	0			;AN000;reserved
 36991 000080C1 0000                    	dw	0			;AN000;offset of on/off (new)
 36992 000080C3 0000                    	dw	0			;AN000;segment of arg
 36993 000080C5 01                      	db	1			;AN000;first subst
 36994 000080C6 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36995 000080C7 80                      	db	128			;AN000;maximum width
 36996 000080C8 01                      	db	1			;AN000;minimum width
 36997 000080C9 20                      	db	blank ; 20h		;AN000;pad character
 36998                                  
 36999                                  ;  "VERIFY is %1",13,10
 37000                                  VeriMes_Ptr:
 37001 000080CA 2004                    	dw	1056			;AN000;message number
 37002 000080CC 01                      	db	1			;AN000;number of subst
 37003 000080CD 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37004 000080CE 00                      	db	0			;AN000;reserved
 37005 000080CF 0000                    	dw	0			;AN000;offset of on/off (new)
 37006 000080D1 0000                    	dw	0			;AN000;segment of arg
 37007 000080D3 01                      	db	1			;AN000;first subst
 37008 000080D4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37009 000080D5 80                      	db	128			;AN000;maximum width
 37010 000080D6 01                      	db	1			;AN000;minimum width
 37011 000080D7 20                      	db	blank ; 20h		;AN000;pad character
 37012                                  
 37013                                  ;  "ECHO is %1",13,10
 37014                                  EchoMes_Ptr:
 37015 000080D8 2104                    	dw	1057			;AN000;message number
 37016 000080DA 01                      	db	1			;AN000;number of subst
 37017 000080DB 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37018 000080DC 00                      	db	0			;AN000;reserved
 37019 000080DD 0000                    	dw	0			;AN000;offset of on/off (new)
 37020 000080DF 0000                    	dw	0			;AN000;segment of arg
 37021 000080E1 01                      	db	1			;AN000;first subst
 37022 000080E2 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37023 000080E3 80                      	db	128			;AN000;maximum width
 37024 000080E4 01                      	db	1			;AN000;minimum width
 37025 000080E5 20                      	db	blank ; 20h		;AN000;pad character
 37026                                  
 37027                                  ;  "off"
 37028                                  OFFMES_PTR:
 37029 000080E6 2304                    	dw	1059			;AN000;message number
 37030 000080E8 00                      	db	no_subst		;AN000;number of subst
 37031                                  
 37032                                  ;  "on"
 37033                                  ONMES_PTR:
 37034 000080E9 2404                    	dw	1060			;AN000;message number
 37035 000080EB 00                      	db	no_subst ; 0		;AN000;number of subst
 37036                                  
 37037                                  ;  "Error writing to device",13,10
 37038                                  DEVWMES_PTR:
 37039 000080EC 2504                    	dw	1061			;AN000;message number
 37040 000080EE 00                      	db	no_subst ; 0		;AN000;number of subst
 37041                                  
 37042                                  ;  "Invalid path",13,10
 37043                                  INVAL_PATH_PTR:
 37044 000080EF 2604                    	dw	1062			;AN000;message number
 37045 000080F1 00                      	db	no_subst ; 0		;AN000;number of subst
 37046                                  
 37047                                  ;  unformatted string output
 37048                                  arg_buf_ptr:
 37049 000080F2 2704                    	dw	1063			;AN000;message number
 37050 000080F4 01                      	db	1			;AN000;number of subst
 37051 000080F5 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37052 000080F6 00                      	db	0			;AN000;reserved
 37053 000080F7 [2C8C]                  	dw	Arg_Buf 		;AN000;offset of arg
 37054 000080F9 0000                    	dw	0			;AN000;segment of arg
 37055 000080FB 01                      	db	1			;AN000;first subst
 37056 000080FC 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37057 000080FD 80                      	db	128			;AN000;maximum width
 37058 000080FE 00                      	db	0			;AN000;minimum width
 37059 000080FF 20                      	db	blank ; 20h		;AN000;pad character
 37060                                  
 37061                                  ;  file name output
 37062                                  file_name_ptr:
 37063 00008100 2804                    	dw	1064			;AN000;message number
 37064 00008102 01                      	db	1			;AN000;number of subst
 37065 00008103 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37066 00008104 00                      	db	0			;AN000;reserved
 37067 00008105 [2F8D]                  	dw	SrcBuf			;AN000;offset of arg
 37068 00008107 0000                    	dw	0			;AN000;segment of arg
 37069 00008109 01                      	db	1			;AN000;first subst
 37070 0000810A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37071 0000810B 80                      	db	128			;AN000;maximum width
 37072 0000810C 00                      	db	0			;AN000;minimum width
 37073 0000810D 20                      	db	blank ; 20h		;AN000;pad character
 37074                                  
 37075                                  ;  file size output for dir
 37076                                  disp_file_size_ptr:
 37077 0000810E 2904                    	dw	1065			;AN000;message number
 37078 00008110 01                      	db	1			;AN000;number of subst
 37079 00008111 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37080 00008112 00                      	db	0			;AN000;reserved
 37081 00008113 [AC8C]                  	dw	File_Size_Low		;AN000;offset of arg
 37082 00008115 0000                    	dw	0			;AN000;segment of arg
 37083 00008117 01                      	db	1			;AN000;first subst
 37084 00008118 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37085                                  					;AN000;long binary to decimal
 37086 00008119 0A                      	db	10			;AN000;maximum width
 37087 0000811A 0A                      	db	10			;AN000;minimum width
 37088 0000811B 20                      	db	blank ; 20h		;AN000;pad character
 37089                                  
 37090                                  ;  unformatted string output
 37091                                  ; %s
 37092                                  string_buf_ptr:
 37093 0000811C 2A04                    	dw	1066			;AN000;message number
 37094 0000811E 01                      	db	1			;AN000;number of subst
 37095 0000811F 0B                      	db	parm_block_size 	;AN000;size of sublist
 37096 00008120 00                      	db	0			;AN000;reserved
 37097 00008121 [B08C]                  	dw	string_ptr_2		;AN000;offset of arg
 37098 00008123 0000                    	dw	0			;AN000;segment of arg
 37099 00008125 01                      	db	1			;AN000;first subst
 37100 00008126 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37101 00008127 80                      	db	128			;AN000;maximum width
 37102 00008128 00                      	db	0			;AN000;minimum width
 37103 00008129 20                      	db	blank ; 20h		;AN000;pad character
 37104 0000812A 00                      	db	0			;AN000;
 37105                                  
 37106                                  ;  tab character
 37107                                  tab_ptr:
 37108 0000812B 2B04                    	dw	1067			;AN000;message number
 37109 0000812D 00                      	db	no_subst ; 0		;AN000;number of subst
 37110                                  
 37111                                  ;  " <DIR>   "
 37112                                  dmes_ptr:
 37113 0000812E 2C04                    	dw	1068			;AN000;message number
 37114 00008130 00                      	db	no_subst ; 0		;AN000;number of subst
 37115                                  
 37116                                  ;  destructive back space
 37117                                  dback_ptr:
 37118 00008131 2D04                    	dw	1069			;AN000;message number
 37119 00008133 00                      	db	no_subst ; 0		;AN000;number of subst
 37120                                  
 37121                                  ;  carriage return / line feed
 37122                                  acrlf_ptr:
 37123 00008134 2E04                    	dw	1070			;AN000;message number
 37124 00008136 00                      	db	no_subst ; 0		;AN000;number of subst
 37125                                  
 37126                                  ;  "mm-dd-yy"
 37127                                  usadat_ptr:
 37128 00008137 3004                    	dw	1072			;AN000;message number
 37129 00008139 00                      	db	no_subst ; 0		;AN000;number of subst
 37130                                  
 37131                                  ;  "dd-mm-yy"
 37132                                  eurdat_ptr:
 37133 0000813A 3104                    	dw	1073			;AN000;message number
 37134 0000813C 00                      	db	no_subst ; 0		;AN000;number of subst
 37135                                  
 37136                                  ;  "yy-mm-dd"
 37137                                  japdat_ptr:
 37138 0000813D 3204                    	dw	1074			;AN000;message number
 37139 0000813F 00                      	db	no_subst ; 0		;AN000;number of subst
 37140                                  
 37141                                  ;  date string for prompt
 37142                                  promptdat_ptr:
 37143 00008140 3304                    	dw	1075			;AN000;message number
 37144 00008142 02                      	db	2			;AN000;number of subst
 37145 00008143 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37146 00008144 00                      	db	0			;AN000;reserved
 37147 00008145 [2C8C]                  	dw	Arg_Buf			;AN000;offset of arg
 37148 00008147 0000                    	dw	0			;AN000;segment of arg
 37149 00008149 01                      	db	1			;AN000;first subst
 37150 0000814A 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37151 0000814B 03                      	db	3			;AN000;maximum width
 37152 0000814C 03                      	db	3			;AN000;minimum width
 37153 0000814D 20                       	db	blank ; 20h		;AN000;pad character
 37154 0000814E 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37155 0000814F 00                      	db	0			;AN000;reserved
 37156                                  promptDat_yr:
 37157 00008150 0000                    	dw	0			;AN000;year
 37158                                  promptDat_moday:
 37159 00008152 0000                    	dw	0			;AN000;month,day
 37160 00008154 02                      	db	2			;AN000;second subst
 37161 00008155 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37162 00008156 0A                      	db	10			;AN000;maximum width
 37163 00008157 08                      	db	8			;AN000;minimum width
 37164 00008158 20                      	db	blank ; 20h		;AN000;pad character
 37165                                  
 37166                                  ;  Time for prompt
 37167                                  promtim_ptr:
 37168 00008159 3404                    	dw	1076			;AN000;message number
 37169 0000815B 01                      	db	1			;AN000;number of subst
 37170 0000815C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37171 0000815D 00                      	db	0			;AN000;reserved
 37172                                  PromTim_hr_min:
 37173 0000815E 0000                    	dw	0			;AN000;hours,minutes
 37174                                  PromTim_Sec_hn:
 37175 00008160 0000                    	dw	0			;AN000;seconds,hundredths
 37176 00008162 01                      	db	1			;AN000;first subst
 37177 00008163 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37178                                  					;AC013;time
 37179 00008164 0B                      	db	11			;AN000;maximum width
 37180 00008165 0B                      	db	11			;AC013;minimum width
 37181 00008166 20                      	db	blank ; 20h		;AN000;pad character
 37182                                  
 37183                                  ;  Date and time for DIR
 37184                                  dirdattim_ptr:
 37185 00008167 3504                    	dw	1077			;AN000;message number
 37186 00008169 02                      	db	2			;AN000;number of subst
 37187 0000816A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37188 0000816B 00                      	db	0			;AN000;reserved
 37189                                  DirDat_Yr:
 37190 0000816C 0000                    	dw	0			;AN000;year
 37191                                  DirDat_Mo_Day:
 37192 0000816E 0000                    	dw	0			;AN000;month,day
 37193 00008170 01                      	db	1			;AN000;first subst
 37194 00008171 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37195                                  					;AN000;date
 37196 00008172 0A                      	db	10			;AN000;maximum width
 37197 00008173 08                      	db	8			;AN000;minimum width
 37198 00008174 20                      	db	blank ; 20h		;AN000;pad character
 37199 00008175 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37200 00008176 00                      	db	0			;AN000;reserved
 37201                                  DirTim_Hr_Min:
 37202 00008177 0000                    	dw	0			;AN000;hours,minutes
 37203                                  DirTim_Sec_hn:
 37204 00008179 0000                    	dw	0			;AN000;seconds,hundredths
 37205 0000817B 02                      	db	2			;AN000;second subst
 37206 0000817C 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37207                                  					;AN000;time
 37208 0000817D 06                      	db	6			;AN000;maximum width
 37209 0000817E 06                      	db	6			;AN000;minimum width
 37210 0000817F 20                      	db	blank ; 20h		;AN000;pad character
 37211                                  
 37212                                  ;  "Directory already exists"
 37213                                  MD_EXISTS_PTR:
 37214 00008180 3604                    	dw	1078			;AN000;message number
 37215 00008182 00                      	db	no_subst		;AN000;number of subst
 37216                                  
 37217                                  ;  "%1 bytes",13,10
 37218                                  bytes_ptr:
 37219 00008183 3704                    	dw	1079			; message number
 37220 00008185 01                      	db	1			; number of subst
 37221 00008186 0B                              db	parm_block_size ; 11	; size of sublist
 37222 00008187 00                              db	0			; reserved
 37223 00008188 [EE8A]                          dw	FileSiz			; offset of arg
 37224 0000818A 0000                            dw	0			; segment of arg
 37225 0000818C 01                              db	1			; first subst
 37226 0000818D B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37227                                  					; long binary to decimal
 37228 0000818E 0A                              db	10			; maximum width
 37229 0000818F 0A                              db	10			; minimum width
 37230 00008190 20                              db	blank ; 20h		; pad character
 37231                                  
 37232                                  ;  "Total:",13,10
 37233                                  total_ptr:
 37234 00008191 3804                    	dw	1080			; message number
 37235 00008193 00                      	db	no_subst ; 0		; number of subst
 37236                                  
 37237                                  ;  "Error parsing environment variable:",13,10
 37238                                  errparsenv_ptr:
 37239 00008194 3904                    	dw	1081			; message number
 37240 00008196 00                      	db	no_subst ; 0		; number of subst
 37241                                  
 37242                                  ;  "(continuing %1)",13,10
 37243                                  dircont_ptr:
 37244 00008197 3C04                    	dw	1084			;AN000;message number
 37245 00008199 01                      	db	1			;AN000;number of subst
 37246 0000819A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37247 0000819B 00                      	db	0			;AN000;reserved
 37248 0000819C [C98B]                  	dw	BWDBUF			;AN000;offset of arg
 37249 0000819E 0000                    	dw	0			;AN000;segment of arg
 37250 000081A0 01                      	db	1			;AN000;first subst
 37251 000081A1 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37252 000081A2 80                      	db	128			;AN000;maximum width
 37253 000081A3 00                      	db	0			;AN000;minimum width
 37254 000081A4 20                      	db	blank ; 20h		;AN000;pad character
 37255                                  
 37256                                  ;  "Revision %1",CR,LF
 37257                                  dosrev_ptr:
 37258 000081A5 4204                    	dw	1090
 37259 000081A7 01                      	db	1			; one substitution
 37260 000081A8 0B                      	db	parm_block_size ; 11
 37261 000081A9 00                      	db	0
 37262 000081AA [BF8C]                  	dw	One_Char_Val		; ptr to char
 37263 000081AC 0000                    	dw	0			; segment addr?
 37264 000081AE 01                      	db	1			; 1st substitution
 37265 000081AF 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37266 000081B0 01                      	db	1			; max width
 37267 000081B1 01                      	db	1			; min width
 37268 000081B2 20                      	db	blank ; 20h		; pad char
 37269                                  
 37270                                  ;  "DOS is in ROM"
 37271                                  DosRom_Ptr:
 37272 000081B3 4304                    	dw	1091
 37273 000081B5 00                      	db	no_subst ; 0		
 37274                                  
 37275                                  ;  "DOS is in HMA"
 37276                                  DosHma_Ptr:
 37277 000081B6 4404                    	dw	1092
 37278 000081B8 00                      	db	no_subst ; 0		
 37279                                  
 37280                                  ;  "DOS is in low memory"
 37281                                  DosLow_Ptr:
 37282 000081B9 4504                    	dw	1093
 37283 000081BB 00                      	db	no_subst ; 0		
 37284                                  
 37285                                  ;  "Cannot Loadhigh batch file" ;M016
 37286                                  NoExecBat_Ptr:
 37287 000081BC 4604                    	dw	1094			; M016
 37288 000081BE 00                      	db	no_subst ; 0		; M016
 37289                                  
 37290                                  ;  "LoadHigh: Invalid filename" ; M016
 37291                                  LhInvFil_Ptr:
 37292 000081BF 4704                    	dw	1095			; M016
 37293 000081C1 00                      	db	no_subst ; 0		; M016
 37294                                  
 37295                                  ;  "Could not open specified country information file" ; M045
 37296                                  NoCntry_Ptr:
 37297 000081C2 4804                    	dw	1096			; M045
 37298 000081C4 00                      	db	no_subst ; 0		; M045
 37299                                  
 37300                                  ; 15/04/2023
 37301                                  ; MSDOS 6.0 COMMAND.COM only !
 37302                                  %if 0
 37303                                  
 37304                                  ;* The next four errors emulate those reported by the normal parse
 37305                                  ;  mechanism, with a little more accurate wording; that parser has been
 37306                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37307                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37308                                  ;  parser, so they've been added here.
 37309                                  
 37310                                  ;  "LoadHigh: Invalid argument"
 37311                                  LhInvArg_Ptr:
 37312                                  	dw	1097
 37313                                  	db	no_subst ; 0		
 37314                                  
 37315                                  ;  "Required parameter missing"
 37316                                  ReqParmMiss:
 37317                                  	dw	1098
 37318                                  	db	no_subst ; 0		
 37319                                  
 37320                                  ;  "Unrecognized switch"
 37321                                  LhInvSwt_Ptr:
 37322                                  	dw	1099
 37323                                  	db	no_subst ; 0		
 37324                                  
 37325                                  ;  "A bad UMB number has been specified"
 37326                                  LhBadUMB_Ptr:
 37327                                  	dw	1100
 37328                                  	db	no_subst ; 0
 37329                                  %endif		
 37330                                  
 37331                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37332                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37333                                  ; ---------------------------------------------------------------------------
 37334                                  
 37335                                  PATH_TEXT:
 37336 000081C5 504154483D              	db	"PATH="
 37337                                  PROMPT_TEXT:
 37338 000081CA 50524F4D50543D          	db	"PROMPT="
 37339                                  COMSPECSTR:
 37340 000081D1 434F4D535045433D        	db	"COMSPEC="
 37341                                  DirEnvVar:
 37342 000081D9 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37343                                  
 37344                                  ; 15/04/2023
 37345                                  %if 0
 37346                                  
 37347                                  ;============================================================================
 37348                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37349                                  ;============================================================================
 37350                                  ; 30/09/2018 - Retro DOS v3.0
 37351                                  
 37352                                  ; TITLE	COMMAND Transient Initialized DATA
 37353                                  
 37354                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37355                                  ;initial values at the beginning of each command cycle. It is
 37356                                  ;included in the transient checksum area. If values in TRANDATA
 37357                                  ;change, the transient will be reloaded for the next command cycle.
 37358                                  
 37359                                  align 16
 37360                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37361                                  
 37362                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37363                                  _3740h:		db '%S',0
 37364                                  ARG_BUF_PTR:	dw _3740h
 37365                                  		dw _3747h
 37366                                  _3747h:		dw ARG_BUF ; _43E8h
 37367                                  _3749h:		db '%S ',0
 37368                                  STRINGBUF1PTR:	dw _3749h
 37369                                  		dw STRING_PTR_1 ; _4468h
 37370                                  _3751h:		db '%9ld',0
 37371                                  FSIZEMESPTR:	dw _3751h
 37372                                  		dw FILESIZE_L ; _446Ah
 37373                                  		dw FILESIZE_H ; _446Ch
 37374                                  _375Ch:		db '%S',0
 37375                                  STRINGBUF2PTR:	dw _375Ch
 37376                                  		dw STRING_PTR_2 ; _446Eh
 37377                                  _3763h:		db 9,0
 37378                                  TABPTR:		dw _3763h
 37379                                  _3767h:		db 0Dh,0Ah
 37380                                  		db 'Batch file missing',0Dh,0Ah,0
 37381                                  BADPATHPTR:	dw _3767h
 37382                                  _3780h:		db 0Dh,0Ah
 37383                                  		db 'Insert disk with batch file',0Dh,0Ah
 37384                                  		db 'and press any key when ready',0Dh,0Ah,0
 37385                                  INSERTDSKPTR:	dw _3780h
 37386                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37387                                  BADNAMPTR:	dw _37C0h
 37388                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37389                                  RENERRPTR:	dw _37DDh
 37390                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37391                                  FNOTFOUNDPTR:	dw _3807h
 37392                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37393                                  PNOTFOUNDPTR:	dw _381Ah
 37394                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37395                                  ACCDENPTR:	dw _382Dh
 37396                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37397                                  NOSPACEPTR:	dw _383Fh
 37398                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37399                                  ENVERRPTR:	dw _385Bh
 37400                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37401                                  FULDIRPTR:	dw 3878h
 37402                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37403                                  OVERWRPTR:	dw _3890h
 37404                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37405                                  LOSTERRPTR:	dw _38B6h
 37406                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37407                                  INORNOTPTR:	dw _38E2h
 37408                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37409                                  COPIEDPTR:	dw _3909h
 37410                                  		dw COPY_NUM ; _4470h
 37411                                  _3922h:		db '%9d File(s) ',0
 37412                                  DIRMESPTR:	dw _3922h
 37413                                  		dw DIR_NUM  ; _4477h
 37414                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37415                                  BYTEMESPTR:	dw _3933h
 37416                                  		dw BYTES_FREE   ; _4479h
 37417                                  		dw BYTES_FREE+2 ; _447Bh
 37418                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37419                                  BADDRVPTR:	dw _394Bh
 37420                                  _396Bh:		db 0Dh,0Ah
 37421                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37422                                  CPNOTSETPTR:	dw _396Bh
 37423                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37424                                  _3999h:		db 0Dh,0Ah
 37425                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37426                                  CPNOTALLPTR:	dw _3999h
 37427                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37428                                  _39CCh:		db 0Dh,0Ah
 37429                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37430                                  CPACTIVEPTR:	dw _39CCh
 37431                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37432                                  _39EAh:		db 'Current drive is no longer valid',0
 37433                                  BADCURDRVPTR:	dw _39EAh
 37434                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37435                                  PAUSEMESPTR:	dw _3A0Dh
 37436                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37437                                  BADPARMPTR:	dw _3A2Eh
 37438                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37439                                  _3A59h:		db 0Dh,0Ah
 37440                                  		db 'Invalid date',0
 37441                                  BADDATPTR:	dw _3A59h
 37442                                  _3A6Ah:		db 'Current date is ',0
 37443                                  CURDATPTR:	dw _3A6Ah
 37444                                  _3A7Dh:		db 0Dh,0Ah
 37445                                  		db 'Enter new date ',0
 37446                                  NEWDATPTR:	dw _3A7Dh
 37447                                  _3A91h:		db '(mm-dd-yy): ',0
 37448                                  USADATPTR:	dw _3A91h
 37449                                  _3AA0h:		db '(dd-mm-yy): ',0
 37450                                  EURDATPTR:	dw _3AA0h
 37451                                  _3AAFh:		db '(yy-mm-dd): ',0
 37452                                  JAPDATPTR:	dw _3AAFh
 37453                                  _3ABEh:		db 0Dh,0Ah
 37454                                  		db 'Invalid time ',0
 37455                                  BADTIMPTR:	dw _3ABEh
 37456                                  _3AD0h:		db 'Current time is ',0
 37457                                  CURTIMPTR:	dw _3AD0h
 37458                                  _3AE3h:		db 0Dh,0Ah
 37459                                  		db 'Enter new time: ',0
 37460                                  NEWTIMPTR:	dw _3AE3h
 37461                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37462                                  SUREMESPTR:	dw _3AF8h
 37463                                  _3B0Eh:		db ' <DIR>   ',0
 37464                                  DMESPTR:	dw _3B0Eh
 37465                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37466                                  VERMESPTR:	dw _3B1Ah
 37467                                  		dw MAJOR_VER_NUM ; _447Dh
 37468                                  		dw MINOR_VER_NUM ; _447Fh
 37469                                  _3B4Dh:		db '%C',0
 37470                                  ONECHRVALPTR:	dw _3B4Dh
 37471                                  		dw ONE_CHAR_VAL	; _4481h
 37472                                  _3B54h:		db ' Volume in drive %c %s',0
 37473                                  VOLMESPTR:	dw _3B54h
 37474                                  		dw VOL_DRV ; _4484h
 37475                                  		dw VOLNAME_ADDR ; _4482h
 37476                                  IS:		db 'is ',0
 37477                                  NOVOL:		db 'has no label',0
 37478                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37479                                  BADCDPTR:	dw _3B82h
 37480                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37481                                  BADMKDPTR:	dw _3B98h
 37482                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37483                                  		db 'or directory not empty',0Dh,0Ah,0
 37484                                  BADRMDPTR:	dw _3BB7h
 37485                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37486                                  BADONOFFPTR:	dw _3BF0h
 37487                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37488                                  DIRHEADPTR:	dw _3C0Bh
 37489                                  		dw VOL_DIR ; _4485h
 37490                                  _3C23h:		db 'No Path',0
 37491                                  NULLPATHPTR:	dw _3C23h
 37492                                  PATH_TEXT:	db 'PATH='
 37493                                  PROMPT_TEXT:	db 'PROMPT='
 37494                                  COMSPEC_TEXT:	db 'COMSPEC='
 37495                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37496                                  BADPMESPTR:	dw _3C41h
 37497                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37498                                  BADDEVPTR:	dw _3C62h
 37499                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37500                                  BADLABPTR:	dw _3C75h
 37501                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37502                                  SYNTMESPTR:	dw _3C89h
 37503                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37504                                  FORNESTMESTR:	dw _3C9Ah
 37505                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37506                                  INSFMEMMESPTR:	dw _3CB4h
 37507                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37508                                  PIPEEMESPTR:	dw _3CCCh
 37509                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37510                                  INBDEVPTR:	dw _3CF4h
 37511                                  _3D1Dh:		db 'BREAK is ',0
 37512                                  CTRLMESPTR:	dw _3D1Dh
 37513                                  _3D29h:		db 'VERIFY is ',0
 37514                                  VERIMESPTR:	dw _3D29h
 37515                                  _3D36h:		db 'ECHO is ',0
 37516                                  ECHOMESPTR:	dw _3D36h
 37517                                  _3D41h:		db 'off',0Dh,0Ah,0
 37518                                  OFFMESPTR:	dw _3D41h
 37519                                  _3D49h:		db 'on',0Dh,0Ah,0
 37520                                  ONMESPTR:	dw _3D49h
 37521                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 37522                                  BADCPMESPTR:	dw _3D50h
 37523                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 37524                                  BADARGSPTR:	dw _3D6Eh
 37525                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 37526                                  DEVWMESPTR:	dw _3D8Fh
 37527                                  _3DABh:		db 0Dh,0Ah,0
 37528                                  ACRLFPTR:	dw _3DABh
 37529                                  _3DB0h:		db 8
 37530                                  		db 20h
 37531                                  		db 8
 37532                                  		db 0
 37533                                  DBACKPTR:	dw _3DB0h
 37534                                  small_y:	db 'y'
 37535                                  small_n:	db 'n'
 37536                                  CAPITAL_Y:	db 'Y'
 37537                                  CAPITAL_N:	db 'N'
 37538                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 37539                                  PROMPT_TABLE:
 37540                                  		db 'B' ; 42h
 37541                                  		dw PRINT_B
 37542                                  		db 'D' ; 44h
 37543                                  		dw PRINT_DATE
 37544                                  		db 'E' ; 45h
 37545                                  		dw PRINT_ESC
 37546                                  		db 'G' ; 47h
 37547                                  		dw PRINT_G
 37548                                  		db 'H' ; 48h
 37549                                  		dw PRINT_BACK
 37550                                  		db 'L' ; 4Ch
 37551                                  		dw PRINT_L
 37552                                  		db 'N' ; 4Eh
 37553                                  		dw PRINT_DRIVE
 37554                                  		db 'P' ; 50h
 37555                                  		dw BUILD_DIR_FOR_PROMPT
 37556                                  		db 'Q' ; 51h
 37557                                  		dw PRINT_EQ
 37558                                  		db 'T' ; 54h
 37559                                  		dw PRINT_TIME
 37560                                  		db 'V' ; 56h
 37561                                  		dw PRINT_VERSION
 37562                                  		db '_' ; 5Fh
 37563                                  		dw CRLF2
 37564                                  		db '$' ; 24h
 37565                                  		dw PRINT_CHAR
 37566                                  		db 0
 37567                                  
 37568                                  		; Table of IF conditionals
 37569                                  IFTAB:
 37570                                  		db 3	; First byte is count
 37571                                  		db 'NOT'
 37572                                  		dw IFNOT
 37573                                  		db 10
 37574                                  		db 'ERRORLEVEL'
 37575                                  		dw IFERLEV
 37576                                  		db 5
 37577                                  		db 'EXIST'
 37578                                  		dw IFEXISTS
 37579                                  		db 0
 37580                                  
 37581                                  		; Table for internal command names
 37582                                  
 37583                                  COMTAB:		db 3
 37584                                  		db 'DIR'
 37585                                  		db 3
 37586                                  		dw CATALOG
 37587                                  		db 4
 37588                                  		db 'CALL'
 37589                                  		db 2
 37590                                  		dw _$CALL
 37591                                  		db 4
 37592                                  		db 'CHCP'
 37593                                  		db 2
 37594                                  		dw CHCP
 37595                                  		db 6
 37596                                  		db 'RENAME'
 37597                                  		db 1
 37598                                  		dw CRENAME
 37599                                  		db 3
 37600                                  		db 'REN'
 37601                                  		db 1
 37602                                  		dw CRENAME
 37603                                  		db 5
 37604                                  		db 'ERASE'
 37605                                  		db 1
 37606                                  		dw ERASE
 37607                                  		db 3
 37608                                  		db 'DEL'
 37609                                  		db 1
 37610                                  		dw ERASE
 37611                                  		db 4
 37612                                  		db 'TYPE'
 37613                                  		db 1
 37614                                  		dw TYPEFIL
 37615                                  		db 3
 37616                                  		db 'REM'
 37617                                  		db 2
 37618                                  		dw TCOMMAND
 37619                                  		db 4
 37620                                  		db 'COPY'
 37621                                  		db 3
 37622                                  		dw COPY
 37623                                  		db 5
 37624                                  		db 'PAUSE'
 37625                                  		db 2
 37626                                  		dw PAUSE
 37627                                  		db 4
 37628                                  		db 'DATE'
 37629                                  		db 2
 37630                                  		dw DATE
 37631                                  		db 4
 37632                                  		db 'TIME'
 37633                                  		db 0
 37634                                  		dw CTIME
 37635                                  		db 3
 37636                                  		db 'VER'
 37637                                  		db 0
 37638                                  		dw VERSION
 37639                                  		db 3
 37640                                  		db 'VOL'
 37641                                  		db 1
 37642                                  		dw VOLUME
 37643                                  		db 2
 37644                                  		db 'CD'
 37645                                  		db 1
 37646                                  		dw _$CHDIR
 37647                                  		db 5
 37648                                  		db 'CHDIR'
 37649                                  		db 1
 37650                                  		dw _$CHDIR
 37651                                  		db 2
 37652                                  		db 'MD'
 37653                                  		db 1
 37654                                  		dw _$MKDIR
 37655                                  		db 5
 37656                                  		db 'MKDIR'
 37657                                  		db 1
 37658                                  		dw _$MKDIR
 37659                                  		db 2
 37660                                  		db 'RD'
 37661                                  		db 1
 37662                                  		dw _$RMDIR
 37663                                  		db 5
 37664                                  		db 'RMDIR'
 37665                                  		db 1
 37666                                  		dw _$RMDIR
 37667                                  		db 5
 37668                                  		db 'BREAK'
 37669                                  		db 0
 37670                                  		dw CNTRLC
 37671                                  		db 6
 37672                                  		db 'VERIFY'
 37673                                  		db 0
 37674                                  		dw VERIFY
 37675                                  		db 3
 37676                                  		db 'SET'
 37677                                  		db 2
 37678                                  		dw ADD_NAME_TO_ENVIRONMENT
 37679                                  		db 6
 37680                                  		db 'PROMPT'
 37681                                  		db 2
 37682                                  		dw ADD_PROMPT
 37683                                  		db 4
 37684                                  		db 'PATH'
 37685                                  		db 2
 37686                                  		dw PATH
 37687                                  		db 4
 37688                                  		db 'EXIT'
 37689                                  		db 0
 37690                                  		dw _$EXIT
 37691                                  		db 4
 37692                                  		db 'CTTY'
 37693                                  		db 3
 37694                                  		dw CTTY
 37695                                  		db 4
 37696                                  		db 'ECHO'
 37697                                  		db 2
 37698                                  		dw _ECHO
 37699                                  		db 4
 37700                                  		db 'GOTO'
 37701                                  		db 2
 37702                                  		dw _GOTO
 37703                                  		db 5
 37704                                  		db 'SHIFT'
 37705                                  		db 2
 37706                                  		dw _SHIFT
 37707                                  		db 2
 37708                                  		db 'IF'
 37709                                  		db 2
 37710                                  		dw _$IF
 37711                                  		db 3
 37712                                  		db 'FOR'
 37713                                  		db 2
 37714                                  		dw _$FOR
 37715                                  		db 3
 37716                                  		db 'CLS'
 37717                                  		db 0
 37718                                  		dw CLS
 37719                                  		db 0
 37720                                  
 37721                                  CAPITAL_A:	db 'A'
 37722                                  VBAR:		db '|'
 37723                                  LABRACKET:	db '<' ; 3Ch
 37724                                  RABRACKET:	db '>' ; 3Eh
 37725                                  DOLLAR:		db '$'
 37726                                  LPAREN:		db '('
 37727                                  RPAREN:		db ')'
 37728                                  NULLRPAREN:	db ')' ; 29h
 37729                                  		db 0
 37730                                  IN_WORD:	db 'I','N'
 37731                                  DO_WORD	:	db 'D','O'
 37732                                  STAR:		db '*'
 37733                                  CHAR_SUB:	db '-' 
 37734                                  PLUS_CHR:	db '+'
 37735                                  CHAR_L:		db 'L'
 37736                                  char_l:		db 'l'
 37737                                  small_a:	db 'a'
 37738                                  small_z:	db 'z'
 37739                                  CHAR_D:		db 'D'
 37740                                  CHAR_C:		db 'C'
 37741                                  CHAR_S:		db 'S'
 37742                                  CHAR_X:		db 'X'
 37743                                  DOT_CHR:	db '.' 
 37744                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 37745                                  		db ','
 37746                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 37747                                  MNCHR:		db 'p'
 37748                                  SYSTEM_CPAGE:	db 0
 37749                                  		db 0
 37750                                  
 37751                                  COMEXT:		db '.COM'
 37752                                  EXEEXT:		db '.EXE'
 37753                                  BATEXT:		db '.BAT'
 37754                                  SWITCH_LIST:	db 'VBAPW'
 37755                                  BATBUFLEN:	dw BATLEN ; 32
 37756                                  
 37757                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 37758                                  
 37759                                  TRANDATAEND:
 37760                                  
 37761                                  %endif
 37762                                  
 37763                                  ;============================================================================
 37764                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37765                                  ;============================================================================
 37766                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37767                                  
 37768                                  	; 15/04/2023
 37769 000081E0 00                      	db	0
 37770 000081E1 90                      align 2
 37771                                  
 37772                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 37773                                  ; ---------------------------------------------------------------------------
 37774 000081E2 00                      	db 0
 37775                                  ; Lists of help message numbers for internal commands and /?
 37776                                  
 37777                                  ;;NoHelpMsgs:
 37778 000081E3 B0040000                	dw	1200,0		;M014
 37779                                  BreakHelpMsgs:
 37780 000081E7 14050000                	dw	1300,0
 37781                                  ChcpHelpMsgs:
 37782 000081EB 280529050000            	dw	1320,1321,0
 37783                                  CdHelpMsgs:
 37784 000081F1 3C053D053E050000        	dw	1340,1341,1342,0
 37785                                  ClsHelpMsgs:
 37786 000081F9 50050000                	dw	1360,0
 37787                                  CopyHelpMsgs:
 37788 000081FD 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 37788 00008206 050000             
 37789                                  CttyHelpMsgs:
 37790 00008209 8C050000                	dw	1420,0
 37791                                  DateHelpMsgs:
 37792 0000820D A005A1050000            	dw	1440,1441,0
 37793                                  DelHelpMsgs:
 37794 00008213 B405B505B6050000        	dw	1460,1461,1462,0
 37795                                  DirHelpMsgs:
 37796 0000821B C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 37796 00008224 05CD05CE05CF05D005 
 37797                                  	; MSDOS 6.0 COMMAND.COM
 37798                                  	;dw	1489,1490,1491,1492
 37799 0000822D 0000                    	dw	0
 37800                                  ExitHelpMsgs:
 37801 0000822F DC050000                	dw	1500,0
 37802                                  MdHelpMsgs:
 37803 00008233 F0050000                	dw	1520,0
 37804                                  PathHelpMsgs:
 37805 00008237 0406050606060000        	dw	1540,1541,1542,0
 37806                                  PromptHelpMsgs:
 37807 0000823F 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 37807 00008248 061D061E061F062006-
 37807 00008251 0000               
 37808                                  RdHelpMsgs:
 37809 00008253 2C060000                	dw	1580,0
 37810                                  RenHelpMsgs:
 37811 00008257 4006410642060000        	dw	1600,1601,1602,0
 37812                                  SetHelpMsgs:
 37813 0000825F 5406550656060000        	dw	1620,1621,1622,0
 37814                                  TimeHelpMsgs:
 37815 00008267 680669060000            	dw	1640,1641,0
 37816                                  TypeHelpMsgs:
 37817 0000826D 7C060000                	dw	1660,0
 37818                                  VerHelpMsgs:
 37819 00008271 90060000                	dw	1680,0
 37820                                  VerifyHelpMsgs:
 37821 00008275 A4060000                	dw	1700,0
 37822                                  VolHelpMsgs:
 37823 00008279 B8060000                	dw	1720,0
 37824                                  CallHelpMsgs:
 37825 0000827D CC06CD060000            	dw	1740,1741,0	;M014
 37826                                  RemHelpMsgs:
 37827 00008283 E0060000                	dw	1760,0		;M014
 37828                                  PauseHelpMsgs:
 37829 00008287 F4060000                	dw	1780,0		;M014
 37830                                  EchoHelpMsgs:
 37831 0000828B 080709070000            	dw	1800,1801,0	;M014
 37832                                  GotoHelpMsgs:
 37833 00008291 1C071D070000            	dw	1820,1821,0	;M014
 37834                                  ShiftHelpMsgs:
 37835 00008297 30070000                	dw	1840,0		;M014
 37836                                  IfHelpMsgs:
 37837 0000829B 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 37837 000082A4 0749074A070000     
 37838                                  ForHelpMsgs:
 37839 000082AB 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 37839 000082B4 00                 
 37840                                  TruenameHelpMsgs:
 37841 000082B5 6C070000                	 dw	1900,0		;M014
 37842                                  LoadhighHelpMsgs:
 37843 000082B9 800781078207            	dw	1920,1921,1922
 37844                                  	; MSDOS 6.0 COMMAND.COM
 37845                                  	;dw	1923,1924,1925,1926,1927 ;M014
 37846 000082BF 0000                    	dw	0
 37847                                  
 37848                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 37849                                  CLSSTRING:
 37850 000082C1 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 37851                                  
 37852                                  PROMPT_TABLE:
 37853 000082C6 42                      	db	"B"
 37854 000082C7 [FA1D]                  	dw	Print_B
 37855 000082C9 44                      	db	"D"
 37856 000082CA [FA36]                  	dw	PRINT_DATE
 37857 000082CC 45                      	db	"E"
 37858 000082CD [EE1D]                  	dw	PRINT_ESC
 37859 000082CF 47                      	db	"G"
 37860 000082D0 [F21D]                  	dw	PRINT_G
 37861 000082D2 48                      	db	"H"
 37862 000082D3 [E41D]                  	dw	PRINT_BACK
 37863 000082D5 4C                      	db	"L"
 37864 000082D6 [F61D]                  	dw	PRINT_L
 37865 000082D8 4E                      	db	"N"
 37866 000082D9 [0B1E]                  	dw	PRINT_DRIVE
 37867 000082DB 50                      	db	"P"
 37868 000082DC [131E]                  	dw	build_dir_for_prompt
 37869 000082DE 51                      	db	"Q"
 37870 000082DF [EA1D]                  	dw	PRINT_EQ
 37871 000082E1 54                      	db	"T"
 37872 000082E2 [9D2F]                  	dw	PRINT_TIME
 37873 000082E4 56                      	db	"V"
 37874 000082E5 [7A1D]                  	dw	PRINT_VERSION
 37875 000082E7 5F                      	db	"_"
 37876 000082E8 [D925]                  	dw	CRLF2
 37877 000082EA 24                      	db	"$"
 37878 000082EB [FC1D]                  	dw	PRINT_CHAR
 37879 000082ED 00                      	db	0			; NUL TERMINATED
 37880                                  
 37881                                  ; Table of IF conditionals
 37882                                  IFTAB:
 37883 000082EE 034E4F54                	db	3,"NOT"			; First byte is count
 37884 000082F2 [E50A]                  	dw	IFNOT
 37885 000082F4 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 37885 000082FD 454C               
 37886 000082FF [A40B]                  	dw	IFERLEV
 37887 00008301 054558495354            	db	5,"EXIST"
 37888 00008307 [390B]                  	dw	IFEXISTS
 37889 00008309 00                      	db	0
 37890                                  
 37891                                  ; Table for internal command names
 37892                                  COMTAB:
 37893 0000830A 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 37894 0000830F [6C10]                  	dw	CATALOG			; In TCMD1.ASM
 37895 00008311 [1B82]                  	dw	DirHelpMsgs
 37896                                  
 37897 00008313 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 37898 00008319 [190C]                  	dw	_$CALL			; In TBATCH2.ASM
 37899 0000831B [7D82]                  	dw	CallHelpMsgs
 37900                                  
 37901 0000831D 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 37902 00008323 [5920]                  	dw	CHCP			; In TCMD2B.ASM
 37903 00008325 [EB81]                  	dw	ChcpHelpMsgs
 37904                                  
 37905 00008327 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37906 0000832F [501A]                  	dw	CRENAME			; In TCMD1.ASM
 37907 00008331 [5782]                  	dw	RenHelpMsgs
 37908                                  
 37909 00008333 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37910 00008338 [501A]                  	dw	CRENAME			; In TCMD1.ASM
 37911 0000833A [5782]                  	dw	RenHelpMsgs
 37912                                  	
 37913 0000833C 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 37914 00008343 [CB19]                  	dw	ERASE			; In TCMD1.ASM
 37915 00008345 [1382]                  	dw	DelHelpMsgs
 37916                                  	
 37917 00008347 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 37918 0000834C [CB19]                  	dw	ERASE			; In TCMD1.ASM
 37919 0000834E [1382]                  	dw	DelHelpMsgs
 37920                                  	
 37921 00008350 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37922 00008356 [F71A]                  	dw	TYPEFIL			; In TCMD1.ASM
 37923 00008358 [6D82]                  	dw	TypeHelpMsgs
 37924                                  	
 37925 0000835A 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 37926 0000835F [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 37927 00008361 [8382]                  	dw	RemHelpMsgs
 37928                                  	
 37929 00008363 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 37930 00008369 [4737]                  	dw	COPY			; In COPY.ASM
 37931 0000836B [FD81]                  	dw	CopyHelpMsgs
 37932                                  	
 37933 0000836D 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 37934 00008374 [BF19]                  	dw	PAUSE			; In TCMD1.ASM
 37935 00008376 [8782]                  	dw	PauseHelpMsgs
 37936                                  	
 37937 00008378 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 37938 0000837E [A42E]                  	dw	DATE			; In TPIPE.ASM
 37939 00008380 [0D82]                  	dw	DateHelpMsgs
 37940                                  	
 37941 00008382 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 37942 00008388 [092F]                  	dw	CTIME			; In TPIPE.ASM
 37943 0000838A [6782]                  	dw	TimeHelpMsgs
 37944                                  	
 37945 0000838C 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 37946 00008391 [191D]                  	dw	VERSION			; In TCMD2.ASM
 37947 00008393 [7182]                  	dw	VerHelpMsgs
 37948                                  	
 37949 00008395 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37950 0000839A [1E1C]                  	dw	VOLUME			; In TCMD1.ASM
 37951 0000839C [7982]                  	dw	VolHelpMsgs
 37952                                  	
 37953 0000839E 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37954 000083A2 [9F24]                  	dw	_$CHDIR			; In TENV.ASM
 37955 000083A4 [F181]                  	dw	CdHelpMsgs
 37956                                  	
 37957 000083A6 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37958 000083AD [9F24]                  	dw	_$CHDIR			; In TENV.ASM
 37959 000083AF [F181]                  	dw	CdHelpMsgs
 37960                                  	
 37961 000083B1 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37962 000083B5 [0725]                  	dw	_$MKDIR			; In TENV.ASM
 37963 000083B7 [3382]                  	dw	MdHelpMsgs
 37964                                  	
 37965 000083B9 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37966 000083C0 [0725]                  	dw	_$MKDIR			; In TENV.ASM
 37967 000083C2 [3382]                  	dw	MdHelpMsgs
 37968                                  	
 37969 000083C4 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37970 000083C8 [4925]                  	dw	_$RMDIR			; In TENV.ASM
 37971 000083CA [5382]                  	dw	RdHelpMsgs
 37972                                  	
 37973 000083CC 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37974 000083D3 [4925]                  	dw	_$RMDIR			; In TENV.ASM
 37975 000083D5 [5382]                  	dw	RdHelpMsgs
 37976                                  	
 37977 000083D7 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 37978 000083DE [4436]                  	dw	CNTRLC			; In TUCODE.ASM
 37979 000083E0 [E781]                  	dw	BreakHelpMsgs
 37980                                  	
 37981 000083E2 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 37982 000083EA [8636]                  	dw	VERIFY			; In TUCODE.ASM
 37983 000083EC [7582]                  	dw	VerifyHelpMsgs
 37984                                  	
 37985 000083EE 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 37986 000083F3 [0922]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 37987 000083F5 [5F82]                  	dw	SetHelpMsgs
 37988                                  	
 37989 000083F7 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 37990 000083FF [EF21]                  	dw	ADD_PROMPT		; In TENV.ASM
 37991 00008401 [3F82]                  	dw	PromptHelpMsgs
 37992                                  	
 37993 00008403 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 37994 00008409 [7A1E]                  	dw	PATH			; In TCMD2.ASM
 37995 0000840B [3782]                  	dw	PathHelpMsgs
 37996                                  	
 37997 0000840D 044558495400            	db	4,"EXIT",0
 37998 00008413 [5121]                  	dw	_$EXIT			; In TCMD2.ASM
 37999 00008415 [2F82]                  	dw	ExitHelpMsgs
 38000                                  	
 38001 00008417 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 38002 0000841D [B81F]                  	dw	CTTY			; In TCMD2.ASM
 38003 0000841F [0982]                  	dw	CttyHelpMsgs
 38004                                  	
 38005 00008421 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 38006 00008427 [0B36]                  	dw	_ECHO			; In TUCODE.ASM
 38007 00008429 [8B82]                  	dw	EchoHelpMsgs
 38008                                  	
 38009 0000842B 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 38010 00008431 [4D0C]                  	dw	_GOTO			; In TBATCH.ASM
 38011 00008433 [9182]                  	dw	GotoHelpMsgs
 38012                                  	
 38013 00008435 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 38014 0000843C [D20B]                  	dw	_SHIFT			; In TBATCH.ASM
 38015 0000843E [9782]                  	dw	ShiftHelpMsgs
 38016                                  	
 38017 00008440 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 38018 00008444 [7E0A]                  	dw	_$IF			; In TBATCH.ASM
 38019 00008446 [9B82]                  	dw	IfHelpMsgs
 38020                                  	
 38021 00008448 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 38022 0000844D [050F]                  	dw	_$FOR			; In TBATCH.ASM
 38023 0000844F [AB82]                  	dw	ForHelpMsgs
 38024                                  	
 38025 00008451 03434C5300              	db	3,"CLS",0
 38026 00008456 [1F1F]                  	dw	CLS			; In TCMD2.ASM
 38027 00008458 [F981]                  	dw	ClsHelpMsgs
 38028                                  	
 38029 0000845A 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 38029 00008463 03                 
 38030 00008464 [DA20]                  	dw	TRUENAME		;AN000;
 38031 00008466 [B582]                  	dw	TruenameHelpMsgs
 38032                                  	
 38033 00008468 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 38033 00008471 02                 
 38034 00008472 [7E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38035 00008474 [B982]                  	dw	LoadhighHelpMsgs	; M003
 38036                                  	
 38037 00008476 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 38038 0000847A [7E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38039 0000847C [B982]                  	dw	LoadhighHelpMsgs	; M003
 38040                                  	
 38041 0000847E 00                      	db	0			; Terminate command table
 38042                                  
 38043                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 38044                                  
 38045 0000847F 2E434F4D                comext:	db	".COM"
 38046 00008483 2E455845                exeext:	db	".EXE"
 38047 00008487 2E424154                batext:	db	".BAT"
 38048                                  
 38049                                  switch_list:
 38050 0000848B 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 38051                                  
 38052                                  AttrLtrs:
 38053 00008491 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 38054                                  
 38055                                  ;	Attribute letters in AttrLtrs must appear in the order that
 38056                                  ;	attribute bits occur in the attribute byte returned by
 38057                                  ;	directory searches, starting with bit 0.
 38058                                  ;	The volume label attribute is lowercased to keep it from
 38059                                  ;	being matched (by an uppercase comparison).
 38060                                  
 38061                                  OrderLtrs:
 38062 00008497 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 38063                                  	; MSDOS 6.0 COMMAND.COM
 38064                                  	;db	"NEDSGC"		; sort order letters for DIR
 38065                                  
 38066                                  ;	Sort order letters stand for file name, extension,
 38067                                  ;	date/time, size, grouped (directory files before others),
 38068                                  ;	and compression ratio. DIR routines rely on the specific
 38069                                  ;	order of the letters in this list.
 38070                                  
 38071                                  comspec_flag:
 38072 0000849C 00                      	db	0                       ;AN071;
 38073                                  
 38074                                  BATBUFLEN:
 38075 0000849D 2000                    	dw	BatLen ; 32
 38076                                  
 38077                                  ; *****************************************************
 38078                                  ; EMG 4.00
 38079                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 38080                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 38081                                  ; *****************************************************
 38082                                  
 38083                                  ; COMMON PARSE BLOCKS
 38084                                  
 38085                                  ; Indicates no value list for PARSE.
 38086                                  
 38087                                  NO_VALUES:
 38088 0000849F 0000                    	dw	0			;AN000;  no values
 38089                                  
 38090                                  NULL_VALUE_LIST:  ; for unvalidated value
 38091 000084A1 00                       	db	0                       ; no value lists
 38092                                  
 38093                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38094                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 38095                                  
 38096                                  ; PARSE control block for a required file specification (upper cased)
 38097                                  
 38098                                  FILE_REQUIRED:
 38099 000084A2 0002                    	dw	0200h			;AN000;  filespec - required
 38100 000084A4 0100                    	dw	1			;AN000;  capitalize - file table
 38101 000084A6 [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38102 000084A8 [9F84]                  	dw	NO_VALUES		;AN000;
 38103 000084AA 00                      	db	0			;AN000;  no keywords
 38104                                  
 38105                                  ; PARSE control block for an optional file specification (upper cased)
 38106                                  ; or drive number
 38107                                  
 38108                                  FILE_OPTIONAL:
 38109 000084AB 0103                    	dw	0301h			;AN000;  filespec or drive number
 38110                                  					;	 optional
 38111 000084AD 0100                    	dw	1			;AN000;  capitalize - file table
 38112 000084AF [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38113 000084B1 [9F84]                  	dw	NO_VALUES		;AN000;
 38114 000084B3 00                      	db	0			;AN000;  no keywords
 38115                                  
 38116                                  ; PARSE control block for an optional file specification (upper cased)
 38117                                  
 38118                                  FILE_OPTIONAL2:
 38119 000084B4 0102                    	dw	0201h                   ;AN000;  filespec optional
 38120 000084B6 0100                    	dw	1                       ;AN000;  capitalize - file table
 38121 000084B8 [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38122 000084BA [9F84]                  	dw	NO_VALUES		;AN000;
 38123 000084BC 00                      	db	0			;AN000;  no keywords
 38124                                  
 38125                                  ; PARSE control block for an optional /P switch
 38126                                  
 38127                                  SLASH_P_SWITCH:
 38128 000084BD 0000                    	dw	0			;AN000;  no match flags
 38129 000084BF 0200                    	dw	2			;AN000;  capitalize - char table
 38130 000084C1 [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38131 000084C3 [9F84]                  	dw	NO_VALUES		;AN000;
 38132 000084C5 01                      	db	1			;AN000;  1 keyword
 38133                                  SLASH_P_SYN:
 38134 000084C6 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38135                                  
 38136                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38137                                  
 38138                                  ; The following parse control block can be used for any command which
 38139                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38140                                  ; the equal sign as an additional delimiter. Returns verified result
 38141                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38142                                  ; internal commands.
 38143                                  
 38144                                  PARSE_BREAK:
 38145 000084C9 [CC84]                  	dw	BREAK_PARMS		;AN000;
 38146 000084CB 00                      	db	0			;AN032; no extra delimiter
 38147                                  
 38148                                  BREAK_PARMS:
 38149 000084CC 0001                    	db	0,1			;AN000;  1 positional parm
 38150 000084CE [D284]                  	dw	BREAK_CONTROL1		;AN000;
 38151 000084D0 00                      	db	0			;AN000;  no switches
 38152 000084D1 00                      	db	0			;AN000;  no keywords
 38153                                  
 38154                                  BREAK_CONTROL1:
 38155 000084D2 0120                    	dw	2001h			;AN000;  string value - optional
 38156 000084D4 0200                    	dw	2			;AN000;  capitalize - char table
 38157 000084D6 [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38158 000084D8 [DB84]                  	dw	BREAK_VALUES		;AN000;
 38159 000084DA 00                      	db	0			;AN000;  no keywords
 38160                                  
 38161                                  BREAK_VALUES:
 38162 000084DB 03                      	db	3			;AN000;
 38163 000084DC 00                      	db	0			;AN000;  no ranges
 38164 000084DD 00                      	db	0			;AN000;  no numeric values
 38165 000084DE 02                      	db	2			;AN000;  2 string values
 38166 000084DF 00                      	db	0			;AN000;  returned if ON
 38167 000084E0 [E584]                  	dw	BREAK_ON		;AN000;  point to ON string
 38168 000084E2 66                      	db	'f'                     ;AN000;  returned if OFF
 38169 000084E3 [E884]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38170                                  
 38171                                  BREAK_ON:
 38172 000084E5 4F4E00                  	db	"ON",0                  ;AN000;
 38173                                  BREAK_OFF:
 38174 000084E8 4F464600                	db	"OFF",0                 ;AN000;
 38175                                  
 38176                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38177                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38178                                  
 38179                                  ; PARSE BLOCK FOR CHCP
 38180                                  
 38181                                  ; The following parse control block can be used for any command which
 38182                                  ; needs only one optional three digit decimal parameter for operands.
 38183                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38184                                  ; CHCP internal command.
 38185                                  
 38186                                  CHCP_MINVAL	EQU	100			;AN000;
 38187                                  CHCP_MAXVAL	EQU	999			;AN000;
 38188                                  
 38189                                  PARSE_CHCP:
 38190 000084EC [EF84]                  	dw	CHCP_PARMS			;AN000;
 38191 000084EE 00                      	db	0				;AN000;  no extra delimiter
 38192                                  CHCP_PARMS:
 38193 000084EF 0001                    	db	0,1				;AN000;  1 positional parm
 38194 000084F1 [F584]                  	dw	CHCP_CONTROL1			;AN000;
 38195 000084F3 00                      	db	0				;AN000;  no switches
 38196 000084F4 00                      	db	0				;AN000;  no keywords
 38197                                  
 38198                                  CHCP_CONTROL1:
 38199 000084F5 0180                    	dw	8001h				;AN000;  numeric value - optional
 38200 000084F7 0000                    	dw	0				;AN000;  no function flags
 38201 000084F9 [EF95]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38202 000084FB [FE84]                  	dw	CHCP_VALUES			;AN000;
 38203 000084FD 00                      	db	0				;AN000;  no keywords
 38204                                  
 38205                                  CHCP_VALUES:
 38206 000084FE 01                      	db	1				;AN000;
 38207 000084FF 01                      	db	1				;AN000;  1 range
 38208 00008500 01                      	db	1				;AN000;  returned if result
 38209 00008501 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38210 00008509 00                      	db	0				;AN000;  no numeric values
 38211 0000850A 00                      	db	0				;AN000;  no string values
 38212                                  
 38213                                  ; PARSE BLOCK FOR DATE
 38214                                  
 38215                                  ; The following parse control block can be used for any command which
 38216                                  ; needs only an optional date string as an operand. Returns unverified
 38217                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38218                                  
 38219                                  PARSE_DATE:
 38220 0000850B [0E85]                  	dw	DATE_PARMS			;AN000;
 38221 0000850D 00                      	db	0				;AN000;  no extra delimiter
 38222                                  DATE_PARMS:
 38223 0000850E 0001                    	db	0,1				;AN000;  1 positional parm
 38224 00008510 [1485]                  	dw	DATE_CONTROL1			;AN000;
 38225 00008512 00                      	db	0				;AN000;  no switches
 38226 00008513 00                      	db	0				;AN000;  no keywords
 38227                                  
 38228                                  DATE_CONTROL1:
 38229 00008514 0110                    	dw	1001h				;AN000;  date - optional
 38230 00008516 0000                    	dw	0				;AN000;  no function flags
 38231 00008518 [F795]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38232 0000851A [9F84]                  	dw	NO_VALUES			;AN000;
 38233 0000851C 00                      	db	0				;AN000;  no keywords
 38234                                  
 38235                                  ; PARSE BLOCK FOR TIME
 38236                                  
 38237                                  ; The following parse control block can be used for any command which
 38238                                  ; needs only an optional time string as an operand. Returns unverified
 38239                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38240                                  
 38241                                  PARSE_TIME:
 38242 0000851D [2085]                  	dw	TIME_PARMS			;AN000;
 38243 0000851F 00                      	db	0				;AN000;  no extra delimiter
 38244                                  TIME_PARMS:
 38245 00008520 0001                    	db	0,1				;AN000;  1 positional parm
 38246 00008522 [2685]                  	dw	TIME_CONTROL1			;AN000;
 38247 00008524 00                      	db	0				;AN000;  no switches
 38248 00008525 00                      	db	0				;AN000;  no keywords
 38249                                  
 38250                                  TIME_CONTROL1:
 38251 00008526 0108                    	dw	0801h				;AN000;  TIME - optional
 38252 00008528 0000                    	dw	0				;AN000;  no function flags
 38253 0000852A [FF95]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38254 0000852C [9F84]                  	dw	NO_VALUES			;AN000;
 38255 0000852E 00                      	db	0				;AN000;  no keywords
 38256                                  
 38257                                  ; PARSE BLOCK FOR VOL
 38258                                  
 38259                                  ; The following parse control block can be used for any command which
 38260                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38261                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38262                                  ; internal command.
 38263                                  
 38264                                  PARSE_VOL:
 38265 0000852F [3285]                  	dw	VOL_PARMS			;AN000;
 38266 00008531 00                      	db	0				;AN000;  no extra delimiter
 38267                                  VOL_PARMS:
 38268 00008532 0001                    	db	0,1				;AN000;  1 positional parm
 38269 00008534 [3885]                  	dw	DRIVE_CONTROL1			;AN000;
 38270 00008536 00                      	db	0				;AN000;  no switches
 38271 00008537 00                      	db	0				;AN000;  no keywords
 38272                                  
 38273                                  DRIVE_CONTROL1:
 38274 00008538 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38275 0000853A 0100                    	dw	1				;AN000;  capitalize - file table
 38276 0000853C [0796]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38277 0000853E [9F84]                  	dw	NO_VALUES			;AN000;
 38278 00008540 00                      	db	0				;AN000;  no keywords
 38279                                  
 38280                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38281                                  
 38282                                  ; The following parse control block can be used for any command which
 38283                                  ; needs only one required file specification as an operand. Returns a
 38284                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38285                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38286                                  
 38287                                  PARSE_MRDIR:
 38288 00008541 [4485]                  	dw	MRDIR_PARMS			;AN000;
 38289 00008543 00                      	db	0				;AN000;  no extra delimiter
 38290                                  MRDIR_PARMS:
 38291 00008544 0101                    	db	1,1				;AN000;  1 positional parm
 38292 00008546 [A284]                  	dw	FILE_REQUIRED			;AN000;
 38293 00008548 00                      	db	0				;AN000;  no switches
 38294 00008549 00                      	db	0				;AN000;  no keywords
 38295                                  
 38296                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38297                                  
 38298                                  ; The following parse control block can be used for any command which
 38299                                  ; needs only one optional file specification an operand. Returns a
 38300                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38301                                  ; for the CHDIR and TRUENAME internal commands.
 38302                                  
 38303                                  PARSE_CHDIR:
 38304 0000854A [4D85]                  	dw	CHDIR_PARMS			;AN000;
 38305 0000854C 00                      	db	0				;AN000;  no extra delimiter
 38306                                  CHDIR_PARMS:
 38307 0000854D 0001                    	db	0,1				;AN000;  1 positional parm
 38308 0000854F [AB84]                  	dw	FILE_OPTIONAL			;AN000;
 38309 00008551 00                      	db	0				;AN000;  no switches
 38310 00008552 00                      	db	0				;AN000;  no keywords
 38311                                  
 38312                                  ; PARSE BLOCK FOR ERASE
 38313                                  
 38314                                  ; The following parse control block is used for the DEL/ERASE internal
 38315                                  ; commands. This command has one required file specification and an
 38316                                  ; optional switch (/p) as operands. The verified switch or unverified
 38317                                  ; file specification is returned in PARSE1_OUTPUT.
 38318                                  
 38319                                  PARSE_ERASE:
 38320 00008553 [5685]                  	dw	ERASE_PARMS			;AN000;
 38321 00008555 00                      	db	0				;AN000;  no extra delimiter
 38322                                  
 38323                                  ERASE_PARMS:
 38324 00008556 0101                    	db	1,1				;AN000;  1 positional parm
 38325 00008558 [A284]                  	dw	FILE_REQUIRED			;AN000;
 38326 0000855A 01                      	db	1				;AN000;  1 switch
 38327 0000855B [BD84]                  	dw	SLASH_P_SWITCH			;AN000;
 38328 0000855D 00                      	db	0				;AN000;  no keywords
 38329                                  
 38330                                  ; PARSE BLOCK FOR DIR
 38331                                  
 38332                                  ; The following parse control block is used for the DIR internal command.
 38333                                  ; This command has one optional file specification and several optional
 38334                                  ; switches. Switches, switch values, and the filespec are returned in 
 38335                                  ; PARSE1_OUTPUT.
 38336                                  ;
 38337                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38338                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38339                                  ; do not require colons, and are not checked against a value list.
 38340                                  ;
 38341                                  ; Switch /h has been removed from the DIR command	;M008
 38342                                  ; Switch /? is no longer handled internally		;M008
 38343                                  ;
 38344                                  ; A list of pointers to all the switch synonyms is provided here to
 38345                                  ; help identify which switch has been matched.
 38346                                  
 38347                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38348                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38349                                  
 38350                                  PARSE_DIR:
 38351 0000855E [6185]                  	dw	DIR_PARMS
 38352 00008560 00                      	db	0			; no extra delimiters
 38353                                  DIR_PARMS:
 38354 00008561 0001                    	db	0,1			; 1 optional positional param
 38355 00008563 [B484]                  	dw	FILE_OPTIONAL2
 38356 00008565 02                      	db	2			; 2 kinds of switches
 38357 00008566 [6B85]                  	dw	DIR_SW_VALUED
 38358 00008568 [7A85]                  	dw	DIR_SW_UNVALUED
 38359 0000856A 00                      	db	0			; no keywords
 38360                                  
 38361                                  DIR_SW_VALUED:
 38362 0000856B 0120                    	dw	2001h			; optional string value
 38363 0000856D 2100                    	dw	21h			; optional colon; capitalize 
 38364 0000856F [EF95]                  	dw	PARSE1_OUTPUT		; result buffer
 38365 00008571 [A184]                  	dw	NULL_VALUE_LIST		; don't validate value
 38366                                  
 38367 00008573 02                      	db	2
 38368                                  
 38369                                  ; MSDOS 6.0 COMMAND.COM
 38370                                  ;ifdef DBLSPACE_HOOKS
 38371                                  ;	db	3		; 3 'synonyms'
 38372                                  ;else
 38373                                  ;	db	2		; 2 'synonyms'
 38374                                  ;endif
 38375                                  
 38376                                  DIR_SW_A:
 38377 00008574 2F4100                  	db	"/A",0
 38378                                  DIR_SW_O:
 38379 00008577 2F4F00                  	db	"/O",0
 38380                                  
 38381                                  ; MSDOS 6.0 COMMAND.COM
 38382                                  ;ifdef DBLSPACE_HOOKS
 38383                                  ;DIR_SW_C	db	"/C",0
 38384                                  ;endif
 38385                                  
 38386                                  DIR_SW_UNVALUED:
 38387 0000857A 0000                    	dw	0			; no value
 38388 0000857C 0000                    	dw	0			; no format functions
 38389 0000857E [EF95]                  	dw	PARSE1_OUTPUT		; result buffer
 38390 00008580 [9F84]                  	dw	NO_VALUES
 38391                                  
 38392                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38393                                  	;db	12
 38394                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38395 00008582 0E                      	db	14		; 14 'synonyms' !?
 38396                                  
 38397                                  ; MSDOS 6.0 COMMAND.COM
 38398                                  ;ifdef DBLSPACE_HOOKS
 38399                                  ;	db	13		; 13 'synonyms'
 38400                                  ;else
 38401                                  ;	db	12		; 12 'synonyms'
 38402                                  ;endif
 38403                                  
 38404                                  DIR_SW_NEG_A:
 38405 00008583 2F2D4100                	db	"/-A",0
 38406                                  DIR_SW_NEG_O:
 38407 00008587 2F2D4F00                	db	"/-O",0
 38408                                  DIR_SW_S:
 38409 0000858B 2F5300                  	db	"/S",0
 38410                                  DIR_SW_NEG_S:
 38411 0000858E 2F2D5300                	db	"/-S",0
 38412                                  DIR_SW_B:
 38413 00008592 2F4200                  	db	"/B",0
 38414                                  DIR_SW_NEG_B:
 38415 00008595 2F2D4200                	db	"/-B",0
 38416                                  DIR_SW_W:
 38417 00008599 2F5700                  	db	"/W",0
 38418                                  DIR_SW_NEG_W:
 38419 0000859C 2F2D5700                	db	"/-W",0
 38420                                  DIR_SW_P:
 38421 000085A0 2F5000                  	db	"/P",0
 38422                                  DIR_SW_NEG_P:
 38423 000085A3 2F2D5000                	db	"/-P",0
 38424                                  DIR_SW_L:
 38425 000085A7 2F4C00                  	db	"/L",0		;M010
 38426                                  DIR_SW_NEG_L:
 38427 000085AA 2F2D4C00                	db	"/-L",0 	;M010
 38428                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38429                                  ;DIR_SW_NEG_C:
 38430                                  ;	db	"/-C",0
 38431                                  
 38432                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38433                                  ; identification. Order is critical - DIR routines rely on the
 38434                                  ; specific order in this list. Negated options appear at odd 
 38435                                  ; positions in the list, and simple on/off options appear first.
 38436                                  
 38437                                  Dir_Sw_Ptrs:
 38438                                  	; MSDOS 5.0 COMMAND.COM
 38439 000085AE [9C85]                  	dw	DIR_SW_NEG_W 
 38440                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38441                                  	; MSDOS 6.0 COMMAND.COM
 38442                                  	;dw	DIR_SW_NEG_C
 38443                                  	;dw	DIR_SW_C
 38444                                  	;dw	DIR_SW_NEG_W
 38445                                  	
 38446 000085B0 [9985]                  	dw	DIR_SW_W
 38447 000085B2 [A385]                  	dw	DIR_SW_NEG_P
 38448 000085B4 [A085]                  	dw	DIR_SW_P
 38449 000085B6 [8E85]                  	dw	DIR_SW_NEG_S
 38450 000085B8 [8B85]                  	dw	DIR_SW_S
 38451 000085BA [9585]                  	dw	DIR_SW_NEG_B
 38452 000085BC [9285]                  	dw	DIR_SW_B
 38453 000085BE [AA85]                  	dw	DIR_SW_NEG_L	;M010
 38454 000085C0 [A785]                  	dw	DIR_SW_L	;M010
 38455 000085C2 [8785]                  	dw	DIR_SW_NEG_O
 38456 000085C4 [7785]                  	dw	DIR_SW_O
 38457 000085C6 [8385]                  	dw	DIR_SW_NEG_A
 38458 000085C8 [7485]                  	dw	DIR_SW_A
 38459                                  
 38460                                  ; PARSE BLOCK FOR RENAME
 38461                                  
 38462                                  ; The following parse control block can be used for any command which
 38463                                  ; needs only two required file specifications as operands. Returns
 38464                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38465                                  ; Currently used for the RENAME internal command.
 38466                                  
 38467                                  PARSE_RENAME:
 38468 000085CA [CD85]                  	dw	RENAME_PARMS		;AN000;
 38469 000085CC 00                      	db	0			;AN000;  no extra delimiter
 38470                                  RENAME_PARMS:
 38471 000085CD 0202                    	db	2,2			;AN000;  2 positional parms
 38472 000085CF [A284]                  	dw	FILE_REQUIRED		;AN000;
 38473 000085D1 [A284]                  	dw	FILE_REQUIRED		;AN000;
 38474 000085D3 00                      	db	0			;AN000;  no switches
 38475 000085D4 00                      	db	0			;AN000;  no keywords
 38476                                  
 38477                                  ; PARSE BLOCK FOR CTTY
 38478                                  
 38479                                  ; The following parse control block can be used for any command which
 38480                                  ; needs one required device name as an operand. Returns a pointer to
 38481                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38482                                  ; internal command.
 38483                                  
 38484                                  PARSE_CTTY:
 38485 000085D5 [D885]                  	dw	CTTY_PARMS		;AN000;
 38486 000085D7 00                      	db	0			;AN000;  no extra delimiter
 38487                                  CTTY_PARMS:
 38488 000085D8 0101                    	db	1,1			;AN000;  1 positional parm
 38489 000085DA [DE85]                  	dw	CTTY_CONTROL1		;AN000;
 38490 000085DC 00                      	db	0			;AN000;  no switches
 38491 000085DD 00                      	db	0			;AN000;  no keywords
 38492                                  CTTY_CONTROL1:
 38493 000085DE 0020                    	dw	2000h			;AN000;  string value - required
 38494 000085E0 1100                    	dw	11h			;AN000;  capitalize - file table
 38495                                  					;AN000;  remove colon at end
 38496 000085E2 [EF95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38497 000085E4 [9F84]                  	dw	NO_VALUES		;AN000;
 38498 000085E6 00                      	db	0			;AN000;  no keywords
 38499                                  
 38500                                  ; PARSE BLOCK FOR VER
 38501                                  
 38502                                  ; The following parse control block can be used for any command which
 38503                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38504                                  
 38505                                  PARSE_VER:
 38506 000085E7 [EA85]                  	dw	VER_PARMS
 38507 000085E9 00                      	db	0			; no extra delimiters
 38508                                  VER_PARMS:
 38509 000085EA 0000                    	db	0,0			; no positional parameters
 38510 000085EC 01                      	db	1			; one switch
 38511 000085ED [F085]                  	dw	SLASH_R
 38512 000085EF 00                      	db	0			; no keywords
 38513                                  SLASH_R:
 38514 000085F0 0000                    	dw	0			; no values
 38515 000085F2 0200                    	dw	2			; capitalize by filename table
 38516 000085F4 [EF95]                  	dw	PARSE1_OUTPUT		; result buffer
 38517 000085F6 [9F84]                  	dw	NO_VALUES		; no values
 38518 000085F8 01                      	db	1			; one synonym
 38519                                  SLASH_R_SYN:
 38520 000085F9 2F5200                  	db	"/R",0
 38521                                  
 38522                                  ; M003 ; Start of changes for LoadHigh support
 38523                                  
 38524                                  ;Parse Control Block for LOADHIGH command
 38525                                  
 38526                                  Parse_LoadHi:
 38527 000085FC [FF85]                  	dw	LoadHi_Parms		;extended parm table
 38528 000085FE 00                      	db	0			;no extra delimiters
 38529                                  
 38530                                  LoadHi_Parms:
 38531 000085FF 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 38532 00008601 [A284]                  	dw	FILE_REQUIRED		;control struc for filename
 38533 00008603 00                      	db	0			;no switches
 38534 00008604 00                      	db	0			;no keywords
 38535                                  
 38536                                  ; M003 ; End of changes for LoadHigh support
 38537                                  
 38538                                  TempVarName:
 38539 00008605 54454D503D00            	db	"TEMP=",0
 38540                                  
 38541                                  	; 16/04/2023
 38542                                  TRANDATAEND:		; TRANGROUP:88C2h
 38543                                  
 38544                                  ;============================================================================
 38545                                  ; PSDATA.INC, MSDOS 6.0, 1991
 38546                                  ;============================================================================
 38547                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38548                                  
 38549                                  ; 18/04/2023
 38550                                  TRANSPACESTART:
 38551                                  
 38552                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 38553                                  
 38554                                  ;********************** Local Data *************************************
 38555                                  
 38556                                  $P_ORDINAL:
 38557 0000860B 0000                    	dw	0		;AN000; Operand ordinal save area
 38558                                  $P_RC:
 38559 0000860D 0000                    	dw	0		;AN000; Return code from parser
 38560                                  $P_SI_Save:
 38561 0000860F 0000                    	dw	0		;AN000; Pointer of command buffer
 38562                                  $P_DX:
 38563 00008611 0000                    	dw	0		;AN000; Return result buffer address
 38564                                  $P_Terminator:
 38565 00008613 00                      	db	0		;AN000; Terminator code (ASCII)
 38566                                  $P_DBCSEV_OFF:
 38567 00008614 0000                    	dw	0		;AN000; Offset of DBCS EV
 38568                                  $P_DBCSEV_SEG:
 38569 00008616 0000                    	dw	0		;AN000; Segment of DBCS EV
 38570                                  $P_Flags:			;AN000; Parser internal flags
 38571                                  $P_Flags1:
 38572 00008618 00                      	db	0		;AN038; to reference first byte flags
 38573                                  $P_Flags2:
 38574 00008619 00                      	db	0		;AN038; to reference second byte flags only
 38575                                  $P_SaveSI_Cmpx:
 38576 0000861A 0000                    	dw	0		;AN000; save si for later use by complex
 38577                                  $P_KEYorSW_Ptr:
 38578 0000861C 0000                    	dw	0		;AN000; points next to "=" or ":" code
 38579                                  $P_Save_EOB:
 38580 0000861E 0000                    	dw	0		;AN000; save pointer to EOB
 38581                                  $P_Found_SYNONYM:
 38582 00008620 0000                    	dw	0		;AN000; es:@ points to found synonym
 38583                                  $P_STRING_BUF:
 38584 00008622 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 38585                                  $P_ORIG_ORD:
 38586 000086A2 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 38587                                  $P_ORIG_STACK:
 38588 000086A4 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 38589                                  $P_ORIG_SI:
 38590 000086A6 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 38591                                  $P_Got_Time:
 38592 000086A8 00                      	db	0		;AN023; if 1, use Time delimiters
 38593                                  $P_Country_Info:
 38594 000086A9 FFFF                    	dw	-1 ; 0FFFFh
 38595 000086AB 00<rep 20h>             	times	32 db 0	
 38596                                  $P_1st_Val:
 38597 000086CB 0000                    	dw	0		;AN000; used when process date or time
 38598                                  $P_2nd_Val:
 38599 000086CD 0000                    	dw	0		;AN000; used when process date or time
 38600                                  $P_3rd_Val:
 38601 000086CF 0000                    	dw	0		;AN000; used when process date or time
 38602                                  $P_4th_Val:
 38603 000086D1 0000                    	dw	0		;AN000; used when process date or time
 38604                                  $P_Char_CAP_Ptr:
 38605 000086D3 FF                      	db	0FFh		;AN000; info id
 38606 000086D4 0000                    	dw	0		;AN000; offset	of char case map table
 38607 000086D6 0000                    	dw	0		;AN000; segment of char case map table
 38608                                  $P_File_CAP_Ptr:
 38609 000086D8 FF                      	db	0FFh		;AN000; info id
 38610 000086D9 0000                    	dw	0		;AN000; offset	of file case map table
 38611 000086DB 0000                    	dw	0		;AN000; segment of file case map table
 38612                                  
 38613                                  	; 18/04/2023
 38614                                  ;M029
 38615                                  ;!!!WARNING!!!
 38616                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 38617                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 38618                                  ;changes need to be made in SYSPARSE
 38619                                  
 38620                                  $P_FileSp_Char:
 38621 000086DD 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 38622                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 38623                                  
 38624                                  ;filespec error flag
 38625                                  $P_err_flag:
 38626 000086E6 00                      	db	0		;AN033; flag set if filespec parsing error
 38627                                  				;AN033;  was detected.
 38628                                  
 38629                                  ;============================================================================
 38630                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 38631                                  ;============================================================================
 38632                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38633                                  
 38634                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 38635                                  
 38636                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38637                                  ;;
 38638                                  ;; STRUCTURE: $M_RES_ADDRS
 38639                                  ;;
 38640                                  ;; Resident data area definition of variables
 38641                                  ;;
 38642                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38643                                  
 38644                                  $M_RT:
 38645 000086E7 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 38646                                  
 38647                                  ;============================================================================
 38648                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 38649                                  ;============================================================================
 38650                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38651                                  
 38652                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 38653                                  ; ---------------------------------------------------------------------------
 38654                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 38655                                  ;;M031 - changed copyright to 1991
 38656                                  ;;9/16 - changed verison to 6.0 and copyright to 1992
 38657                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 38658                                  ;;B49,50 - changed version to 6 and copyright to 1993
 38659                                  ; ---------------------------------------------------------------------------
 38660                                  
 38661                                  ;;ifdef USA
 38662                                  ;MsDosVer6_CCopy:
 38663                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 38664                                  ;	db	"Licensed Material - Property of Microsoft "
 38665                                  ;	db	"All rights reserved "
 38666                                  ;endif
 38667                                  
 38668                                  ; 15/04/2023
 38669                                  MsDosVer5_CCopy:
 38670 00008774 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 38670 0000877D 7273696F6E20352E30-
 38670 00008786 3020284329436F7079-
 38670 0000878F 726967687420313938-
 38670 00008798 312D31393931204D69-
 38670 000087A1 63726F736F66742043-
 38670 000087AA 6F727020           
 38671 000087AE 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 38671 000087B7 4D6174657269616C20-
 38671 000087C0 2D2050726F70657274-
 38671 000087C9 79206F66204D696372-
 38671 000087D2 6F736F667420       
 38672 000087D8 416C6C207269676874-     	db	"All rights reserved "
 38672 000087E1 732072657365727665-
 38672 000087EA 6420               
 38673                                  ; ---------------------------------------------------------------------------
 38674                                  ; 15/04/2023
 38675                                  	; 16/04/2023 - 21/04/2023
 38676                                  	;db 	0
 38677                                  	;db	0Dh,0Ah
 38678                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 38679                                  	;db	0
 38680                                  	;db	'by Erdogan Tan - 05/05/2023'
 38681                                  	;db	0
 38682                                  
 38683                                  ;============================================================================
 38684                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 38685                                  ;============================================================================
 38686                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38687                                  
 38688                                  PRINTF_HANDLE:
 38689 000087EC 0000                    	dw	0		;AC000;
 38690                                  
 38691                                  ; 15/047/2023
 38692                                  %if 0
 38693                                  
 38694                                  ;============================================================================
 38695                                  ; TSPC.ASM, MSDOS 6.0, 1991
 38696                                  ;============================================================================
 38697                                  ; 29/09/2018 - Retro DOS v3.0
 38698                                  
 38699                                  ;TITLE	COMMAND Transient Uninitialized DATA
 38700                                  
 38701                                  ;The TRANSPACE segment contains variable data that is considered
 38702                                  ;volatile between command cycles, and therefore is not included in the
 38703                                  ;transient checksum area. Contents of these variables MUST be
 38704                                  ;initialized before use, and must not be relied upon from command
 38705                                  ;cycle to command cycle.
 38706                                  ;
 38707                                  ;No constant data values should be stored here.
 38708                                  
 38709                                  ; ---------------------------------------------------------------------------
 38710                                  ; START OF UNITIALIZED DATA
 38711                                  ; ---------------------------------------------------------------------------
 38712                                  
 38713                                  ;	times 12 db 0
 38714                                  
 38715                                  align 16
 38716                                  
 38717                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 38718                                  
 38719                                  PRINTF_LEFT:	db 0
 38720                                  PRINTF_LONG:	db 0
 38721                                  PRINTF_HEX:	db 0
 38722                                  TABLE_INDEX:	db 0
 38723                                  PRINTF_WIDTH:	dw 0
 38724                                  PRINTF_BASE:	dw 0
 38725                                  PAD_CHAR:	db 0
 38726                                  PRINTF_HANDLE:	dw 0
 38727                                  PRINTF_BUF: times 100 db 0
 38728                                  PRINTF_BUF_END: ; 30/09/2018
 38729                                  
 38730                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 38731                                  
 38732                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38733                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38734                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 38735                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 38736                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 38737                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 38738                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 38739                                  
 38740                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 38741                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 38742                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 38743                                  TPA:		dw 0			; LTPA	    (dw 0)	
 38744                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 38745                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 38746                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 38747                                  					; MYSEG1    (dw 0)	
 38748                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 38749                                  					; MYSEG2    (dw 0)	
 38750                                  		dw 0			; RESTEST   (dw 0)	
 38751                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 38752                                  
 38753                                  CHKDRV:		db 0
 38754                                  IFNOTFLAG:
 38755                                  FILTYP:
 38756                                  RDEOF:		db 0			; Misc flags
 38757                                  CURDRV:		db 0
 38758                                  PARM1:
 38759                                  Concat:		db 0
 38760                                  PARM2:
 38761                                  ArgC:		db 0
 38762                                  COMSW:		dw 0			; Switches between command and 1st arg
 38763                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 38764                                  ARG2S:					; Switches after 2nd arg		
 38765                                  DestSwitch:	dw 0
 38766                                  ARGTS:
 38767                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 38768                                  CFLAG:		db 0
 38769                                  DestClosed:
 38770                                  SPECDRV:	db 0
 38771                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 38772                                  NXTADD:		dw 0
 38773                                  FRSTSRCH:	db 0
 38774                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 38775                                  ;PerLine:	db 0			; entries/line u.b. DIR
 38776                                  LINCNT:		db 0
 38777                                  LINLEN:		db 0
 38778                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 38779                                  FILECNT:	dw 0			; file count u.b. DIR
 38780                                  ;FileSiz:	dd 0			; file size u.b. DIR
 38781                                  
 38782                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 38783                                  ;
 38784                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 38785                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 38786                                  
 38787                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 38788                                  
 38789                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 38790                                  DESTFCB2:
 38791                                  IDLEN:		db 0
 38792                                  ID:	  times	8  db 0
 38793                                  COM:	  times	3  db 0 
 38794                                  DEST:	  times 37 db 0
 38795                                  DESTNAME: times 11 db 0
 38796                                  DESTDIR:
 38797                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 38798                                  GOTOLEN:	; word
 38799                                  BWDBUF: 	; byte
 38800                                  EXEFCB: 	; word
 38801                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 38802                                  
 38803                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 38804                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 38805                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 38806                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 38807                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 38808                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 38809                                  
 38810                                  SDIRBUF:  times 12 db 0	
 38811                                  _BITS:		dw 0
 38812                                  PATHCNT:	dw 0
 38813                                  PATHPOS:	dw 0
 38814                                  PATHSW:		dw 0
 38815                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 38816                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 38817                                  LINPERPAG:	db 0
 38818                                  		db 0
 38819                                  COMMA:		db 0			; flag set if +,, occurs
 38820                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 38821                                  
 38822                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 38823                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 38824                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 38825                                  
 38826                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 38827                                  STRING_PTR_1:	dw 0	   ; _4468h	
 38828                                  FILESIZE_L:	dw 0	   ; _446Ah		
 38829                                  FILESIZE_H:	dw 0	   ; _446Ch	
 38830                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 38831                                  
 38832                                  COPY_NUM:	dw 0
 38833                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 38834                                  CPYFLAG:	db 0
 38835                                  DIR_NUM:	dw 0
 38836                                  BYTES_FREE:	dw 0
 38837                                  		dw 0
 38838                                  MAJOR_VER_NUM:	dw 0
 38839                                  MINOR_VER_NUM:	dw 0
 38840                                  ONE_CHAR_VAL:	db 0
 38841                                  		;db 0
 38842                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 38843                                  VOL_DRV:	db 0
 38844                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 38845                                  
 38846                                  ROM_CALL:	db 0			; flag for rom function
 38847                                  ROM_IP:		dw 0
 38848                                  ROM_CS:		dw 0
 38849                                  
 38850                                  DestVars:
 38851                                  DestIsDir:	db 0
 38852                                  DestSiz:	db 0
 38853                                  DestTail:	dw 0
 38854                                  DestInfo:	db 0
 38855                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 38856                                  ENDDESTBUF:
 38857                                  
 38858                                  DESTHAND:	dw 0
 38859                                  DESTISDEV:	db 0
 38860                                  FIRSTDEST:	db 0
 38861                                  MELCOPY:	db 0
 38862                                  MELSTART:	dw 0
 38863                                  
 38864                                  SrcVars:
 38865                                  SrcIsDir:	db 0
 38866                                  SrcSiz:		db 0
 38867                                  SrcTail:	dw 0
 38868                                  SrcInfo:	db 0
 38869                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 38870                                  
 38871                                  SRCHAND:	dw 0
 38872                                  SRCISDEV:	db 0
 38873                                  
 38874                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 38875                                  
 38876                                  SRCPT:		dw 0
 38877                                  INEXACT:	db 0
 38878                                  		db 0 ; MSDOS 3.3 
 38879                                  NOWRITE:	db 0
 38880                                  BINARY:		db 0
 38881                                  WRITTEN:	dw 0
 38882                                  TERMREAD:	db 0
 38883                                  ASCII:		db 0
 38884                                  PLUS:		db 0
 38885                                  OBJCNT:		db 0			; Used in copy
 38886                                  CPDATE:		dw 0
 38887                                  CPTIME:		dw 0
 38888                                  
 38889                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 38890                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 38891                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 38892                                  
 38893                                  BATHAND:	dw 0			; Batch handle
 38894                                  STARTEL:	dw 0
 38895                                  ELCNT:		db 0
 38896                                  ELPOS:		db 0
 38897                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 38898                                  MSDOS 5.0
 38899                                  SKPDEL:
 38900                                  SOURCE:   times	11 db 0
 38901                                  
 38902                                  ext_entered:	db 0			;AN005;
 38903                                  
 38904                                  ;display_ioctl	db 0			;AN000; info level
 38905                                  ;		db 0			;AN000; reserved
 38906                                  ;		dw crt_ioctl_ln		;AN000; length of data
 38907                                  ;		dw 0			;AN000; control flags
 38908                                  ;display_mode:	db 0			;AN000; display mode, colors
 38909                                  ;		db 0			;AN000; reserved
 38910                                  ;		dw 0			;AN023; colors
 38911                                  ;		dw 0			;AN000; display width (PELS)
 38912                                  ;		dw 0			;AN000; display length (PELS)
 38913                                  ;display_width:	dw 0			;AN000; display width
 38914                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 38915                                  ;
 38916                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 38917                                  ;		dw 0			;AN000; info level
 38918                                  ;vol_serial:	dd 0			;AN000; volume serial number
 38919                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 38920                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 38921                                  
 38922                                  EXPAND_STAR:	db 0
 38923                                  
 38924                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 38925                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 38926                                  ;append_exec:	db 0			;AN041; set if internal append executed
 38927                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 38928                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 38929                                  
 38930                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 38931                                  
 38932                                  ; Data declarations taken out of parse.asm
 38933                                  
 38934                                  ; MSDOS 6.0
 38935                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 38936                                  ;argbufptr	dw	?		; index for argv[].argpointer
 38937                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 38938                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 38939                                  ;comptr		dw	?		; ptr into combuf
 38940                                  
 38941                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 38942                                  ARG:
 38943                                  ARG_ARGV:
 38944                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 38945                                  ARGV0_ARG_FLAGS:  db 0
 38946                                  ARGV0_ARGSTARTEL: dw 0
 38947                                  ARGV0_ARGLEN:	  dw 0
 38948                                  ARGV0_ARGSW_WORD: dw 0
 38949                                  ARGV0_OCOMPTR:	  dw 0
 38950                                  
 38951                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 38952                                  	  times 5 db 0
 38953                                  ARGV1_ARGSW_WORD: dw 0
 38954                                  		  dw 0
 38955                                  
 38956                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 38957                                  	  times 5 db 0
 38958                                  ARGV2_ARGSW_WORD: dw 0
 38959                                  		  dw 0
 38960                                  
 38961                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 38962                                  	
 38963                                  ARG_ARGVCNT:	dw 0
 38964                                  ARG_ARGSWINFO:	dw 0
 38965                                  
 38966                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 38967                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 38968                                  
 38969                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 38970                                  
 38971                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 38972                                  TPBUF:    times 128 db 0		; temporary buffer
 38973                                  LASTARG:	dw 0			; point at which to accumulate switch info
 38974                                  COMPTR:		dw 0			; ptr into combuf
 38975                                  
 38976                                  ; Data declarations taken out of path.asm
 38977                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 38978                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 38979                                  ;psep_char	DB	?			; '/' or '\'
 38980                                  ;search_best	DB	(?)			; best code, best filename so far
 38981                                  ;fname_max_len	equ	13
 38982                                  ;search_best_buf DB	fname_max_len DUP (?)
 38983                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 38984                                  ;search_error	DW	(?)			; address of error message to be printed
 38985                                  
 38986                                  FINDBUFLEN equ FIND_BUF.size ; 43
 38987                                  
 38988                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 38989                                  
 38990                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 38991                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 38992                                  PATHINFO:
 38993                                  PATHINFO_0:	dw 0
 38994                                  PATHINFO_2:	dw 0
 38995                                  PATHINFO_4:	dw 0
 38996                                  PSEP_CHAR:	db 0
 38997                                  SEARCH_BEST:	db 0
 38998                                  ;FNAME_MAX_LEN equ 13
 38999                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 39000                                  SEARCH_CURDIR_BUF: times 64 db 0
 39001                                  SEARCH_ERROR:	dw 0
 39002                                  
 39003                                  ; Data declarations taken out of tbatch.asm
 39004                                  
 39005                                  ;if_not_count	DW	?
 39006                                  ;
 39007                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39008                                  ;
 39009                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39010                                  
 39011                                  ; 31/03/2023
 39012                                  STACK:		;LABEL	WORD
 39013                                  
 39014                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 39015                                  
 39016                                  IF_NOT_COUNT:	dw 0
 39017                                  ZFLAG:		db 0
 39018                                  	  times 256 db 0 	
 39019                                  STACK:
 39020                                  
 39021                                  ;INTERNATVARS	internat_block <>
 39022                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39023                                  ;
 39024                                  ;;		Buffer for DOS function 64h (Get extended country information)
 39025                                  ;;		subfunctions 2, 4, 6, or 7:
 39026                                  ;
 39027                                  ;CountryPtrInfo	label	byte
 39028                                  ;CountryPtrId	db	?
 39029                                  ;CountryPtr	dd	?
 39030                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39031                                  
 39032                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 39033                                  
 39034                                  INTERNATVARS:	
 39035                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 39036                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39037                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 39038                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 39039                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 39040                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 39041                                  BIT_FIELD:	db 0			; Bit values
 39042                                  					;   Bit 0 = 0 if currency symbol first
 39043                                  					;	  = 1 if currency symbol last
 39044                                  					;   Bit 1 = 0 if No space after currency symbol
 39045                                  					;	  = 1 if space after currency symbol
 39046                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 39047                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39048                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39049                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39050                                  					;  in pieces.
 39051                                  DATA_SEP:	db 0,0			; Data list separator character		
 39052                                  
 39053                                  		times 8 db 0
 39054                                  ;
 39055                                  ; Max size of the block returned by the INTERNATIONAL call
 39056                                  ;
 39057                                  INTERNAT_BLOCK_SIZE EQU	32
 39058                                  
 39059                                  BATLEN equ 32
 39060                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 39061                                  
 39062                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 39063                                  
 39064                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 39065                                  
 39066                                  BATBUFEND:	dw 0
 39067                                  
 39068                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 39069                                  
 39070                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 39071                                  
 39072                                  ; 18/04/2023
 39073                                  ; ----------------------------------------------------------------------------
 39074                                  ; 09/01/2023
 39075                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 39076                                  
 39077                                  %endif
 39078                                  
 39079                                  ;============================================================================
 39080                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39081                                  ;============================================================================
 39082                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39083                                  
 39084                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39085                                  
 39086                                  ;The TRANSPACE segment contains variable data that is considered
 39087                                  ;volatile between command cycles, and therefore is not included in the
 39088                                  ;transient checksum area. Contents of these variables MUST be
 39089                                  ;initialized before use, and must not be relied upon from command
 39090                                  ;cycle to command cycle.
 39091                                  ;
 39092                                  ;No constant data values should be stored here.
 39093                                  
 39094                                  ; ---------------------------------------------------------------------------
 39095                                  ; START OF UNITIALIZED DATA
 39096                                  ; ---------------------------------------------------------------------------
 39097                                  
 39098                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 39099                                  
 39100 000087EE 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39101 00008845 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39102 0000889C 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39103 0000891F 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39104 000089A2 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39105 000089E8 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39106 00008A6B 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39107                                  
 39108                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39109                                  HEADCALL:
 39110 00008ABE 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 39111 00008AC0 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 39112 00008AC2 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 39113                                  SWITCHAR:
 39114 00008AC4 00                      	db 0			; RSWITCHAR (db '-')
 39115                                  DIRCHAR:
 39116 00008AC5 00                      	db 0			; RDIRCHAR  (db '/')
 39117                                  EXEC_ADDR:
 39118 00008AC6 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 39119                                  				; MYSEG1    (dw 0)	
 39120                                  RCH_ADDR:
 39121 00008ACA 00000000                	dd 0			;	    (dw TREMCHECK) 	
 39122                                  				; MYSEG2    (dw 0)	
 39123 00008ACE 0000                    	dw 0			; RESTEST   (dw 0)	
 39124                                  TRAN_TPA:
 39125 00008AD0 0000                    	dw 0			; RES_TPA   (dw 0)	
 39126                                  
 39127 00008AD2 00                      CHKDRV:	db 0
 39128                                  IFNOTFLAG:
 39129                                  FILTYP:
 39130 00008AD3 00                      RDEOF:	db 0			; Misc flags
 39131 00008AD4 00                      CURDRV:	db 0
 39132                                  PARM1:
 39133 00008AD5 00                      Concat:	db 0
 39134                                  PARM2:
 39135 00008AD6 00                      ArgC:	db 0
 39136 00008AD7 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39137 00008AD9 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39138                                  ARG2S:				; Switches after 2nd arg		
 39139                                  DestSwitch:
 39140 00008ADB 0000                    	dw 0
 39141                                  ARGTS:
 39142                                  AllSwitch:
 39143 00008ADD 0000                    	dw 0			; ALL switches except for COMSW
 39144 00008ADF 00                      CFLAG:	db 0
 39145                                  DestClosed:
 39146                                  SPECDRV:
 39147 00008AE0 00                      	db 0
 39148 00008AE1 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39149 00008AE3 0000                    NXTADD:	dw 0
 39150                                  FRSTSRCH:
 39151 00008AE5 00                      	db 0
 39152                                  ; 15/04/2023
 39153                                  LeftOnLine:
 39154 00008AE6 00                      	db 0			; entries left on line u.b. DIR
 39155                                  PerLine:
 39156 00008AE7 00                      	db 0			; entries/line u.b. DIR
 39157 00008AE8 00                      LINCNT:	db 0
 39158 00008AE9 00                      LINLEN:	db 0
 39159                                  LeftOnPage:
 39160 00008AEA 0000                    	dw 0			; lines left on page u.b. DIR
 39161                                  FileCnt:
 39162 00008AEC 0000                    	dw 0			; file count u.b. DIR
 39163                                  FileSiz:
 39164 00008AEE 00000000                	dd 0			; file size u.b. DIR
 39165                                  
 39166                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39167                                  
 39168                                  FileCntTotal:
 39169 00008AF2 00000000                	dd 0			; total file count u.b. DIR
 39170                                  FileSizTotal:
 39171 00008AF6 00000000                	dd 0			; total file size u.b. DIR
 39172                                  
 39173                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39174                                  CHARBUF:
 39175 00008AFA 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39176                                  DESTFCB2:
 39177 00008B4A 00                      IDLEN:	db 0
 39178 00008B4B 00<rep 8h>              ID:	times	8  db 0
 39179 00008B53 00<rep 3h>              COM:	times	3  db 0 
 39180 00008B56 00<rep 25h>             DEST:	times	37 db 0
 39181                                  DESTNAME:
 39182 00008B7B 00<rep Bh>              	times	11 db 0
 39183                                  DESTDIR:
 39184                                  DestFcb:
 39185 00008B86 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39186                                  GOTOLEN: ; word
 39187                                  BWDBUF:  ; byte
 39188                                  EXEFCB:  ; word
 39189 00008BC9 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39190                                  
 39191                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39192                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39193                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39194                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39195                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39196                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39197                                  
 39198                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39199                                  SDIRBUF:
 39200 00008C0F 00<rep Ch>              	times 12 db 0	
 39201                                  _Bits:
 39202 00008C1B 0000                    	dw 0
 39203                                  PathCnt:
 39204 00008C1D 0000                    	dw 0
 39205                                  PathPos:
 39206 00008C1F 0000                    	dw 0
 39207 00008C21 0000                    PathSw:	dw 0
 39208                                  AttrSpecified:
 39209 00008C23 00                      	db 0			; attribute bits u.b. DIR
 39210                                  AttrSelect:
 39211 00008C24 00                      	db 0			; attribute bits u.b. DIR
 39212 00008C25 00                      comma:	db 0			; flag set if +,, occurs
 39213                                  plus_comma:
 39214 00008C26 00                      	db 0			; flag set if +,, occurs
 39215                                  DirFlag:
 39216 00008C27 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39217                                  parse_last:
 39218 00008C28 0000                    	dw 0			;AN018; used to hold parsing position
 39219                                  system_cpage:
 39220 00008C2A 0000                    	dw 0			;AC001; used for CHCP variable
 39221                                  Arg_Buf:
 39222 00008C2C 00<rep 80h>             	times 128 db 0	
 39223                                  File_Size_Low:
 39224 00008CAC 0000                    	dw 0	
 39225                                  File_Size_High:
 39226 00008CAE 0000                    	dw 0		
 39227                                  string_ptr_2:
 39228 00008CB0 0000                    	dw 0	
 39229                                  Copy_num:
 39230 00008CB2 0000                    	dw 0
 39231                                  cpyflag:
 39232 00008CB4 00                      	db 0
 39233                                  Dir_Num:
 39234 00008CB5 0000                    	dw 0
 39235                                  Bytes_Free:
 39236 00008CB7 00000000                	dd 0
 39237                                  
 39238                                  Major_Ver_Num:
 39239 00008CBB 0000                    	dw 0
 39240                                  Minor_Ver_Num:
 39241 00008CBD 0000                    	dw 0
 39242                                  
 39243                                  One_Char_Val:
 39244 00008CBF 00                      	db 0
 39245 00008CC0 00                      	db 0
 39246                                  vol_drv:
 39247 00008CC1 00                      	db 0
 39248                                  ROM_CALL:
 39249 00008CC2 00                      	db 0			; flag for rom function
 39250 00008CC3 0000                    ROM_IP:	dw 0
 39251 00008CC5 0000                    ROM_CS:	dw 0
 39252                                  
 39253                                  DestVars:
 39254                                  DestIsDir:
 39255 00008CC7 00                      	db 0
 39256                                  DestSiz:
 39257 00008CC8 00                      	db 0
 39258                                  DestTail:
 39259 00008CC9 0000                    	dw 0
 39260                                  DestInfo:
 39261 00008CCB 00                      	db 0
 39262                                  DestBuf:
 39263 00008CCC 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39264                                  EndDestBuf:
 39265                                  DESTHAND:
 39266 00008D23 0000                    	dw 0
 39267                                  DESTISDEV:
 39268 00008D25 00                      	db 0
 39269                                  FIRSTDEST:
 39270 00008D26 00                      	db 0
 39271                                  MELCOPY:
 39272 00008D27 00                      	db 0
 39273                                  MELSTART:
 39274 00008D28 0000                    	dw 0
 39275                                  SrcVars:
 39276                                  SrcIsDir:
 39277 00008D2A 00                      	db 0
 39278 00008D2B 00                      SrcSiz:	db 0
 39279                                  SrcTail:
 39280 00008D2C 0000                    	dw 0
 39281                                  SrcInfo:
 39282 00008D2E 00                      	db 0
 39283                                  SrcBuf:
 39284 00008D2F 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39285                                  SRCHAND:
 39286 00008D86 0000                    	dw 0
 39287                                  SRCISDEV:
 39288 00008D88 00                      	db 0
 39289                                  ScanBuf:
 39290 00008D89 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39291                                  
 39292 00008DE0 0000                    SRCPT:	dw 0
 39293                                  INEXACT:
 39294 00008DE2 00                      	db 0
 39295                                  NOWRITE:
 39296 00008DE3 00                      	db 0
 39297                                  BINARY:
 39298 00008DE4 00                      	db 0
 39299                                  WRITTEN:
 39300 00008DE5 0000                    	dw 0
 39301                                  TERMREAD:
 39302 00008DE7 00                      	db 0
 39303 00008DE8 00                      ASCII:	db 0
 39304 00008DE9 00                      PLUS:	db 0
 39305 00008DEA 00                      objcnt:	db 0			; Used in copy
 39306 00008DEB 0000                    CPDATE:	dw 0
 39307 00008DED 0000                    CPTIME:	dw 0
 39308                                  
 39309                                  OFilePtr_Lo:
 39310 00008DEF 0000                    	dw 0			; original file ptr for COPY when
 39311                                  OFilePtr_Hi:
 39312 00008DF1 0000                    	dw 0			; 1st source is also destination
 39313 00008DF3 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39314                                  BATHAND:
 39315 00008DF4 0000                    	dw 0			; Batch handle
 39316                                  STARTEL:
 39317 00008DF6 0000                    	dw 0
 39318 00008DF8 00                      ELCNT:	db 0
 39319 00008DF9 00                      ELPOS:	db 0
 39320                                  
 39321                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39322                                  ; MSDOS 5.0
 39323                                  SKPDEL:
 39324 00008DFA 00<rep Bh>              SOURCE:	times 11 db 0
 39325                                  
 39326                                  ext_entered:
 39327 00008E05 00                      	db 0			;AN005;
 39328                                  
 39329                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39330                                  
 39331                                  Display_Ioctl:
 39332 00008E06 00                      	db 0			;AN000; info level
 39333 00008E07 00                      	db 0			;AN000; reserved
 39334 00008E08 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39335 00008E0A 0000                    	dw 0			;AN000; control flags
 39336                                  display_mode:
 39337 00008E0C 00                      	db 0			;AN000; display mode, colors
 39338 00008E0D 00                      	db 0			;AN000; reserved
 39339 00008E0E 0000                    	dw 0			;AN023; colors
 39340 00008E10 0000                    	dw 0			;AN000; display width (PELS)
 39341 00008E12 0000                    	dw 0			;AN000; display length (PELS)
 39342                                  display_width:
 39343 00008E14 0000                    	dw 0			;AN000; display width
 39344                                  LinPerPag:
 39345 00008E16 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39346                                  
 39347                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39348 00008E18 0000                    	dw 0			;AN000; info level
 39349                                  vol_serial:
 39350 00008E1A 00000000                	dd 0			;AN000; volume serial number
 39351                                  vol_label:
 39352 00008E1E 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39353 00008E29 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39354                                  
 39355                                  expand_star:
 39356 00008E31 00                      	db 0
 39357                                  
 39358                                  msg_flag:
 39359 00008E32 00                      	db 0			;AN022; flag set if non-utility message issued
 39360                                  Msg_Numb:
 39361 00008E33 0000                    	dw 0			;AN022; set with extended error message issued
 39362                                  append_exec:
 39363 00008E35 00                      	db 0			;AN041; set if internal append executed
 39364                                  print_err_flag:
 39365 00008E36 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39366                                  subst_buffer:
 39367 00008E38 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39368                                  				;AN061;
 39369                                  ; 15/04/2023
 39370 00008E4E 00                      KPARSE:	db 0	; 3/3/KK	
 39371                                  
 39372                                  ; Data declarations taken out of parse.asm
 39373                                  
 39374                                  ; MSDOS 6.0
 39375                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39376                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39377                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39378                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39379                                  ;comptr		dw	?		; ptr into combuf
 39380                                  
 39381                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39382                                  ARG:
 39383                                  ARG_ARGV:
 39384                                  ARGV0_ARGPOINTER:
 39385 00008E4F 0000                    	dw 0	; ARGV[0]
 39386                                  ARGV0_ARG_FLAGS:
 39387 00008E51 00                      	db 0
 39388                                  ARGV0_ARGSTARTEL:
 39389 00008E52 0000                    	dw 0
 39390                                  ARGV0_ARGLEN:
 39391 00008E54 0000                    	dw 0
 39392                                  ARGV0_ARGSW_WORD:
 39393 00008E56 0000                    	dw 0
 39394                                  ARGV0_OCOMPTR:
 39395 00008E58 0000                    	dw 0
 39396                                  ARGV1_ARGPOINTER:
 39397 00008E5A 0000                    	dw 0	; ARGV[1]	
 39398 00008E5C 00<rep 5h>              	times 5 db 0
 39399                                  ARGV1_ARGSW_WORD:
 39400 00008E61 0000                    	dw 0
 39401 00008E63 0000                    	dw 0
 39402                                  ARGV2_ARGPOINTER:
 39403 00008E65 0000                    	dw 0	; ARGV[2]
 39404 00008E67 00<rep 5h>              	times 5 db 0
 39405                                  ARGV2_ARGSW_WORD:
 39406 00008E6C 0000                    	dw 0
 39407 00008E6E 0000                    	dw 0
 39408 00008E70 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39409                                  ARG_ARGVCNT:
 39410 0000910F 0000                    	dw 0
 39411                                  ARG_ARGSWINFO:
 39412 00009111 0000                    	dw 0
 39413                                  ARG_ARGBUF:
 39414 00009113 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39415                                  ARG_ARGFORCOMBUF:
 39416 00009313 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39417                                  
 39418                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39419                                  ARGBUF_PTR:
 39420 00009393 0000                    	dw 0			; index for argv[].argpointer
 39421 00009395 00<rep 80h>             TPBUF:	times 128 db 0		; temporary buffer
 39422                                  LASTARG:
 39423 00009415 0000                    	dw 0			; point at which to accumulate switch info
 39424 00009417 0000                    COMPTR:	dw 0			; ptr into combuf
 39425                                  
 39426                                  ; Data declarations taken out of path.asm
 39427                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39428                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39429                                  ;psep_char	DB	?		; '/' or '\'
 39430                                  ;search_best	DB	(?)		; best code, best filename so far
 39431                                  ;fname_max_len	equ	13
 39432                                  ;search_best_buf DB	fname_max_len DUP (?)
 39433                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39434                                  ;search_error	DW	(?)		; address of error message to be printed
 39435                                  
 39436                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39437                                  
 39438                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39439                                  
 39440 00009419 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39441                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39442                                  pathinfo:
 39443                                  ;pathinfo_0:
 39444 00009444 0000                    	dw 0
 39445                                  ;pathinfo_2:
 39446 00009446 0000                    	dw 0
 39447                                  ;pathinfo_4:
 39448 00009448 0000                    	dw 0
 39449                                  psep_char:
 39450 0000944A 00                      	db 0
 39451                                  search_best:
 39452 0000944B 00                      	db 0
 39453                                  FNAME_MAX_LEN equ 13
 39454                                  search_best_buf:
 39455 0000944C 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39456                                  search_curdir_buf:
 39457 00009459 00<rep 40h>             	times 64 db 0
 39458                                  search_error:
 39459 00009499 0000                    	dw 0
 39460                                  
 39461                                  ; Data declarations taken out of tbatch.asm
 39462                                  
 39463                                  ;if_not_count	DW	?
 39464                                  ;
 39465                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39466                                  ;
 39467                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39468                                  
 39469                                  ; 31/03/2023
 39470                                  ;STACK:	;LABEL	WORD
 39471                                  
 39472                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 39473                                  
 39474                                  IF_NOT_COUNT:
 39475 0000949B 0000                    	dw 0
 39476 0000949D 00                      zflag:	db 0
 39477 0000949E 00<rep 100h>            	times 256 db 0 
 39478                                  	; 16/04/2023
 39479                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 39480                                  STACK:
 39481                                  
 39482                                  ;INTERNATVARS	internat_block <>
 39483                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39484                                  
 39485                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 39486                                  INTERNATVARS:
 39487                                  		; (24+8 = 32 bytes)
 39488                                  DATE_TIME_FORMAT:
 39489 0000959E 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 39490                                  CURRENCY_SYM:
 39491 000095A0 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39492                                  THOUS_SEP:
 39493 000095A5 0000                    	db 0,0			; Thousands separator 2 bytes
 39494                                  DECIMAL_SEP:
 39495 000095A7 0000                    	db 0,0			; Decimal separator 2 bytes
 39496                                  DATE_SEP:
 39497 000095A9 0000                    	db 0,0			; Date separator 2 bytes
 39498                                  TIME_SEP:
 39499 000095AB 0000                    	db 0,0			; Time separator 2 bytes	
 39500                                  BIT_FIELD:
 39501 000095AD 00                      	db 0			; Bit values
 39502                                  				;   Bit 0 = 0 if currency symbol first
 39503                                  				;	  = 1 if currency symbol last
 39504                                  				;   Bit 1 = 0 if No space after currency symbol
 39505                                  				;	  = 1 if space after currency symbol
 39506                                  CURRENCY_CENTS:
 39507 000095AE 00                      	db 0			; Number of places after currency dec point
 39508                                  TIME_24:
 39509 000095AF 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39510                                  MAP_CALL:
 39511 000095B0 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39512                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39513                                  				;  in pieces.
 39514                                  DATA_SEP:
 39515 000095B4 0000                    	db 0,0			; Data list separator character		
 39516                                  
 39517 000095B6 00<rep 8h>              	times 8 db 0
 39518                                  
 39519                                  ; Max size of the block returned by the INTERNATIONAL call
 39520                                  
 39521                                  INTERNAT_BLOCK_SIZE EQU	32
 39522                                  
 39523                                  ;;	Buffer for DOS function 64h (Get extended country information)
 39524                                  ;;	subfunctions 2, 4, 6, or 7:
 39525                                  ;
 39526                                  ;CountryPtrInfo	label	byte
 39527                                  ;CountryPtrId	db	?
 39528                                  ;CountryPtr	dd	?
 39529                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39530                                  	
 39531                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 39532                                  CountryPtrInfo:
 39533                                  CountryPtrId:	
 39534 000095BE 00                      	db 0
 39535                                  CountryPtr:
 39536 000095BF 00000000                	dd 0
 39537                                  
 39538                                  OldCtrlCHandler:
 39539 000095C3 00000000                	dd 0			; previous int 23 vector		
 39540                                  
 39541                                  BATLEN equ 32
 39542                                  
 39543                                  BATBUFPOS:
 39544 000095C7 0000                    	dw 0			; integer position in buffer of next byte
 39545                                  
 39546 000095C9 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 39547                                  BATBUFEND:
 39548 000095E9 0000                    	dw 0
 39549                                  TypeFilSiz:
 39550 000095EB 00000000                	dd 0			; stores size of file to be typed
 39551                                  
 39552                                  ; *****************************************************
 39553                                  ; EMG 4.00
 39554                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 39555                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 39556                                  ; *****************************************************
 39557                                  ;
 39558                                  ; COMMON PARSE OUTPUT BLOCKS
 39559                                  
 39560                                  ; Common output blocks for PARSE number, complex, or string values.
 39561                                  
 39562                                  PARSE1_OUTPUT:
 39563                                  PARSE1_TYPE:
 39564 000095EF 00                      	db 0			;AN000;  type
 39565                                  PARSE1_CODE:
 39566 000095F0 00                      	db 0			;AN000;  return value
 39567                                  PARSE1_SYN:
 39568 000095F1 0000                    	dw 0			;AN000;  es offset of synonym
 39569                                  PARSE1_ADDR:
 39570 000095F3 00000000                	dd 0			;AN000;  numeric value / address
 39571                                  				;	 of string value
 39572                                  
 39573                                  ;  Common output block for PARSE date strings.
 39574                                  
 39575                                  DATE_OUTPUT:
 39576                                  DATE_TYPE:
 39577 000095F7 00                      	db 0			;AN000;  type
 39578 000095F8 00                      	db 0			;AN000;  return value
 39579 000095F9 0000                    	dw 0			;AN000;  es offset of synonym
 39580                                  DATE_YEAR:
 39581 000095FB 0000                    	dw 0			;AN000;  year
 39582                                  DATE_MONTH:
 39583 000095FD 00                      	db 0			;AN000;  month
 39584                                  DATE_DAY:
 39585 000095FE 00                      	db 0			;AN000;  day
 39586                                  
 39587                                  ;  Common output block for PARSE time strings.
 39588                                  
 39589                                  TIME_OUTPUT:
 39590                                  TIME_TYPE:
 39591 000095FF 00                      	db 0			;AN000;  type
 39592 00009600 00                      	db 0			;AN000;  return value
 39593 00009601 0000                    	dw 0			;AN000;  es offset of synonym
 39594                                  TIME_HOUR:
 39595 00009603 00                      	db 0			;AN000;  hour
 39596                                  TIME_MINUTES:
 39597 00009604 00                      	db 0			;AN000;  minutes
 39598                                  TIME_SECONDS:
 39599 00009605 00                      	db 0			;AN000;  seconds
 39600                                  TIME_FRACTION:
 39601 00009606 00                      	db 0			;AN000;  hundredths
 39602                                  
 39603                                  ;  Common output block for PARSE drive specifier (one based drive number).
 39604                                  
 39605                                  DRIVE_OUTPUT:
 39606                                  DRIVE_TYPE:
 39607 00009607 00                      	db 0			;AN000;  type
 39608                                  DRIVE_VALUE:
 39609 00009608 00                      	db 0			;AN000;  return value
 39610 00009609 0000                    	dw 0			;AN000;  es offset of synonym
 39611                                  DRIVE_NUMBER:
 39612 0000960B 00                      	db 0			;AN000;  drive number
 39613 0000960C 000000                  	db 0,0,0		;AN000;  reserved
 39614                                  
 39615                                  	; 18/04/2023
 39616                                  	; 16/04/2023
 39617                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 39618                                  
 39619                                  ; ----------------------------------------------------------------------------
 39620                                  ; 20/04/2023
 39621                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
