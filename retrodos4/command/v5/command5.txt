     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update:  14/08/2024 (v5.0 - 2024 optimization)
     5                                  ;		15/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.15 (2.11)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  ; ----------------------------------------------------------------------------
    44                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    45                                  
    46                                  ;============================================================================
    47                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    48                                  ;============================================================================
    49                                  ; 21/09/2018 - Retro DOS v3.0
    50                                  
    51                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    52                                  ;BREAK <system call definitions>
    53                                  
    54                                  ;
    55                                  ;	Microsoft Confidential
    56                                  ;	Copyright (C) Microsoft Corporation 1991
    57                                  ;	All Rights Reserved.
    58                                  ;
    59                                  
    60                                  ;SUBTTL	system call definitions
    61                                  ;PAGE
    62                                  
    63                                  Abort				EQU 0	;  0	  0
    64                                  STD_CON_INPUT			EQU 1	;  1	  1
    65                                  Std_Con_Output			EQU 2	;  2	  2
    66                                  Std_Aux_Input			EQU 3	;  3	  3
    67                                  Std_Aux_Output			EQU 4	;  4	  4
    68                                  Std_Printer_Output		EQU 5	;  5	  5
    69                                  Raw_Con_IO			EQU 6	;  6	  6
    70                                  RAW_CON_INPUT			EQU 7	;  7	  7
    71                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    72                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    73                                  Std_Con_String_Input		EQU 10	; 10	  A
    74                                  Std_Con_Input_Status		EQU 11	; 11	  B
    75                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    76                                  DISK_RESET			EQU 13	; 13	  D
    77                                  Set_Default_Drive		EQU 14	; 14	  E
    78                                  FCB_Open			EQU 15	; 15	  F
    79                                  FCB_Close			EQU 16	; 16	 10
    80                                  Dir_Search_First		EQU 17	; 17	 11
    81                                  Dir_Search_Next 		EQU 18	; 18	 12
    82                                  FCB_Delete			EQU 19	; 19	 13
    83                                  FCB_Seq_Read			EQU 20	; 20	 14
    84                                  FCB_Seq_Write			EQU 21	; 21	 15
    85                                  FCB_Create			EQU 22	; 22	 16
    86                                  FCB_Rename			EQU 23	; 23	 17
    87                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    88                                  Set_DMA 			EQU 26	; 26	 1A
    89                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    90                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    91                                  ;									   ;
    92                                  Get_Default_DPB 		EQU 31	; 31	 1F
    93                                  ;									   ;
    94                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    95                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    96                                  FCB_Random_Read 		EQU 33	; 33	 21
    97                                  FCB_Random_Write		EQU 34	; 34	 22
    98                                  Get_FCB_File_Length		EQU 35	; 35	 23
    99                                  Get_FCB_Position		EQU 36	; 36	 24
   100                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   101                                  Create_Process_Data_Block	EQU 38	; 38	 26
   102                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   103                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   104                                  Parse_File_Descriptor		EQU 41	; 41	 29
   105                                  Get_Date			EQU 42	; 42	 2A
   106                                  Set_Date			EQU 43	; 43	 2B
   107                                  Get_Time			EQU 44	; 44	 2C
   108                                  Set_Time			EQU 45	; 45	 2D
   109                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   110                                  ; Extended functionality group
   111                                  Get_DMA 			EQU 47	; 47	 2F
   112                                  GET_VERSION			EQU 48	; 48	 30
   113                                  Keep_Process			EQU 49	; 49	 31
   114                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   115                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   116                                  ;									   ;
   117                                  Get_DPB 			EQU 50	; 50	 32
   118                                  ;									   ;
   119                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   120                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   121                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   122                                  Get_InDOS_Flag			EQU 52	; 52	 34
   123                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   124                                  Get_Drive_Freespace		EQU 54	; 54	 36
   125                                  CHAR_OPER			EQU 55	; 55	 37
   126                                  International			EQU 56	; 56	 38
   127                                  ;   Directory Group
   128                                  MKDir				EQU 57	; 57	 39
   129                                  RMDir				EQU 58	; 58	 3A
   130                                  CHDir				EQU 59	; 59	 3B
   131                                  ;   File Group
   132                                  Creat				EQU 60	; 60	 3C
   133                                  OPEN				EQU 61	; 61	 3D
   134                                  CLOSE				EQU 62	; 62	 3E
   135                                  READ				EQU 63	; 63	 3F
   136                                  Write				EQU 64	; 64	 40
   137                                  Unlink				EQU 65	; 65	 41
   138                                  LSEEK				EQU 66	; 66	 42
   139                                  CHMod				EQU 67	; 67	 43
   140                                  IOCTL				EQU 68	; 68	 44
   141                                  XDUP				EQU 69	; 69	 45
   142                                  XDup2				EQU 70	; 70	 46
   143                                  Current_Dir			EQU 71	; 71	 47
   144                                  ;    Memory Group
   145                                  ALLOC				EQU 72	; 72	 48
   146                                  DEALLOC				EQU 73	; 73	 49
   147                                  SETBLOCK			EQU 74	; 74	 4A
   148                                  ;    Process Group
   149                                  Exec				EQU 75	; 75	 4B
   150                                  EXIT				EQU 76	; 76	 4C
   151                                  WAITPROCESS			EQU 77	; 77	 4D
   152                                  Find_First			EQU 78	; 78	 4E
   153                                  ;   Special Group
   154                                  Find_Next			EQU 79	; 79	 4F
   155                                  ; SPECIAL SYSTEM GROUP
   156                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   157                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   158                                  ;									   ;
   159                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   160                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   161                                  Get_In_Vars			EQU 82	; 82	 52
   162                                  SetDPB				EQU 83	; 83	 53
   163                                  ;									   ;
   164                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   165                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   166                                  Get_Verify_On_Write		EQU 84	; 84	 54
   167                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   168                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   169                                  ;									   ;
   170                                  Dup_PDB 			EQU 85	; 85	 55
   171                                  ;									   ;
   172                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   173                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   174                                  Rename				EQU 86	; 86	 56
   175                                  File_Times			EQU 87	; 87	 57
   176                                  AllocOper			EQU 88	; 88	 58
   177                                  ; Network extention system calls
   178                                  GetExtendedError		EQU 89	; 89	 59
   179                                  CreateTempFile			EQU 90	; 90	 5A
   180                                  CreateNewFile			EQU 91	; 91	 5B
   181                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   182                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   183                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   184                                  ;									   ;
   185                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   186                                  					;	    CloseByName, CloseUser,
   187                                  					;	    CloseUserProcess,
   188                                  					;	    GetOpenFileList
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  UserOper			EQU 94	; 94	 5E Get and Set
   193                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   194                                  xNameTrans			EQU 96	; 96	 60
   195                                  PathParse			EQU 97	; 97	 61
   196                                  GetCurrentPSP			EQU 98	; 98	 62
   197                                  Hongeul 			EQU 99	; 99	 63
   198                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   199                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   200                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   201                                  ;									   ;
   202                                  Set_Printer_Flag		EQU 100 ; 100	 64
   203                                  ;									   ;
   204                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   205                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   206                                  GetExtCntry			EQU 101 ; 101	 65
   207                                  GetSetCdPg			EQU 102 ; 102	 66
   208                                  ExtHandle			EQU 103 ; 103	 67
   209                                  Commit				EQU 104 ; 104	 68
   210                                  GetSetMediaID			EQU 105 ; 105	 69
   211                                  IFS_IOCTL			EQU 107 ; 107	 6B
   212                                  ExtOpen 			EQU 108 ; 108	 6C
   213                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   214                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   215                                  ;                                                                          ;
   216                                  ;ifdef ROMEXEC
   217                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   218                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   219                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   220                                  ;endif
   221                                  ;                                                                          ;
   222                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  ;
   225                                  ;
   226                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   227                                  OEM_C1				EQU 249 ; 249	 F9
   228                                  OEM_C2				EQU 250 ; 250	 FA
   229                                  OEM_C3				EQU 251 ; 251	 FB
   230                                  OEM_C4				EQU 252 ; 252	 FC
   231                                  OEM_C5				EQU 253 ; 253	 FD
   232                                  OEM_C6				EQU 254 ; 254	 FE
   233                                  OEM_C7				EQU 255 ; 255	 FF
   234                                  
   235                                  ;============================================================================
   236                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   237                                  ;============================================================================
   238                                  ; 21/09/2018 - Retro DOS v3.0
   239                                  
   240                                  ;BREAK <Control character definitions>
   241                                  
   242                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   243                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   244                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   245                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   246                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   247                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   248                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   249                                  c_HT	    EQU     09h 	; ^I ASCII tab
   250                                  
   251                                  ;============================================================================
   252                                  ; DIRENT.INC, MSDOS 6.0, 1991
   253                                  ;============================================================================
   254                                  ; 21/09/2018 - Retro DOS v3.0
   255                                  
   256                                  ;Break <Directory entry>
   257                                  
   258                                  ;	NOTE:  These offsets are also used in the DTA for
   259                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   260                                  ;	with the FCB filename field, and the rest of the
   261                                  ;	DIR_ENTRY fields follow. -DavidOls
   262                                  
   263                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   264                                  ;
   265                                  ;	+---------------------------+
   266                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   267                                  ;	+---------------------------+
   268                                  ;	|     (BYTE) attributes     |	    11	    B
   269                                  ;	+---------------------------+
   270                                  ;	|    (10 BYTE) reserved     |	    12	    C
   271                                  ;	+---------------------------+
   272                                  ;	| (WORD) time of last write |	    22	    16
   273                                  ;	+---------------------------+
   274                                  ;	| (WORD) date of last write |	    24	    18
   275                                  ;	+---------------------------+
   276                                  ;	|   (WORD) First cluster    |	    26	    1A
   277                                  ;	+---------------------------+
   278                                  ;	|     (DWORD) file size     |	    28	    1C
   279                                  ;	+---------------------------+
   280                                  ;
   281                                  ;   First byte of filename  = E5 -> free directory entry
   282                                  ;			    = 00 -> end of allocated directory
   283                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   284                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   285                                  ;
   286                                  
   287                                  STRUC DIR_ENTRY
   288 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   289 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   290 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   291 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   292 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   293 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   294 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   295 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   296 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   297 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   298 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   299                                  .size:
   300                                  
   301                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   302                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   303                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   304                                  ;	    this field is zero for subdirectory files.
   305                                  
   306                                  ENDSTRUC
   307                                  
   308                                  ATTR_READ_ONLY	equ	 1h
   309                                  ATTR_HIDDEN	equ	 2h
   310                                  ATTR_SYSTEM	equ	 4h
   311                                  ATTR_VOLUME_ID	equ	 8h
   312                                  ATTR_DIRECTORY	equ	10h
   313                                  ATTR_ARCHIVE	equ	20h
   314                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   315                                  				;   NO directory entry on a disk EVER
   316                                  				;   has this bit set. It is set non-zero
   317                                  				;   when a device is found by GETPATH
   318                                  
   319                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   320                                  				; OR of hard attributes for FINDENTRY
   321                                  
   322                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   323                                  				; ignore this(ese) attribute(s) during
   324                                  				; search first/next
   325                                  
   326                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   327                                  				; changeable via CHMOD
   328                                  
   329                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   330                                  
   331                                  ;============================================================================
   332                                  ; ERROR.INC, MSDOS 6.0, 1991
   333                                  ;============================================================================
   334                                  ; 21/09/2018 - Retro DOS v3.0
   335                                  
   336                                  ;**	ERROR.INC - DOS Error Codes
   337                                  ;
   338                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   339                                  ;    return error codes through AX.	If an error occurred then
   340                                  ;    the carry bit will be set and the error code is in AX.	If no error
   341                                  ;    occurred then the carry bit is reset and AX contains returned info.
   342                                  ;
   343                                  ;    Since the set of error codes is being extended as we extend the operating
   344                                  ;    system, we have provided a means for applications to ask the system for a
   345                                  ;    recommended course of action when they receive an error.
   346                                  ;
   347                                  ;    The GetExtendedError system call returns a universal error, an error
   348                                  ;    location and a recommended course of action.	The universal error code is
   349                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   350                                  ;    is issued.
   351                                  
   352                                  
   353                                  ;	2.0 error codes
   354                                  
   355                                  error_invalid_function		EQU	1
   356                                  ERROR_FILE_NOT_FOUND		EQU	2
   357                                  ERROR_PATH_NOT_FOUND		EQU	3
   358                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   359                                  ERROR_ACCESS_DENIED		EQU	5
   360                                  error_invalid_handle		EQU	6
   361                                  error_arena_trashed		EQU	7
   362                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   363                                  error_invalid_block		EQU	9
   364                                  error_bad_environment		EQU	10
   365                                  ERROR_BAD_FORMAT		EQU	11
   366                                  error_invalid_access		EQU	12
   367                                  ERROR_INVALID_DATA		EQU	13
   368                                  ;**** reserved			EQU	14	; *****
   369                                  error_invalid_drive		EQU	15
   370                                  error_current_directory 	EQU	16
   371                                  error_not_same_device		EQU	17
   372                                  ERROR_NO_MORE_FILES		EQU	18
   373                                  
   374                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   375                                  
   376                                  ERROR_WRITE_PROTECT		EQU	19
   377                                  error_bad_unit			EQU	20
   378                                  error_not_ready 		EQU	21
   379                                  error_bad_command		EQU	22
   380                                  error_CRC			EQU	23
   381                                  error_bad_length		EQU	24
   382                                  error_Seek			EQU	25
   383                                  error_not_DOS_disk		EQU	26
   384                                  error_sector_not_found		EQU	27
   385                                  error_out_of_paper		EQU	28
   386                                  error_write_fault		EQU	29
   387                                  error_read_fault		EQU	30
   388                                  ERROR_GEN_FAILURE		EQU	31
   389                                  
   390                                  ;	the new 3.0 error codes reported through INT 24
   391                                  
   392                                  error_sharing_violation 	EQU	32
   393                                  error_lock_violation		EQU	33
   394                                  error_wrong_disk		EQU	34
   395                                  ERROR_FCB_UNAVAILABLE		EQU	35
   396                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   397                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   398                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   399                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   400                                  
   401                                  ;	New OEM network-related errors are 50-79
   402                                  
   403                                  error_not_supported		EQU	50
   404                                  
   405                                  error_net_access_denied		EQU	65	;M028
   406                                  
   407                                  ;	End of INT 24 reportable errors
   408                                  
   409                                  error_file_exists		EQU	80
   410                                  error_DUP_FCB			EQU	81	; *****
   411                                  error_cannot_make		EQU	82
   412                                  error_FAIL_I24			EQU	83
   413                                  
   414                                  ;	New 3.0 network related error codes
   415                                  
   416                                  error_out_of_structures 	EQU	84
   417                                  error_Already_assigned		EQU	85
   418                                  error_invalid_password		EQU	86
   419                                  error_invalid_parameter 	EQU	87
   420                                  error_NET_write_fault		EQU	88
   421                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   422                                  
   423                                  ;============================================================================
   424                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   425                                  ;============================================================================
   426                                  ; 22/09/2018 - Retro DOS v3.0
   427                                  
   428                                  ;**	DevSym.inc - Device Symbols
   429                                  
   430                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   431                                  
   432                                  STRUC SYSDEV
   433 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   434 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   435 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   436 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   437 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   438                                  .size:
   439                                  ENDSTRUC
   440                                  
   441                                  ; 24/09/2018
   442                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   443                                  
   444                                  ;============================================================================
   445                                  ; CURDIR.INC, MSDOS 6.0, 1991
   446                                  ;============================================================================
   447                                  ; 21/09/2018 - Retro DOS v3.0
   448                                  
   449                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   450                                  
   451                                  ;============================================================================
   452                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   453                                  ;============================================================================
   454                                  ; 21/09/2018 - Retro DOS v3.0
   455                                  
   456                                  ;/*
   457                                  ; *                      Microsoft Confidential
   458                                  ; *                      Copyright (C) Microsoft Corporation 1991
   459                                  ; *                      All Rights Reserved.
   460                                  ; */
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   463                                  ;*************************************
   464                                  ; COMMAND EQUs which are not switch dependant
   465                                  
   466                                  ;		include	curdir.inc	; to get DIRSTRLEN
   467                                  ;		Note dossym.inc must already have been included!
   468                                  
   469                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   470                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   471                                  
   472                                  SYM		EQU	">"
   473                                  
   474                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   475                                  
   476                                  NORMPERLIN	EQU	1
   477                                  WIDEPERLIN	EQU	5
   478                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   479                                  BatLen		EQU	32		; buffer for batch files
   480                                  YES_ECHO	EQU	1		; echo line
   481                                  NO_ECHO 	EQU	0		; don't echo line
   482                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   483                                  call_in_progress EQU	1		; indicate we're in the CALL command
   484                                  length_call	EQU	4		; length of CALL
   485                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   486                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   487                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   488                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   489                                  nullcommand	EQU     1		; no command on command line
   490                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   491                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   492                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   493                                  result_number	EQU	1		;AN000; number returned from parser
   494                                  result_string	EQU	3		;AN000; string returned from parser
   495                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   496                                  result_drive	EQU	6		;AN000; drive returned from parser
   497                                  result_date	EQU	7		;AN000; date returned from parser
   498                                  result_time	EQU	8		;AN000; time returned from parser
   499                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   500                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   501                                  util_msg_class	EQU	-1		;AN000; message class for utility
   502                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   503                                  parse_msg_class EQU	2		;AN000; message class for parse error
   504                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   505                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   506                                  colon_char	EQU	":"             ;AN000; colon character
   507                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   508                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   509                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   510                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   511                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   512                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   513                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   514                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   515                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   516                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   517                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   518                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   519                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   520                                  parm_block_size equ	11		;AN000; size of message subst block
   521                                  blank		equ	" "             ;AN000; blank character
   522                                  no_subst	equ	0		;AN000; no substitutions for messages
   523                                  one_subst	equ	1		;AN000; one substitution for messages
   524                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   525                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   526                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   527                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   528                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   529                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   530                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   531                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   532                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   533                                  capital_A	equ	'A'             ;AC000;
   534                                  vbar		equ	'|'             ;AC000;
   535                                  labracket	equ	'<'             ;AC000;
   536                                  rabracket	equ	'>'             ;AC000;
   537                                  dollar		equ	'$'             ;AC000;
   538                                  lparen		equ	'('             ;AC000;
   539                                  rparen		equ	')'             ;AC000;
   540                                  nullrparen	equ	29h		;AC000;
   541                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   542                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   543                                  star		equ	'*'             ;AC000;
   544                                  plus_chr	equ	'+'             ;AC000;
   545                                  small_a 	equ	'a'             ;AC000;
   546                                  small_z 	equ	'z'             ;AC000;
   547                                  dot_chr 	equ	'.'             ;AC000;
   548                                  tab_chr 	equ	9		;AN032;
   549                                  equal_chr	equ	'='             ;AN032;
   550                                  semicolon	equ	';'             ;AN049;
   551                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   552                                  dot_colon	equ	2e3ah		;AC000; '.:'
   553                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   554                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   555                                  AppendInstall	equ	0B700H		;AN020; append install check
   556                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   557                                  AppendGetState	equ	0B706H		;AN020; append get current state
   558                                  AppendSetState	equ	0B707H		;AN020; append set current state
   559                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   560                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   561                                  
   562                                  ;*************************************
   563                                  ;* PARSE ERROR MESSAGES
   564                                  ;*************************************
   565                                  
   566                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   567                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   568                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   569                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   570                                  
   571                                  ;*************************************
   572                                  ;* EQUATES FOR MESSAGE RETRIEVER
   573                                  ;*************************************
   574                                  
   575                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   576                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   577                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   578                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   579                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   580                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   581                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   582                                  
   583                                  ;*********************************
   584                                  ;* EQUATES FOR INT 10H
   585                                  ;*********************************
   586                                  
   587                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   588                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   589                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   590                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   591                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   592                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   593                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   594                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   595                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   596                                  
   597                                  AltPipeChr	equ	"|"             ; alternate pipe character
   598                                  
   599                                  FCB		equ	5Ch
   600                                  
   601                                  STRUC VARSTRUC
   602 00000000 ??                      .ISDIR:		RESB	1
   603 00000001 ??                      .SIZ:		RESB	1
   604 00000002 ????                    .TTAIL:		RESW	1
   605 00000004 ??                      .INFO:		RESB	1
   606 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   607                                  .size:
   608                                  ENDSTRUC
   609                                  ;
   610                                  ; Flags for internal command parsing
   611                                  ;
   612                                  fCheckDrive	equ	00000001b	; validate drive letter
   613                                  fSwitchAllowed	equ	00000010b	; switches allowed
   614                                  fLimitHelp	equ	00000100b	; /? must appear alone
   615                                  
   616                                  ;
   617                                  ; Test switches
   618                                  ;
   619                                  fParse		EQU	0001h		; display results of parseline
   620                                  
   621                                  ;
   622                                  ; Batch segment structure
   623                                  ;
   624                                  ;   BYTE    type of segment
   625                                  ;   BYTE    echo state of parent on entry to batch file
   626                                  ;   WORD    segment of last batch file
   627                                  ;   WORD    segment for FOR command
   628                                  ;   BYTE    FOR flag state on entry to batch file
   629                                  ;   DWORD   offset for next line
   630                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   631                                  ;   ASCIZ   file name (with . and ..)
   632                                  ;   BYTES   CR-terminated parameters
   633                                  ;   BYTE    0 flag to indicate end of parameters
   634                                  ;
   635                                  
   636                                  BATCHTYPE   equ 0
   637                                  
   638                                  STRUC BATCHSEGMENT
   639 00000000 ??                      .BatType:	RESB	1		; signature
   640 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   641                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   642 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   643 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   644 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   645 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   646 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   647 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   648 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   649                                  .SIZE:
   650                                  ENDSTRUC
   651                                  
   652                                  ANULL		equ	0		; terminates an argv string
   653                                  ARGMAX		equ	64		; max args on a command line
   654                                  ;ARGBLEN 	equ	2*128		; 1char each plus term NUL
   655                                  ; 27/07/2024 - PCDOS 7.1 COMMAND.COM ;*
   656                                  ARGBLEN 	equ	2*64
   657                                  tplen		equ	64		; max size of one argument
   658                                  arg_cnt_error	equ	1		; number of args > MAXARG
   659                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   660                                  
   661                                  STRUC ARGV_ELE				; elements in the argv array
   662 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   663 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   664 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   665 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   666 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   667 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   668                                  .SIZE:	; 11 ; 27/07/2024
   669                                  ENDSTRUC
   670                                  
   671                                  STRUC ARG_UNIT
   672 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   673 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   674 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   675 000002C4 <res 100h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   676 000003C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   677                                  .SIZE:	; 1092 ; 27/07/2024 ; (it was 1348 in MSDOS 5.0-6.22 COMMAND.COM) ;*
   678                                  ENDSTRUC
   679                                  
   680                                  ; Equates for initialization
   681                                  ;
   682                                  INITINIT	equ	01h		; initialization in progress
   683                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   684                                  INITCTRLC	equ	04h		; already in ^C handler
   685                                  
   686                                  ;============================================================================
   687                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   688                                  ;============================================================================
   689                                  ; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   690                                  
   691                                  ; Current structure of the data returned by the international call
   692                                  
   693                                  struc INTERNAT_BLOCK
   694 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   695 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   696 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   697 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   698 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   699 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   700 0000000F ??                      .bit_field:	resb 1			; Bit values
   701                                  					;   Bit 0 = 0 if currency symbol first
   702                                  					;	  = 1 if currency symbol last
   703                                  					;   Bit 1 = 0 if No space after currency symbol
   704                                  					;	  = 1 if space after currency symbol
   705                                  .currency_cents:
   706 00000010 ??                      		resb 1			; Number of places after currency dec point
   707 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   708 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   709                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   710                                  					;  in pieces.
   711 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   712 00000017 ??                      		resb 1
   713                                  endstruc
   714                                  
   715                                  ; Max size of the block returned by the INTERNATIONAL call
   716                                  
   717                                  internat_block_max equ 32
   718                                  
   719                                  ;============================================================================
   720                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   721                                  ;============================================================================
   722                                  ; 13/10/2018 - Retro DOS v3.0
   723                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   724                                  
   725                                  ;Break	<find first/next buffer>
   726                                  
   727                                  	; MSDOS 3.3 & MSDOS 6.0
   728                                  
   729                                  struc FIND_BUF
   730 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   731 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   732 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   733 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   734 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   735 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   736 00000015 ??                      .ATTR:	    resb 1	; attribute found
   737 00000016 ????                    .TIMR:	    resw 1	; time
   738 00000018 ????                    .DATE:	    resw 1	; date
   739 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   740 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   741 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   742                                  .size:
   743                                  endstruc
   744                                  
   745                                  ;=============================================================================
   746                                  ; PDB.INC, MSDOS 6.0, 1991
   747                                  ;=============================================================================
   748                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   749                                  
   750                                  ;**	Process data block (otherwise known as program header)
   751                                  
   752                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   753                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   754                                  ;	for use.
   755                                  
   756                                  FILPERPROC	EQU     20
   757                                  
   758                                  struc PDB	; Process_data_block
   759 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   760 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   761 00000004 ??                                      resb 1
   762 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   763 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   764 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   765 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   766 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   767 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   768 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   769 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   770 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   771 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   772 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   773 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   774 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   775 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   776 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   777 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   778 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   779 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   780                                  				;  an extended FCB
   781                                  ;endstruc 	; MSDOS 3.3
   782                                  	  	; MSDOS 6.0
   783 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   784 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   785 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   786 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   787                                  endstruc
   788                                  
   789                                  ;=============================================================================
   790                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   791                                  ;=============================================================================
   792                                  ; 24/09/2018 - Retro DOS v3.0
   793                                  
   794                                  ;major_version	equ 6		; Major DOS version
   795                                  ;minor_version	equ 0		; Minor DOS Version
   796                                  
   797                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   798                                  
   799                                  ; MSDOS 3.3 COMMAND.COM
   800                                  ;MAJOR_VERSION	EQU 3
   801                                  ;MINOR_VERSION	EQU 30
   802                                  
   803                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   804                                  MAJOR_VERSION	EQU 5		; Major DOS version
   805                                  MINOR_VERSION	EQU 0		; Minor DOS version
   806                                  
   807                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   808                                  
   809                                  ;-----------------------------------------------------------------------------
   810                                  ; 21/09/2018
   811                                  ;-----------------------------------------------------------------------------
   812                                  ; Retro DOS v3.0 NOTE:  
   813                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   814                                  ;	with minor modifications which are done by me (Erdogan Tan).
   815                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   816                                  ;	source code files (written by using MASM syntax).
   817                                  ;-----------------------------------------------------------------------------
   818                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   819                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   820                                  ;----------------------------------------------------------------------------- 	
   821                                  
   822                                  ;=============================================================================
   823                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   824                                  ;=============================================================================
   825                                  ; 21/09/2018 - Retro DOS v3.0
   826                                  
   827                                  ;	page ,132
   828                                  ;	title	COMMAND - resident code for COMMAND.COM
   829                                  ;	name	COMMAND
   830                                  
   831                                  ;/*
   832                                  ; *                      Microsoft Confidential
   833                                  ; *                      Copyright (C) Microsoft Corporation 1991
   834                                  ; *                      All Rights Reserved.
   835                                  ; */
   836                                  
   837                                  ;*****************************************************************************
   838                                  ;
   839                                  ; MODULE:	       COMMAND.COM
   840                                  ;
   841                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   842                                  ;
   843                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   844                                  ;		       parts.  First is the resident portion, which includes
   845                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   846                                  ;		       error), and 2EH (command line execute); it also has
   847                                  ;		       code to test and, if necessary, reload the transient
   848                                  ;		       portion. Following the resident is the init code, which
   849                                  ;		       is overwritten after use.  Then comes the transient
   850                                  ;		       portion, which includes all command processing (whether
   851                                  ;		       internal or external).  The transient portion loads at
   852                                  ;		       the end of physical memory, and it may be overlayed by
   853                                  ;		       programs that need as much memory as possible. When the
   854                                  ;		       resident portion of command regains control from a user
   855                                  ;		       program, a check sum is performed on the transient
   856                                  ;		       portion to see if it must be reloaded.  Thus programs
   857                                  ;		       which do not need maximum memory will save the time
   858                                  ;		       required to reload COMMAND when they terminate.
   859                                  ;
   860                                  ; ENTRY POINT:	       PROGSTART
   861                                  ;
   862                                  ; INPUT:	       command line at offset 81H
   863                                  ;
   864                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   865                                  ;		       from a secondary command processor via the EXIT
   866                                  ;		       internal command.
   867                                  ;
   868                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   869                                  ;		       hang the system.
   870                                  ;
   871                                  ; INTERNAL REFERENCES:
   872                                  ;
   873                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   877                                  ;		       (COMMAND.DOC)
   878                                  ;
   879                                  ; EXTERNAL REFERENCES:
   880                                  ;
   881                                  ;      ROUTINES:       none
   882                                  ;
   883                                  ;      DATA AREAS:     none
   884                                  ;
   885                                  ;*****************************************************************************
   886                                  ;
   887                                  ;			      REVISION HISTORY
   888                                  ;			      ----------------
   889                                  ;
   890                                  ; DOS 1.00 to DOS 3.30
   891                                  ; --------------------------
   892                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   893                                  ;
   894                                  ; REV 1.17
   895                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   896                                  ;	       resident since the EXELOAD may have overwritten the transient.
   897                                  ;
   898                                  ; REV 1.18
   899                                  ;    05/21/82  IBM version always looks on drive A
   900                                  ;	       MSVER always looks on default drive
   901                                  ;
   902                                  ; REV 1.19
   903                                  ;    06/03/82  Drive spec now entered in command line
   904                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   905                                  ;	       (print volume label)
   906                                  ;
   907                                  ; REV 1.20
   908                                  ;    06/09/82  Prints "directory" after directories
   909                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   910                                  ;
   911                                  ; REV 1.50
   912                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   913                                  ;	       do it right.
   914                                  ;
   915                                  ; REV 1.70
   916                                  ;	       EXEC used to fork off new processes
   917                                  ;
   918                                  ; REV 1.80
   919                                  ;	       C switch for single command execution
   920                                  ;
   921                                  ; REV 1.90
   922                                  ;	       Batch uses XENIX
   923                                  ;
   924                                  ; Rev 2.00
   925                                  ;	       Lots of neato stuff
   926                                  ;	       IBM 2.00 level
   927                                  ;
   928                                  ; Rev 2.01
   929                                  ;	       'D' switch for date time suppression
   930                                  ;
   931                                  ; Rev 2.02
   932                                  ;	       Default userpath is NUL rather than BIN
   933                                  ;		       same as IBM
   934                                  ;	       COMMAND split into pieces
   935                                  ;
   936                                  ; Rev 2.10
   937                                  ;	       INTERNATIONAL SUPPORT
   938                                  ;
   939                                  ; Rev 2.50
   940                                  ;	       all the 2.x new stuff -MU
   941                                  ;
   942                                  ; Rev 3.30     (Ellen G)
   943                                  ;	       CALL internal command (TBATCH2.ASM)
   944                                  ;	       CHCP internal command (TCMD2B.ASM)
   945                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   946                                  ;	       @ sign suppression of batch file line
   947                                  ;	       Replaceable environment value support in batch files
   948                                  ;	       INT 2FH calls for APPEND
   949                                  ;	       Lots of PTR fixes!
   950                                  ;
   951                                  ; Beyond 3.30 to forever  (Ellen G)
   952                                  ; ----------------------
   953                                  ;
   954                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   955                                  ;			Use Message Retriever services
   956                                  ;			/MSG switch for resident extended error msg
   957                                  ;			Convert to new capitalization support
   958                                  ;			Better error recovery on CHCP command
   959                                  ;			Code page file tag support
   960                                  ;			TRUENAME internal command
   961                                  ;			Extended screen line support
   962                                  ;			/P switch on DEL/ERASE command
   963                                  ;			Improved file redirection error recovery
   964                                  ;	(removed)	Improved batch file performance
   965                                  ;			Unconditional DBCS support
   966                                  ;			Volume serial number support
   967                                  ;	(removed)	COMMENT=?? support
   968                                  ;
   969                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   970                                  ;
   971                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   972                                  ;			require delimiters.
   973                                  ;
   974                                  ; A003	PTM P5,P9,P111	Included in A000 development
   975                                  ;
   976                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   977                                  ;			executing
   978                                  ;
   979                                  ; A005	DCR D17 	If user specifies an extension on the command
   980                                  ;			line search for that extension only.
   981                                  ;
   982                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   983                                  ;			exists"
   984                                  ;
   985                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   986                                  ;
   987                                  ; A008	PTM P182	Change COPY to set default if invalid function
   988                                  ;			returned from code page call.
   989                                  ;
   990                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   991                                  ;
   992                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   993                                  ;			transient COMMAND.
   994                                  ;
   995                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   996                                  ;			before appending to a file.
   997                                  ;
   998                                  ; A012	PTM P189	Fix redirection error recovery.
   999                                  ;
  1000                                  ; A013	PTM P330	Change date format
  1001                                  ;
  1002                                  ; A014	PTM P455	Fix echo parsing
  1003                                  ;
  1004                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1005                                  ;
  1006                                  ; A016	PTM P354	Fix extended error message addressing
  1007                                  ;
  1008                                  ; A017	PTM P448	Fix appending to 0 length files
  1009                                  ;
  1010                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1011                                  ;			the parser fails on. Fail on duplicate switches.
  1012                                  ;
  1013                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1014                                  ;			critical error
  1015                                  ;
  1016                                  ; A020	DCR D43 	Set append state off while in DIR
  1017                                  ;
  1018                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1019                                  ;
  1020                                  ; A022	DCR D209	Enhanced error recovery
  1021                                  ;
  1022                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1023                                  ;
  1024                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1025                                  ;
  1026                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1027                                  ;
  1028                                  ; A026	DCR D191	Change redirection error recovery support.
  1029                                  ;
  1030                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1031                                  ;			with a carriage return.
  1032                                  ;
  1033                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1034                                  ;			date and invalid time messages.
  1035                                  ;
  1036                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1037                                  ;			and TIME.
  1038                                  ;
  1039                                  ; A030	DCR D201	New extended attribute format.
  1040                                  ;
  1041                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1042                                  ;
  1043                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1044                                  ;
  1045                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1046                                  ;
  1047                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1048                                  ;
  1049                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1050                                  ;			do a read to determine eof.
  1051                                  ;
  1052                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1053                                  ;			so that ASSIGN works correctly.
  1054                                  ;
  1055                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1056                                  ;
  1057                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1058                                  ;
  1059                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1060                                  ;
  1061                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1062                                  ;			specified.
  1063                                  ;
  1064                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1065                                  ;			executes.
  1066                                  ;
  1067                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1068                                  ;			files causing loss of batch file.
  1069                                  ;
  1070                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1071                                  ;			CALL'ed batch files.
  1072                                  ;
  1073                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1074                                  ;			as an end of line character
  1075                                  ;
  1076                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1077                                  ;			and extended message pointers when we EXIT if
  1078                                  ;			COMMAND /P is the top level process.
  1079                                  ;
  1080                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1081                                  ;			"File not found - fn"
  1082                                  ;
  1083                                  ; A047	PTM P2819	Fix transient reload prompt message
  1084                                  ;
  1085                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1086                                  ;			when DBCS code was added.
  1087                                  ;
  1088                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1089                                  ;			on line.
  1090                                  ;
  1091                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1092                                  ;
  1093                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1094                                  ;
  1095                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1096                                  ;
  1097                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1098                                  ;
  1099                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1100                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1101                                  ;
  1102                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1103                                  ;			problems with breaking out of INT 24h
  1104                                  ;
  1105                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1106                                  ;
  1107                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1108                                  ;			before the "string".  EX: COMMAND /CDIR
  1109                                  ;
  1110                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1111                                  ;			DBCS switch.
  1112                                  ;
  1113                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1114                                  ;			the time.
  1115                                  ;
  1116                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1117                                  ;			messages to be disk based.  Only keep them if /MSG
  1118                                  ;			is used.
  1119                                  ;
  1120                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1121                                  ;			out of internal commands, due to substitution blocks
  1122                                  ;			not being reset.
  1123                                  ;
  1124                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1125                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1126                                  ;			secondary copy of environment.	Change default slash in
  1127                                  ;			default comspec string to backslash.
  1128                                  ;
  1129                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1130                                  ;			text for critical error messages.
  1131                                  ;
  1132                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1133                                  ;	5/20/88 	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1136                                  ;	 5/20/88	with Microsoft product already shipped.
  1137                                  ;
  1138                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1139                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1140                                  ;			header and space remaining.
  1141                                  ;
  1142                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1143                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1144                                  ;			environment was putting a "Z block" marker in the old
  1145                                  ;			environment.  The fix is to move to the old environment
  1146                                  ;			to the new environment before doing the SETBLOCK.
  1147                                  ;
  1148                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1149                                  ;        09/19/88       because the check for APPEND needed to be performed
  1150                                  ;                       before the DIR's findfirst.
  1151                                  ;
  1152                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1153                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1154                                  ;                       loading trans w/new comspec with no user change comspec.
  1155                                  ;
  1156                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1157                                  ;        11/05/88       Expansion of environment variables into batch line of
  1158                                  ;                       128 chars was not being counted and "%" which should be
  1159                                  ;                       ignored were being counted.
  1160                                  ;
  1161                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1162                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1163                                  ;                       ing included in checksum and was being overwritten by
  1164                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1165                                  ;                       Also removed fix A069 (because flag now protected).
  1166                                  ;
  1167                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1168                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1169                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1170                                  ;
  1171                                  ;***********************************************************************************
  1172                                  
  1173                                  ;
  1174                                  ;	Revision History
  1175                                  ;	================
  1176                                  ;
  1177                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1178                                  ;					at init time (date/time prompt)
  1179                                  ;
  1180                                  
  1181                                  ;
  1182                                  ;.xcref
  1183                                  ;.xlist
  1184                                  ;	include dossym.inc		; basic DOS symbol set
  1185                                  ;	include syscall.inc		; DOS function names
  1186                                  ;	include comsw.asm		; build version info
  1187                                  ;	include comequ.asm		; common command.com symbols
  1188                                  ;	include resmsg.equ		; resident message names
  1189                                  ;
  1190                                  ;	include comseg.asm		;segment ordering
  1191                                  ;.list
  1192                                  ;.cref
  1193                                  
  1194                                  ;CODERES segment public byte
  1195                                  ;CODERES ends
  1196                                  ;
  1197                                  ;DATARES 	segment public byte
  1198                                  ;		extrn	AccDen:byte
  1199                                  ;		extrn	Batch:word
  1200                                  ;		extrn	EchoFlag:byte
  1201                                  ;		extrn	ExeBad:byte
  1202                                  ;		extrn	ExecEMes:byte
  1203                                  ;		extrn	ExecErrSubst:byte
  1204                                  ;		extrn	ExtCom:byte
  1205                                  ;		extrn	ForFlag:byte
  1206                                  ;		extrn	IfFlag:byte
  1207                                  ;		extrn	InitFlag:BYTE
  1208                                  ;		extrn	Nest:word
  1209                                  ;		extrn	PipeFlag:byte
  1210                                  ;		extrn	RBadNam:byte
  1211                                  ;		extrn	RetCode:word
  1212                                  ;		extrn	SingleCom:word
  1213                                  ;		extrn	TooBig:byte
  1214                                  ;
  1215                                  ;		extrn	OldDS:word
  1216                                  ;
  1217                                  ;DATARES 	ends
  1218                                  ;
  1219                                  ;
  1220                                  ;INIT		segment public para
  1221                                  ;		extrn	ConProc:near
  1222                                  ;		extrn	Init_Contc_SpecialCase:near
  1223                                  ;INIT		ends
  1224                                  
  1225                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1226                                  ; --------------------------------------
  1227                                  ; 'command5.s' source code reference(s):
  1228                                  
  1229                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1230                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1231                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1232                                  ; ----------------------------------------------------------------------				 	 	
  1233                                  
  1234                                  ; ----------------------------------------------------------------------------
  1235                                  ; START OF RESIDENT PORTION
  1236                                  ; ----------------------------------------------------------------------------
  1237                                  ; SEGMENT - DATARES
  1238                                  ; ----------------------------------------------------------------------------
  1239                                  
  1240                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1241                                  
  1242                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1243                                  
  1244                                  ; ----------------------------------------------------------------------------
  1245                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1246                                  ; ----------------------------------------------------------------------------
  1247                                  
  1248                                  ;This file contains the low memory stub for command.com which hooks all the
  1249                                  ;entry points into the resident command.com and directs the calls to the
  1250                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1251                                  ;
  1252                                  ;The stub has been made part of the resident data and will always
  1253                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1254                                  ;that actually hook the interrupt vectors belong to either the first 
  1255                                  ;command.com or to any other command.com executed with the /p switch. 
  1256                                  ;
  1257                                  ;The stub also keeps track of the current active data segment. The 
  1258                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1259                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1260                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1261                                  ;the exit code picks up the previous data segment pointer from the current
  1262                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1263                                  ;
  1264                                  ;Right now the stub does not bother about A20 switching. We assume
  1265                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1266                                  ;value of the current data segment in one of the registers. A20 toggle 
  1267                                  ;support maybe added as a future enhancement, if the need is felt.
  1268                                  
  1269                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1270                                  
  1271                                  	[ORG 100H]
  1272                                  
  1273                                  	; 21/09/2018 - Retro DOS v3.0
  1274                                  StartCode:
  1275 00000000 E9FD13                  	jmp	ConProc	; 10/01/2023 
  1276                                  
  1277                                  	; 09/01/2023
  1278                                  
  1279                                  ; Make following table word-aligned, and at the same time, provide a
  1280                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1281                                  
  1282                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1283 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1284                                  
  1285                                  ;All the entry points declared below are patched in at INIT time with the
  1286                                  ;proper segment and offset values after the resident code segment has been
  1287                                  ;moved to its final location
  1288                                  
  1289                                  ;!!!WARNING!!!
  1290                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1291                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1292                                  ;in the correct segments and offsets
  1293                                  
  1294                                  Int2f_Entry:
  1295 00000004 [1713]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1296 00000006 0000                    	dw	0
  1297                                  Int2e_Entry:
  1298 00000008 [730D]                  	dw	Int_2e			; Address of int 2eh handler
  1299 0000000A 0000                    	dw	0
  1300                                  Ctrlc_Entry:
  1301 0000000C [330C]                  	dw	ContC			; Address of Ctrl-C handler
  1302 0000000E 0000                    	dw	0
  1303                                  CritErr_Entry:
  1304 00000010 [3410]                  	dw	DSKERR			; Address of critical error handler
  1305 00000012 0000                    	dw	0
  1306                                  
  1307                                  Exec_Entry:
  1308 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1309                                  RemCheck_Entry:
  1310 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1311                                  TrnLodCom1_Entry:
  1312 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1313                                  LodCom_Entry:
  1314 00000020 00000000                	dd	0			; Entry after exit from command.com
  1315                                  MsgRetrv_Entry:
  1316 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1317                                  HeadFix_Entry:
  1318 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1319                                  UMBOff_Entry:
  1320 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1321                                  XMMCallAddr:
  1322 00000030 00000000                	dd	0			; Call address for XMM functions
  1323                                  ComInHMA:
  1324 00000034 00                      	db	0			; Flags if command.com in HMA
  1325                                  
  1326                                  Int2f_Trap:
  1327                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1328 00000035 E86400                  	call	CheckA20
  1329 00000038 1E                      	push	ds			; push current ds value
  1330 00000039 0E                      	push	cs			; push resident data segment value
  1331                                  	;jmp	cs:Int2f_Entry
  1332 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1333                                  
  1334                                  Int2e_Trap:
  1335 0000003F FB                      	sti
  1336 00000040 E85900                  	call	CheckA20
  1337 00000043 1E                      	push	ds			; push current ds value
  1338 00000044 0E                      	push	cs			; push resident data segment value
  1339                                  	;jmp	cs:Int2e_Entry
  1340 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1341                                  
  1342                                  Ctrlc_Trap:
  1343 0000004A FB                      	sti
  1344 0000004B E84E00                  	call	CheckA20
  1345 0000004E 1E                      	push	ds			; push current ds value
  1346 0000004F 0E                      	push	cs			; push resident data segment value
  1347                                  	;jmp	cs:Ctrlc_Entry
  1348 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1349                                  
  1350                                  CritErr_Trap:
  1351 00000055 FB                      	sti
  1352 00000056 E84300                  	call	CheckA20
  1353 00000059 1E                      	push	ds			; push current ds value
  1354 0000005A 0E                      	push	cs			; push resident data segment value
  1355                                  	;jmp	cs:CritErr_Entry
  1356 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1357                                  
  1358                                  Exec_Trap:
  1359 00000060 E83900                  	call	CheckA20
  1360 00000063 1E                      	push	ds			; push current ds value
  1361 00000064 0E                      	push	cs			; push resident data segment value
  1362                                  	;jmp	cs:Exec_Entry
  1363 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1364                                  
  1365                                  RemCheck_Trap:
  1366 0000006A E82F00                  	call	CheckA20
  1367 0000006D 1E                      	push	ds			; push current ds value
  1368 0000006E 0E                      	push	cs			; push resident data segment value
  1369                                  	;jmp	cs:RemCheck_Entry
  1370 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1371                                  
  1372                                  TrnLodCom1_Trap:
  1373 00000074 E82500                  	call	CheckA20
  1374 00000077 1E                      	push	ds			; push current ds value
  1375 00000078 0E                      	push	cs			; push resident data segment value
  1376                                  	;jmp	cs:TrnLodCom1_Entry
  1377 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1378                                  
  1379                                  LodCom_Trap:
  1380 0000007E E81B00                  	call	CheckA20
  1381 00000081 1E                      	push	ds			; push current ds value
  1382 00000082 0E                      	push	cs			; push resident data segment value
  1383                                  	;jmp	cs:LodCom_Entry
  1384 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1385                                  
  1386                                  MsgRetrv_Trap:
  1387 00000088 E81100                  	call	CheckA20
  1388 0000008B 1E                      	push	ds			; push current ds value
  1389 0000008C 0E                      	push	cs			; push resident data segment value
  1390                                  	;jmp	cs:MsgRetrv_Entry
  1391 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1392                                  
  1393                                  HeadFix_Trap:
  1394 00000092 E80700                  	call	CheckA20
  1395 00000095 1E                      	push	ds			; push current ds value
  1396 00000096 0E                      	push	cs			; push resident data segment value
  1397                                  	;jmp	cs:HeadFix_Entry
  1398 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1399                                  
  1400                                  ; ----------------------------------------------------------------------------
  1401                                  
  1402                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1403                                  %if 0
  1404                                  	; 09/01/2023
  1405                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1406                                  
  1407                                  	; 05/06/2023
  1408                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1409                                  CheckA20:
  1410                                  	pushf				; save current flags
  1411                                  	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1412                                  	jz	short A20_on		; no, jump to resident
  1413                                  
  1414                                  	call	QueryA20
  1415                                  	jnc	short A20_on		; A20 is on, jump to resident
  1416                                  
  1417                                  	call	EnableA20		; turn A20 on
  1418                                  A20_on:
  1419                                  	popf				; flags have to be unchanged
  1420                                  	retn
  1421                                  %else
  1422                                  	; 18/07/2024
  1423                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1424                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1425                                  	; PCDOS 7.1 COMMAND.COM - RESGROUP:01FFh
  1426                                  CheckA20:
  1427 0000009C 9C                      	pushf				; save current flags
  1428 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1429 000000A3 741A                    	jz	short A20_on		; no, jump to resident
  1430                                  	; 18/07/2024
  1431 000000A5 50                      	push	ax
  1432 000000A6 53                      	push	bx
  1433                                  QueryA20:
  1434                                  	;mov	ah,7
  1435 000000A7 B407                    	mov	ah,XMM_QUERY_A20
  1436                                  	;call	cs:XMMCallAddr
  1437 000000A9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1438 000000AE 09C0                    	or	ax,ax
  1439                                  	; 16/04/2023
  1440 000000B0 750B                    	jnz	short QA20_ON		; A20 is on, jump to resident
  1441                                  	; 18/07/2024
  1442                                  EnableA20:
  1443                                  	;mov	ah,5
  1444 000000B2 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20	; turn A20 on
  1445                                  	;call	cs:XMMCallAddr
  1446 000000B4 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1447 000000B9 09C0                    	or	ax,ax
  1448 000000BB 7404                    	jz	short XMMerror		; AX = 0 fatal error
  1449                                  QA20_ON:
  1450 000000BD 5B                      	pop	bx
  1451 000000BE 58                      	pop	ax
  1452                                  A20_on:
  1453 000000BF 9D                      	popf				; flags have to be unchanged
  1454 000000C0 C3                      	retn
  1455                                  ;If we get an error, we just loop forever
  1456                                  XMMerror:
  1457 000000C1 EBFE                    	jmp	short XMMerror
  1458                                  %endif
  1459                                  
  1460                                  ; ----------------------------------------------------------------------------
  1461                                  
  1462                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1463                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1464                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1465                                  ; M005; pointers because our cs is going to be different. The segment to
  1466                                  ; M005; jump to is patched in at init time. (in init.asm)
  1467                                  
  1468                                  Carousel_i2f_Hook:			; M005
  1469 000000C3 EA                      	db	0EAh			; far jump opcode; M005
  1470 000000C4 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1471 000000C6 0000                    	dw	0			; int 2fh segment; M005
  1472                                  
  1473                                  ; ----------------------------------------------------------------------------
  1474                                  
  1475                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1476                                  %if 0
  1477                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1478                                  QueryA20:
  1479                                  	push	bx
  1480                                  	push	ax
  1481                                  	;mov	ah,7
  1482                                  	mov	ah,XMM_QUERY_A20
  1483                                  	;call	cs:XMMCallAddr
  1484                                  	call	far [cs:XMMCallAddr]
  1485                                  	or	ax,ax
  1486                                  	pop	ax
  1487                                  	pop	bx
  1488                                  	; 16/04/2023
  1489                                  	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1490                                  	stc					; OFF
  1491                                  	;retn
  1492                                  QA20_ON:
  1493                                  	;clc					; ON
  1494                                  	retn
  1495                                  %endif
  1496                                  
  1497                                  ; ----------------------------------------------------------------------------
  1498                                  
  1499                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1500                                  %if 0
  1501                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1502                                  EnableA20:
  1503                                  	push	bx
  1504                                  	push	ax
  1505                                  	;mov	ah,5
  1506                                  	mov	ah,XMM_LOCAL_ENABLE_A20
  1507                                  	;call	cs:XMMCallAddr
  1508                                  	call	far [cs:XMMCallAddr]
  1509                                  	or	ax,ax
  1510                                  	jz	short XMMerror			; AX = 0 fatal error
  1511                                  	pop	ax
  1512                                  	pop	bx
  1513                                  	retn
  1514                                  ;If we get an error, we just loop forever
  1515                                  XMMerror:
  1516                                  	jmp	short XMMerror
  1517                                  %endif
  1518                                  
  1519                                  ; -----------------------------------------------------------------------------
  1520                                  
  1521                                  HV_Extern   equ	1
  1522                                  HV_LoadHigh equ	1
  1523                                  HV_Stub	    equ	1
  1524                                  
  1525                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1526                                  
  1527                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1528                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1529                                  ;returns with all registers preserved and so all our segment registers are
  1530                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1531                                  ;comes back here. In this case the segment registers and the stack are
  1532                                  ;not set up and random things can happen. The only way to setup all the 
  1533                                  ;registers is to use the cs value and this can only be done when we are in
  1534                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1535                                  ;the code segment to the data segment.
  1536                                  
  1537                                  Issue_Exec_Call:
  1538 000000C8 CD21                    	int 	21h
  1539                                  
  1540                                  ;We disable interrupts while changing the stack because there is a bug in 
  1541                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1542                                  ;are being changed.
  1543                                  
  1544 000000CA FA                      	cli
  1545 000000CB 0E                      	push	cs
  1546 000000CC 17                      	pop	ss
  1547                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1548                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1549 000000CD BC[1E04]                	mov	sp,RStack		; stack is set up
  1550                                  	
  1551                                  	; 20/04/2023
  1552                                  	;sti
  1553                                  	;push	cs
  1554                                  	;pop	ds			; ds = DATARES
  1555                                  
  1556                                  ; M009; Restore UMB state to that before Exec
  1557                                  
  1558                                  	;pushf				;    This call frees HIDDEN umb's,
  1559                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1560                                  	;popf				;    strategy and link state, as app.
  1561                                  
  1562                                  	; 09/01/2023 - Retro DOS v4.0
  1563                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1564                                  	; ----------------------
  1565 000000D0 FB                      	sti
  1566                                  	
  1567 000000D1 0E                      	push    cs
  1568 000000D2 1F                      	pop     ds
  1569 000000D3 9C                      	pushf
  1570                                  	;mov	al,[cs:fInHigh]
  1571                                  	; 18/04/2023
  1572 000000D4 A0[2004]                	mov	al,[fInHigh]
  1573 000000D7 A880                    	test	al,80h
  1574 000000D9 7406                    	jz      short uhu10
  1575 000000DB 247F                    	and     al,7Fh
  1576                                  	;;call	cs:UMBOff_Entry
  1577                                  	;call	far [cs:UMBOff_Entry]
  1578 000000DD FF1E[2C00]              	call	far [UMBOff_Entry]
  1579                                  uhu10:
  1580                                  	;and	byte [cs:fInHigh],7Fh
  1581                                  	; 18/04/2023
  1582 000000E1 8026[2004]7F            	and	byte [fInHigh],7Fh
  1583 000000E6 9D                      	popf
  1584                                  	; ----------------------
  1585                                  
  1586                                  ;We now jump to the stub trap which returns us to the resident code. All
  1587                                  ;flags are preserved by the stub code.
  1588                                  
  1589 000000E7 E976FF                  	jmp	Exec_Trap
  1590                                  
  1591                                  ; ----------------------------------------------------------------------------
  1592                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1593                                  ; ----------------------------------------------------------------------------
  1594                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1595                                  
  1596                                  ;***	Message substitution blocks
  1597                                  
  1598                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1599                                  
  1600                                  ;BlkDevErrSubst	label	byte
  1601                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1602                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1603                                  
  1604 000000EA 02                      BlkDevErrSubst: db	2
  1605 000000EB 0000                    BlkDevErrRw:	dw	0
  1606 000000ED 01                      		db	1
  1607 000000EE [F000]                  		dw	DrvLet
  1608                                  
  1609 000000F0 41                      DrvLet:		db	'A'			; drive letter
  1610                                  
  1611                                  
  1612                                  ;CharDevErrSubst label	byte
  1613                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1614                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1615                                  
  1616 000000F1 02                      CharDevErrSubst: db	2
  1617 000000F2 0000                    CharDevErrRw:	dw	0
  1618 000000F4 02                      		db	2
  1619 000000F5 [0301]                  		dw	DevName
  1620                                  
  1621                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0318h
  1622                                  ;DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1623                                  ;		db	0
  1624                                  
  1625                                  ;NeedVolSubst	label	byte
  1626                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1627                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1628                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1629                                  
  1630 000000F7 02                      NeedVolSubst:	db	2
  1631 000000F8 [0001]                  		dw	VolName
  1632 000000FA 03                      		db	3
  1633 000000FB [0E01]                  		dw	VolSer+2
  1634 000000FD 03                      		db	3
  1635 000000FE [0C01]                  		dw	VolSer
  1636                                  
  1637                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0321h
  1638                                  	; NOTE:	VolName and VolSer must be adjacent
  1639                                  ;VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1640                                  		; 18/07/2024
  1641 00000100 000000                  VolName:	db	3 dup(0)
  1642 00000103 0000000000000000        DevName:	db	8 dup(0)
  1643                                  	
  1644 0000010B 00                      		db	0
  1645 0000010C 00000000                VolSer:		dd	0			; volume serial #
  1646                                  
  1647 00000110 00                      CDevAt:		db	0
  1648                                  
  1649                                  ;BadFatSubst	label	byte
  1650                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1651                                  
  1652 00000111 01                      BadFatSubst:	db	1
  1653 00000112 [F000]                  		dw	DrvLet
  1654                                  
  1655                                  ;PutBackSubst	label	byte
  1656                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1657                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1658                                  
  1659 00000114 02                      PutBackSubst:	db	2
  1660 00000115 0000                    PutBackComSpec:	dw	0
  1661 00000117 01                      		db	1
  1662 00000118 [1A01]                  		dw	PutBackDrv
  1663                                  
  1664 0000011A 20                      PutBackDrv:	db	' '			; drive letter
  1665                                  
  1666                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1667                                  
  1668 0000011B 02                      ExecErrSubst:	db	2
  1669 0000011C [4903]                  		dw	SafePathBuffer
  1670                                  
  1671 0000011E 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1672 00000122 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1673                                  
  1674 00000123 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1675 00000127 0000                    Save_Pdb:	dw	0
  1676 00000129 0000                    Parent:		dw	0
  1677 0000012B 00000000                OldTerm:	dd	0
  1678 0000012F 0000                    ErrCd_24:	dw	0
  1679 00000131 0000                    Handle01:	dw	0
  1680 00000133 00                      Loading:	db	0
  1681 00000134 0000                    Batch:		dw	0	; assume no batch mode initially
  1682                                  
  1683                                  ;;;;SR;
  1684                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1685                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1686                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1687                                  ;;;;
  1688                                  ;;;BatchEOF:	db	0
  1689                                  
  1690                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1691                                  	; What's this comspec_end about?
  1692 00000136 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1693 00000176 0000                    ComSpec_End:	dw	0
  1694                                  
  1695                                  ;Trans		label	dword
  1696                                  ;		dw	TRANGROUP:Command
  1697                                  
  1698                                  Trans:		;dw	12Ch
  1699                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1700 00000178 [2C01]                  		dw	COMMAND ; 16/04/2023
  1701 0000017A 0000                    TrnSeg:		dw	0
  1702                                  
  1703 0000017C 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1704                                  
  1705 0000017D 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1706 0000017E 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1707                                  
  1708 0000017F 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1709 00000180 0000                    MemSiz:		dw	0
  1710 00000182 0000                    Sum:		dw	0
  1711 00000184 01                      ExtCom:		db	1	; for init, pretend just did an external
  1712 00000185 0000                    RetCode: 	dw	0
  1713 00000187 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1714                                  
  1715                                  
  1716                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1717                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1718                                  
  1719 00000188 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1720 00000189 01                      Suppress:	db	1	; used for echo, 1=echo line
  1721 0000018A 0000                    Io_Save: 	dw	0
  1722 0000018C 00                      RestDir: 	db	0
  1723 0000018D 00                      PermCom: 	db	0	; true => permanent command
  1724                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1725                                  				; true => semi-permanent command (/K)
  1726 0000018E 0000                    SingleCom:	dw	0	; true => single command version
  1727 00000190 FFFF                    VerVal:		dw	-1
  1728 00000192 00                      fFail:		db	0	; true => fail all int 24s
  1729 00000193 00                      IfFlag:		db	0	; true => IF statement in progress
  1730                                  
  1731 00000194 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1732 00000195 0000                    ForPtr:		dw	0
  1733                                  
  1734 00000197 0000                    Nest:		dw	0	; nested batch file counter
  1735 00000199 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1736 0000019A 00                      Call_Batch_Flag: db	0
  1737 0000019B 0000                    Next_Batch:	dw	0	; address of next batch segment
  1738 0000019D 00                      NullFlag:	db	0	; flag if no command on command line
  1739 0000019E 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1740                                  				; buffer for file ucase address
  1741                                  ; Bugbug: don't need crit_msg_ anymore?
  1742                                  
  1743 000001A3 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1744 000001A5 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1745 000001A7 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1746 000001A9 0000                    		 dw	0	; DBCS vector segment
  1747 000001AB 0000                    Append_State:	dw	0	; current state of append
  1748                                  				;  (if Append_Flag is set)
  1749 000001AD 00                      Append_Flag:	db	0	; set if append state is valid
  1750 000001AE 00                      Re_Out_App:	db	0
  1751 000001AF 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1752                                  
  1753                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1754                                  ; various times. Here is the breakdown:
  1755                                  ;
  1756                                  ;   INITINIT	We are in the init code.
  1757                                  ;   INITSPECIAL We are in the date/time prompt
  1758                                  ;   INITCTRLC	We are handling a ^C already.
  1759                                  ;
  1760                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1761                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1762                                  ;
  1763                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1764                                  ; input buffer with a CR to pretend an empty response.
  1765                                  ;
  1766                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1767                                  ; (ourselves). We can then detect the carry set and properly retry the
  1768                                  ; operation.
  1769                                  
  1770                                  InitFlag:	;db	1
  1771 000001FF 01                      		db	INITINIT
  1772                                  
  1773                                  ; Note: these two bytes are referenced as a word
  1774 00000200 00                      PipeFlag:	db	0
  1775 00000201 00                      PipeFiles:	db	0
  1776                                  
  1777                                  ; (rdata.asm, msdos 6.0, 1992)
  1778                                  ; ----------------------------------------------------------------------------
  1779                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1780                                  
  1781                                  
  1782                                  ;;SR
  1783                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1784                                  ;;
  1785                                  ;
  1786                                  ;; Bugbug: can we find any way around maintaining these
  1787                                  ;; large buffers?
  1788                                  ;
  1789                                  ;Pipe1		db	67+12 dup (?)
  1790                                  ;Pipe2		db	67+12 dup (?)
  1791                                  ;
  1792                                  ;PipePtr 	dw	?
  1793                                  ;
  1794                                  ;PipeStr 	db	129 dup (?)
  1795                                  ;
  1796                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1797                                  ;
  1798                                  ;;SR;
  1799                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1800                                  ;;automatically be discarded after init.
  1801                                  ;;
  1802                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1803                                  ;; M004; the origin.
  1804                                  ;;
  1805                                  ;	ORG	Pipe1	; M004
  1806                                  ;
  1807                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1808                                  ;; what it expects, what it does.
  1809                                  ;
  1810                                  
  1811                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1812                                  
  1813                                  Pipe1	equ	EndInit
  1814                                  Pipe2	equ	Pipe1+67+12
  1815                                  PipePtr	equ	Pipe2+67+12
  1816                                  PipeStr	equ	PipePtr+2
  1817                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1818                                  
  1819                                  ; Bugbug: really need a procedure header for EndInit, describing
  1820                                  ; what it expects, what it does.
  1821                                  
  1822                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1823                                  
  1824                                  EndInit:
  1825 00000202 1E                      	push	ds
  1826 00000203 06                      	push	es		; save segments
  1827 00000204 0E                      	push	cs
  1828 00000205 1F                      	pop	ds		
  1829                                  	;assume	ds:RESGROUP
  1830                                  
  1831                                  ; M004; Save size of transient here before INIT segment is deallocated
  1832                                  
  1833 00000206 8B16[7E1C]              	mov	dx,[TrnSize]		; M004
  1834                                  ;M027
  1835                                  ; These variables are also defined in the INIT segment and need to be saved
  1836                                  ;before we resize
  1837                                  ;
  1838 0000020A A1[721C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1839 0000020D 8B1E[6E1C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1840 00000211 8B0E[741C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1841 00000215 50                      	push	ax		; Save all these values ;M027
  1842 00000216 53                      	push	bx		; M027
  1843 00000217 51                      	push	cx		; M027
  1844                                  
  1845                                  
  1846                                  ; Bugbug: push ds, pop es here.
  1847                                  	;mov	bx,ds
  1848                                  	;mov	es,bx		; es = RESGROUP
  1849                                  	; 09/01/2023
  1850 00000218 1E                      	push	ds
  1851 00000219 07                      	pop	es
  1852                                  
  1853                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1854                                  ; code + data for low COMMAND
  1855                                  
  1856 0000021A 8B1E[9F03]              	mov	bx,[ResSize]	; Total size of resident
  1857 0000021E B44A                    	mov	ah,4Ah
  1858                                  	;mov	ah,SETBLOCK
  1859 00000220 CD21                    	int	21h		; Set block to resident size
  1860                                  
  1861                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1862                                  		; ES = segment address of block to change
  1863                                  		; BX = new size in paragraphs
  1864                                  
  1865                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1866                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1867                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1868                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1869                                  ;
  1870                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1871                                  	
  1872 00000222 803E[8D01]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1873 00000227 7530                    	jne	short adjust_env ; no, do not free batchseg
  1874                                  
  1875 00000229 833E[3401]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1876 0000022E 7429                    	je	short adjust_env ; no, dont juggle
  1877                                  
  1878                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  1879                                  	; 21/01/2023
  1880 00000230 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1881                                  	;mov	bx,4	; 09/01/2023
  1882                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1883 00000233 B448                    	mov	ah,48h
  1884                                  	;mov	ah,ALLOC
  1885 00000235 CD21                    	int	21h
  1886                                  
  1887                                  		; DOS - 2+ - ALLOCATE MEMORY
  1888                                  		; BX = number of 16-byte paragraphs desired
  1889                                  
  1890                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1891                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1892                                  ; could be making it worse! We're second-guessing where memory
  1893                                  ; allocations go, which might not be such a great idea. Is there
  1894                                  ; a strategy, short of doing something even worse like diddling
  1895                                  ; arena headers, where we can minimize the possibility of fragmentation
  1896                                  ; under all cases? Hmm..
  1897                                  	
  1898 00000237 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1899                                  
  1900 00000239 8EC0                    	mov	es,ax		 ; es = New batch segment
  1901 0000023B 31FF                    	xor	di,di
  1902 0000023D 31F6                    	xor	si,si
  1903                                  
  1904 0000023F 1E                      	push	ds
  1905 00000240 8E1E[3401]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1906                                  	;assume	ds:nothing
  1907                                  	;mov	cx,SIZE BatchSegment
  1908                                  	; 23/01/2023
  1909                                  	;mov	cx,BATCHSEGMENT.SIZE
  1910                                  	;;mov	cx,33	; 09/01/2023
  1911                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1912                                  	;
  1913                                  	;add	cx,16		 ; for the filename
  1914                                  	; 20/04/2023
  1915 00000244 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16
  1916                                  
  1917                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1918                                  	; It's sure be bad if we copied more bytes than the batch segment
  1919                                  	; holds!
  1920                                  	
  1921 00000247 FC                      	cld
  1922 00000248 F3A4                    	rep	movsb
  1923 0000024A 1F                      	pop	ds
  1924                                  	;assume	ds:RESGROUP
  1925                                  
  1926 0000024B 8CC1                    	mov	cx,es		; save new batch segment 
  1927 0000024D 8E06[3401]              	mov	es,[Batch]
  1928 00000251 B449                    	mov	ah,49h
  1929                                  	;mov	ah,DEALLOC
  1930 00000253 CD21                    	int	21h		; free the old batch segment
  1931                                  
  1932                                  	; Bugbug: should we check for error?
  1933                                  
  1934 00000255 890E[3401]              	mov	[Batch],cx	; store new batch segment address
  1935                                  
  1936                                  adjust_env:
  1937 00000259 59                      	pop	cx		; cx = size of old env ;M027
  1938 0000025A 5B                      	pop	bx		; bx = size of new env needed ;M027
  1939 0000025B 5D                      	pop	bp		; bp = old env seg ;M027
  1940                                  
  1941                                  ;Allocate the correct size for the environment
  1942                                  
  1943 0000025C B448                    	mov	ah,48h
  1944                                  	;mov	ah,ALLOC
  1945 0000025E CD21                    	int	21h		; get memory
  1946 00000260 7264                    	jc	short nomem_err	; out of memory,signal error
  1947                                  	
  1948                                  	; Bugbug: why not continue, leaving environment where it is?
  1949                                  
  1950 00000262 A3[2703]                	mov	[EnvirSeg],ax	; Store new environment segment
  1951                                  	;;mov	[ds:2Ch],ax
  1952                                  	;mov	[2Ch],ax
  1953                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1954 00000265 A32C00                  	mov	[PDB.ENVIRON],ax
  1955 00000268 8EC0                    	mov	es,ax		; es = address of allocated memory
  1956                                  	;assume	es:nothing
  1957                                  
  1958                                  ;Copy the environment to the newly allocated segment
  1959                                  
  1960 0000026A 1E                      	push	ds
  1961 0000026B 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1962                                  	;assume	ds:nothing
  1963                                  
  1964 0000026D 31F6                    	xor	si,si
  1965 0000026F 89F7                    	mov	di,si		; Start transfer from 0
  1966                                  
  1967 00000271 FC                      	cld
  1968 00000272 F3A4                    	rep	movsb		; Do the copy
  1969                                  
  1970 00000274 1F                      	pop	ds		; ds = RESGROUP
  1971                                  	;assume	ds:RESGROUP
  1972                                  
  1973                                  ; We have to free the old environment block if it was allocated by INIT
  1974                                  
  1975                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1976                                  ; or does it also apply to passed environments?
  1977                                  
  1978                                  ;M036
  1979                                  ; Free up old env segment always because this is a copy passed by Exec and
  1980                                  ; takes up memory that is never used
  1981                                  
  1982                                  ;M044
  1983                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1984                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1985                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1986                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1987                                  ; in
  1988                                  
  1989                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1990                                          ;je	short no_free	    ; no, do not free it
  1991                                  	; 21/01/2023
  1992                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1993 00000275 803E[521C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment
  1994 0000027A 7506                    	jne	short no_free 
  1995                                  
  1996 0000027C 8EC5                    	mov	es,bp
  1997 0000027E B449                    	mov	ah,49h
  1998                                  	;mov	ah,DEALLOC
  1999 00000280 CD21                    	int	21h		    ; Free it
  2000                                  no_free:
  2001                                  
  2002                                  ; M004; Start of changes
  2003                                  
  2004                                  ; Move the transient now. We will allocate the biggest block available
  2005                                  ; now and move the transient to the top of the block. We will then
  2006                                  ; deallocate this block. When the resident starts executing, it will
  2007                                  ; hopefully allocate this block again and find the transient intact.
  2008                                  
  2009 00000282 C606[7C01]01            	mov	byte [TrnMvFlg],1 ; Indicate that transient has been moved
  2010 00000287 06                      	push	es
  2011                                  	;;mov	si,offset ResGroup:TranStart
  2012                                  	; 09/01/2023
  2013                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2014 00000288 BE0022                  	mov	si,TRANSTART	; (End of the resident portion)
  2015                                  	;mov	di,0
  2016 0000028B 31FF                    	xor	di,di ; 0
  2017                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2018                                  	;mov	cx,98C5h
  2019 0000028D B96F95                  	mov	cx,TRANSPACEEND
  2020                                  	
  2021                                  ; Find the largest block available
  2022                                  
  2023 00000290 BBFFFF                  	mov	bx,0FFFFh
  2024 00000293 B448                    	mov	ah,48h
  2025                                  	;mov	ah,ALLOC
  2026 00000295 CD21                    	int	21h
  2027                                  
  2028                                  ; dx = size of transient saved previously 
  2029                                  
  2030 00000297 39D3                    	cmp	bx,dx		; enough memory?
  2031 00000299 722B                    	jb	short nomem_err	; not enough memory for transient
  2032                                  
  2033 0000029B B448                    	mov	ah,48h
  2034                                  	;mov	ah,ALLOC
  2035 0000029D CD21                    	int	21h		; get the largest block
  2036 0000029F 7225                    	jc	short nomem_err	; something is really screwed up
  2037                                  
  2038 000002A1 50                      	push	ax		; save memory address
  2039 000002A2 01D8                    	add	ax,bx		; ax = top of my memory block
  2040 000002A4 29D0                    	sub	ax,dx		; less size of transient
  2041 000002A6 A3[7A01]                	mov	[TrnSeg],ax	; save transient segment
  2042 000002A9 8EC0                    	mov	es,ax		;
  2043 000002AB 58                      	pop	ax		; restore our seg addr
  2044                                  
  2045                                  ; Everything is set for a move. We need to move in the reverse direction to
  2046                                  ; make sure we dont overwrite ourselves while copying
  2047                                  
  2048 000002AC 01CE                    	add	si,cx
  2049 000002AE 4E                      	dec	si
  2050 000002AF 01CF                    	add	di,cx
  2051 000002B1 4F                      	dec	di
  2052 000002B2 FD                      	std
  2053 000002B3 F3A4                    	rep	movsb
  2054 000002B5 FC                      	cld
  2055                                  
  2056                                  ; Now we have to free up this block so that resident can get hold of it
  2057                                  
  2058 000002B6 8EC0                    	mov	es,ax
  2059 000002B8 B449                    	mov	ah,49h
  2060                                  	;mov	ah,DEALLOC
  2061 000002BA CD21                    	int	21h		; release the memory block
  2062                                  
  2063                                  ; M004; End of changes
  2064                                  
  2065                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2066                                  	; 09/01/2023
  2067 000002BC C606[FF01]00            	mov	byte [InitFlag],0	
  2068                                  
  2069 000002C1 07                      	pop	es
  2070 000002C2 1F                      	pop	ds
  2071                                  	;assume	ds:nothing
  2072                                  	
  2073                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2074                                  	
  2075 000002C3 E9B8FD                  	jmp	LodCom_Trap	; allocate transient
  2076                                  
  2077                                  nomem_err:
  2078                                  
  2079                                  ;We call the error routine which will never return. It will either exit
  2080                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2081                                  ;message ( if first COMMAND )
  2082                                  
  2083 000002C6 E9F518                  	jmp	Alloc_error
  2084                                  
  2085                                  ;EndCodeInit:	; label	byte		; M004
  2086                                  
  2087                                  	; 16/04/2023
  2088                                  	EndCodeInit equ $
  2089                                  
  2090                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2091                                  ;; M004; If not, we signal an assembly error
  2092                                  ;
  2093                                  ;IF2
  2094                                  ;	IF ($ GT EndPipe)
  2095                                  ;		.err
  2096                                  ;		%out	"ENDINIT CODE TOO BIG"
  2097                                  ;	ENDIF
  2098                                  ;ENDIF
  2099                                  
  2100                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2101                                  ;;
  2102                                  ;		ORG	EndPipe		; M004
  2103                                  
  2104                                  ; 09/01/2023
  2105                                  
  2106                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2107                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2108                                  
  2109                                  ; 16/04/2023
  2110                                  	FillBytes equ EndPipe - EndCodeInit
  2111                                  
  2112                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2113                                  ; 16/04/2023
  2114                                  %if FillBytes>0
  2115                                  	;times EndPipe - EndCodeInit db 0
  2116 000002C9 00<rep 5Ah>             	times FillBytes db 0
  2117                                  %endif
  2118                                  
  2119                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2120                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289
  2121                                  
  2122                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h
  2123                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2124                                  
  2125 00000323 [0202]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2126 00000325 [5102]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2127                                  
  2128                                  Exec_Block:	; label	byte	; the data block for exec calls
  2129 00000327 0000                    EnvirSeg:	dw	0
  2130                                  Com_Ptr:	; label	dword
  2131 00000329 8000                    		dw	80h	; point at unformatted parameters
  2132 0000032B 0000                    		dw	0
  2133                                  Com_Fcb1:	; label	dword
  2134 0000032D 5C00                    		dw	5Ch
  2135 0000032F 0000                    		dw	0
  2136                                  Com_Fcb2:	; label	dword
  2137 00000331 6C00                    		dw	6Ch
  2138 00000333 0000                    		dw	0
  2139                                  
  2140                                  ; variables passed to transient
  2141                                  TranVars:	; label	byte
  2142                                  		;dw	offset DATARES:HeadFix_Trap
  2143 00000335 [9200]                  		dw	HeadFix_Trap
  2144 00000337 0000                    MySeg:		dw	0	; put our own segment here
  2145 00000339 0000                    LTpa:		dw	0	; will store tpa segment here
  2146 0000033B 2F                      RSwitChar:	db	"/"
  2147 0000033C 5C                      RDirChar:	db	"\"
  2148                                  		;dw	offset DATARES:Issue_Exec_Call
  2149 0000033D [C800]                  		dw	Issue_Exec_Call
  2150 0000033F 0000                    MySeg1:		dw	0
  2151                                  		;dw	offset DATARES:RemCheck_Trap
  2152 00000341 [6A00]                  		dw	RemCheck_Trap
  2153 00000343 0000                    MySeg2:		dw	0
  2154                                  
  2155                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
  2156                                  %if 0
  2157                                  ResTest: 	dw	0
  2158                                  %endif
  2159                                  
  2160 00000345 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2161                                  
  2162                                  TranVarEnd:	; label	byte
  2163                                  
  2164 00000347 0000                    OldErrNo:	dw	0
  2165                                  
  2166                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2167                                  ;  MsgBuffer is only used while a command is being executed.
  2168                                  ;  SafePathBuffer is no longer needed, since it is used for
  2169                                  ;  unsuccessful program launches.
  2170                                  
  2171                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2172                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2173                                  	;Bugbug: Why so big a buffer?
  2174                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2175 00000349 00<rep 50h>             		times	64+3+13 db 0		
  2176                                  
  2177                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2178                                  
  2179 00000399 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2180 0000039D 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2181                                  
  2182                                  ;SR;
  2183                                  ; The three vars below have been added for a pure COMMAND.COM
  2184                                  
  2185 0000039F 0000                    ResSize:	dw	0
  2186                                  
  2187                                  ;SR;
  2188                                  ; Moved the stack here from the code segment
  2189                                  ;
  2190                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2191                                  	
  2192                                  		;db	(80h - 3) dup (?)
  2193 000003A1 90                      align 2
  2194 000003A2 00<rep 7Ch>             		times	124 db 0		
  2195                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2196                                  RStack:		; label	word
  2197 0000041E 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2198                                  				; resident code segments
  2199                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2200                                  
  2201                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2202                                  ; -------------------------------
  2203                                  
  2204                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2205                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2206                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2207                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2208                                  ;            given a command-line like "/L:3,500;4"
  2209                                  ; UmbUsed  - An array of characters, each of which is 1 if the UMB
  2210                                  ;            matching its index number was specified on the command-line;
  2211                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2212                                  ;            will be set to 1. All others will be set to 0.
  2213                                  ; UmbSize  - An array of words, each of which is interpreted as a size
  2214                                  ;            specified by the user for a UMB (in the above example, all
  2215                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2216                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2217                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2218                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2219                                  ;            for details).
  2220                                  
  2221                                  ; - MSDOS 6.0 COMMAND.COM -
  2222                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2223                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2224                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2225                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2226                                  ;; space problem (it's just such a nice round number, eh?).
  2227                                  
  2228                                  ;MAXUMB	equ	16
  2229                                  
  2230                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2231                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2232                                  
  2233 00000420 00                      fInHigh:	db	0
  2234                                  
  2235                                  ; MSDOS 6.0 COMMAND.COM
  2236                                  ;fUmbTiny:	db	0
  2237                                  ;SegLoad:	dw	0
  2238                                  ;UmbLoad:	db	0
  2239                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2240                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2241                                  ;fm_umb:	db	0
  2242                                  ;fm_strat:	db	0
  2243                                  ;fm_argc:	db	0
  2244                                  
  2245                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2246                                  ; UmbLoad is set to the UMB number given.
  2247                                  
  2248                                  ;*** MESSAGES
  2249                                  ;    and other translatable text
  2250                                  
  2251                                  ; include comrmsg.inc	; M00
  2252                                  ; ------------------------------
  2253                                  
  2254                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2255                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2256                                  
  2257 00000421 41                      ABORT_CHAR:	db 'A'
  2258 00000422 52                      RETRY_CHAR:	db 'R'
  2259 00000423 49                      IGNORE_CHAR:	db 'I'
  2260 00000424 46                      FAIL_CHAR:	db 'F'
  2261 00000425 59                      YES_CHAR:	db 'Y'
  2262 00000426 4E                      NO_CHAR:	db 'N'
  2263 00000427 05                      REQ_ABORT:	db 5
  2264 00000428 41626F7274              		db 'Abort'
  2265 0000042D 07                      REQ_RETRY:	db 7
  2266 0000042E 2C205265747279          		db ', Retry'
  2267 00000435 08                      REQ_IGNORE:	db 8
  2268 00000436 2C2049676E6F7265        		db ', Ignore'
  2269 0000043E 06                      REQ_FAIL:	db 6
  2270 0000043F 2C204661696C            		db ', Fail'
  2271 00000445 01                      REQ_END:	db 1
  2272 00000446 3F                      		db '?'
  2273 00000447 08                      MREAD:		db 8
  2274 00000448 72656164696E6700        		db 'reading', 0
  2275 00000450 08                      MWRITE:		db 8
  2276 00000451 77726974696E6700        		db 'writing', 0
  2277 00000459 0E                      MDRIVE:		db 14
  2278 0000045A 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2278 00000463 2025320D0A         
  2279 00000468 0F                      MDEVICE:	db 15
  2280 00000469 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2280 00000472 652025320D0A       
  2281 00000478 26                      MVOLSERIAL:	db 38
  2282 00000479 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2282 00000482 7365727420766F6C75-
  2282 0000048B 6D6520253120736572-
  2282 00000494 69616C2025322D2533-
  2282 0000049D 0D0A               
  2283 0000049F 25                      BADFATMSG:	db 37
  2284 000004A0 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2284 000004A9 636174696F6E207461-
  2284 000004B2 626C65206261642C20-
  2284 000004BB 64726976652025310D-
  2284 000004C4 0A                 
  2285 000004C5 15                      COMBAD:		db 21
  2286 000004C6 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2286 000004CF 4F4D4D414E442E434F-
  2286 000004D8 4D0D0A             
  2287 000004DB 21                      PUTBACKMSG:	db 33
  2288 000004DC 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2288 000004E5 736B20776974682025-
  2288 000004EE 3120696E2064726976-
  2288 000004F7 652025320D0A       
  2289 000004FD 21                      PROMPT:		db 33
  2290 000004FE 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2290 00000507 206B657920746F2063-
  2290 00000510 6F6E74696E7565202E-
  2290 00000519 202E202E0D0A       
  2291 0000051F 1C                      ENDBATMES:	db 28
  2292 00000520 0D0A                    		db 0Dh,0Ah
  2293 00000522 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2293 0000052B 206261746368206A6F-
  2293 00000534 622028592F4E293F   
  2294 0000053C 13                      EXECEMES:	db 19
  2295 0000053D 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2295 00000546 65637574652025310D-
  2295 0000054F 0A                 
  2296 00000550 13                      EXEBAD:		db 19
  2297 00000551 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2297 0000055A 4558452066696C650D-
  2297 00000563 0A                 
  2298 00000564 22                      TOOBIG:		db 34
  2299 00000565 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2299 0000056E 6F6F2062696720746F-
  2299 00000577 2066697420696E206D-
  2299 00000580 656D6F72790D0A     
  2300 00000587 16                      NOHANDMES:	db 22
  2301 00000588 0D0A                    		db 0Dh,0Ah
  2302 0000058A 4E6F20667265652066-     		db 'No free file handles'
  2302 00000593 696C652068616E646C-
  2302 0000059C 6573               
  2303 0000059E 1A                      RBADNAM:	db 26
  2304 0000059F 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2304 000005A8 6E64206F722066696C-
  2304 000005B1 65206E616D650D0A   
  2305                                  ACCDENIED:	; 14/01/2023
  2306                                  		; 10/01/2023
  2307                                  ACCDEN:		;db 14
  2308                                  		;db 'Access denied '
  2309                                  		; 19/07/2024 - PCDOS 7.1
  2310 000005B9 0D                      		db 13
  2311 000005BA 416363657373206465-     		db 'Access denied'
  2311 000005C3 6E696564           
  2312 000005C7 19                      BMEMMES:	db 25
  2313 000005C8 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2313 000005D1 616C6C6F636174696F-
  2313 000005DA 6E206572726F72     
  2314 000005E1 26                      HALTMES:	db 38
  2315 000005E2 0D0A                    		db 0Dh,0Ah
  2316 000005E4 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2316 000005ED 616420434F4D4D414E-
  2316 000005F6 442C2073797374656D-
  2316 000005FF 2068616C7465640D0A 
  2317 00000608 21                      FRETMES:	db 33
  2318 00000609 0D0A                    		db 0Dh,0Ah,
  2319 0000060B 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2319 00000614 61727420434F4D4D41-
  2319 0000061D 4E442C206578697469-
  2319 00000626 6E670D0A           
  2320 0000062A 2E                      PATRICIDE:	db 46
  2321 0000062B 0D0A                    		db 0Dh,0Ah
  2322 0000062D 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2322 00000636 2070726F6365737320-
  2322 0000063F 61626F727465642C20-
  2322 00000648 63616E6E6F7420636F-
  2322 00000651 6E74696E7565       
  2323 00000657 0D0A                    		db 0Dh,0Ah
  2324 00000659 02                      NEWLINE:	db 2
  2325 0000065A 0D0A                    		db 0Dh, 0Ah
  2326                                  
  2327                                  ; 10/01/2023
  2328                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2329                                  
  2330 0000065C [400B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2331 0000065E 0100                    		dw 1
  2332 00000660 [FB08]                  		dw PARSMSGPTRS		; parse	error messages
  2333 00000662 0100                    		dw 1
  2334 00000664 [400B]                  		dw EXTMSGPTRS		; critical error messages
  2335 00000666 0100                    		dw 1
  2336 00000668 0000                    		dw 0			; File system error messages
  2337 0000066A 0000                    		dw 0			; are not supported.
  2338 0000066C [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2339 0000066E 0000                    MySeg3:		dw 0			; segment of retriever routine
  2340                                  
  2341                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2342                                  
  2343 00000670 13                      CRMSG0:		db 19
  2344 00000671 57726974652070726F-     		db 'Write protect error'
  2344 0000067A 74656374206572726F-
  2344 00000683 72                 
  2345 00000684 0C                      CRMSG1:		db 12
  2346 00000685 496E76616C69642075-     		db 'Invalid unit'
  2346 0000068E 6E6974             
  2347 00000691 09                      CRMSG2:		db 9
  2348 00000692 4E6F74207265616479      		db 'Not ready'
  2349 0000069B 16                      CRMSG3:		db 22
  2350 0000069C 496E76616C69642064-     		db 'Invalid device request'
  2350 000006A5 657669636520726571-
  2350 000006AE 75657374           
  2351 000006B2 0A                      CRMSG4:		db 10
  2352 000006B3 44617461206572726F-     		db 'Data error'
  2352 000006BC 72                 
  2353 000006BD 21                      CRMSG5:		db 33
  2354 000006BE 496E76616C69642064-     		db 'Invalid device request parameters'
  2354 000006C7 657669636520726571-
  2354 000006D0 756573742070617261-
  2354 000006D9 6D6574657273       
  2355 000006DF 0A                      CRMSG6:		db 10
  2356 000006E0 5365656B206572726F-     		db 'Seek error'
  2356 000006E9 72                 
  2357 000006EA 12                      CRMSG7:		db 18
  2358 000006EB 496E76616C6964206D-     		db 'Invalid media type'
  2358 000006F4 656469612074797065 
  2359 000006FD 10                      CRMSG8:		db 16
  2360 000006FE 536563746F72206E6F-     		db 'Sector not found'
  2360 00000707 7420666F756E64     
  2361 0000070E 1A                      CRMSG9:		db 26
  2362 0000070F 5072696E746572206F-     		db 'Printer out of paper error'
  2362 00000718 7574206F6620706170-
  2362 00000721 6572206572726F72   
  2363 00000729 11                      CRMSG10:	db 17
  2364 0000072A 577269746520666175-     		db 'Write fault error'
  2364 00000733 6C74206572726F72   
  2365 0000073B 10                      CRMSG11:	db 16
  2366 0000073C 52656164206661756C-     		db 'Read fault error'
  2366 00000745 74206572726F72     
  2367 0000074C 0F                      CRMSG12:	db 15
  2368 0000074D 47656E6572616C2066-     		db 'General failure'
  2368 00000756 61696C757265       
  2369 0000075C 11                      CRMSG13:	db 17
  2370 0000075D 53686172696E672076-     		db 'Sharing violation'
  2370 00000766 696F6C6174696F6E   
  2371 0000076E 0E                      CRMSG14:	db 14
  2372 0000076F 4C6F636B2076696F6C-     		db 'Lock violation'
  2372 00000778 6174696F6E         
  2373 0000077D 13                      CRMSG15:	db 19
  2374 0000077E 496E76616C69642064-     		db 'Invalid disk change'
  2374 00000787 69736B206368616E67-
  2374 00000790 65                 
  2375 00000791 0F                      CRMSG16:	db 15
  2376 00000792 46434220756E617661-     		db 'FCB unavailable'
  2376 0000079B 696C61626C65       
  2377 000007A1 19                      CRMSG17:	db 25
  2378 000007A2 53797374656D207265-     		db 'System resource exhausted'
  2378 000007AB 736F75726365206578-
  2378 000007B4 68617573746564     
  2379 000007BB 12                      CRMSG18:	db 18
  2380 000007BC 436F64652070616765-     		db 'Code page mismatch'
  2380 000007C5 206D69736D61746368 
  2381 000007CE 0C                      CRMSG19:	db 12
  2382 000007CF 4F7574206F6620696E-     		db 'Out of input'
  2382 000007D8 707574             
  2383 000007DB 17                      CRMSG20:	db 23
  2384 000007DC 496E73756666696369-     		db 'Insufficient disk space'
  2384 000007E5 656E74206469736B20-
  2384 000007EE 7370616365         
  2385                                  
  2386                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2387                                  
  2388 000007F3 [7006]                  CRITMSGPTRS:	dw CRMSG0
  2389 000007F5 [8406]                  		dw CRMSG1
  2390 000007F7 [9106]                  		dw CRMSG2
  2391 000007F9 [9B06]                  		dw CRMSG3
  2392 000007FB [B206]                  		dw CRMSG4
  2393 000007FD [BD06]                  		dw CRMSG5
  2394 000007FF [DF06]                  		dw CRMSG6
  2395 00000801 [EA06]                  		dw CRMSG7
  2396 00000803 [FD06]                  		dw CRMSG8
  2397 00000805 [0E07]                  		dw CRMSG9
  2398 00000807 [2907]                  		dw CRMSG10
  2399 00000809 [3B07]                  		dw CRMSG11
  2400 0000080B [4C07]                  		dw CRMSG12
  2401 0000080D [5C07]                  		dw CRMSG13
  2402 0000080F [6E07]                  		dw CRMSG14
  2403 00000811 [7D07]                  		dw CRMSG15
  2404 00000813 [9107]                  		dw CRMSG16
  2405 00000815 [A107]                  		dw CRMSG17
  2406 00000817 [BB07]                  		dw CRMSG18
  2407 00000819 [CE07]                  		dw CRMSG19
  2408 0000081B [DB07]                  		dw CRMSG20
  2409                                  
  2410                                  		; 14/01/2023
  2411                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2412                                  
  2413 0000081D 13                      PAERRMSG0:	db 19
  2414 0000081E 546F6F206D616E7920-     		db 'Too many parameters'
  2414 00000827 706172616D65746572-
  2414 00000830 73                 
  2415 00000831 1A                      PAERRMSG1:	db 26
  2416 00000832 526571756972656420-     		db 'Required parameter missing'
  2416 0000083B 706172616D65746572-
  2416 00000844 206D697373696E67   
  2417 0000084C 0E                      PAERRMSG2:	db 14
  2418 0000084D 496E76616C69642073-     		db 'Invalid switch'
  2418 00000856 7769746368         
  2419 0000085B 0F                      PAERRMSG3:	db 15
  2420 0000085C 496E76616C6964206B-     		db 'Invalid keyword'
  2420 00000865 6579776F7264       
  2421 0000086B 01                      PAERRMSG4:	db 1
  2422 0000086C 20                      		db 20h
  2423 0000086D 24                      PAERRMSG5:	db 36
  2424 0000086E 506172616D65746572-     		db 'Parameter value not in allowed range'
  2424 00000877 2076616C7565206E6F-
  2424 00000880 7420696E20616C6C6F-
  2424 00000889 7765642072616E6765 
  2425                                  PAERRMSG6:	; 10/01/2023
  2426 00000892 1B                      PAERRMSG7:	db 27
  2427 00000893 506172616D65746572-     		db 'Parameter value not allowed'
  2427 0000089C 2076616C7565206E6F-
  2427 000008A5 7420616C6C6F776564 
  2428                                  ;PAERRMSG7:	db 27
  2429                                  ;		db 'Parameter value not allowed'
  2430 000008AE 1C                      PAERRMSG8:	db 28
  2431 000008AF 506172616D65746572-     		db 'Parameter format not correct'
  2431 000008B8 20666F726D6174206E-
  2431 000008C1 6F7420636F72726563-
  2431 000008CA 74                 
  2432 000008CB 11                      PAERRMSG9:	db 17
  2433 000008CC 496E76616C69642070-     		db 'Invalid parameter'
  2433 000008D5 6172616D65746572   
  2434 000008DD 1D                      PAERRMSG10:	db 29
  2435 000008DE 496E76616C69642070-     		db 'Invalid parameter combination'
  2435 000008E7 6172616D6574657220-
  2435 000008F0 636F6D62696E617469-
  2435 000008F9 6F6E               
  2436                                  
  2437                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2438                                  
  2439 000008FB [1D08]                  PARSMSGPTRS:	dw PAERRMSG0
  2440 000008FD [3108]                  		dw PAERRMSG1
  2441 000008FF [4C08]                  		dw PAERRMSG2
  2442 00000901 [5B08]                  		dw PAERRMSG3
  2443 00000903 [6B08]                  		dw PAERRMSG4
  2444 00000905 [6D08]                  		dw PAERRMSG5
  2445 00000907 [9208]                  		dw PAERRMSG6
  2446 00000909 [9208]                  		dw PAERRMSG7
  2447 0000090B [AE08]                  		dw PAERRMSG8
  2448 0000090D [CB08]                  		dw PAERRMSG9
  2449 0000090F [DD08]                  		dw PAERRMSG10
  2450                                  ; 21/04/2023
  2451                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2452                                  
  2453 00000911 10                      INVLFUNCT:	db 16
  2454 00000912 496E76616C69642066-     		db 'Invalid function'
  2454 0000091B 756E6374696F6E     
  2455 00000922 0E                      FNOTFOUND:	db 14
  2456 00000923 46696C65206E6F7420-     		db 'File not found'
  2456 0000092C 666F756E64         
  2457 00000931 0E                      PNOTFOUND:	db 14
  2458 00000932 50617468206E6F7420-     		db 'Path not found'
  2458 0000093B 666F756E64         
  2459 00000940 13                      TOOMANYOF:	db 19
  2460 00000941 546F6F206D616E7920-     		db 'Too many open files'
  2460 0000094A 6F70656E2066696C65-
  2460 00000953 73                 
  2461                                  ; 14/01/2023
  2462                                  ;ACCDEN:	; 10/01/2023
  2463                                  ;ACCDENIED:	db 14
  2464                                  ;		db 'Access denied '
  2465 00000954 0E                      INVHANDLE:	db 14
  2466 00000955 496E76616C69642068-     		db 'Invalid handle'
  2466 0000095E 616E646C65         
  2467 00000963 1F                      MEMCBDEST:	db 31
  2468 00000964 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2468 0000096D 6E74726F6C20626C6F-
  2468 00000976 636B73206465737472-
  2468 0000097F 6F796564           
  2469 00000983 13                      INSUFFMEM:	db 19
  2470 00000984 496E73756666696369-     		db 'Insufficient memory'
  2470 0000098D 656E74206D656D6F72-
  2470 00000996 79                 
  2471 00000997 1C                      INVMEMBLA:	db 28
  2472 00000998 496E76616C6964206D-     		db 'Invalid memory block address'
  2472 000009A1 656D6F727920626C6F-
  2472 000009AA 636B20616464726573-
  2472 000009B3 73                 
  2473 000009B4 13                      INVENVIRO:	db 19
  2474 000009B5 496E76616C69642045-     		db 'Invalid Environment'
  2474 000009BE 6E7669726F6E6D656E-
  2474 000009C7 74                 
  2475 000009C8 0E                      INVFORMAT:	db 14
  2476 000009C9 496E76616C69642066-     		db 'Invalid format'
  2476 000009D2 6F726D6174         
  2477 000009D7 1A                      INVFNPARM:	db 26
  2478 000009D8 496E76616C69642066-     		db 'Invalid function parameter'
  2478 000009E1 756E6374696F6E2070-
  2478 000009EA 6172616D65746572   
  2479 000009F2 0C                      INVLDDATA:	db 12
  2480 000009F3 496E76616C69642064-     		db 'Invalid data'
  2480 000009FC 617461             
  2481 000009FF 1B                      INVDRVSPC:	db 27
  2482 00000A00 496E76616C69642064-     		db 'Invalid drive specification'
  2482 00000A09 726976652073706563-
  2482 00000A12 696669636174696F6E 
  2483 00000A1B 23                      ATRCURDIR:	db 35
  2484 00000A1C 417474656D70742074-     		db 'Attempt to remove current directory'
  2484 00000A25 6F2072656D6F766520-
  2484 00000A2E 63757272656E742064-
  2484 00000A37 69726563746F7279   
  2485 00000A3F 0F                      NOTSAMDEV:	db 15
  2486 00000A40 4E6F742073616D6520-     		db 'Not same device'
  2486 00000A49 646576696365       
  2487 00000A4F 0D                      NOMOREFIL:	db 13
  2488 00000A50 4E6F206D6F72652066-     		db 'No more files'
  2488 00000A59 696C6573           
  2489 00000A5D 0B                      FILEXISTS:	db 11
  2490 00000A5E 46696C652065786973-     		db 'File exists'
  2490 00000A67 7473               
  2491 00000A69 1B                      CANTMKDIR:	db 27
  2492 00000A6A 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2492 00000A73 6B6520646972656374-
  2492 00000A7C 6F727920656E747279 
  2493 00000A85 0E                      FAILINT24:	db 14
  2494 00000A86 4661696C206F6E2049-     		db 'Fail on INT 24'
  2494 00000A8F 4E54203234         
  2495 00000A94 15                      TOOMANYRD:	db 21
  2496 00000A95 546F6F206D616E7920-     		db 'Too many redirections'
  2496 00000A9E 726564697265637469-
  2496 00000AA7 6F6E73             
  2497 00000AAA 15                      DUPLREDIR:	db 21
  2498 00000AAB 4475706C6963617465-     		db 'Duplicate redirection'
  2498 00000AB4 207265646972656374-
  2498 00000ABD 696F6E             
  2499 00000AC0 10                      INVPASSWD:	db 16
  2500 00000AC1 496E76616C69642070-     		db 'Invalid password'
  2500 00000ACA 617373776F7264     
  2501 00000AD1 11                      INVLDPARM:	db 17
  2502 00000AD2 496E76616C69642070-     		db 'Invalid parameter'
  2502 00000ADB 6172616D65746572   
  2503 00000AE3 12                      NETDATFAU:	db 18
  2504 00000AE4 4E6574776F726B2064-     		db 'Network data fault'
  2504 00000AED 617461206661756C74 
  2505 00000AF6 21                      FNOSUPNET:	db 33
  2506 00000AF7 46756E6374696F6E20-     		db 'Function not supported by network'
  2506 00000B00 6E6F7420737570706F-
  2506 00000B09 72746564206279206E-
  2506 00000B12 6574776F726B       
  2507 00000B18 27                      RSCNOTINS:	db 39
  2508 00000B19 526571756972656420-     		db 'Required system component not installed'
  2508 00000B22 73797374656D20636F-
  2508 00000B2B 6D706F6E656E74206E-
  2508 00000B34 6F7420696E7374616C-
  2508 00000B3D 6C6564             
  2509                                  
  2510                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2511                                  
  2512 00000B40 [1109]                  EXTMSGPTRS:	dw INVLFUNCT
  2513 00000B42 [2209]                  		dw FNOTFOUND
  2514 00000B44 [3109]                  		dw PNOTFOUND
  2515 00000B46 [4009]                  		dw TOOMANYOF
  2516 00000B48 [B905]                  		dw ACCDENIED
  2517 00000B4A [5409]                  		dw INVHANDLE
  2518 00000B4C [6309]                  		dw MEMCBDEST
  2519 00000B4E [8309]                  		dw INSUFFMEM
  2520 00000B50 [9709]                  		dw INVMEMBLA
  2521 00000B52 [B409]                  		dw INVENVIRO
  2522 00000B54 [C809]                  		dw INVFORMAT
  2523 00000B56 [D709]                  		dw INVFNPARM
  2524 00000B58 [F209]                  		dw INVLDDATA
  2525 00000B5A 0000                    		dw 0
  2526 00000B5C [FF09]                  		dw INVDRVSPC
  2527 00000B5E [1B0A]                  		dw ATRCURDIR
  2528 00000B60 [3F0A]                  		dw NOTSAMDEV
  2529 00000B62 [4F0A]                  		dw NOMOREFIL
  2530 00000B64 [7006]                  		dw CRMSG0
  2531 00000B66 [8406]                  		dw CRMSG1
  2532 00000B68 [9106]                  		dw CRMSG2
  2533 00000B6A [9B06]                  		dw CRMSG3
  2534 00000B6C [B206]                  		dw CRMSG4
  2535 00000B6E [BD06]                  		dw CRMSG5
  2536 00000B70 [DF06]                  		dw CRMSG6
  2537 00000B72 [EA06]                  		dw CRMSG7
  2538 00000B74 [FD06]                  		dw CRMSG8
  2539 00000B76 [0E07]                  		dw CRMSG9
  2540 00000B78 [2907]                  		dw CRMSG10
  2541 00000B7A [3B07]                  		dw CRMSG11
  2542 00000B7C [4C07]                  		dw CRMSG12
  2543 00000B7E [5C07]                  		dw CRMSG13
  2544 00000B80 [6E07]                  		dw CRMSG14
  2545 00000B82 [7D07]                  		dw CRMSG15
  2546 00000B84 [9107]                  		dw CRMSG16
  2547 00000B86 [A107]                  		dw CRMSG17
  2548 00000B88 [BB07]                  		dw CRMSG18
  2549 00000B8A [CE07]                  		dw CRMSG19
  2550 00000B8C [DB07]                  		dw CRMSG20
  2551 00000B8E 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2552 00000BDE [5D0A]                  		dw FILEXISTS
  2553 00000BE0 0000                    		dw 0
  2554 00000BE2 [690A]                  		dw CANTMKDIR
  2555 00000BE4 [850A]                  		dw FAILINT24
  2556 00000BE6 [940A]                  		dw TOOMANYRD
  2557 00000BE8 [AA0A]                  		dw DUPLREDIR
  2558 00000BEA [C00A]                  		dw INVPASSWD
  2559 00000BEC [D10A]                  		dw INVLDPARM
  2560 00000BEE [E30A]                  		dw NETDATFAU
  2561 00000BF0 [F60A]                  		dw FNOSUPNET
  2562 00000BF2 [180B]                  		dw RSCNOTINS
  2563                                  ; ----------------------------------------------------------------------------
  2564                                  	; 17/04/2023
  2565                                  ExtMsgEnd:
  2566                                  
  2567                                  ; 21/04/2023
  2568                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2569                                  
  2570                                  ; ----------------------------------------------------------------------------
  2571                                  
  2572                                  ; 20/04/2023
  2573                                  
  2574 00000BF4 90<rep Ch>              align 16
  2575                                  
  2576                                  ; ----------------------------------------------------------------------------
  2577                                  
  2578                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2579                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2580                                  
  2581                                  ; ----------------------------------------------------------------------------
  2582                                  ; SEGMENT - CODERES
  2583                                  ; ----------------------------------------------------------------------------
  2584                                  
  2585                                  ; 11/01/2023
  2586                                  RCODE_START:	
  2587                                  
  2588                                  ; ----------------------------------------------------------------------------
  2589                                  ;***	EXEC error handling
  2590                                  ;
  2591                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2592                                  ;	We examine the error code and select an appropriate message.
  2593                                  ; --------------------------
  2594                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2595                                  ;	Condense the error scan?
  2596                                  ;	RBADNAM is checked by transient, no need here?
  2597                                  ;	Move below Ext_Exec.
  2598                                  ; ----------------------------------------------------------------------------
  2599                                  
  2600                                  Exec_Err:
  2601                                  ;SR;
  2602                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2603                                  ; in order here
  2604                                  
  2605                                  ;	Bugbug:	can we use byte compares here?
  2606                                  ;	Might be able to use byte msg#s, too.
  2607                                  
  2608                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2609                                  ;	Speed not high priority here.
  2610                                  
  2611                                  ;	Move this to transient.
  2612                                  
  2613                                  	; 10/01/2023
  2614                                  
  2615                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2616 00000C00 BA[9E05]                	mov	dx,RBADNAM
  2617 00000C03 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2618 00000C05 741B                    	je	short GotExecEMes		; bad command
  2619                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2620 00000C07 BA[6405]                	mov	dx,TOOBIG
  2621 00000C0A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2622 00000C0C 7414                    	je	short GotExecEMes		; file not found
  2623                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2624 00000C0E BA[5005]                	mov	dx,EXEBAD
  2625 00000C11 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2626 00000C13 740D                    	je	short GotExecEMes		; bad exe file
  2627                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2628 00000C15 BA[B905]                	mov	dx,ACCDEN
  2629 00000C18 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2630 00000C1A 7406                    	je	short GotExecEMes		; access denied
  2631                                  
  2632                                  Default_Message:
  2633                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2634 00000C1C BA[3C05]                	mov	dx,EXECEMES
  2635                                  						; default message
  2636 00000C1F BE[1B01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2637                                  						; get address of subst block
  2638                                  GotExecEMes:
  2639                                  	;mov	dx,bx				; DX = ptr to msg
  2640 00000C22 E85006                  	call	RPrint ; invoke	RPrint
  2641 00000C25 EB09                    	jmp	short NoExec
  2642                                  
  2643                                  ; ----------------------------------------------------------------------------
  2644                                  ;***	EXEC call
  2645                                  ;
  2646                                  ;	The transient has set up everything for an EXEC system call.
  2647                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2648                                  ;	so that we may be able to recover cleanly upon success.
  2649                                  ;
  2650                                  ;	CS,DS,ES,SS = DATARES seg addr
  2651                                  ; ----------------------------------------------------------------------------
  2652                                  
  2653                                  Ext_Exec:
  2654                                  ;SR;
  2655                                  ; The words put on the stack by the stub will be popped off when we finally
  2656                                  ;jump to LodCom (by LodCom).
  2657                                  
  2658                                  	; 10/01/2023
  2659                                  	;int	21h			; do the exec
  2660                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2661                                  Exec_Ret:
  2662 00000C27 72D7                    	jc	short Exec_Err		; exec failed
  2663                                  
  2664                                  ;	The exec has completed. Retrieve the exit code.
  2665                                  
  2666                                  Exec_Wait:
  2667 00000C29 B44D                    	mov	ah,4Dh
  2668                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2669 00000C2B CD21                    	int	21h			; get the return code
  2670                                  	;mov	[cs:RetCode],ax
  2671                                  	; 11/01/2023
  2672 00000C2D A3[8501]                	mov	[RetCode],ax
  2673                                  
  2674                                  ;	See if we can reload the transient. The external command
  2675                                  ;	may have overwritten part of the transient.
  2676                                  
  2677                                  NoExec:
  2678                                  ;SR;
  2679                                  ; ds = es = ss = DATARES when we jump to LodCom
  2680                                  ;
  2681 00000C30 E97701                  	jmp	LodCom
  2682                                  
  2683                                  ; ----------------------------------------------------------------------------
  2684                                  ;***	Int 23 (ctrl-c) handler
  2685                                  ;
  2686                                  ;	This is the default system INT 23 handler. All processes
  2687                                  ;	(including COMMAND) get it by default. There are some
  2688                                  ;	games that are played: We ignore ^C during most of the
  2689                                  ;	INIT code. This is because we may perform an ALLOC and
  2690                                  ;	diddle the header! Also, if we are prompting for date/time
  2691                                  ;	in the init code, we are to treat ^C as empty responses.
  2692                                  ; ---------------------------
  2693                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2694                                  ; ----------------------------------------------------------------------------
  2695                                  
  2696                                  ;SR;
  2697                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2698                                  ;both these values off the stack now
  2699                                  ;
  2700                                  ;ContC	proc	far
  2701                                  
  2702                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2703                                  
  2704                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2705                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2706                                  ContC:
  2707 00000C33 1F                      	pop	ds			; ds = DATARES
  2708                                  ;	assume	ds:DATARES
  2709                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2710                                  
  2711 00000C34 F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1
  2712                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2713 00000C39 740D                    	jz	short NotAtInit		; no
  2714 00000C3B F606[FF01]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2715                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2716 00000C40 7404                    	jz	short CmdIret		; no, ignore ^C
  2717 00000C42 1F                      	pop	ds			; restore before jumping; M021
  2718                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2719 00000C43 E9E80D                  	jmp	init_contc_specialcase
  2720                                  CmdIret:
  2721                                  ;SR;
  2722                                  ; Restore ds to its previous value
  2723                                  ;
  2724                                  
  2725                                  ;;	mov	ds,[OLdDS]		;
  2726 00000C46 1F                      	pop	ds
  2727 00000C47 CF                      	iret				; yes, ignore the ^C
  2728                                  
  2729                                  NotAtInit:
  2730 00000C48 F606[FF01]04            	test	byte [InitFlag],INITCTRLC ; 4
  2731                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2732 00000C4D 7411                    	jz	short NotInit 		; nope too.
  2733                                  
  2734                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2735                                  ;	to set carry and return to the user sans flags only if the
  2736                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2737                                  
  2738                                  	;cmp	ah,1
  2739                                  	;jb	short CmdIret
  2740                                  	; 19/07/2024
  2741 00000C4F 84E4                    	test	ah,ah
  2742 00000C51 74F3                    	jz	short CmdIret
  2743                                  
  2744 00000C53 80FC0C                  	cmp	ah,12
  2745 00000C56 77EE                    	ja	short CmdIret
  2746                                  
  2747 00000C58 1F                      	pop	ds			;restore ds to old value
  2748 00000C59 83C406                  	add	sp,6			; remove int frame
  2749 00000C5C F9                      	stc
  2750                                  
  2751                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2752 00000C5D CA0200                  	retf	2			; remove those flags...
  2753                                  
  2754                                  NotInit:
  2755                                  
  2756                                  ;*	We have now received a ^C for some process (maybe ourselves
  2757                                  ;	but not at INIT).
  2758                                  ;	
  2759                                  ;	Note that we are running on the user's stack!!! Bad news if
  2760                                  ;	any of the system calls below go and issue another INT
  2761                                  ;	24... Massive stack overflow! Another bad point is that
  2762                                  ;	SavHand will save an already saved handle, thus losing a
  2763                                  ;	possible redirection...
  2764                                  ;	
  2765                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2766                                  ;	The above code will correctly flag the ^C diring the
  2767                                  ;	message output and prompting while ignoring the ^C the rest
  2768                                  ;	of the time.
  2769                                  ;	
  2770                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2771                                  ;	file, we ask if he wants to terminate it. If he does, then
  2772                                  ;	we turn off all internal flags and let the DOS abort.
  2773                                  
  2774 00000C60 800E[FF01]04            	or	byte [InitFlag],INITCTRLC ; 4
  2775                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2776 00000C65 FB                      	sti
  2777                                  
  2778                                  ;	push	cs			; el yucko! change the user's ds!!
  2779                                  ;	pop	ds
  2780                                  
  2781                                  ;	assume	ds:RESGROUP
  2782                                  
  2783 00000C66 58                      	pop	ax			; discard the old ds value
  2784                                  
  2785 00000C67 A1[8E01]                	mov	ax,[SingleCom]
  2786 00000C6A 09C0                    	or	ax,ax
  2787 00000C6C 7506                    	jnz	short NoReset
  2788 00000C6E 50                      	push	ax
  2789 00000C6F B40D                    	mov	ah,DISK_RESET ; 0Dh
  2790 00000C71 CD21                    	int	21h			; reset disks in case files were open
  2791 00000C73 58                      	pop	ax
  2792                                  
  2793                                  NoReset:
  2794                                  
  2795                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2796                                  ;	walk the entire active list and free each segment. Here,
  2797                                  ;	we just free the single batch segment.
  2798                                  
  2799 00000C74 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2800 00000C7A 7451                    	jz	short ContCTerm
  2801 00000C7C 09C0                    	or	ax,ax
  2802 00000C7E 754D                    	jnz	short ContCTerm
  2803 00000C80 E88402                  	call	SavHand
  2804 00000C83 E89203                  	call	AskEnd			; ask if user wants to end batch
  2805                                  
  2806                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2807                                  
  2808 00000C86 733F                    	jnc	short ContBatch
  2809 00000C88 8A0E[8801]              	mov	cl,[EchoFlag]		; get current echo flag
  2810 00000C8C 53                      	push	bx
  2811                                  
  2812                                  ClearBatch:
  2813 00000C8D 8E06[3401]              	mov	es,[Batch]		; get batch segment
  2814                                  	;mov	di,20h
  2815                                  	; 06/06/2023 (BugFix)
  2816 00000C91 BF2000                  	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
  2817                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2818                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2819 00000C94 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2820                                  	; MSDOS 3.3 ([ES:4])
  2821                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2822                                  	;
  2823                                  	; 19/07/2024
  2824                                  	;cmp	bx,0			; is a FOR in progress
  2825                                  	;je	short No_Bat_For	; no - don't deallocate
  2826 00000C99 85DB                    	test	bx,bx
  2827 00000C9B 7408                    	jz	short No_Bat_For
  2828                                  
  2829 00000C9D 06                      	push	es			;
  2830 00000C9E 8EC3                    	mov	es,bx			; yes - free it up...
  2831 00000CA0 B449                    	mov	ah,49h
  2832                                  	;mov	ah,DEALLOC ; 49h	;
  2833 00000CA2 CD21                    	int	21h			;
  2834 00000CA4 07                      	pop	es			; restore to batch segment
  2835                                  
  2836                                  No_Bat_For:
  2837                                  	;mov	cl,[es:1]
  2838 00000CA5 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2839                                  	;mov	bx,[es:3]
  2840 00000CAA 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2841 00000CAF B449                    	mov	ah,49h
  2842                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2843 00000CB1 CD21                    	int	21h
  2844 00000CB3 891E[3401]              	mov	[Batch],bx		; get ready to deallocate next batch
  2845 00000CB7 FF0E[9701]              	dec	word [Nest]		; is there another batch file?
  2846 00000CBB 75D0                    	jnz	short ClearBatch	; keep going until no batch file
  2847                                  
  2848                                  ;	We are terminating a batch file; restore the echo status
  2849                                  
  2850                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2851 00000CBD 5B                      	pop	bx
  2852 00000CBE 880E[8801]              	mov	[EchoFlag],cl		; reset echo status
  2853                                  	; 29/05/2018
  2854 00000CC2 C606[0002]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2855                                  
  2856                                  ContBatch:
  2857 00000CC7 E8A805                  	call	crlf			; print out crlf before returning
  2858 00000CCA E86302                  	call	RestHand
  2859                                  
  2860                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2861                                  
  2862                                  ContCTerm:
  2863 00000CCD 31C0                    	xor	ax,ax			; indicate no read
  2864 00000CCF 89C5                    	mov	bp,ax
  2865                                  
  2866                                  ;	The following resetting of the state flags is good for the
  2867                                  ;	generalized batch processing.
  2868                                  
  2869 00000CD1 A2[9301]                	mov	[IfFlag],al		; turn off iffing
  2870 00000CD4 A2[9401]                	mov	[ForFlag],al		; turn off for processing
  2871 00000CD7 E81C00                  	call	ResPipeOff
  2872 00000CDA 3906[8E01]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2873 00000CDE 7406                    	jz	short NoSetSing
  2874 00000CE0 C706[8E01]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2875                                  					;  pipe, batch, for
  2876                                  NoSetSing:
  2877                                  
  2878                                  ;	If we are doing an internal command, go through the reload process.
  2879                                  ;	If we are doing an external, let DOS abort the process.
  2880                                  ;	In both cases, we are now done with the ^C processing.
  2881                                  
  2882 00000CE6 8026[FF01]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2883 00000CEB 3806[8401]              	cmp	[ExtCom],al
  2884 00000CEF 7503                    	jnz	short DoDAb		; internal ^c
  2885 00000CF1 E94501                  	jmp	LodCom1
  2886                                  DoDAb:
  2887 00000CF4 F9                      	stc				; tell dos to abort
  2888                                  
  2889                                  ;SR;
  2890                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2891                                  ;by setting carry and leaving flags on the stack
  2892                                  
  2893 00000CF5 CB                      	retf				; Leave flags on stack
  2894                                  
  2895                                  ;ContC	endp
  2896                                  
  2897                                  ;SR;
  2898                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2899                                  ;both have ds = DATARES
  2900                                  
  2901                                  	; 11/01/2023
  2902                                  ResPipeOff:
  2903 00000CF6 50                      	push	ax
  2904 00000CF7 31C0                    	xor	ax,ax
  2905                                  	;xchg	al,[cs:PIPEFLAG]
  2906 00000CF9 8606[0002]              	xchg	al,[PipeFlag]
  2907 00000CFD 08C0                    	or	al,al
  2908 00000CFF 7404                    	jz	short NoPipePop
  2909                                  	;shr	byte [cs:ECHOFLAG],1
  2910 00000D01 D02E[8801]              	shr	byte [EchoFlag],1
  2911                                  NoPipePop:
  2912 00000D05 58                      	pop	ax
  2913 00000D06 C3                      	retn
  2914                                  
  2915                                  ;CODERES ends
  2916                                  
  2917                                  ;=============================================================================
  2918                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2919                                  ;=============================================================================
  2920                                  ; 21/09/2018 - Retro DOS v3.0
  2921                                  
  2922                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2923                                  ;	name	COMMAND2
  2924                                  
  2925                                  ;/*
  2926                                  ; *                      Microsoft Confidential
  2927                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2928                                  ; *                      All Rights Reserved.
  2929                                  ; */
  2930                                  
  2931                                  ;
  2932                                  ;	Revision History
  2933                                  ;	================
  2934                                  ;
  2935                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2936                                  ;			reserve memory by changing int 12h and then give it
  2937                                  ;			back to DOS by changing arenas in autoexec.bat.
  2938                                  ;			This makes command.com reload transient and this
  2939                                  ;			cannot be done at this stage.
  2940                                  ;
  2941                                  
  2942                                  ;CODERES segment public byte
  2943                                  
  2944                                  ;*	If we cannot allocate enough memory for the transient or there
  2945                                  ;	was some other allocation error, we display a message and
  2946                                  ;	then die.
  2947                                  
  2948                                  ;SR;
  2949                                  ; We will have to make sure that at this entry point and at FatalC, 
  2950                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2951                                  ;and so we should be able to do this
  2952                                  
  2953                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2954                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2955                                  
  2956                                  	;assume	ds:DATARES
  2957                                  BadMemErr:
  2958 00000D07 BA[C705]                	mov	dx,BMEMMES			; DX = ptr to msg
  2959                                  FatalC:
  2960                                  	; 12/01/2023
  2961                                  ;;	push	cs
  2962                                  ;;	pop	ds
  2963                                  ;;	assume	ds:ResGroup
  2964                                  ;	invoke	RPrint
  2965                                  
  2966                                  	; 12/01/2023
  2967                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2968 00000D0A E86805                  	call	RPrint
  2969                                  
  2970                                  	; MSDOS 3.3
  2971                                  	;call	RDISPMSG
  2972                                  
  2973                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2974                                  ;	we can't do anything else!
  2975                                  
  2976 00000D0D 803E[8D01]00            	cmp	byte [PermCom],0
  2977 00000D12 7410                    	je	short FatalRet
  2978                                  
  2979                                  ;	We are a permanent command. If we are in the process of the
  2980                                  ;	magic interrupt (Singlecom) then exit too.
  2981                                  
  2982 00000D14 833E[8E01]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2983 00000D19 7509                    	jne	short FatalRet			; must take int_2e exit
  2984                                  
  2985                                  ;	Permanent command. We can't do ANYthing except halt.
  2986                                  
  2987 00000D1B BA[E105]                	mov	dx,HALTMES			; DX = ptr to msg
  2988                                  	;invoke	RPrint
  2989                                  	; 12/01/2023	
  2990                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2991 00000D1E E85405                  	call	RPrint	
  2992                                  	; MSDOS 3.3
  2993                                  	;call	RDISPMSG
  2994 00000D21 FB                      	sti
  2995                                  Stall:
  2996 00000D22 EBFE                    	jmp	short Stall			; crash the system nicely
  2997                                  
  2998                                  FatalRet:
  2999 00000D24 BA[0806]                	mov	dx,FRETMES			; DX = ptr to msg
  3000                                  	;call	RDISPMSG
  3001                                  	; 12/01/2023	
  3002 00000D27 E84B05                  	call	RPrint	
  3003                                  FatalRet2:
  3004 00000D2A 803E[8D01]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  3005 00000D2F 7517                    	jne	short Ret_2e			; must be int_2e
  3006                                  
  3007                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3008                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3009                                  ;	case we decide to do that.)
  3010                                  
  3011 00000D31 A1[2901]                	mov	ax,[Parent]
  3012                                  	;mov	[16h],ax
  3013 00000D34 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3014 00000D37 A1[2B01]                	mov	ax,[OldTerm]
  3015                                  	;mov	[0Ah],ax
  3016 00000D3A A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3017 00000D3D A1[2D01]                	mov	ax,[OldTerm+2]
  3018                                  	;mov	[0Ch],ax
  3019 00000D40 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3020 00000D43 B8004C                  	mov	ax,4C00h
  3021                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3022 00000D46 CD21                    	int	21h
  3023                                  Ret_2e:
  3024                                  ;SR;
  3025                                  ; We will ensure that ds = DATARES for all entries to this place
  3026                                  ;
  3027                                  
  3028                                  ;;	push	cs
  3029                                  ;;	pop	ds
  3030                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3031                                    	
  3032                                  ;	assume	ds:DATARES
  3033                                  
  3034                                  	;PUSH	CS
  3035                                  	;POP	DS
  3036                                  
  3037 00000D48 C706[8E01]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3038 00000D4E 8E06[4503]              	mov	es,[Res_Tpa]
  3039                                  	;mov	ah,49h	; 12/01/2023
  3040 00000D52 B449                    	mov	ah,DEALLOC
  3041 00000D54 CD21                    	int	21h			; free up space used by transient
  3042 00000D56 8B1E[2701]              	mov	bx,[Save_Pdb]
  3043 00000D5A B450                    	mov	ah,50h
  3044                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3045 00000D5C CD21                    	int	21h			; current process is user
  3046 00000D5E A1[8501]                	mov	ax,[RetCode]
  3047 00000D61 803E[8401]00            	cmp	byte [ExtCom],0
  3048 00000D66 7502                    	jne	short GotECode
  3049 00000D68 31C0                    	xor	ax,ax			; internals always return 0
  3050                                  GotECode:
  3051 00000D6A C606[8401]01            	mov	byte [ExtCom],1		; force external
  3052                                  
  3053                                  ;SR; This is actually returning to the caller. However, the old code had
  3054                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3055                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3056                                  
  3057                                  	; 12/01/2023
  3058 00000D6F FF2E[2301]              	jmp	far [Int_2e_Ret]	; "iret"
  3059                                  
  3060                                  ;***	Int_2e, magic command executer
  3061                                  
  3062                                  Int_2e:
  3063                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3064                                  ;SR;
  3065                                  ;We are going to come here from the stub with the old ds and DATARES value
  3066                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3067                                  
  3068                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3069                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3070                                  
  3071 00000D73 1F                      	pop	ds			; ds = DATARES
  3072                                  	;assume	ds:DATARES
  3073 00000D74 58                      	pop	ax
  3074                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3075                                  
  3076                                  	;pop	word [cs:Int_2e_Ret]
  3077                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3078                                  	;pop	ax			; chuck flags
  3079 00000D75 8F06[2301]              	pop	word [Int_2e_Ret]
  3080 00000D79 8F06[2501]              	pop	word [Int_2e_Ret+2]
  3081                                  	
  3082 00000D7D 83C402                  	add	sp,2
  3083                                  
  3084                                  ;;	push	cs
  3085                                  ;;	pop	es
  3086                                  
  3087 00000D80 1E                      	push	ds
  3088 00000D81 07                      	pop	es			; es = DATARES
  3089                                  ;	;mov	ds,OldDS
  3090 00000D82 8ED8                    	mov	ds,ax
  3091                                  	;assume	ds:nothing		; ds = old value
  3092                                  
  3093 00000D84 BF8000                  	mov	di,80h
  3094 00000D87 B94000                  	mov	cx,64
  3095                                  ;	Bugbug:	cld
  3096 00000D8A F3A5                    	rep	movsw
  3097 00000D8C B451                    	mov	ah,51h
  3098                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3099 00000D8E CD21                    	int	21h			; get user's header
  3100                                  	; 12/01/2023
  3101 00000D90 26891E[2701]            	mov	[es:Save_Pdb],bx
  3102                                  	;mov	[cs:Save_Pdb],bx
  3103 00000D95 B450                    	mov	ah,50h
  3104                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3105                                  
  3106                                  ;;	mov	bx,cs
  3107                                  ;SR;
  3108                                  ;Set ds = DATARES because BadMemErr expects this
  3109                                  
  3110                                  	; 12/01/2023
  3111 00000D97 06                      	push	es
  3112 00000D98 1F                      	pop	ds
  3113                                  	;assume	ds:DATARES
  3114                                  
  3115 00000D99 8CDB                    	mov	bx,ds			; es = our PSP now
  3116                                  	;mov	bx,cs
  3117                                  
  3118 00000D9B CD21                    	int	21h			; current process is me
  3119                                  	;mov	word [cs:SingleCom],81h
  3120                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3121                                  	; 12/01/2023
  3122 00000D9D C706[8E01]8100          	mov	word [SingleCom],81h
  3123 00000DA3 C606[8401]01            	mov	byte [ExtCom],1		; make sure this case forced
  3124                                  
  3125                                  ;SR;
  3126                                  ;We can enter LodCom directly after a command shell is terminated or we
  3127                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3128                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3129                                  ;be properly set. To fake this, we push dummy values here.
  3130                                  
  3131                                  	; 12/01/2023
  3132 00000DA8 1E                      	push	ds			; old value of ds
  3133 00000DA9 1E                      	push	ds			; data seg value, ds = DATARES
  3134                                  LodCom: 				; termination handler
  3135 00000DAA 1F                      	pop	ds			; ds = DATARES
  3136                                  	;assume	ds:DATARES
  3137 00000DAB 83C402                  	add	sp,2
  3138                                  ;	;pop	OldDS			; store old ds
  3139                                  	;cmp	ExtCom,0
  3140 00000DAE 803E[8401]00            	cmp	byte [ExtCom],0
  3141                                  	;cmp	byte [cs:ExtCom],0
  3142                                  	;jne	short @f	 	; internal cmd - memory allocated
  3143                                  	; 16/04/2023
  3144 00000DB3 7503                    	jne	short LodCom0 ; 24/09/2018
  3145 00000DB5 E98100                  	jmp	LodCom1
  3146                                  	;je	short LodCom1 ; 25/09/2018	
  3147                                  ;@@:
  3148                                  LodCom0: ; 24/09/2018
  3149 00000DB8 BBFFFF                  	mov	bx,0FFFFh
  3150 00000DBB B448                    	mov	ah,48h	; 12/01/2023
  3151                                  	;mov	ah,ALLOC ; 48h	
  3152 00000DBD CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3153                                  				; BX = number of 16-byte paragraphs desired
  3154 00000DBF E80A00                  	call	SetSize
  3155 00000DC2 83C020                  	add	ax,20h
  3156 00000DC5 39C3                    	cmp	bx,ax
  3157 00000DC7 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3158                                  BadMemErrJ:
  3159 00000DC9 E93BFF                  	jmp	BadMemErr		; not enough memory
  3160                                  
  3161                                  ;***	SetSize - get transient size in paragraphs
  3162                                  
  3163                                  SetSize:
  3164                                  	; 12/01/2023
  3165                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3166                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3167 00000DCC B87E95                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3168 00000DCF B104                    	mov	cl,4
  3169 00000DD1 D3E8                    	shr	ax,cl
  3170 00000DD3 C3                      	retn
  3171                                  
  3172                                  MemOk:
  3173                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3174                                  
  3175 00000DD4 B448                    	mov	ah,48h
  3176                                  	;mov	ah,ALLOC  ; 48h
  3177 00000DD6 CD21                    	int	21h
  3178 00000DD8 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3179                                  	;mov	byte [cs:ExtCom],0
  3180                                  	;mov	[cs:Res_Tpa],ax
  3181                                  	; 12/01/2023
  3182 00000DDA C606[8401]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3183 00000DDF A3[4503]                	mov	[Res_Tpa],ax		; save current tpa segment
  3184                                  
  3185 00000DE2 2500F0                  	and	ax,0F000h
  3186 00000DE5 050010                  	add	ax,1000h		; round up to next 64k boundary
  3187 00000DE8 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3188                                  
  3189                                  ;	Make sure that new boundary is within allocated range
  3190                                  
  3191                                  	;mov	dx,[cs:Res_Tpa]
  3192                                  	; 12/01/2023
  3193 00000DEA 8B16[4503]              	mov	dx,[Res_Tpa]
  3194 00000DEE 01DA                    	add	dx,bx			; compute maximum address
  3195 00000DF0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3196 00000DF2 7608                    	jbe	short Bad_Tpa
  3197                                  
  3198                                  ;	Must have 64K of usable space.
  3199                                  
  3200 00000DF4 29C2                    	sub	dx,ax			; compute the usable space
  3201 00000DF6 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3202 00000DFA 7303                    	jae	short LTpaSet
  3203                                  Bad_Tpa:
  3204                                  	;mov	ax,[cs:Res_Tpa]
  3205                                  	; 12/01/2023
  3206 00000DFC A1[4503]                	mov	ax,[Res_Tpa]
  3207                                  LTpaSet:
  3208                                  	;mov	[cs:LTPA],ax
  3209                                  	;mov	ax,[cs:Res_Tpa]
  3210                                  	; 12/01/2023
  3211 00000DFF A3[3903]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3212 00000E02 A1[4503]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3213 00000E05 01C3                    	add	bx,ax
  3214                                  	;mov	[cs:MemSiz],bx
  3215 00000E07 891E[8001]              	mov	[MemSiz],bx
  3216 00000E0B E8BEFF                  	call	SetSize
  3217 00000E0E 29C3                    	sub	bx,ax
  3218                                  
  3219                                  	; MSDOS 6.0
  3220                                  
  3221                                  ;M038; Start of changes
  3222                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3223                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3224                                  ;running a program that changes arenas. This changes the largest block that
  3225                                  ;command.com gets and so changes the transient segment. So, command.com does
  3226                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3227                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3228                                  ;reload fails, hanging the system. To get around this we just copy the
  3229                                  ;transient from the previous address to the new address(if changed) and
  3230                                  ;then let command.com do the checksum. So, if the transient area is not
  3231                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3232                                  ;is not really corrupted and so this should work.
  3233                                  
  3234                                  	; 12/01/2023
  3235                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3236                                  
  3237 00000E10 3B1E[7A01]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3238 00000E14 7423                    	je	short LodCom1		; yes, dont copy
  3239                                  
  3240                                  ;Check if the new segment is above or below the current move. If the new
  3241                                  ;segment is above (i.e new block is larger than previous block), then we
  3242                                  ;have to move in the reverse direction
  3243                                  
  3244                                  	;mov	cx,98C5h
  3245 00000E16 B96F95                  	mov	cx,TRANSPACEEND		; cx = length to move
  3246 00000E19 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3247 00000E1B 31F6                    	xor	si,si			; normal move
  3248 00000E1D 89F7                    	mov	di,si
  3249 00000E1F FC                      	cld
  3250 00000E20 EB06                    	jmp	short copy_trans
  3251                                  mov_down:
  3252 00000E22 89CE                    	mov	si,cx			; reverse move, start from end
  3253 00000E24 4E                      	dec	si
  3254 00000E25 89F7                    	mov	di,si
  3255 00000E27 FD                      	std
  3256                                  copy_trans:
  3257 00000E28 1E                      	push	ds
  3258 00000E29 06                      	push	es
  3259 00000E2A 8EC3                    	mov	es,bx			; dest segment
  3260 00000E2C 8E1E[7A01]              	mov	ds,[TrnSeg]		; source segment
  3261                                  	;assume	ds:nothing
  3262                                  
  3263 00000E30 F3A4                    	rep	movsb			; copy transient
  3264 00000E32 FC                      	cld
  3265 00000E33 07                      	pop	es
  3266 00000E34 1F                      	pop	ds
  3267                                  	;assume	ds:DATARES
  3268                                  
  3269                                  ;M038; End of changes
  3270                                  
  3271                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3272                                  	; 12/01/2023
  3273 00000E35 891E[7A01]              	mov	[TrnSeg],bx
  3274                                  
  3275                                  LodCom1:
  3276                                  ;;	mov	ax,cs
  3277                                  ;;	mov	ss,ax
  3278                                  ;SR; At this point ds = DATARES which is where the stack is located
  3279                                  
  3280                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3281                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3282 00000E39 8CD8                    	mov	ax,ds
  3283 00000E3B 8ED0                    	mov	ss,ax
  3284                                  	;assume	ss:DATARES
  3285                                  	;;mov	sp,offset DATARES:RStack
  3286                                  	;mov	sp,53Eh
  3287 00000E3D BC[1E04]                	mov	sp,RStack
  3288                                  
  3289                                  ;;	mov	ds,ax
  3290                                  
  3291                                  	;assume	ds:DATARES
  3292                                  	
  3293                                  	; MSDOS 3.3
  3294                                  	;mov	ax,cs
  3295                                  	;mov	ss,ax
  3296                                  	;mov	sp,RSTACK
  3297                                  	;mov	ds,ax
  3298                                  
  3299 00000E40 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3300 00000E43 31ED                    	xor	bp,bp			; flag command ok
  3301 00000E45 B8FFFF                  	mov	ax,-1
  3302 00000E48 8706[9001]              	xchg	ax,[VerVal]
  3303 00000E4C 83F8FF                  	cmp	ax,-1
  3304 00000E4F 7404                    	je	short NoSetVer
  3305 00000E51 B42E                    	mov	ah,2Eh
  3306                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3307 00000E53 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3308                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3309                                  NoSetVer:
  3310 00000E55 833E[8E01]FF            	cmp	word [SingleCom],-1
  3311 00000E5A 7503                    	jne	short NoSng
  3312 00000E5C E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3313                                  NoSng:
  3314 00000E5F E87201                  	call	ChkSum			; check the transient
  3315                                  	;cmp	dx,[Sum]
  3316                                  	;je	short HavCom		; transient ok
  3317                                  	; 12/01/2023
  3318 00000E62 7412                    	jz	short HavCom
  3319                                  Bogus_Com:
  3320 00000E64 C606[3301]01            	mov	byte [Loading],1	; flag DskErr routine
  3321 00000E69 E81E01                  	call	LoadCom
  3322                                  ChkSame:
  3323 00000E6C E86501                  	call	ChkSum
  3324                                  	;cmp	dx,[Sum]
  3325                                  	;je	short HavCom		; same command
  3326                                  	; 12/01/2023
  3327 00000E6F 7405                    	jz	short HavCom
  3328                                  Also_Bogus:
  3329 00000E71 E85801                  	call	WrongCom
  3330 00000E74 EBF6                    	jmp	short ChkSame
  3331                                  
  3332                                  	; 12/01/2023
  3333                                  ;HavCom:
  3334                                  ;	; 25/09/2018
  3335                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3336                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3337                                  ;			; Return: AL = FFh unsupported subfunction
  3338                                  ;			; DL = current switch character
  3339                                  ;	mov     [RSWITCHAR],dl
  3340                                  ;	cmp     dl,'/'
  3341                                  ;	jnz     short USESLASH
  3342                                  ;	;mov	cl,'\'
  3343                                  ;	;mov	[RDIRCHAR],cl
  3344                                  ;	mov	byte [RDIRCHAR],'\'
  3345                                  ;USESLASH:
  3346                                  
  3347                                  HavCom:
  3348                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3349 00000E76 C606[3301]00            	mov	byte [Loading],0		; flag to DskErr
  3350                                  	;;mov	si,offset DATARES:TranVars
  3351                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3352 00000E7B BE[3503]                	mov	si,TranVars
  3353                                  	;;mov	di,offset TRANGROUP:HeadCall
  3354                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3355 00000E7E BF[A38A]                	mov	di,HEADCALL
  3356 00000E81 8E06[7A01]              	mov	es,[TrnSeg]
  3357 00000E85 FC                      	cld
  3358                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3359 00000E86 B9[4703]                	mov	cx,TranVarEnd
  3360 00000E89 29F1                    	sub	cx,si
  3361 00000E8B F3A4                    	rep	movsb			; transfer info to transient
  3362 00000E8D A1[8001]                	mov	ax,[MemSiz]
  3363 00000E90 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3364                                  
  3365                                  ;***	TJmp - jump-off to transient
  3366                                  ;
  3367                                  ;	Public label so debugger can find this spot.
  3368                                  
  3369                                  TJmp:	; 12/01/2023
  3370 00000E93 FF2E[7801]              	jmp	far [Trans]		; jmp dword ptr Trans
  3371                                  
  3372                                  ;***	TRemCheck - far version of RemCheck for transient
  3373                                  
  3374                                  TRemCheck:
  3375                                  	; 12/01/2023
  3376 00000E97 1F                      	pop	ds			; ds = DATARES
  3377 00000E98 83C402                  	add	sp,2			; discard old value of ds
  3378                                  
  3379 00000E9B E80100                  	call	RemCheck
  3380 00000E9E CB                      	retf
  3381                                  
  3382                                  ;***	RemCheck
  3383                                  ;
  3384                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3385                                  ;
  3386                                  ;	EXIT	ZR set if removeable media
  3387                                  ;		ZR clear if fixed media
  3388                                  ;
  3389                                  ;	USED	none
  3390                                  
  3391                                  	; 12/01/2023
  3392                                  RemCheck:
  3393 00000E9F 50                      	push	ax
  3394 00000EA0 53                      	push	bx
  3395 00000EA1 89C3                    	mov	bx,ax
  3396 00000EA3 B80844                  	mov	ax,4408h
  3397                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3398 00000EA6 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3399 00000EA8 7304                    	jnc	short rcCont		
  3400                                  
  3401                                  ;	If an error occurred, assume the media is non-removable.
  3402                                  ;	AX contains the non-zero error code from the int 21, so
  3403                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3404                                  ;	appear to be non-removable.				
  3405                                  					
  3406 00000EAA 09C0                    	or	ax,ax			
  3407 00000EAC EB05                    	jmp	short ResRegs
  3408                                  rcCont:
  3409 00000EAE 83E001                  	and	ax,1
  3410 00000EB1 F7D0                    	not	ax
  3411                                  ResRegs:
  3412 00000EB3 5B                      	pop	bx
  3413 00000EB4 58                      	pop	ax
  3414 00000EB5 C3                      	retn
  3415                                  
  3416                                  ;***	THeadFix
  3417                                  ;
  3418                                  ;	Far version of HeadFix, called from transient.
  3419                                  
  3420                                  THeadFix:
  3421                                  	; 12/01/2023
  3422 00000EB6 1F                      	pop	ds			; ds = DATARES
  3423 00000EB7 83C402                  	add	sp,2			; discard old ds value on stack
  3424                                  
  3425 00000EBA E80100                  	call	HeadFix
  3426 00000EBD CB                      	retf
  3427                                  
  3428                                  ;***	HeadFix
  3429                                  
  3430                                  	; 12/01/2023
  3431                                  HeadFix:
  3432 00000EBE E83101                  	call	SetVect			; set vectors to our values
  3433                                  
  3434                                  ;	Clean up header
  3435                                  
  3436                                  ;	Bugbug:	optimize:
  3437                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3438                                  
  3439 00000EC1 31DB                    	xor	bx,bx			; BX = handle = 0
  3440 00000EC3 8B0E[8A01]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3441                                  	;mov	dx,[18h] 
  3442 00000EC7 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3443 00000ECB 38D1                    	cmp	cl,dl
  3444 00000ECD 7408                    	je	short Chk1		; stdin matches
  3445 00000ECF B43E                    	mov	ah,3Eh
  3446                                  	;mov	ah,CLOSE  ; 3Eh
  3447 00000ED1 CD21                    	int	21h			; close stdin
  3448                                  	;mov	[18h],cl
  3449 00000ED3 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3450                                  Chk1:
  3451 00000ED7 43                      	inc	bx			; BX = handle = 1
  3452 00000ED8 38F5                    	cmp	ch,dh			
  3453 00000EDA 7408                    	je	short ChkOtherHand	; stdout matches
  3454 00000EDC B43E                    	mov	ah,3Eh
  3455                                  	;mov	ah,CLOSE
  3456 00000EDE CD21                    	int	21h			; close stdout
  3457                                  	;mov	[19h],ch
  3458 00000EE0 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3459                                  ChkOtherHand:
  3460 00000EE4 83C304                  	add	bx,4			; skip handles 2,3,4
  3461 00000EE7 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3462                                  					; (handles 0-4 already done)
  3463                                  CloseLoop:
  3464 00000EEA B43E                    	mov	ah,3Eh
  3465                                  	;mov	ah,CLOSE ; 3Eh
  3466 00000EEC CD21                    	int	21h			; close each handle
  3467 00000EEE 43                      	inc	bx			; BX = next handle
  3468 00000EEF E2F9                    	loop	CloseLoop
  3469                                  
  3470                                  	; MSDOS 6.0
  3471                                  ;	Bugbug:	since this is for transient code, move it there
  3472                                  	
  3473                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3474                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3475                                  
  3476                                  ;	M012: remove this CS -> DS. Must've been missed during
  3477                                  ;	purification.
  3478                                  ;;	push	ds			; save data segment
  3479                                  ;;	push	cs			; get local segment into DS
  3480                                  ;;	pop	ds			;
  3481 00000EF1 803E[AD01]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3482 00000EF6 750E                    	jne	short Append_Fix_End	; no - just exit
  3483 00000EF8 B807B7                  	mov	ax,0B707h
  3484                                  	;mov	ax,AppendSetState	; set the state of Append
  3485 00000EFB 8B1E[AB01]              	mov	bx,[Append_State] 	; back to the original state
  3486 00000EFF CD2F                    	int	2Fh			;
  3487 00000F01 C606[AD01]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3488                                  Append_Fix_End: 			;
  3489                                  ;;	pop	ds			; get data segment back
  3490 00000F06 C3                      	retn
  3491                                  
  3492                                  	; MSDOS 3.3
  3493                                  	;retn
  3494                                  
  3495                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3496                                  ;
  3497                                  ;	ENTRY	nothing
  3498                                  ;
  3499                                  ;	EXIT	nothing
  3500                                  ;
  3501                                  ;	USED	flags
  3502                                  ;
  3503                                  ;	EFFECTS
  3504                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3505                                  ;	  current program's stdin,stdout set to our stderr
  3506                                  ;
  3507                                  
  3508                                  ;SR;
  3509                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3510                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3511                                  
  3512                                  SavHand:
  3513                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3514                                  
  3515                                  	; 12/01/2023
  3516                                  	;push	ds ; MSDOS 3.3
  3517                                  
  3518 00000F07 53                      	push	bx			;preserve registers
  3519 00000F08 50                      	push	ax
  3520                                  	; 12/01/2023
  3521 00000F09 06                      	push	es
  3522 00000F0A 1E                      	push	ds			; save DATARES value
  3523                                  
  3524 00000F0B B451                    	mov	ah,51h
  3525                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3526 00000F0D CD21                    	int	21h			; BX = user's header seg addr
  3527 00000F0F 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3528                                  	;lds	bx,[34h]	
  3529 00000F11 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3530 00000F15 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3531                                  	; 12/01/2023
  3532 00000F17 07                      	pop	es			; es = DATARES
  3533 00000F18 06                      	push	es			; save it back on stack
  3534 00000F19 26A3[3101]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3535                                  	;mov	[cs:HANDLE01],ax
  3536                                  
  3537                                  ;SR;
  3538                                  ; Use es to address Handle01 & our JFN_Table
  3539                                  
  3540                                  	; 12/01/2023
  3541                                  	;mov	al,[es:1Ah]
  3542 00000F1D 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3543                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3544 00000F21 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3545 00000F23 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3546                                  	; 12/01/2023
  3547 00000F25 1F                      	pop	ds			; restore registers
  3548 00000F26 07                      	pop	es
  3549 00000F27 58                      	pop	ax
  3550 00000F28 5B                      	pop	bx
  3551                                  	;pop	ds ; MSDOS 3.3
  3552 00000F29 C3                      	retn
  3553                                  
  3554                                  	;assume	ds:DATARES
  3555                                  GetComDsk2:
  3556 00000F2A E81F00                  	call	GetComDsk
  3557 00000F2D E909FF                  	jmp	LodCom1			; memory already allocated
  3558                                  
  3559                                  RestHand:
  3560 00000F30 1E                      	push	ds
  3561 00000F31 53                      	push	bx			; restore stdin, stdout to user
  3562 00000F32 50                      	push	ax
  3563                                  	; 12/01/2023
  3564 00000F33 B451                    	mov	ah,51h
  3565                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3566 00000F35 CD21                    	int	21h			; point to user's header
  3567 00000F37 A1[3101]                	mov	ax,[Handle01]
  3568 00000F3A 8EDB                    	mov	ds,bx
  3569                                  	;assume ds:NOTHING
  3570                                  	;lds	bx,[34h] 
  3571 00000F3C C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3572 00000F40 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3573 00000F42 58                      	pop	ax
  3574 00000F43 5B                      	pop	bx
  3575 00000F44 1F                      	pop	ds
  3576 00000F45 C3                      	retn
  3577                                  
  3578                                  	;assume ds:DATARES,ss:DATARES
  3579                                  Hopeless:
  3580 00000F46 BA[C504]                	mov	dx,COMBAD
  3581 00000F49 E9BEFD                  	jmp	FatalC
  3582                                  
  3583                                  GetComDsk:
  3584 00000F4C A0[7F01]                	mov	al,[ComDrv]
  3585 00000F4F E84DFF                  	call	RemCheck
  3586 00000F52 75F2                    	jnz	short Hopeless		; non-removable media
  3587                                  GetComDsk3:
  3588 00000F54 81FA[C504]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3589 00000F58 7503                    	jne	short GetComDsk4
  3590                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3591                                  	; 12/01/2023
  3592                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3593                                  	;invoke	RPrint			; say COMMAND is invalid
  3594 00000F5A E81803                  	call	RPrint
  3595                                  	;call	RDISPMSG
  3596                                  
  3597                                  GetComDsk4:
  3598                                  
  3599                                  ;	Bugbug:	there's always a drive here? No need to check?
  3600                                  
  3601 00000F5D 803E[1A01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3602 00000F62 7509                    	jne	short Users_Drive	; yes - use it
  3603 00000F64 B419                    	mov	ah,19h
  3604                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3605 00000F66 CD21                    	int	21h
  3606 00000F68 0441                    	add	al,"A"                  ; convert to ascii
  3607 00000F6A A2[1A01]                	mov	[PutBackDrv],al		; put in message to print out
  3608                                  
  3609                                  Users_Drive:
  3610                                  	; 12/01/2023
  3611                                  	; MSDOS 6.0
  3612 00000F6D BA[DB04]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3613                                  	;mov	si,offset DATARES:PutBackSubst
  3614                                  	;invoke	RPrint
  3615 00000F70 BE[1401]                	mov	si,PutBackSubst		; containing COMMAND
  3616 00000F73 E8FF02                  	call	RPrint
  3617                                  	;mov	dx,offset DATARES:Prompt
  3618                                  	;invoke	RPrint
  3619 00000F76 BA[FD04]                	mov	dx,PROMPT		; "Press any key"
  3620 00000F79 E8F902                  	call	RPrint
  3621                                  
  3622                                  	; MSDOS 3.3
  3623                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3624                                  	;call	RDISPMSG
  3625                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3626                                  	;mov	si,[COMSPEC_END]
  3627                                  	;mov	byte [si+1],'$'
  3628                                  	;call	RDISPMSG
  3629                                  	;mov	byte [si+1],0
  3630                                  	;mov	dx,PROMPT
  3631                                  	;call	RDISPMSG
  3632                                  
  3633                                  	;call	GetRawFlushedByte
  3634                                  	;retn
  3635                                  	; 12/01/2023
  3636                                  	;jmp	short GetRawFlushedByte
  3637                                  
  3638                                  ;***	GetRawFlushedByte - flush world and get raw input
  3639                                  
  3640                                  GetRawFlushedByte:
  3641                                  	; 12/01/2023
  3642 00000F7C B8070C                  	mov	ax,0C07h
  3643                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3644 00000F7F CD21                    	int	21h			; get char without testing or echo
  3645 00000F81 B8000C                  	mov	ax,0C00h
  3646                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3647 00000F84 CD21                    	int	21h
  3648                                  
  3649                                  ;	Bugbug:	get rid of this return and the following retz.
  3650                                  
  3651                                  LoadCom_retn:
  3652 00000F86 C3                      	retn
  3653                                  
  3654                                  	; 21/04/2023
  3655                                  TryDoOpen:
  3656 00000F87 E8C2FF                  	call	GetComDsk
  3657                                  	;jmp	short LoadCom
  3658                                  
  3659                                  ;***	LoadCom - load in transient
  3660                                  
  3661                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3662                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3663                                  
  3664                                  LoadCom:
  3665                                  	;assume	ds:DATARES
  3666                                  	
  3667 00000F8A 45                      	inc	bp				; flag command read
  3668                                  
  3669 00000F8B BA[3601]                	mov	dx,ComSpec
  3670 00000F8E B8003D                  	mov	ax,3D00h
  3671                                  	;mov	ax,OPEN<<8	; 3D00h
  3672 00000F91 CD21                    	int	21h				; open command.com
  3673 00000F93 730B                    	jnc	short ReadCom
  3674                                  	;cmp	ax,4
  3675 00000F95 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3676 00000F98 75ED                    	jnz	short TryDoOpen
  3677 00000F9A BA[8705]                	mov	dx,NOHANDMES
  3678 00000F9D E96AFD                  	jmp	FatalC				; will never find a handle
  3679                                  
  3680                                  	; 21/04/2023
  3681                                  ;TryDoOpen:
  3682                                  	;call	GetComDsk
  3683                                  	;jmp	short LoadCom
  3684                                  
  3685                                  ReadCom:
  3686 00000FA0 89C3                    	mov	bx,ax				; BX = handle
  3687                                  	;mov	dx,offset RESGROUP:TranStart
  3688 00000FA2 BA0022                  	mov	dx,TRANSTART
  3689 00000FA5 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3690 00000FA7 B80042                  	mov	ax,4200h
  3691                                  	;mov	ax,LSEEK<<8	; 4200h
  3692 00000FAA CD21                    	int	21h
  3693 00000FAC 7210                    	jc	short WrongCom1
  3694                                  	; 12/01/2023
  3695                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3696                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3697 00000FAE B96F94                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3698 00000FB1 1E                      	push	ds
  3699 00000FB2 8E1E[7A01]              	mov	ds,[TrnSeg]
  3700                                  	;assume	ds:NOTHING
  3701 00000FB6 BA0001                  	mov	dx,100h
  3702 00000FB9 B43F                    	mov	ah,3Fh
  3703                                  	;mov	ah,READ	; 3Fh	
  3704 00000FBB CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3705                                  			; BX = file handle, CX = number of bytes to read
  3706                                  			; DS:DX -> buffer
  3707 00000FBD 1F                      	pop	ds
  3708                                  	;assume	ds:DATARES
  3709                                  WrongCom1:
  3710 00000FBE 9C                      	pushf
  3711 00000FBF 50                      	push	ax
  3712 00000FC0 B43E                    	mov	ah,3Eh
  3713                                  	;mov	ah,CLOSE ; 3Eh
  3714 00000FC2 CD21                    	int	21h			; close command.com
  3715 00000FC4 58                      	pop	ax
  3716 00000FC5 9D                      	popf
  3717 00000FC6 7204                    	jc	short WrongCom		; error on read
  3718 00000FC8 39C8                    	cmp	ax,cx
  3719                                  	;retz				; size matched
  3720 00000FCA 74BA                    	jz	short LoadCom_retn
  3721                                  WrongCom:
  3722 00000FCC BA[C504]                	mov	dx,COMBAD
  3723 00000FCF E87AFF                  	call	GetComDsk
  3724 00000FD2 EBB6                    	jmp	short LoadCom		; try again
  3725                                  
  3726                                  ;***	ChkSum - compute transient checksum
  3727                                  
  3728                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3729                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3730                                  ChkSum:
  3731 00000FD4 1E                      	push	ds
  3732 00000FD5 8E1E[7A01]              	mov	ds,[TrnSeg]
  3733 00000FD9 BE0001                  	mov	si,100h
  3734                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3735                                  	;mov	cx,87C2h
  3736 00000FDC B9[F084]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3737                                  Check_Sum:
  3738 00000FDF FC                      	cld
  3739 00000FE0 D1E9                    	shr	cx,1
  3740 00000FE2 31D2                    	xor	dx,dx
  3741                                  Chk:
  3742 00000FE4 AD                      	lodsw
  3743 00000FE5 01C2                    	add	dx,ax
  3744 00000FE7 83D200                  	adc	dx,0
  3745 00000FEA E2F8                    	loop	Chk
  3746                                  
  3747                                  	; 04/05/2023
  3748 00000FEC 1F                      	pop	ds
  3749                                  
  3750                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3751 00000FED 3B16[8201]              	cmp	dx,[Sum]
  3752                                  
  3753                                  	;pop	ds ; 04/05/2023
  3754 00000FF1 C3                      	retn
  3755                                  
  3756                                  ;***	SetVect - set interrupt vectors
  3757                                  
  3758                                  SetVect:
  3759                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3760                                  	; 12/01/2023
  3761 00000FF2 BA[7E00]                	mov	dx,LodCom_Trap
  3762                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3763 00000FF5 B82225                  	mov	ax,2522h
  3764                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3765 00000FF8 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3766 00000FFC 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3767 00001000 CD21                    	int	21h
  3768                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3769 00001002 BA[4A00]                	mov	dx,Ctrlc_Trap
  3770                                  	;mov	dx,CONTC ; MSDOS 3.3
  3771 00001005 FEC0                    	inc	al	; 23h
  3772 00001007 CD21                    	int	21h
  3773                                  	;mov	dx,offset DATARES:CritErr_Trap
  3774 00001009 BA[5500]                	mov	dx,CritErr_Trap
  3775                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3776 0000100C FEC0                    	inc	al	; 24h
  3777 0000100E CD21                    	int	21h
  3778 00001010 C3                      	retn
  3779                                  
  3780                                  	; MSDOS 6.0
  3781                                  ;;SR;
  3782                                  ;We have this to take care of the extra values pushed on the stack by
  3783                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3784                                  ;Lodcom1
  3785                                  
  3786                                  ;public	TrnLodCom1
  3787                                  	; 12/01/2023
  3788                                  TrnLodCom1:
  3789 00001011 1F                      	pop	ds			; ds = DATARES
  3790 00001012 83C402                  	add	sp,2
  3791                                  ;	pop	ds:OldDS
  3792 00001015 E921FE                  	jmp	LodCom1
  3793                                  
  3794                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3795                                  
  3796                                  %if 0
  3797                                  
  3798                                  ;***	EndInit - end up initialization sequence
  3799                                  ;
  3800                                  ;	Move the environment to a newly allocated segment.
  3801                                  
  3802                                  	; MSDOS 3.3
  3803                                  ENDINIT:
  3804                                  	push	ds			; save segments
  3805                                  	push	es			;
  3806                                  	push	cs			; get resident segment to DS
  3807                                  	pop	ds			;
  3808                                  	;assume	ds:RESGROUP
  3809                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3810                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3811                                  	;assume	es:NOTHING
  3812                                  
  3813                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3814                                  	jne	short NO_RESET 		; no - we already did it
  3815                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3816                                  	push	es			; save environment - just to be sure
  3817                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3818                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3819                                  				; ES = segment address of block to change
  3820                                  				; BX = new size in paragraphs
  3821                                  	pop	es
  3822                                  
  3823                                  NO_RESET:
  3824                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3825                                  	mov	ds,[OLDENV]		; source environment segment
  3826                                  	;assume	ds:NOTHING
  3827                                  	xor	si,si			; set up offsets to start of segments
  3828                                  	xor	di,di
  3829                                  	cld
  3830                                  	rep	movsb			; move it
  3831                                  	xor	ax,ax
  3832                                  	stosb				; make sure it ends with double-null
  3833                                  
  3834                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3835                                  	pop	es
  3836                                  	pop	ds
  3837                                  	jmp	LODCOM			; allocate transient
  3838                                  
  3839                                  	; MSDOS 6.0
  3840                                  
  3841                                  ;The init code has been changed to take care of the new way in which the
  3842                                  ;environment segment is allocated.
  3843                                  ;NB: We can use all the init variables at this point because they are all in
  3844                                  ;RESGROUP
  3845                                  ;Bugbug: The above approach will not work for ROMDOS
  3846                                  
  3847                                  ;IF 0
  3848                                  ;
  3849                                  ;EndInit:
  3850                                  ;	push	ds
  3851                                  ;	push	es			;save segments
  3852                                  ;	push	cs
  3853                                  ;	pop	ds		
  3854                                  ;	assume	ds:RESGROUP
  3855                                  ;;
  3856                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3857                                  ;;
  3858                                  ;	mov	bx,ds
  3859                                  ;	mov	es,bx			;es = RESGROUP
  3860                                  ;;
  3861                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3862                                  ;; code + data for low COMMAND
  3863                                  ;;
  3864                                  ;	mov	bx,ResSize		;Total size of resident
  3865                                  ;	mov	ah,SETBLOCK
  3866                                  ;	int	21h			;Set block to resident size
  3867                                  ;;
  3868                                  ;;Allocate the correct size for the environment
  3869                                  ;;
  3870                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3871                                  ;	mov	ah,ALLOC
  3872                                  ;	int	21h			;get memory
  3873                                  ;	jc	nomem_err		;out of memory,signal error
  3874                                  ;
  3875                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3876                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3877                                  ;	mov	es,ax			;es = address of allocated memory
  3878                                  ;	assume	es:nothing
  3879                                  ;
  3880                                  ;;
  3881                                  ;;Copy the environment to the newly allocated segment
  3882                                  ;;
  3883                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3884                                  ;
  3885                                  ;	push	ds
  3886                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3887                                  ;	assume	ds:nothing
  3888                                  ;
  3889                                  ;	xor	si,si
  3890                                  ;	mov	di,si			;Start transfer from 0
  3891                                  ;
  3892                                  ;	cld
  3893                                  ;	rep	movsb			;Do the copy
  3894                                  ;
  3895                                  ;	xor	ax,ax			
  3896                                  ;	stosb				;Make it end with double-null
  3897                                  ;
  3898                                  ;	pop	ds			;ds = RESGROUP
  3899                                  ;	assume	ds:RESGROUP
  3900                                  ;;
  3901                                  ;;We have to free the old environment block if it was allocated by INIT
  3902                                  ;;
  3903                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3904                                  ;	je      no_free                 ;no, do not free it
  3905                                  ;
  3906                                  ;	mov	ax,OldEnv		;Get old environment
  3907                                  ;	mov	es,ax
  3908                                  ;	mov	ah,DEALLOC	
  3909                                  ;	int	21h			;Free it
  3910                                  ;no_free:
  3911                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3912                                  ;	
  3913                                  ;	pop	es
  3914                                  ;	pop	ds
  3915                                  ;	assume	ds:nothing
  3916                                  ;	
  3917                                  ;	jmp	LodCom			;allocate transient
  3918                                  ;
  3919                                  ;nomem_err:
  3920                                  ;;
  3921                                  ;;We call the error routine which will never return. It will either exit
  3922                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3923                                  ;;message ( if first COMMAND )
  3924                                  ;;
  3925                                  ;
  3926                                  ;	call	Alloc_error
  3927                                  ;ENDIF
  3928                                  ;
  3929                                  ;CODERES ends
  3930                                  
  3931                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3932                                  ;	the resident group which is the location where the transient
  3933                                  ;	segments will be loaded initial.
  3934                                  
  3935                                  ;TAIL		segment public para
  3936                                  ;
  3937                                  ;		org	0
  3938                                  ;TranStart	label	word
  3939                                  ;		public	TranStart
  3940                                  ;
  3941                                  ;TAIL		ends
  3942                                  ;
  3943                                  
  3944                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3945                                  ;	the transient group which is the location where the exec
  3946                                  ;	segments will be loaded initial.
  3947                                  ;
  3948                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3949                                  
  3950                                  ;TRANTAIL	segment public para
  3951                                  ;
  3952                                  ;		org	0
  3953                                  ;ExecStart   	label   word
  3954                                  ;
  3955                                  ;TRANTAIL    	ends
  3956                                  
  3957                                  %endif ; 12/01/2023
  3958                                  
  3959                                  ;=============================================================================
  3960                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3961                                  ;=============================================================================
  3962                                  ; 22/09/2018 - Retro DOS v3.0
  3963                                  
  3964                                  ;	title	Localizable code for resident COMMAND
  3965                                  
  3966                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3967                                  
  3968                                  ; ----------------------------------------------------------------------------
  3969                                  ;***	AskEnd - ask user to confirm batch file termination
  3970                                  ;
  3971                                  ;	Confirm with user before freeing batch ...
  3972                                  ;
  3973                                  ;	ENTRY	nothing
  3974                                  ;
  3975                                  ;	EXIT	CY = set if batch termination is confirmed
  3976                                  ;
  3977                                  ;		CY = clear if batch should continue
  3978                                  ;
  3979                                  ;	USED	AX,DX,...
  3980                                  ;
  3981                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3982                                  ;	Bugbug:	or move it to command1 1st.
  3983                                  ;
  3984                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3985                                  ; ----------------------------------------------------------------------------
  3986                                  
  3987                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3988                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3989                                  
  3990                                  AskEnd:
  3991                                  	;assume	ds:DATARES
  3992                                  
  3993 00001018 BA[1F05]                	mov	dx,ENDBATMES			; DX = message #
  3994 0000101B E85702                  	call	RPrint
  3995                                  	;call	RDISPMSG  ; MSDOS 3.3
  3996 0000101E B8010C                  	mov	ax,0C01h
  3997                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3998 00001021 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3999                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  4000 00001023 E8E802                  	call	CharToUpper			; change to upper case
  4001 00001026 3A06[2604]              	cmp	al,[NO_CHAR]
  4002 0000102A 7407                    	je	short aeRet			; answer is no (CY is clear)
  4003 0000102C 3A06[2504]              	cmp	al,[YES_CHAR]
  4004 00001030 75E6                    	jne	short AskEnd			; invalid response, try again
  4005 00001032 F9                      	stc					; answer is yes
  4006                                  aeRet:	
  4007 00001033 C3                      	retn
  4008                                  
  4009                                  ; ----------------------------------------------------------------------------
  4010                                  ;***	DskErr - critical error handler
  4011                                  ;
  4012                                  ;	Default critical error handler unless user intercepts int 24h.
  4013                                  ;
  4014                                  ;	ENTRY	int 24h
  4015                                  ;
  4016                                  ;	EXIT
  4017                                  ;
  4018                                  ;	USED
  4019                                  ;
  4020                                  ;	EFFECTS
  4021                                  ; ----------------------------------------------------------------------------
  4022                                  
  4023                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4024                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4025                                  
  4026                                  ;SR; 
  4027                                  ;The stub is going to push the old ds value and the resident data segment
  4028                                  ;onto the stack in that order. Get it off the stack
  4029                                  
  4030                                  ;DskErr	proc	far
  4031                                  DSKERR:
  4032                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4033                                  	; 12/01/2023
  4034 00001034 1F                      	pop	ds			; ds = DATARES
  4035                                  	;assume ds:DATARES
  4036 00001035 8F06[1E04]              	pop	word [OldDS]		; save old ds value
  4037                                  
  4038                                  ;CRITERR: ; MSDOS 3.3
  4039 00001039 FB                      	sti
  4040                                  	; 12/01/2023
  4041                                  	;push	ds ; 25/09/2018
  4042 0000103A 06                      	push	es
  4043 0000103B 56                      	push	si
  4044 0000103C 51                      	push	cx
  4045 0000103D 57                      	push	di
  4046 0000103E 51                      	push	cx
  4047 0000103F 50                      	push	ax
  4048                                  
  4049 00001040 1E                      	push	ds			;save our data segment
  4050                                  	;push	cs ; 25/09/2018
  4051 00001041 07                      	pop	es			;es = DATARES
  4052                                  
  4053 00001042 8EDD                    	mov	ds,bp
  4054                                  	;assume	ds:nothing
  4055                                  
  4056                                  	;mov	ax,[si].SDEVATT
  4057 00001044 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4058 00001047 268826[1001]            	mov	[es:CDevAt],ah
  4059                                  
  4060                                  	;push	cs
  4061                                  	;pop	es
  4062                                  
  4063 0000104C BF[0301]                	mov	di,DevName
  4064 0000104F B90800                  	mov	cx,8
  4065                                  	;add	si,SDEVNAME  ; add si,10
  4066 00001052 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4067                                  				
  4068 00001055 FC                      	cld
  4069 00001056 F3A4                    	rep	movsb
  4070 00001058 58                      	pop	ax
  4071 00001059 59                      	pop	cx
  4072 0000105A 5F                      	pop	di
  4073                                  
  4074                                  ;	Stack still contains DS and ES.
  4075                                  
  4076                                  ;SR;
  4077                                  ;We need ds = DATARES for SavHand
  4078                                  
  4079                                  	 ;12/01/2023
  4080 0000105B 06                      	push	es
  4081 0000105C 1F                      	pop	ds
  4082                                  	;assume	ds:DATARES
  4083                                  
  4084                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4085 0000105D E8A7FE                  	call	SavHand
  4086                                  
  4087                                  	; 12/01/2023
  4088                                  	; 25/09/2018
  4089                                  	;;push	cs
  4090                                  	;push	es
  4091                                  	;pop	ds		; set up local data segment
  4092                                  	;assume	ds:resgroup
  4093                                  
  4094 00001060 52                      	push	dx
  4095 00001061 E80E02                  	call	crlf
  4096 00001064 5A                      	pop	dx
  4097                                  
  4098                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4099                                  
  4100 00001065 8826[8701]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4101                                  
  4102                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4103                                  
  4104 00001069 0441                    	add	al,'A'
  4105 0000106B A2[F000]                	mov	[DrvLet],al
  4106                                  
  4107                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4108                                  
  4109 0000106E F6C480                  	test	ah,80h
  4110 00001071 740A                    	jz	short NoHardE		; it's a disk-device error
  4111 00001073 F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4112 00001078 7503                    	jnz	short NoHardE		; it's a character device
  4113 0000107A E9E801                  	jmp	FatErr			; it's a FAT error
  4114                                  
  4115                                  NoHardE:
  4116 0000107D BE[4704]                	mov	si,MREAD		; SI = "read" msg #
  4117 00001080 F6C401                  	test	ah,1
  4118 00001083 7403                    	jz	short SavMes		; it's a read error
  4119 00001085 BE[5004]                	mov	si,MWRITE		; SI = "write" msg #
  4120                                  SavMes:
  4121 00001088 893E[4703]              	mov	[OldErrNo],di		; save critical error code
  4122                                  
  4123                                  ;	Bugbug:	don't need to save/restore all here?
  4124                                  
  4125 0000108C 06                      	push	es
  4126                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4127                                  	;push	ds			; GetExtendedError likes to STOMP
  4128                                  	; 12/01/2023
  4129                                  	; (all registers are changed -in dos service- except bp) *
  4130                                  	;push	bp
  4131                                  	; 19/07/2024
  4132                                  	;push	si
  4133                                  	;push	dx
  4134 0000108D 51                      	push	cx
  4135 0000108E 53                      	push	bx
  4136                                  	; 05/06/2023
  4137 0000108F B459                    	mov	ah,59h ; *
  4138                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4139 00001091 CD21                    	int	21h
  4140 00001093 5B                      	pop	bx
  4141 00001094 59                      	pop	cx
  4142                                  	; 19/07/2024
  4143                                  	;pop	dx
  4144                                  	;pop	si
  4145                                  	; 12/01/2023
  4146                                  	;pop	bp
  4147                                  	; 19/07/2024
  4148                                  	;pop	ds
  4149 00001095 893E[1E01]              	mov	[NeedVol],di		; save possible ptr to volume label
  4150 00001099 8C06[2001]              	mov	[NeedVol+2],es
  4151 0000109D 07                      	pop	es
  4152                                  
  4153                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4154                                  
  4155                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4156                                  	;xor	ah,ah
  4157 0000109E 89C7                    	mov	di,ax			; DI = error code
  4158                                  
  4159                                  ; Bugbug: somewhat obsolete documentation?
  4160                                  ;
  4161                                  ; DI is now the correct error code. Classify things to see what we are
  4162                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4163                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4164                                  ; the like) are contiguous.
  4165                                  
  4166                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4167                                  ;	Check use of ErrCd_24, though.
  4168                                  
  4169 000010A0 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4170 000010A3 7303                    	jae	short HavCod
  4171                                  
  4172                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4173                                  ;	even though it's not a critical error?
  4174                                  
  4175 000010A5 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4176                                  
  4177                                  ; DI now has the mapped error code. Old style errors are:
  4178                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4179                                  ; New style errors are:
  4180                                  ;   FOOBAR
  4181                                  ; We need to figure out which the particular error belongs to.
  4182                                  
  4183                                  HavCod:
  4184 000010A8 C606[2201]00            	mov	byte [ErrType],0	; assume old style
  4185 000010AD 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4186 000010B0 7405                    	je	short SetStyle
  4187 000010B2 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4188 000010B5 7504                    	jne	short GotStyle
  4189                                  
  4190                                  SetStyle:
  4191                                  ;	Bugbug:	use INC
  4192                                  	;mov	byte [ErrType],1		; must be new type
  4193 000010B7 FE06[2201]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4194                                  
  4195                                  GotStyle:
  4196 000010BB 893E[2F01]              	mov	[ErrCd_24],di
  4197                                  	; 12/01/2023
  4198                                  	; 25/09/2018
  4199                                  	; MSDOS 6.0
  4200 000010BF 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4201                                  	; MSDOS 3.3
  4202                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4203                                  
  4204                                  						; If the error message is unknown
  4205 000010C2 7641                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4206                                  
  4207                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4208                                  ; how to handle things
  4209                                  
  4210                                  ;input to IFSFUNC:    AL=1
  4211                                  ;		      BX=extended error number
  4212                                  ;
  4213                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4214                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4215                                  ;			   Abort, Retry, Ignore
  4216                                  ;			 1=<message>
  4217                                  ;			   Abort, Retry, Ignore
  4218                                  ;		      ES:DI=pointer to message text
  4219                                  ;		      carry set=>no message
  4220                                  
  4221 000010C4 89C7                    	mov	di,ax			; retrieve correct extended error...
  4222 000010C6 B80005                  	mov	ax,0500h		; is the redir there?
  4223 000010C9 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4224                                  			; Return: AL = 00h not installed, OK to install
  4225                                  			; 01h not installed, can't install
  4226                                  			; FFh installed
  4227 000010CB 3CFF                    	cmp	al,0FFh
  4228 000010CD 7529                    	jne	short NoHandler		; no, go to NoHandler
  4229                                  
  4230                                  	; 12/01/2023
  4231                                  	; MSDOS 6.0
  4232 000010CF 53                      	push	bx
  4233 000010D0 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4234 000010D2 B80105                  	mov	ax,0501h
  4235 000010D5 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4236 000010D7 5B                      	pop	bx 
  4237 000010D8 721E                    	jc	short NoHandler
  4238                                  	
  4239                                  	; MSDOS 3.3
  4240                                  	;mov     ax,di
  4241                                  	;mov     ah,5
  4242                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4243                                  	;jc      short NOHANDLER
  4244                                  
  4245                                  ;	Bugbug:	need to record error type?
  4246                                  
  4247 000010DA A2[2201]                	mov	[ErrType],al
  4248                                  
  4249 000010DD 1E                      	push	ds
  4250 000010DE 06                      	push	es
  4251 000010DF 1F                      	pop	ds
  4252 000010E0 89FA                    	mov	dx,di
  4253 000010E2 B9FFFF                  	mov	cx,-1			; find end of msg
  4254 000010E5 30C0                    	xor	al,al
  4255                                  
  4256 000010E7 FC                      	cld
  4257 000010E8 F2AE                    	repnz	scasb
  4258                                  
  4259                                  ;	Bugbug:	we can do better than this.
  4260                                  
  4261                                  	;mov	byte [di-1],'$'
  4262                                  	; 19/07/2024
  4263 000010EA 4F                      	dec	di
  4264 000010EB C60524                  	mov	byte [di],'$'
  4265                                  	
  4266                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4267                                  	
  4268 000010EE B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4269 000010F0 CD21                    	int	21h
  4270                                  
  4271                                  	;mov	byte [di-1],0			; restore terminal byte
  4272                                  	; 19/07/2024
  4273 000010F2 C60500                  	mov	byte [di],0
  4274                                  
  4275 000010F5 1F                      	pop	ds				; clean up and continue
  4276 000010F6 EB15                    	jmp	short CheckErrType
  4277                                  
  4278                                  ;*	Redir isn't available or doesn't recognize the error.
  4279                                  ;	Restore regs to unextended error.
  4280                                  
  4281                                  NoHandler:
  4282 000010F8 C606[2201]00            	mov	byte [ErrType],0
  4283                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4284 000010FD 8B3E[4703]              	mov	di,[OldErrNo]
  4285 00001101 893E[2F01]              	mov	[ErrCd_24],di
  4286                                  
  4287                                  NormalError:
  4288                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4289                                  	; MSDOS 6.0
  4290 00001105 83C713                  	add	di,ERROR_WRITE_PROTECT
  4291 00001108 87FA                    	xchg	di,dx			; may need dx later
  4292 0000110A E88101                  	call	RPrintCrit		; print error type
  4293                                  
  4294                                  	; MSDOS 3.3
  4295                                  	;shl     di,1
  4296                                  	;mov     di,[CRMSGTBL+di]
  4297                                  	;xchg    di,dx
  4298                                  	;call    RDISPMSG
  4299                                  
  4300                                  CheckErrType:
  4301 0000110D 803E[2201]00            	cmp	byte [ErrType],0	; Check error style...
  4302 00001112 7405                    	je	short ContOld
  4303 00001114 E85B01                  	call	crlf			; if new style then done printing
  4304 00001117 EB31                    	jmp	short Ask
  4305                                  
  4306                                  ContOld:
  4307                                  	; 12/01/2023
  4308                                  	; MSDOS 6.0
  4309 00001119 46                      	inc	si			; DS:SI = ptr to asciiz string
  4310                                  
  4311                                  ;	Bugbug:	combine some of the following two sections?
  4312                                  
  4313                                  	; 12/01/2023
  4314 0000111A F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4315                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4316 0000111F 740F                    	jz	short BlkErr
  4317                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4318                                  	;mov	dx,ChardevErr
  4319 00001121 BA[6804]                	mov	dx,MDEVICE
  4320                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4321 00001124 8936[F200]              	mov	[CharDevErrRw],si
  4322                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4323 00001128 BE[F100]                	mov	si,CharDevErrSubst
  4324                                  
  4325 0000112B E84701                  	call	RPrint				; print the message
  4326 0000112E EB1A                    	jmp	short Ask			; don't ralph on command
  4327                                  
  4328                                  	; 12/01/2023
  4329                                  	; MSDOS 3.3
  4330                                  	;mov	dx,ERRMES
  4331                                  	;call	RDISPMSG
  4332                                  	;mov	dx,si
  4333                                  	;call	RDISPMSG
  4334                                  	;
  4335                                  	;test	byte [CDevAt],80h
  4336                                  	;jz	short BLKERR
  4337                                  	;mov	dx,CHARDEVERR	; " device "
  4338                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4339                                  	;int	21h		; DOS - PRINT STRING
  4340                                  	;			; DS:DX -> string terminated by "$"
  4341                                  	;jmp	short ASK
  4342                                  
  4343                                  BlkErr:
  4344                                  	; 12/01/2023
  4345                                  	; MSDOS 6.0
  4346                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4347                                  	;mov	dx,BlkDevErr
  4348 00001130 BA[5904]                	mov	dx,MDRIVE
  4349                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4350 00001133 8936[EB00]              	mov	[BlkDevErrRw],si
  4351                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4352 00001137 BE[EA00]                	mov	si,BlkDevErrSubst
  4353 0000113A E83801                  	call	RPrint
  4354                                  
  4355                                  	; MSDOS 3.3
  4356                                  	;mov	dx,BLKDEVERR
  4357                                  	;call	RDISPMSG
  4358                                  
  4359 0000113D 803E[3301]00            	cmp	byte [Loading],0
  4360 00001142 7406                    	jz	short Ask
  4361 00001144 E8E9FD                  	call	RestHand
  4362 00001147 E9E0FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4363                                  Ask:
  4364 0000114A 833E[2F01]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4365 0000114F 751E                    	jne	short Not15		; not error 15
  4366                                  
  4367                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4368                                  
  4369 00001151 51                      	push	cx
  4370                                  
  4371                                  ;	Bugbug:	does this push/pop need to be done?
  4372                                  
  4373 00001152 1E                      	push	ds
  4374 00001153 07                      	pop	es
  4375 00001154 C536[1E01]              	lds	si,[NeedVol]
  4376                                  	;assume	ds:NOTHING
  4377 00001158 57                      	push	di
  4378 00001159 BF[0001]                	mov	di,VolName
  4379                                  	; 12/01/2023
  4380                                  	; MSDOS 6.0
  4381 0000115C B91000                  	mov	cx,16			; copy volume name & serial #
  4382                                  	; MSDOS 3.3
  4383                                  	;mov	cx,11			; copy volume name
  4384 0000115F FC                      	cld
  4385 00001160 F3A4                    	rep	movsb
  4386 00001162 5F                      	pop	di
  4387 00001163 06                      	push	es
  4388 00001164 1F                      	pop	ds
  4389 00001165 59                      	pop	cx
  4390                                  	;assume	ds:DATARES
  4391                                  	; 12/01/2023
  4392                                  	; MSDOS 6.0
  4393                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4394                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4395                                  	;mov	dx,NeedVolMsg
  4396 00001166 BA[7804]                	mov	dx,MVOLSERIAL
  4397 00001169 BE[F700]                	mov	si,NeedVolSubst
  4398 0000116C E80601                  	call	RPrint
  4399                                  
  4400                                  	; MSDOS 3.3
  4401                                  	;mov	dx,NEEDVOLMSG
  4402                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4403                                  	;int	21h		; DOS - PRINT STRING
  4404                                  	;			; DS:DX -> string terminated by "$"
  4405                                  Not15:
  4406                                  ;*	Print abort, retry, ignore, fail message.
  4407                                  ;	Print only options that are valid.
  4408                                  
  4409                                  ;	Bugbug:	sizzle this.
  4410                                  
  4411                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4412 0000116F BA[2704]                	mov	dx,REQ_ABORT
  4413 00001172 E80001                  	call	RPrint
  4414                                  	;call	RDISPMSG
  4415 00001175 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4416 0000117A 7406                    	jz	short Try_Ignore
  4417 0000117C BA[2D04]                	mov	dx,REQ_RETRY
  4418 0000117F E8F300                  	call	RPrint
  4419                                  	;call	RDISPMSG
  4420                                  Try_Ignore:
  4421 00001182 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4422 00001187 7406                    	jz	short Try_Fail
  4423 00001189 BA[3504]                	mov	dx,REQ_IGNORE
  4424 0000118C E8E600                  	call	RPrint
  4425                                  	;call	RDISPMSG
  4426                                  Try_Fail:
  4427 0000118F F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4428 00001194 7406                    	jz	short Term_Question
  4429 00001196 BA[3E04]                	mov	dx,REQ_FAIL
  4430 00001199 E8D900                  	call	RPrint
  4431                                  	;call	RDISPMSG
  4432                                  Term_Question:
  4433 0000119C BA[4504]                	mov	dx,REQ_END
  4434 0000119F E8D300                  	call	RPrint
  4435                                  	;call	RDISPMSG
  4436                                  
  4437                                  ;	If the /f switch was given, we fail all requests.
  4438                                  
  4439 000011A2 F606[9201]FF            	test	byte [fFail],-1
  4440 000011A7 741B                    	jz	short DoPrompt
  4441 000011A9 B403                    	mov	ah,3				; signal fail
  4442 000011AB E9A800                  	jmp	EExit
  4443                                  
  4444                                  	; 16/04/2023
  4445                                  Abort_Process:
  4446 000011AE F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4447 000011B3 745D                    	jz	short AbortCont			; no, handle it normally
  4448 000011B5 803E[8D01]00            	cmp	byte [PermCom],0		; are we top level process?
  4449 000011BA 744B                    	jz	short JustExit			; yes, just exit
  4450                                  
  4451 000011BC BA[2A06]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4452                                  	; 12/01/2023
  4453 000011BF E8B300                  	call	RPrint				; print it
  4454                                  	;call	RDISPMSG
  4455                                  DeadInTheWater:
  4456 000011C2 EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4457                                  
  4458                                  DoPrompt:
  4459                                  	; 12/01/2023
  4460 000011C4 B8010C                  	mov	ax,0C01h
  4461                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4462 000011C7 CD21                    	int	21h				; get response
  4463                                  
  4464 000011C9 E8A600                  	call	crlf
  4465 000011CC E83F01                  	call	CharToUpper			; convert to upper case
  4466 000011CF B400                    	mov	ah,0				; return code for ignore
  4467 000011D1 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4468 000011D6 7406                    	jz	short User_Retry
  4469 000011D8 3A06[2304]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4470                                  	;jz	short EExitJ
  4471                                  	; 16/04/2023
  4472 000011DC 7478                    	jz	short EExit
  4473                                  
  4474                                  ;	Bugbug:	optimize following code.
  4475                                  
  4476                                  User_Retry:
  4477 000011DE FEC4                    	inc	ah				; return code for retry
  4478 000011E0 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4479 000011E5 7406                    	jz	short User_Abort
  4480 000011E7 3A06[2204]              	cmp	al,[RETRY_CHAR]			; retry?
  4481                                  	;jz	short EExitJ
  4482                                  	; 16/04/2023
  4483 000011EB 7469                    	jz	short EExit
  4484                                  User_Abort:
  4485 000011ED FEC4                    	inc	ah				; return code for abort
  4486                                  						;  (abort always allowed)
  4487 000011EF 3A06[2104]              	cmp	al,[ABORT_CHAR]			; abort?
  4488 000011F3 74B9                    	jz	short Abort_Process		; exit user program
  4489 000011F5 FEC4                    	inc	ah				; return code for fail
  4490 000011F7 F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4491 000011FC 7406                    	jz	short AskJ
  4492 000011FE 3A06[2404]              	cmp	al,[FAIL_CHAR]			; fail?
  4493                                  	;jz	short EExitJ
  4494                                  	; 16/04/2023
  4495 00001202 7452                    	jz	short EExit
  4496                                  AskJ:
  4497 00001204 E943FF                  	jmp	Ask
  4498                                  
  4499                                  	; 12/01/2023
  4500                                  ;EExitJ:
  4501                                  	;jmp	short EExit
  4502                                  
  4503                                  JustExit:
  4504                                  	;assume	ds:DATARES
  4505                                  	; 12/01/2023
  4506 00001207 A1[2901]                	mov	ax,[Parent]			; load real parent pid
  4507                                  	;mov	[16h],ax
  4508 0000120A A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4509 0000120D B8FF4C                  	mov	ax,4CFFh
  4510                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4511 00001210 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4512                                  				; AL = exit code
  4513                                  AbortCont:
  4514 00001212 F606[7D01]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4515 00001217 7405                    	jz	short Not_Batch_Abort
  4516 00001219 C606[7E01]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4517                                  
  4518                                  Not_Batch_Abort:
  4519 0000121E 8A16[0002]              	mov	dl,[PipeFlag]
  4520 00001222 E8D1FA                  	call	ResPipeOff
  4521 00001225 08D2                    	or	dl,dl
  4522 00001227 740D                    	je	short CheckForA
  4523 00001229 833E[8E01]00            	cmp	word [SingleCom],0
  4524 0000122E 7406                    	je	short CheckForA
  4525 00001230 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4526                                  
  4527                                  CheckForA:
  4528 00001236 833E[2F01]00            	cmp	word [ErrCd_24],0		; write protect?
  4529 0000123B 7407                    	je	short abortfor
  4530 0000123D 833E[2F01]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4531 00001242 7512                    	jne	short EExit			; don't abort the FOR
  4532                                  
  4533                                  abortfor:
  4534 00001244 C606[9401]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4535 00001249 833E[8E01]00            	cmp	word [SingleCom],0
  4536 0000124E 7406                    	je	short EExit
  4537 00001250 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4538                                  
  4539                                  EExit:
  4540 00001256 88E0                    	mov	al,ah
  4541 00001258 89FA                    	mov	dx,di
  4542                                  RestHd:
  4543 0000125A E8D3FC                  	call    RestHand
  4544 0000125D 59                      	pop	cx
  4545 0000125E 5E                      	pop	si				; restore registers
  4546 0000125F 07                      	pop	es
  4547                                  
  4548                                  	; 12/01/2023	
  4549                                  	; MSDOS 6.0
  4550                                  ;;	pop	ds
  4551                                  ;SR;
  4552                                  ;ds has to be got from the variable we saved it in
  4553                                  
  4554 00001260 8E1E[1E04]               	mov	ds,[OldDS]			; restore old value of ds
  4555                                  
  4556                                  ;	pop	ds
  4557                                  ;	assume	ds:nothing
  4558                                  
  4559                                  	; MSDOS 3.3
  4560                                  	;pop	ds
  4561                                  
  4562 00001264 CF                      	iret
  4563                                  
  4564                                  FatErr:
  4565                                  	; 12/01/2023
  4566                                  	; MSDOS 6.0
  4567                                  	;mov	dx,offset DATARES:BadFatMsg
  4568                                  	;mov	si,offset DATARES:BadFatSubst
  4569 00001265 BA[9F04]                	mov	dx,BADFATMSG
  4570 00001268 BE[1101]                	mov	si,BadFatSubst
  4571 0000126B E80700                  	call	RPrint
  4572                                  
  4573                                  	; MSDOS 3.3
  4574                                  	;mov	dx,BADFATMSG
  4575                                  	;call	RDISPMSG
  4576                                  	;mov	dx,BLKDEVERR
  4577                                  	;call	RDISPMSG
  4578                                  
  4579 0000126E B002                    	mov	al,2				; abort
  4580 00001270 EBE8                    	jmp	short RestHd
  4581                                  
  4582                                  ;DskErr	endp
  4583                                  
  4584                                  	; MSDOS 6.0
  4585                                  ; ----------------------------------------------------------------------------
  4586                                  ;***	RPrint - print message
  4587                                  ;***	Crlf - display cr/lf
  4588                                  ;
  4589                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4590                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4591                                  ;		variable fields related to substitution blocks are set
  4592                                  ;
  4593                                  ;	EXIT	nothing
  4594                                  ;
  4595                                  ;	USED	flags
  4596                                  ;
  4597                                  ;	EFFECTS
  4598                                  ;	  Message is displayed on stdout.
  4599                                  ;
  4600                                  ;	NOTE
  4601                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4602                                  ;	  be greater than number of substition blocks present.
  4603                                  ; ----------------------------------------------------------------------------
  4604                                  
  4605                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4606                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4607                                  
  4608                                  crlf: 
  4609                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4610                                  	; 14/01/2023
  4611 00001272 BA[5906]                	mov	dx,NEWLINE
  4612                                  
  4613                                  ;RPrint	proc
  4614                                  ;
  4615                                  ;	assume	ds:DATARES,ss:DATARES
  4616                                  ;
  4617                                  	; 14/01/2023
  4618                                  RPrint:
  4619                                  
  4620                                  ;	Bugbug:	do we need to save all reg's?
  4621                                  
  4622 00001275 56                      	push	si			; preserve registers
  4623 00001276 50                      	push	ax
  4624 00001277 53                      	push	bx
  4625 00001278 51                      	push	cx
  4626 00001279 52                      	push	dx
  4627                                  
  4628 0000127A 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4629 0000127C 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4630 0000127E AC                      	lodsb				; AL = message length
  4631                                  					; DS:SI = ptr to message text
  4632 0000127F 31C9                    	xor	cx,cx
  4633 00001281 88C1                    	mov	cl,al			; CX = message length
  4634 00001283 E303                    	jcxz	rpRet
  4635                                  
  4636 00001285 E81900                  	call	RDispMsg
  4637                                  
  4638 00001288 5A                      rpRet:	pop	dx
  4639 00001289 59                      	pop	cx
  4640 0000128A 5B                      	pop	bx
  4641 0000128B 58                      	pop	ax
  4642 0000128C 5E                      	pop	si
  4643 0000128D C3                      	retn
  4644                                  
  4645                                  ;RPrint	endp
  4646                                  
  4647                                  	; 14/01/2023
  4648                                  ;	; MSDOS 3.3
  4649                                  ;CRLF:
  4650                                  ;	mov     dx,NEWLIN
  4651                                  ;
  4652                                  ;RDISPMSG: ; Display message/text
  4653                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4654                                  ;	push    ax
  4655                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4656                                  ;	clc
  4657                                  ;	int     21h             ; DOS - PRINT STRING
  4658                                  ;				; DS:DX -> string terminated by "$"
  4659                                  ;	pop     ax
  4660                                  ;	retn
  4661                                  
  4662                                  
  4663                                  	; MSDOS 6.0
  4664                                  ; ----------------------------------------------------------------------------
  4665                                  ;***	RPrintCrit - print critical error message
  4666                                  ;
  4667                                  ;	ENTRY	DX = extended error # (19-39)
  4668                                  ;
  4669                                  ;	EXIT	nothing
  4670                                  ;
  4671                                  ;	USED	flags
  4672                                  ;
  4673                                  ;	EFFECTS
  4674                                  ;	  Message is displayed on stdout
  4675                                  ; ----------------------------------------------------------------------------
  4676                                  
  4677                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4678                                  
  4679                                  ;RPrintCrit	proc
  4680                                  ;	assume	ds:DATARES,ss:DATARES
  4681                                  
  4682                                  	; 14/01/2023
  4683                                  RPrintCrit:
  4684 0000128E 52                      	push	dx			; preserve DX
  4685 0000128F 87DA                    	xchg	bx,dx			; BX = extended error #
  4686                                  					; DX = saved BX
  4687 00001291 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4688 00001294 D1E3                    	shl	bx,1			; BX = offset in word table
  4689 00001296 8B9F[F307]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4690 0000129A 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4691                                  					; BX = restored
  4692 0000129C E8D6FF                  	call	RPrint			; print the message
  4693 0000129F 5A                      	pop	dx			; restore DX
  4694 000012A0 C3                      	retn
  4695                                  
  4696                                  ;RPrintCrit	endp
  4697                                  
  4698                                  ; ----------------------------------------------------------------------------
  4699                                  ;***	RDispMsg - display message
  4700                                  ;
  4701                                  ;	Display message, with substitutions, for RPrint.
  4702                                  ;
  4703                                  ;	ENTRY	DS:SI = ptr to message text
  4704                                  ;		CX = message length
  4705                                  ;		DS:BX = ptr to substitution block, if any
  4706                                  ;
  4707                                  ;	EXIT	nothing
  4708                                  ;
  4709                                  ;	USED	AX,CX,DX,SI
  4710                                  ; ----------------------------------------------------------------------------
  4711                                  
  4712                                  ;RDispMsg	proc
  4713                                  ;	assume	ds:DATARES,ss:DATARES
  4714                                  
  4715                                  RDispMsg:
  4716                                  	; 14/01/2023
  4717                                  rdNextChar:
  4718 000012A1 AC                      	lodsb				; AL = next char
  4719 000012A2 3C25                    	cmp	al,'%'
  4720 000012A4 7511                    	jne	short rdOutChar		; not a substitution
  4721 000012A6 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4722 000012A8 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4723 000012AB 80FA09                  	cmp	dl,9
  4724 000012AE 7307                    	jae	short rdOutChar		; not a substitution
  4725                                  
  4726                                  ;*	A substitution code %1 - %9 has been encountered.
  4727                                  ;	DL = 0-8, indicating %1-%9
  4728                                  ;	DS:BX = ptr to substitution block
  4729                                  
  4730 000012B0 E80D00                  	call	SubstMsg		; display the substitution
  4731 000012B3 46                      	inc	si			; SI = ptr past %n
  4732 000012B4 49                      	dec	cx			; count extra character in %n
  4733 000012B5 EB06                    	jmp	short rdCharDone
  4734                                  
  4735                                  ;*	Normal character output.
  4736                                  
  4737                                  rdOutChar:
  4738 000012B7 88C2                    	mov	dl,al			; DL = char
  4739 000012B9 B402                    	mov	ah,2			; AH = DOS Character Output code
  4740 000012BB CD21                    	int	21h			; call DOS
  4741                                  rdCharDone:
  4742 000012BD E2E2                    	loop	rdNextChar
  4743 000012BF C3                      	retn
  4744                                  
  4745                                  ;RDispMsg	endp
  4746                                  
  4747                                  ; ----------------------------------------------------------------------------
  4748                                  ;***	SubstMsg - display message substitution
  4749                                  ;
  4750                                  ;	Display a substitution string within a message.
  4751                                  ;	Substitution can be a char, an ASCIIZ string, or
  4752                                  ;	a word to be displayed as hex digits.
  4753                                  ;
  4754                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4755                                  ;		DS:BX = ptr to substitution block
  4756                                  ;
  4757                                  ;	EXIT	nothing
  4758                                  ;
  4759                                  ;	USED	AX,DX
  4760                                  ; ----------------------------------------------------------------------------
  4761                                  
  4762                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4763                                  
  4764                                  ;SubstMsg	proc
  4765                                  ;	assume	ds:DATARES,ss:DATARES
  4766                                  	
  4767                                  	; 14/01/2023
  4768                                  SubstMsg:
  4769 000012C0 53                      	push	bx			; preserve BX
  4770 000012C1 51                      	push	cx			; preserve CX
  4771                                  
  4772                                  	;mov	al,size SUBST		; AL = size of substitution block
  4773 000012C2 B003                    	mov	al,3
  4774 000012C4 F6E2                    	mul	dl			; AX = offset of desired subst block
  4775 000012C6 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4776                                  
  4777                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4778 000012C8 8A07                    	mov	al,[bx]
  4779                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4780 000012CA 8B5F01                  	mov	bx,[bx+1]
  4781                                  
  4782                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4783                                  
  4784 000012CD FEC8                    	dec	al
  4785 000012CF 7428                    	jz	short smChar
  4786 000012D1 FEC8                    	dec	al
  4787 000012D3 742C                    	jz	short smStr
  4788                                  
  4789                                  ;*	Hex number substitution.
  4790                                  
  4791                                  	;mov	ax,ds:[bx]		; AX = word value
  4792 000012D5 8B07                    	mov	ax,[bx]
  4793 000012D7 B90400                  	mov	cx,4			; CX = # digits to display
  4794                                  smDigit:
  4795 000012DA D1C0                    	rol	ax,1
  4796 000012DC D1C0                    	rol	ax,1
  4797 000012DE D1C0                    	rol	ax,1
  4798 000012E0 D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4799                                  
  4800 000012E2 50                      	push	ax			; save other digits
  4801 000012E3 240F                    	and	al,0Fh			; AL = binary digit
  4802 000012E5 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4803 000012E7 3C39                    	cmp	al,'9'
  4804 000012E9 7602                    	jbe	short smDigit09		; it's 0-9
  4805                                  	;add	al,7
  4806 000012EB 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4807                                  smDigit09:
  4808 000012ED 88C2                    	mov	dl,al			; DL = ascii digit
  4809 000012EF B402                    	mov	ah,2
  4810 000012F1 CD21                    	int	21h			; output the ascii digit
  4811 000012F3 58                      	pop	ax			; restore all digits
  4812                                  
  4813 000012F4 E2E4                    	loop	smDigit
  4814                                  	;jmp	short smRet
  4815                                  	; 14/01/2023
  4816                                  smRet:	
  4817 000012F6 59                      	pop	cx
  4818 000012F7 5B                      	pop	bx
  4819 000012F8 C3                      	retn
  4820                                  
  4821                                  ;*	Char substitution.
  4822                                  
  4823                                  smChar:
  4824                                  	;mov	dl,ds:[bx]		; DL = char to output
  4825 000012F9 8A17                    	mov	dl,[bx]
  4826 000012FB B402                    	mov	ah,2
  4827 000012FD CD21                    	int	21h
  4828 000012FF EBF5                    	jmp	short smRet
  4829                                  
  4830                                  ;*	String substitution.
  4831                                  
  4832                                  smStr:
  4833                                  	;mov	dl,ds:[bx]		; DL = next char
  4834 00001301 8A17                    	mov	dl,[bx]
  4835 00001303 08D2                    	or	dl,dl
  4836 00001305 74EF                    	jz	short smRet		; null char - we're done
  4837 00001307 B402                    	mov	ah,2
  4838 00001309 CD21                    	int	21h			; display char
  4839 0000130B 43                      	inc	bx			; DS:BX = ptr to next char
  4840 0000130C EBF3                    	jmp	short smStr
  4841                                  
  4842                                  ;smRet:	pop	cx
  4843                                  ;	pop	bx
  4844                                  ;	retn
  4845                                  
  4846                                  ;SubstMsg	endp
  4847                                  
  4848                                  	; MSDOS 6.0
  4849                                  ; ----------------------------------------------------------------------------
  4850                                  ;***	CharToUpper - convert character to uppercase
  4851                                  ;
  4852                                  ;	ENTRY	AL = char
  4853                                  ;
  4854                                  ;	EXIT	AL = uppercase char
  4855                                  ;
  4856                                  ;	USED	AX
  4857                                  ; ----------------------------------------------------------------------------
  4858                                  
  4859                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4860                                  
  4861                                  ;CharToUpper	proc
  4862                                  ;	assume	ds:DATARES
  4863                                  CharToUpper:
  4864 0000130E 50                      	push	ax		; put char on stack as arg to int 2F
  4865 0000130F B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4866 00001312 CD2F                    	int	2Fh
  4867 00001314 44                      	inc	sp		; throw away old char on stack
  4868 00001315 44                      	inc	sp
  4869 00001316 C3                      	retn
  4870                                  
  4871                                  ;CharToUpper	endp
  4872                                  
  4873                                  	; 14/01/2023
  4874                                  ;	; MSDOS 3.3
  4875                                  ;CHARTOUPPER:
  4876                                  ;	cmp	al,80h
  4877                                  ;	jb	short CHARTOUPPER1
  4878                                  ;	sub	al,80h
  4879                                  ;	push	ds
  4880                                  ;	push	bx
  4881                                  ;	lds	bx,[UPPERCASETBL]
  4882                                  ;	add	bx,2
  4883                                  ;	xlat
  4884                                  ;	pop	bx
  4885                                  ;	pop	ds
  4886                                  ;	jmp	short CHARTOUPPER_RETN
  4887                                  ;CHARTOUPPER1:
  4888                                  ;	cmp	al,'a'
  4889                                  ;	jb	short CHARTOUPPER_RETN
  4890                                  ;	cmp	al,'z'
  4891                                  ;	ja	short CHARTOUPPER_RETN
  4892                                  ;	sub	al,20h
  4893                                  ;CHARTOUPPER_RETN:
  4894                                  ;	retn
  4895                                  
  4896                                  ;public	EndCode
  4897                                  ;EndCode label byte
  4898                                  
  4899                                  	; MSDOS 6.0
  4900                                  ; ----------------------------------------------------------------------------
  4901                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4902                                  ;
  4903                                  ;	ENTRY	If we handle it -
  4904                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4905                                  ;		  DL = operation =
  4906                                  ;		     0 = get extended error messages
  4907                                  ;		     1 = set extended error messages
  4908                                  ;		     2 = get parse error messages
  4909                                  ;		     3 = set parse error messages
  4910                                  ;		     4 = get critical error messages
  4911                                  ;		     5 = set critical error messages
  4912                                  ;		     6 = get file system error messages
  4913                                  ;		     7 = set file system error messages
  4914                                  ;		     8 = get disk retriever routine
  4915                                  ;		     9 = set disk retriever routine
  4916                                  ;		  ES:DI = address for 'set' operations
  4917                                  ;
  4918                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4919                                  ;
  4920                                  ;	NOTE
  4921                                  ;	  This handler replaces the one that used to reside in DOS.
  4922                                  ;	  'Set' operations are ignored.
  4923                                  ;	  'File system error messages' are not supported.
  4924                                  ; ----------------------------------------------------------------------------
  4925                                  
  4926                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4927                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4928                                  ;SR;
  4929                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4930                                  ;segment address. Get them off the stack
  4931                                  
  4932                                  ;MsgInt2fHandler proc	far
  4933                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4934                                  
  4935                                  	; 14/01/2023
  4936                                  MsgInt2fHandler:
  4937 00001317 1F                      	pop	ds			; ds = DATARES
  4938                                  	;assume	ds:DATARES
  4939                                  ;	pop	word [OldDS]		; save old value of ds
  4940                                  
  4941 00001318 3D2E12                  	cmp	ax,122Eh
  4942                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4943                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4944 0000131B 742A                    	je	short miOurs		; it's ours
  4945                                  
  4946                                  ;ifndef ROMDOS
  4947                                  	;cmp	ax,5500h
  4948 0000131D 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4949                                  ;else
  4950                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4951                                  ;endif	;ROMDOS
  4952 00001320 741C                    	je	short fcOurs
  4953                                  
  4954                                  ;SR;
  4955                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4956                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4957                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4958                                  ;current value of ds as it points at the data segment. So we do some kinky
  4959                                  ;stack manipulations.
  4960                                  
  4961 00001322 50                      	push	ax
  4962 00001323 50                      	push	ax			; create 2 words on stack for retf
  4963                                  
  4964 00001324 55                      	push	bp
  4965 00001325 50                      	push	ax
  4966                                  
  4967 00001326 89E5                    	mov	bp,sp			; bp can be used to address stack
  4968                                  
  4969                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4970                                  ;do a 'pop ds' at the end to restore our ds
  4971                                  
  4972 00001328 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4973 0000132B 894604                  	mov	[bp+4],ax
  4974                                  	
  4975                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4976 0000132E A1[9B03]                	mov	ax,[Int2fHandler+2]
  4977 00001331 894608                  	mov	[bp+8],ax		; put segment address
  4978                                  	;mov	ax,word ptr ds:Int2fHandler
  4979 00001334 A1[9903]                	mov	ax,[Int2fHandler]
  4980 00001337 894606                  	mov	[bp+6],ax		; put offset address
  4981                                  
  4982 0000133A 58                      	pop	ax
  4983 0000133B 5D                      	pop	bp
  4984 0000133C 1F                      	pop	ds
  4985                                  
  4986 0000133D CB                      	retf				; chain on to next handler
  4987                                  
  4988                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4989                                  
  4990                                  fcOurs:
  4991                                  
  4992                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4993                                  
  4994 0000133E 58                      	pop	ax			; discard ds currently on stack
  4995 0000133F 1E                      	push	ds			; store our data segment
  4996                                  
  4997                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4998 00001340 BE[0400]                	mov	si,Int2f_Entry
  4999                                  
  5000 00001343 31C0                    	xor	ax,ax			; indicate COMMAND present
  5001 00001345 EB11                    	jmp	short miRet		; return to caller
  5002                                  
  5003                                  miOurs:
  5004 00001347 F6C201                  	test	dl,1
  5005 0000134A 750C                    	jnz	short miRet		; ignore 'set' operations
  5006                                  
  5007 0000134C 53                      	push	bx			; preserve BX
  5008 0000134D 89D3                    	mov	bx,dx
  5009 0000134F 30FF                    	xor	bh,bh			; BX = index in word table
  5010 00001351 D1E3                    	shl	bx,1			; BX = index in dword table
  5011                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5012 00001353 C4BF[5C06]              	les	di,[bx+MsgPtrLists]
  5013 00001357 5B                      	pop	bx			; restore BX
  5014                                  miRet:
  5015                                  ;	mov	ds,[OldDS]		; restore ds
  5016 00001358 1F                      	pop	ds
  5017                                  	;assume	ds:nothing
  5018                                  
  5019 00001359 CF                      	iret
  5020                                  
  5021                                  ;MsgInt2fHandler endp
  5022                                  
  5023                                  	; MSDOS 6.0
  5024                                  ; ----------------------------------------------------------------------------
  5025                                  ;***	MsgRetriever - message retrieval routine for utilities
  5026                                  ;
  5027                                  ;	Address of this routine is passed to utility programs via 
  5028                                  ;	message services int 2f. We try to find the desired message
  5029                                  ;	in memory or in our disk image.
  5030                                  ;
  5031                                  ;	ENTRY	AX = message #
  5032                                  ;		DI = offset in RESGROUP of msg ptr list
  5033                                  ;		ComSpec = asciiz pathname to our disk image
  5034                                  ;
  5035                                  ;	EXIT	CY clear for success
  5036                                  ;		ES:DI = ptr to count byte, followed by message text
  5037                                  ;
  5038                                  ;		CY set for failure
  5039                                  ;		ES,DI undefined
  5040                                  ;
  5041                                  ;	USED	flags
  5042                                  ;
  5043                                  ;	NOTE
  5044                                  ;	  The message # in AX is used to compute an offset into
  5045                                  ;	  the message ptr list pointed to by DI. The lists must
  5046                                  ;	  start with message # 1 and proceed through consecutive
  5047                                  ;	  message #'s.  
  5048                                  ;
  5049                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5050                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5051                                  ;	  valid message #.  ;M033
  5052                                  ;
  5053                                  ;	  List positions with no corresponding message text are
  5054                                  ;	  indicated by null pointers, which this routine detects.
  5055                                  ; ----------------------------------------------------------------------------
  5056                                  
  5057                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5058                                  
  5059                                  ;SR; This routine will be called directly by the utilities. So, we have
  5060                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5061                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5062                                  
  5063                                  ;MsgRetriever	proc	far
  5064                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5065                                  
  5066                                  	; 14/01/2023
  5067                                  MsgRetriever:
  5068 0000135A 1F                      	pop	ds			; ds = DATARES
  5069                                  	;assume	ds:DATARES
  5070                                  ;	pop	word [OldDS]		; save old ds
  5071                                  
  5072 0000135B 50                      	push	ax			; preserve registers
  5073 0000135C 53                      	push	bx
  5074 0000135D 51                      	push	cx
  5075 0000135E 52                      	push	dx
  5076 0000135F 56                      	push	si
  5077                                  
  5078                                  ;;	push	ds
  5079                                  ;;	push	cs
  5080                                  ;;	pop	ds			; DS = DATARES seg addr
  5081                                  ;;	assume	ds:RESGROUP
  5082                                  ;;	push	cs
  5083                                  
  5084 00001360 1E                      	push	ds			; get es from ds
  5085 00001361 07                      	pop	es			; ES = DATARES seg addr
  5086                                  
  5087                                  ;	Begin modification M033.
  5088                                  
  5089                                  ;	Make sure msg # is valid.
  5090                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5091                                  
  5092                                  	;mov	bx,11
  5093 00001362 BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5094                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5095 00001365 81FF[FB08]              	cmp	di,PARSMSGPTRS
  5096 00001369 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5097                                  	;mov	bx,90
  5098 0000136B BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5099                                  chkmsgnum:
  5100 0000136E 39C3                    	cmp	bx,ax
  5101 00001370 725A                    	jc	short mrRet		; msg # too high, return carry
  5102                                  
  5103                                  ;	Msg # is valid.
  5104                                  
  5105                                  ;	End modification M033.
  5106                                  
  5107 00001372 48                      	dec	ax
  5108 00001373 D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5109 00001375 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5110                                  
  5111 00001377 81FF[9D03]              	cmp	di,ResMsgEnd
  5112 0000137B 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5113                                  
  5114                                  ;*	Retrieve message from disk (or ROM) image.
  5115                                  ;	Read once to get the ptr to the message, then again for the message.
  5116                                  
  5117                                  ;ifndef	ROMDOS
  5118                                  	; 14/01/2023
  5119                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5120 0000137D BE[3601]                	mov	si,ComSpec
  5121 00001380 BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5122 00001383 BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5123 00001386 B8006C                  	mov	ax,6C00h
  5124                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5125 00001389 CD21                    	int	21h				; call DOS
  5126 0000138B 723F                    	jc	short mrRet			; return failure
  5127                                  
  5128 0000138D 89C3                    	mov	bx,ax				; BX = file handle
  5129 0000138F 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5130 00001391 31F6                    	xor	si,si				; SI = read count
  5131                                  mrRead:
  5132 00001393 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5133 00001397 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5134 00001399 B80042                  	mov	ax,4200h
  5135                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5136 0000139C CD21                    	int	21h				; call DOS
  5137 0000139E 721A                    	jc	short mrCloseFile		; handle error
  5138                                  
  5139                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5140 000013A0 BA[4903]                	mov	dx,MsgBuffer
  5141 000013A3 B94000                  	mov	cx,64				; CX = # bytes to read
  5142 000013A6 B43F                    	mov	ah,3Fh
  5143                                  	;mov	ah,READ				; AH = 'Read File'
  5144 000013A8 CD21                    	int	21h				; call DOS
  5145 000013AA 720E                    	jc	short mrCloseFile		; handle error
  5146                                  
  5147 000013AC 09F6                    	or	si,si				; (CY cleared)
  5148 000013AE 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5149 000013B0 46                      	inc	si				; mark one read done
  5150 000013B1 8B16[4903]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5151 000013B5 09D2                    	or	dx,dx
  5152 000013B7 75DA                    	jnz	short mrRead			; go read the message
  5153 000013B9 F9                      	stc					; null ptr found- no msg
  5154                                  
  5155                                  mrCloseFile:
  5156 000013BA 9C                      	pushf				; save success/failure (CY)
  5157 000013BB B43E                    	mov	ah,3Eh
  5158                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5159 000013BD CD21                    	int	21h			; call DOS
  5160                                  ;	Bugbug: should we avoid this popf?
  5161 000013BF 9D                      	popf				; CY = success/failure
  5162 000013C0 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5163 000013C2 EB08                    	jmp	short mrRet		; we're done
  5164                                  
  5165                                  ;else	;ROMDOS
  5166                                  ;
  5167                                  ;;	DI = ptr to msg ptr
  5168                                  ;
  5169                                  ;	mov	si,di			; SI = ptr to msg ptr
  5170                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5171                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5172                                  ;
  5173                                  ;;	ASSUME ES:NOTHING is still in effect.
  5174                                  ;
  5175                                  ;	push	ds
  5176                                  ;	pop	es				; ES = DATARES seg addr
  5177                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5178                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5179                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5180                                  ;	or	si,si
  5181                                  ;	jz	mrNoMsg			; null ptr- no message text
  5182                                  ;
  5183                                  ;	sub	si,100h			; SI = offset into image of msg
  5184                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5185                                  ;	mov	di,offset DATARES:MsgBuffer
  5186                                  ;	invoke	LoadFromROM
  5187                                  ;	clc					; success
  5188                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5189                                  ;	jmp	short mrRet
  5190                                  ;
  5191                                  ;mrNoMsg:
  5192                                  ;	stc
  5193                                  ;	jmp	short mrRet
  5194                                  ;
  5195                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5196                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5197                                  ;	assume	es:NOTHING
  5198                                  ;
  5199                                  ;endif	;ROMDOS
  5200                                  
  5201                                  ;*	Message ptr is in memory.
  5202                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5203                                  
  5204                                  mrInMem:
  5205                                  	; 14/01/2023
  5206 000013C4 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5207 000013C7 09FF                    	or	di,di			; (CY cleared)
  5208 000013C9 7501                    	jnz	short mrRet		; found message
  5209 000013CB F9                      	stc				; null ptr found - no message
  5210                                  mrRet:	
  5211 000013CC 5E                      	pop	si			; restore all registers
  5212 000013CD 5A                      	pop	dx
  5213 000013CE 59                      	pop	cx
  5214 000013CF 5B                      	pop	bx
  5215 000013D0 58                      	pop	ax
  5216                                  
  5217                                  ;	mov	ds,[OldDS]		; restore ds
  5218 000013D1 1F                      	pop	ds
  5219                                  	;assume	ds:nothing
  5220                                  
  5221 000013D2 CB                      	retf	; 21/04/2023
  5222                                  
  5223                                  ;MsgRetriever endp
  5224                                  
  5225                                  ; M003; Start of changes for UMB support
  5226                                  
  5227                                  ; ----------------------------------------------------------------------------
  5228                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5229                                  ;
  5230                                  ;	ENTRY	al = Saved alloc strat and link state
  5231                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5232                                  ;			b1 = 1 if link state to restore is Linked
  5233                                  ;
  5234                                  ;	EXIT	None
  5235                                  ;
  5236                                  ;	USED	ax, bx, cx
  5237                                  ; ----------------------------------------------------------------------------
  5238                                  
  5239                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5240                                  
  5241                                  ;public	Lh_OffUnlink
  5242                                  Lh_OffUnlink:	; proc	far
  5243                                  	; 14/01/2023
  5244 000013D3 88C5                    	mov	ch,al
  5245 000013D5 88C1                    	mov	cl,al
  5246                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5247                                  	;mov	ax,(ALLOCOPER<<8)
  5248 000013D7 B80058                  	mov	ax,5800h
  5249 000013DA CD21                    	int	21h
  5250 000013DC 89C3                    	mov	bx,ax
  5251 000013DE D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5252 000013E0 80E180                  	and	cl,80h				; mask off b6-b0
  5253 000013E3 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5254 000013E6 08CB                    	or	bl,cl				; set HighFirst bit state
  5255                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5256                                  	;mov	ax,(ALLOCOPER<<8)|1
  5257 000013E8 B80158                  	mov	ax,5801h
  5258 000013EB CD21                    	int	21h				; set alloc strat
  5259                                  
  5260 000013ED 88EB                    	mov	bl,ch
  5261 000013EF D0EB                    	shr	bl,1
  5262 000013F1 30FF                    	xor	bh,bh				; bx = linkstate
  5263                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5264                                  	;mov	ax,(ALLOCOPER<<8)|3
  5265 000013F3 B80358                  	mov	ax,5803h
  5266 000013F6 CD21                    	int	21h				; set linkstate
  5267                                  
  5268 000013F8 CB                      	retf
  5269                                  
  5270                                  ;Lh_OffUnlink endp
  5271                                  
  5272                                  ; M003; End of changes for UMB support
  5273                                  
  5274                                  ;public	EndCode
  5275                                  ; 14/01/2023
  5276                                  ;EndCode: ; label byte
  5277                                  ; 06/06/2023
  5278                                  ; 16/04/2023
  5279                                  EndCode equ ($-StartCode)+100h
  5280                                  ; 06/06/2023
  5281                                  ;EndCode equ $-StartCode	
  5282                                  
  5283                                  ;CODERES ends
  5284                                  ;	end
  5285                                  
  5286                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5287                                  
  5288 000013F9 00<rep 7h>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5289                                  
  5290                                  ;align 16
  5291                                  
  5292                                  ;=============================================================================
  5293                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5294                                  ;=============================================================================
  5295                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5296                                  
  5297                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5298                                  
  5299                                  ;TITLE   COMMAND Initialization
  5300                                  
  5301                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5302                                  ;ENVIRONSIZ2 EQU 092H
  5303                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5304                                  
  5305                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5306                                  ; 23/09/2018
  5307                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5308                                  ; 14/01/2023
  5309                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5310                                  
  5311                                  ; ----------------------------------------------------------------------------
  5312                                  
  5313                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5314                                  
  5315                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5316                                  ENVIRONSIZ equ 160
  5317                                  ENVSML	equ 256	; minimum environment size
  5318                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5319                                  MAX_COMSPEC equ 146
  5320                                  ECOMSPEC equ 14
  5321                                  
  5322                                  ; 14/01/2023
  5323                                  TAB_CHAR equ 09h
  5324                                  SPACE_CHAR equ 20h	
  5325                                  
  5326                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5327                                  ;ENVIRONSIZ equ 180	; SIZE Environment 
  5328                                  
  5329                                  ;----------------------------------------------------
  5330                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5331                                  ;----------------------------------------------------
  5332                                  ;Environment Struc	; Default COMMAND environment
  5333                                  ;
  5334                                  ;Env_PathString  db	"path="
  5335                                  ;Env_PathSpec	 db	"c:\msdos"
  5336                                  ;                db	0
  5337                                  ;Env_PrmptString db	"prompt="
  5338                                  ;Env_PrmptSpec   db	"$p$g"
  5339                                  ;                db	0
  5340                                  ;Env_ComString   db	"comspec="
  5341                                  ;Env_ComSpec     db	"\command.com"
  5342                                  ;		 db	134 dup (0)
  5343                                  ;
  5344                                  ;Environment ends
  5345                                  ;----------------------------------------------------
  5346                                  
  5347                                  ;-----------------------------------------------------------------------------
  5348                                  
  5349                                  ;-----------------------------------------------------------------------------
  5350                                  ; START OF INIT PORTION
  5351                                  ; This code is deallocated after initialization.
  5352                                  ;-----------------------------------------------------------------------------
  5353                                  
  5354                                  ;INIT	SEGMENT PUBLIC PARA
  5355                                  
  5356                                  ; 	EXTRN   HEADER:BYTE
  5357                                  ;	EXTRN   BADCOMLKMES:BYTE
  5358                                  
  5359                                  ;	PUBLIC  CONPROC
  5360                                  
  5361                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5362                                  
  5363                                          ;ORG 0
  5364                                  ;ZERO = $
  5365                                  	; 23/09/2018
  5366                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5367                                  
  5368                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5369                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5370                                  ConProc:
  5371                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5372 00001400 BC[1E04]                	mov	sp,RStack
  5373                                  
  5374                                  ; We need to set the PSP to us right at start because Carousel needs
  5375                                  ; to be lied to and it does not set PSP when it transfers control to
  5376                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5377                                  ; command.com is also not lied to.
  5378                                  
  5379                                  	; 14/01/2023
  5380                                  	; MSDOS 6.0
  5381 00001403 B450                            mov	ah,50h
  5382                                  	;mov	ah,SET_CURRENT_PDB
  5383 00001405 8CC3                            mov	bx,es
  5384 00001407 CD21                            int	21h
  5385                                  
  5386                                  	; 14/01/2023
  5387 00001409 B430                    	mov	ah,30h 
  5388                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5389                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5390                                  	;mov	ax,3000h
  5391 0000140B CD21                    	int	21h
  5392                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5393                                  	;cmp	ax,5
  5394 0000140D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5395 00001410 7411                    	je	short okdos			; DOS version is ok
  5396                                  
  5397 00001412 BA[181D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5398 00001415 E85DFE                  	call	RPrint
  5399                                  
  5400                                  	; MSDOS 3.3
  5401                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5402                                  	;int	21h             ; DOS - PRINT STRING
  5403                                  				; DS:DX -> string terminated by "$"
  5404 00001418 8CC0                    	mov	ax,es
  5405 0000141A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5406                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5407                                  Here:	
  5408 0000141F 74FE                    	jz	short Here			;  loop forever
  5409                                  	
  5410 00001421 CD20                    	int	20h				; otherwise, exit
  5411                                  okdos:
  5412                                  	; 23/09/2018
  5413                                  
  5414                                  ;  Calculate and save the end of the INIT segment (which is also
  5415                                  ;  the beginning of TRANGROUP).
  5416                                  
  5417                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5418                                  	; MSDOS 3.3
  5419                                  	;mov	ah,65h
  5420                                  	;mov	al,2
  5421                                  	;mov	dx,-1
  5422                                  	;mov	bx,-1
  5423                                  	;mov	cx,5
  5424                                  	;mov	di,UCASE_ADDR
  5425                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5426                                  	;		; AL = 02h : Get pointer to character translation table
  5427                                  	;		; BX = code page (-1 = current global code page)
  5428                                  	;		; DX = country ID (-1 = current country)
  5429                                  	;		; CX = amount of data to return
  5430                                  	;; ES:DI = pointer to output buffer
  5431                                  	;; Buffer offset :
  5432                                  	;;	00h -  byte,  country Id
  5433                                  	;;  	01h -  dword, pointer to uppercase table	
  5434                                  
  5435                                  	; 14/01/2023
  5436                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5437                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5438 00001423 BA0F22                  	mov	dx,TRANSTART+15			; get end of init code
  5439                                  	; 27/09/2018
  5440                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5441 00001426 B104                    	mov	cl,4				; change to paragraphs
  5442 00001428 D3EA                            shr	dx,cl				;
  5443 0000142A 8CC8                            mov     ax,cs                           ; get current segment
  5444 0000142C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5445 0000142E A3[7C1C]                        mov     [initend],ax			; save this
  5446                                  
  5447                                  	; 14/01/2023
  5448                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5449                                  
  5450                                  ;  Check for /? on the command line. If found, display help text and exit.
  5451                                  ;  NOTE: this routine may terminate the program, never returning.
  5452                                  
  5453 00001431 E86A06                  	call	CheckHelp
  5454                                  
  5455                                  ; We have to patch the segment values for the various interrupt entry points.
  5456                                  ; This is because we need to have the default addresses of the handlers in our
  5457                                  ; stub before the relocation is done. These values will then be changed once
  5458                                  ; the resident is relocated
  5459                                  
  5460 00001434 E8A507                  	call	patch_segs
  5461                                  
  5462                                  ;  Turn APPEND off during initialization processing
  5463                                  
  5464                                  	; 14/01/2023
  5465 00001437 B800B7                  	mov     ax,0B700h
  5466                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5467 0000143A CD2F                    	int	2Fh				;
  5468                                  	;cmp	al,0				; append installed?
  5469 0000143C 08C0                    	or	al,al
  5470 0000143E 7418                    	jz	short set_msg_addr		; no - continue
  5471                                  	
  5472 00001440 B802B7                  	mov	ax,0B702h
  5473                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5474 00001443 CD2F                    	int	2Fh				;
  5475                                  	;cmp	ax,-1				; append version correct?
  5476                                  	;jne	short set_msg_addr		; no - continue
  5477 00001445 40                      	inc	ax ; -1 -> 0
  5478 00001446 7510                    	jnz	short set_msg_addr        
  5479                                  	
  5480 00001448 B806B7                  	mov     ax,0B706h
  5481                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5482 0000144B CD2F                    	int	2Fh				;
  5483 0000144D 891E[AB01]                      mov     [Append_State],bx		; save append state
  5484                                         
  5485 00001451 31DB                    	xor	bx,bx                           ; clear out state
  5486 00001453 B807B7                  	mov	ax,0B707h
  5487                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5488 00001456 CD2F                    	int	2Fh				; set everything off
  5489                                  
  5490                                  set_msg_addr:
  5491                                  	; 14/01/2023
  5492                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5493                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5494                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5495 00001458 BF[1D08]                	mov	di,DataresEnd
  5496 0000145B 893E[9D03]              	mov	[ResMsgEnd],di			; save it
  5497                                  
  5498 0000145F E88C07                          call    get_XMMAddr                     ; get XMM call address
  5499                                  
  5500                                  ; Check if this is the first instance of command.com. If not, we just exit
  5501                                  ; this routine without moving any code.
  5502                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5503                                  ; stub. We just have to copy this over
  5504                                  	
  5505                                  ;ifndef ROMDOS
  5506 00001462 B80055                  	mov	ax,5500h
  5507                                  	;mov	ax,GET_COMMAND_STATE	
  5508                                  ;else
  5509                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5510                                  ;endif ; ROMDOS
  5511                                  
  5512 00001465 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5513                                  	;assume	ds:nothing
  5514                                  
  5515                                  	; 03/05/2023
  5516                                  	; Return:
  5517                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5518                                  	;   DS:SI -> entry point table
  5519                                  
  5520                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5521                                  
  5522 00001467 09C0                    	or	ax,ax
  5523 00001469 750C                    	jnz	short first_com			; this is the first instance
  5524                                  
  5525                                  	; 14/01/2023
  5526 0000146B 268936[BC20]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5527 00001470 268C1E[BE20]            	mov	[es:ResJmpTable+2],ds
  5528 00001475 EB06                    	jmp	short init_cntry
  5529                                  
  5530                                  first_com:
  5531 00001477 26C606[C020]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5532                                  
  5533                                  init_cntry:
  5534                                  	; 14/01/2023
  5535 0000147D 06                      	push	es
  5536 0000147E 1F                      	pop	ds
  5537                                  	;assume	ds:RESGROUP
  5538                                  
  5539 0000147F B465                    	mov	ah,65h
  5540                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5541 00001481 B004                    	mov	al,4				; get file ucase table
  5542 00001483 BAFFFF                  	mov	dx,-1				;
  5543                                  	;mov	bx,-1				;
  5544 00001486 89D3                    	mov	bx,dx
  5545 00001488 B90500                  	mov	cx,5				; number of bytes we want
  5546                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5547 0000148B BF[9E01]                	mov	di,FUCase_Addr
  5548 0000148E CD21                    	int	21h
  5549                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5550                                  		; AL = function -
  5551                                  
  5552                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5553                                  
  5554 00001490 1E                      	push	ds				;
  5555 00001491 B80063                  	mov	ax,6300h
  5556                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5557 00001494 CD21                    	int	21h				;
  5558                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5559                                  			
  5560 00001496 8CDB                    	mov	bx,ds				; get segment to bx
  5561 00001498 1F                      	pop	ds				;
  5562 00001499 8936[A701]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5563 0000149D 891E[A901]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5564                                  
  5565                                  	;mov	ax,[16h]
  5566 000014A1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5567                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5568 000014A4 A3[2901]                	mov	[Parent],ax			;  correctly.
  5569 000014A7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5570 000014AA A3[2B01]                	mov	[OldTerm],ax
  5571 000014AD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5572 000014B0 A3[2D01]                	mov	[OldTerm+2],ax
  5573                                  
  5574                                  	; 14/01/2023
  5575                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5576                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5577                                  	;mov	ax,EndCode+15
  5578                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5579                                  	; 14/01/2023
  5580                                  	;mov	cl,4				; ax = size of resident part of
  5581                                  	;shr	ax,cl				;  command in paragraphs. Add
  5582                                  	;mov	cx,cs				;  this to CS and you get the
  5583                                  	;add	ax,cx				;  segment of the TPA.
  5584                                  
  5585 000014B3 8CC8                    	mov	ax,cs
  5586 000014B5 055001                  	add	ax,(EndCode+15)>>4
  5587                                  	
  5588 000014B8 A3[4503]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5589 000014BB 2500F0                  	and     ax,0F000h
  5590 000014BE 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5591 000014C1 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5592 000014C3 A1[4503]                	mov     ax,[Res_Tpa]
  5593                                  TpaSet:
  5594 000014C6 A3[3903]                	mov	[LTpa],ax			; Good enough for the moment
  5595                                  	;mov	ax,[2]
  5596 000014C9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5597                                  
  5598 000014CC 8C1E[3F03]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5599 000014D0 8C1E[4303]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5600 000014D4 8C1E[3703]              	mov	[MySeg],ds			;  use to call resident routines.
  5601                                  	; 19/04/2023
  5602                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5603 000014D8 8C1E[6E06]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5604                                  
  5605 000014DC A3[8001]                	mov	[MemSiz],ax			; Needed for execing other programs
  5606                                  
  5607                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5608                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5609                                  
  5610                                  ; First reallocate the COMMAND size to its memory image
  5611                                  	
  5612 000014DF 50                      	push	ax    
  5613                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5614                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5615                                  	;mov	bx,TRANSTART
  5616                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5617                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5618                                  	;add	bx,15 ; *			; round up the size
  5619                                  
  5620                                  	; 03/05/2023
  5621                                  	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5622                                  	;;add	bx,TRANSPACEEND
  5623                                  	; 06/06/2023
  5624                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5625                                          ;mov	cl,4				;
  5626                                          ;shr	bx,cl				; size of command.com
  5627 000014E0 BB770B                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
  5628                                  	
  5629 000014E3 B44A                    	mov	ah,4Ah
  5630                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5631 000014E5 CD21                            int     21h				;
  5632 000014E7 58                              pop     ax				;
  5633                                  	
  5634                                  ; Compute maximum size of environment
  5635                                  
  5636                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5637                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5638                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5639                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5640                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5641 000014E8 C706[701C]4C00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5642                                  ;
  5643                                  ; Compute minimum size of environment
  5644                                  ;
  5645                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5646                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5647 000014EE C706[6E1C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5648                                  
  5649                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5650                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5651                                  	; 06/06/2023
  5652                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5653                                  	;mov	cl,4				;  in paragraphs.
  5654                                  	;shr	dx,cl
  5655 000014F4 BA5709                  	mov	dx,(TRANSPACEEND+15)>>4
  5656 000014F7 8916[7E1C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5657                                  
  5658 000014FB 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5659 000014FD A3[7A01]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5660                                  	;mov	ax,[2Ch]
  5661 00001500 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5662                                  
  5663                                  	; 14/01/2023
  5664                                          ; MSDOS 6.0
  5665                                  	;mov	[EnvirSeg],ax
  5666                                          
  5667                                  	; 21/01/2023
  5668 00001503 09C0                    	or	ax,ax				; if there is no environment segment,
  5669 00001505 7406                    	jz	short buildenv			; make one
  5670                                    
  5671                                  	; 21/01/2023
  5672                                  	; MSDOS 3.3 & MSDOS 5.0
  5673                                  	;inc	byte [CHUCKENV]
  5674 00001507 FE06[521C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5675                                  	
  5676                                  	; MSDOS 3.3 & MSDOS 5.0
  5677 0000150B EB03                    	jmp	short environpassed
  5678                                  	; MSDOS 6.0
  5679                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5680                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5681                                  
  5682                                  	; MSDOS 6.0
  5683                                  
  5684                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5685                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5686                                  ; size and free this buffer. We need this buffer because we no longer have an
  5687                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5688                                  ; given on the command line before we know the environment size. This routine
  5689                                  ; will not return in case of an allocation error. It will either exit or hang
  5690                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5691                                  
  5692                                  	; 14/01/2023
  5693                                  buildenv:
  5694 0000150D E87206                  	call	alloc_env                       ; try to allocate buffer
  5695                                  environpassed:
  5696                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5697 00001510 A3[2703]                	mov	[EnvirSeg],ax
  5698                                  	;
  5699 00001513 8EC0                    	mov	es,ax                           ; and it load into es.
  5700                                  	;assume	es:nothing
  5701                                  
  5702                                  gottheenvir:
  5703                                  
  5704                                  ; Initialize the command drive
  5705                                  
  5706                                  ; 14/01/2023
  5707                                  %if 0
  5708                                  	; MSDOS 3.3
  5709                                  BUILDENV:
  5710                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5711                                  	mov	ax,PATHSTRING ; "PATH="
  5712                                  	mov	cl,4
  5713                                  	shr	ax,cl
  5714                                  	mov	dx,ds
  5715                                  	add	ax,dx
  5716                                  ENVIRONPASSED:
  5717                                          mov	[ENVIRSEG],ax
  5718                                          MOV     es,ax
  5719                                  
  5720                                          ;mov	ax,CHAR_OPER<<8
  5721                                          mov	ax,CHAR_OPER*256 ; 3700h
  5722                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5723                                  			; Return: AL = FFh unsupported subfunction
  5724                                  			; DL = current switch character
  5725                                          mov	[RSWITCHAR],dl
  5726                                  
  5727                                          ;CMP	dl,'/'
  5728                                  	cmp	dl,[slash_chr]
  5729                                          jnz	short IUSESLASH
  5730                                  
  5731                                  	;mov	al,'\'
  5732                                   	mov	al,[bslash_chr]
  5733                                  	mov	[COMSPECT],al
  5734                                  
  5735                                  	cmp	byte [CHUCKENV],0
  5736                                  	jnz	short IUSESLASH
  5737                                  
  5738                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5739                                  	; 30/04/2018
  5740                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5741                                  	; 23/09/2018
  5742                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5743                                  gottheenvir:
  5744                                  IUSESLASH:
  5745                                  
  5746                                  ; Initialize the command drive
  5747                                  
  5748                                  %endif
  5749                                  	; 14/01/2023
  5750                                  	; MSDOS 3.3 & MSDOS 6.0
  5751 00001515 B419                    	mov	ah,19h
  5752                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5753 00001517 CD21                    	int	21h
  5754 00001519 FEC0                    	inc	al
  5755 0000151B A2[7F01]                	mov	[ComDrv],al
  5756                                  
  5757                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5758 0000151E A05C00                          mov	al,[FCB]
  5759 00001521 08C0                    	or	al,al
  5760 00001523 7426                    	jz	short nocomdrv		; no drive specified
  5761                                  
  5762 00001525 B43A                    	mov	ah,':'
  5763 00001527 A2[7F01]                	mov	[ComDrv],al
  5764 0000152A 0440                    	add	al,40h			; convert number to uppercase character
  5765                                  
  5766 0000152C FD                      	std
  5767                                  
  5768                                  	; MSDOS 6.0
  5769                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5770                                  	;je	short notwidenv		;  move the default comspec string in it
  5771                                  	; 14/01/2023
  5772                                  	; MSDOS 5.0 COMMAND.COM
  5773                                  	;mov	di,[ComspOffset]
  5774                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5775                                          ;je	short notwidenv		; yes, must have been inherited that way
  5776                                  
  5777                                  	; MSDOS 3.3
  5778                                  	;cmp	byte [CHUCKENV],0
  5779                                  	;jne	short NOTWIDENV
  5780                                  	; 21/01/2021
  5781                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5782 0000152D 803E[521C]00             	cmp	byte [AllocedEnv],0
  5783 00001532 7713                    	ja	short notwidenv
  5784                                  
  5785 00001534 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5786 00001535 06                      	push	es			;  the drivespec is in ax and is copied
  5787 00001536 1F                      	pop	ds			;  on to the front of the string.
  5788                                  
  5789                                  	; MSDOS 6.0
  5790                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5791                                          ;lea	di,[di+MAX_COMSPEC-1]
  5792                                  
  5793                                  	; 21/01/2023
  5794                                  	; 14/01/2023
  5795                                  	; MSDOS 5.0 COMMAND.COM
  5796                                  	; MSDOS 3.3
  5797                                  	; 23/09/2018
  5798                                  	; 30/04/2018
  5799                                  	;mov	di,159
  5800                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5801                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5802 00001537 BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5803                                  	;mov	si,157
  5804                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5805                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5806 0000153A BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5807                                  	;mov	cx,144
  5808                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5809 0000153D B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5810                                  
  5811 00001540 F3A4                    	rep	movsb
  5812 00001542 1F                      	pop	ds
  5813                                  
  5814                                  	; MSDOS 6.0
  5815                                  	;mov	word ptr es:[di-1],ax
  5816                                  
  5817                                  	; MSDOS 3.3
  5818                                  	;mov	[es:0Eh],ax
  5819                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5820                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5821                                  	; 14/01/2023
  5822 00001543 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5823                                  
  5824                                  	; MSDOS 3.3 & MSDOS 6.0
  5825                                  notwidenv:
  5826 00001547 FC                      	cld
  5827 00001548 A3[341C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5828                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5829                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5830                                  	;mov	[KAUTOBAT],ax
  5831                                  nocomdrv:
  5832 0000154B E8A4FA                  	call	SetVect        ; Set the vectors
  5833                                  
  5834                                  ; parsing starts here
  5835                                  
  5836                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5837                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5838                                  	; MSDOS 6.0
  5839 0000154E 0E                      	push	cs
  5840 0000154F 0E                      	push	cs
  5841 00001550 1F                      	pop	ds
  5842 00001551 07                      	pop	es
  5843                                  	;assume ds:ResGroup,es:ResGroup
  5844                                  
  5845                                  ; 14/01/2023
  5846                                  %if 0	
  5847                                  	; MSDOS 3.3
  5848                                  	mov	si,80h		; get command line
  5849                                  	lodsb			; get length of line
  5850                                  	mov	cl,al
  5851                                  	xor	ch,ch		; cx = length of command line
  5852                                  
  5853                                  ; insure that the command line correctly ends with a cr
  5854                                  
  5855                                  	add	si,cx		; go to end of command line	
  5856                                  	mov	byte [si], 0Dh	; insert a carriage return
  5857                                  
  5858                                  	mov	si,81h		; Start of parms
  5859                                  CHKARG:
  5860                                          jcxz	COMRETURNSJ     ; No parameters
  5861                                          dec	cx
  5862                                  	lodsb
  5863                                  CHECKSWITCHCHR:
  5864                                  	;cmp	al,' '
  5865                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5866                                  	jz	short CHKARG
  5867                                  	cmp	al,9		; Skip TAB characters
  5868                                  	jz	short CHKARG
  5869                                  	cmp	al,[RSWITCHAR]	; Switch?
  5870                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5871                                  	jmp	CHKOTHERARGS	; No
  5872                                  
  5873                                  %endif
  5874                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5875                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5876                                  	; MSDOS 6.0
  5877                                  
  5878 00001552 BE8000                  	mov	si,80h				; get command line
  5879 00001555 AC                      	lodsb					; get length of line
  5880 00001556 89F7                    	mov	di,si				; get line position in di
  5881 00001558 30E4                    	xor	ah,ah				; ax = length of command line
  5882                                  
  5883                                  ; insure that the command line correctly ends with a cr
  5884                                  
  5885 0000155A 01C7                    	add	di,ax				; go to end of command line
  5886 0000155C C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5887 0000155F 31C9                    	xor	cx,cx				; clear cx
  5888 00001561 890E[141D]                      mov	[num_positionals],cx		; initialize positionals
  5889                                  
  5890                                  ; Scan the command line looking for the parameters
  5891                                  
  5892                                  Parse_command_line:
  5893                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5894 00001565 BF[861C]                	mov	di,PARSE_COMMAND
  5895 00001568 8B0E[141D]              	mov	cx,[num_positionals]		; Get number of positionals
  5896 0000156C 31D2                    	xor	dx,dx				; clear dx
  5897 0000156E 8936[161D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5898                                  	;call	dword ptr Init_Parse
  5899 00001572 FF1E[7A1C]              	call	far [Init_Parse]		; call parser
  5900 00001576 890E[141D]                      mov     [num_positionals],cx		; Save number of positionals
  5901                                  	; 29/01/2023
  5902                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5903                                          ;cmp	ax,-1
  5904                                  	;jne	short t1
  5905                                  	; 10/06/2023
  5906 0000157A 40                      	inc	ax	 ; cmp ax,-1
  5907 0000157B 7503                    	jnz	short t1 ; 0FFFFh -> 0
  5908                                  	; ax = 0
  5909 0000157D E9FB01                  	jmp     ArgsDone                        ; yes - exit
  5910                                  t1:	
  5911                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5912                                  	;;cmp	ax,0
  5913                                  	;and	ax,ax
  5914                                  	; 10/06/2023
  5915 00001580 48                      	dec	ax  ; cmp ax,0
  5916 00001581 7447                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  5917                                  
  5918                                  ; Before issuing error message - make sure switch is not /C
  5919                                  
  5920                                  parse_line_error:
  5921                                  	; 14/01/2023
  5922                                  	;push	si				; save line position
  5923                                  	;push	ax				; save error number
  5924                                  	;cmp	ax,3
  5925 00001583 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5926                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5927 00001586 752A                    	jne	short parse_line_error_disp2
  5928 00001588 56                      	push	si ; **				; save line position
  5929 00001589 50                      	push	ax ; *				; save error number
  5930 0000158A 89F7                    	mov	di,si				; Get terminating pointer in DI
  5931 0000158C 8B36[161D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5932                                  
  5933                                  init_chk_delim:
  5934 00001590 39FE                    	cmp	si,di				; at end of parsed parameter?
  5935 00001592 741C                            je	short parse_line_error_disp	; Yes - just display message
  5936 00001594 AC                      	lodsb					;
  5937 00001595 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5938                                  	;cmp	al,space_chr ; 14/01/2023
  5939                                  	;;cmp	al,[space]			; Skip blank spaces
  5940 00001597 74F7                    	je	short init_chk_delim		;
  5941                                  	;cmp	al,9
  5942 00001599 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5943 0000159B 74F3                    	je	short init_chk_delim		;
  5944                                  
  5945 0000159D 3A06[3B03]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5946 000015A1 750D                            jne	short parse_line_error_disp	; No - just issue message
  5947 000015A3 AC                      	lodsb					; Get the char after the switch
  5948                                  
  5949 000015A4 E86804                  	call	iupconv 			; upper case it
  5950                                  
  5951                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5952                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5953                                  	;16/04/2023
  5954 000015A7 3C43                    	cmp	al,'C' ; scswitch
  5955 000015A9 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5956 000015AB 5A                      	pop	dx ; *				; even up stack
  5957 000015AC 5A                      	pop	dx ; **				; even up stack
  5958 000015AD E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5959                                  
  5960                                  	; MSDOS 6.0
  5961                                  ;check_k_too:
  5962                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  5963                                          ;jne	short parse_line_error_disp	;
  5964                                  	;pop	dx ; *				; even up stack
  5965                                  	;pop	dx ; **				; even up stack
  5966                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5967                                  
  5968                                  parse_line_error_disp:
  5969                                  	; 14/01/2023
  5970 000015B0 58                      	pop	ax ; *				; restore error number
  5971 000015B1 5E                      	pop	si ; **				; restore line position
  5972                                  parse_line_error_disp2:
  5973 000015B2 89C2                    	mov	dx,ax				; get message number
  5974 000015B4 E8FC03                  	call	RPrintParse
  5975 000015B7 E8B8FC                  	call	crlf
  5976 000015BA EBA9                            jmp     short Parse_command_line        ; continue parsing
  5977                                  
  5978                                  ; 16/04/2023
  5979                                  %if 1
  5980                                  SetMSwitch:
  5981                                          ;cmp	byte [ext_msg],1
  5982 000015BC 803E[811C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5983                                  	; 16/04/2023
  5984                                  	;jnz	short setMswitchok		; no - set it
  5985                                  	;;mov	ax,1
  5986                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5987                                  	;jmp	parse_line_error                ; go issue error message
  5988                                  	; 16/04/2023
  5989 000015C1 744F                    	je	short parse_line_error_j
  5990                                  setMswitchok:
  5991                                          ;mov	byte [ext_msg],1
  5992 000015C3 C606[811C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  5993                                  	; 06/06/2023
  5994 000015C8 EB9B                    	jmp	short Parse_command_line	; keep parsing
  5995                                  %endif
  5996                                  
  5997                                  parse_cont:
  5998                                  
  5999                                  ; 15/01/2023
  6000                                  %if 0
  6001                                  	; MSDOS 3.3
  6002                                  
  6003                                  ; See if a switch was entered
  6004                                  
  6005                                  	jcxz	COMRETURNSJ
  6006                                  	dec	cx
  6007                                  	lodsb
  6008                                  	or	al,20h		; Lower case
  6009                                  	cmp	al,'f'		; FAIL switch
  6010                                  	jnz     short CHECKPSWITCH
  6011                                  %endif
  6012                                  
  6013                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6014                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6015                                  	; MSDOS 6.0
  6016                                  
  6017                                  ; See if a switch was entered
  6018                                  ;
  6019                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6020                                  
  6021 000015CA 813E[0D1D][BD1C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6022 000015D0 742A                    	je	short SetFSwitch		; yes go set fail switch
  6023 000015D2 813E[0D1D][B11C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6024 000015D8 7431                    	je	short SetPSwitch		; yes go set up PERMCOM
  6025 000015DA 813E[0D1D][C91C]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6026 000015E0 7453                    	je	short SetDSwitch		; yes go set date switch
  6027 000015E2 813E[0D1D][EE1C]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6028 000015E8 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6029                                  	; MSDOS 6.0 only!
  6030                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6031                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  6032 000015EA 813E[0D1D][D51C]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6033 000015F0 7467                    	je	short SetESwitch		; yes go set up environment
  6034 000015F2 813E[0D1D][FA1C]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6035                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6036                                  	; 15/01/2023
  6037 000015F8 74C2                    	je	short SetMSwitch 
  6038 000015FA EB7B                    	jmp	ChkOtherArgs		; Must be something else
  6039                                  
  6040                                  	; MSDOS 6.0
  6041                                  ;SetMSwitchjmp:
  6042                                  	;jmp	SetMSwitch
  6043                                  	
  6044                                  	; MSDOS 6.0
  6045                                  SetFSwitch:
  6046 000015FC 803E[9201]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6047                                  	; 16/04/2023
  6048                                  	;jne	short failok		; no - set it
  6049                                  	;;mov	ax,1
  6050                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6051                                          ;jmp	parse_line_error        ; go issue error 
  6052                                  	; 16/04/2023
  6053 00001601 740F                    	je	short parse_line_error_j
  6054                                  
  6055                                  	; MSDOS 3.3 & MSDOS 6.0
  6056                                  failok:
  6057 00001603 C606[9201]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6058                                  	; MSDOS 3.3
  6059                                  	;jmp	short CHKARG
  6060                                  	; MSDOS 6.0
  6061 00001608 E95AFF                  	jmp	Parse_command_line
  6062                                  
  6063                                  ;CHECKPSWITCH:
  6064                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6065                                  	;cmp	al,[letter_p]
  6066                                          ;jnz	short CHECKDSWITCH
  6067                                  
  6068                                  SetPSwitch:
  6069                                  
  6070                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6071                                  ; termination address.
  6072                                  
  6073                                  	; MSDOS 6.0
  6074 0000160B 803E[8D01]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6075 00001610 7406                    	jz	short permcomok		; no - set it
  6076                                  	; 16/04/2023
  6077                                  parse_line_error_j:
  6078                                          ;mov	ax,1
  6079 00001612 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6080 00001615 E96BFF                          jmp	parse_line_error	; go issue error 
  6081                                  
  6082                                  permcomok:
  6083                                  	; MSDOS 3.3 & MSDOS 6.0
  6084 00001618 FE06[8D01]              	inc	byte [PermCom]
  6085                                  	;mov	word [OLDTERM],LODCOM
  6086 0000161C C706[2B01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6087                                  	;mov	[OLDTERM+2],ds
  6088 00001622 8C1E[2D01]              	mov	[OldTerm+2],ds
  6089                                  
  6090                                  ; make sure that we display the date and time. if the flag was not
  6091                                  ; initialized, set it to indicate yes, do prompt.
  6092                                  
  6093                                  	; MSDOS 3.3
  6094                                  	;cmp	byte [PRDATTM],-1
  6095                                  	;jnz	short CHKARG
  6096                                  	;mov	byte [PRDATTM],0
  6097                                  	;jmp	short CHKARG
  6098                                  
  6099                                  	; MSDOS 6.0
  6100 00001626 803E[451C]FF            	cmp	byte [PRDATTM],-1
  6101 0000162B 7505                    	jne	short Parse_command_line_jmp
  6102 0000162D C606[451C]00            	mov	byte [PRDATTM],0
  6103                                  Parse_command_line_jmp:
  6104 00001632 E930FF                  	jmp     Parse_command_line	; keep parsing
  6105                                  
  6106                                  ;COMRETURNSJ:
  6107                                  ;	; MSDOS 3.3
  6108                                  ;	JMP	ARGSDONE
  6109                                  
  6110                                  ;CHECKDSWITCH:
  6111                                  	;;cmp	al,'d'
  6112                                          ;cmp	al,[letter_d]
  6113                                  	;jnz	short CHECKCSWITCH
  6114                                  
  6115                                  SetDSwitch:
  6116                                  
  6117                                  ; Flag no date/time prompting.
  6118                                  
  6119                                  	; MSDOS 6.0
  6120 00001635 803E[831C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6121                                  	; 16/04/2023
  6122                                  	;jz	short setdateok		; no - set it
  6123                                          ;;mov	ax,1
  6124                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6125                                          ;jmp	parse_line_error	; go issue error message
  6126                                  	; 16/04/2023
  6127 0000163A 75D6                    	jnz	short parse_line_error_j
  6128                                  setdateok:
  6129 0000163C FE06[831C]              	inc	byte  [dswitch]		; indicate /D entered
  6130                                  
  6131                                  	; MSDOS 3.3 & MSDOS 6.0
  6132 00001640 C606[451C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6133                                  	; MSDOS 3.3
  6134                                  	;jmp	short CHKARG
  6135                                  	; MSDOS 6.0
  6136 00001645 E91DFF                  	jmp     Parse_command_line	; continue parsing
  6137                                  
  6138                                  	; 15/01/2023
  6139                                  	; MSDOS 6.0 
  6140                                  ;SetKSwitch:
  6141                                  	;mov	byte [SemiPermCom],0
  6142                                  	;jmp	short SetSorKSwitch
  6143                                  
  6144                                  ;CHECKCSWITCH:
  6145                                  	;;cmp	al,'c'
  6146                                  	;cmp	al,[letter_c]
  6147                                          ;jnz	short CHECKESWITCH
  6148                                  
  6149                                  SetSSwitch:
  6150                                  ;SETCSWITCH:
  6151                                  
  6152                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6153                                  
  6154 00001648 C606[8D01]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6155                                  ;SetSorKSwitch:
  6156 0000164D 8936[8E01]              	mov	[SingleCom],si		; Point to the rest of the command line
  6157 00001651 C606[451C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6158                                  ;COMRETURNSJ: ; 24/09/2018
  6159 00001656 E92201                  	jmp     ArgsDone
  6160                                  
  6161                                  ;CHECKESWITCH:
  6162                                  	;cmp	al,'e'
  6163                                  	;jnz	short CHKARG
  6164                                  
  6165                                  ; Look for environment-size setting switch
  6166                                  
  6167                                  ; The environment size is represented in decimal bytes and is
  6168                                  ; converted into paragraphs (rounded up to the next paragraph).
  6169                                  
  6170                                  SetESwitch:
  6171                                  	; MSDOS 6.0
  6172 00001659 803E[821C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6173                                  	; 16/04/2023
  6174                                  	;jz	short eswitchok		; no - set it
  6175                                  	;;mov	ax,1
  6176                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6177                                          ;jmp	parse_line_error	; go issue error message
  6178                                  	; 16/04/2023
  6179 0000165E 75B2                    	jnz	short parse_line_error_j
  6180                                  eswitchok:
  6181 00001660 FE06[821C]              	inc	byte [eswitch]		; indicate /E entered
  6182                                  
  6183                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6184                                  %if 0
  6185                                  	; 23/09/2018 - Retro DOS v3.0
  6186                                  
  6187                                  	; MSDOS 3.3
  6188                                  	; (COMMAND.COM offset 0FC5h)
  6189                                  ESWITCHOK:
  6190                                  	jcxz    CHKARG
  6191                                  	dec     cx
  6192                                  	lodsb
  6193                                  	cmp     al,':'
  6194                                  	jnz     short CHECKSWITCHCHR
  6195                                  	xor     bx,bx
  6196                                  	mov     ax,bx
  6197                                  GETENVSIZE:
  6198                                  	jcxz    SETENVSIZE
  6199                                  	dec     cx
  6200                                  	lodsb
  6201                                  	cmp     al,'0'
  6202                                  	jb      short NOTDECIMALCHR
  6203                                  	cmp     al,'9'
  6204                                  	ja      short NOTDECIMALCHR
  6205                                  	sub     al,'0'
  6206                                  	mov     dx,bx
  6207                                  	shl     dx,1
  6208                                  	shl     dx,1   ; dx = 4*bx
  6209                                  	add     bx,dx  ; bx = 5*bx
  6210                                  	shl     bx,1   ; bx = 10*bx
  6211                                  	add     bx,ax
  6212                                  	jmp     short GETENVSIZE
  6213                                  
  6214                                  NOTDECIMALCHR:
  6215                                  	;cmp	al,' '
  6216                                  	cmp	al,[SPACE_CHAR]
  6217                                  	jz      short CHECKENVSIZE
  6218                                  	;cmp	al,'/'
  6219                                  	cmp     al,[RSWITCHAR]
  6220                                  	jz      short CHECKENVSIZE
  6221                                  
  6222                                  CHECKNEXTECHR:
  6223                                  	jcxz    INVENVSIZE
  6224                                  	dec     cx
  6225                                  	lodsb
  6226                                  	;cmp	al,' '
  6227                                  	cmp     al,[SPACE_CHR]
  6228                                  	jz      short ENVSIZESPC
  6229                                  	;cmp	al,'/'
  6230                                  	cmp     al,[RSWITCHAR]
  6231                                  	jnz     short CHECKNEXTECHR
  6232                                  
  6233                                  ENVSIZESPC:
  6234                                  	dec     si
  6235                                  	inc     cx
  6236                                  	jmp     short INVENVSIZE
  6237                                  	
  6238                                  	;nop
  6239                                  
  6240                                  CHECKENVSIZE: 
  6241                                  	dec     si
  6242                                  	inc     cx
  6243                                  
  6244                                  SETENVSIZE:
  6245                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6246                                  	mov	word [ENVSIZ],ENVBIG/16
  6247                                  	cmp     bx,32768
  6248                                  	ja      short INVENVSIZE
  6249                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6250                                  	mov	word [ENVSIZ],ENVSML/16
  6251                                  	cmp     bx,160
  6252                                  	jb      short INVENVSIZE
  6253                                  	add     bx,15
  6254                                  	shr     bx,1
  6255                                  	shr     bx,1
  6256                                  	shr     bx,1
  6257                                  	shr     bx,1
  6258                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6259                                  	jmp     short NEXTCH2
  6260                                  
  6261                                  	;nop
  6262                                  
  6263                                  INVENVSIZE:
  6264                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6265                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6266                                  	int     21h             ; DOS - PRINT STRING
  6267                                  				; DS:DX -> string terminated by "$"
  6268                                  NEXTCH2:
  6269                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6270                                  	jmp     CHKARG
  6271                                  
  6272                                  	;jmp	ARGSDONE
  6273                                  
  6274                                  %endif
  6275                                  	; 15/01/2023
  6276                                  	; MSDOS 6.0
  6277                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6278 00001664 BF[0F1D]                        mov	di,COMND1_ADDR
  6279 00001667 8B1D                    	mov     bx,[di]				; into bx
  6280                                  
  6281 00001669 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6282 0000166C B104                    	mov	cl,4				; convert to pargraphs
  6283 0000166E D3EB                    	shr	bx,cl				; by right 4
  6284                                  
  6285 00001670 891E[6E1C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6286 00001674 E9EEFE                  	jmp	Parse_command_line		; continue parsing command line
  6287                                  
  6288                                  ; 16/04/2023
  6289                                  %if 0
  6290                                  SetMSwitch:
  6291                                          ;cmp	byte [ext_msg],1
  6292                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6293                                  	jnz	short setMswitchok		; no - set it
  6294                                  	;mov	ax,1
  6295                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6296                                  	jmp	parse_line_error                ; go issue error message
  6297                                  setMswitchok:
  6298                                          ;mov	byte [ext_msg],1
  6299                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6300                                  	jmp	Parse_command_line              ; keep parsing
  6301                                  %endif
  6302                                  
  6303                                  ;ArgsDoneJ:
  6304                                  	;jmp	ArgsDone
  6305                                  
  6306                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6307                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6308                                  	
  6309                                  ChkOtherArgs:
  6310                                  
  6311                                  ; We have a non-switch character here.
  6312                                  
  6313                                  	; MSDOS 6.0
  6314 00001677 1E                      	push	ds ; ****			;
  6315 00001678 56                      	push	si ; *** 			; save place in command line
  6316 00001679 C536[0F1D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6317                                  	;assume	ds:nothing			;
  6318                                  
  6319 0000167D 89F2                    	mov	dx,si				; put in dx also
  6320 0000167F B8023D                  	mov	ax,3D02h
  6321                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6322 00001682 CD21                    	int	21h
  6323 00001684 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6324 00001686 89C3                    	mov	bx,ax
  6325 00001688 B80044                  	mov	ax,4400h
  6326                                  	;mov	ax,IOCTL shl 8
  6327 0000168B CD21                    	int	21h
  6328 0000168D F6C280                  	test	dl,80h
  6329 00001690 7506                    	jnz	short IsaDevice
  6330                                  BadSetCon:
  6331 00001692 B43E                    	mov	ah,3Eh
  6332                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6333 00001694 CD21                    	int	21h
  6334 00001696 EB4E                    	jmp	short ChkSrchSpec
  6335                                  
  6336                                  ; 15/01/2023
  6337                                  %if 0
  6338                                  	; MSDOS 3.3
  6339                                  	; (COMMAND.COM offset 1047h)
  6340                                          dec	si
  6341                                  	inc	cx
  6342                                  	mov	dx,si
  6343                                  	push	cx ; **
  6344                                  	push	si ; *
  6345                                  CONTRLOOP:
  6346                                  	lodsb
  6347                                  	dec	cx
  6348                                  	;cmp	al,' '
  6349                                  	cmp	al,[SPACE_CHR]
  6350                                  	jz	short SETCDEV
  6351                                  	cmp	al,9
  6352                                  	jz	short SETCDEV
  6353                                  	jcxz	SETCDEVA
  6354                                  	jmp	short CONTRLOOP
  6355                                  
  6356                                  SETCDEVA:
  6357                                          inc	si
  6358                                  SETCDEV:
  6359                                  	mov	byte [SI-1],0
  6360                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6361                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6362                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6363                                  			; DS:DX -> ASCIZ filename
  6364                                  			; AL = access mode
  6365                                  			; 2 - read & write
  6366                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6367                                          mov	bx,ax
  6368                                          ;mov	ax,IOCTL shl 8
  6369                                          mov     ax,IOCTL*256 ; 4400h
  6370                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6371                                  			; BX = file or device handle
  6372                                          test	dl,80H
  6373                                  	jnz	short ISADEVICE
  6374                                  BADSETCON: ; MSDOS 6.0
  6375                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6376                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6377                                  			; BX = file handle
  6378                                          JMP     short CHKSRCHSPEC
  6379                                  %endif
  6380                                  	;nop
  6381                                  
  6382                                  	; 15/01/2023
  6383                                  IsaDevice:
  6384                                  	; MSDOS 3.3 & MSDOS 6.0
  6385 00001698 30F6                    	xor	dh,dh
  6386 0000169A 80CA03                  	or	dl,3				; Make sure has CON attributes
  6387                                  	;mov	ax,(IOCTL shl 8) or 1
  6388 0000169D B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6389 000016A0 CD21                    	int	21h
  6390                                  	;
  6391                                  	; 15/01/2023
  6392 000016A2 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6393                                  	; 25/09/2018
  6394                                  	;pop	dx ; *
  6395                                  	;pop	dx ; **
  6396                                  	;
  6397                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6398                                  	
  6399 000016A4 89DA                    	mov	dx,bx				; Save new handle
  6400                                  
  6401                                  	; MSDOS 6.0
  6402 000016A6 26803E[C120]01          	cmp	byte [es:DevFlag],1
  6403 000016AC 742A                    	jz	short DevErr
  6404                                  
  6405                                  	; MSDOS 3.3
  6406                                          ;pop	bx ; *				; Throw away saved SI
  6407                                          ;pop	bx ; **				; Throw away saved CX
  6408                                  
  6409                                  	; MSDOS 3.3 & MSDOS 6.0
  6410 000016AE 51                      	push	cx ; **
  6411 000016AF B90300                  	mov	cx,3
  6412 000016B2 31DB                    	xor	bx,bx
  6413                                  
  6414                                  	; 15/01/2023
  6415                                  rcclloop:
  6416 000016B4 B43E                    	mov	ah,3Eh
  6417                                  	;mov	ah,CLOSE ; 3Eh
  6418 000016B6 CD21                    	int	21h
  6419 000016B8 43                      	inc	bx
  6420 000016B9 E2F9                    	loop	rcclloop
  6421                                  
  6422 000016BB 89D3                    	mov	bx,dx				; New device handle
  6423 000016BD B445                    	mov	ah,45h
  6424                                  	;mov	ah,XDUP ; 45h
  6425 000016BF CD21                    	int	21h				; Dup to 0
  6426 000016C1 B445                    	mov	ah,45h
  6427                                  	;mov	ah,XDUP
  6428 000016C3 CD21                    	int	21h				; Dup to 1
  6429 000016C5 B445                    	mov	ah,45h
  6430                                  	;mov	ah,XDUP
  6431 000016C7 CD21                    	int	21h				; Dup to 2
  6432 000016C9 B43E                    	mov	ah,3Eh
  6433                                  	;mov	ah,CLOSE
  6434 000016CB CD21                    	int	21h				; Close initial handle
  6435                                  	
  6436 000016CD 59                      	pop	cx ; **
  6437                                  	
  6438                                  	; MSDOS 6.0
  6439 000016CE 5E                      	pop	si ; ***			; restore position of command line
  6440 000016CF 1F                      	pop	ds ; ****			;
  6441                                  
  6442                                  ; Register the fact that we already have redirected the output
  6443                                  ; and can not do it again
  6444                                  
  6445 000016D0 26FE06[C120]            	inc	byte [es:DevFlag]		
  6446 000016D5 E98DFE                  	jmp	Parse_command_line		; continue parsing
  6447                                  
  6448                                  	; MSDOS 3.3
  6449                                  	;jcxz	ARGSDONEJ2
  6450                                  	;jmp	CHKARG
  6451                                  
  6452                                  	; MSDOS 6.0
  6453                                  DevErr:
  6454 000016D8 5E                      	pop	si ; ***
  6455 000016D9 1F                      	pop	ds ; ****
  6456 000016DA BA0100                  	mov	dx,1
  6457 000016DD E8D302                          call	RPrintParse                     ; "Too many parameters"
  6458 000016E0 E88FFB                          call	crlf
  6459 000016E3 E97FFE                  	jmp	Parse_command_line
  6460                                  
  6461                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6462                                  	; MSDOS 6.0
  6463 000016E6 26803E[C220]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6464 000016EC 74EA                            jz	short DevErr			; yes, error
  6465                                  	
  6466 000016EE 26FE06[C220]                    inc	byte [es:PathFlag]		; mark that we have a path
  6467                                  
  6468                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6469                                  ; This buffer will later be replaced by a proper environment
  6470                                  
  6471                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6472                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6473 000016F3 36A1[2703]              	mov	ax,[ss:EnvirSeg]
  6474                                  	
  6475                                  	; MSDOS 6.0
  6476                                  	;call	alloc_env                       ; environment buffer
  6477                                  
  6478                                  	; 15/01/2023
  6479                                  	; MSDOS 5.0
  6480 000016F7 36803E[521C]01          	cmp	byte [ss:AllocedEnv],1
  6481 000016FD 36C606[521C]00          	mov	byte [ss:AllocedEnv],0
  6482 00001703 7507                    	jne     short env_alloced
  6483 00001705 E87A04                  	call	alloc_env
  6484 00001708 36A3[2703]              	mov	[ss:EnvirSeg],ax
  6485                                  
  6486                                  env_alloced:
  6487                                  	; MSDOS 5.0 & MSDOS 6.0
  6488 0000170C 8EC0                    	mov	es,ax
  6489                                  	;assume	es:nothing
  6490 0000170E 56                      	push	si ; **				; remember location of file
  6491 0000170F 31C9                    	xor	cx,cx				; clear cx for counting
  6492                                  	
  6493                                  	; 15/01/2023
  6494                                  countloop:
  6495 00001711 AC                      	lodsb					; get a character
  6496 00001712 41                      	inc	cx				; increment counter
  6497                                          ;;cmp	al,0
  6498                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6499                                  	;jne	short countloop			; no - keep counting
  6500 00001713 08C0                    	or	al,al	
  6501 00001715 75FA                    	jnz	short countloop
  6502                                  
  6503                                  	;;;;mov	al,[Space]
  6504                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6505                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6506                                  	; 16/04/2023
  6507                                  	;mov	al,20h ; ' ' 
  6508 00001717 4E                      	dec	si				; move back one
  6509                                          ;mov	[si],al				; put a space at end of line
  6510 00001718 C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6511                                  
  6512                                  ; We now know how long the new pathspec for command.com is. Time to
  6513                                  ; figure out how long the current COMSPEC setting is, and then to move
  6514                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6515                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6516                                  ; where the filespec exists in the environment) is updated as well.
  6517                                  
  6518                                  	; MSDOS 6.0 COMMAND.COM
  6519                                  	;push	cx                              ;
  6520                                          ;mov	cx,ENVBIG                       ;
  6521                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6522                                          ;mov	al,0                            ;
  6523                                          ;repne	scasb                           ; find the end of COMSPEC
  6524                                          ;mov	si,di                           ;
  6525                                  ;comp_endenv:                                   ;
  6526                                          ;scasb                                  ; end of env?
  6527                                          ;je	got_endenv                      ; yes
  6528                                          ;repne	scasb                           ;
  6529                                          ;jmp	comp_endenv                     ;
  6530                                  ;got_endenv:                                    ;
  6531                                          ;mov    cx,di                           ;
  6532                                          ;sub    cx,si                           ;
  6533                                          ;mov    di,ComspOffset                  ;
  6534                                          ;sub    di,ComspStrLen                  ;
  6535                                          ;push   ds                              ;
  6536                                          ;push   es                              ;
  6537                                          ;pop    ds                              ;
  6538                                          ;rep    movsb                           ;
  6539                                          ;dec    di                              ; copy in new COMSPEC=
  6540                                          ;push   cs                              ;
  6541                                          ;pop    ds                              ;
  6542                                          ;assume ds:ResGroup                     ;
  6543                                          ;mov    si,offset RESGROUP:ComspString  ;
  6544                                          ;mov    cx,ComspStrLen                  ;
  6545                                          ;rep    movsb                           ;
  6546                                          ;mov    ComspOffset,di                  ;
  6547                                          ;pop    ds                              ;
  6548                                          ;assume ds:nothing                      ;
  6549                                          ;pop    cx                              ;
  6550                                  	;
  6551                                          ;pop    si                              ; get new comspec location back
  6552                                  
  6553                                  	; MSDOS 3.3 COMMAND.COM
  6554                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6555                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6556                                  	;mov	cl,4
  6557                                  	;shr	ax,cl
  6558                                  	;mov	dx,ds
  6559                                  	;add	ax,dx
  6560                                  	;mov	[ENVIRSEG],ax
  6561                                  	;mov	es,ax
  6562                                  	;;mov	al,' '
  6563                                  	;mov	al,[SPACE_CHR]
  6564                                  	;mov	[si-1],al
  6565                                  	;pop	si ; **				; Remember location
  6566                                  	;pop	cx ; *				; and count
  6567                                  	;;mov	di,[ECOMLOC]
  6568                                  	;mov	di,[COMSPOFFSET]
  6569                                  
  6570                                  	; 15/01/2023
  6571                                  	; MSDOS 5.0 COMMAND.COM
  6572 0000171B 5E                      	pop	si ; **
  6573                                  	;mov	di,14
  6574 0000171C BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6575                                  
  6576                                  ComtrLoop:
  6577                                  	; MSDOS 3.3 & MSDOS 6.0
  6578 0000171F AC                      	lodsb
  6579 00001720 49                      	dec	cx
  6580                                  	;;;;cmp	al,' '
  6581                                  	;;;cmp	al,[space_chr]
  6582                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6583                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6584                                  	; 16/04/2023
  6585 00001721 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6586 00001723 7405                    	je	short SetComsr
  6587                                  	; MSDOS 3.3
  6588                                  	;cmp	al,9
  6589                                  	;je	short SetComsr
  6590                                  	; MSDOS 3.3 & MSDOS 6.0
  6591 00001725 AA                      	stosb
  6592 00001726 E302                    	jcxz	SetComsr
  6593 00001728 EBF5                    	jmp	short ComtrLoop
  6594                                  
  6595                                  SetComsr:
  6596                                  	; 15/01/2023
  6597                                  	; MSDOS 6.0
  6598 0000172A 51                      	push	cx ; **
  6599 0000172B 0E                      	push	cs				; Get local segment
  6600 0000172C 1F                      	pop	ds				;
  6601                                  	;assume	ds:ResGroup			;
  6602 0000172D 1E                      	push	ds ; *
  6603                                  	;mov	si,offset ResGroup:ComSpect
  6604 0000172E BE[261C]                	mov	si,COMSPECT
  6605 00001731 B90E00                  	mov	cx,14
  6606 00001734 268A45FF                	mov	al,[es:di-1]
  6607 00001738 3A06[3C03]              	cmp	al,[RDirChar]
  6608 0000173C 7502                    	jne	short iNotRoot
  6609 0000173E 46                      	inc	si				; Don't make a double /
  6610 0000173F 49                      	dec	cx
  6611                                  	
  6612                                  	; MSDOS 3.3
  6613                                  	;push	si
  6614                                  	;push	cx
  6615                                  	;push	ds
  6616                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6617                                  	;mov	cx,14
  6618                                  	;mov	al,[es:di-1]
  6619                                  	;call	PATHCHRCMPR
  6620                                  	;jnz	short INOTROOT			
  6621                                  	;inc	si				; Don't make a double /
  6622                                  	;dec	cx
  6623                                  
  6624                                  iNotRoot:
  6625                                  	; MSDOS 3.3 & MSDOS 6.0
  6626 00001740 F3A4                    	rep	movsb
  6627                                  
  6628                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6629                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6630                                  	; 15/01/2023
  6631                                  	;mov	dx,14
  6632 00001742 BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6633                                  
  6634 00001745 06                      	push	es
  6635 00001746 1F                      	pop	ds
  6636                                  	;;mov	ax,OPEN shl 8
  6637                                  	;mov	ax,OPEN*256 ; 3D00h
  6638 00001747 B8003D                  	mov	ax,3D00h ; 15/01/2023
  6639 0000174A CD21                    	int	21h				; Open COMMAND.COM
  6640 0000174C 1F                      	pop	ds ; *
  6641 0000174D 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6642 0000174F 89C3                    	mov	bx,ax				; Handle
  6643 00001751 B43E                    	mov	ah,3Eh ; 15/01/2023
  6644                                  	;mov	ah,CLOSE ; 3Eh
  6645 00001753 CD21                    	int	21h				; Close COMMAND.COM
  6646                                  SetComsrRet:
  6647                                  	; 15/01/2023
  6648 00001755 59                      	pop	cx ; **
  6649 00001756 5E                      	pop	si ; ***
  6650                                  
  6651                                  	; MSDOS 6.0
  6652 00001757 1F                      	pop	ds ; ****			;
  6653                                  	;assume	ds:ResGroup			;
  6654                                  	;
  6655 00001758 0E                      	push	cs				; Make sure local ES is
  6656 00001759 07                      	pop	es				;  restored
  6657 0000175A E908FE                  	jmp	Parse_command_line		; continue parsing command line
  6658                                  
  6659                                  	; MSDOS 3.3
  6660                                  ;ARGSDONEJ2:
  6661                                  	;jcxz	ARGSDONE
  6662                                  	;jmp	CHKARG
  6663                                  
  6664                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6665                                  SetComsrBad:
  6666                                  	; MSDOS 3.3 & MSDOS 6.0
  6667                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6668 0000175D BA[AA1D]                	mov	dx,BADCOMLKMES
  6669                                  
  6670                                  ;	Note: we're about to make a near call to TriageError, which
  6671                                  ;	lives in a different segment and group. Some linkers will
  6672                                  ;	generate a warning like "Possible fix-up overflow". We're
  6673                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6674                                  ;	we're still all together.
  6675                                  
  6676                                  	; 16/01/2023
  6677                                  	TRIAGEERROR equ TRANSTART+TriageError
  6678                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6679                                  
  6680                                  	;call	50B2h
  6681 00001760 E8(784E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6682                                  				; in original MSDOS 3.3 COMMAND.COM
  6683                                  
  6684                                  			; TriageError procedure is at offset 50B2h
  6685                                  			; in original MSDOS 5.0 COMMAND.COM	
  6686 00001763 83F841                  	cmp	ax,65
  6687 00001766 7503                    	jne	short doprt
  6688                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6689 00001768 BA[D31D]                	mov	dx,BADCOMACCMSG
  6690                                  doprt:
  6691 0000176B E807FB                  	call	RPrint
  6692                                  	;mov	si,offset ResGroup:ComSpect
  6693 0000176E BE[261C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6694                                  	;;mov	di,[ECOMLOC]
  6695                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6696                                  	; 16/01/2023
  6697 00001771 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6698 00001774 B90E00                  	mov	cx,14
  6699 00001777 F3A4                    	rep	movsb				; get my default back
  6700                                  
  6701 00001779 EBDA                    	jmp	short SetComsrRet
  6702                                  
  6703                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6704                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6705                                  ArgsDone:
  6706                                  	; MSDOS 6.0
  6707 0000177B 8E06[2703]              	mov	es,[EnvirSeg]			; get environment back
  6708                                  	;assume	es:nothing			;
  6709                                  
  6710                                  	; MSDOS 3.3 & MSDOS 6.0
  6711 0000177F 803E[8D01]00                    cmp	byte [PermCom],0
  6712 00001784 742E                            jz	short ComReturns
  6713                                  
  6714 00001786 06                      	push	es				; Save environment pointer
  6715 00001787 B450                    	mov	ah,50h
  6716                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6717 00001789 8CDB                    	mov	bx,ds
  6718 0000178B 8EC3                    	mov	es,bx
  6719 0000178D CD21                    	int	21h				; current process is me
  6720 0000178F BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6721                                  	;;mov	ax,offset RESGROUP:LODCOM
  6722                                  	;mov	ax,LODCOM
  6723                                  	; 16/01/2023
  6724 00001792 B8[7E00]                	mov	ax,LodCom_Trap
  6725 00001795 AB                              stosw
  6726 00001796 8CD8                            mov	ax,ds
  6727 00001798 AB                              stosw
  6728                                  	;;mov	ax,offset RESGROUP:CONTC
  6729                                  	;mov	ax,CONTC
  6730                                  	; 16/01/2023
  6731 00001799 B8[4A00]                	mov	ax,Ctrlc_Trap
  6732 0000179C AB                              stosw
  6733 0000179D 8CD8                            mov	ax,ds
  6734 0000179F AB                              stosw
  6735                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6736                                  	;mov	ax,CRITERR
  6737                                  	; 16/01/2023
  6738 000017A0 B8[5500]                	mov	ax,CritErr_Trap
  6739 000017A3 AB                      	stosw
  6740 000017A4 8CD8                    	mov     ax,ds
  6741 000017A6 AB                      	stosw
  6742                                  	;;mov	word ptr ds:16h,ds
  6743                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6744 000017A7 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6745                                          ;;mov	dx,offset RESGROUP:Int_2e
  6746                                  	;mov	dx,Int_2e
  6747                                          ; 16/01/2023
  6748 000017AB BA[3F00]                	mov	dx,Int2e_Trap
  6749 000017AE B82E25                  	mov	ax,252Eh
  6750                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6751                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6752 000017B1 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6753                                  			; AL = interrupt number
  6754                                  			; DS:DX = new vector to be used for specified interrupt
  6755 000017B3 07                              pop	es				; Remember environment
  6756                                  	
  6757                                  ComReturns:
  6758                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6759 000017B4 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6760                                  	; 16/01/2023
  6761 000017B7 A3[2901]                	mov	[Parent],ax			; Save parent
  6762                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6763 000017BA 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6764                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6765 000017BE A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6766 000017C1 A3[8A01]                        mov	[Io_Save],ax		; Get the default stdin and out
  6767 000017C4 8C1E[2B03]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6768 000017C8 8C1E[2F03]                      mov	[Com_Fcb1+2],ds
  6769 000017CC 8C1E[3303]              	mov	[Com_Fcb2+2],ds
  6770                                          ;mov	di,offset ResGroup:ComSpec
  6771 000017D0 BF[3601]                        mov	di,ComSpec
  6772                                  
  6773                                  	;;mov	si,[ECOMLOC]
  6774                                  	; 16/01/2023
  6775                                  	;mov	si,[ComspOffset]
  6776 000017D3 BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6777 000017D6 803E[521C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6778                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6779                                  	
  6780 000017DB 8CD8                    	mov	ax,ds				; Xchg es,ds
  6781 000017DD 06                      	push	es
  6782 000017DE 1F                      	pop	ds
  6783 000017DF 8EC0                    	mov	es,ax
  6784                                  
  6785                                  	;jne	short CopyComsp ; MSDOS 6.0
  6786                                  	; 16/01/2023	
  6787 000017E1 7417                    	je	short CopyComsp ; MSDOS 5.0
  6788                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6789                                  
  6790 000017E3 0E                              push	cs
  6791 000017E4 1F                              pop	ds
  6792                                  
  6793                                          ;mov	si,offset ResGroup:ComspString
  6794 000017E5 BE[591C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6795 000017E8 06                      	push	es
  6796 000017E9 57                      	push	di
  6797 000017EA E8D701                  	call	IfindE
  6798 000017ED 89FE                    	mov	si,di
  6799 000017EF 06                      	push	es
  6800 000017F0 1F                      	pop	ds
  6801 000017F1 5F                      	pop	di
  6802 000017F2 07                      	pop	es
  6803 000017F3 7305                            jnc	short CopyComsp
  6804                                  
  6805                                  	; MSDOS 6.0
  6806                                  ComSpecNofnd:
  6807                                  	;mov	si,offset ResGroup:ComspString
  6808                                  	;add	si,ComspStrLen
  6809                                  	;push	cs
  6810                                  	;pop	ds
  6811                                  
  6812                                  	; 21/01/2023
  6813                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6814                                  	;mov	si,0Eh
  6815 000017F5 BE0E00                  	mov	si,ECOMSPEC
  6816 000017F8 0E                      	push	cs
  6817 000017F9 1F                      	pop	ds	
  6818                                  
  6819                                  	; 21/01/2023
  6820                                  ;COMSPECNOFND:
  6821                                  	; MSDOS 3.3
  6822                                          ;;mov	si,[es:ECOMLOC]
  6823                                          ;mov	si,[es:COMSPOFFSET]
  6824                                  	;;add	si,offset RESGROUP:PATHSTRING
  6825                                          ;add	si,PATHSTRING ; "PATH="
  6826                                  	;push	cs
  6827                                  	;pop	ds
  6828                                  
  6829                                  CopyComsp:
  6830                                  	; 21/01/2023
  6831                                  ;COPYCOMSP:
  6832                                  	; MSDOS 3.3 & MSDOS 6.0
  6833                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6834                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6835 000017FA 26893E[1501]            	mov	[es:PutBackComSpec],di
  6836 000017FF 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6837 00001803 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6838                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6839                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6840 00001805 268306[1501]02          	add	word [es:PutBackComSpec],2
  6841                                  CopyComspLoop:
  6842 0000180B AC                      	lodsb
  6843 0000180C AA                      	stosb
  6844 0000180D 08C0                    	or	al,al
  6845 0000180F 75FA                    	jnz	short CopyComspLoop
  6846                                  
  6847 00001811 26893E[7601]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6848 00001816 26FF0E[7601]            	dec	word [es:ComSpec_End]
  6849 0000181B 268A26[7F01]            	mov	ah,[es:ComDrv]
  6850 00001820 80C440                  	add	ah,'A'-1 ; 40h
  6851 00001823 268826[1A01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6852                                  
  6853                                  	; -------------------------------
  6854                                  
  6855                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6856                                  %if 0
  6857                                  
  6858                                  	; MSDOS 3.3
  6859                                  	push	cs
  6860                                          pop	ds
  6861                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6862                                  	mov	bx,DATARESEND+15
  6863                                          mov	cl,4
  6864                                          shr	bx,cl
  6865                                          MOV     AH,SETBLOCK ; 4Ah
  6866                                          int	21h			; Shrink me to the resident only
  6867                                  
  6868                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6869                                  
  6870                                  	mov	byte [TRNMVFLG], 1
  6871                                  	push	es ; *
  6872                                  	mov	si,TRANSTART
  6873                                  	mov	di,0
  6874                                  	mov	es,[TrnSeg]
  6875                                  	;mov	cx,4D5Ch
  6876                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6877                                  	push	cx
  6878                                  	mov	ax,cx
  6879                                  	add	ax,si
  6880                                  	mov	cl,4
  6881                                  	shr	ax,cl
  6882                                  	inc	ax
  6883                                  	mov	cx,ds
  6884                                  	add	ax,cx
  6885                                  	cmp	ax,[TrnSeg]
  6886                                  	pop	cx
  6887                                  	jb	short MOV_DOWN
  6888                                  
  6889                                  	call	LOADCOM
  6890                                  	jmp	short ICHKSUM
  6891                                  
  6892                                  MOV_DOWN:
  6893                                  	add     si,cx
  6894                                  	dec     si
  6895                                  	add     di,cx
  6896                                  	dec     di
  6897                                  	std
  6898                                  	rep	movsb
  6899                                  	cld
  6900                                  
  6901                                  ICHKSUM:
  6902                                  	; 24/09/2018
  6903                                  ;
  6904                                  ; Compute checksum right now before we can get corrupted and save it
  6905                                  ;
  6906                                  	; MSDOS 6.0
  6907                                  	;mov	si,offset RESGROUP:TranStart
  6908                                  	;add	si,100h
  6909                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6910                                  	;
  6911                                  	;cld
  6912                                  	;shr	cx,1
  6913                                  	;xor	dx,dx
  6914                                  ;Ichksum:
  6915                                  	;lodsw
  6916                                  	;add	dx,ax
  6917                                  	;adc	dx,0
  6918                                  	;loop	Ichksum
  6919                                  	;
  6920                                          ;mov	Sum,dx			; store checksum
  6921                                  
  6922                                  	; MSDOS 3.3
  6923                                  	pop     es ; *
  6924                                  	call    CHKSUM
  6925                                  	mov     [SUM],dx
  6926                                  
  6927                                  	; MSDOS 3.3 & MSDOS 6.0
  6928                                          cmp     byte [PRDATTM],0	;
  6929                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6930                                  ;
  6931                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6932                                  ;
  6933                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6934                                  	;mov	bx,3
  6935                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6936                                          mov     ah,ALLOC ; 48h		;
  6937                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6938                                  			; BX = number of 16-byte paragraphs desired
  6939                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6940                                          mov     [BATCH],ax		; save batch segment
  6941                                  
  6942                                  NOBATCHSEG:
  6943                                  
  6944                                  %endif
  6945                                  	; -------------------------------
  6946                                  
  6947                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6948                                  	
  6949                                  	; MSDOS 6.0
  6950 00001828 E81002                  	call	setup_for_messages		; set up parse and extended error messages
  6951                                  
  6952                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6953                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6954                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6955                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6956                                  ; the data otherwise it is just the data.
  6957                                   
  6958 0000182B E8A702                  	call	Setup_res_end			; put resident size in ResSize
  6959                                  
  6960 0000182E 0E                      	push	cs
  6961 0000182F 1F                      	pop	ds
  6962                                  	;assume	ds:RESGROUP
  6963                                  
  6964                                  ;Public EnvMaximum
  6965                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6966                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6967                                  
  6968                                  	; 21/01/2023
  6969                                  	; MSDOS 6.0
  6970                                  	;;mov	si,offset RESGROUP:TranStart
  6971                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6972                                  	;mov	si,TRANSTART
  6973                                  	;add	si,100h
  6974                                  	; 23/04/2023
  6975 00001830 BE0023                  	mov	si,TRANSTART+100h
  6976                                  
  6977                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6978                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6979 00001833 B9[F084]                	mov	cx,TRANDATAEND-100h
  6980                                  
  6981 00001836 FC                      	cld
  6982 00001837 D1E9                    	shr	cx,1
  6983 00001839 31D2                    	xor	dx,dx
  6984                                  Ichksum:
  6985 0000183B AD                      	lodsw
  6986 0000183C 01C2                    	add	dx,ax
  6987 0000183E 83D200                  	adc	dx,0
  6988 00001841 E2F8                    	loop	Ichksum
  6989                                  
  6990 00001843 8916[8201]                      mov	[Sum],dx			; store checksum
  6991                                  
  6992 00001847 803E[451C]00                    cmp     byte [PRDATTM],0
  6993 0000184C 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6994                                  	
  6995                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6996                                  
  6997                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6998                                  	; 21/01/2023
  6999                                  	;mov	bx,4
  7000 0000184E BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  7001 00001851 B448                    	mov	ah,48h
  7002                                  	;mov	ah,ALLOC                        ;
  7003 00001853 CD21                            int	21h                             ;
  7004 00001855 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  7005 00001857 A3[3401]                        mov	[Batch],ax			; save batch segment
  7006                                  
  7007                                  NoBatchSeg:
  7008                                  
  7009                                  ; 21/01/2023
  7010                                  %if 0
  7011                                  	; MSDOS 3.3
  7012                                  	mov     bx,0FFFFh ; 65535
  7013                                  	mov     ah,ALLOC ; 48h
  7014                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7015                                  			; BX = number of 16-byte paragraphs desired
  7016                                  	sub     bx,[TRNSIZE]
  7017                                  	sub     bx,128
  7018                                  	mov     [ENVMAX],bx
  7019                                  
  7020                                  	cmp     bx,4096
  7021                                  	jb      short ALLOCENVIRSEG
  7022                                  	mov     bx,4096-1		; max. allowed environment size
  7023                                  	mov     [ENVMAX],bx
  7024                                  
  7025                                  ALLOCENVIRSEG:
  7026                                  	mov     ah,ALLOC ; 48h
  7027                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7028                                  			; BX = number of 16-byte paragraphs desired
  7029                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  7030                                  	mov     [OLDENV],bx		; save it	
  7031                                  	mov     word [USEDENV],0	; initialize environment size counter
  7032                                  	mov     ds,bx
  7033                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  7034                                  	mov     es,ax
  7035                                  	xor     si,si
  7036                                  	mov     di,si
  7037                                  	mov     bx,[ss:ENVMAX]
  7038                                  	shl     bx,1
  7039                                  	shl     bx,1
  7040                                  	shl     bx,1
  7041                                  	shl     bx,1
  7042                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  7043                                  	dec     bx			; dec by one to leave room for double 0
  7044                                  	xor     dx,dx			; use dx to indicate that there was
  7045                                  					; no environment size error.
  7046                                  
  7047                                  NXSTR:
  7048                                  	call    GETSTRLEN		; get the size of the current env string
  7049                                  
  7050                                  	push    ds
  7051                                  	push    cs
  7052                                  	pop     ds
  7053                                  	add     [USEDENV],cx		; add the string length to env size
  7054                                  	pop     ds
  7055                                  	cmp     cx,1			; end of environment was encountered.
  7056                                  	je      short ENVEXIT
  7057                                  	sub     bx,cx
  7058                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  7059                                  	inc     dx			; out of env space msg must be displayed
  7060                                  	jmp     short ENVEXIT
  7061                                  
  7062                                  	;nop
  7063                                  
  7064                                  OKCPYSTR:
  7065                                  	jmp     short NXSTR
  7066                                  
  7067                                  ENVEXIT: 
  7068                                  	push    cs
  7069                                  	pop     ds
  7070                                  	or      dx, dx			; dx will be non-zero if error
  7071                                  	jz      short ENVNOERR
  7072                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  7073                                  	call    RPRINT
  7074                                  
  7075                                  %endif
  7076                                  
  7077                                  	; 21/01/2023
  7078                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7079 0000185A 8B1E[2703]              	mov	bx,[EnvirSeg]			; get old environment segment
  7080 0000185E 891E[721C]              	mov	[OldEnv],bx			; save it
  7081 00001862 C706[741C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7082 00001868 8EDB                    	mov	ds,bx
  7083                                  	;assume	ds:nothing
  7084                                  	
  7085 0000186A 31F6                    	xor	si,si
  7086 0000186C 89F7                    	mov	di,si
  7087                                  
  7088                                  ; This is the maximum allowed size for the environment
  7089                                  
  7090                                  	; 21/01/2023
  7091                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7092                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7093                                  	;;mov	[ss:EnvMax],bx
  7094                                  	;shl	bx,1
  7095                                  	;shl	bx,1
  7096                                  	;shl	bx,1
  7097                                  	;shl	bx,1
  7098 0000186E BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7099 00001871 36891E[701C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7100 00001876 4B                      	dec	bx				; dec by one to leave room for double 0
  7101 00001877 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7102                                  						; no environment size error.
  7103                                  ;public NxtStr
  7104                                  NxtStr:
  7105 00001879 E81E01                  	call	GetStrLen			; get the size of the current env string
  7106                                  
  7107                                  ;Bugbug: Can use ss here to address UsedEnv
  7108                                  
  7109 0000187C 1E                      	push	ds                              ; get addressability to environment
  7110 0000187D 0E                              push	cs                              ;                       counter
  7111 0000187E 1F                              pop	ds                              ;
  7112                                  	;assume	ds:ResGroup
  7113 0000187F 010E[741C]                      add	[UsedEnv],cx			; add the string length to env size
  7114 00001883 1F                      	pop	ds                              ;
  7115                                  	;assume	ds:nothing
  7116                                  	
  7117 00001884 83F901                  	cmp	cx,1				; end of environment was encountered.
  7118 00001887 7405                    	je	short EnvExit
  7119 00001889 29CB                    	sub	bx,cx
  7120                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7121                                  	; 21/01/2023
  7122 0000188B 73EC                    	jae	short NxtStr
  7123 0000188D 42                      	inc	dx				; out of env space msg must be displayed
  7124                                  	;jmp	short EnvExit
  7125                                  
  7126                                  ;OkCpyStr:
  7127                                  	;jmp	short NxtStr
  7128                                  
  7129                                  EnvExit:
  7130 0000188E 0E                      	push	cs
  7131 0000188F 1F                      	pop	ds
  7132                                  	;assume	ds:ResGroup
  7133 00001890 09D2                    	or	dx,dx				; dx will be non-zero if error
  7134 00001892 7406                    	jz	short EnvNoErr
  7135                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7136 00001894 BA[301D]                	mov	dx,OUTENVMSG
  7137 00001897 E8DBF9                  	call 	RPrint
  7138                                  EnvNoErr:
  7139 0000189A A1[6E1C]                	mov	ax,[EnvSiz]			; env size previously set
  7140 0000189D B104                    	mov	cl,4
  7141 0000189F D3E0                    	shl	ax,cl				; get size in bytes
  7142 000018A1 3B06[741C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7143 000018A5 7706                    	ja	short st_envsize		; yes, store the size
  7144 000018A7 A1[741C]                	mov	ax,[UsedEnv]
  7145 000018AA 83C00F                  	add	ax,15				; round up
  7146                                  st_envsize:	
  7147 000018AD D3E8                    	shr	ax,cl
  7148 000018AF A3[6E1C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7149                                  
  7150                                  ;if MSVER
  7151                                  	;cmp	SingleCom,0
  7152                                  	;jnz	nophead 			; don't print header if SingleCom
  7153                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7154                                  	;call	RPrint
  7155                                  ;nophead:
  7156                                  ;endif
  7157                                  
  7158                                  ; 21/01/2023
  7159                                  %if 0
  7160                                  	; MSDOS 3.3
  7161                                  ENVNOERR:
  7162                                  	mov     cx,[ENVMAX]
  7163                                  	sub     cx,bx			; current environment size in bytes
  7164                                  	add     cx,16			; add memory arena to the size
  7165                                  	shr     cx,1
  7166                                  	shr     cx,1
  7167                                  	shr     cx,1
  7168                                  	shr     cx,1			; convert current env size to paragraphs
  7169                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7170                                  	;jb	short SET_ENVSIZE
  7171                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7172                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7173                                  
  7174                                  SET_ENVSIZE:
  7175                                  	mov     bx,[ENVSIZ]
  7176                                  	mov     ax,es
  7177                                  	add     ax,bx			; get end segment of environemnt
  7178                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7179                                  	ja      short NOPHEAD
  7180                                  					; free unused paragraghs		
  7181                                  	mov     ax,es
  7182                                  	mov     bx,[INITEND]
  7183                                  	sub     bx,ax
  7184                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7185                                  	mov	word [RESETENV],1	; environment segment reset sign
  7186                                  
  7187                                  NOPHEAD:
  7188                                  	; MSDOS 3.3
  7189                                  	mov     ah,SETBLOCK ; 4Ah
  7190                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7191                                  			; ES = segment address of block to change
  7192                                  			; BX = new size in paragraphs
  7193                                  %endif
  7194                                  	; 21/01/2023
  7195                                  
  7196                                  	; MSDOS 3.3 & 6.0
  7197 000018B2 833E[3401]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7198 000018B7 7503                    	jnz     short DoDate		; yes - go initialize it
  7199 000018B9 E99300                  	jmp     NoDttm			; don't do autoexec or date time
  7200                                  
  7201                                  DoDate:
  7202                                  
  7203                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7204                                  
  7205 000018BC A1[3401]                	mov	ax,[Batch]		; get batch segment
  7206 000018BF C606[8801]03            	mov	byte [EchoFlag],3	; set batch echo
  7207 000018C4 C706[9701]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7208 000018CA 8EC0                    	mov	es,ax
  7209                                  
  7210                                  ; initialize the segment
  7211                                  
  7212 000018CC 31FF                    	xor	di,di
  7213                                  	;;mov	al,0
  7214                                  	;mov	al,BATCHTYPE ; 0
  7215                                  	; 06/06/2023
  7216 000018CE 31C0                    	xor	ax,ax
  7217 000018D0 AA                      	stosb
  7218                                  	;mov	al,1			; initialize echo for batch exit
  7219                                  	;inc	al
  7220                                  	; 22/07/2024
  7221 000018D1 40                      	inc	ax
  7222 000018D2 AA                      	stosb
  7223                                  
  7224                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7225                                  
  7226                                  	;xor	ax,ax			; initialize to zero
  7227                                  	; 06/06/2023
  7228                                  	;dec	al ; ax = 0
  7229                                  	; 22/07/2024
  7230 000018D3 48                      	dec	ax
  7231                                  
  7232                                  	; 21/01/2023
  7233 000018D4 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7234                                  
  7235 000018D5 AB                      	stosw				; batch segment of last job - batlast
  7236 000018D6 AB                      	stosw				; segment for FOR
  7237 000018D7 AA                      	stosb				; FOR flag
  7238 000018D8 AB                      	stosw				; position in file - batseek
  7239 000018D9 AB                      	stosw
  7240                                  
  7241                                  ; clean out the parameters
  7242                                  
  7243                                  	;mov	ax,-1			; initialize to no parameters
  7244                                  	; 06/06/2023
  7245 000018DA 48                      	dec	ax ; ax = -1
  7246                                  
  7247 000018DB B90A00                  	mov	cx,10
  7248 000018DE F3AB                    	rep	stosw
  7249                                  
  7250                                  ; decide whether we should grab the default drive
  7251                                  
  7252 000018E0 803E[341C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7253 000018E5 7509                    	jne	short NoAutSet
  7254 000018E7 B419                    	mov	ah,19h	; 21/01/2023
  7255                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7256 000018E9 CD21                    	int	21h
  7257                                  	;;add	al,'A'
  7258                                  	;add	al,[letter_A] ; Ucasea
  7259                                  	;add	al,[ucasea] ; 21/01/2023
  7260                                  	; 21/01/2023
  7261 000018EB 0441                    	add	al,'A'
  7262 000018ED A2[341C]                	mov	[AUTOBAT],al
  7263                                  	; 21/01/2023
  7264                                  	;mov	[KAUTOBAT],al
  7265                                  NoAutSet:
  7266                                  
  7267                                  ; copy in the batch file name (including nul)
  7268                                  
  7269                                  	;mov	si,offset ResGroup:AutoBat
  7270 000018F0 BE[341C]                	mov	si,AUTOBAT
  7271 000018F3 B90800                  	mov	cx,8
  7272 000018F6 F3A5                    	rep	movsw
  7273                                  	; 23/04/2023
  7274 000018F8 A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7275                                  
  7276                                  	;mov	dx,offset ResGroup:AutoBat
  7277 000018F9 BA[341C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7278                                  
  7279                                  	;;mov	ax,OPEN shl 8
  7280 000018FC B8003D                  	mov	ax,3D00h ; 21/01/2023
  7281                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7282 000018FF CD21                    	int	21h			; see if autoexec.bat exists
  7283 00001901 7208                    	jc	short noabat
  7284 00001903 89C3                    	mov	bx,ax
  7285 00001905 B43E                    	mov	ah,3Eh ; 21/01/2023
  7286                                  	;mov	ah,CLOSE  ; 3Eh
  7287 00001907 CD21                    	int	21h
  7288 00001909 EB51                    	jmp	short Drv0		; go process autoexec
  7289                                  
  7290                                  noabat:
  7291 0000190B 50                      	push	ax
  7292 0000190C E89400                  	call	Setup_Seg
  7293 0000190F A3[501C]                	mov	[triage_add+2],ax
  7294 00001912 58                      	pop	ax
  7295 00001913 FF1E[4E1C]              	call	far [triage_add]	; get extended error
  7296 00001917 83F841                  	cmp	ax,65			; network access denied?
  7297                                  	;jne	short OPENERR		; no - go deallocate batch
  7298                                  	; 21/01/2023
  7299                                  	;je	short AccDenErr
  7300 0000191A 7506                    	jne	short OpenErr
  7301                                  
  7302                                  	; 21/01/2023
  7303                                  ;_ACCDENERROR:					; yes - put out message
  7304                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7305                                  ;	mov	dx,ACCDENERR
  7306                                  ;	call	RPRINT
  7307                                  
  7308                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7309                                  
  7310                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7311                                  
  7312                                  ; 21/01/2023
  7313                                  %if 0
  7314                                  
  7315                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7316                                  ; by Ellen to check only when in Korea. The country information
  7317                                  ; returned will overlay the old parse data area, but we don't care
  7318                                  ; since we won't need the parse information or country information.
  7319                                  ; We only care about the country code returned in BX.
  7320                                  
  7321                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7322                                  
  7323                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7324                                  	mov	dx,INTERNAT_INFO
  7325                                  	mov	ax,3800h
  7326                                  	;mov	ax,INTERNATIONAL<<8
  7327                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7328                                  	int	21h				;
  7329                                  	jc	short NoKabat 			; error - don't bother with it
  7330                                  	cmp	bx,52h
  7331                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7332                                  	jne	short OpenErr 			; no, don't check for kautoexe
  7333                                  
  7334                                  	;mov	di,BatFile			; 3/3/kk
  7335                                  	mov	di,20h
  7336                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7337                                  	mov	si,KAUTOBAT
  7338                                  	mov	cx,8				; auto execution for the 3/3/kk
  7339                                  	rep	movsw				; non-english country	3/3/kk
  7340                                  	movsb					; move in carraige return to terminate string
  7341                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7342                                  	mov	dx,KAUTOBAT
  7343                                  	mov	ax,3D00h
  7344                                  	;mov	ax,OPEN<<8
  7345                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7346                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7347                                  	jc	short NoKabat 			; 3/3/kk
  7348                                  	mov	bx,ax				; 3/3/kk
  7349                                  	mov	ah,3Eh
  7350                                  	;mov	ah,CLOSE			; 3/3/kk
  7351                                  	int	21h				; 3/3/kk
  7352                                  	jmp	short Drv0			; 3/3/kk
  7353                                  
  7354                                  NoKabat:					; 3/3/kk
  7355                                  	call	far [triage_add]		; get extended error
  7356                                  	cmp	ax,65				; network access denied?
  7357                                  	jnz	short OpenErr 			; no - go deallocate batch
  7358                                  
  7359                                  %endif
  7360                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7361                                  
  7362                                  AccDenErr:					; yes - put out message
  7363                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7364 0000191C BA[B905]                	mov	dx,ACCDEN
  7365 0000191F E853F9                  	call	RPrint
  7366                                  OpenErr:
  7367                                  ;OPENERR:
  7368 00001922 8E06[3401]              	mov	es,[Batch]		; not found--turn off batch job
  7369 00001926 B449                    	mov	ah,49h
  7370                                  	;mov	ah,DEALLOC ; 49h
  7371 00001928 CD21                    	int	21h
  7372 0000192A C706[3401]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7373 00001930 C606[8801]01            	mov	byte [EchoFlag],1
  7374 00001935 C706[9701]0000          	mov	word [Nest],0		; indicate no batch in progress
  7375                                  
  7376                                  ;DoDttm:
  7377                                  	;mov	ax,offset TranGroup:Datinit
  7378 0000193B B8[5F2E]                	mov	ax,DATINIT
  7379 0000193E A3[461C]                	mov	[INITADD],ax
  7380                                  
  7381                                  	; MSDOS 6.0
  7382                                  ;;M004;;mov	ax,TrnSeg	
  7383                                  ;
  7384                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7385                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7386                                  ; M004; We use TranStart to get the start of the transient segment.
  7387                                  
  7388                                  	; 21/01/2023
  7389                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7390                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7391                                  	; 06/06/2023
  7392                                  	;mov	ax,TRANSTART
  7393                                  	;mov	cl,4				; M004
  7394                                  	;shr	ax,cl				; get relative seg ; M004
  7395                                  	; 06/06/2023
  7396 00001941 B82002                  	mov	ax,TRANSTART>>4	
  7397                                  
  7398 00001944 8CC9                    	mov	cx,cs
  7399 00001946 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7400                                  
  7401                                  	; 21/01/2023
  7402                                  	; MSDOS 3.3
  7403                                  	; 25/09/2018
  7404                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7405                                  
  7406                                  	; MSDOS 3.3 & MSDOS 6.0
  7407 00001948 A3[481C]                	mov	[INITADD+2],ax
  7408                                  	;call	dword ptr InitAdd
  7409 0000194B FF1E[461C]              	call	far [INITADD]
  7410                                  
  7411                                  NoDttm:
  7412                                  	; MSDOS 6.0
  7413                                  	; 21/01/2023
  7414                                  ;Copyright:
  7415                                  	;public	Copyright
  7416                                  ;	Bugbug:	remove Copyright label.
  7417                                  
  7418                                  ;if IBMVER
  7419 0000194F 833E[8E01]00            	cmp	word [SingleCom],0
  7420 00001954 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7421                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7422 00001956 BA[4B1D]                	mov	dx,COPYRIGHTMSG
  7423 00001959 E819F9                  	call	RPrint
  7424                                  ;endif
  7425                                  	; 21/01/2023
  7426                                  	; MSDOS 3.3
  7427                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7428                                  	;jnz	short DRV0
  7429                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7430                                  	;call	RPRINT
  7431                                  ;DRV0:
  7432                                  	; MSDOS 3.3
  7433                                  	;mov	byte [INITFLAG],0
  7434                                  	;jmp	ENDINIT
  7435                                  
  7436                                  	; 21/01/2023
  7437                                  	; MSDOS 6.0
  7438                                  Drv0:						; Reset APPEND state
  7439 0000195C 1E                      	push	ds				; save data segment
  7440 0000195D 0E                      	push	cs				; Get local segment into DS
  7441 0000195E 1F                      	pop	ds				;
  7442 0000195F B807B7                  	mov	ax,0B707h ; 21/01/2023
  7443                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7444 00001962 8B1E[AB01]              	mov	bx,[Append_State] 		;  back to the original state
  7445 00001966 CD2F                    	int	2Fh				;
  7446 00001968 1F                      	pop	ds				; get data segment back
  7447                                  
  7448                                  ;Check FirstCom set previously to see if this is the first instance of
  7449                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7450                                  ;jump table from the previous stub to the current stub.
  7451                                  
  7452 00001969 803E[C020]01            	cmp	byte [FirstCom],1		; first command.com?
  7453 0000196E 7424                    	jz	short move_code			; yes, move it
  7454                                  
  7455 00001970 06                      	push	es
  7456 00001971 1E                      	push	ds
  7457                                  
  7458 00001972 1E                      	push	ds
  7459 00001973 07                      	pop	es
  7460                                  	;mov	di,offset DATARES:Int2f_Entry
  7461 00001974 BF[0400]                	mov	di,Int2f_Entry	
  7462                                  
  7463                                  	;mov	ds,[es:ResJmpTable+2]		; get segment address
  7464                                  	;mov	si,[es:ResJmpTable]		; get offset address
  7465                                  	; 22/07/2024 - PCDOS 7.1 COMMAND.COM
  7466 00001977 26C536[BC20]            	lds	si,[es:ResJmpTable]
  7467                                  
  7468                                  	;mov	cx,11
  7469                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7470                                  	;shl	cx,1
  7471                                  	;shl	cx,1				; size of table in bytes
  7472                                  	; 21/01/2023
  7473 0000197C B92C00                  	mov	cx,44				; size of table in bytes
  7474                                  
  7475 0000197F FC                      	cld
  7476 00001980 F3A4                    	rep	movsb				; copy the jump table
  7477                                  
  7478                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7479                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7480                                  
  7481 00001982 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7482 00001988 7206                    	jb	short res_low			; no, dont set flag
  7483                                  
  7484 0000198A 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7485                                  res_low:
  7486 00001990 1F                      	pop	ds
  7487 00001991 07                      	pop	es
  7488 00001992 EB03                    	jmp	short finish_init
  7489                                  
  7490                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7491                                  ;or to overlay the messages in the data segment if the user has not used the
  7492                                  ;/msg switch.
  7493                                  
  7494                                  move_code:
  7495 00001994 E88501                  	call	Move_res_code			; move the code
  7496                                  
  7497                                  finish_init:
  7498                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7499 00001997 E968E8                  	jmp	EndInit
  7500                                  
  7501                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7502                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7503                                  
  7504                                  GetStrLen:
  7505                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7506                                  ;	Length is returned in CX
  7507                                  
  7508                                  	; MSDOS 3.3 & MSDOS 6.0
  7509 0000199A 31C9                    	xor	cx,cx
  7510                                  NxtChar:
  7511 0000199C AC                      	lodsb
  7512 0000199D 41                      	inc	cx
  7513 0000199E 08C0                    	or	al,al
  7514 000019A0 75FA                    	jnz	short NxtChar
  7515 000019A2 C3                      	retn
  7516                                  
  7517                                  	; 29/01/2023
  7518                                  Setup_Seg:
  7519                                  
  7520                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7521                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7522                                  ; code segment is used
  7523                                  ; Segment returned in AX.
  7524                                  
  7525                                  	; MSDOS 3.3 & MSDOS 6.0
  7526 000019A3 A1[7A01]                	mov	ax,[TrnSeg]
  7527 000019A6 803E[7C01]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7528 000019AB 7405                    	je	short setup_end
  7529                                  
  7530                                  ;06/06/2023
  7531                                  %if 0
  7532                                  	push	bx
  7533                                  	mov	bx,cs
  7534                                  	;mov	ax,offset ResGroup:TranStart
  7535                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7536                                  	; 06/06/2023
  7537                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7538                                  	;mov	ax,TRANSTART
  7539                                  	;shr	ax,1
  7540                                  	;shr	ax,1
  7541                                  	;shr	ax,1
  7542                                  	;shr	ax,1
  7543                                  	; 29/01/2023
  7544                                  	mov	ax,TRANSTART>>4
  7545                                  	add	ax,bx
  7546                                  	pop	bx
  7547                                  %endif
  7548                                  	; 06/06/2023
  7549 000019AD 8CC8                    	mov	ax,cs
  7550 000019AF 052002                  	add	ax,TRANSTART>>4
  7551                                  
  7552                                  setup_end:
  7553 000019B2 C3                      	retn
  7554                                  
  7555                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7556                                  ;RPRINT:
  7557                                  	; MSDOS 3.3
  7558                                  	;push    ax
  7559                                  	;call    SETUP_SEG
  7560                                  	;mov     [PRINTADD+2], ax
  7561                                  	;;call	dword ptr PRINTADD
  7562                                  	;call	far [PRINTADD]
  7563                                  	;pop     ax
  7564                                  	;retn
  7565                                  
  7566                                  	; 29/01/2023
  7567                                  	; MSDOS 6.0
  7568                                  ;***	RPrintParse - display parse error message
  7569                                  ;
  7570                                  ;	ENTRY	DX = parse error #
  7571                                  ;
  7572                                  ;	EXIT	nothing
  7573                                  ;
  7574                                  ;	USED	flags
  7575                                  ;
  7576                                  ;	EFFECTS
  7577                                  ;	  Message is displayed on stdout.
  7578                                  
  7579                                  RPrintParse:	;proc
  7580                                  	;assume	ds:ResGroup,ss:ResGroup
  7581                                  
  7582 000019B3 52                      	push	dx				; preserve DX
  7583 000019B4 87DA                    	xchg	bx,dx				; bx = parse error #
  7584                                  						; dx = saved BX
  7585 000019B6 4B                      	dec	bx				; bx = parse error index, from 0
  7586 000019B7 D1E3                    	shl	bx,1				; bx = offset in word table
  7587                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7588 000019B9 8B9F[FB08]              	mov	bx,[bx+PARSMSGPTRS]
  7589 000019BD 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7590                                  						; bx = restored
  7591 000019BF E8B3F8                  	call	RPrint				; print the message
  7592 000019C2 5A                      	pop	dx				; restore DX
  7593 000019C3 C3                      	retn
  7594                                  
  7595                                  ;RPrintParse	endp
  7596                                  
  7597                                  	; 29/01/2023
  7598                                  ;PATHCHRCMPR:
  7599                                  	; MSDOS 3.3
  7600                                  	;push	dx
  7601                                  	;mov	dl,[slash_chr]
  7602                                  	;;cmp	byte [RSWITCHAR],'/'
  7603                                          ;cmp	[RSWITCHAR],dl
  7604                                  	;je	short RNOSLASHT
  7605                                  	;;cmp	al,'/'
  7606                                  	;cmp	al,dl
  7607                                  	;je	short RET41 ; zf = 1 
  7608                                  ;RNOSLASHT:
  7609                                          ;;cmp	al,'\'
  7610                                  	;cmp	al,[bslash_chr]
  7611                                  ;RET41:
  7612                                  	;pop	dx
  7613                                  	;retn
  7614                                  
  7615                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7616                                  IfindE:
  7617                                  	; MSDOS 3.3 & MSDOS 6.0
  7618 000019C4 E80300                  	call	ifind				; find the name
  7619                                  	;jc	short ifind2			; carry means not found
  7620                                  	;jmp	short Iscasb1 			; scan for = sign
  7621                                  	; 29/01/2023
  7622 000019C7 733A                    	jnc	short Iscasb1
  7623                                  ifind2:
  7624 000019C9 C3                      	retn
  7625                                  
  7626                                  	; 29/01/2023
  7627                                  
  7628                                  ; on return of find1, es:di points to beginning of name
  7629                                  
  7630                                  ifind:
  7631 000019CA FC                      	cld
  7632 000019CB E82700                  	call	Icount0				; cx = length of name
  7633 000019CE 8E06[2703]              	mov	es,[EnvirSeg]
  7634 000019D2 31FF                    	xor	di,di
  7635                                  ifind1:
  7636 000019D4 51                      	push	cx
  7637 000019D5 56                      	push	si
  7638 000019D6 57                      	push	di
  7639                                  ifind11:
  7640 000019D7 AC                      	lodsb
  7641 000019D8 E83400                  	call	iupconv
  7642 000019DB 47                      	inc	di
  7643 000019DC 263A45FF                	cmp	al,[es:di-1]
  7644 000019E0 7502                    	jnz	short ifind12
  7645 000019E2 E2F3                    	loop	ifind11
  7646                                  ifind12:
  7647 000019E4 5F                      	pop	di
  7648 000019E5 5E                      	pop	si
  7649 000019E6 59                      	pop	cx
  7650 000019E7 74E0                    	jz	short ifind2
  7651 000019E9 51                      	push	cx
  7652 000019EA E81A00                  	call	Iscasb2 			; scan for a nul
  7653 000019ED 59                      	pop	cx
  7654                                  	;cmp	byte [es:di],0
  7655                                  	;jnz	short ifind1
  7656                                  	;stc					; indicate not found
  7657 000019EE 26803D01                	cmp	byte [es:di],1
  7658 000019F2 73E0                    	jnb	short ifind1
  7659                                  	; cf=1					; indicate not found
  7660                                  ;ifind2:
  7661 000019F4 C3                      	retn
  7662                                  
  7663                                  	; 29/01/2023
  7664                                  Icount0:
  7665 000019F5 1E                      	push	ds
  7666 000019F6 07                      	pop	es
  7667 000019F7 89F7                    	mov	di,si
  7668                                  
  7669 000019F9 57                      	push	di				; count number of chars until "="
  7670 000019FA E80600                  	call	Iscasb1
  7671                                  	; 25/09/2018
  7672                                  	;jmp	short Icountx
  7673                                  	;push	di				; count number of chars until nul
  7674                                  	;call	Iscasb2
  7675                                  ;Icountx:
  7676 000019FD 59                      	pop	cx
  7677 000019FE 29CF                    	sub	di,cx
  7678 00001A00 87F9                    	xchg	di,cx
  7679 00001A02 C3                      	retn
  7680                                  
  7681                                  Iscasb1:
  7682                                  	; 29/01/2023
  7683 00001A03 B03D                    	mov	al,"="
  7684                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7685 00001A05 EB02                    	jmp	short Iscasbx
  7686                                  Iscasb2:
  7687 00001A07 30C0                    	xor	al,al				; scan for a nul
  7688                                  Iscasbx:
  7689 00001A09 B90001                  	mov	cx,256 ; 100h
  7690 00001A0C F2AE                    	repnz	scasb
  7691 00001A0E C3                      	retn
  7692                                  
  7693                                  	; 29/01/2023
  7694                                  ;IUPCONV:
  7695                                  	; MSDOS 3.3
  7696                                          ;;cmp	al,"a"
  7697                                  	;cmp	al,[letter_a]
  7698                                          ;jb	short IRET22
  7699                                          ;;cmp	al,"z"
  7700                                          ;cmp	al,[letter_z]
  7701                                  	;ja	short IRET22
  7702                                          ;sub	al,20h			; Lower-case changed to upper-case
  7703                                  ;IRET22:
  7704                                  	;retn
  7705                                  
  7706                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7707                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7708                                  
  7709                                  	; MSDOS 6.0
  7710                                  ; *****************************************************************
  7711                                  ; *
  7712                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7713                                  ; *
  7714                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7715                                  ; *		 the character in AL from the file upper case table
  7716                                  ; *		 in DOS if character if above ascii 128, else
  7717                                  ; *		 subtracts 20H if between "a" and "z".
  7718                                  ; *
  7719                                  ; * INPUT:	 DS	      set to resident
  7720                                  ; *		 AL	      char to be upper cased
  7721                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7722                                  ; *
  7723                                  ; * OUTPUT:	 AL	      upper cased character
  7724                                  ; *
  7725                                  ; *****************************************************************
  7726                                  
  7727                                  iupconv:	;proc	near				
  7728                                  	;assume	ds:ResGroup			;
  7729                                  
  7730 00001A0F 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7731 00001A11 7210                    	jb	short other_fucase		; no - upper case math
  7732 00001A13 2C80                    	sub	al,80h				; only upper 128 chars in table
  7733 00001A15 1E                      	push	ds				;
  7734 00001A16 53                      	push	bx				;
  7735                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7736 00001A17 C51E[9F01]              	lds     bx,[FUCase_Addr+1]
  7737 00001A1B 83C302                  	add	bx,2				; skip over first word
  7738                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7739 00001A1E D7                      	xlat
  7740 00001A1F 5B                      	pop	bx				;
  7741 00001A20 1F                      	pop	ds				;
  7742 00001A21 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7743                                  
  7744                                  other_fucase:					;
  7745                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7746 00001A23 3C61                    	cmp	al,'a'
  7747 00001A25 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7748                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7749 00001A27 3C7A                    	cmp	al,'z'
  7750 00001A29 7702                    	ja	short iupconv_end		;
  7751 00001A2B 2C20                    	sub	al,20h				; Change lower-case to upper
  7752                                  iupconv_end:					;
  7753 00001A2D C3                      	retn
  7754                                  
  7755                                  ;iupConv endp
  7756                                  
  7757                                  	; 29/01/2023
  7758                                  init_contc_specialcase:
  7759                                  	; MSDOS 3.3 & MSDOS 6.0
  7760                                  						; This routine is called if control-C
  7761 00001A2E 83C406                  	add	sp,6				;  is type during the date/time prompt
  7762 00001A31 56                      	push	si				;  at initialization time.  The desired
  7763 00001A32 89D6                    	mov	si,dx				;  response is to make it look like the
  7764 00001A34 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7765 00001A39 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7766 00001A3A CF                      	iret					;  a <CR> in the user's buffer, and
  7767                                  						;  returning directly to the user.
  7768                                  						; In this case the user is TCODE.
  7769                                  
  7770                                  ; ----------------------------------------------------------------------------
  7771                                  
  7772                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7773                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7774                                  
  7775                                  	; MSDOS 6.0
  7776                                  ; ****************************************************************
  7777                                  ; *
  7778                                  ; * ROUTINE:	 Setup_for_messages
  7779                                  ; *
  7780                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7781                                  ; *		 messages as follows:
  7782                                  ; *
  7783                                  ; *		 IF /P and /MSG are entered
  7784                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7785                                  ; *		 ELSE IF /P is entered
  7786                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7787                                  ; *		    remove PARSE ERRORS from memory
  7788                                  ; *		 ELSE
  7789                                  ; *		    remove PARSE ERRORS from memory
  7790                                  ; *		 ENDIF
  7791                                  ; *
  7792                                  ; * INPUT:	 PERMCOM	Set up with user input
  7793                                  ; *		 EXT_MSG	Set up with user input
  7794                                  ; *		 System set up to retain PARSE ERRORS
  7795                                  ; *
  7796                                  ; * OUTPUT:	 registers unchanged
  7797                                  ; *
  7798                                  ; ****************************************************************
  7799                                  
  7800                                  setup_for_messages: ;proc near		
  7801                                  
  7802 00001A3B 53                      	push	bx
  7803 00001A3C 1E                      	push	ds				; save data segment
  7804 00001A3D 06                      	push	es				; save environment segment
  7805 00001A3E 50                      	push	ax				;
  7806 00001A3F 52                      	push	dx				;
  7807 00001A40 57                      	push	di				;
  7808 00001A41 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7809 00001A43 8ED8                    	mov	ds,ax				;
  7810 00001A45 8EC0                    	mov	es,ax				;
  7811                                  
  7812 00001A47 803E[8D01]00            	cmp	byte [PermCom],0		; was permcom set?
  7813 00001A4C 743C                    	jz	short no_permcom		; No - don't worry about messages
  7814                                  
  7815                                  ;*	We're permanent. Install our message services int 2f handler.
  7816                                  
  7817 00001A4E 06                      	push	es
  7818                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7819 00001A4F B82F35                  	mov	ax,352Fh
  7820 00001A52 CD21                    	int	21h
  7821                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7822                                  			; AL = interrupt number
  7823                                  			; Return: ES:BX = value of interrupt vector
  7824 00001A54 891E[9903]              	mov	[Int2fHandler],bx
  7825 00001A58 8C06[9B03]              	mov	[Int2fHandler+2],es
  7826 00001A5C 07                      	pop	es
  7827                                  
  7828                                  ;	DS = RESGROUP seg addr
  7829                                  
  7830                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7831                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7832                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7833                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7834                                  ; M005; call) goes off into space.
  7835                                  
  7836 00001A5D 803E[C020]00            	cmp	byte [FirstCom],0		; M005
  7837 00001A62 7416                    	je	short no_msg_hook		; M005
  7838                                  ;
  7839                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7840                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7841                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7842                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7843                                  ; M005; segment matches the command.com PSP and then updates these segments
  7844                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7845                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7846                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7847                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7848                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7849                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7850                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7851                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7852                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7853                                  ; M005; jump to the actual int 2fh entry point.
  7854                                  ;
  7855 00001A64 1E                      	push	ds				; M005
  7856                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7857 00001A65 BA[C300]                	mov     dx,Carousel_i2f_Hook
  7858 00001A68 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7859 00001A6B 8CD8                    	mov	ax,ds				; M005
  7860 00001A6D 40                      	inc	ax				; Relocated cs ; M005
  7861 00001A6E 8ED8                    	mov	ds,ax				; M005
  7862                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7863 00001A70 B82F25                  	mov	ax,252Fh
  7864 00001A73 CD21                    	int	21h
  7865                                  			; DOS - SET INTERRUPT VECTOR
  7866                                  			; AL = interrupt number
  7867                                  			; DS:DX = new vector to be used for specified interrupt
  7868 00001A75 1F                      	pop	ds				; M005
  7869                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7870 00001A76 8C1E[C600]              	mov	[Carousel_i2f_Hook+3],ds
  7871                                  						; patch in the cs for jump
  7872                                  no_msg_hook:					; M005
  7873 00001A7A 803E[811C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7874 00001A7F 7516                    	jne	short permcom_end		; no /msg - exit
  7875                                  
  7876                                  permcom_slash_msg:				; Keep messages in memory
  7877                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7878 00001A81 BF[F40B]                	mov     di,ExtMsgEnd
  7879 00001A84 893E[9D03]              	mov	[ResMsgEnd],di			; save it
  7880 00001A88 EB0D                    	jmp	short permcom_end		; exit
  7881                                  
  7882                                  no_permcom:					
  7883                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7884 00001A8A 803E[811C]01            	cmp	byte [ext_msg],1
  7885 00001A8F 7506                    	jne	short permcom_end		; no - no error
  7886                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7887 00001A91 BA0200                  	mov	dx,2
  7888 00001A94 E81CFF                  	call	RPrintParse
  7889                                  
  7890                                  permcom_end:
  7891 00001A97 5F                      	pop	di				;
  7892 00001A98 5A                      	pop	dx				;
  7893 00001A99 58                      	pop	ax				;
  7894 00001A9A 07                      	pop	es				; get environment back
  7895 00001A9B 1F                      	pop	ds				;
  7896 00001A9C 5B                      	pop	bx
  7897                                  
  7898 00001A9D C3                      	retn					;
  7899                                  
  7900                                  ;setup_for_messages	endp
  7901                                  
  7902                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7903                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7904                                  
  7905                                  	; MSDOS 6.0
  7906                                  
  7907                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7908                                  ;
  7909                                  ;	ENTRY	command-line tail at 81h
  7910                                  ;
  7911                                  ;	EXIT	return if /? not found
  7912                                  ;		terminate if /? found
  7913                                  ;
  7914                                  ;	USED	AX,BX,CX,DX,SI,DI
  7915                                  ;
  7916                                  ;	EFFECTS	Help text displayed if /? found on command line
  7917                                  
  7918                                  CheckHelp:	; proc
  7919                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7920                                  
  7921 00001A9E BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7922                                  	;mov	di,offset RESGROUP:Parse_Command
  7923 00001AA1 BF[861C]                	mov	di,PARSE_COMMAND
  7924                                  					; ES:DI = ptr to primary parse block
  7925 00001AA4 31C9                    	xor	cx,cx			; CX = # positional param's found
  7926 00001AA6 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7927                                  chParse:
  7928                                  	;call	dword ptr Init_Parse
  7929 00001AA8 FF1E[7A1C]              	call	far [Init_Parse]	; call system parser
  7930                                  
  7931                                  	;;cmp	ax,END_OF_LINE
  7932                                  	;cmp	ax,-1 ; 0FFFFh	
  7933                                  	;je	short chRet		; end of command line, no /? found
  7934                                  	;;cmp	ax,RESULT_NO_ERROR
  7935                                  	;;cmp	ax,0
  7936                                  	;;je	short chWhich		; valid syntax element found
  7937                                  	;;jmp	short chParse		; go parse more
  7938                                  	;and	ax,ax ; cmp ax,0
  7939                                  	;jnz	short chParse ; jne
  7940                                  	; 10/06/2023
  7941 00001AAC 40                      	inc	ax	; cmp ax,-1
  7942 00001AAD 7413                    	jz	short chRet   ; 0FFFFh -> 0
  7943 00001AAF 48                      	dec	ax	; cmp ax,0
  7944 00001AB0 75F6                    	jnz	short chParse ; 1 -> 0
  7945                                  	; ax = 0
  7946                                  chWhich:
  7947                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7948 00001AB2 813E[0D1D][081D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7949 00001AB8 7409                    	je	short chHelp		; /? found - display help & exit
  7950                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7951 00001ABA 813E[0D1D][EE1C]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7952                                  	;je	short chRet		; /c found - ignore rest of line
  7953                                  	; 29/01/2023
  7954 00001AC0 75E6                    	jne	short chParse
  7955                                  	; MSDOS 6.0
  7956                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7957                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7958                                  	;je	short chRet		; /k found - ignore rest of line
  7959                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7960                                  chRet:
  7961 00001AC2 C3                      	retn
  7962                                  chHelp:
  7963                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7964 00001AC3 BE[9220]                	mov	si,HelpMsgs
  7965                                  chHelpNext:
  7966 00001AC6 AD                      	lodsw					; AX = ptr to msg
  7967 00001AC7 09C0                    	or	ax,ax
  7968 00001AC9 7407                    	jz	short chHelpDone		; end of list - all done
  7969 00001ACB 89C2                    	mov	dx,ax				; DX = ptr to msg
  7970 00001ACD E8A5F7                  	call	RPrint				; display msg
  7971 00001AD0 EBF4                    	jmp	short chHelpNext		; go do next msg
  7972                                  
  7973                                  chHelpDone:
  7974 00001AD2 CD20                    	int	20h				; terminate program
  7975                                  ;chRet:
  7976 00001AD4 C3                      	retn
  7977                                  
  7978                                  ;CheckHelp	endp
  7979                                  
  7980                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7981                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7982                                  
  7983                                  	; MSDOS 6.0
  7984                                  
  7985                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7986                                  ;
  7987                                  ; It determines based on 2 factors:
  7988                                  ;	1. Is this is the first COMMAND?
  7989                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7990                                  ;   The strategy works as follows:
  7991                                  ;
  7992                                  ;	if (First COMMAND)
  7993                                  ;	then if (COMMAND in HIMEM)
  7994                                  ;		ResSize = resident_data;
  7995                                  ;	     else
  7996                                  ;		ResSize = resident_data + resident_code;
  7997                                  ;	else
  7998                                  ;	   ResSize = resident_data;
  7999                                  ;
  8000                                  ; Int 2fh calls have been added to determine whether or not we are the first
  8001                                  ; COMMAND and whether DOS is in HIMEM.
  8002                                  ;
  8003                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  8004                                  ;
  8005                                  ;	EXIT:  ResSize = resident size in low memory
  8006                                  ;
  8007                                  ;	REGISTERS AFFECTED: ax,cx,dx
  8008                                  ;
  8009                                  
  8010                                  GET_HMA_ADDR	equ	4A02h
  8011                                  
  8012                                  Setup_res_end:	;proc near
  8013                                  	
  8014 00001AD5 1E                      	push	ds
  8015 00001AD6 8CC8                    	mov	ax,cs
  8016 00001AD8 8ED8                    	mov	ds,ax				;ds = RESGROUP
  8017                                  	;assume	ds:RESGROUP
  8018                                  
  8019 00001ADA 8B0E[9D03]              	mov	cx,[ResMsgEnd]			;set resident size = data
  8020                                  
  8021                                  ;ifndef	ROMDOS
  8022                                  
  8023                                  ;M042 -- Begin changes
  8024                                  ;If messages are to be kept behind, we need to round up the messages to
  8025                                  ;the next para boundary. This is because we have a dummy segment between the
  8026                                  ;data and the resident code segment so that the code segment starts on a
  8027                                  ;para boundary
  8028                                  
  8029                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  8030 00001ADE 81F9[F40B]              	cmp	cx,ExtMsgEnd
  8031 00001AE2 7506                    	jne	short calc_res			;no, continue
  8032 00001AE4 83C10F                  	add	cx,15				;round up
  8033 00001AE7 83E1F0                  	and	cx,0FFF0h
  8034                                  calc_res:
  8035                                  
  8036                                  ;M042 -- End changes
  8037                                  
  8038                                  	; 18/07/2024
  8039                                  	;xor	ax,ax
  8040                                         	
  8041 00001AEA 803E[C020]01            	cmp	byte [FirstCom],1		;is it first command.com?
  8042                                  	;jne	short not_first			;no, do not keep code
  8043                                  	; 06/06/2023
  8044 00001AEF 751A                    	jne	short not_first2
  8045                                  
  8046                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  8047                                  ;bit 4 of dh is set
  8048                                  
  8049 00001AF1 53                      	push	bx
  8050 00001AF2 51                      	push	cx
  8051                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  8052 00001AF3 B80633                  	mov	ax,3306h
  8053 00001AF6 CD21                    	int	21h
  8054                                  		; DOS - 5+ Get TRUE Version Number
  8055                                  		; (BL major, BH minor, DL revision, DH flags)
  8056 00001AF8 59                      	pop	cx
  8057                                  
  8058                                  ;bugbug: remove version check after testing
  8059                                  
  8060 00001AF9 80FB05                  	cmp	bl,5				;bl has true version ; M013
  8061 00001AFC 7207                    	jb	short oldver
  8062                                  
  8063 00001AFE 31C0                    	xor	ax,ax
  8064 00001B00 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  8065                                  	;pop	bx
  8066                                  	;jnz	short not_first			;DOS in HIMEM, code not
  8067                                  						;	resident
  8068                                  	; 29/01/2023
  8069 00001B03 7503                    	jnz	short not_first_pop
  8070                                  oldver:
  8071                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8072                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8073                                  	; 06/06/2023
  8074                                  	; 29/01/2023
  8075                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  8076                                  	; 03/05/2023
  8077 00001B05 B8(F908)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  8078                                  
  8079                                  not_first_pop:
  8080                                  	; 29/01/2023
  8081 00001B08 5B                      	pop	bx
  8082                                  
  8083                                  not_first:
  8084                                  
  8085                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  8086                                  
  8087 00001B09 01C1                    	add	cx,ax
  8088                                  
  8089                                  not_first2:	; 06/06/2023
  8090                                  
  8091                                  ;endif	;not ROMDOS
  8092                                  
  8093 00001B0B 83C10F                  	add	cx,15				;round up to next para
  8094 00001B0E D1E9                    	shr	cx,1
  8095 00001B10 D1E9                    	shr	cx,1
  8096 00001B12 D1E9                    	shr	cx,1
  8097 00001B14 D1E9                    	shr	cx,1				;ax = para size of res code
  8098 00001B16 890E[9F03]              	mov	[ResSize],cx			;store resident size
  8099                                  
  8100 00001B1A 1F                      	pop	ds
  8101                                  	;assume	ds:nothing
  8102 00001B1B C3                      	retn
  8103                                  
  8104                                  ;ifndef	ROMDOS
  8105                                  
  8106                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8107                                  
  8108                                  	; 29/01/2023
  8109                                  ;oldver:
  8110                                  ;	pop	bx
  8111                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8112                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8113                                  ;	; 29/01/2023
  8114                                  ;	mov	ax,EndCode-RCODE_START
  8115                                  ;	jmp	short not_first
  8116                                  
  8117                                  ;endif	;not ROMDOS
  8118                                  
  8119                                  ;setup_res_end	endp
  8120                                  
  8121                                  ;ifndef	ROMDOS
  8122                                  
  8123                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8124                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8125                                  
  8126                                  	; MSDOS 6.0
  8127                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8128                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8129                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8130                                  ; the correct resident size. When remaining low, we have to check if we 
  8131                                  ; need to overlay the messages part of the data segment which is determined
  8132                                  ; by the /msg switch.
  8133                                  ;
  8134                                  ;	ENTRY: ResMsgEnd = end of resident data
  8135                                  ;
  8136                                  ;	EXIT:  The resident code is either up high or in its final location
  8137                                  ;		down low.
  8138                                  ;
  8139                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8140                                  	
  8141                                  Move_res_code:	;proc near
  8142                                  
  8143 00001B1C 1E                      	push	ds
  8144 00001B1D 06                      	push	es
  8145                                  
  8146 00001B1E 8CC8                    	mov	ax,cs
  8147 00001B20 8ED8                    	mov	ds,ax
  8148                                  	;assume	ds:RESGROUP
  8149                                  
  8150                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8151 00001B22 B80633                  	mov	ax,3306h
  8152 00001B25 CD21                    	int	21h				;DOS in HIMEM?
  8153                                  		; DOS - 5+ Get TRUE Version Number
  8154                                  		; (BL major, BH minor, DL revision, DH flags)
  8155                                  
  8156 00001B27 80E610                  	and	dh,10h				; M013
  8157 00001B2A 750E                    	jnz	short move_high			;yes, move code high
  8158                                  
  8159                                  ;Check if messages have been discarded or not
  8160                                  
  8161                                  load_low:
  8162 00001B2C 1E                      	push	ds
  8163 00001B2D 07                      	pop	es				;es = RESGROUP
  8164 00001B2E 8B3E[9D03]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8165                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8166                                  	;mov	bx,ExtMsgEnd
  8167                                  	; 29/01/2023
  8168 00001B32 81FF[F40B]              	cmp	di,ExtMsgEnd
  8169                                  	;cmp	di,bx				;are messages to be kept?
  8170 00001B36 7431                    	je	short no_move			;yes, dont move code
  8171                                  
  8172 00001B38 EB37                    	jmp	short setup_move		;es:di points at dest.
  8173                                  
  8174                                  move_high:
  8175                                  
  8176                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8177                                  ;We pass in bx the number of bytes we need
  8178                                  
  8179                                  	;mov	bx,offset CODERES:EndCode
  8180                                  	; 29/01/2023
  8181                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8182                                  	; 06/06/2023
  8183                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8184                                  	; 03/05/2023
  8185 00001B3A BB(F908)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8186                                  
  8187                                  ;M030;
  8188                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8189                                  
  8190 00001B3D BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8191                                  						;this ; M030
  8192 00001B40 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8193 00001B43 CD2F                    	int	2Fh
  8194                                  
  8195                                  ;If the offset = 0xffff, then no HMA available
  8196                                  
  8197 00001B45 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8198 00001B48 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8199 00001B4D 7522                    	jne	short setup_move		;no error, es:di = memory
  8200                                  
  8201                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8202                                  	; 29/01/2023	
  8203 00001B4F FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8204                                  
  8205                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8206                                  ;ResSize to reflect this
  8207                                  
  8208 00001B53 8B0E[9D03]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8209                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8210                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8211                                  	;mov	ax,EndCode-RCODE_START
  8212                                  	;add	cx,ax
  8213                                  	; 06/06/2023
  8214                                  	; 29/01/2023
  8215                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8216                                  	;add	cx,15				;round up to next para
  8217                                  	; 03/05/2023
  8218 00001B57 81C1(0809)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8219 00001B5B D1E9                    	shr	cx,1
  8220 00001B5D D1E9                    	shr	cx,1
  8221 00001B5F D1E9                    	shr	cx,1
  8222 00001B61 D1E9                    	shr	cx,1				;ax = para size of res code
  8223 00001B63 890E[9F03]              	mov	[ResSize],cx			;store resident size
  8224 00001B67 EBC3                    	jmp	short load_low			;let code remain low
  8225                                  
  8226                                  no_move:
  8227                                  	; 05/05/2023
  8228                                  	;mov	cl,4
  8229 00001B69 83C70F                  	add	di,0Fh
  8230 00001B6C 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8231 00001B6F EB0B                    	jmp	short patch_up
  8232                                  
  8233                                  setup_move:
  8234                                  	;mov	si,offset RESGROUP:StartCode
  8235                                  	; 03/05/2023
  8236 00001B71 BE[000C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8237                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8238                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8239                                  	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8240                                  	; 06/06/2023
  8241                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8242                                  	; 03/05/2023
  8243 00001B74 B9(F908)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8244                                  
  8245 00001B77 FC                      	cld
  8246 00001B78 57                      	push	di				;need di for patching offset
  8247 00001B79 F3A4                    	rep	movsb
  8248 00001B7B 5F                      	pop	di
  8249                                  
  8250                                  patch_up:
  8251 00001B7C E84200                  	call	patch_stub
  8252 00001B7F 07                      	pop	es
  8253 00001B80 1F                      	pop	ds
  8254                                  	;assume	ds:nothing
  8255 00001B81 C3                      	retn
  8256                                  
  8257                                  ;Move_res_code endp
  8258                                  
  8259                                  ;else	;ROMDOS
  8260                                  ;
  8261                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8262                                  ;
  8263                                  ;Move_res_code	proc
  8264                                  ;
  8265                                  ;	push	es
  8266                                  ;
  8267                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8268                                  ;	call	patch_stub
  8269                                  ;
  8270                                  ;	pop	es
  8271                                  ;	ret
  8272                                  ;
  8273                                  ;Move_res_code	endp
  8274                                  ;
  8275                                  ;	assume	ds:NOTHING		; to match ending assume above
  8276                                  ;
  8277                                  ;endif	;ROMDOS
  8278                                  
  8279                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8280                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8281                                  
  8282                                  	; MSDOS 6.0
  8283                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8284                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8285                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8286                                  ; the contents of this temporary environment are copied to it. This routine
  8287                                  ; will not be called in case a valid environment is passed to command.com
  8288                                  ;
  8289                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8290                                  ;
  8291                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8292                                  ;
  8293                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8294                                  
  8295                                  alloc_env:	;proc near
  8296                                  	;assume ds:nothing
  8297                                  	
  8298 00001B82 1E                              push    ds
  8299 00001B83 06                      	push	es
  8300 00001B84 56                      	push	si
  8301 00001B85 57                      	push	di
  8302                                  
  8303                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8304                                  %if 0
  8305                                          push    ss
  8306                                          pop     ds
  8307                                  	;assume ds:RESGROUP
  8308                                  
  8309                                          mov     ax,[EnvirSeg]
  8310                                  
  8311                                          cmp	byte [AllocedEnv],0
  8312                                          je	short alloc_cont
  8313                                          jmp     alloc_done
  8314                                  
  8315                                  alloc_cont:
  8316                                          sub     di,di                           ; default start
  8317                                          ;mov	bx,SIZE Environment             ; default size needed
  8318                                  	; 29/01/2023
  8319                                  	mov	bx,ENVIRONSIZ
  8320                                  
  8321                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8322                                          je	short alloc_seg			; no
  8323                                  
  8324                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8325                                  ;   Record their respective locations and do not add the default vars.
  8326                                  
  8327                                  	or      ax,ax
  8328                                  	jz	short alloc_new			; no previous environment
  8329                                  
  8330                                          mov     es,ax
  8331                                  	;assume es:nothing
  8332                                  
  8333                                  _find_path:
  8334                                          mov     al,0
  8335                                          sub     di,di
  8336                                  comp_path:
  8337                                          scasb                                   ; end of env?
  8338                                  	je	short _find_prompt		; yes
  8339                                          dec     di
  8340                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8341                                          ;mov	si,offset RESGROUP:PathString
  8342                                  	mov	si,PathString	
  8343                                          repe    cmpsb
  8344                                          je	short got_path
  8345                                          mov	cx,256
  8346                                          repne   scasb                           ; find next NULL
  8347                                          jmp     short comp_path
  8348                                  
  8349                                  got_path:
  8350                                          mov	byte [PathString],0		; don't add it
  8351                                  
  8352                                  _find_prompt:
  8353                                          sub     di,di
  8354                                  comp_prompt:
  8355                                  	scasb                                   ; end of env?
  8356                                  	je	short find_comspec		; yes
  8357                                  	dec     di
  8358                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8359                                  	;mov	si,offset RESGROUP:PrmptString
  8360                                  	mov	si,PrmptString
  8361                                          repe    cmpsb
  8362                                          je	short got_prompt
  8363                                          mov     cx,256
  8364                                          repne   scasb                           ; find next NULL
  8365                                          jmp	short comp_prompt
  8366                                  
  8367                                  got_prompt:
  8368                                  	mov	byte [PrmptString],0		; don't add it
  8369                                  
  8370                                  find_comspec:
  8371                                          sub     di,di
  8372                                  comp_comspec:
  8373                                          scasb                                   ; end of env?
  8374                                          je	short got_envend		; yes
  8375                                          dec     di
  8376                                          mov	cx,ComspStrLen ; mov cx,8
  8377                                  	;mov	si,offset RESGROUP:ComspString
  8378                                  	mov	si,ComspString
  8379                                          repe    cmpsb
  8380                                          je	short got_comspec
  8381                                          mov     cx,256
  8382                                          repne   scasb                           ; find next NULL
  8383                                          jmp	short comp_comspec
  8384                                  
  8385                                  got_comspec:
  8386                                          mov     [ComspOffset],di
  8387                                  
  8388                                  find_envend:
  8389                                          sub     di,di
  8390                                          mov     cx,ENVBIG                       ; max env size
  8391                                  comp_envend:
  8392                                          dec     cx                              ;
  8393                                          scasb                                   ; end of env?
  8394                                          je	short got_envend		; yes
  8395                                          repne   scasb
  8396                                          jmp	short comp_envend
  8397                                  
  8398                                  got_envend:
  8399                                          dec     di
  8400                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8401                                  
  8402                                  ;   We want to fall through to alloc_new and set up default
  8403                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8404                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8405                                  
  8406                                          push    ds
  8407                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8408                                          mov	ds,[PDB.PARENT_PID]
  8409                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8410                                  	cmp	word [PDB.PARENT_PID],0
  8411                                  	pop     ds
  8412                                          jne	short alloc_seg			; no, we're not the first process
  8413                                                                                  ; so don't muck with the env.
  8414                                  alloc_new:
  8415                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8416                                  
  8417                                  alloc_seg:
  8418                                  
  8419                                  ; Allocate default environment size
  8420                                  
  8421                                          mov     cx,bx                           ; save byte-granular size in CX
  8422                                          add     bx,15
  8423                                          shr     bx,1
  8424                                          shr     bx,1
  8425                                          shr     bx,1
  8426                                          shr     bx,1                            ; BX = # paras
  8427                                  	mov	ah,ALLOC
  8428                                  	int	21h
  8429                                          jnc	short init_ok
  8430                                          jmp     init_nomem                      ; insufficient memory, error
  8431                                  
  8432                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8433                                  ; the new buffer
  8434                                  
  8435                                  init_ok:
  8436                                  	mov	es,ax
  8437                                  	;assume	es:nothing                      ; es = temp env segment
  8438                                  
  8439                                  	or      di,di
  8440                                          jz	short copy_path
  8441                                  
  8442                                          push    cx
  8443                                          push    ds
  8444                                          mov     ds,[EnvirSeg]
  8445                                          ;assume ds:nothing
  8446                                          sub     si,si
  8447                                          mov     cx,di
  8448                                          sub     di,di
  8449                                          rep     movsb
  8450                                          pop     ds
  8451                                          ;assume ds:RESGROUP
  8452                                          pop     cx
  8453                                          sub     cx,di
  8454                                  
  8455                                  copy_path:
  8456                                  
  8457                                  ; First clear out (the rest of) the buffer
  8458                                  
  8459                                          push    di
  8460                                          sub     ax,ax
  8461                                          rep     stosb
  8462                                          pop     di
  8463                                  
  8464                                  ; Initialize the path string (PATH=) first
  8465                                  
  8466                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8467                                  	mov	si,PathString
  8468                                          cmp     byte [si],al			; add it?
  8469                                          je	short init_prompt		; no
  8470                                  	;mov	cx,PathStrLen+1                 ;
  8471                                  	mov	cx,6 ; db "PATH=",0
  8472                                          rep     movsb                           ;
  8473                                          cmp     [AllocedEnv],al			; virgin env?
  8474                                          je	short init_prompt		; no
  8475                                  
  8476                                  ; Establish a more reasonable default for the PATH
  8477                                  
  8478                                  	;mov	ah,GET_DEFAULT_DRIVE
  8479                                  	mov	ah,19h
  8480                                  	int	21h
  8481                                          add     al,'A'                          ; convert to letter
  8482                                          mov     [DefPathString],al              ;
  8483                                          mov     [DefPath2String],al             ; now our default paths are complete
  8484                                  
  8485                                          mov     dl,0                            ; get dir for default drive
  8486                                          push    ds                              ;
  8487                                          push    es                              ;
  8488                                          pop     ds                              ;
  8489                                          mov     byte [di],'\'			;
  8490                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8491                                  	;mov	ah,Current_Dir                  ;
  8492                                          mov	ah,47h
  8493                                  	int     21h                             ;
  8494                                          pop     ds                              ;
  8495                                  
  8496                                  	;mov	cx,DefPathStrLen+1              ;
  8497                                  	mov	cx,9 ; db "C:\MSDOS",0
  8498                                  	;mov	dx,offset RESGROUP:DefPathString
  8499                                  	mov	dx,DefPathString 
  8500                                  	mov	si,dx                           ;
  8501                                          ;mov	ah,CHDir                        ;
  8502                                          mov	ah,3Bh
  8503                                  	int     21h                             ;
  8504                                          jnc	short init_setpath		; DefPathString exists!
  8505                                  
  8506                                  	;mov	cx,DefPath2StrLen+1		;
  8507                                          mov	cx,7 ; db "C:\DOS",0
  8508                                  	;mov	dx,offset RESGROUP:DefPath2String
  8509                                  	mov	dx,DefPath2String
  8510                                          mov     si,dx                           ;
  8511                                          ;mov	ah,CHDir                        ;
  8512                                          mov	ah,3Bh
  8513                                          int     21h                             ;
  8514                                          jc	short init_prompt		; DefPath2String doesn't exist
  8515                                  
  8516                                  init_setpath:
  8517                                          mov     dx,di                           ; success
  8518                                          push    ds                              ; so restore prev dir
  8519                                          push    es                              ;
  8520                                          pop     ds                              ; DS:DX -> prev dir
  8521                                          ;mov	ah,CHDir                        ;
  8522                                          mov	ah,3Bh
  8523                                          int     21h                             ;
  8524                                          pop     ds                              ;
  8525                                  
  8526                                          dec     di                              ; then copy in DefPathString
  8527                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8528                                  
  8529                                  ; Initialize the default prompt
  8530                                  
  8531                                  init_prompt:
  8532                                          push    di                              ;
  8533                                          sub     ax,ax                           ;
  8534                                          mov     cx,64                           ; insure any data read in
  8535                                          rep     stosb                           ; from Current_Dir is zapped
  8536                                          pop     di                              ;
  8537                                  
  8538                                  	cmp	[AllocedEnv],al			; virgin env?
  8539                                          je	short init_comspec		; no
  8540                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8541                                          mov	si,PrmptString
  8542                                  	cmp     [si],al				; add it?
  8543                                          je      short init_comspec		; no
  8544                                  	;mov	cx,PrmptStrLen+1                ;
  8545                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8546                                  	rep     movsb                           ;
  8547                                  
  8548                                  ; Initialize the Comspec string
  8549                                  
  8550                                  init_comspec:
  8551                                          cmp	[ComspOffset],ax		; add it?
  8552                                          jne	short init_done			; no
  8553                                          lea     ax,[di+ComspStrLen]             ;
  8554                                          mov	[ComspOffset],ax		;
  8555                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8556                                          mov	si,ComspString
  8557                                  	;mov	cx,ComspStrLen2+1               ;
  8558                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8559                                  	rep     movsb                           ;
  8560                                  
  8561                                  init_done:
  8562                                          mov     ax,es                           ; return env seg in ax
  8563                                          mov     [EnvirSeg],ax			; save env seg
  8564                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8565                                  %endif
  8566                                  
  8567                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8568                                  %if 1
  8569                                  	;mov	bx,10
  8570 00001B86 BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8571 00001B89 B448                    	mov	ah,48h
  8572 00001B8B CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8573                                  			; BX = number of 16-byte paragraphs desired
  8574 00001B8D 722C                    	jc	short init_nomem
  8575                                  
  8576                                  init_ok:
  8577 00001B8F 8EC0                    	mov	es,ax
  8578                                  	;assume	es:nothing                      ; es = temp env segment
  8579                                  
  8580 00001B91 31FF                    	xor	di,di
  8581 00001B93 89F8                    	mov	ax,di
  8582                                  	;mov	cx,160	
  8583 00001B95 B9A000                          mov     cx,ENVIRONSIZ
  8584 00001B98 F3AA                            rep	stosb
  8585                                  
  8586                                  init_pathstr:
  8587                                  
  8588                                  ; Initialize the path string (PATH=) first
  8589                                  
  8590 00001B9A 16                      	push	ss
  8591 00001B9B 1F                      	pop	ds
  8592                                  
  8593                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8594 00001B9C BE[531C]                	mov	si,PathString
  8595 00001B9F BF0000                  	mov	di,0
  8596                                  init_cp_pathstr:
  8597 00001BA2 AC                      	lodsb
  8598 00001BA3 AA                      	stosb
  8599 00001BA4 08C0                    	or	al,al
  8600 00001BA6 75FA                    	jnz	short init_cp_pathstr
  8601                                  
  8602                                  ; Initialize the Comspec string
  8603                                  
  8604                                  init_comspec:
  8605                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8606 00001BA8 BE[591C]                        mov	si,ComspString
  8607                                  	; 05/05/2023
  8608 00001BAB BF0600                  	mov	di,6
  8609                                  init_cp_compstr:
  8610 00001BAE AC                      	lodsb
  8611 00001BAF AA                      	stosb
  8612 00001BB0 08C0                    	or	al,al
  8613 00001BB2 75FA                    	jnz	short init_cp_compstr
  8614                                  
  8615                                  init_done:
  8616 00001BB4 8CC0                            mov     ax,es                           ; return env seg in ax
  8617                                          ;mov	[EnvirSeg],ax			; save env seg
  8618                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8619                                  %endif	
  8620                                  
  8621                                  	; 29/01/2023
  8622                                  alloc_done:
  8623 00001BB6 5F                      	pop	di
  8624 00001BB7 5E                      	pop	si
  8625 00001BB8 07                      	pop	es
  8626 00001BB9 1F                              pop     ds
  8627                                  	;assume	ds:nothing
  8628 00001BBA C3                      	retn
  8629                                  
  8630                                  	; 29/01/2023
  8631                                  init_nomem:
  8632                                  
  8633                                  ;We call the error routine from here. This routine never returns. It either
  8634                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8635                                  ;the system ( if it is the first COMMAND.COM ).
  8636                                  
  8637 00001BBB E80000                  	call	Alloc_error
  8638                                  
  8639                                  ;Alloc_env	endp
  8640                                  
  8641                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8642                                  ; check if this is a permanent or secondary command.com and take the 
  8643                                  ; appropriate action.
  8644                                  ;
  8645                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8646                                  ;
  8647                                  ;	EXIT:	None - does not return
  8648                                  ;
  8649                                  ;	REGISTERS AFFECTED: Does not matter
  8650                                  ;
  8651                                  
  8652                                  ;public Alloc_error
  8653                                  Alloc_error:	;proc	near
  8654                                  
  8655                                  	;jmp	RESGROUP:BadMemErr
  8656                                  	; 29/01/2023
  8657 00001BBE E946F1                  	jmp	BadMemErr	
  8658                                  	
  8659                                  ;Alloc_error	endp
  8660                                  
  8661                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8662                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8663                                  
  8664                                  	; MSDOS 6.0
  8665                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8666                                  ; the stub table of the various entry points in the resident code segment.
  8667                                  ; Some of them are interrupt entry points and some of them are entries from
  8668                                  ; the transient to the resident code segment.
  8669                                  ;
  8670                                  ;	ENTRY:	ds = RESGROUP
  8671                                  ;		es:di = segment:offset of final location of resident code
  8672                                  ;
  8673                                  ;	EXIT:	All segments and offsets patched into the stub table
  8674                                  ;
  8675                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8676                                  
  8677                                  patch_stub:	;proc near
  8678                                  	;assume	ds:RESGROUP
  8679                                  	
  8680 00001BC1 06                      	push	es
  8681                                  
  8682 00001BC2 8CC3                    	mov	bx,es			;bx = resident code segment
  8683 00001BC4 89FA                    	mov	dx,di
  8684                                  	;mov	di,offset DATARES:Int2f_Entry
  8685 00001BC6 BF[0400]                	mov	di,Int2f_Entry
  8686                                  	;mov	si,offset RESGROUP:Reloc_Table
  8687 00001BC9 BE[A620]                	mov	si,Reloc_Table
  8688 00001BCC 1E                      	push	ds
  8689 00001BCD 07                      	pop	es			;es = RESGROUP = DATARES
  8690                                  
  8691                                  ;bx:dx = segment:offset of resident code segment
  8692                                  ;es:di = entry point table in stub
  8693                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8694                                  
  8695                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8696 00001BCE B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8697                                  patchlp:
  8698 00001BD1 AD                      	lodsw				;get current offset
  8699 00001BD2 01D0                    	add	ax,dx			;offset it by code seg location 
  8700 00001BD4 AB                      	stosw				;store offset
  8701 00001BD5 89D8                    	mov	ax,bx			
  8702 00001BD7 AB                      	stosw				;store segment 
  8703 00001BD8 E2F7                    	loop	patchlp
  8704                                  
  8705 00001BDA 07                      	pop	es
  8706 00001BDB C3                      	retn
  8707                                  
  8708                                  ;Patch_stub	endp
  8709                                  
  8710                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8711                                  
  8712                                  	; MSDOS 6.0
  8713                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8714                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8715                                  ; are temporarily needed to handle these interrupts if they occur before
  8716                                  ; the resident is relocated to its final position and all the addresses of
  8717                                  ; the handlers have been updated.
  8718                                  ;
  8719                                  ;	ENTRY:	es = PSP segment = code segment
  8720                                  ;
  8721                                  ;	EXIT:	Current segment values patched into the jump table in the
  8722                                  ;		stub.
  8723                                  ;
  8724                                  ;	REGISTERS AFFECTED: ax, cx, di
  8725                                  
  8726                                  patch_segs:	;proc near
  8727                                  
  8728                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8729 00001BDC BF[0400]                	mov	di,Int2f_Entry 
  8730 00001BDF B90400                  	mov	cx,4			;we have to patch 4 handlers
  8731 00001BE2 83C702                  	add	di,2
  8732 00001BE5 8CC0                    	mov	ax,es
  8733                                  pseglp:
  8734 00001BE7 AB                      	stosw				;store the segment value
  8735 00001BE8 83C702                  	add	di,2			;skip the next offset value
  8736 00001BEB E2FA                    	loop	pseglp
  8737                                  
  8738 00001BED C3                      	retn
  8739                                  
  8740                                  ;Patch_segs	endp
  8741                                  
  8742                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8743                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8744                                  
  8745                                  	; MSDOS 6.0
  8746                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8747                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8748                                  ; and is used by the stub when we have to jump to the resident in HMA
  8749                                  ;
  8750                                  ;	ENTRY:	ds = RESGROUP
  8751                                  ;
  8752                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8753                                  ;
  8754                                  ;	REGISTERS AFFECTED:
  8755                                  ;
  8756                                  
  8757                                  get_XMMAddr:	;proc near
  8758                                  	;assume	ds:RESGROUP
  8759                                  
  8760 00001BEE 06                      	push	es
  8761                                  
  8762                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8763 00001BEF B80043                  	mov	ax,4300h
  8764 00001BF2 CD2F                    	int	2Fh
  8765                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8766                                  		; Return: AL = 80h XMS driver installed
  8767                                  		; AL <> 80h no driver
  8768 00001BF4 3C80                    	cmp	al,80h			; Q: installed
  8769 00001BF6 750D                    	jne	short cXMMexit		; N: set error, quit
  8770                                  ;
  8771                                  ; get the XMM control functions entry point, save it, we
  8772                                  ; need to call it later.
  8773                                  ;
  8774                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8775 00001BF8 B81043                  	mov	ax,4310h
  8776 00001BFB CD2F                    	int	2Fh
  8777                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8778                                  		; Return: ES:BX -> driver entry point
  8779                                  
  8780 00001BFD 891E[3000]              	mov	[XMMCallAddr], bx
  8781 00001C01 8C06[3200]              	mov	[XMMCallAddr+2],es
  8782                                  cXMMexit:
  8783 00001C05 07                      	pop	es
  8784 00001C06 C3                      	retn				; done
  8785                                  
  8786                                  ;get_XMMAddr	endp
  8787                                  
  8788                                  ;=============================================================================
  8789                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8790                                  ;=============================================================================
  8791                                  ; 24/09/2018 - Retro DOS v3.0
  8792                                  
  8793                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8794                                  
  8795                                  ; TITLE	COMMAND Initialization messages
  8796                                  
  8797                                  ;INIT	SEGMENT PUBLIC PARA
  8798                                  
  8799                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8800                                  
  8801                                  	; 25/09/2018
  8802                                  	; (15 bytes filler)
  8803 00001C07 00                      	db 0
  8804                                  	;db "25/9/2018 ETAN"
  8805                                  	; 15/06/2023
  8806                                  	;db "15/6/2023 ETAN"
  8807                                  	; 31/07/2024
  8808 00001C08 31342F382F32303234-     	db "14/8/2024 ETAN" ; 14/08/2024
  8808 00001C11 204554414E         
  8809 00001C16 00                      	db 0
  8810                                  
  8811                                  ; 30/01/2023
  8812                                  %if 0
  8813                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8814                                  	;dw 0
  8815                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8816                                  	db 0Dh,0Ah
  8817                                  	db 0Dh,0Ah
  8818                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8819                                  	db 0Dh,0Ah
  8820                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8821                                  	db ' ',0Dh,0Ah
  8822                                  	db '                                                   ',
  8823                                  	db 0Dh,0Ah,0
  8824                                  
  8825                                  	times 43 db 20h
  8826                                  
  8827                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8828                                  BADCOMLKMES:
  8829                                  	dw _152Fh
  8830                                  
  8831                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8832                                  BADCOMACCMSG:
  8833                                  	dw _155Ah
  8834                                  
  8835                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8836                                  ACCDENERR:
  8837                                  	dw _1593h
  8838                                  
  8839                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8840                                  OUTENVMSG:
  8841                                  	dw _15A5h
  8842                                  
  8843                                  BADVERMSG:
  8844                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8845                                  
  8846                                  BADENVSIZMSG:
  8847                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8848                                  
  8849                                  HEADERPTR:
  8850                                  	dw COPYRIGHTMSG
  8851                                  %endif
  8852                                  
  8853                                  ; 30/01/2023
  8854                                  ;align 16
  8855                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8856                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8857                                  ICONDEV:
  8858 00001C17 2F4445562F                      db '/DEV/'
  8859 00001C1C 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8860                                  BADCSPFL:
  8861 00001C25 00                      	db 0
  8862                                  COMSPECT:
  8863 00001C26 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8863 00001C2F 434F4D00           
  8864 00001C33 00                      	db 0
  8865                                  AUTOBAT:
  8866 00001C34 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8866 00001C3D 45432E424154000D   
  8867                                  ;KAUTOBAT:
  8868                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8869                                  PRDATTM:
  8870 00001C45 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8871                                  INITADD:
  8872 00001C46 00000000                	dd 0
  8873                                  print_add:
  8874 00001C4A [BF4D]                  	dw Printf_Init
  8875 00001C4C 0000                    	dw 0
  8876                                  triage_add:
  8877 00001C4E [9F2C]                  	dw Triage_Init
  8878 00001C50 0000                    	dw 0
  8879                                  ;CHUCKENV:
  8880                                  AllocedEnv:
  8881 00001C52 00                      	db 0
  8882                                  
  8883                                  ; 30/01/2023 - MSDOS 3.3
  8884                                  ;COMSPOFFSET:
  8885                                  ;ECOMLOC:
  8886                                  ;	;dw 0Eh
  8887                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8888                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8889                                  ;COMSPSTRING:
  8890                                  ;	db 'COMSPEC='
  8891                                  
  8892                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8893                                  PathString:
  8894 00001C53 504154483D00            	db 'PATH=',0
  8895                                  PathStrLen equ $-PathString-1
  8896                                  ; MSDOS 6.0
  8897                                  ;DefPathString:
  8898                                  ;	db 'C:\MSDOS',0
  8899                                  ;DefPathStrLen equ  $-DefPathString-1
  8900                                  ;DefPath2String:
  8901                                  ;	db 'C:\DOS',0
  8902                                  ;DefPath2StrLen equ $-DefPath2String-1
  8903                                  ;
  8904                                  ;PrmptString:
  8905                                  ;	db 'PROMPT=$P$G',0
  8906                                  ;PrmptStrLen equ $-PrmptString-1
  8907                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8908                                  ;ComspOffset:
  8909                                  ;	dw 0
  8910                                  ComspString:
  8911 00001C59 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8911 00001C62 434F4D4D414E442E43-
  8911 00001C6B 4F4D00             
  8912                                  ComspStrLen equ 8		; length of COMSPEC=
  8913                                  ComspStrLen2 equ $-ComspString-1
  8914                                  				; length of full COMSPEC
  8915                                  	; 29/01/2023
  8916                                  ;equal_sign:
  8917                                  ;equalsign:
  8918                                  ;	db '='
  8919                                  ;letter_a:
  8920                                  ;lcasea:
  8921                                  ;	db 'a'
  8922                                  ;letter_z:
  8923                                  ;lcasez:
  8924                                  ;	db 'z'
  8925                                  	; 30/01/2023
  8926                                  ;;slash_chr:
  8927                                  ;;	db '/'
  8928                                  ;;bslash_chr:
  8929                                  ;;	db '\'
  8930                                  ;space_chr:
  8931                                  ;;space:
  8932                                  ;	db 20h
  8933                                  ;;letter_p:
  8934                                  ;;	db 'p'
  8935                                  ;;letter_d:
  8936                                  ;;	db 'd'
  8937                                  ;;letter_c:
  8938                                  ;;	db 'c'
  8939                                  	; 16/04/2023
  8940                                  ; MSDOS 5.0 & MSDOS 6.0
  8941                                  ;scswitch:
  8942                                  ;	db 'C'		; Single command
  8943                                  ;;skswitch:
  8944                                  ;	db 'K' ; MSDOS 6.0
  8945                                  ;;letter_A:
  8946                                  ;ucasea: ; 21/01/2023 
  8947                                  ;	db 'A'
  8948                                  
  8949                                  	; 30/01/2023
  8950                                  EnvSiz:
  8951 00001C6E 0000                    	dw 0		; size user wants to allocate
  8952                                  EnvMax:
  8953 00001C70 0000                    	dw 0		; maximum size allowed
  8954                                  OldEnv:
  8955 00001C72 0000                    	dw 0		; envirseg at initialization
  8956                                  UsedEnv:
  8957 00001C74 0000                    	dw 0		; amount of envirseg used
  8958                                  	; MSDOS 5.0 & MSDOS 6.0
  8959                                  PARS_MSG_OFF:
  8960 00001C76 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8961                                  PARS_MSG_SEG:
  8962 00001C78 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8963                                  
  8964                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8965                                  
  8966                                  Init_Parse:
  8967                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8968                                  init_p:
  8969 00001C7A [BB4D]                  	dw append_parse
  8970                                  initend:
  8971 00001C7C 0000                    	dw 0		; segment address of end of init
  8972                                  TrnSize:
  8973 00001C7E 0000                    	dw 0		; size of transient in paragraphs
  8974                                  
  8975                                  ; 23/07/2024 - Retro DOS v4.1 (& 4.0) COMMAND.COM
  8976                                  ;%if 0
  8977                                  resetenv:
  8978                                  	;dw 0		; set if we need to setblck env at endinit
  8979                                  	; 23/07/2024
  8980 00001C80 00                      	db 0
  8981                                  ;%endif
  8982                                  
  8983                                  ext_msg:
  8984 00001C81 00                      	db 0		; set if /MSG switch entered
  8985                                  eswitch:
  8986 00001C82 00                      	db 0		; set if /e was entered
  8987                                  dswitch:
  8988 00001C83 00                      	db 0		; set if /d was entered
  8989                                  parsemes_ptr:
  8990 00001C84 0000                    	dw 0		; word to store parse error number
  8991                                  
  8992                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8993                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  8994                                  
  8995                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8996                                  ;  The following parse control block is used for COMMAND. This block is
  8997                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8998                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8999                                  ;
  9000                                  ;  Anything on the command line after the /C switch will be passed to the
  9001                                  ;  executable command, so if /C is used, it must be specified last. The
  9002                                  ;  /MSG switch can only be specified if the /P switch is specified.
  9003                                  ;
  9004                                  ;  The /? switch causes help text to be displayed. Any other options
  9005                                  ;  on the command line are ignored. Command.com will not load if /?
  9006                                  ;  is specified.
  9007                                  
  9008                                  INTERNAT_INFO:		; used for country info after parsing is completed
  9009                                  PARSE_COMMAND:
  9010 00001C86 [891C]                  	dw COMMAND_PARMS
  9011 00001C88 00                      	db 0			; no extra delimiter
  9012                                  COMMAND_PARMS:
  9013 00001C89 0002                    	db 0,2			; 1 positional parm
  9014 00001C8B [9F1C]                  	dw COMMAND_FILE
  9015 00001C8D [9F1C]                  	dw COMMAND_FILE
  9016                                          ; MSDOS 5.0
  9017 00001C8F 07                      	db 7			; 7 switches
  9018                                  	; MSDOS 6.0
  9019                                  	;db 8 			; 8 switches
  9020 00001C90 [A81C]                  	dw COMMAND_SWITCH1
  9021 00001C92 [B41C]                  	dw COMMAND_SWITCH2
  9022 00001C94 [C01C]                  	dw COMMAND_SWITCH3
  9023 00001C96 [CC1C]                  	dw COMMAND_SWITCH4
  9024 00001C98 [E51C]                  	dw COMMAND_SWITCH5
  9025 00001C9A [F11C]                  	dw COMMAND_SWITCH6
  9026 00001C9C [FF1C]                  	dw COMMAND_SWITCH7
  9027                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  9028 00001C9E 00                      	db 0			; no keywords
  9029                                  
  9030                                  COMMAND_FILE:
  9031 00001C9F 0102                    	dw 0201h		; filespec - optional
  9032 00001CA1 0100                    	dw 1			; capitalize - file table
  9033 00001CA3 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9034 00001CA5 [131D]                  	dw NO_VAL 		;
  9035 00001CA7 00                      	db 0			; no keywords
  9036                                  
  9037                                  COMMAND_SWITCH1:
  9038 00001CA8 0000                    	dw 0			; no match flags
  9039 00001CAA 0200                    	dw 2			; capitalize by char table
  9040 00001CAC [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9041 00001CAE [131D]                  	dw NO_VAL 		;
  9042 00001CB0 01                      	db 1			; 1 keyword
  9043                                  COMMAND_P_SYN:
  9044 00001CB1 2F5000                  	db '/P',0		; /P switch
  9045                                  
  9046                                  COMMAND_SWITCH2:
  9047 00001CB4 0000                    	dw 0			; no match flags
  9048 00001CB6 0200                    	dw 2			; capitalize by char table
  9049 00001CB8 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9050 00001CBA [131D]                  	dw NO_VAL 		;
  9051 00001CBC 01                      	db 1			; 1 keyword
  9052                                  COMMAND_F_SYN:
  9053 00001CBD 2F4600                  	db '/F',0		; /F switch
  9054                                  
  9055                                  COMMAND_SWITCH3:
  9056 00001CC0 0000                    	dw 0			; no match flags
  9057 00001CC2 0200                    	dw 2			; capitalize by char table
  9058 00001CC4 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9059 00001CC6 [131D]                  	dw NO_VAL 		;
  9060 00001CC8 01                      	db 1			; 1 keyword
  9061                                  COMMAND_D_SYN:
  9062 00001CC9 2F4400                  	db '/D',0		; /D switch
  9063                                  
  9064                                  COMMAND_SWITCH4:
  9065 00001CCC 0080                    	dw 8000h		; numeric value - required
  9066 00001CCE 0000                    	dw 0			; no function flags
  9067 00001CD0 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9068 00001CD2 [D81C]                  	dw COMMAND_E_VAL	; pointer to value list
  9069 00001CD4 01                      	db 1			; 1 keyword
  9070                                  COMMAND_E_SYN:
  9071 00001CD5 2F4500                  	db '/E',0		; /E switch
  9072                                  
  9073                                  COMMAND_E_VAL:
  9074 00001CD8 01                      	db 1			;
  9075 00001CD9 01                      	db 1			; 1 range
  9076 00001CDA 01                      	db 1			; returned if result
  9077                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  9078                                  	; MSDOS 5.0 COMMAND.COM
  9079                                  	; (RESGROUP:1F2Bh)
  9080 00001CDB A0000000                	dd 160	 ; ENVSML
  9081 00001CDF 00800000                	dd 32768 ; ENVBIG
  9082 00001CE3 00                      	db 0			; no numeric values
  9083 00001CE4 00                      	db 0			; no string values
  9084                                  
  9085                                  COMMAND_SWITCH5:
  9086 00001CE5 0000                    	dw 0			; no match flags
  9087 00001CE7 0200                    	dw 2			; capitalize by char table
  9088 00001CE9 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9089 00001CEB [131D]                  	dw NO_VAL 		;
  9090 00001CED 01                      	db 1			; 1 keyword
  9091                                  COMMAND_C_SYN:
  9092 00001CEE 2F4300                  	db '/C',0		; /C switch
  9093                                  
  9094                                  COMMAND_SWITCH6:
  9095 00001CF1 0000                    	dw 0			; no match flags
  9096 00001CF3 0200                    	dw 2			; capitalize by char table
  9097 00001CF5 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9098 00001CF7 [131D]                  	dw NO_VAL 		;
  9099 00001CF9 01                      	db 1			; 1 keyword
  9100                                  COMMAND_M_SYN:
  9101 00001CFA 2F4D534700              	db '/MSG',0		; /MSG switch
  9102                                  
  9103                                  COMMAND_SWITCH7:
  9104 00001CFF 0000                    	dw 0			; no match flags
  9105 00001D01 0200                    	dw 2			; capitalize by char table
  9106 00001D03 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9107 00001D05 [131D]                  	dw NO_VAL 		;
  9108 00001D07 01                      	db 1			; 1 keyword
  9109                                  COMMAND_?_SYN:
  9110 00001D08 2F3F00                  	db '/?',0 		; /? switch
  9111                                  
  9112                                  	; MSDOS 6.0
  9113                                  ;COMMAND_SWITCH8:
  9114                                  ;	dw 0			; no match flags
  9115                                  ;	dw 2			; capitalize by char table
  9116                                  ;	dw COMND1_OUTPUT	; result buffer
  9117                                  ;	dw NO_VAL 		;
  9118                                  ;	db 1			; 1 keyword
  9119                                  ;COMMAND_K_SYN:
  9120                                  ;	db '/K',0		; /K switch
  9121                                  
  9122                                  COMND1_OUTPUT:
  9123                                  COMND1_TYPE:
  9124 00001D0B 00                      	db 0			; type
  9125                                  COMND1_CODE:
  9126 00001D0C 00                      	db 0			; return value
  9127                                  COMND1_SYN:
  9128 00001D0D 0000                    	dw 0			; synonym pointer
  9129                                  COMND1_ADDR:
  9130 00001D0F 00000000                	dd 0			; numeric value / address
  9131                                  				; of string value
  9132                                  NO_VAL:
  9133 00001D13 00                      	db 0			; no values
  9134                                  num_positionals:
  9135 00001D14 0000                    	dw 0			; counter for positionals
  9136                                  old_parse_ptr:
  9137 00001D16 0000                    	dw 0			; SI position before calling parser
  9138                                  
  9139                                  	; 30/01/2023
  9140                                  ;***	INITIALIZATION MESSAGES
  9141                                  ;	-------------------------
  9142                                  ;	include	comimsg.inc	;M00
  9143                                  ;-----------------------------------------------------------------------------	
  9144                                  
  9145                                  BADVERMSG:
  9146 00001D18 17                      	db 23
  9147 00001D19 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9147 00001D22 20444F532076657273-
  9147 00001D2B 696F6E0D0A         
  9148                                  OUTENVMSG:
  9149 00001D30 1A                      	db 26
  9150 00001D31 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9150 00001D3A 7669726F6E6D656E74-
  9150 00001D43 2073706163650D0A   
  9151                                  COPYRIGHTMSG:
  9152 00001D4B 5E                      	db 94
  9153 00001D4C 0D0A                    	db 0Dh,0Ah
  9154 00001D4E 0D0A                    	db 0Dh,0Ah
  9155 00001D50 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9155 00001D59 285229204D532D444F-
  9155 00001D62 532852292056657273-
  9155 00001D6B 696F6E20352E30300D-
  9155 00001D74 0A                 
  9156 00001D75 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9156 00001D7E 20202020284329436F-
  9156 00001D87 70797269676874204D-
  9156 00001D90 6963726F736F667420-
  9156 00001D99 436F72702031393831-
  9156 00001DA2 2D313939312E0D0A   
  9157                                  BADCOMLKMES:
  9158 00001DAA 28                      	db 40
  9159 00001DAB 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9159 00001DB4 20434F4D4D414E4420-
  9159 00001DBD 736561726368206469-
  9159 00001DC6 726563746F72792062-
  9159 00001DCF 61640D0A           
  9160                                  BADCOMACCMSG:
  9161 00001DD3 36                      	db 54
  9162 00001DD4 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9162 00001DDD 20434F4D4D414E4420-
  9162 00001DE6 736561726368206469-
  9162 00001DEF 726563746F72792062-
  9162 00001DF8 616420             
  9163 00001DFB 616363657373206465-     	db 'access denied',0Dh,0Ah
  9163 00001E04 6E6965640D0A       
  9164                                  HELPMSG1:
  9165 00001E0A 3C                      	db 60
  9166 00001E0B 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9166 00001E14 6E657720696E737461-
  9166 00001E1D 6E6365206F66207468-
  9166 00001E26 65204D532D444F5320-
  9166 00001E2F 636F6D6D616E642069-
  9166 00001E38 6E7465727072657465-
  9166 00001E41 722E0D0A           
  9167 00001E45 0D0A                    	db 0Dh,0Ah
  9168                                  HELPMSG2:
  9169 00001E47 46                      	db 70
  9170 00001E48 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9170 00001E51 5B64726976653A5D70-
  9170 00001E5A 6174685D205B646576-
  9170 00001E63 6963655D205B2F453A-
  9170 00001E6C 6E6E6E6E6E5D205B2F-
  9170 00001E75 505D205B2F43207374-
  9170 00001E7E 72696E675D205B2F4D-
  9170 00001E87 53475D             
  9171 00001E8A 0D0A                    	db 0Dh,0Ah
  9172 00001E8C 0D0A                    	db 0Dh,0Ah
  9173                                  HELPMSG3:
  9174 00001E8E 48                              db 72
  9175 00001E8F 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9175 00001E98 5D7061746820202020-
  9175 00001EA1 537065636966696573-
  9175 00001EAA 207468652064697265-
  9175 00001EB3 63746F727920636F6E-
  9175 00001EBC 7461696E696E672043-
  9175 00001EC5 4F4D4D414E442E434F-
  9175 00001ECE 4D20               
  9176 00001ED0 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9177                                  HELPMSG4:
  9178 00001ED7 4D                      	db 77
  9179 00001ED8 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9179 00001EE1 202020202020202020-
  9179 00001EEA 537065636966696573-
  9179 00001EF3 207468652064657669-
  9179 00001EFC 636520746F20757365-
  9179 00001F05 20666F7220636F6D6D-
  9179 00001F0E 616E6420696E707574-
  9179 00001F17 20616E6420         
  9180 00001F1C 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9181                                  HELPMSG5:
  9182 00001F25 45                      	db 69
  9183 00001F26 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9183 00001F2F 6E2020202020202020-
  9183 00001F38 536574732074686520-
  9183 00001F41 696E697469616C2065-
  9183 00001F4A 6E7669726F6E6D656E-
  9183 00001F53 742073697A6520746F-
  9183 00001F5C 206E6E6E6E6E206279-
  9183 00001F65 7465732E           
  9184 00001F69 0D0A                    	db 0Dh,0Ah
  9185                                  HELPMSG6:
  9186 00001F6B 4D                      	db 77
  9187 00001F6C 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9187 00001F75 202020202020202020-
  9187 00001F7E 4D616B657320746865-
  9187 00001F87 206E657720636F6D6D-
  9187 00001F90 616E6420696E746572-
  9187 00001F99 707265746572207065-
  9187 00001FA2 726D616E656E7420   
  9188 00001FAA 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9188 00001FB3 6974292E0D0A       
  9189                                  HELPMSG7:
  9190 00001FB9 50                      	db 80
  9191 00001FBA 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9191 00001FC3 6E6720202020202020-
  9191 00001FCC 43617272696573206F-
  9191 00001FD5 75742074686520636F-
  9191 00001FDE 6D6D616E6420737065-
  9191 00001FE7 636966696564206279-
  9191 00001FF0 20737472696E672C20-
  9191 00001FF9 616E6420           
  9192 00001FFD 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9192 00002006 732E0D0A           
  9193                                  HELPMSG8:
  9194 0000200A 4E                      	db 78
  9195 0000200B 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9195 00002014 202020202020202020-
  9195 0000201D 537065636966696573-
  9195 00002026 207468617420616C6C-
  9195 0000202F 206572726F72206D65-
  9195 00002038 737361676573206265-
  9195 00002041 2073746F7265642069-
  9195 0000204A 6E20               
  9196 0000204C 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9196 00002055 6F750D0A           
  9197                                  HELPMSG9:
  9198 00002059 38                      	db 56
  9199 0000205A 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9199 00002063 202020202020202020-
  9199 0000206C 6E65656420746F2073-
  9199 00002075 706563696679202F50-
  9199 0000207E 207769746820746869-
  9199 00002087 73207377697463682E-
  9199 00002090 0D0A               
  9200                                  HelpMsgs:
  9201 00002092 [0A1E]                          dw HELPMSG1
  9202 00002094 [471E]                  	dw HELPMSG2
  9203 00002096 [8E1E]                  	dw HELPMSG3
  9204 00002098 [D71E]                  	dw HELPMSG4
  9205 0000209A [251F]                  	dw HELPMSG5
  9206 0000209C [6B1F]                  	dw HELPMSG6
  9207 0000209E [B91F]                  	dw HELPMSG7
  9208 000020A0 [0A20]                  	dw HELPMSG8
  9209 000020A2 [5920]                  	dw HELPMSG9
  9210                                  
  9211                                  	; 23/04/2023
  9212 000020A4 0000                    	dw 0
  9213                                  
  9214                                  ;-----------------------------------------------------------------------------
  9215                                  
  9216                                  ;SR;
  9217                                  ; This table of offsets is used by the init code to calculate the new offsets
  9218                                  ;for these labels after the resident code has been relocated
  9219                                  
  9220                                  ;Reloc_Table:
  9221                                  	;dw offset CODERES:MsgInt2fHandler
  9222                                  	;dw offset CODERES:Int_2e
  9223                                  	;dw offset CODERES:ContC
  9224                                  	;dw offset CODERES:DskErr
  9225                                  	;dw offset CODERES:Exec_Ret
  9226                                  	;dw offset CODERES:TRemCheck
  9227                                  	;dw offset CODERES:TrnLodCom1
  9228                                  	;dw offset CODERES:LodCom
  9229                                  	;dw offset CODERES:MsgRetriever
  9230                                  	;dw offset CODERES:THeadFix
  9231                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9232                                  
  9233                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9234                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9235                                  
  9236                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9237 000020A6 1707                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9238 000020A8 7301                    	dw Int_2e - RCODE_START		  ; 177h	
  9239 000020AA 3300                    	dw ContC - RCODE_START		  ; 035h
  9240 000020AC 3404                    	dw DSKERR - RCODE_START		  ; 445h
  9241 000020AE 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9242 000020B0 9702                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9243 000020B2 1104                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9244 000020B4 AA01                    	dw LodCom - RCODE_START		  ; 1AEh
  9245 000020B6 5A07                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9246 000020B8 B602                    	dw THeadFix - RCODE_START	  ; 2C2h
  9247 000020BA D307                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9248                                  
  9249                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9250                                  
  9251                                  ResJmpTable:
  9252 000020BC 00000000                	dd 0			; stores prev stub jump table addr
  9253                                  FirstCom:
  9254 000020C0 00                      	db 0			; flag set if first command.com
  9255                                  DevFlag:
  9256 000020C1 00                      	db 0
  9257                                  PathFlag:
  9258 000020C2 00                      	db 0
  9259                                  
  9260                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9261                                  	;times 13 db 0
  9262                                  
  9263                                  ; 30/01/2023
  9264                                  coderes_end equ $
  9265                                  
  9266                                  ;INIT	ENDS
  9267                                  
  9268                                  ;	END
  9269                                  
  9270                                  ;-----------------------------------------------------------------------------
  9271                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9272                                  ;-----------------------------------------------------------------------------
  9273                                  
  9274                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9275                                  	; 30/01/2023
  9276 000020C3 00                      db	0
  9277                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"
  9278 000020C4 526574726F20444F53-     db	"Retro DOS v4 COMMAND.COM by Erdogan Tan [2024]" ; 21/07/2024	
  9278 000020CD 20763420434F4D4D41-
  9278 000020D6 4E442E434F4D206279-
  9278 000020DF 204572646F67616E20-
  9278 000020E8 54616E205B32303234-
  9278 000020F1 5D                 
  9279 000020F2 00                      db	0
  9280                                  
  9281                                  ;-----------------------------------------------------------------------------
  9282                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9283                                  ;-----------------------------------------------------------------------------
  9284                                  
  9285                                  ;TAIL    SEGMENT PUBLIC PARA
  9286                                  ;        ORG     0
  9287                                  ;TRANSTART LABEL WORD
  9288                                  ;TAIL    ENDS
  9289                                  
  9290                                  ;ALIGN 16  ; 25/09/2018
  9291                                  
  9292                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9293                                  
  9294                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9295                                  numbertomod equ (numbertodiv % 16)
  9296                                  
  9297                                  %if numbertomod>0 & numbertomod<16
  9298 000020F3 00<rep Dh>              	times (16-numbertomod) db 0
  9299                                  %endif
  9300                                  
  9301                                  ; 30/01/2023
  9302                                  ;TRANSTART:
  9303                                  
  9304                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9305                                  ;	times	128 db 0	
  9306                                  
  9307                                  ;-----------------------------------------------------------------------------
  9308                                  ; SEGMENT - TRANSCODE
  9309                                  ;-----------------------------------------------------------------------------
  9310                                  
  9311                                  ;TRANGROUP: ; 21/04/2018
  9312                                  
  9313                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9314                                  ;-----------------------------------------------------------------------------
  9315                                  
  9316                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9317                                  
  9318                                  ; 21/04/2018 - Retro DOS v2.0
  9319                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9320                                  ; (these values must be changed when transcom.s source code is changed
  9321                                  ; and data offsets are changed)
  9322                                  ;
  9323                                  ; 30/04/2018
  9324                                  ; 29/04/2018
  9325                                  
  9326                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9327                                  ;COMMAND      EQU  012CH
  9328                                  ;DATINIT      EQU  2091H
  9329                                  ;HEADCALL     EQU  428FH
  9330                                  ;TRANSPACEEND EQU  4D5CH
  9331                                  ;TRANDATAEND  EQU  3F44H
  9332                                  
  9333                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9334                                  ;TRIAGE_INIT  EQU  1F15H
  9335                                  ;PRINTF_INIT  EQU  34E0H 
  9336                                  
  9337                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9338                                  
  9339                                  ;TPA	EQU  4293H
  9340                                  ;TRNLEN	EQU  04D6H
  9341                                  
  9342                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9343                                  ;COMMAND      EQU  012CH
  9344                                  ;DATINIT      EQU  206FH
  9345                                  ;HEADCALL     EQU  426FH
  9346                                  ; 09/01/2023
  9347                                  ;TRANSPACEEND EQU  4D3CH
  9348                                  ;TRANDATAEND  EQU  3F24H
  9349                                  ;TRIAGE_INIT  EQU  1EF3H
  9350                                  ;PRINTF_INIT  EQU  34BFH 
  9351                                  ;
  9352                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9353                                  
  9354                                  ;-----------------------------------------------------------------------------
  9355                                  ; ARENA.INC, MSDOS 6.0, 1991
  9356                                  ;-----------------------------------------------------------------------------
  9357                                  ; 13/10/2018 - Retro DOS 3.0
  9358                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9359                                  
  9360                                  ;BREAK <Memory arena structure>
  9361                                  
  9362                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9363                                  
  9364                                  ; arena item
  9365                                  
  9366                                  struc ARENA
  9367 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9368 00000001 ????                      .owner:	resw 1		; owner of arena item
  9369 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9370                                  endstruc
  9371                                  
  9372                                  ;-----------------------------------------------------------------------------
  9373                                  ;START OF TRANSIENT PORTION
  9374                                  ;This code is loaded at the end of memory and may be overwritten by
  9375                                  ;memory-intensive user programs.
  9376                                  ;-----------------------------------------------------------------------------
  9377                                  
  9378                                  ; 16/04/2023
  9379                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9380                                  ; 29/09/2018
  9381                                  ; 31/01/2023 
  9382                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9383                                  			; 09/01/2023
  9384                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9385                                  
  9386                                  ; 25/09/2018
  9387                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9388                                  ;
  9389                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9390                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9391                                  ;
  9392                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9393                                  ;
  9394                                  ;
  9395                                  ;COMTRANS:
  9396                                  ;
  9397                                  ; 20/10/2018 - Retro DOS v3.0	
  9398                                  ;INCBIN	"TRANCOM3.BIN"
  9399                                  ;
  9400                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9401                                  ;
  9402                                  ; 29/04/2018
  9403                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9404                                  ;
  9405                                  ;TIMES BSS_SIZE db 0
  9406                                  ;
  9407                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9408                                  
  9409                                  ;COMMANDCOMSIZE equ $ - 100h
  9410                                  
  9411                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9412                                  ; ============================================================================
  9413                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9414                                  ; ============================================================================
  9415                                  
  9416                                  ; ----------------------------------------------------------------------------
  9417                                  ; START OF TRANSIENT PORTION
  9418                                  ; ----------------------------------------------------------------------------
  9419                                  ; SEGMENT - TRANSCODE
  9420                                  ; ----------------------------------------------------------------------------
  9421                                  
  9422                                  ; 18/04/2023
  9423                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9424                                  
  9425                                  ; 18/04/2023
  9426                                  ;-----------------------------------------------------------------------------
  9427                                  ; TRANSCODE segment offset 0
  9428                                  TRANSIENTSTART:
  9429                                  
  9430                                  	; 31/01/2023
  9431 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9432                                  
  9433                                  ;============================================================================
  9434                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9435                                  ;============================================================================
  9436                                  ; 12/10/2018 - Retro DOS v3.0
  9437                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9438                                  
  9439                                  ;[ORG 100h]
  9440                                  
  9441                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9442                                  
  9443                                  ; ---------------------------------------------------------------------------
  9444                                  		
  9445                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9446                                  		; (TRANGROUP:0100h)
  9447                                  SETDRV:
  9448 00000100 B40E                    	mov	ah,0Eh
  9449                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9450 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9451                                  			; DL = new default drive number
  9452                                  			;		(0 = A, 1 = B, ..)
  9453                                  			; Return: AL = number of logical drives
  9454                                  
  9455                                  ; ---------------------------------------------------------------------------
  9456                                  
  9457                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9458                                  ; No registers (CS:IP) no flags, nothing.
  9459                                  
  9460                                  TCOMMAND:
  9461 00000104 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
  9462 00000109 B8FFFF                  	mov	ax,-1
  9463 0000010C 8706[9001]              	xchg	ax,[VerVal]
  9464 00000110 83F8FF                  	cmp	ax,-1
  9465 00000113 7404                    	je	short NOSETVER2
  9466 00000115 B42E                    	mov	ah,2Eh
  9467                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9468 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9469                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9470                                  NOSETVER2:
  9471 00000119 2EFF1E[A38A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9472 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9473 00000120 833E[8E01]FF            	cmp	word [SingleCom],-1
  9474 00000125 7505                    	jne	short COMMAND
  9475                                  _$EXITPREP:
  9476 00000127 0E                      	push	cs
  9477 00000128 1F                      	pop	ds
  9478 00000129 E91E20                  	jmp	_$EXIT		; Have finished the single command
  9479                                  
  9480                                  ; ---------------------------------------------------------------------------
  9481                                  ;
  9482                                  ; Main entry point from resident portion.
  9483                                  ;
  9484                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9485                                  ;   just beginning the processing of another command.
  9486                                  ;
  9487                                  ; ---------------------------------------------------------------------------
  9488                                  
  9489                                  ; We are not always sure of the state of the world at this time. We presume
  9490                                  ; worst case and initialize the relevant registers: segments and stack.
  9491                                  
  9492                                  COMMAND:
  9493 0000012C FC                      	cld
  9494 0000012D 8CC8                    	mov	ax,cs
  9495 0000012F FA                      	cli
  9496 00000130 8ED0                    	mov	ss,ax
  9497                                  	;mov	sp,offset TRANGROUP:STACK
  9498                                  				; 07/06/2023
  9499 00000132 BC[FE94]                	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
  9500                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9501 00000135 FB                      	sti
  9502                                  		
  9503 00000136 8EC0                    	mov	es,ax
  9504                                  		
  9505                                  	; MSDOS 6.0
  9506 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9507                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9508                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9509                                  	; 31/01/2023
  9510 0000013A E8714D                  	call	TSYSLOADMSG
  9511 0000013D C606[968D]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9512                                  
  9513                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9514                                  	;mov	ds,[ss:RESSEG]
  9515                                  	; 31/01/2023
  9516 00000142 8E1E[A58A]              	mov	ds,[RESSEG]
  9517 00000146 36C606[8188]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9518 0000014C 36C606[0489]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9519                                  
  9520                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9521                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9522                                  ; I guess not: the only circumstances in which we reload the command processor
  9523                                  ; is after a transient program execution. In this case, we let the current
  9524                                  ; directory lie where it may.
  9525                                  
  9526 00000152 09ED                    	or	bp,bp		; See if just read
  9527 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9528 00000156 36C706[8288]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9529 0000015D EB17                    	jmp	short NOSETBUF
  9530                                  TESTRDIR:
  9531 0000015F 803E[8C01]00            	cmp	byte [RestDir],0
  9532 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9533 00000166 1E                      	push	ds
  9534                                  
  9535                                  ; We have an unusual situation to handle. The user *may* have changed his
  9536                                  ; directory as a result of an internal command that got aborted. Restoring it
  9537                                  ; twice may not help us: the problem may never go away. We just attempt it
  9538                                  ; once and give up.
  9539                                  
  9540 00000167 C606[8C01]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9541                                  
  9542                                  	; Restore users directory
  9543 0000016C 0E                      	push	cs
  9544 0000016D 1F                      	pop	ds
  9545 0000016E BA[8789]                	mov	dx,USERDIR1
  9546 00000171 B43B                    	mov	ah,3Bh
  9547                                  	;mov	ah,CHDir ; 3Bh
  9548 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9549                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9550 00000175 1F                      	pop	ds
  9551                                  NOSETBUF:
  9552 00000176 803E[0102]00            	cmp	byte [PipeFiles],0
  9553 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9554 0000017D 803E[0002]00            	cmp	byte [PipeFlag],0
  9555 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9556 00000184 E8642B                  	call	PIPEDEL
  9557                                  NOPCLOSE:
  9558                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9559                                  	; 31/01/2023
  9560 00000187 C606[8401]00            	mov	byte [ExtCom],0 ; Flag internal command
  9561 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9562 0000018E 8ED8                    	mov	ds,ax
  9563 00000190 50                      	push	ax
  9564                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9565 00000191 BA[FE94]                	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
  9566                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9567 00000194 B80038                  	mov	ax,3800h
  9568                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9569 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9570                                  			; get current-country info
  9571                                  			; DS:DX	-> buffer for returned info
  9572 00000199 58                      	pop	ax
  9573 0000019A 2B06[A78A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9574 0000019E 53                      	push	bx
  9575 0000019F BB1000                  	mov	bx,16
  9576 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9577 000001A4 5B                      	pop	bx
  9578 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9579 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9580 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9581                                  SAVSIZ:
  9582                                  
  9583                                  ; AX is the number of bytes free in the buffer between the resident and the
  9584                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9585                                  
  9586 000001AC 3D0002                  	cmp	ax,512
  9587 000001AF 7603                    	jbe	short GOTSIZE
  9588                                  	;and	ax,~1FFh
  9589 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9590                                  GOTSIZE:
  9591 000001B4 A3[C48A]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9592 000001B7 8E1E[A58A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9593                                  
  9594 000001BB F606[8801]01            	test	byte [EchoFlag],1 
  9595 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9596 000001C2 E8052B                  	call	SINGLETEST
  9597 000001C5 7219                    	jb	short GETCOM
  9598 000001C7 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1
  9599 000001CC 7512                    	jnz	short GETCOM
  9600                                  				; G  Don't print prompt in FOR
  9601 000001CE F606[9401]FF            	test	byte [ForFlag],0FFh ; -1
  9602 000001D3 750B                    	jnz	short GETCOM
  9603                                  				; G  Don't print prompt if in batch
  9604 000001D5 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
  9605 000001DB 7503                    	jnz	short GETCOM
  9606 000001DD E8EF23                  	call	CRLF2
  9607                                  GETCOM:
  9608 000001E0 C606[9901]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9609 000001E5 C606[9A01]00            	mov	byte [Call_Batch_Flag],0
  9610 000001EA B419                    	mov	ah,19h
  9611                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9612 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9613 000001EE 36A2[B78A]              	mov	[ss:CURDRV],al
  9614 000001F2 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9615 000001F7 7403                    	jz	short NOPIPE
  9616 000001F9 E9BA2B                  	jmp	PIPEPROC	; Continue the pipeline
  9617                                  NOPIPE:
  9618 000001FC F606[8801]01            	test	byte [EchoFlag],1
  9619 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9620 00000203 E8C42A                  	call	SINGLETEST
  9621 00000206 7212                    	jb	short NOPDRV
  9622 00000208 F606[9401]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9623 0000020D 750B                    	jnz	short NOPDRV
  9624 0000020F F706[3401]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9625 00000215 750D                    	jnz	short TESTFORBAT
  9626 00000217 E8771B                  	call	PRINT_PROMPT	; Prompt the user
  9627                                  NOPDRV:
  9628 0000021A F606[9401]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9629 0000021F 7403                    	jz	short TESTFORBAT
  9630 00000221 E9B70B                  	jmp	FORPROC		; Continue the FOR
  9631                                  
  9632                                  TESTFORBAT:
  9633 00000224 36C606[508A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9634 0000022A C606[AF01]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9635 0000022F C606[AE01]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9636 00000234 C606[9301]00            	mov	byte [IfFlag],0	; no more ifs...
  9637 00000239 F706[3401]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9638 0000023F 7441                    	jz	short ISNOBAT
  9639                                  
  9640                                  	; 31/01/2023
  9641                                  
  9642                                  	; MSDOS 6.0
  9643                                  
  9644                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9645                                  
  9646 00000241 06                      	push	es			;AN000; save ES
  9647 00000242 1E                      	push	ds			;AN000; save DS
  9648                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9649                                  	; 05/02/2023
  9650 00000243 B80219                  	mov	ax,1902h
  9651 00000246 8E06[3401]              	mov	es,[Batch]		;AN000; get batch segment
  9652                                  	;mov	di,20h
  9653 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9654 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9655 0000024E 1F                      	pop	ds			;AN000;
  9656                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9657 0000024F BA[0489]                	mov	dx,COMBUF
  9658 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9659                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9660                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9661                                  		; final filename element uppercased
  9662                                  		; DS:DX -> buffer for results
  9663                                  	;cmp	al,0FFh
  9664 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9665 00000256 1F                      	pop	ds			;AN000; restore DS
  9666 00000257 07                      	pop	es			;AN000; restore ES
  9667 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9668                                  
  9669                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9670 0000025A 1E                      	push	ds
  9671 0000025B E81603                  	call	READBAT			; Continue BATCH
  9672 0000025E 1F                      	pop	ds
  9673 0000025F C606[9D01]00            	mov	byte [NullFlag],0	;G reset no command flag
  9674 00000264 F706[3401]FFFF          	test	word [Batch],0FFFFh
  9675 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9676 0000026C 8B1E[9B01]              	mov	bx,[Next_Batch]
  9677                                  	; 31/01/2023
  9678 00000270 09DB                    	or	bx,bx
  9679                                  	;cmp	bx,0			;G see if there is a new batch file
  9680 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9681 00000274 891E[3401]              	mov	[Batch],bx		;G get segment of next batch file
  9682 00000278 C706[9B01]0000          	mov	word [Next_Batch],0	;G reset next batch
  9683                                  JDOCOM1:
  9684 0000027E 0E                      	push	cs
  9685 0000027F 1F                      	pop	ds
  9686 00000280 EB55                    	jmp	short DOCOM1
  9687                                  ISNOBAT:
  9688 00000282 833E[8E01]00            	cmp	word [SingleCom],0
  9689 00000287 741C                    	jz	short REGCOM
  9690                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9691 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9692 0000028C 8736[8E01]              	xchg	si,[SingleCom]
  9693 00000290 BF[0689]                	mov	di,COMBUF+2
  9694 00000293 31C9                    	xor	cx,cx
  9695                                  SINGLELOOP:
  9696 00000295 AC                      	lodsb
  9697 00000296 AA                      	stosb
  9698 00000297 41                      	inc	cx
  9699 00000298 3C0D                    	cmp	al,0Dh
  9700 0000029A 75F9                    	jnz	short SINGLELOOP
  9701 0000029C 49                      	dec	cx
  9702 0000029D 0E                      	push	cs
  9703 0000029E 1F                      	pop	ds
  9704 0000029F 880E[0589]              	mov	[COMBUF+1],cl
  9705                                  
  9706                                  ; do NOT issue a trailing CRLF...
  9707                                  
  9708 000002A3 EB32                    	jmp	short DOCOM1
  9709                                  
  9710                                  	;nop
  9711                                  
  9712                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9713                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9714                                  
  9715                                  ; We have a normal command.  
  9716                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9717                                  ; sometimes they aren't. At this point, we automatically close all spool
  9718                                  ; files and turn on truncation mode.
  9719                                  
  9720                                  REGCOM:
  9721                                  	;mov	ax,(ServerCall shl 8) + 9
  9722                                  	; 31/01/2023
  9723 000002A5 B8095D                  	mov	ax,5D09h
  9724                                  	;mov	ax,(SERVERCALL<<8)+9
  9725 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9726                                  	;mov	ax,(ServerCall shl 8) + 8
  9727 000002AA B8085D                  	mov	ax,5D08h
  9728                                  	;mov	ax,(SERVERCALL<<8)+8
  9729 000002AD B201                    	mov	dl,1
  9730 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9731                                  			; DL = 00h redirected output is	combined
  9732                                  			;      01h redirected output placed in separate	jobs
  9733                                  			; start	new print job now
  9734 000002B1 0E                      	push	cs
  9735 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9736 000002B3 BA[8188]                	mov	dx,UCOMBUF
  9737                                  
  9738                                  	; MSDOS 6.0
  9739                                  ;	Try to read interactive command line via DOSKey.
  9740                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9741                                  
  9742                                  	; 31/01/2023
  9743 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9744 000002B9 CD2F                    	int	2Fh
  9745 000002BB 09C0                    	or	ax,ax
  9746 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9747                                  
  9748 000002BF B40A                    	mov	ah,0Ah
  9749                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9750 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9751                                  			; DS:DX	-> buffer
  9752                                  GOTCOM:
  9753 000002C3 8A0E[8188]              	mov	cl,[UCOMBUF]
  9754 000002C7 30ED                    	xor	ch,ch
  9755 000002C9 83C103                  	add	cx,3
  9756 000002CC BE[8188]                	mov	si,UCOMBUF
  9757 000002CF BF[0489]                	mov	di,COMBUF
  9758 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9759                                  DOCOM:
  9760 000002D4 E8F822                  	call	CRLF2
  9761                                  DOCOM1:
  9762 000002D7 E87C26                  	call	PRESCAN		; Cook the input buffer
  9763 000002DA 7406                    	jz	short NOPIPEPROC
  9764 000002DC E9562A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9765                                  
  9766                                  NULLCOMJ:
  9767 000002DF E9FA00                  	jmp	NULLCOM
  9768                                  
  9769                                  NOPIPEPROC:
  9770 000002E2 E84E2D                  	call	PARSELINE
  9771 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9772                                  BADPARSE:
  9773 000002E7 0E                      	push	cs
  9774 000002E8 1F                      	pop	ds
  9775 000002E9 BA[1F7F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9776 000002EC E8DA4A                  	call	std_eprintf
  9777 000002EF E912FE                  	jmp	TCOMMAND
  9778                                  
  9779                                  OKPARSE:
  9780                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9781                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9782                                  	; 01/02/2023
  9783 000002F2 F606[B28D]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9784 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9785                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9786 000002F9 833E[7090]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9787 000002FE 74DF                    	jz	short NULLCOMJ
  9788                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9789 00000300 833E[B58D]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9790 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9791                                  
  9792 00000307 BE[0689]                	mov	si,COMBUF+2
  9793 0000030A BF[2B8B]                	mov	di,IDLEN
  9794                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9795                                  				; Make FCB with blank scan-off
  9796                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9797 0000030D B80129                  	mov	ax,2901h
  9798 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9799                                  			; DS:SI	-> string to parse
  9800                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9801                                  			; AL = bit mask	to control parsing
  9802                                  	;mov	bx,[ARG_ARGV]
  9803 00000312 8B1E[B08D]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9804 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9805 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9806 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9807                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9808                                  	;and	dl,~20h
  9809 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9810                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9811                                  	; 31/01/2023
  9812 00000321 80EA41                  	sub	dl,'A'
  9813 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9814 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9815                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9816 00000328 8B3E[B38D]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9817 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9818 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9819 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9820                                  DRVBADJ:
  9821 00000334 E92125                  	jmp	DRVBAD
  9822                                  DRVGD:
  9823 00000337 8A05                    	mov	al,[di]
  9824 00000339 A2[C38A]                	mov	[SPECDRV],al
  9825 0000033C B020                    	mov	al,' '
  9826 0000033E B90900                  	mov	cx,9
  9827 00000341 47                      	inc	di
  9828 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9829 00000344 B008                    	mov	al,8
  9830 00000346 28C8                    	sub	al,cl
  9831 00000348 A2[2B8B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9832 0000034B BF8100                  	mov	di,81h
  9833 0000034E 56                      	push	si
  9834 0000034F BE[0689]                	mov	si,COMBUF+2	; Skip over all leading delims
  9835 00000352 E88722                  	call	scanoff
  9836                                  
  9837                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9838                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9839                                  
  9840                                  	; MSDOS 6.0
  9841                                  ;SR;
  9842                                  ; We are going to skip over the first char always. The logic is that the
  9843                                  ;command tail can never start from the first character. The code below is 
  9844                                  ;trying to figure out the command tail and copy it to the command line 
  9845                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9846                                  ;character and the user given command line is a full 128 bytes, we try to
  9847                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9848                                  ;char overwrites the code and leads to a crash on future commands.
  9849                                  
  9850 00000355 46                      	inc	si ;  MSDOS 6.0
  9851                                  DO_SKIPCOM:
  9852 00000356 AC                      	lodsb			; move command line pointer over
  9853 00000357 E88A22                  	call	DELIM		; pathname -- have to do it ourselves
  9854 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9855 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9856 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9857 00000360 3A06[A98A]              	cmp	al,[SWITCHAR]	; specified command string
  9858 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9859                                  DO_SKIPPED:
  9860 00000366 4E                      	dec	si
  9861 00000367 31C9                    	xor	cx,cx
  9862                                  COMTAIL:
  9863 00000369 AC                      	lodsb
  9864 0000036A AA                      	stosb			; Move command tail to 80h
  9865 0000036B 3C0D                    	cmp	al,0Dh
  9866 0000036D E0FA                    	loopne	COMTAIL
  9867 0000036F 4F                      	dec	di
  9868 00000370 89FD                    	mov	bp,di
  9869 00000372 F6D1                    	not	cl
  9870 00000374 880E8000                	mov	[80h],cl
  9871 00000378 5E                      	pop	si
  9872                                  ;-----
  9873                                  ; Some of these comments are sadly at odds with this brave new code.
  9874                                  ;-----
  9875                                  ; If the command has 0 parameters must check here for
  9876                                  ; any switches that might be present.
  9877                                  ; SI -> first character after the command.
  9878                                  
  9879                                  	;mov	di,arg.argv[0].argsw_word
  9880                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9881 00000379 8B3E[B78D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9882 0000037D 893E[BA8A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9883                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9884                                  				; s = argv[1];
  9885                                  	;mov	si,[ARGV1_ARGPOINTER]
  9886 00000381 8B36[BB8D]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9887 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9888 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9889 00000389 89EE                    	mov	si,bp
  9890                                  DOPARSE:
  9891 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9892                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9893                                  	; 01/02/2023
  9894 0000038E B80129                  	mov	ax,2901h
  9895                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9896 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9897                                  			; DS:SI	-> string to parse
  9898                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9899                                  			; AL = bit mask	to control parsing
  9900 00000393 A2[B88A]                	mov	[PARM1],al	; Save result of parse
  9901                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9902                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9903 00000396 8B3E[C28D]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9904 0000039A 893E[BC8A]              	mov	[ARG1S],di
  9905                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9906                                  				; s = argv[2];
  9907                                  	;mov	si,[ARGV2_ARGPOINTER]
  9908 0000039E 8B36[C68D]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9909 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9910 000003A4 7502                    	jnz	short DOPARSE2
  9911 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9912                                  DOPARSE2:			
  9913 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9914                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9915 000003AB B80129                  	mov	ax,2901h
  9916                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9917 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9918                                  			; DS:SI	-> string to parse
  9919                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9920                                  			; AL = bit mask	to control parsing
  9921 000003B0 A2[B98A]                	mov	[PARM2],al	; Save result
  9922                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9923                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9924 000003B3 8B3E[CD8D]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9925 000003B7 893E[BE8A]              	mov	[ARG2S],di
  9926                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9927                                  	;mov	di,arg.argv[0].argsw_word
  9928 000003BB 8B3E[B78D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9929 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9930                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9931                                  	;and	di,arg.argswinfo	
  9932 000003C1 233E[7290]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9933 000003C5 893E[C08A]              	mov	[ARGTS],di
  9934                                  
  9935 000003C9 A0[2B8B]                	mov	al,[IDLEN]
  9936 000003CC 8A16[C38A]              	mov	dl,[SPECDRV]
  9937 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9938 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9939 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9940 000003D6 E9D223                  	jmp	FNDCOM		; otherwise, check internal com table
  9941                                  EXTERNALJ1:
  9942 000003D9 E9D424                  	jmp	EXTERNAL
  9943                                  NULLCOM:
  9944 000003DC 8E1E[A58A]              	mov	ds,[RESSEG]
  9945 000003E0 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9946 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9947 000003E8 C606[9D01]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9948                                  	;mov	byte [NullFlag],nullcommand ; 1
  9949                                  NOSETFLAG:
  9950 000003ED 833E[8E01]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9951 000003F2 7403                    	je	short EXITJ
  9952 000003F4 E9E9FD                  	jmp	GETCOM
  9953                                  EXITJ:
  9954 000003F7 E92DFD                  	jmp	_$EXITPREP
  9955                                  
  9956                                  ;============================================================================
  9957                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9958                                  ;============================================================================
  9959                                  ; 12/10/2018 - Retro DOS v3.0
  9960                                  
  9961                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9962                                  
  9963                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9964                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9965                                  ;   there is a header that describes a block of rom program.  This header
  9966                                  ;   contains information needed to initialize a module and to provide PCDOS
  9967                                  ;   with a set of reserved names for execution.
  9968                                  ;
  9969                                  ;   This header has the following format:
  9970                                  ;
  9971                                  ;   rom_header	STRUC
  9972                                  ;	Signature1  DB	55h
  9973                                  ;	Signature2  DB	AAh
  9974                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9975                                  ;	init_jmp    DB	3 dup (?)
  9976                                  ;	name_list   name_struc <>
  9977                                  ;   rom_header	ENDS
  9978                                  ;
  9979                                  ;   name_struc	STRUC
  9980                                  ;	name_len    DB	?
  9981                                  ;	name_text   DB	? DUP (?)
  9982                                  ;	name_jmp    DB	3 DUP (?)
  9983                                  ;   name_struc	ENDS
  9984                                  ;
  9985                                  ;   The name list is a list of names that are reserved by a particular section
  9986                                  ;   of a module.  This list of names is terminated by a null name (length
  9987                                  ;   is zero).
  9988                                  ;
  9989                                  ;   Consider now, the PCDOS action when a user enters a command:
  9990                                  ;
  9991                                  ;	COMMAND.COM has control.
  9992                                  ;	o   If location FFFFEh has FDh then
  9993                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  9994                                  ;		    by AAh, stop scan if we get above or = F0000H
  9995                                  ;	o	When we've found one, compare the name entered by the user
  9996                                  ;		    with the one found in the rom.  If we have a match, then
  9997                                  ;		    set up the environment for execution and do a long jump
  9998                                  ;		    to the near jump after the found name.
  9999                                  ;	o	If no more names in the list, then continue scanning the module
 10000                                  ;		    for more 55h followed by AAh.
 10001                                  ;	o   We get to this point only if there is no matching name in the
 10002                                  ;		rom.  We now look on disk for the command.
 10003                                  ;
 10004                                  ;   This gives us the flexibility to execute any rom cartridge without having
 10005                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10006                                  ;   want to be invisible to the DOS should not have any names in their lists
 10007                                  ;   (i.e. they have a single null name).
 10008                                  ;
 10009                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10010                                  ;   Clearly this version will be available on disk.  How does a user actually
 10011                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10012                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10013                                  ;   solution:
 10014                                  ;
 10015                                  ;   o	Keep things consistent and force the user to have his software named
 10016                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10017                                  
 10018                                  struc ROM_HEADER
 10019 00000000 ??                          .signature1: resb 1
 10020 00000001 ??                          .signature2: resb 1
 10021 00000002 ??                          .rom_length: resb 1
 10022 00000003 ??????                      .init_jmp:	 resb 3
 10023 00000006 ??                          .name_list:	 resb 1
 10024                                      .size:
 10025                                  endstruc
 10026                                  
 10027                                  struc NAME_STRUC
 10028 00000000 ??                          .name_len:	resb 1
 10029 00000001 ??                          .name_text:	resb 1
 10030 00000002 ??????                      .name_jmp:	resb 3
 10031                                      .size:	
 10032                                  endstruc
 10033                                  
 10034                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10035                                  
 10036                                  ; =============== S U B	R O U T	I N E =======================================
 10037                                  
 10038                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10039                                  
 10040                                  ; 05/02/2023
 10041                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10042                                  
 10043                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10044                                  
 10045                                  ROM_SCAN:
 10046 000003FA 06                      	push	es
 10047 000003FB 56                      	push	si
 10048 000003FC 57                      	push	di
 10049 000003FD 51                      	push	cx
 10050 000003FE 50                      	push	ax
 10051 000003FF 53                      	push	bx
 10052                                  
 10053                                  	; check for PC Jr signature in rom
 10054                                  
 10055 00000400 B800F0                  	mov	ax,0F000h
 10056 00000403 8EC0                    	mov	es,ax
 10057 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10058 0000040B 7408                    	je	short SCAN_IT
 10059                                  NO_ROM:
 10060 0000040D F8                      	clc
 10061                                  ROM_RET:
 10062 0000040E 5B                      	pop	bx
 10063 0000040F 58                      	pop	ax
 10064 00000410 59                      	pop	cx
 10065 00000411 5F                      	pop	di
 10066 00000412 5E                      	pop	si
 10067 00000413 07                      	pop	es
 10068 00000414 C3                      	retn
 10069                                  
 10070                                  	; start scanning at C000h
 10071                                  SCAN_IT:
 10072 00000415 B800C0                  	mov	ax,0C000h
 10073                                  SCAN_ONE:
 10074 00000418 8EC0                    	mov	es,ax
 10075 0000041A 31FF                    	xor	di,di
 10076                                  
 10077                                  	; check for a valid header
 10078                                  SCAN_MODULE:
 10079 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
 10080 00000421 740A                    	je	short SCAN_LIST
 10081 00000423 058000                  	add	ax,80h
 10082                                  SCAN_END:
 10083 00000426 3D00F0                  	cmp	ax,0F000h
 10084 00000429 72ED                    	jb	short SCAN_ONE
 10085 0000042B EBE0                    	jmp	short NO_ROM
 10086                                  
 10087                                  	; trundle down list of names
 10088                                  SCAN_LIST:
 10089                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10090 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10091 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
 10092 00000433 D1E3                    	shl	bx,1
 10093 00000435 D1E3                    	shl	bx,1		; number of paragraphs
 10094 00000437 83C37F                  	add	bx,7Fh
 10095 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
 10096                                  	;mov	di,6
 10097                                  	; 05/05/2023
 10098 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
 10099                                  	;nop
 10100                                  SCAN_NAME:
 10101 00000440 268A0D                  	mov	cl,[es:di]	; length of name
 10102 00000443 47                      	inc	di		; point to name
 10103 00000444 30ED                    	xor	ch,ch
 10104 00000446 09C9                    	or	cx,cx		; zero length name
 10105 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
 10106 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
 10107 0000044C EBD8                    	jmp	short SCAN_END
 10108                                  
 10109                                  	; compare a single name
 10110                                  SCAN_TEST:
 10111 0000044E 89D6                    	mov	si,dx
 10112 00000450 46                      	inc	si
 10113 00000451 F3A6                    	repe cmpsb		 ; compare name
 10114 00000453 7407                    	jz	short SCAN_FOUND ; success!
 10115                                  SCAN_NEXT:
 10116 00000455 01CF                    	add	di,cx		; failure, next name piece
 10117 00000457 83C703                  	add	di,3
 10118 0000045A EBE4                    	jmp	short SCAN_NAME
 10119                                  
 10120                                  	; found a name. save entry location
 10121                                  SCAN_FOUND:	
 10122 0000045C 803C3F                  	cmp	byte [si],'?'
 10123 0000045F 7405                    	je	short SCAN_SAVE
 10124 00000461 803C20                  	cmp	byte [si],' '
 10125 00000464 75EF                    	jne	short SCAN_NEXT
 10126                                  SCAN_SAVE:
 10127 00000466 2E8C06[268C]            	mov	[cs:ROM_CS],es
 10128 0000046B 2E893E[248C]            	mov	[cs:ROM_IP],di
 10129 00000470 F9                      	stc
 10130 00000471 EB9B                    	jmp	short ROM_RET
 10131                                  
 10132                                  ; ---------------------------------------------------------------------------
 10133                                  
 10134                                  ; execute a rom-placed body of code. allocate largest block
 10135                                  
 10136                                  ROM_EXEC:
 10137 00000473 BBFFFF                  	mov	bx,0FFFFh
 10138                                  	; 05/02/2023
 10139 00000476 B448                    	mov	ah,48h
 10140                                  	;mov	ah,ALLOC ; 48h
 10141 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10142                                  			; BX = number of 16-byte paragraphs desired
 10143 0000047A B448                    	mov	ah,48h
 10144                                  	;mov	ah,ALLOC ; 48h
 10145 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10146                                  			; BX = number of 16-byte paragraphs desired
 10147 0000047E 53                      	push	bx
 10148 0000047F 50                      	push	ax
 10149                                  
 10150                                  	; set terminate addresses
 10151                                  
 10152 00000480 B82225                  	mov	ax,2522h
 10153                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10154                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10155 00000483 1E                      	push	ds
 10156 00000484 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 10157                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10158                                  	;mov	dx,131h ; MSDOS 3.3
 10159                                  	; 05/02/2023
 10160                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10161 00000489 BA[290C]                	mov	dx,Exec_Wait
 10162 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10163                                  			; AL = interrupt number
 10164                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10165 0000048E 8CDA                    	mov	dx,ds
 10166 00000490 8EC2                    	mov	es,dx
 10167 00000492 1F                      	pop	ds
 10168                                  		
 10169                                  	; and create program header and dup all jfn's
 10170                                  
 10171 00000493 5A                      	pop	dx
 10172 00000494 B455                    	mov	ah,55h
 10173                                  	;mov	ah,DUP_PDB ; 55h
 10174 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10175                                  			; DX = segment number at which to set up PSP
 10176                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10177                                  		
 10178                                  	; set up dma address
 10179                                  
 10180 00000498 8EDA                    	mov	ds,dx
 10181 0000049A BA8000                  	mov	dx,80h
 10182 0000049D B41A                    	mov	ah,1Ah
 10183                                  	;mov	ah,Set_DMA ; 1Ah
 10184 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10185                                  			; DS:DX	-> disk	transfer buffer
 10186                                  
 10187                                  	; copy in environment info
 10188                                  
 10189 000004A1 26A1[2703]              	mov	ax,[es:EnvirSeg]
 10190                                  	;mov	[2Ch],ax
 10191 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10192                                  
 10193                                  	; set up correct size of block
 10194                                  
 10195 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10196 000004A9 8CDA                    	mov	dx,ds
 10197 000004AB 01DA                    	add	dx,bx
 10198                                  	;mov	[2],dx
 10199 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10200                                  
 10201                                  	; change ownership of block
 10202                                  
 10203 000004B1 8CDA                    	mov	dx,ds
 10204 000004B3 4A                      	dec	dx
 10205 000004B4 8EDA                    	mov	ds,dx
 10206 000004B6 42                      	inc	dx	
 10207                                  	;mov	[1],dx
 10208 000004B7 89160100                	mov	[ARENA.owner],dx
 10209 000004BB 8EDA                    	mov	ds,dx
 10210                                  
 10211                                  	; set up correct stack
 10212                                  
 10213 000004BD 81FB0010                	cmp	bx,1000h
 10214 000004C1 7202                    	jb	short GOT_STACK
 10215 000004C3 31DB                    	xor	bx,bx
 10216                                  GOT_STACK:
 10217 000004C5 B104                    	mov	cl,4
 10218 000004C7 D3E3                    	shl	bx,cl
 10219 000004C9 8CDA                    	mov	dx,ds
 10220 000004CB 8ED2                    	mov	ss,dx
 10221 000004CD 89DC                    	mov	sp,bx
 10222 000004CF 31C0                    	xor	ax,ax
 10223 000004D1 50                      	push	ax
 10224                                  
 10225                                  	; set up initial registers and go to the guy
 10226                                  
 10227 000004D2 F7D0                    	not	ax
 10228 000004D4 2EFF36[268C]            	push	word [cs:ROM_CS]
 10229 000004D9 2EFF36[248C]            	push	word [cs:ROM_IP]
 10230 000004DE 8EC2                    	mov	es,dx
 10231 000004E0 CB                      	retf	; far return
 10232                                  
 10233                                  ;============================================================================
 10234                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10235                                  ;============================================================================
 10236                                  ; 12/10/2018 - Retro DOS v3.0
 10237                                  
 10238                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10239                                  
 10240                                  ; =============== S U B	R O U T	I N E =======================================
 10241                                  
 10242                                  ;Break	<PromptBat - Open or wait for batch file>
 10243                                  
 10244                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10245                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10246                                  
 10247                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10248                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10249                                  ; file. Leave segment registers alone.
 10250                                  
 10251                                  PROMPTBAT:
 10252 000004E1 E84808                  	call	BATOPEN
 10253 000004E4 7201                    	jc	short PROMPTBAT1
 10254 000004E6 C3                      	retn
 10255                                  PROMPTBAT1:
 10256                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10257                                  	; MSDOS 6.0 COMMAND.COM
 10258 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10259 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10260 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10261 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10262                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10263 000004F1 E83500                  	call	output_batch_name
 10264 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10265                                  
 10266                                  	; 05/02/2023
 10267                                  	; MSDOS 3.3 COMMAND.COM
 10268                                  	;cmp	dx,ACCDENPTR
 10269                                  	;jz	short BATDIE
 10270                                  
 10271                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10272                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10273 000004F6 2EFF1E[AF8A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10274 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10275                                  
 10276                                  ; The media is not changeable. Turn everything off.
 10277                                  
 10278 000004FD E83D0B                  	call	FOROFF
 10279 00000500 E8632A                  	call	PipeOff
 10280 00000503 A2[9301]                	mov	[IfFlag],al	; No If in progress.	
 10281 00000506 BA[197F]                	mov	dx,BADBAT_PTR
 10282                                  BATDIE:
 10283 00000509 E8F003                  	call	BATCHOFF
 10284 0000050C 0E                      	push	cs
 10285 0000050D 1F                      	pop	ds
 10286                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10287                                  	; 05/02/2023
 10288 0000050E E8B848                  	call	std_eprintf	; MSDOS 6.0
 10289                                  	;call	STD_PRINTF	; MSDOS 3.3
 10290                                  
 10291                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10292                                  
 10293 00000511 E9F0FB                  	jmp	TCOMMAND
 10294                                  
 10295                                  ; Ask the user to reinsert the batch file
 10296                                  
 10297                                  ASKFORBAT:
 10298 00000514 1E                      	push	ds
 10299 00000515 0E                      	push	cs
 10300 00000516 1F                      	pop	ds
 10301                                  
 10302                                  	; MSDOS 6.0
 10303                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10304 00000517 BA[1C7F]                	mov	dx,NEEDBAT_PTR
 10305                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10306                                  	; 05/02/2023
 10307 0000051A E8AC48                  	call	std_eprintf
 10308                                  	;mov	dx,offset trangroup:pausemes_ptr
 10309 0000051D BA[8E7F]                	mov	dx,PAUSEMES_PTR
 10310                                  	;invoke std_eprintf		;AN000; get second part of message
 10311 00000520 E8A648                  	call	std_eprintf
 10312                                  					;AN000; print it to stderr
 10313                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10314                                  	;call	STD_EPRINTF
 10315 00000523 E82E00                  	call	GETKEYSTROKE
 10316 00000526 1F                      	pop	ds
 10317 00000527 EBB8                    	jmp	short PROMPTBAT
 10318                                  
 10319                                  
 10320                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10321                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10322                                  
 10323                                  	; MSDOS 6.0
 10324                                  ;****************************************************************
 10325                                  ;*
 10326                                  ;* ROUTINE:	Output_batch_name
 10327                                  ;*
 10328                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10329                                  ;*
 10330                                  ;* INPUT:	DX - extended error number
 10331                                  ;*
 10332                                  ;* OUTPUT:	Ready to call print routine
 10333                                  ;*
 10334                                  ;****************************************************************
 10335                                  ;
 10336                                  ;public	output_batch_name		;AN022;
 10337                                  
 10338                                  output_batch_name:	;proc near	;AN022;
 10339                                  
 10340 00000529 1E                      	push	ds			;AN022; save resident segment
 10341 0000052A 8E1E[3401]              	mov	ds,[Batch]		;AN022; get batch file segment
 10342                                  	;assume	DS:nothing		;AN022;
 10343                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10344                                  	; 05/02/2023
 10345                                  	;mov	si,20h
 10346                                  	; 24/04/2023
 10347 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10348                                  	;invoke	dstrlen 		;AN022; get length of string
 10349 00000531 E83627                  	call	dstrlen
 10350                                  	;mov	di,offset Trangroup:bwdbuf
 10351                                  					;AN022; target for batch name
 10352 00000534 BF[AA8B]                	mov	di,BWDBUF
 10353 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10354                                  
 10355 00000539 0E                      	push	cs			;AN022; get local segment
 10356 0000053A 1F                      	pop	ds			;AN022;
 10357                                  	;assume	DS:trangroup		;AN022;
 10358                                  	; 05/02/2023
 10359 0000053B 8916[FC7E]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10360                                  	;mov	byte [msg_disp_class],1
 10361 0000053F C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 10362                                  					;AN022; set up extended error msg class
 10363                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10364 00000544 BA[FC7E]                	mov	dx,extend_buf_ptr	
 10365                                  					;AN022; get extended message pointer
 10366                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10367 00000547 C706[118C][AA8B]        	mov	word [string_ptr_2],BWDBUF	
 10368                                  					;AN022; point to substitution
 10369                                  	;mov	byte [extend_buf_sub],1
 10370 0000054D C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 10371                                  					;AN022; set up for one subst
 10372 00000552 1F                      	pop	ds			;AN022; restore data segment
 10373 00000553 C3                      	retn				;AN022; return
 10374                                  
 10375                                  ;output_batch_name    endp		;AN022;
 10376                                  
 10377                                  
 10378                                  ; =============== S U B	R O U T	I N E =======================================
 10379                                  
 10380                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10381                                  
 10382                                  ; Read the next keystroke. Since there may be several characters in the queue
 10383                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10384                                  ; AFTER waiting.
 10385                                  
 10386                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10387                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10388                                  
 10389                                  GETKEYSTROKE:
 10390                                  	; 05/02/2023
 10391                                  	; MSDOS 3.3
 10392                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10393                                  	;;mov	ax,0C08h
 10394                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10395                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10396                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10397                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10398                                  	;;mov	ax,0C00h
 10399                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10400                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10401                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10402                                  	;retn
 10403                                  
 10404                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10405                                  	; MSDOS 6.0
 10406 00000554 52                      	push	dx			;AN000;  3/3/KK
 10407                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10408                                  					;AN000;  3/3/KK
 10409 00000555 B80263                  	mov	ax,6302h
 10410 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10411                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10412                                  	
 10413 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10414                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10415                                  					;AN000;  3/3/KK
 10416 0000055B B80163                  	mov	ax,6301h
 10417 0000055E B201                    	mov	dl,1
 10418                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10419 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10420                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10421                                  		; DL = new mode
 10422                                  		; 00h return only full characters on DOS keyboard input functions
 10423                                  		; 01h return partially-formed characters also
 10424                                  	
 10425                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10426 00000562 B8080C                  	mov	ax,0C08h
 10427 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10428                                  		; DOS - CLEAR KEYBOARD BUFFER
 10429                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10430                                  
 10431                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10432 00000567 B8000C                  	mov	ax,0C00h
 10433 0000056A CD21                    	int	21h
 10434                                  		; DOS - CLEAR KEYBOARD BUFFER
 10435                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10436                                  
 10437                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10438                                  					;AN000;  3/3/KK
 10439 0000056C B80163                  	mov	ax,6301h
 10440 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10441 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10442 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10443                                  	
 10444 00000573 C3                      	retn
 10445                                  
 10446                                  ; =============== S U B	R O U T	I N E =======================================
 10447                                  
 10448                                  ; Break	<ReadBat - read 1 line from batch file>
 10449                                  
 10450                                  ; ReadBat - read a single line from the batch file. 
 10451                                  ; Perform all substitutions as appropriate.
 10452                                  
 10453                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10454                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10455                                  
 10456                                  READBAT:
 10457                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10458                                  		
 10459                                  	;mov	byte [Suppress],1
 10460                                  				; initialize line suppress status
 10461 00000574 C606[8901]01            	mov	byte [Suppress],YES_ECHO
 10462 00000579 F606[7E01]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10463 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10464 00000580 C606[7D01]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10465                                  
 10466                                  	; MSDOS 6.0
 10467                                  
 10468                                  ;M037; Start of changes
 10469                                  ; We check here if we have set the flag indicating that the batchfile is at
 10470                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10471                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10472                                  ;batch file gets closed etc. and then return as if everything is done.
 10473                                  
 10474                                  	; 05/02/2023
 10475 00000585 1E                      	push	ds
 10476 00000586 8E1E[3401]              	mov	ds,[Batch]
 10477                                  	;cmp	byte [2],0
 10478 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10479                                  				; are we at EOF in batchfile
 10480 0000058F 1F                      	pop	ds
 10481 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10482                                  	;invoke	GetBatByt	; frees up batchseg
 10483 00000592 E8D303                  	call	GETBATBYT
 10484 00000595 26A2[0689]              	mov	[es:COMBUF+2],al
 10485                                  				; stuff CR into command buffer
 10486                                  				; as a dummy command
 10487                                  	;;invoke CrLf2		; print a CR-LF
 10488                                  	;call	CRLF2
 10489                                  	;;return		; done batch processing
 10490                                  	;retn
 10491                                  	; 24/04/2023
 10492 00000599 E93320                  	jmp	CRLF2
 10493                                  
 10494                                  ;M037; End of changes
 10495                                  		
 10496                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10497                                  CONTBAT:
 10498 0000059C E842FF                  	call	PROMPTBAT
 10499                                  
 10500                                  TRYING_TO_ABORT:
 10501 0000059F BF[0689]                	mov	di,COMBUF+2
 10502                                  
 10503                                  ; Save position and try to scan for first non delimiter.
 10504                                  
 10505                                  TESTNOP:
 10506 000005A2 8CD8                    	mov	ax,ds
 10507 000005A4 8E1E[3401]              	mov	ds,[Batch]
 10508 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10509 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10510                                  				; save current location.
 10511 000005B0 8ED8                    	mov	ds,ax
 10512 000005B2 E84B06                  	call	SKIPDELIM	; skip to first non-delim
 10513                                  
 10514                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10515                                  ; beginning and read the line.
 10516                                  
 10517 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10518 000005B7 59                      	pop	cx
 10519 000005B8 5A                      	pop	dx		; restore position in bat file
 10520 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10521 000005BB F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10522 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10523                                  
 10524                                  	;cmp	al,'@'
 10525 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10526 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10527                                  	;mov	byte [Suppress],0
 10528 000005C7 C606[8901]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10529 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10530                                  	;nop
 10531                                  SET_BAT_POS:
 10532 000005CE 1E                      	push	ds
 10533 000005CF 8E1E[3401]              	mov	ds,[Batch]
 10534                                  	;mov	[8],dx
 10535 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10536                                  	;mov	[10],cx
 10537 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10538 000005DB 1F                      	pop	ds
 10539                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10540                                  	; 05/02/2023
 10541 000005DC B80042                  	mov	ax,4200h
 10542                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10543 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10544                                  			; AL = method: offset from beginning of	file
 10545                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10546                                  	; 24/04/2023
 10547                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10548 000005E1 26C706[2795]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10549                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10550 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10551 000005EA EB0F                    	jmp	short RDBAT
 10552                                  
 10553                                  	;nop
 10554                                  
 10555                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10556                                  ; We eat characters until a CR is seen.
 10557                                  
 10558                                  NOPLINE:
 10559 000005EC E80501                  	call	SKIPTOEOL
 10560 000005EF E87603                  	call	GETBATBYT	; eat trailing LF
 10561                                  	;test	word [Batch],0FFFFh
 10562 000005F2 F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10563 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10564                                  READBAT_RETN:			; Hit EOF
 10565 000005FA C3                      	retn
 10566                                  
 10567                                  ; ---------------------------------------------------------------------------
 10568                                  
 10569                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10570                                  ; input, we are to consider two special cases:
 10571                                  ;
 10572                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10573                                  ;   %sym%	This is a symbol from the environment
 10574                                  
 10575                                  RDBAT:
 10576 000005FB E86A03                  	call	GETBATBYT
 10577 000005FE 41                      	inc	cx		; Inc the line length
 10578                                  
 10579                                  	; 05/02/2023
 10580                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10581 000005FF E8BB1D                  	call	testkanj
 10582 00000602 740C                    	jz	short RDBAT1
 10583                                  	;cmp	cx,127
 10584 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10585 00000607 7350                    	jnb	short TOOLONG
 10586 00000609 AA                      	stosb
 10587 0000060A E85B03                  	call    GETBATBYT
 10588 0000060D 41                      	inc	cx
 10589 0000060E EB0A                    	jmp	short SAVBATBYT
 10590                                  RDBAT1:
 10591 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10592 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10593                                  
 10594                                  ; See if we have a parameter character.
 10595                                  
 10596 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10597 00000618 7449                    	je	short NEEDPARM
 10598                                  
 10599                                  ; no parameter character. Store it as usual and see if we are done.
 10600                                  
 10601                                  SAVBATBYT:
 10602 0000061A AA                      	stosb			; End of line found?
 10603 0000061B 3C0D                    	cmp	al,0Dh
 10604 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10605                                  
 10606                                  ; We have read in an entire line. 
 10607                                  ; Decide whether we should echo the command line or not.
 10608                                  
 10609                                  FOUND_EOL:
 10610 0000061F 81EF[0789]              	sub	di,COMBUF+3
 10611 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10612 00000625 26A2[0589]              	mov	[es:COMBUF+1],al
 10613                                  				; Set length of line
 10614 00000629 E83C03                  	call	GETBATBYT	; Eat linefeed
 10615 0000062C E8E906                  	call	BATCLOSE
 10616 0000062F 803E[8901]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10617 00000634 7407                    	jz	short RESET
 10618 00000636 F606[8801]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10619 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10620                                  RESET:
 10621 0000063D 0E                      	push	cs
 10622 0000063E 1F                      	pop	ds		; Go back to local segment
 10623 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10624                                  TRY_NEXTFLAG:
 10625 00000641 803E[9D01]01            	cmp	byte [NullFlag],nullcommand ; 1
 10626                                  				;G was there a command last time?
 10627 00000646 7403                    	jz	short NO_CRLF_PRINT
 10628                                  				;G no - don't print crlf
 10629 00000648 E8841F                  	call	CRLF2		;G Print out prompt
 10630                                  NO_CRLF_PRINT:
 10631 0000064B E84317                  	call	PRINT_PROMPT
 10632 0000064E 0E                      	push	cs		;G change data segment
 10633 0000064F 1F                      	pop	ds
 10634 00000650 BA[0689]                	mov	dx,COMBUF+2	; get command line for echoing
 10635 00000653 E8D21F                  	call	CRPRINT
 10636                                  	;call	CRLF2
 10637                                  	;retn
 10638                                  	; 06/02/2023
 10639 00000656 E9761F                  	jmp	CRLF2
 10640                                  
 10641                                  ; The line was too long. Eat remainder of input text up until the CR
 10642                                  
 10643                                  TOOLONG:
 10644 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10645 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10646 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10647                                  LTLCONT:
 10648 00000660 AA                      	stosb			; Terminate the command
 10649 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10650                                  
 10651                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10652                                  
 10653                                  NEEDPARM:
 10654 00000663 E80203                  	call	GETBATBYT	; get next character
 10655 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10656 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10657 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10658 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10659                                  
 10660                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10661                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10662                                  ; see if the <something> has a terminating % and then look up the contents
 10663                                  ; in the environment.
 10664                                  
 10665                                  PAROK:
 10666 0000066E 2C30                    	sub	al,'0'
 10667 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10668 00000672 3C09                    	cmp	al,9
 10669 00000674 7735                    	ja	short NEEDENV
 10670                                  
 10671                                  ; We have found %<number>. This is taken from the parameters in the
 10672                                  ; allocated batch area.
 10673                                  
 10674 00000676 98                      	cbw
 10675 00000677 89C3                    	mov	bx,ax		; move index into AX
 10676 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10677 0000067B 06                      	push	es
 10678 0000067C 8E06[3401]              	mov	es,[Batch]
 10679                                  
 10680                                  ; The structure of the batch area is:
 10681                                  ;
 10682                                  ;   BYTE    type of segment
 10683                                  ;   DWORD   offset for next line
 10684                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10685                                  ;   ASCIZ   file name (with . and ..)
 10686                                  ;   BYTES   CR-terminated parameters
 10687                                  ;   BYTE    0 flag to indicate end of parameters
 10688                                  ;
 10689                                  ; Get pointer to BX'th argument
 10690                                  
 10691                                  	;;mov	si,[es:bx+0Bh]
 10692                                  	; 05/02/2023
 10693                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10694 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10695 00000684 07                      	pop	es
 10696                                  
 10697                                  ; Is there a parameter here?
 10698                                  
 10699 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10700 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10701 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10702                                  
 10703                                  ; Copy in the found parameter from batch segment
 10704                                  
 10705                                  YES_THERE_IS:
 10706 0000068D 1E                      	push	ds
 10707 0000068E 8E1E[3401]              	mov	ds,[Batch]
 10708 00000692 49                      	dec	cx		; Don't count '%' in line length
 10709                                  COPYPARM:
 10710 00000693 AC                      	lodsb			; From resident segment
 10711 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10712 00000696 740F                    	je	short ENDPARAM
 10713 00000698 41                      	inc	cx		; Inc the line length
 10714 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10715 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10716 0000069F AA                      	stosb
 10717 000006A0 EBF1                    	jmp	short COPYPARM
 10718                                  
 10719                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10720                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10721                                  ; believing that we are at EOL. Clobber AL too.
 10722                                  
 10723                                  LINETOOL:
 10724 000006A2 30C0                    	xor	al,al
 10725 000006A4 1F                      	pop	ds
 10726 000006A5 EBB2                    	jmp	short TOOLONG
 10727                                  
 10728                                  ; We have copied in an entire parameter. Go back for more
 10729                                  
 10730                                  ENDPARAM:
 10731 000006A7 1F                      	pop	ds
 10732 000006A8 E950FF                  	jmp	RDBAT
 10733                                  
 10734                                  ; We have found % followed by something other than 0-9. We presume that there
 10735                                  ; will be a following % character. In between is an environment variable that
 10736                                  ; we will fetch and replace in the batch line with its value.
 10737                                  
 10738                                  NEEDENV:
 10739                                  	; MSDOS 6.0 COMMAND.COM
 10740                                  	; 05/02/2023 
 10741 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10742                                  
 10743                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10744 000006AC 1E                      	push	ds
 10745 000006AD 57                      	push	di
 10746                                  				; temp spot for name
 10747 000006AE BF[2C8B]                	mov	di,ID
 10748 000006B1 0430                    	add	al,'0'		; reconvert character
 10749 000006B3 AA                      	stosb			; store it in appropriate place
 10750                                  
 10751                                  ; loop getting characters until the next % is found or until EOL
 10752                                  
 10753                                  GETENV1:
 10754 000006B4 E8B102                  	call	GETBATBYT	; get the byte
 10755 000006B7 AA                      	stosb			; store it
 10756 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10757 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10758                                  
 10759                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10760                                  
 10761 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10762 000006C1 BE[2C8B]                	mov	si,ID 		; point to buffer
 10763 000006C4 5F                      	pop	di		; point to line buffer
 10764 000006C5 0E                      	push	cs
 10765 000006C6 1F                      	pop	ds
 10766 000006C7 E88B02                  	call	STRCPY
 10767                                  	; 05/02/2023
 10768 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10769                                  	; 24/04/2023
 10770                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10771 000006CC 1F                      	pop	ds
 10772 000006CD E94AFF                  	jmp	SAVBATBYT
 10773                                  GETENV15:
 10774 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10775 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10776                                  
 10777                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10778                                  ; This was the source of bug #1.
 10779                                  ;	dec	cx		;AN070; Don't count "%"
 10780                                  
 10781 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10782 000006D6 268845FF                	mov	[es:di-1],al
 10783                                  
 10784                                  ; ID now either has a =-terminated string which we are to find in the
 10785                                  ; environment or a non =-terminated string which will not be found in the
 10786                                  ; environment.
 10787                                  
 10788                                  GETENV2:
 10789 000006DA BE[2C8B]                	mov	si,ID
 10790 000006DD 0E                      	push	cs
 10791 000006DE 1F                      	pop	ds		; DS:SI points to name
 10792 000006DF 51                      	push	cx
 10793 000006E0 E8301C                  	call	find_name_in_environment
 10794 000006E3 59                      	pop	cx
 10795 000006E4 06                      	push	es
 10796 000006E5 1F                      	pop	ds
 10797 000006E6 0E                      	push	cs
 10798 000006E7 07                      	pop	es
 10799 000006E8 89FE                    	mov	si,di
 10800 000006EA 5F                      	pop	di		; get back pointer to command line
 10801                                  
 10802                                  ; If the parameter was not found, there is no need to perform any replacement.
 10803                                  ; We merely pretend that we've copied the parameter.
 10804                                  
 10805 000006EB 7203                    	jc	short GETENV6
 10806                                  
 10807                                  ; ES:DI points to command line being built
 10808                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10809                                  
 10810 000006ED E86502                  	call	STRCPY		; (let RdBat handle overflow)
 10811                                  	; 24/04/2022
 10812                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10813                                  GETENV6:
 10814 000006F0 1F                      	pop	ds
 10815 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10816                                  
 10817                                  ; =============== S U B	R O U T	I N E =======================================
 10818                                  
 10819                                  ;   SkipToEOL - read from batch file until end of line
 10820                                  
 10821                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10822                                  SKIPTOEOL:
 10823 000006F4 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10824                                  	;jnz	short SKIPTOEOL1  	
 10825                                  	;retn			; no batch file in effect
 10826                                  	
 10827 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10828                                  SKIPTOEOL1:
 10829 000006FC E86902                  	call	GETBATBYT
 10830 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10831 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10832                                  SKIPTOEOL2:
 10833 00000703 C3                      	retn
 10834                                  
 10835                                  ; =============== S U B	R O U T	I N E =======================================
 10836                                  
 10837                                  ;Break	<Allocate and deallocate the transient portion>
 10838                                  
 10839                                  ; Free Transient. Modify ES,AX,flags
 10840                                  
 10841                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10842                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10843                                  FREE_TPA:
 10844 00000704 06                      	push	es
 10845 00000705 8E06[A58A]              	mov	es,[RESSEG]
 10846 00000709 268E06[4503]            	mov	es,[es:Res_Tpa]
 10847 0000070E B449                    	mov	ah,49h
 10848                                  	;mov	ah,DEALLOC ; 49h
 10849 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10850                                  			; ES = segment address of area to be freed
 10851 00000712 07                      	pop	es
 10852 00000713 C3                      	retn
 10853                                  
 10854                                  ; =============== S U B	R O U T	I N E =======================================
 10855                                  
 10856                                  ; Allocate transient. Modify AX,BX,DX,flags
 10857                                  
 10858                                  	; 06/02/2023
 10859                                  ALLOC_TPA:
 10860 00000714 06                      	push	es
 10861 00000715 8E06[A58A]              	mov	es,[RESSEG]
 10862 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10863 0000071C B448                    	mov	ah,48h
 10864                                  	;mov	ah,ALLOC ; 48h
 10865 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10866                                  			; BX = number of 16-byte paragraphs desired
 10867 00000720 53                      	push	bx	  	; Save size of block
 10868 00000721 B448                    	mov	ah,48h
 10869                                  	;mov	ah,ALLOC ; 48h
 10870 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10871                                  			; BX = number of 16-byte paragraphs desired
 10872                                  
 10873                                  ; Attempt to align TPA on 64K boundary
 10874                                  
 10875 00000725 5B                      	pop	bx		; Restore size of block
 10876 00000726 26A3[4503]              	mov	[es:Res_Tpa],ax
 10877                                  				; Save segment to beginning of block
 10878 0000072A A3[B38A]                	mov	[TRAN_TPA],ax
 10879                                  
 10880                                  ; Is the segment already aligned on a 64K boundary
 10881                                  
 10882 0000072D 89C2                    	mov	dx,ax		; Save segment
 10883 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10884 00000732 7507                    	jnz	short CALC_TPA
 10885 00000734 89D0                    	mov	ax,dx
 10886 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10887 00000739 7523                    	jnz	short NOROUND
 10888                                  CALC_TPA:
 10889 0000073B 89D0                    	mov	ax,dx
 10890 0000073D 2500F0                  	and	ax,0F000h
 10891 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10892 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10893                                  
 10894                                  ; Make sure that new boundary is within allocated range
 10895                                  
 10896 00000745 268B16[4503]            	mov	dx,[es:Res_Tpa]
 10897 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10898 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10899 0000074E 720E                    	jb	short NOROUND
 10900                                  
 10901                                  ; Make sure that we won't overwrite the transient
 10902                                  
 10903 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10904 00000752 39C3                    	cmp	bx,ax
 10905 00000754 7208                    	jb	short NOROUND
 10906                                  
 10907                                  ; The area from the 64K boundary to the beginning of the transient must
 10908                                  ; be at least 64K.
 10909                                  
 10910 00000756 29C3                    	sub	bx,ax
 10911                                  	;cmp	bx,4096
 10912 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10913 0000075C 7304                    	jnb	short ROUNDDONE
 10914                                  NOROUND:
 10915 0000075E 26A1[4503]              	mov	ax,[es:Res_Tpa]
 10916                                  ROUNDDONE:
 10917 00000762 26A3[3903]              	mov	[es:LTpa],ax	; Re-compute everything
 10918 00000766 A3[A78A]                	mov	[TPA],ax
 10919 00000769 89C3                    	mov	bx,ax
 10920 0000076B 8CC8                    	mov	ax,cs
 10921 0000076D 29D8                    	sub	ax,bx
 10922 0000076F 53                      	push	bx
 10923 00000770 BB1000                  	mov	bx,16
 10924 00000773 F7E3                    	mul	bx
 10925 00000775 5B                      	pop	bx
 10926 00000776 09D2                    	or	dx,dx
 10927 00000778 7403                    	jz	short SAVSIZ2
 10928 0000077A B8FFFF                  	mov	ax,-1
 10929                                  SAVSIZ2:
 10930                                  
 10931                                  ; AX is the number of bytes free in the buffer between the resident and the
 10932                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10933                                  
 10934 0000077D 3D0002                  	cmp	ax,512
 10935 00000780 7603                    	jbe	short GOTSIZE2
 10936                                  	;and	ax,~1FFh
 10937 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10938                                  GOTSIZE2:
 10939 00000785 A3[C48A]                	mov	[BYTCNT],ax
 10940 00000788 07                      	pop	es
 10941 00000789 C3                      	retn
 10942                                  
 10943                                  ; =============== S U B	R O U T	I N E =======================================
 10944                                  
 10945                                  ;Break	<BatCom - enter a batch file>
 10946                                  
 10947                                  ; The exec search has determined that the user has requested a batch file for
 10948                                  ; execution. We parse the arguments, create the batch segment, and signal
 10949                                  ; batch processing.
 10950                                  
 10951                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10952                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10953                                  BATCOM:	
 10954                                  
 10955                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10956                                  
 10957                                  ; Batch parameters are read with ES set to segment of resident part
 10958                                  
 10959                                  	; MSDOS 6.0
 10960 0000078A 8E06[A58A]              	mov	es,[RESSEG]
 10961                                  	;ASSUME	ES:RESGROUP
 10962                                  	;cmp	byte [es:Call_Batch_Flag],1
 10963 0000078E 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10964                                  					;AN043; If in CALL,
 10965 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10966                                  	;invoke	IOSET			; Set up any redirection
 10967 00000796 E8E223                  	call	IOSET
 10968                                  skip_ioset:				;AN043;
 10969 00000799 E868FF                  	call	FREE_TPA		; G
 10970                                  	;cmp	byte [es:Call_Batch_Flag],1
 10971 0000079C 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10972 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10973                                  
 10974                                  	; 12/02/2023
 10975                                  	; MSDOS 3.3
 10976                                  	;call	IOSET
 10977                                  	;mov	es,[RESSEG]
 10978                                  	;call	FREE_TPA
 10979                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 10980                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 10981                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 10982                                  
 10983                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10984                                  
 10985                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 10986                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 10987                                  ; Don't execute if in call
 10988                                  
 10989 000007A4 E89608                  	call	FOROFF
 10990                                  GETECHO:
 10991 000007A7 E8BC27                  	call	PipeOff
 10992 000007AA 26A0[8801]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 10993 000007AE 2401                    	and	al,1			; Save current echo state
 10994                                  
 10995 000007B0 50                      	push	ax
 10996 000007B1 31C0                    	xor	ax,ax
 10997 000007B3 26F706[3401]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 10998 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 10999 000007BC 26A1[3401]              	mov	ax,[es:Batch] 		; Get current batch segment
 11000                                  	;cmp	byte [es:Call_Batch_Flag],1
 11001 000007C0 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11002 000007C6 7408                    	jz	short LEAVEBAT
 11003                                  
 11004                                  ;  We are in a chained batch file, save batlast from previous batch segment
 11005                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11006                                  
 11007 000007C8 06                      	push	es
 11008 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 11009                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11010                                  				; Get previous batch segment
 11011                                  	; 12/02/2023
 11012                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11013 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11014 000007CF 07                      	pop	es
 11015                                  LEAVEBAT:
 11016 000007D0 50                      	push	ax		; Keep segment until new one created
 11017                                  	;cmp	byte [es:Call_Batch_Flag],1
 11018 000007D1 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11019 000007D7 7403                    	jz	short STARTBAT
 11020 000007D9 E82001                  	call	BATCHOFF
 11021                                  
 11022                                  ; Find length of batch file
 11023                                  
 11024                                  STARTBAT:
 11025 000007DC 26C606[9A01]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11026 000007E2 BE[CD89]                	mov	si,EXECPATH
 11027                                  
 11028                                  	; 12/02/2023
 11029                                  	; MSDOS 6.0
 11030 000007E5 B811B7                  	mov	ax,0B711h
 11031                                  	;mov	ax,AppendTruename
 11032                                  				;AN042; Get the real path where the batch file
 11033 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11034 000007EA B44E                    	mov	ah,4Eh
 11035                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11036 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 11037 000007EE B91300                  	mov	cx,13h
 11038                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11039 000007F1 CD21                    	int	21h		;AN042;
 11040                                  
 11041                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11042 000007F3 E87424                  	call	dstrlen
 11043                                  ;
 11044                                  ; Allocate batch area:
 11045                                  ;   BYTE    type of segment
 11046                                  ;   WORD    segment of last batch file
 11047                                  ;   WORD    segment for FOR command
 11048                                  ;   BYTE    FOR flag state on entry to batch file
 11049                                  ;   DWORD   offset for next line
 11050                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11051                                  ;   ASCIZ   file name (with . and ..)
 11052                                  ;   BYTES   CR-terminated parameters
 11053                                  ;   BYTE    0 flag to indicate end of parameters
 11054                                  ;
 11055                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11056                                  ; later when we've squeezed out the extra
 11057                                  ;
 11058 000007F6 89CB                    	mov	bx,cx		; length of file name.
 11059                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11060                                  	; 12/02/2023
 11061                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11062                                  	; 25/04/2023
 11063 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11064                                  					; structure + max len + round up
 11065 000007FC 51                      	push	cx
 11066 000007FD B104                    	mov	cl,4
 11067 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 11068 00000801 53                      	push	bx		; Save size of batch segment
 11069 00000802 B448                    	mov	ah,48h
 11070                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11071 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11072                                  				; BX = number of 16-byte paragraphs desired
 11073 00000806 5B                      	pop	bx		; Get size of batch segment
 11074                                  
 11075                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11076                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11077                                  ; G This error will occur with nesting of batch files. We also need to
 11078                                  ; G make sure that we don't overlay the transient.
 11079                                  
 11080 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11081                                  
 11082 00000809 50                      	push	ax		;G save batch segment
 11083 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 11084 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 11085 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 11086                                  
 11087                                  	; MSDOS 6.0
 11088                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11089                                  ; M006; batchseg is always above the transient. We need to change this code
 11090                                  ; M006; to only check for an overlap
 11091                                  
 11092                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11093                                  	; 12/02/2023
 11094                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11095                                  	;mov	dx,TRANSPACEEND		
 11096                                  	;add	dx,15		;round up para; M006
 11097 00000811 BA7E95                  	mov	dx,TRANSPACEEND+15
 11098                                  
 11099 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 11100 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 11101                                  
 11102 00000818 39D8                    	cmp	ax,bx		; M006
 11103 0000081A 7211                    	jb	short ENOUGH_MEM
 11104                                  				; Batchseg below transient
 11105                                  				; enough memory ; M006
 11106 0000081C 39D0                    	cmp	ax,dx		; M006
 11107 0000081E 770D                    	ja	short ENOUGH_MEM	
 11108                                  				; Batchseg above transient
 11109                                  				; enough memory ; M006
 11110                                  
 11111                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11112                                  
 11113 00000820 58                      	pop	ax		; restore ax; M006
 11114                                  
 11115                                  	; 12/02/2023
 11116                                  	; MSDOS 3.3
 11117                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11118                                  ; M006;	pop	ax		;G get batch segment back
 11119                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11120                                  
 11121                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11122 00000821 06                      	push	es		;G no we're hitting the transient
 11123 00000822 8EC0                    	mov	es,ax
 11124 00000824 B80049                  	mov	ax,4900h
 11125                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11126 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11127                                  			; ES = segment address of area to be freed
 11128 00000829 07                      	pop	es
 11129                                  MEM_ERROR:
 11130 0000082A E9B800                  	jmp	NO_MEMORY	;G Set up for message and exit
 11131                                  
 11132                                  ENOUGH_MEM:
 11133                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11134                                  	; MSDOS 6.0
 11135 0000082D 58                      	pop	ax		; restore ax; M006
 11136                                  
 11137                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11138 0000082E 26A3[3401]              	mov	[es:Batch],ax
 11139 00000832 E8DFFE                  	call	ALLOC_TPA
 11140                                  
 11141                                  ; Initialize batch segment
 11142                                  
 11143 00000835 5A                      	pop	dx		; length of name
 11144 00000836 58                      	pop	ax		;G get saved batch segment back
 11145 00000837 26FF06[9701]            	inc	word [es:Nest]	;G increment # batch files in progress
 11146 0000083C 06                      	push	es
 11147 0000083D 268E06[3401]            	mov	es,[es:Batch]
 11148                                  	;mov	byte [ES:0],0
 11149                                  				; signal batch file type
 11150 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11151                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11152                                  				;G save segment of last batch file
 11153                                  	;mov	[es:3],ax	; MSDOS 6.0
 11154 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11155 0000084C 1E                      	push	ds
 11156 0000084D 8E1E[A58A]              	mov	ds,[RESSEG]	;G set to resident data
 11157                                  
 11158 00000851 31C0                    	xor	ax,ax
 11159 00000853 8A1E[9401]              	mov	bl,[ForFlag]	;G get the current FOR state
 11160                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11161                                  				;G save it in the batch segment
 11162                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11163 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11164 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11165 0000085F 7406                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11166                                  	;mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11167                                  	;mov	byte [ForFlag],0 ;G reset forflag
 11168                                  	; 26/07/2024
 11169 00000861 A2[9401]                	mov	[ForFlag],al ; 0
 11170 00000864 A1[9501]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11171                                  FOR_NOT_ON:
 11172                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11173                                  				;G save FOR segment in batch segment
 11174                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11175 00000867 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11176 0000086B 31C0                    	xor	ax,ax
 11177 0000086D A3[9501]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11178 00000870 8A1E[8801]              	mov	bl,[EchoFlag]
 11179 00000874 1F                      	pop	ds
 11180                                  	;mov	[es:1],bl 
 11181                                  				 ;G save echo state of parent
 11182 00000875 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11183                                  ;SR;
 11184                                  ; Initialize the new BatchEOF flag we have added to 0
 11185                                  
 11186                                  	; MSDOS 6.0
 11187                                  	;mov	byte [es:2],0
 11188 0000087A 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11189                                  
 11190                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11191 00000880 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11192                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11193 00000884 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11194                                  
 11195                                  ; Initialize pointers
 11196                                  
 11197 00000888 48                      	dec	ax		; put -1 into AX
 11198                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11199                                  				; point to parm area
 11200                                  	;mov	di,0Ch	; MSDOS 6.0
 11201 00000889 BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11202 0000088C 89FB                    	mov	bx,di
 11203 0000088E B90A00                  	mov	cx,10
 11204 00000891 F3AB                    	rep stosw		; Init to no parms
 11205                                  
 11206                                  ; Move in batch file name
 11207                                  
 11208 00000893 89D1                    	mov	cx,dx
 11209 00000895 F3A4                    	rep	movsb
 11210                                  
 11211                                  ; Now copy the command line into batch segment, parsing the arguments along
 11212                                  ; the way. Segment will look like this:
 11213                                  ;
 11214                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11215                                  ;
 11216                                  ; or, in the case of fewer arguments:
 11217                                  ;
 11218                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11219                                  
 11220 00000897 BE[0689]                	mov	si,COMBUF+2
 11221                                  	;mov	cx,10		; at most 10 arguments
 11222                                  	; 07/06/2023
 11223 0000089A B10A                    	mov	cl,10
 11224                                  EACHPARM:
 11225 0000089C E83D1D                  	call	scanoff		; skip to argument
 11226                                  
 11227                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11228                                  
 11229 0000089F 3C0D                    	cmp	al,0Dh		; end of road?
 11230 000008A1 741D                    	jz	short HAVPARM	; yes, no more arguments
 11231                                  
 11232                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11233                                  
 11234 000008A3 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11235                                  
 11236                                  ; Go into allocated piece and stick in new argument pointer.
 11237                                  
 11238 000008A5 26893F                  	mov	[es:bx],di	; store batch pointer
 11239 000008A8 83C302                  	add	bx,2		; advance arg counter
 11240                                  
 11241                                  ; Move the parameter into batch segment
 11242                                  
 11243                                  MOVPARM:
 11244 000008AB AC                      	lodsb			; get byte
 11245 000008AC E8351D                  	call	DELIM		; if delimiter
 11246 000008AF 7407                    	jz	short ENDPARM	; then done with parm
 11247 000008B1 AA                      	stosb			; store byte
 11248 000008B2 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11249 000008B4 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11250 000008B6 EBF3                    	jmp	short MOVPARM
 11251                                  
 11252                                  ; We have copied a parameter up until the first separator.
 11253                                  ; Terminate it with CR.
 11254                                  
 11255                                  ENDPARM:
 11256 000008B8 B00D                    	mov	al,0Dh
 11257 000008BA AA                      	stosb
 11258 000008BB E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11259 000008BD 49                      	dec	cx		; remember that we've seen one.	
 11260 000008BE EBDC                    	jmp	short EACHPARM
 11261                                  
 11262                                  ; We have parsed the entire line. Terminate the arg list
 11263                                  
 11264                                  HAVPARM:
 11265 000008C0 30C0                    	xor	al,al		; Nul terminate the parms
 11266 000008C2 AA                      	stosb
 11267                                  
 11268                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11269                                  ; into paragraphs and setblock to the appropriate size
 11270                                  
 11271 000008C3 8D5D0F                  	lea	bx,[di+15]
 11272 000008C6 B104                    	mov	cl,4
 11273 000008C8 D3EB                    	shr	bx,cl
 11274 000008CA B44A                    	mov	ah,4Ah
 11275                                  	;mov	ah,SETBLOCK ; 4Ah
 11276 000008CC CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11277                                  			; ES = segment address of block	to change
 11278                                  			; BX = new size	in paragraphs
 11279 000008CE 07                      	pop	es
 11280 000008CF 06                      	push	es
 11281 000008D0 1F                      	pop	ds		; Simply batch FCB setup
 11282 000008D1 833E[8E01]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11283 000008D6 7506                    	jne	short NOBATSING
 11284 000008D8 C706[8E01]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11285                                  
 11286                                  NOBATSING:
 11287                                  
 11288                                  ; Enter the batch file with the current echo state
 11289                                  
 11290 000008DE 58                      	pop	ax		; Get original echo state
 11291 000008DF A2[8801]                	mov	[EchoFlag],al	; restore it
 11292 000008E2 E91FF8                  	jmp	TCOMMAND
 11293                                  
 11294                                  ; The following is executed if there isn't enough memory for batch segment
 11295                                  
 11296                                  NO_MEMORY:
 11297 000008E5 5A                      	pop	dx		; even up our stack 
 11298 000008E6 58                      	pop	ax
 11299 000008E7 58                      	pop	ax
 11300 000008E8 E829FE                  	call	ALLOC_TPA	; reallocate memory
 11301                                  
 11302                                  	; 12/02/2023
 11303                                  	; MSDOS 3.3
 11304                                  	;mov	dx,INSFMEMMESPTR
 11305                                  	;jmp	CERROR
 11306                                  
 11307                                  	; MSDOS 6.0
 11308                                  	;mov	byte [msg_disp_class],1
 11309 000008EB C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 11310                                  				;AN000; set up extended error msg class
 11311                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11312 000008F0 BA[FC7E]                	mov	dx,extend_buf_ptr
 11313                                  	;			;AC000; get extended message pointer
 11314                                  	;mov	word [extend_buf_ptr],8
 11315 000008F3 C706[FC7E]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11316                                  				;AN000; get message number in control block
 11317 000008F9 E95420                  	jmp	cerror		;g print error message and go...
 11318                                  
 11319                                  ; =============== S U B	R O U T	I N E =======================================
 11320                                  
 11321                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11322                                  BATCHOFF:
 11323 000008FC 50                      	push	ax
 11324 000008FD 06                      	push	es
 11325 000008FE 1E                      	push	ds
 11326 000008FF 53                      	push	bx
 11327                                  
 11328 00000900 2E8E06[A58A]            	mov	es,[cs:RESSEG]
 11329                                  	;mov	ds,[cs:RESSEG]
 11330                                  	; 26/07/2024
 11331 00000905 06                      	push	es
 11332 00000906 1F                      	pop	ds
 11333                                  
 11334 00000907 A1[3401]                	mov	ax,[Batch]	; Free the batch segment
 11335 0000090A 09C0                    	or	ax,ax
 11336 0000090C 7442                    	jz	short NOTFREE
 11337                                  
 11338 0000090E 06                      	push	es
 11339 0000090F 8EC0                    	mov	es,ax
 11340 00000911 F606[8801]01            	test	byte [EchoFlag],1
 11341                                  				;G Is echo on?
 11342 00000916 7505                    	jnz	short ECHO_LAST_LINE
 11343                                  				;G Yes - echo last line in file
 11344                                  	;mov	byte [SUPPRESS],0
 11345 00000918 C606[8901]00            	mov	byte [Suppress],NO_ECHO
 11346                                  				;G no - don't echo last line in file	
 11347                                  ECHO_LAST_LINE:
 11348                                  	;mov	bl,[es:1]
 11349 0000091D 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11350                                  				; G get echo state
 11351 00000922 881E[8801]              	mov	[EchoFlag],bl
 11352                                  				; G  and restore it
 11353                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11354                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11355 00000926 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11356                                  				;G Get FOR segment
 11357 0000092B 891E[9501]              	mov	[ForPtr],bx	;G  and restore it
 11358                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11359                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11360 0000092F 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11361                                  				;G Get FOR flag
 11362 00000934 881E[9401]              	mov	[ForFlag],bl
 11363                                  				;G  and restore it
 11364                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11365                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11366 00000938 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11367                                  				;G  Get old batch segment
 11368                                  
 11369 0000093D B449                    	mov	ah,49h
 11370                                  	;mov	ah,DEALLOC ; 49h
 11371 0000093F CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11372                                  			; ES = segment address of area to be freed
 11373 00000941 07                      	pop	es
 11374 00000942 891E[9B01]              	mov	[Next_Batch],bx	;G reset batch segment	
 11375 00000946 26FF0E[9701]            	dec	word [es:Nest]
 11376 0000094B 31C0                    	xor	ax,ax
 11377 0000094D A3[3401]                	mov	[Batch],ax	; No batch in progress
 11378                                  NOTFREE:
 11379 00000950 5B                      	pop	bx
 11380 00000951 1F                      	pop	ds
 11381 00000952 07                      	pop	es
 11382 00000953 58                      	pop	ax
 11383 00000954 C3                      	retn
 11384                                  
 11385                                  ; =============== S U B	R O U T	I N E =======================================
 11386                                  
 11387                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11388                                  
 11389                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11390                                  ;	Entry : DS:SI ==> source string
 11391                                  ;		ES:DI ==> destination string
 11392                                  ;		CX = current length of destination string
 11393                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11394                                  
 11395                                  	; 12/02/2023	
 11396                                  	; MSDOS 3.3
 11397                                  ;STRCPY:
 11398                                  	;push	ax
 11399                                  ;CCYCLE:
 11400                                  	;lodsb
 11401                                  	;stosb
 11402                                  	;or	al,al
 11403                                  	;jnz	short CCYCLE
 11404                                  	;pop	ax
 11405                                  	;retn
 11406                                  
 11407                                  ;Procedure StrCpy,NEAR
 11408                                  
 11409                                  	; 12/02/2023
 11410                                  	; MSDOS 6.0
 11411                                  STRCPY:
 11412 00000955 50                      	push	ax
 11413                                  ccycle:
 11414 00000956 AC                      	lodsb
 11415 00000957 41                      	inc	cx
 11416                                  	;cmp	cx,128
 11417 00000958 81F98000                	cmp	cx,COMBUFLEN
 11418                                  	;jb	short ccopy
 11419                                  	;stc			; set carry to signal error
 11420                                  	;jmp	short ccend
 11421                                  	; 12/02/2023
 11422 0000095C F5                      	cmc
 11423 0000095D 7205                    	jc	short ccend
 11424                                  ccopy:
 11425 0000095F AA                      	stosb
 11426 00000960 08C0                    	or	al,al
 11427 00000962 75F2                    	jnz	short ccycle
 11428                                  ccend:
 11429 00000964 49                      	dec	cx		; discount extra byte
 11430 00000965 4F                      	dec	di		; back up pointer
 11431 00000966 58                      	pop	ax
 11432 00000967 C3                      	retn			; return carry clear
 11433                                  
 11434                                  ;EndProc StrCpy
 11435                                  
 11436                                  ;============================================================================
 11437                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11438                                  ;============================================================================
 11439                                  ; 12/10/2018 - Retro DOS v3.0
 11440                                  
 11441                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11442                                  
 11443                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11444                                  
 11445                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11446                                  
 11447                                  ; =============== S U B	R O U T	I N E =======================================
 11448                                  
 11449                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11450                                  
 11451                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11452                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11453                                  ; AH, DX destroyed.
 11454                                  
 11455                                  GETBATBYT:
 11456 00000968 53                      	push	bx
 11457 00000969 51                      	push	cx
 11458 0000096A 1E                      	push	ds
 11459 0000096B F606[7E01]FF            	test	byte [Batch_Abort],-1
 11460                                  	;jnz	short BATEOF
 11461                                  	; 14/02/2023
 11462 00000970 7403                    	jz	short getbatbyt1
 11463 00000972 E9D100                  	jmp	BATEOF
 11464                                  getbatbyt1:
 11465 00000975 F706[3401]FFFF          	test	word [Batch],-1
 11466                                  	;jz	short BATEOF
 11467                                  	; 14/02/2023
 11468 0000097B 7503                    	jnz	short getbatbyt2
 11469 0000097D E9C600                  	jmp	BATEOF
 11470                                  getbatbyt2:
 11471 00000980 06                      	push	es
 11472 00000981 8E06[3401]              	mov	es,[Batch]
 11473                                  
 11474                                  	; MSDOS 6.0
 11475                                  ;M020;
 11476                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11477                                  ;try to read from the batchfile again.
 11478                                  
 11479                                  	;cmp	byte [es:2],0
 11480 00000985 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11481                                  				;already reached EOF?	;M020
 11482 0000098B 7403                    	jz	short not_eof	;no, read batch file	;M020
 11483 0000098D E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11484                                  not_eof:						;M020
 11485                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11486                                  	;add	word [es:8],1	; MSDOS 6.0
 11487 00000990 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11488                                  	;adc	word [es:10],0	; MSDOS 6.0
 11489 00000996 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11490 0000099C 07                      	pop	es
 11491                                  
 11492                                  ; See if we have bytes buffered...
 11493                                  
 11494 0000099D 8CC8                    	mov	ax,cs
 11495 0000099F 8ED8                    	mov	ds,ax
 11496 000009A1 8B1E[2795]              	mov	bx,[BATBUFPOS]
 11497 000009A5 83FBFF                  	cmp	bx,-1
 11498 000009A8 7540                    	jnz	short UNBUF
 11499                                  
 11500                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11501                                  
 11502 000009AA BA[2995]                	mov	dx,BATBUF
 11503 000009AD 8B0E[4384]              	mov	cx,[BATBUFLEN] ; max to read.
 11504 000009B1 8B1E[558D]              	mov	bx,[BATHAND]
 11505                                  	; 14/02/2023
 11506 000009B5 B43F                    	mov	ah,3Fh
 11507                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11508 000009B7 CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11509                                  			; BX = file handle,CX = number	of bytes to read
 11510                                  			; DS:DX	-> buffer
 11511                                  	; MSDOS 6.0
 11512 000009B9 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11513                                  	;invoke	get_ext_error_number	;AN022; get the error
 11514 000009BB E83213                  	call	get_ext_error_number
 11515 000009BE 1E                      	push	ds			;AN022; save local segment
 11516 000009BF 8E1E[A58A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11517                                  	;assume ds:resgroup		;AN022;
 11518 000009C3 89C2                    	mov	dx,ax			;AN022; put error in DX
 11519                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11520 000009C5 E861FB                  	call	output_batch_name
 11521 000009C8 1F                      	pop	ds			;AN022;
 11522                                  	;assume	ds:trangroup		;AN022;
 11523                                  	;invoke	std_eprintf		;AN022; print out the error
 11524 000009C9 E8FD43                  	call	std_eprintf
 11525                                  	;mov	byte ptr combuf+2,end_of_line_in
 11526 000009CC C606[0689]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11527                                  	;				;AN022; terminate the batch line for parsing
 11528                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11529 000009D1 C606[0789]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11530                                  	;				;AN022; terminate the batch line for output
 11531                                  ;M020;
 11532                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11533                                  ;error is never hit (and it shouldn't be)
 11534                                  
 11535 000009D6 8E1E[A58A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11536 000009DA EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11537                                  bat_read_ok:				;AN022;
 11538                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11539 000009DC 89C1                    	mov	cx,ax
 11540                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11541                                  	; 14/02/2023
 11542 000009DE E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11543 000009E0 890E[4995]              	mov	[BATBUFEND],cx
 11544 000009E4 31DB                    	xor	bx,bx
 11545 000009E6 891E[2795]              	mov	[BATBUFPOS],bx
 11546                                  
 11547                                  	; Buffered bytes!
 11548                                  UNBUF:
 11549 000009EA 8A87[2995]              	mov	al,[BATBUF+bx]		; get next byte
 11550 000009EE 43                      	inc	bx
 11551 000009EF 3B1E[4995]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11552 000009F3 7203                    	jb	short SETBUFPOS
 11553 000009F5 BBFFFF                  	mov	bx,-1
 11554                                  SETBUFPOS:
 11555 000009F8 891E[2795]              	mov	[BATBUFPOS],bx
 11556 000009FC 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11557 000009FE 7575                    	jne	short GETBYTEDONE
 11558                                  
 11559                                  ;We get here only when we hit an EOF
 11560                                  	
 11561                                  	; MSDOS 6.0
 11562                                  BATEOFDS:
 11563                                  ;SR;
 11564                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11565                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11566                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11567                                  ;batch processing is turned off before the last line is processed and so 
 11568                                  ;this line would never be executed. 
 11569                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11570                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11571                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11572                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11573                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11574                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11575                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11576                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11577                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11578                                  ;another redundant CR-LF. There is no work-around I can think of.
 11579                                  ; 	I would love to restructure this entire routine and its caller to
 11580                                  ;make the flow really easy to understand but I guess this will have to wait.
 11581                                  ;
 11582 00000A00 06                      	push	es
 11583 00000A01 8E06[A58A]              	mov	es,[RESSEG]
 11584                                  ;SR;
 11585                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11586                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11587                                  ;
 11588 00000A05 268E06[3401]            	mov	es,[es:Batch]
 11589                                  	;cmp	byte [es:2],0
 11590 00000A0A 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11591 00000A10 7516                    	jnz	short crpresent
 11592                                  
 11593                                  	;inc	byte [es:2]
 11594 00000A12 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11595                                  					;match the dec following
 11596 00000A17 8B1E[4995]              	mov	bx,[BATBUFEND]
 11597 00000A1B 80BF[2895]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11598 00000A20 7406                    	je	short crpresent		;yes, no need to fake it
 11599                                  
 11600                                  	;add	byte [es:2],3
 11601 00000A22 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11602                                  					;BatchEOF == 4 to fake CR-LF
 11603                                  crpresent:
 11604                                  ;;	;pop	es
 11605                                  
 11606                                  	;ASSUME	DS:TranGroup
 11607                                  	; 14/02/2023
 11608 00000A28 8E1E[A58A]              	mov	ds,[RESSEG]
 11609                                  	;ASSUME	DS:ResGroup
 11610                                  ;SR;
 11611                                  ; The shift operation is done here to replace the decrement. This is because
 11612                                  ;we can jump to this label directly from above when bogus calls are made to
 11613                                  ;this routine even after batch processing is turned off. The shift ensures
 11614                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11615                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11616                                  ;calls.
 11617                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11618                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11619                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11620                                  ;turning batch processing off.
 11621                                  
 11622                                  At_EOF:					;new label added ;M020
 11623                                  	;shr	byte [es:2],1
 11624 00000A2C 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11625                                  					;decrement the flag
 11626 00000A31 7412                    	jz	short turn_off		;zero,turn batch off
 11627                                  	;cmp	byte [es:2],1
 11628 00000A33 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11629 00000A39 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11630                                  ;
 11631                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11632                                  ;
 11633 00000A3B B00D                    	mov	al,0Dh			;return fake CR.
 11634 00000A3D 07                      	pop	es
 11635 00000A3E EB35                    	jmp	short GETBYTEDONE
 11636                                  ret_lf:
 11637 00000A40 B00A                    	mov	al,0Ah			;return fake LF
 11638 00000A42 07                      	pop	es
 11639 00000A43 EB30                    	jmp	short GETBYTEDONE		
 11640                                  turn_off:
 11641 00000A45 07                      	pop	es
 11642                                  ;BATEOF:
 11643                                  	; MSDOS 3.3
 11644                                  ;TURN_OFF:
 11645                                  	;mov	ds,[RESSEG]
 11646                                  
 11647                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11648                                  BATEOF:
 11649 00000A46 E8B3FE                  	call	BATCHOFF
 11650 00000A49 E8CC02                  	call	BATCLOSE
 11651                                  
 11652                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11653                                  
 11654                                  ;SR; BugBug
 11655                                  ; There is a good reason why this carriage return is being returned here. 
 11656                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11657                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11658                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11659                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11660                                  ;the batchfile already had a CR-LF. 
 11661                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11662                                  ;the end-of-line. This CR is to mark the end-of-file.
 11663                                  
 11664 00000A4C B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11665 00000A4E F606[7E01]FF            	test	byte [Batch_Abort],-1
 11666 00000A53 C606[7E01]00            	mov	byte [Batch_Abort],0
 11667 00000A58 7407                    	jz	short CONT_GET_BYT
 11668 00000A5A BF[0689]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11669 00000A5D 31C9                    	xor	cx,cx			; zero line length
 11670 00000A5F EB14                    	jmp	short GETBYTEDONE
 11671                                  CONT_GET_BYT:
 11672 00000A61 833E[8E01]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11673 00000A66 750D                    	jne	short GETBYTEDONE
 11674 00000A68 833E[9701]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11675 00000A6D 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11676 00000A6F C706[8E01]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11677                                  GETBYTEDONE:
 11678 00000A75 1F                      	pop	ds
 11679 00000A76 59                      	pop	cx
 11680 00000A77 5B                      	pop	bx
 11681 00000A78 C3                      	retn
 11682                                  
 11683                                  ; ---------------------------------------------------------------------------
 11684                                  
 11685                                  ;break	<$If - conditional execution>
 11686                                  
 11687                                  	; 17/04/2023
 11688                                  ;IFERRORP:
 11689                                  ;	pop	ax
 11690                                  ;IFERROR:
 11691                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11692                                  ;FORERROR:
 11693                                  ;	mov	dx,SYNTMES_PTR
 11694                                  ;	jmp	cerror
 11695                                  
 11696                                  ; ---------------------------------------------------------------------------
 11697                                  
 11698                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11699                                  _$IF:
 11700                                  	; MSDOS 6.0
 11701                                  ; Turn off any pipes in progress.
 11702 00000A79 1E                      	push	ds			;AN004; save local DS
 11703 00000A7A 8E1E[A58A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11704                                  	;assume	ds:resgroup		;AN004;
 11705 00000A7E 803E[0102]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11706 00000A83 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11707                                  	;invoke	PipeDel 		;AN004; turn off piping
 11708 00000A85 E86322                  	call	PIPEDEL	
 11709                                  IFNoPipe:				;AN004;
 11710 00000A88 1F                      	pop	ds			;AN004; get local DS back
 11711                                  	;assume	ds:trangroup		;AN004;
 11712                                  
 11713                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11714 00000A89 C606[B68A]00            	mov	byte [IFNOTFLAG],0
 11715 00000A8E C706[FC93]0000          	mov	word [IF_NOT_COUNT],0
 11716 00000A94 BE8100                  	mov	si,81h
 11717                                  IFREENT:
 11718 00000A97 E8421B                  	call	scanoff
 11719 00000A9A 3C0D                    	cmp	al,0Dh
 11720 00000A9C 743C                    	je	short IFERROR
 11721 00000A9E 89F5                    	mov	bp,si
 11722 00000AA0 BF[9482]                	mov	di,IFTAB		; Prepare to search if table	
 11723                                  	;mov	ch,0
 11724                                  	; 17/04/2023
 11725 00000AA3 30ED                    	xor	ch,ch
 11726                                  IFINDCOM:
 11727 00000AA5 89EE                    	mov	si,bp
 11728 00000AA7 8A0D                    	mov	cl,[di]
 11729 00000AA9 47                      	inc	di
 11730 00000AAA E33E                    	jcxz	IFSTRING
 11731 00000AAC EB02                    	jmp	short FIRSTCOMP
 11732                                  IFCOMP:
 11733 00000AAE 7510                    	jnz	short IF_DIF
 11734                                  FIRSTCOMP:
 11735 00000AB0 AC                      	lodsb
 11736 00000AB1 268A25                  	mov	ah,[es:di]
 11737 00000AB4 47                      	inc	di
 11738 00000AB5 38E0                    	cmp	al,ah
 11739 00000AB7 7405                    	je	short IFLP
 11740 00000AB9 80CC20                  	or	ah,20h			; Try lower case
 11741 00000ABC 38E0                    	cmp	al,ah
 11742                                  IFLP:
 11743 00000ABE E2EE                    	loop	IFCOMP
 11744                                  IF_DIF:
 11745 00000AC0 9F                      	lahf
 11746 00000AC1 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11747 00000AC3 8B1D                    	mov	bx,[di]			; Get handler address
 11748 00000AC5 47                      	inc	di
 11749 00000AC6 47                      	inc	di
 11750 00000AC7 9E                      	sahf
 11751 00000AC8 75DB                    	jnz	short IFINDCOM
 11752 00000ACA AC                      	lodsb
 11753 00000ACB 3C0D                    	cmp	al,0Dh
 11754                                  IFERRJ:
 11755 00000ACD 740B                    	jz	short IFERROR
 11756 00000ACF E8121B                  	call	DELIM
 11757 00000AD2 75D1                    	jnz	short IFINDCOM
 11758 00000AD4 E8051B                  	call	scanoff
 11759 00000AD7 FFE3                    	jmp	bx
 11760                                  
 11761                                  	; 17/04/2023
 11762                                  IFERRORP:
 11763 00000AD9 58                      	pop	ax
 11764                                  IFERROR:
 11765                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11766                                  FORERROR:
 11767 00000ADA BA[947F]                	mov	dx,SYNTMES_PTR
 11768 00000ADD E9701E                  	jmp	cerror
 11769                                  
 11770                                  IFNOT:
 11771 00000AE0 F616[B68A]              	not	byte [IFNOTFLAG]
 11772 00000AE4 FF06[FC93]              	inc	word [IF_NOT_COUNT]
 11773 00000AE8 EBAD                    	jmp	short IFREENT
 11774                                  
 11775                                  ; We are comparing two strings for equality. First, find the end of the
 11776                                  ; first string.
 11777                                  
 11778                                  IFSTRING:
 11779 00000AEA 56                      	push	si			; save away pointer for later compare
 11780 00000AEB 31C9                    	xor	cx,cx			; count of chars in first string
 11781                                  FIRST_STRING:
 11782 00000AED AC                      	lodsb				; get character
 11783 00000AEE 3C0D                    	cmp	al,0Dh			; end of line?
 11784 00000AF0 74E7                    	jz	short IFERRORP		; yes => error
 11785 00000AF2 E8EF1A                  	call	DELIM			; is it a delimiter?
 11786 00000AF5 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11787 00000AF7 41                      	inc	cx			; remember 1 byte for the length
 11788 00000AF8 EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11789                                  EQUAL_CHECK:
 11790 00000AFA 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11791 00000AFC 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11792 00000AFE 3C0D                    	cmp	al,0Dh			; end of line?
 11793 00000B00 74D7                    	je	short IFERRORP		; yes, syntax error
 11794 00000B02 AC                      	lodsb				; get next char
 11795 00000B03 EBF5                    	jmp	short EQUAL_CHECK
 11796                                  
 11797                                  ; The first = has been found. The next char had better be an = too.
 11798                                  
 11799                                  EQUAL_CHECK2:
 11800 00000B05 AC                      	lodsb				; get potential = char
 11801 00000B06 3C3D                    	cmp	al,'='			; is it good?	
 11802                                  	;jnz	short IFERRPJ		; no, error
 11803                                  	; 17/04/2023
 11804 00000B08 75CF                    	jne	short IFERRORP
 11805                                  
 11806                                  ; Find beginning of second string.
 11807                                  
 11808 00000B0A E8CF1A                  	call	scanoff
 11809 00000B0D 3C0D                    	cmp	al,0Dh
 11810                                  	;jz	short IFERRPJ
 11811                                  	; 17/04/2023
 11812 00000B0F 74C8                    	je	short IFERRORP
 11813 00000B11 5F                      	pop	di
 11814                                  
 11815                                  ; DS:SI points to second string
 11816                                  ; CX has number of chars in first string
 11817                                  ; ES:DI points to first string
 11818                                  
 11819 00000B12 F3A6                    	repe	cmpsb
 11820 00000B14 7414                    	jz	short MATCH		; match found!
 11821                                  
 11822                                  ; No match. Let's find out what was wrong. The character that did not match
 11823                                  ; has been advanced over. Let's back up to it.
 11824                                  
 11825 00000B16 4E                      	dec	si
 11826                                  
 11827                                  ; If it is EOL, then syntax error
 11828                                  
 11829 00000B17 803C0D                  	cmp	byte [si],0Dh
 11830                                  	;jz	short IFERRJ
 11831                                  	; 17/04/2023
 11832 00000B1A 74BE                    	je	short IFERROR
 11833                                  
 11834                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11835                                  
 11836                                  SKIPSTRINGEND:
 11837 00000B1C AC                      	lodsb
 11838                                  NOTMATCH:
 11839 00000B1D 3C0D                    	cmp	al,0Dh
 11840                                  IFERRORJ2:
 11841                                  	;jz	short IFERRJ
 11842                                  	; 17/04/2023
 11843 00000B1F 74B9                    	jz	short IFERROR
 11844 00000B21 E8C01A                  	call	DELIM
 11845 00000B24 75F6                    	jnz	short SKIPSTRINGEND
 11846                                  
 11847                                  ; Signal that we did NOT have a match
 11848                                  
 11849 00000B26 B0FF                    	mov	al,-1
 11850 00000B28 EB37                    	jmp	short IFRET
 11851                                  
 11852                                  	; 17/04/2023
 11853                                  ;IFERRPJ:
 11854                                  	;jmp	IFERRORP
 11855                                  
 11856                                  ; The compare succeeded. Was the second string longer than the first?
 11857                                  ; We do this by seeing if the next char is a delimiter.
 11858                                  
 11859                                  MATCH:
 11860 00000B2A AC                      	lodsb
 11861 00000B2B E8B61A                  	call	DELIM
 11862 00000B2E 75ED                    	jnz	short NOTMATCH ; not same.
 11863 00000B30 30C0                    	xor	al,al
 11864 00000B32 EB2D                    	jmp	short IFRET
 11865                                  
 11866                                  ; ---------------------------------------------------------------------------
 11867                                  
 11868                                  IFEXISTS:
 11869                                  
 11870                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11871                                  
 11872                                  ;MOREDELIM:
 11873 00000B34 AC                      	lodsb
 11874 00000B35 E8AC1A                  	call	DELIM
 11875 00000B38 75FA                    	jnz	short IFEXISTS
 11876                                  	;jnz	short MOREDELIM
 11877                                  
 11878 00000B3A BA[AA8B]                	mov	dx,DIRBUF
 11879 00000B3D B8001A                  	mov	ax,1A00h
 11880                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11881 00000B40 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11882                                  			; DS:DX	-> disk	transfer buffer
 11883 00000B42 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11884 00000B45 031E[FC93]              	add	bx,[IF_NOT_COUNT]
 11885                                  	;mov	ax,ARG_ARGV
 11886                                  	;mov	ax,ARG+ARG_UNIT.argv
 11887 00000B49 B8[B08D]                	mov	ax,ARG
 11888 00000B4C E8FD25                  	call	argv_calc		; convert arg index to pointer
 11889 00000B4F 8B17                    	mov	dx,[bx]
 11890                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11891                                  	;mov	cx,6
 11892 00000B51 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11893 00000B54 B8004E                  	mov	ax,4E00h
 11894                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11895 00000B57 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11896                                  			; CX = search attributes
 11897                                  			; DS:DX	-> ASCIZ filespec
 11898                                  			; (drive,path, and wildcards allowed)
 11899 00000B59 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11900 00000B5B 30C0                    	xor	al,al
 11901 00000B5D EB02                    	jmp	short IFRET
 11902                                  
 11903                                  	;nop
 11904                                  IF_EX_C:
 11905 00000B5F B0FF                    	mov	al,-1			; false 'n' fall through...
 11906                                  IFRET:
 11907 00000B61 F606[B68A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11908 00000B66 7402                    	jz	short REALTEST
 11909 00000B68 F6D0                    	not	al
 11910                                  REALTEST:
 11911 00000B6A 08C0                    	or	al,al
 11912 00000B6C 7403                    	jz	short IFTRUE
 11913 00000B6E E993F5                  	jmp	TCOMMAND
 11914                                  
 11915                                  IFTRUE:
 11916 00000B71 E8681A                  	call	scanoff
 11917 00000B74 89F1                    	mov	cx,si
 11918 00000B76 81E98100                	sub	cx,81h
 11919 00000B7A 280E8000                	sub	[80h],cl
 11920 00000B7E 8A0E8000                	mov	cl,[80h]
 11921 00000B82 880E[0589]              	mov	[COMBUF+1],cl
 11922 00000B86 BF[0689]                	mov	di,COMBUF+2
 11923 00000B89 FC                      	cld
 11924 00000B8A F3A4                    	rep	movsb
 11925 00000B8C B00D                    	mov	al,0Dh
 11926 00000B8E AA                      	stosb
 11927                                  
 11928                                  ; Signal that an IF was done. 
 11929                                  ; This prevents the redirections from getting lost.
 11930                                  
 11931 00000B8F 1E                      	push	ds
 11932 00000B90 8E1E[A58A]              	mov	ds,[RESSEG]
 11933 00000B94 C606[9301]FF            	mov	byte [IfFlag],-1
 11934 00000B99 1F                      	pop	ds
 11935                                  
 11936                                  ; Go do the command
 11937                                  
 11938 00000B9A E93AF7                  	jmp	DOCOM1
 11939                                  
 11940                                  ; ---------------------------------------------------------------------------
 11941                                  
 11942                                  IFERRORJ3:
 11943 00000B9D EB80                    	jmp	IFERRORJ2
 11944                                  
 11945                                  IFERLEV:
 11946 00000B9F B70A                    	mov	bh,10
 11947 00000BA1 30DB                    	xor	bl,bl
 11948                                  GETNUMLP:
 11949 00000BA3 AC                      	lodsb
 11950 00000BA4 3C0D                    	cmp	al,0Dh
 11951 00000BA6 74F5                    	je	short IFERRORJ3
 11952 00000BA8 E8391A                  	call	DELIM
 11953 00000BAB 740C                    	jz	short GOTNUM
 11954 00000BAD 2C30                    	sub	al,'0'
 11955 00000BAF 86C3                    	xchg	al,bl
 11956 00000BB1 F6E7                    	mul	bh
 11957 00000BB3 00D8                    	add	al,bl
 11958 00000BB5 86C3                    	xchg	al,bl
 11959 00000BB7 EBEA                    	jmp	short GETNUMLP
 11960                                  GOTNUM:
 11961 00000BB9 1E                      	push	ds
 11962 00000BBA 8E1E[A58A]              	mov	ds,[RESSEG]
 11963 00000BBE 8A26[8501]              	mov	ah,[RetCode]
 11964 00000BC2 1F                      	pop	ds
 11965 00000BC3 30C0                    	xor	al,al
 11966 00000BC5 38DC                    	cmp	ah,bl
 11967 00000BC7 7398                    	jnb	short IFRET
 11968 00000BC9 FEC8                    	dec	al
 11969 00000BCB EB94                    	jmp	short IFRET
 11970                                  
 11971                                  ; ---------------------------------------------------------------------------
 11972                                  
 11973                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11974                                  ; This is a NOP if no batch in progress.
 11975                                  
 11976                                  _SHIFT:
 11977 00000BCD 8E1E[A58A]              	mov	ds,[RESSEG]
 11978 00000BD1 A1[3401]                	mov	ax,[Batch]		; get batch pointer
 11979 00000BD4 09C0                    	or	ax,ax			; in batch mode?
 11980 00000BD6 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 11981                                  SHIFT_RETN:				; no, done.
 11982 00000BD8 C3                      	retn
 11983                                  SHIFT1:
 11984 00000BD9 8EC0                    	mov	es,ax
 11985 00000BDB 8ED8                    	mov	ds,ax
 11986                                  
 11987                                  ; Now move the batch args down by 1 word
 11988                                  
 11989                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 11990                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 11991 00000BDD BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 11992 00000BE0 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 11993 00000BE3 B90900                  	mov	cx,9			; move 9 parameters
 11994 00000BE6 F3A5                    	rep	movsw			; SHIFT down
 11995                                  
 11996                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 11997                                  ; We have copied it into the previous position.
 11998                                  
 11999 00000BE8 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 12000 00000BEB 74EB                    	je	short SHIFT_RETN ; No new parm
 12001                                  
 12002                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 12003                                  ; Assume, first, that there is no next argument.
 12004                                   
 12005 00000BED 8B35                    	mov	si,[di]
 12006 00000BEF C705FFFF                	mov	word [di],-1		; Assume no parm
 12007                                  
 12008                                  ; The parameters are CR separated. Scan for end of this parm.
 12009                                  
 12010                                  SKIPCRLP:
 12011 00000BF3 AC                      	lodsb
 12012 00000BF4 3C0D                    	cmp	al,0Dh
 12013 00000BF6 75FB                    	jne	short SKIPCRLP
 12014                                  
 12015                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12016                                  ; are finished. There are no more parms and the pointer has been previously
 12017                                  ; initialized to indicate it.
 12018                                  
 12019 00000BF8 803C00                  	cmp	byte [si],0
 12020 00000BFB 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12021 00000BFD 8935                    	mov	[di],si			; Pointer to next parm as %9
 12022 00000BFF C3                      	retn
 12023                                  
 12024                                  ; =============== S U B	R O U T	I N E =======================================
 12025                                  
 12026                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12027                                  ; returns char in AL, carry set -> eof
 12028                                  
 12029                                  SKIPDELIM:
 12030 00000C00 F706[3401]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12031 00000C06 740A                    	jz	short SKIPERR
 12032 00000C08 E85DFD                  	call	GETBATBYT		; get a char
 12033 00000C0B E8D619                  	call	DELIM			; check for ignoreable chars
 12034 00000C0E 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12035 00000C10 F8                      	clc
 12036 00000C11 C3                      	retn
 12037                                  SKIPERR:
 12038 00000C12 F9                      	stc
 12039                                  GOTO_RETN:
 12040 00000C13 C3                      	retn
 12041                                  
 12042                                  ; ---------------------------------------------------------------------------
 12043                                  
 12044                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12045                                  ;  .com file. This routine strips the CALL off the command line, sets
 12046                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12047                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12048                                  ;  being CALLed.
 12049                                  
 12050                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12051                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12052                                  _$CALL:
 12053                                  
 12054                                  ;  strip off CALL from command line
 12055                                  
 12056                                  	;ASSUME DS:trangroup,ES:trangroup
 12057                                  
 12058 00000C14 56                      	push	si
 12059 00000C15 57                      	push	di
 12060 00000C16 50                      	push	ax
 12061 00000C17 51                      	push	cx
 12062 00000C18 BE[0689]                	mov	si,COMBUF+2
 12063 00000C1B E8BE19                  	call	scanoff			;get to first non-delimeter
 12064                                  	;add	si,4
 12065 00000C1E 83C604                  	add	si,length_call		;point to char past CALL
 12066 00000C21 BF[0689]                	mov	di,COMBUF+2
 12067                                  	;mov	cx,124		
 12068 00000C24 B97C00                  	mov	cx,COMBUFLEN-length_call 
 12069                                  					;get length of buffer
 12070 00000C27 F3A4                    	rep	movsb			;move it
 12071 00000C29 59                      	pop	cx
 12072 00000C2A 58                      	pop	ax
 12073 00000C2B 5F                      	pop	di
 12074 00000C2C 5E                      	pop	si
 12075                                  
 12076                                  ;  set call flag to indicate call in progress
 12077                                  
 12078 00000C2D 1E                      	push	ds
 12079 00000C2E 8E1E[A58A]              	mov	ds,[RESSEG]
 12080 00000C32 C606[9901]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12081 00000C37 C606[9A01]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12082                                  
 12083                                  ; Turn off any pipes in progress.
 12084                                  
 12085 00000C3C 803E[0102]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12086 00000C41 7403                    	jz	short _NOPIPE
 12087 00000C43 E8A520                  	call	PIPEDEL
 12088                                  _NOPIPE:
 12089 00000C46 1F                      	pop	ds
 12090 00000C47 C3                      	retn
 12091                                  
 12092                                  ; ---------------------------------------------------------------------------
 12093                                  
 12094                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12095                                  _GOTO:
 12096 00000C48 8E1E[A58A]              	mov	ds,[RESSEG]
 12097 00000C4C F706[3401]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12098 00000C52 74BF                    	jz	short GOTO_RETN
 12099 00000C54 31D2                    	xor	dx,dx
 12100 00000C56 1E                      	push	ds
 12101 00000C57 8E1E[3401]              	mov	ds,[Batch]
 12102                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12103 00000C5B 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12104                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12105 00000C5F 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12106                                  
 12107                                  	; MSDOS 6.0
 12108                                  ;M037
 12109                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12110                                  ;
 12111 00000C63 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12112                                  					; clear eof indicator ;M037
 12113                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12114 00000C68 1F                      	pop	ds
 12115                                  GOTOOPEN:
 12116 00000C69 E875F8                  	call	PROMPTBAT
 12117                                  	;mov	di,5Dh
 12118 00000C6C BF5D00                  	mov	di,FCB+1		; Get the label
 12119 00000C6F B90B00                  	mov	cx,11
 12120 00000C72 B020                    	mov	al,' '
 12121 00000C74 F2AE                    	repne	scasb
 12122 00000C76 7501                    	jnz	short NOINC
 12123 00000C78 41                      	inc	cx
 12124                                  NOINC:
 12125 00000C79 83E90B                  	sub	cx,11
 12126 00000C7C F7D9                    	neg	cx
 12127                                  	;mov	[cs:GOTOLEN],cx
 12128                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12129 00000C7E 26890E[AA8B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12130                                  
 12131                                  ; At beginning of file. Skip to first non-delimiter char
 12132                                  
 12133 00000C83 E87AFF                  	call	SKIPDELIM
 12134 00000C86 721C                    	jb	short BADGOTO
 12135 00000C88 3C3A                    	cmp	al,':'
 12136 00000C8A 7426                    	jz	short CHKLABEL
 12137                                  LABLKLP:				; Look for the label
 12138 00000C8C E8D9FC                  	call	GETBATBYT
 12139 00000C8F 3C0A                    	cmp	al,0Ah
 12140 00000C91 7509                    	jne	short LABLKTST
 12141                                  
 12142                                  ; At beginning of line. Skip to first non-delimiter char
 12143                                  
 12144 00000C93 E86AFF                  	call	SKIPDELIM
 12145 00000C96 720C                    	jb	short BADGOTO
 12146 00000C98 3C3A                    	cmp	al,':'
 12147 00000C9A 7416                    	je	short CHKLABEL
 12148                                  LABLKTST:
 12149 00000C9C F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
 12150 00000CA2 75E8                    	jnz	short LABLKLP
 12151                                  BADGOTO:
 12152 00000CA4 E87100                  	call	BATCLOSE
 12153                                  
 12154                                  	; MSDOS 6.0
 12155                                  ;SR;
 12156                                  ; At this point we are terminating without freeing up any nested batch 
 12157                                  ;segments i.e if the error occurred within a called batch file. This routine
 12158                                  ;will traverse the linked list of batch segments and free all of them.
 12159                                  ;
 12160 00000CA7 E8BB00                  	call	free_batch		; free up nested batch segments
 12161                                  
 12162                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12163 00000CAA 0E                      	push	cs
 12164 00000CAB 1F                      	pop	ds
 12165 00000CAC BA[917F]                	mov	dx,BADLAB_PTR
 12166 00000CAF E99E1C                  	jmp	cerror
 12167                                  
 12168                                  ; Found the :.	Skip to first non-delimiter char
 12169                                  
 12170                                  CHKLABEL:
 12171 00000CB2 E84BFF                  	call	SKIPDELIM
 12172 00000CB5 72ED                    	jb	short BADGOTO
 12173 00000CB7 BF5D00                  	mov	di,FCB+1 ; 5Dh
 12174                                  	;mov	cx,[cs:GOTOLEN]
 12175                                  	; 14/02/2023
 12176 00000CBA 268B0E[AA8B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12177 00000CBF EB05                    	jmp	short GOTBYTE
 12178                                  
 12179                                  NEXTCHRLP:
 12180 00000CC1 51                      	push	cx
 12181 00000CC2 E8A3FC                  	call	GETBATBYT
 12182 00000CC5 59                      	pop	cx
 12183                                  GOTBYTE:
 12184                                  	; 18/03/2023
 12185                                  	; 14/02/2023
 12186                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12187 00000CC6 E8F416                  	call	testkanj
 12188 00000CC9 7413                    	jz	short NOTKANJ1
 12189 00000CCB 263A05                  	cmp	al,[es:di]
 12190 00000CCE 75CC                    	jne	short LABLKTST
 12191 00000CD0 47                      	inc	di
 12192 00000CD1 49                      	dec	cx
 12193 00000CD2 E3C8                    	jcxz	LABLKTST
 12194 00000CD4 51                      	push	cx
 12195 00000CD5 E890FC                  	call	GETBATBYT
 12196 00000CD8 59                      	pop	cx
 12197 00000CD9 263A05                  	cmp	al,[es:di]
 12198 00000CDC EB0C                    	jmp	short KNEXTLABCHR
 12199                                  NOTKANJ1:
 12200                                  	; 14/02/2023
 12201                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12202 00000CDE 0C20                    	or	al,20h
 12203 00000CE0 263A05                  	cmp	al,[es:di]
 12204                                  	;jne	short TRYUPPER
 12205                                  	;jmp	short NEXTLABCHR
 12206                                  	; 25/04/2023
 12207 00000CE3 7407                    	je	short NEXTLABCHR 
 12208                                  TRYUPPER:
 12209 00000CE5 2C20                    	sub	al,20h
 12210 00000CE7 263A05                  	cmp	al,[es:di]
 12211                                  KNEXTLABCHR:
 12212 00000CEA 75B0                    	jnz	short LABLKTST
 12213                                  NEXTLABCHR:
 12214 00000CEC 47                      	inc	di
 12215 00000CED E2D2                    	loop	NEXTCHRLP
 12216 00000CEF E876FC                  	call	GETBATBYT
 12217                                  	; 14/02/2023
 12218 00000CF2 26833E[AA8B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12219                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12220 00000CF8 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12221 00000CFA 3C20                    	cmp	al,' '
 12222 00000CFC 779E                    	ja	short LABLKTST
 12223                                  GOTOCONT:
 12224 00000CFE 3C0D                    	cmp	al,0Dh
 12225 00000D00 7407                    	je	short SKIPLFEED
 12226                                  TONEXTBATLIN:
 12227 00000D02 E863FC                  	call	GETBATBYT
 12228 00000D05 3C0D                    	cmp	al,0Dh
 12229 00000D07 75F9                    	jne	short TONEXTBATLIN
 12230                                  SKIPLFEED:
 12231 00000D09 E85CFC                  	call	GETBATBYT
 12232                                  
 12233                                  	; MSDOS 6.0
 12234                                  ;SR;
 12235                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12236                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12237                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12238                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12239                                  ;all other cases, EOF will be hit while trying to read the next line and
 12240                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12241                                  ;
 12242 00000D0C 06                      	push	es
 12243 00000D0D 8E06[3401]              	mov	es,[Batch]
 12244 00000D11 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12245                                  					;invalidate fake CR-LF flag
 12246 00000D17 07                      	pop	es
 12247                                  
 12248                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12249                                  	;call	BATCLOSE
 12250                                  	;retn
 12251                                  	; 14/02/2023
 12252                                  	;jmp	short BATCLOSE
 12253                                  
 12254                                  ; =============== S U B	R O U T	I N E =======================================
 12255                                  
 12256                                  BATCLOSE:
 12257 00000D18 2E8B1E[558D]            	mov	bx,[cs:BATHAND]
 12258 00000D1D 83FB05                  	cmp	bx,5
 12259 00000D20 7204                    	jb	short CLOSERETURN
 12260                                  	; 14/02/2023
 12261 00000D22 B43E                    	mov	ah,3Eh
 12262                                  	;mov	ah,CLOSE ; 3Eh
 12263 00000D24 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12264                                  			; BX = file handle
 12265                                  CLOSERETURN:
 12266 00000D26 C606[7D01]00            	mov	byte [In_Batch],0 ; reset flag	
 12267 00000D2B C3                      	retn
 12268                                  
 12269                                  ; =============== S U B	R O U T	I N E =======================================
 12270                                  
 12271                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12272                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12273                                  
 12274                                  	; 14/02/2023
 12275                                  BATOPEN:
 12276 00000D2C 1E                      	push	ds
 12277 00000D2D 8E1E[3401]              	mov	ds,[Batch]
 12278                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12279                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12280 00000D31 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12281 00000D34 B8003D                  	mov	ax,3D00h
 12282                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12283 00000D37 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12284                                  			; DS:DX	-> ASCIZ filename
 12285                                  			; AL = access mode
 12286                                  			; 0 - read
 12287 00000D39 721C                    	jc	short SETERRDL
 12288                                  	;mov	dx,[8]
 12289 00000D3B 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12290                                  	;mov	cx,[10]
 12291 00000D3F 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12292 00000D43 1F                      	pop	ds
 12293                                  	;mov	[cs:BATHAND],ax
 12294 00000D44 26A3[558D]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12295 00000D48 89C3                    	mov	bx,ax
 12296 00000D4A B80042                  	mov	ax,4200h
 12297                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12298 00000D4D CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12299                                  			; AL = method: offset from beginning of	file
 12300                                  
 12301                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12302                                  					; nuke batch buffer position
 12303 00000D4F 26C706[2795]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12304                                  BATOPEN_RETN:
 12305 00000D56 C3                      	retn
 12306                                  
 12307                                  SETERRDL:
 12308 00000D57 89D3                    	mov	bx,dx
 12309                                  	; MSDOS 6.0
 12310                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12311                                  	; 14/02/2023
 12312 00000D59 E8940F                  	call	get_ext_error_number
 12313 00000D5C 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12314                                  
 12315                                  	; MSDOS 3.3
 12316                                  	;mov	dx,INSERTDSKPTR
 12317                                  	;call	GET_EXT_ERR_NUMBER
 12318                                  
 12319                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12320 00000D5E 8A07                    	mov	al,[bx]			; Get drive spec
 12321 00000D60 2C40                    	sub	al,'@'			; A = 1
 12322 00000D62 1F                      	pop	ds
 12323 00000D63 F9                      	stc				; SUB mucked over carry
 12324 00000D64 C3                      	retn
 12325                                  
 12326                                  ; =============== S U B	R O U T	I N E =======================================
 12327                                  
 12328                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12329                                  ;the batch and FOR segments until all of them are freed. It also restores
 12330                                  ;the old state of the EchoFlag.
 12331                                  ;
 12332                                  ;	ENTRY:	ds = RESGROUP
 12333                                  ;
 12334                                  ;	EXIT: 	All batch & FOR segments freed.
 12335                                  ;		EchoFlag restored to old state before batch process.
 12336                                  ;
 12337                                  ;	REGISTERS AFFECTED: bx, cx
 12338                                  
 12339                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12340                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12341                                  
 12342                                  free_batch: ;proc near
 12343                                  	;assume	ds:RESGROUP,es:nothing
 12344                                  
 12345 00000D65 06                      	push	es
 12346 00000D66 8B1E[9B01]              	mov	bx,[Next_Batch]
 12347 00000D6A 09DB                    	or	bx,bx
 12348 00000D6C 7431                    	jz	short fb_ret
 12349                                  _ClearBatch:
 12350 00000D6E 8EC3                    	mov	es,bx			; get batch segment
 12351                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12352 00000D70 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12353                                  	;cmp	bx,0			; is a FOR in progress
 12354                                  	; 27/07/2024
 12355 00000D75 21DB                    	and	bx,bx
 12356 00000D77 7408                    	jz	short no_bat_for	; no - don't deallocate
 12357 00000D79 06                      	push	es			;
 12358 00000D7A 8EC3                    	mov	es,bx			; yes - free it up...
 12359 00000D7C B449                    	mov	ah,49h
 12360                                  	;mov	ah,DEALLOC		;
 12361 00000D7E CD21                    	int	21h			;
 12362 00000D80 07                      	pop	es			; restore to batch segment
 12363                                  no_bat_for:
 12364                                  	;mov	cl,[es:1]
 12365 00000D81 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12366                                  					; get old echo flag
 12367                                  	;mov	bx,[es:3]
 12368 00000D86 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12369                                  					; get old batch segment
 12370 00000D8B B449                    	mov	ah,49h
 12371                                  	;mov	ah,DEALLOC		; free it up...
 12372 00000D8D CD21                    	int	21h
 12373                                  	; 14/02/2023
 12374                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12375 00000D8F FF0E[9701]              	dec	word [Nest]		; is there another batch file?
 12376 00000D93 75D9                    	jnz	short _ClearBatch	; keep going until no batch file
 12377                                  	
 12378 00000D95 880E[8801]              	mov	[EchoFlag],cl		;restore echo status
 12379 00000D99 C706[3401]0000          	mov	word [Batch],0		;no batch process in progress
 12380                                  fb_ret:
 12381 00000D9F 07                      	pop	es
 12382 00000DA0 C3                      	ret
 12383                                  
 12384                                  ;free_batch endp
 12385                                  
 12386                                  ;============================================================================
 12387                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12388                                  ;============================================================================
 12389                                  ; 10/10/2018 - Retro DOS v3.0
 12390                                  
 12391                                  ; All batch proccessing has DS set to segment of resident portion
 12392                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12393                                  
 12394                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12395                                  
 12396                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12397                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12398                                  
 12399                                  ; ---------------------------------------------------------------------------
 12400                                  
 12401                                  	; 15/02/2023
 12402                                  FORTERM:
 12403                                  	; MSDOS 6.0
 12404 00000DA1 0E                      	push	cs			;AN037; Get local segment into
 12405 00000DA2 1F                      	pop	ds			;AN037;  DS, ES
 12406 00000DA3 0E                      	push	cs			;AN037;
 12407 00000DA4 07                      	pop	es			;AN037;
 12408                                  
 12409                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12410 00000DA5 E89502                  	call	FOROFF
 12411                                  	;mov	ds,[cs:RESSEG]
 12412 00000DA8 268E1E[A58A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12413 00000DAD 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 12414 00000DB3 750F                    	jne	short BAT_CRLF
 12415 00000DB5 833E[9701]00            	cmp	word [Nest],0		;See if we have nested batch files
 12416 00000DBA 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12417 00000DBC C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12418 00000DC2 EB12                    	jmp	short NOFORP2
 12419                                  BAT_CRLF:
 12420 00000DC4 F606[8801]01            	test	byte [EchoFlag],1 	; Is echo on?
 12421 00000DC9 740B                    	jz	short NOFORP2		; no - exit
 12422 00000DCB F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12423                                  					; print CRLF if in batch
 12424 00000DD1 7403                    	jz	short NOFORP2
 12425 00000DD3 E8F917                  	call	CRLF2
 12426                                  NOFORP2:
 12427 00000DD6 E92BF3                  	jmp	TCOMMAND
 12428                                  
 12429                                  ; ---------------------------------------------------------------------------
 12430                                  
 12431                                  ;------
 12432                                  ;   For-loop processing. For loops are of the form:
 12433                                  ;	    for %<loop-variable> in (<list>) do <command>
 12434                                  ; where <command> may contain references of the form %<variable>, which are
 12435                                  ; later substituted with the items in <list>. The for-loop structure is
 12436                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12437                                  ; <command> once for each item in <list>. All of the information needed for
 12438                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12439                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12440                                  ; a complete copy of the original command-line structure as parsed by
 12441                                  ; 'parseline', loop control variables, and a dma buffer for the
 12442                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12443                                  ; processing has completed, this chunk of memory is returned to the system.
 12444                                  ;
 12445                                  ;   All of the previously defined variables, in 'datares', used for loop
 12446                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12447                                  ;
 12448                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12449                                  ; containing all of the other error messages.
 12450                                  ;
 12451                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12452                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12453                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12454                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12455                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12456                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12457                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12458                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12459                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12460                                  ; instead of
 12461                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12462                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12463                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12464                                  ; doesn't matter whether we put brackets around the location or not -- the
 12465                                  ; assembler is "smart" enough to know that we want an address instead of the
 12466                                  ; contents of that location.
 12467                                  ;
 12468                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12469                                  ; One method would be to have a link field in each for-structure pointing to
 12470                                  ; its parent.  Variable references that couldn't be resolved in the local
 12471                                  ; frame would cause a search of prior frames. For-structures would still be
 12472                                  ; allocated and released in exactly the same fashion. The only limit on the
 12473                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12474                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12475                                  ; maintained in the resident data area. This structure would be an array of
 12476                                  ; control-variable names and pointers to for-structure blocks. This would
 12477                                  ; greatly speed up the resolution of non-local variable references. However,
 12478                                  ; since space in the resident is precious, we would have to compromise on a
 12479                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12480                                  ; allocation and de-allocation would have to be modified slightly to take this
 12481                                  ; new structure into account.
 12482                                  ;
 12483                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12484                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12485                                  ; it may be easier to allocate it as part of 'for_segment'.
 12486                                  ;------
 12487                                  		; include fordata.asm
 12488                                  
 12489                                  ; Data structure definitions included by tfor.asm
 12490                                  
 12491                                  struc FOR_INFO
 12492 00000000 <res 444h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12493 00000444 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12494 00000445 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12495 00000447 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12496 00000449 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12497 0000044B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12498 000004CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12499 0000054B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12500                                    .size:
 12501                                  endstruc
 12502                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12503                                  					; ARG_UNIT.SIZE = 1092 ; 27/07/2024
 12504                                  _$FOR_EXIT:
 12505 00000DD9 EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12506                                  
 12507                                  ; ---------------------------------------------------------------------------
 12508                                  
 12509                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12510                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12511                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 12512                                  FORPROC:
 12513 00000DDB A1[9501]                	mov	ax,[ForPtr]
 12514 00000DDE 8ED8                    	mov	ds,ax
 12515 00000DE0 8EC0                    	mov	es,ax			; operate in for-info area
 12516                                  	;;mov	dx,5CBh	; MSDOS 5.0 & 6.22
 12517                                  	;mov	dx,4CBh ; PCDOS 7.1 ; 27/07/2024
 12518 00000DE2 BACB04                  	mov	dx,FOR_INFO.FORDMA	; 1348+1+2+2+2+128 = 1483 = 5CBh
 12519                                  		; PCDOS 7.1 COMMAND.COM ; 1092+1+2+2+2+128 = 1227 = 4CBh
 12520 00000DE5 B8001A                  	mov	ax,1A00h
 12521                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12522 00000DE8 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12523                                  			; DS:DX	-> disk	transfer buffer
 12524                                  FOR_BEGIN:
 12525                                  	;;cmp	word [545h],0
 12526                                  	;cmp	word [445h] ; 27/07/2024
 12527 00000DEA 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12528 00000DEF 7404                    	jz	short FOR_BEGIN1
 12529                                  					; non-zero for_expand equals FALSE
 12530                                  	;;inc	word [547h]
 12531                                  	;inc	word [447h] ; 27/07/2024
 12532 00000DF1 FF064704                	inc	word [FOR_INFO.FOR_MINARG]
 12533                                  FOR_BEGIN1:
 12534                                  	;mov	bx,[447h] ; 27/07/2024
 12535 00000DF5 8B1E4704                	mov	bx,[FOR_INFO.FOR_MINARG] ; current item in <list> to examine
 12536                                  	;cmp	bx,[449h] ; 27/07/2024
 12537 00000DF9 3B1E4904                	cmp	bx,[FOR_INFO.FOR_MAXARG]
 12538 00000DFD 7FDA                     	jg	short _$FOR_EXIT	; exceeding maxarg means all done
 12539                                  	;mov	ax,0
 12540 00000DFF B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12541 00000E02 E84723                  	call	argv_calc		; compute argv[x] address
 12542                                  	;mov	cx,[bx+3]
 12543 00000E05 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12544 00000E08 8B17                    	mov	dx,[bx]
 12545                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12546                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12547 00000E0A F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12548 00000E0E 7512                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12549 00000E10 8B37                    	mov	si,[bx]
 12550                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12551                                  
 12552                                  	;mov	al,[cs:LPAREN]
 12553                                  	; 15/02/2023
 12554                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12555                                  	;mov	al,'('	; mov al,lparen
 12556                                  	;cmp	[si-1],	al		; If the current token is the first
 12557                                  	; 27/07/2024
 12558 00000E12 807CFF28                	cmp	byte [si-1],'('
 12559 00000E16 750A                    	jne	short FORSUB		;  one in the list and originally had
 12560 00000E18 41                      	inc	cx			;  the opening paren as its first char,
 12561                                  					;  the argstartel ptr needs to be
 12562                                  					;  advanced passed it before the prefix
 12563                                  					;  length is computed.
 12564                                  	;mov	al,':'
 12565                                  	;cmp	[si+1],	al		; If the token begins with "(d:",
 12566                                  	; 27/07/2024
 12567 00000E19 807C013A                	cmp	byte [si+1],':'
 12568 00000E1D 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12569 00000E1F 83C102                  	add	cx,2			;  rest of the prefix as well.
 12570                                  FORSUB:
 12571 00000E22 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12572                                  	;;cmp	word [545h],0
 12573                                  	;cmp	word [445h],0 ; 27/07/2024
 12574 00000E24 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12575                                  					; are we still expanding a name?
 12576 00000E29 7416                    	jz	short FOR_FIND_NEXT
 12577                                  					; if so, get next matching filename
 12578                                  	;test	byte [bx+2],2
 12579 00000E2B F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12580 00000E2F 7505                    	jnz	short FOR_FIND_FIRST
 12581                                  					; should we expand THIS (new) arg?
 12582                                  	;mov	cx,[bx+5]
 12583                                  					; else, just copy all of it directly
 12584 00000E31 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12585 00000E34 EB1D                    	jmp	short FOR_SMOOSH
 12586                                  
 12587                                  	;nop
 12588                                  	; 15/02/2023
 12589                                  FOR_FIND_FIRST:
 12590 00000E36 51                      	push	cx
 12591 00000E37 31C9                    	xor	cx,cx
 12592 00000E39 B8004E                  	mov	ax,4E00h
 12593                                  	;mov	ax,Find_First*256 ; 4E00h
 12594 00000E3C CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12595                                  			; CX = search attributes
 12596                                  			; DS:DX	-> ASCIZ filespec
 12597                                  			; (drive,path, and wildcards allowed)
 12598 00000E3E 59                      	pop	cx
 12599 00000E3F EB05                    	jmp	short FOR_RESULT
 12600                                  
 12601                                  	;nop
 12602                                  FOR_FIND_NEXT:
 12603 00000E41 B8004F                  	mov	ax,4F00h
 12604                                  	;mov	ax,Find_Next*256 ;4F00h
 12605 00000E44 CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12606                                  			; [DTA]	= data block from
 12607                                  			; last AH = 4Eh/4Fh call
 12608                                  FOR_RESULT:
 12609 00000E46 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12610 00000E49 7201                    	jc	short FOR_CHECK
 12611                                  	; 15/02/2023
 12612 00000E4B 40                      	inc	ax ; ax = 0
 12613                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12614                                  FOR_CHECK:				; record success of findfirst/next
 12615                                  	;;mov	[545h],ax
 12616                                  	;mov	[445h],ax ; 27/07/2024
 12617 00000E4C A34504                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12618 00000E4F 09C0                    	or	ax,ax			; anything out there?
 12619 00000E51 7597                    	jnz	short FOR_BEGIN		; if not, try next arg
 12620                                  FOR_SMOOSH:
 12621                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12622 00000E53 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12623                                  	;;mov	di,54Bh	; MSDOS 5.0 & 6.22 COMMAND.COM
 12624                                  	;mov	di,44Bh ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12625 00000E55 BF4B04                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12626 00000E58 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12627                                  					
 12628 00000E5A 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12629                                  					; if we're not expanding, we can
 12630 00000E5F 7509                    	jnz	short FOR_MAKE_COM 	; skip the following
 12631                                  	; 15/02/2023
 12632                                  	;;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.22 COMMAND.COM ; 27/07/2024
 12633                                  	; 27/07/2024
 12634                                  	;mov	si,04E9h ; PCDOS 7.1 COMMAND.COM
 12635 00000E61 BEE904                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12636                                  FOR_MORE:
 12637                                  	;cmp	byte [si],0		; tack on matching filename
 12638                                  	;jz	short FOR_MAKE_COM
 12639                                  	;movsb
 12640                                  	;jnz	short FOR_MORE
 12641                                  	; 25/04/2023
 12642 00000E64 AC                      	lodsb
 12643 00000E65 AA                      	stosb
 12644 00000E66 08C0                    	or	al,al
 12645 00000E68 75FA                    	jnz	short FOR_MORE
 12646                                  FOR_MAKE_COM:
 12647                                  	; 25/04/2023
 12648                                  	;xor	al,al			; tack a null byte onto the end
 12649                                  	;stosb				; of the substitute string
 12650 00000E6A 31C9                    	xor	cx,cx			; character count for command line
 12651 00000E6C F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12652 00000E6E 31DB                    	xor	bx,bx			; argpointer
 12653 00000E70 BF[0689]                	mov	di,COMBUF+2
 12654                                  	; 15/02/2023
 12655                                  	;;mov	bl,[544h] ; MSDOS 5.0-6.22 ; 27/07/2024
 12656                                  	; 27/07/2024
 12657                                  	;mov	bl,[444h] ; PCDOS 7.1 COMMAND.COM 
 12658 00000E73 8A1E4404                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12659                                  	;;mov	dh,[64Bh]
 12660                                  	;mov	dh,[54Bh] ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12661 00000E77 8A364B05                	mov	dh,[FOR_INFO.FOR_VAR]
 12662                                  					; %<for-var> is replaced by [forbuf]
 12663 00000E7B 0E                      	push	cs			; time to form the <command> string
 12664 00000E7C 07                      	pop	es
 12665                                  	;assume ES:trangroup
 12666                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12667 00000E7D B80000                  	mov	ax,0			; translate offset to pointer
 12668 00000E80 E8C922                  	call	argv_calc
 12669                                  	;mov	si,[bx+9]
 12670 00000E83 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr]
 12671                                  					; mov ptr passed beginning space
 12672 00000E86 46                      	inc	si
 12673                                  FOR_MAKE_LOOP:
 12674 00000E87 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12675 00000E89 46                      	inc	si
 12676 00000E8A 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12677 00000E8C 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12678 00000E8E 3834                    	cmp	[si],dh			; got the right <variable>?
 12679 00000E90 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12680 00000E92 46                      	inc	si			; skip over <for-variable>
 12681                                  
 12682 00000E93 56                      	push	si
 12683                                  	; 15/02/2023
 12684                                  	;;mov	si,54Bh	; MSDOS 5.0-6.22 ; 27/07/2024
 12685                                  	; 27/07/2024
 12686                                  	;mov	si,44Bh ; PCDOS 7.1 COMMAND.COM
 12687 00000E94 BE4B04                  	mov	si,FOR_INFO.FORBUF
 12688                                  					; substitute the <item> for <variable>
 12689                                  					; to make a final <command> to execute
 12690                                  SLOOP:					
 12691 00000E97 AC                      	lodsb				; grab all those <item> bytes, and
 12692 00000E98 AA                      	stosb				; add 'em to the <command> string,
 12693 00000E99 08C0                    	or	al,al			; until we run into a null
 12694 00000E9B E0FA                    	loopne	SLOOP
 12695 00000E9D 4F                      	dec	di			; adjust length and <command> pointer
 12696 00000E9E 41                      	inc	cx			; so we can overwrite the null
 12697 00000E9F 5E                      	pop	si
 12698 00000EA0 EBE5                    	jmp	short FOR_MAKE_LOOP
 12699                                  					; got back for more <command> bytes
 12700                                  FOR_STOSB:
 12701 00000EA2 AA                      	stosb				; take a byte from the <command> arg
 12702 00000EA3 49                      	dec	cx			; and put it into the <command> to be
 12703                                  					; executed (and note length, too)
 12704 00000EA4 3C0D                    	cmp	al,0Dh
 12705 00000EA6 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12706                                  FOR_MADE_COM:
 12707 00000EA8 F6D1                    	not	cl
 12708                                  	;mov	[cs:COMBUF+1],cl
 12709                                  	;mov	ds,[cs:RESSEG]
 12710                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12711                                  	; MSDOS 5.0 COMMAND.COM
 12712 00000EAA 26880E[0589]            	mov	[es:COMBUF+1],cl
 12713 00000EAF 268E1E[A58A]            	mov	ds,[es:RESSEG]
 12714                                  	;assume DS:resgroup
 12715 00000EB4 F606[8801]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12716 00000EB9 742F                    	jz	short NOECHO3
 12717                                  	;cmp	byte [NullFlag],nullcommand
 12718 00000EBB 803E[9D01]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12719 00000EC0 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf
 12720                                  
 12721 00000EC2 E80A17                  	call	CRLF2		  	;G Print out prompt
 12722                                  NO_CRLF_PR:
 12723 00000EC5 C606[9D01]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12724 00000ECA 0E                      	push	cs
 12725 00000ECB 1F                      	pop	ds
 12726 00000ECC 57                      	push	di
 12727 00000ECD E8C10E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12728 00000ED0 5F                      	pop	di
 12729                                  
 12730 00000ED1 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12731 00000ED6 C706[118C][0689]        	mov	word [string_ptr_2],COMBUF+2
 12732                                  	; 17/04/2023
 12733 00000EDC BA[C380]                	mov	dx,string_buf_ptr
 12734 00000EDF E8EF3E                  	call	std_printf
 12735 00000EE2 26C645FF0D              	mov	byte [es:di-1],0Dh
 12736 00000EE7 E9EAF3                  	jmp	DOCOM		  	; run silent, run deep...
 12737                                  NOECHO3:
 12738 00000EEA C606[9D01]00            	mov	byte [NullFlag],0
 12739 00000EEF 0E                      	push	cs
 12740 00000EF0 1F                      	pop	ds
 12741 00000EF1 E9E3F3                  	jmp	DOCOM1
 12742                                  
 12743                                  FORNESTERRJ:				; no multi-loop processing... yet!
 12744 00000EF4 E84601                  	call	FOROFF
 12745 00000EF7 E92901                  	jmp	FORNESTERR
 12746                                  
 12747                                  ; ---------------------------------------------------------------------------
 12748                                  
 12749                                  FORERRORJ:
 12750 00000EFA E9DDFB                  	jmp	FORERROR
 12751                                  
 12752                                  ; ---------------------------------------------------------------------------
 12753                                  
 12754                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F24h
 12755                                  
 12756                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12757                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 12758                                  
 12759                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12760                                  	; PCDOS 7.1 COMMAND.COM - TRANGROUP:1040h
 12761                                  _$FOR:
 12762 00000EFD 8E06[A58A]              	mov	es,[RESSEG]
 12763 00000F01 26803E[9401]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12764 00000F07 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12765                                  
 12766                                  ; Turn off any pipes in progress.
 12767                                  
 12768 00000F09 26803E[0102]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12769 00000F0F 7403                    	jz	short NO_PIPE
 12770 00000F11 E8D71D                  	call	PIPEDEL
 12771                                  NO_PIPE:
 12772 00000F14 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12773 00000F16 E8F400                  	call	NEXTARG			; move to next argv[n]
 12774 00000F19 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12775 00000F1B 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12776 00000F1D 75DB                    	jne	short FORERRORJ
 12777 00000F1F 89C5                    	mov	bp,ax			; save forloop variable
 12778 00000F21 AC                      	lodsb
 12779 00000F22 08C0                    	or	al,al			; and MUST end immediately...
 12780 00000F24 75D4                    	jnz	short FORERRORJ
 12781 00000F26 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12782 00000F29 72CF                    	jb	short FORERRORJ
 12783                                  	;and	ax,0DFDFh
 12784 00000F2B 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12785                                  	; 15/02/2023
 12786                                  	;cmp	ax,4E49h  	; MSDOS 5.0
 12787                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12788                                  	;cmp	ax,in_word	; MSDOS 5.0
 12789 00000F2E 3D494E                  	cmp	ax,'IN'
 12790 00000F31 75C7                    	jnz	short FORERRORJ
 12791 00000F33 AC                      	lodsb
 12792                                  
 12793                                  	; 15/02/2023
 12794                                  	; MSDOS 3.3
 12795                                  	;or	al,al			; it, too, must end right away
 12796                                  	;jz	short CHECKLPAREN
 12797                                  	;cmp	al,[LPAREN]
 12798                                  	;jnz	short FORERRORJ
 12799                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12800                                  	;add	word [bx],2
 12801                                  	;;add	word [bx+9],2
 12802                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12803                                  	;;sub	word [bx+5],2
 12804                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12805                                  	;mov	ax,[si-1]
 12806                                  	;jmp	short LPCHECK
 12807                                  
 12808                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12809                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12810                                  
 12811                                  	; MSDOS 6.0
 12812                                  ; Compaq bug fix -- exit from this loop on error
 12813                                  
 12814 00000F34 08C0                    	or	al,al
 12815 00000F36 75C2                    	jne	short FORERRORJ		; jump on error
 12816                                  
 12817                                  ;	je	short CHECKLPAREN
 12818                                  ;
 12819                                  ; Not null. Perhaps there are no spaces between this and the (:
 12820                                  ;   FOR %i in(foo bar...
 12821                                  ; Check for the Lparen here
 12822                                  ;
 12823                                  ;;	cmp	al,lparen
 12824                                  ;;	jnz	short FORERRORJ
 12825                                  ;
 12826                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12827                                  ; being there in the first place.
 12828                                  ;
 12829                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12830                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12831                                  ;;						; advance original string
 12832                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12833                                  ;
 12834                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12835                                  ; current value.
 12836                                  ;
 12837                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12838                                  ;;	jmp	short LPCHECK
 12839                                  ;
 12840                                  ; end of Compaq bug fix
 12841                                  
 12842                                  ; ---------------------------------------------------------------------------
 12843                                  
 12844                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12845                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12846                                  
 12847                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12848                                  CHECKLPAREN:
 12849 00000F38 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12850 00000F3B 72BD                    	jc	short FORERRORJ
 12851                                  LPCHECK:
 12852                                  	; 15/02/2023
 12853                                  	; MSDOS 5.0 (% MSDOS 6.0)
 12854                                  	;;cmp	al,[LPAREN]
 12855                                  	;cmp	al,lparen
 12856 00000F3D 3C28                    	cmp	al,'('
 12857 00000F3F 75B9                    	jne	short FORERRORJ
 12858 00000F41 80FC00                  	cmp	ah,0
 12859 00000F44 7410                    	je	short FOR_PAREN_TOKEN
 12860                                  	;;cmp	ah,[RPAREN]		; special case:  null list
 12861                                  	;cmp	ah,rparen
 12862 00000F46 80FC29                  	cmp	ah,')'
 12863 00000F49 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12864 00000F4B E953FE                  	jmp	FORTERM
 12865                                  FOR_LIST_NOT_EMPTY:
 12866                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12867 00000F4E FF07                    	inc	word [bx]		; Advance ptr past "("
 12868                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry
 12869 00000F50 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12870 00000F53 46                      	inc	si			; Inc si so check for ")" works
 12871 00000F54 EB0D                    	jmp	short FOR_LIST
 12872                                  
 12873                                  	;nop
 12874                                  FOR_PAREN_TOKEN:
 12875 00000F56 E8B400                  	call	NEXTARG			; what have we in our <list>?
 12876 00000F59 729F                    	jc	short FORERRORJ
 12877                                  	; 15/02/2023
 12878                                  	;;;cmp	ax,[RPAREN+1]
 12879                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12880                                  	;cmp	ax,nullrparen
 12881 00000F5B 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12882 00000F5E 7503                    	jne	short FOR_LIST
 12883 00000F60 E93EFE                  	jmp	FORTERM
 12884                                  
 12885                                  ;FORERORJJ:
 12886                                  	;jmp	FORERROR
 12887                                  
 12888                                  FOR_LIST:				; skip over rest of <list>
 12889 00000F63 89D1                    	mov	cx,dx			; first arg of <list>
 12890                                  
 12891                                  SKIP_LIST:
 12892                                  	;add	si,[bx+5]
 12893 00000F65 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12894 00000F68 83EE03                  	sub	si,3			; si = ptr to last char of token
 12895                                  	; 15/02/2023
 12896                                  	;;mov	al,[RPAREN]
 12897                                  	;mov	al,rparen
 12898 00000F6B B029                    	mov	al,')'
 12899 00000F6D 3804                    	cmp	[si],al			; Is this the last element in <list>
 12900 00000F6F 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12901 00000F71 E89900                  	call	NEXTARG			; No, get next arg <list>
 12902                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12903                                  	;jmp	short SKIP_LIST
 12904                                  	; 15/02/2023
 12905 00000F74 73EF                    	jnc	short SKIP_LIST
 12906                                  
 12907                                  	; 15/02/2023
 12908                                  FORERORJJ:
 12909 00000F76 E961FB                  	jmp	FORERROR
 12910                                  
 12911                                  FOR_END_LIST:
 12912 00000F79 89D7                    	mov	di,dx			; record position of last arg in <list>
 12913 00000F7B C60400                  	mov	byte [si],0		; Zap the rparen
 12914                                  	; 15/02/2023
 12915                                  	;;;cmp	ax,[RPAREN+1]
 12916                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12917                                  	;cmp	ax,nullparen
 12918 00000F7E 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12919 00000F81 7401                    	je	short FOR_DO		; Yes, continue
 12920 00000F83 47                      	inc	di			; No, inc position of last arg
 12921                                  FOR_DO:
 12922 00000F84 E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12923 00000F87 72ED                    	jc	short FORERORJJ
 12924                                  	;and	ax,0DFDFh
 12925 00000F89 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12926                                  	; 15/02/2023
 12927                                  	;;cmp	ax,[DO_WORD]
 12928                                  	;cmp	ax,do_word ; 4F44h
 12929 00000F8C 3D444F                  	cmp	ax,'DO'	 ; 4F44h
 12930 00000F8F 75E5                    	jne	short FORERORJJ
 12931 00000F91 AC                      	lodsb
 12932 00000F92 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12933 00000F94 75E0                    	jnz	short FORERORJJ
 12934                                  		
 12935 00000F96 E87400                  	call	NEXTARG			; on to the beginning of <command>
 12936 00000F99 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12937                                  
 12938 00000F9B 50                      	push	ax
 12939 00000F9C 53                      	push	bx
 12940 00000F9D 51                      	push	cx
 12941 00000F9E 52                      	push	dx			; preserve registers against disaster
 12942 00000F9F 57                      	push	di
 12943 00000FA0 56                      	push	si
 12944 00000FA1 55                      	push	bp
 12945 00000FA2 E85FF7                  	call	FREE_TPA		; need to make free memory, first
 12946 00000FA5 E89500                  	call	FOROFF
 12947                                  	;mov	bx,264
 12948 00000FA8 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12949 00000FAB E8C524                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12950 00000FAE 9C                      	pushf
 12951 00000FAF 26A3[9501]              	mov	[es:ForPtr],ax
 12952 00000FB3 E85EF7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12953 00000FB6 9D                      	popf
 12954 00000FB7 5D                      	pop	bp
 12955 00000FB8 5E                      	pop	si
 12956 00000FB9 5F                      	pop	di
 12957 00000FBA 5A                      	pop	dx
 12958 00000FBB 59                      	pop	cx
 12959 00000FBC 5B                      	pop	bx
 12960 00000FBD 58                      	pop	ax
 12961 00000FBE 723C                    	jc	short FOR_ALLOC_ERR
 12962                                  
 12963 00000FC0 06                      	push	es			; save resgroup seg...
 12964 00000FC1 26FF36[9501]            	push	word [es:ForPtr]
 12965 00000FC6 07                      	pop	es
 12966                                  	;assume es:for_segment
 12967 00000FC7 49                      	dec	cx			; forproc wants min pointing before
 12968 00000FC8 4F                      	dec	di			; first arg, max right at last one
 12969                                  	; 15/02/2023
 12970                                  	;;mov	[547h],cx
 12971                                  	; 27/07/2024
 12972                                  	;mov	[447h],cx ; PCDOS 7.1 COMMAND.COM
 12973 00000FC9 26890E4704              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12974                                  	;;mov	[549h],di
 12975                                  	;mov	[449h],di ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12976 00000FCE 26893E4904              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12977                                  	;;mov	[544h],dl
 12978                                  	;mov	[444h],dl ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12979 00000FD3 2688164404              	mov	[es:FOR_INFO.FOR_COM_START],dl
 12980                                  	;;mov	word [545h],0FFFFh ; -1
 12981                                  	;mov	[445h],0FFFFh ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12982 00000FD8 26C7064504FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 12983                                  					; non-zero means FALSE
 12984 00000FDF 89E8                    	mov	ax,bp
 12985                                  	;;mov	[64Bh],ah
 12986                                  	;mov	[54Bh],ah ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12987 00000FE1 2688264B05              	mov	[es:FOR_INFO.FOR_VAR],ah
 12988 00000FE6 07                      	pop	es
 12989                                  	;assume es:resgroup
 12990 00000FE7 26FE06[9401]            	inc	byte [es:ForFlag]
 12991 00000FEC 26833E[8E01]FF          	cmp	word [es:SingleCom],-1
 12992 00000FF2 7507                    	jne	short FOR_RET
 12993 00000FF4 26C706[8E01]00FF        	mov	word [es:SingleCom],0FF00h
 12994                                  FOR_RET:
 12995 00000FFB C3                      	retn
 12996                                  
 12997                                  FOR_ALLOC_ERR:
 12998                                  	; 15/02/2023
 12999                                  	; MSDOS 3.3
 13000                                  	;mov	dx,INSFMEMMESPTR
 13001                                  	;jmp	CERROR
 13002                                  
 13003                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13004                                  	; MSDOS 6.0
 13005                                  	;mov	byte [msg_disp_class],1
 13006 00000FFC C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 13007                                  					;AN000; set up extended error msg class
 13008                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 13009 00001001 BA[FC7E]                	mov	dx,extend_buf_ptr
 13010                                  					;AC000; get extended message pointer
 13011                                  	;mov	word [extend_buf_ptr],8
 13012 00001004 C706[FC7E]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13013                                  					;AN000; get message number in control block
 13014 0000100A E94319                  	jmp	cerror
 13015                                  
 13016                                  
 13017                                  ; =============== S U B	R O U T	I N E =======================================
 13018                                  
 13019                                  NEXTARG:
 13020 0000100D 42                      	inc	dx			; next argv[n]
 13021                                  	;cmp	dx,[ARG_ARGVCNT]
 13022 0000100E 3B16[7090]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13023                                  					; make sure we don't run off end
 13024 00001012 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13025 00001014 89D3                    	mov	bx,dx
 13026                                  	;mov	ax,ARG_ARGV
 13027                                  	;mov	ax,ARG+ARG_UNIT.argv
 13028 00001016 B8[B08D]                	mov	ax,ARG
 13029 00001019 E83021                  	call	argv_calc		; convert array index to pointer
 13030 0000101C 8B37                    	mov	si,[bx]			; load pointer to argstring
 13031                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13032 0000101E AD                      	lodsw				; and load first two chars
 13033 0000101F F8                      	clc
 13034 00001020 C3                      	retn
 13035                                  NEXTARG_ERR:
 13036 00001021 F9                      	stc
 13037 00001022 C3                      	retn
 13038                                  
 13039                                  ; ---------------------------------------------------------------------------
 13040                                  
 13041                                  FORNESTERR:
 13042 00001023 1E                      	push	ds
 13043 00001024 8E1E[A58A]              	mov	ds,[RESSEG]
 13044                                  	;ASSUME DS:RESGROUP
 13045 00001028 BA[5A80]                	mov	dx,FORNESTMES_PTR
 13046 0000102B 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 13047 00001031 7506                    	jne	short NOFORP3
 13048 00001033 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13049                                  NOFORP3:
 13050 00001039 1F                      	pop	ds
 13051 0000103A E91319                  	jmp	cerror
 13052                                  
 13053                                  ; =============== S U B	R O U T	I N E =======================================
 13054                                  
 13055                                  ; General routine called to free the for segment. We also clear the forflag
 13056                                  ; too. Change no registers.
 13057                                  
 13058                                  FOROFF:
 13059 0000103D 50                      	push	ax
 13060 0000103E 06                      	push	es
 13061 0000103F 2E8E06[A58A]            	mov	es,[cs:RESSEG]
 13062 00001044 26A1[9501]              	mov	ax,[es:ForPtr]
 13063 00001048 09C0                    	or	ax,ax
 13064 0000104A 7408                    	jz	short FREEDONE
 13065 0000104C 06                      	push	es
 13066 0000104D 8EC0                    	mov	es,ax
 13067                                  	; 15/02/2023
 13068 0000104F B449                    	mov	ah,49h
 13069                                  	;mov	ah,DEALLOC ; 49h
 13070 00001051 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13071                                  			; ES = segment address of area to be freed
 13072 00001053 07                      	pop	es
 13073                                  FREEDONE:
 13074 00001054 26C706[9501]0000        	mov	word [es:ForPtr],0
 13075 0000105B 26C606[9401]00          	mov	byte [es:ForFlag],0
 13076 00001061 07                      	pop	es
 13077 00001062 58                      	pop	ax
 13078 00001063 C3                      	retn
 13079                                  
 13080                                  ;============================================================================
 13081                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13082                                  ;============================================================================
 13083                                  ; 09/10/2018 - Retro DOS v3.0
 13084                                  
 13085                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13086                                  
 13087                                  ; ---------------------------------------------------------------------------
 13088                                  
 13089                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13090                                  
 13091                                  %if 0
 13092                                  
 13093                                  ; The DIR command displays the contents of a directory.
 13094                                  ;
 13095                                  ; ****************************************************************
 13096                                  ; *
 13097                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13098                                  ; *
 13099                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13100                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13101                                  ; *		 If an error occurs issue and error message and
 13102                                  ; *		 transfer control to CERROR.
 13103                                  ; *
 13104                                  ; * INPUT:	 command line at offset 81H
 13105                                  ; *
 13106                                  ; * OUTPUT:	 none
 13107                                  ; *
 13108                                  ; ****************************************************************
 13109                                  
 13110                                  CATALOG:
 13111                                  	; MSDOS 3.3
 13112                                  
 13113                                  	;mov	ax,ARG_ARGV
 13114                                  	;mov	ax,ARG+ARG_UNIT.argv
 13115                                  	mov	ax,ARG
 13116                                  	mov	dx,0FFFFh
 13117                                  	xor	cx,cx
 13118                                  	xor	si,si
 13119                                  DIR1:
 13120                                  	;cmp	cx,[ARG_ARGVCNT]
 13121                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13122                                  	jnb	short DIR6 ; No more arguments
 13123                                  	mov	bx,cx
 13124                                  	call	ARGV_CALC
 13125                                  	;or	si,[bx+7]
 13126                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13127                                  	test	si,7FFCh  ; test si,~8003
 13128                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13129                                  	;test	byte [bx+2],1
 13130                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13131                                  	jz	short DIR3
 13132                                  	jmp	short DIR5
 13133                                  DIR2:
 13134                                  	mov	dx,BADPARMPTR
 13135                                  	jmp	CERROR
 13136                                  DIR3:
 13137                                  	or	cx,cx
 13138                                  	jnz	short DIR4	
 13139                                  	;cmp	word [bx+5],3
 13140                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13141                                  	jz	short DIR5
 13142                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13143                                  	add	word [bx],3
 13144                                  	;add	word [bx+9],3
 13145                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13146                                  	;add	word [bx+3],3
 13147                                  	add	word [bx+ARGV_ELE.argstartel],3
 13148                                  	;sub	word [bx+5],3
 13149                                  	sub	word [bx+ARGV_ELE.arglen],3
 13150                                  DIR4:
 13151                                  	cmp	dx,0FFFFh
 13152                                  	jnz	short DIR2
 13153                                  	mov	dx,bx
 13154                                  DIR5:
 13155                                  	inc	cx
 13156                                  	jmp	short DIR1
 13157                                  DIR6:
 13158                                  	mov	[COMSW],si
 13159                                  	push	dx
 13160                                  	xor	al,al
 13161                                  	cmp	dx,0FFFFh
 13162                                  	jz	short DIR7
 13163                                  	mov	bx,dx
 13164                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13165                                  	mov	di,[bx]
 13166                                  	cmp	byte [di+1],':'
 13167                                  	jnz	short DIR7
 13168                                  	mov	al,[di]
 13169                                  	or	al,20h		; Lowercase drive name	
 13170                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13171                                  DIR7:
 13172                                  	;mov	[5CH],al
 13173                                  	mov	[FCB],al
 13174                                  	call	OKVOLARG
 13175                                  	mov	al,'?'		; *.* is default file spec.
 13176                                  	;mov	di,5Dh
 13177                                  	mov	di,FCB+1
 13178                                  	mov	cx,11
 13179                                  	rep stosb
 13180                                  
 13181                                  ; Begin by processing any switches that may have been specified.
 13182                                  ; BITS will contain any information about switches that was
 13183                                  ; found when the command line was parsed.
 13184                                  
 13185                                  	mov	ax,[COMSW]	; Get switches from command
 13186                                  	mov	[_BITS],ax	; initialize switches
 13187                                  	mov	word [COMSW],0	; initialize flags
 13188                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13189                                  	;test	al,1
 13190                                  	test	al,SWITCHW	; /W ?
 13191                                  	;mov	al,1
 13192                                  	mov	al,NORMPERLIN
 13193                                  	jz	short DIR8
 13194                                  	;mov	al,5
 13195                                  	mov	al,WIDEPERLIN
 13196                                  DIR8:
 13197                                  	mov	[LINLEN],al	; Set number of entries per line
 13198                                  	mov	[LINCNT],al
 13199                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13200                                  	mov	dx,DIRBUF
 13201                                  	mov	ah,Set_DMA ; 1Ah
 13202                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13203                                  			; DS:DX	-> disk	transfer buffer
 13204                                  	;mov	dl,[5Ch]
 13205                                  	mov	dl,[FCB]
 13206                                  	call	SAVUDIR
 13207                                  	pop	bx
 13208                                  	cmp	bx,0FFFFh
 13209                                  	jz	short DIR9
 13210                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13211                                  	mov	dx,[bx]
 13212                                  
 13213                                  ; The user may have specified a device. Search for the path and see if the
 13214                                  ; attributes indicate a device.
 13215                                  
 13216                                  	mov	ah,Find_First ; 4Eh
 13217                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13218                                  			; CX = search attributes
 13219                                  			; DS:DX	-> ASCIZ filespec
 13220                                  			; (drive,path, and wildcards allowed)
 13221                                  	jc	short DIR10
 13222                                  			; Check device atrribute..
 13223                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13224                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13225                                  	; 14/10/2018
 13226                                  	;test	byte [DIRBUF+21],40h
 13227                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13228                                  	jz	short DIR10	; no, go do normal operation
 13229                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13230                                  DIR9:
 13231                                  	jmp	short DOHEADER
 13232                                  DIR10:
 13233                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13234                                  	mov	dx,[bx]
 13235                                  	mov	ah,CHDir ; 3Bh
 13236                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13237                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13238                                  	jnc	short DOHEADER
 13239                                  	;mov	si,[bx+3]
 13240                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13241                                  	cmp	dx,si
 13242                                  	jz	short DIR_NO_DRIVE
 13243                                  	xor	cl,cl
 13244                                  	xchg	cl,[si]
 13245                                  	mov	ah,CHDir ; 3Bh
 13246                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13247                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13248                                  	xchg	cl,[si]
 13249                                  	jnc	short DIR_NO_DRIVE
 13250                                  	mov	al,[si-1]
 13251                                  	call	PATHCHRCMP
 13252                                  	jnz	short DIR11
 13253                                  	mov	al,[si-2]
 13254                                  	call	PATHCHRCMP
 13255                                  	jz	short DIR12
 13256                                  	xchg	cl,[si-1]
 13257                                  	mov	ah,CHDir ; 3Bh
 13258                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13259                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13260                                  	xchg	cl,[si-1]
 13261                                  	jnc	short DIR_NO_DRIVE
 13262                                  DIR11:
 13263                                  	mov	ch,':'
 13264                                  	cmp	ch,[si-1]
 13265                                  	jnz	short DIR12
 13266                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13267                                  	mov	cx,[bx]
 13268                                  	xchg	cx,si
 13269                                  	sub	cx,si
 13270                                  	cmp	cx,2
 13271                                  	jz	short DIR_NO_DRIVE
 13272                                  DIR12:
 13273                                  	mov	dx,BADCDPTR
 13274                                  	;test	byte [bx+2],4
 13275                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13276                                  	jnz	short DIRERROR
 13277                                  DIRNF:
 13278                                  	mov	dx,FNOTFOUNDPTR
 13279                                  DIRERROR:
 13280                                  	jmp	CERROR
 13281                                  DIR_NO_DRIVE:
 13282                                  	cmp	word [si],'..'
 13283                                  	jnz	short DOREALPARSE
 13284                                  	cmp	byte [si+2],0
 13285                                  	jnz	short DOREALPARSE
 13286                                  	inc	word [COMSW]
 13287                                  	jmp	short DOHEADER
 13288                                  DOREALPARSE:
 13289                                  	mov	di,FCB ; 5Ch	
 13290                                  	;mov	ax,290Eh
 13291                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13292                                  	int	21h	; DOS -	PARSE FILENAME
 13293                                  			; DS:SI	-> string to parse
 13294                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13295                                  			; AL = bit mask	to control parsing
 13296                                  	cmp	byte [si],0
 13297                                  	jz	short DOHEADER
 13298                                  	dec	word [COMSW]
 13299                                  DOHEADER:
 13300                                  		
 13301                                  ; Display the header
 13302                                  
 13303                                  	push	bx
 13304                                  	call	BUILD_DIR_STRING
 13305                                  	mov	dx,DIRBUF
 13306                                  	mov	[VOL_DIR],dx
 13307                                  	mov	dx,DIRHEADPTR
 13308                                  	call	PRINTF_CRLF
 13309                                  	pop	bx
 13310                                  	cmp	bx,0FFFFh
 13311                                  	jz	short DOSEARCH
 13312                                  
 13313                                  ; If there were chars left after parse or device, then invalid file name
 13314                                  
 13315                                  	cmp	word [COMSW],0
 13316                                  	jz	short DOSEARCH	; nothing left; good parse
 13317                                  	jl	short DIRNFFIX	; not .. => error file not found
 13318                                  	call	RESTUDIR
 13319                                  	mov	dx,BADCDPTR
 13320                                  	jmp	CERROR		; was .. => error directory not found
 13321                                  DIRNFFIX:
 13322                                  	call	RESTUDIR
 13323                                  	jmp	short DIRNF
 13324                                  
 13325                                  ; We are assured that everything is correct. Let's go and search. Use
 13326                                  ; attributes that will include finding directories. Perform the first search
 13327                                  ; and reset our directory afterward.
 13328                                  
 13329                                  DOSEARCH:
 13330                                  	;mov	byte [55h],0FFh
 13331                                  	mov	byte [FCB-7],0FFh
 13332                                  	;mov	byte [5Bh],10h
 13333                                  	mov	byte [FCB-1],10h
 13334                                  
 13335                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13336                                  ; the directory information as an extended FCB. We must bias all fetches into
 13337                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13338                                  
 13339                                  	mov	ah,Dir_Search_First ; 11h
 13340                                  	mov	dx,FCB-7 ; 55h
 13341                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13342                                  			; DS:DX	-> FCB
 13343                                  
 13344                                  ; Restore the user's directory. We preserve, though, the return from the
 13345                                  ; previous system call for later checking.
 13346                                  
 13347                                  FOUND_FIRST_FILE:
 13348                                  	push	ax		; save return state
 13349                                  	call	RESTUDIR	; restore user's dir	
 13350                                  	pop	ax		; get return state back
 13351                                  
 13352                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13353                                  ; no more.
 13354                                  
 13355                                  DIRSTART:
 13356                                  	inc	al		; 0FFh = file not found
 13357                                  	jnz	short DISPLAY	; Either an error or we are finished
 13358                                  	jmp	CHKCNT
 13359                                  DISPLAY:
 13360                                  	inc	word [FILECNT]	; Keep track of how many we find
 13361                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13362                                  	;call	SHONAME
 13363                                  	call	DISPLAYNAME
 13364                                  	;test	byte [_BITS],1
 13365                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13366                                  	jz	short DIRTEST	; If so, no size, date, or time
 13367                                  	jmp	NEXENT
 13368                                  DIRTEST:
 13369                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13370                                  	; 14/10/2018
 13371                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13372                                  	;test	byte [DIRBUF+19],10h
 13373                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13374                                  	jz	short FILEENT
 13375                                  	mov	dx,DMESPTR
 13376                                  	call	STD_PRINTF
 13377                                  	jmp	short NOFSIZ
 13378                                  FILEENT:
 13379                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13380                                  	;mov	dx,[DIRBUF+36]
 13381                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13382                                  	mov	[FILESIZE_L],dx
 13383                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13384                                  	;mov	dx,[DIRBUF+38]
 13385                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13386                                  	mov	[FILESIZE_H],dx
 13387                                  	mov	dx,FSIZEMESPTR
 13388                                  	call	STD_PRINTF	; Print size of file
 13389                                  NOFSIZ:
 13390                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13391                                  	;mov	ax,[DIRBUF+32]
 13392                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13393                                  	or	ax,ax
 13394                                  	jz	short NEXENT	; Skip if no date
 13395                                  	mov	di,CHARBUF
 13396                                  	push	ax
 13397                                  	mov	ax,'  '
 13398                                  	stosw
 13399                                  	pop	ax
 13400                                  	mov	bx,ax
 13401                                  	and	ax,1Fh		; Get day
 13402                                  	mov	dl,al
 13403                                  	mov	ax,bx
 13404                                  	mov	cl,5
 13405                                  	shr	ax,cl		; Align month
 13406                                  	and	al,0Fh		; Get month
 13407                                  	mov	dh,al
 13408                                  	mov	cl,bh
 13409                                  	shr	cl,1		; Align year
 13410                                  	xor	ch,ch
 13411                                  	add	cx,80		; Relative 1980
 13412                                  	cmp	cl,100
 13413                                  	jb	short MILLENIUM
 13414                                  	sub	cl,100
 13415                                  MILLENIUM:
 13416                                  	call	DATE_CXDX
 13417                                  	;mov	cx,[DIRBUF_FTIME]
 13418                                  	;mov	cx,[DIRBUF+30]
 13419                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13420                                  	jcxz	PRBUF		; Time field present?
 13421                                  	mov	ax,2020h
 13422                                  	stosw
 13423                                  	shr	cx,1
 13424                                  	shr	cx,1
 13425                                  	shr	cx,1
 13426                                  	shr	cl,1
 13427                                  	shr	cl,1		; Hours in CH, minutes in CL
 13428                                  	mov	bl,[TIME_24]
 13429                                  	or	bl,80h		; Tell P_TIME called from DIR
 13430                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13431                                  PRBUF:
 13432                                  	xor	ax,ax
 13433                                  	stosb
 13434                                  	mov	dx,CHARBUF
 13435                                  	mov	[STRING_PTR_2],dx
 13436                                  	mov	dx,STRINGBUF2PTR
 13437                                  	call	STD_PRINTF
 13438                                  NEXENT:
 13439                                  	dec	byte [LINCNT]
 13440                                  	jnz	short SAMLIN
 13441                                  NEXLIN:
 13442                                  	mov	al,[LINLEN]
 13443                                  	mov	[LINCNT],al
 13444                                  	call	CRLF2
 13445                                  	dec	byte [LINPERPAG]
 13446                                  	jnz	short SCROLL
 13447                                  	;test	byte [_BITS],2
 13448                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13449                                  	jz	short SCROLL	; If not, just continue
 13450                                  	mov	byte [LINPERPAG],23
 13451                                  	call	PAUSE
 13452                                  	jmp	short SCROLL
 13453                                  SAMLIN:
 13454                                  	mov	dx,TABPTR	; Output a tab
 13455                                  	call	STD_PRINTF
 13456                                  SCROLL:
 13457                                  	mov	ah,Dir_Search_Next ; 12h
 13458                                  	;mov	dx,55h
 13459                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13460                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13461                                  			; DS:DX	-> FCB
 13462                                  			; Return: AL = status
 13463                                  	jmp	DIRSTART
 13464                                  CHKCNT:
 13465                                  	test	word [FILECNT],0FFFFh ; -1
 13466                                  	jnz	short TRAILER
 13467                                  	jmp	DIRNF
 13468                                  TRAILER:
 13469                                  	mov	al,[LINLEN]
 13470                                  	cmp	al,[LINCNT]
 13471                                  	jz	short MMESSAGE
 13472                                  	call	CRLF2
 13473                                  MMESSAGE:
 13474                                  	mov	dx,DIRMESPTR
 13475                                  	mov	si,[FILECNT]
 13476                                  	mov	[DIR_NUM],si
 13477                                  	call	STD_PRINTF
 13478                                  DTFREE:
 13479                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13480                                  	;mov	dl,[5Ch]
 13481                                  	mov	dl,[FCB]
 13482                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13483                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13484                                  	cmp	ax,-1
 13485                                  	jnz	short DTFREE1
 13486                                  DTRET:
 13487                                  	retn
 13488                                  DTFREE1:
 13489                                  	mul	cx
 13490                                  	mul	bx
 13491                                  	mov	[BYTES_FREE],ax
 13492                                  	mov	[BYTES_FREE+2],dx
 13493                                  	mov	dx,BYTEMESPTR
 13494                                  	jmp	STD_PRINTF
 13495                                  
 13496                                  ; =============== S U B	R O U T	I N E =======================================
 13497                                  
 13498                                  SHONAME:
 13499                                  DISPLAYNAME:
 13500                                  	; MSDOS 3.3
 13501                                  	mov	di,CHARBUF
 13502                                  	mov	cx,8
 13503                                  	rep	movsb
 13504                                  	mov	al,' '
 13505                                  	stosb
 13506                                  	mov	cx,3
 13507                                  	rep	movsb
 13508                                  	xor	ax,ax
 13509                                  	stosb
 13510                                  	push	dx
 13511                                  	mov	dx,CHARBUF
 13512                                  	mov	[STRING_PTR_2],dx
 13513                                  	mov	dx,STRINGBUF2PTR
 13514                                  	call	STD_PRINTF
 13515                                  	pop	dx
 13516                                  	retn
 13517                                  
 13518                                  %endif
 13519                                  
 13520                                  ;============================================================================
 13521                                  ; DIR.ASM, MSDOS 6.0, 1991
 13522                                  ;============================================================================
 13523                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13524                                  
 13525                                  	; MSDOS 6.0
 13526                                  %if 0
 13527                                  
 13528                                  ;***	DIR.ASM - DIR internal command
 13529                                  
 13530                                  comment	% =================================================================
 13531                                  
 13532                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13533                                  "PART4 COMMAND Transient routines".
 13534                                  
 13535                                  From residual documentation, I surmise that TCMD.ASM originally
 13536                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13537                                  VER.  The file seems to have been successively split:
 13538                                  
 13539                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13540                                  
 13541                                  TCMD1A.ASM contained only the DIR command.
 13542                                  
 13543                                  Usage:
 13544                                  ------
 13545                                  
 13546                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13547                                  
 13548                                  DIR /?
 13549                                  
 13550                                  
 13551                                  <filespec> may include any or none of:  drive; directory path;
 13552                                             wildcarded filename.  If drive or directory path are
 13553                                  	   omitted, the current defaults are used.  If the
 13554                                  	   file name or extension is omitted, wildcards are
 13555                                  	   assumed.
 13556                                  
 13557                                  /w	Wide listing format.  Files are displayed in compressed
 13558                                  	'name.ext' format.  Subdirectory files are enclosed in
 13559                                  	brackets, '[dirname]'.
 13560                                  
 13561                                  /p	Paged, or prompted listing.  A screenful is displayed
 13562                                  	at a time.  The name of the directory being listed appears
 13563                                  	at the top of each page.
 13564                                  
 13565                                  	Bugbug:  pages nead to be uniform length..?
 13566                                  
 13567                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13568                                  	listed in compressed 'name.ext' format, one per line,
 13569                                  	without additional information.  Good for making batch
 13570                                  	files or for piping.  When used with /s, complete
 13571                                  	pathnames are listed.
 13572                                  
 13573                                  /s	Descend subdirectory tree.  Performs command on current
 13574                                  	or specified directory, then for each subdirectory below
 13575                                  	that directory.  Directory header and footer is displayed
 13576                                  	for each directory where matching files are found, unless
 13577                                  	used with /b.  /b suppresses headers and footers.
 13578                                  
 13579                                  	Tree is explored depth first, alphabetically within the
 13580                                  	same level.
 13581                                  
 13582                                  	Bugbug:  hidden directories aren't searched.
 13583                                  
 13584                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13585                                  
 13586                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13587                                  	compressed volume.
 13588                                  
 13589                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13590                                  	extension).  A sort order may be specified after /o.  Any of
 13591                                  	the following characters may be used: nedsgc (name, extension,
 13592                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13593                                  	a '-' before any letter causes a downward sort on that field.
 13594                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13595                                  	then within each extension sort by date and time in reverse
 13596                                  	chronological order.
 13597                                  
 13598                                  /a	Attribute selection.  Without /a, hidden and system files
 13599                                  	are suppressed from the listing.  With /a alone, all files
 13600                                  	are listed.  An attribute list may follow /a, consisting of
 13601                                  	any of the following characters:  hsdar (hidden, system,
 13602                                  	directory, archive, read-only).  A '-' before any letter
 13603                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13604                                  	are marked read-only and are not directory files.  Note
 13605                                  	that hidden or system files may be included in the listing.
 13606                                  	They are suppressed without /a but are treated like any other
 13607                                  	attribute with /a.
 13608                                  
 13609                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13610                                  
 13611                                  /h has been removed.					;M008
 13612                                  
 13613                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13614                                  	DIR command line.  Any command line options may be specified
 13615                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13616                                  	A filespec may be specified in DIRCMD and will be used unless
 13617                                  	a filespec is specified on the command line.  Any switch
 13618                                  	specified in DIRCMD may be overridden on the command line.
 13619                                  	If the original DIR default action is desired for a particular
 13620                                  	switch, the switch letter may be preceded by a '-' on the
 13621                                  	command line.  E.g.,
 13622                                  
 13623                                  	  /-w	use long listing format
 13624                                  	  /-p	don't page the listing
 13625                                  	  /-b	don't use bare format
 13626                                  	  /-s	don't descend subdirectory tree
 13627                                  	  /-o	display files in disk order
 13628                                  	  /-a	suppress hidden and system files
 13629                                  
 13630                                  Notes:
 13631                                  ------
 13632                                  
 13633                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13634                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13635                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13636                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13637                                  a flag byte which is made zero when the entry is loaded, and made one
 13638                                  when the entry is used.
 13639                                  
 13640                                  Revision History
 13641                                  ================
 13642                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13643                                  				in the absence of ANSI.SYS
 13644                                  
 13645                                  M007	sa	8/1/90		Allow /p/b combination
 13646                                  
 13647                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13648                                  				to internally handle /? message.
 13649                                  
 13650                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13651                                  
 13652                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13653                                  				first FCB with the drive number when the drive
 13654                                  				letter in the command line is preceded by a
 13655                                  				switch.  Now dir manually loads the drive
 13656                                  				number after parsing.
 13657                                  
 13658                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13659                                  				from the ROM BIOS.
 13660                                  
 13661                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13662                                  				a subdirectory having len(pathname)>MAXPATH.
 13663                                  				Just skip over that subdirectory.
 13664                                  
 13665                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13666                                  				byte value, rather than collating table.
 13667                                  				This to match MS-DOS Shell's sort order.
 13668                                  
 13669                                  ========================================================================= %
 13670                                  
 13671                                  %endif
 13672                                  
 13673                                  ; 16/02/2023
 13674                                  
 13675                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13676                                  
 13677                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13678                                  ;
 13679                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13680                                  ;		(order is hard-coded; see OnOffSw)
 13681                                  ;		Inmem is set when entries are loaded in memory.
 13682                                  
 13683                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13684                                  mask.wide  equ 1
 13685                                  mask.pagd  equ 2
 13686                                  mask.subd  equ 4
 13687                                  mask.bare  equ 8
 13688                                  mask.lcase equ 16
 13689                                  mask.inmem equ 32
 13690                                  ;
 13691                                  mask.dev    equ 1
 13692                                  mask.baddir equ 2	
 13693                                  
 13694                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13695                                  
 13696                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13697                                  
 13698                                  ;ResultBuffer	struc		; structure of parse result buffer
 13699                                  ;ValueType	db	?
 13700                                  ;ValueTag	db	?
 13701                                  ;SynPtr		dw	?
 13702                                  ;ValuePtr	dd	?
 13703                                  ;ResultBuffer	ends
 13704                                  
 13705                                  ;ErrorRec	record	baddir:1,dev:1
 13706                                  ;
 13707                                  ;		Error bits are:
 13708                                  ;		  Invalid directory format
 13709                                  ;		  File is device
 13710                                  
 13711                                  ;EntryStruc	struc			; our private directory entry structure
 13712                                  ;used		db	?		; =0 until entry used, then =1
 13713                                  ;filename	db	8 dup (?)	; filename
 13714                                  ;fileext	db	3 dup (?)	; extension
 13715                                  ;fileattr	db	?		; file attributes
 13716                                  ;filetime	dw	?		; file time
 13717                                  ;filedate	dw	?		; file date
 13718                                  ;filesize	dd	?		; file size
 13719                                  ;EntryStruc	ends
 13720                                  
 13721                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13722                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13723                                  ;	push	ax
 13724                                  ;	endm
 13725                                  
 13726                                  ;	public	Catalog		; our entry point
 13727                                  ;
 13728                                  ;	break	<DIR (Catalog) principal routines>
 13729                                  ;
 13730                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13731                                  ; ---------------------------------------------------------------------------
 13732                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13733                                  
 13734                                  ;----------------------------------------------------------------------------
 13735                                  ;----------------------------------------------------------------------------
 13736                                  
 13737                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13738                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13739                                  
 13740                                  ;***	Catalog - DIR command main routine
 13741                                  ;
 13742                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13743                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13744                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13745                                  ;		Tpa = TPA buffer seg addr
 13746                                  ;		BytCnt = # bytes in TPA buffer
 13747                                  ;
 13748                                  ;	EXIT	nothing
 13749                                  ;
 13750                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13751                                  ;
 13752                                  ;	ERROR EXITS
 13753                                  ;
 13754                                  ;	  Errors are handled by setting up error message pointers
 13755                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13756                                  ;	   the environment variable, however, are handled by printing
 13757                                  ;	   an error message and continuing.
 13758                                  ;
 13759                                  ;	EFFECTS
 13760                                  ;
 13761                                  ;	  Directory listing is displayed (on standard output).
 13762                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13763                                  ;	   restore APPEND state.
 13764                                  ;	  Working directory may be changed. The user's default
 13765                                  ;	   directory is saved and flagged for restoration by RestUDir
 13766                                  ;	   during COMMAND cycle.
 13767                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13768                                  ;
 13769                                  ;	NOTES
 13770                                  ;
 13771                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13772                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13773                                  
 13774                                  	; 16/02/2023
 13775                                  CATALOG:
 13776 00001064 E8A400                  	call	SetDefaults
 13777 00001067 E8C800                  	call	ParseEnvironment
 13778 0000106A E8E000                  	call	ParseCmdLine
 13779 0000106D 7303                    	jnc	short catalog1	; no parse error
 13780 0000106F E99600                  	jmp	catErr		; error msg is set up
 13781                                  catalog1:
 13782 00001072 E80901                  	call	SetOptions
 13783 00001075 E8DF00                  	call	SetCollatingTable
 13784                                  
 13785                                  ;	Drive # to operate on has already been placed in FCB by
 13786                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13787                                  
 13788                                  	;;;test	Bits,mask bare
 13789                                  	;;test 	word [_Bits],8
 13790                                  	;test	byte [_Bits],8
 13791 00001078 F606[FC8B]08            	test	byte [_Bits],mask.bare
 13792 0000107D 750A                    	jnz	short catalog2	; don't display volume info for /b
 13793                                  	;invoke	OkVolArg	; find & display volume info
 13794 0000107F E8E00B                  	call	OkVolArg
 13795                                  	;sub	byte [LeftOnpage],2
 13796 00001082 832E[CB8A]02            	sub	word [LeftOnPage],2
 13797                                  				; record display lines used by volume info
 13798 00001087 EB14                    	jmp	short catCrunch
 13799                                  
 13800                                  ;	OkVolArg side effects:
 13801                                  ;	APPEND is disabled;
 13802                                  ;	DTA established at DirBuf;
 13803                                  ;	Filename fields in FCB are wildcarded.
 13804                                  
 13805                                  catalog2:
 13806                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13807                                  
 13808                                  	;invoke	DisAppend	; disable APPEND
 13809 00001089 E8A30B                  	call	DisAppend
 13810                                  
 13811                                  	;mov	dx,offset TRANGROUP:DirBuf
 13812 0000108C BA[AA8B]                	mov	dx,DIRBUF
 13813 0000108F B41A                    	mov	ah,1Ah
 13814                                  	;mov	ah,Set_DMA
 13815 00001091 CD21                    	int	21h		; set DTA
 13816                                  
 13817                                  
 13818                                  	;mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13819                                  	;inc	di		; ES:DI = ptr to filename field of FCB
 13820                                  	; 28/07/2024
 13821 00001093 BF5D00                  	mov	di,FCB+1 ; 5Dh
 13822 00001096 B03F                    	mov	al,'?'		; AL = wildcard character
 13823 00001098 B90B00                  	mov	cx,11
 13824 0000109B F3AA                    	rep	stosb		; wildcard filename field
 13825                                  
 13826                                  catCrunch:
 13827 0000109D E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13828 000010A0 7230                    	jc	short catRecErr	; handle recorded or extended error
 13829                                  
 13830                                  ;	User's directory has been saved, we've changed to specified directory.
 13831                                  ;	ComSw = error bits for later use
 13832                                  ;	FCB contains parsed filename
 13833                                  
 13834                                  	;cmp	byte [COMSW],0
 13835 000010A2 833E[BA8A]00            	cmp	word [COMSW],0
 13836 000010A7 7529                    	jne	short catRecErr	; handle recorded error
 13837                                  
 13838 000010A9 E88701                  	call	InstallCtrlC	; install control-C handler
 13839 000010AC E8CD08                  	call	ZeroTotals	; zero grand totals
 13840 000010AF E84304                  	call	ListDir		; list main directory
 13841 000010B2 7244                    	jc	short catExtErr
 13842                                  
 13843                                  	;;;test	Bits,mask subd
 13844                                  	;;test	word [_Bits],4
 13845                                  	;test	byte [_Bits],4
 13846 000010B4 F606[FC8B]04            	test	byte [_Bits],mask.subd
 13847 000010B9 7405                    	jz	short catalog3	; subdirectories option not set
 13848 000010BB E88D01                  	call	ListSubds	; list subdirectories
 13849 000010BE 7238                    	jc	short catExtErr
 13850                                  catalog3:
 13851                                  ;	Check if any files were found.
 13852                                  
 13853                                  	;;;test	Bits,mask bare
 13854                                  	;;test	word [_Bits],8
 13855                                  	;test	byte [_Bits],8
 13856 000010C0 F606[FC8B]08            	test	byte [_Bits],mask.bare
 13857 000010C5 750A                    	jnz	short catRet	; don't bother for bare format
 13858                                  
 13859 000010C7 A1[D38A]                	mov	ax,[FileCntTotal]
 13860 000010CA 09C0                    	or	ax,ax
 13861 000010CC 7417                    	jz	short catNoFiles ; no files found
 13862                                  
 13863 000010CE E8A702                  	call	DisplayTotals	; display trailing grand totals
 13864                                  	;jmp	short catRet	; all done
 13865                                  	; 25/04/2023
 13866                                  catRet:
 13867 000010D1 C3                      	retn
 13868                                  
 13869                                  catRecErr:
 13870                                  
 13871                                  ;	ComSw may have error bit set. If not, do extended error.
 13872                                  
 13873                                  	;;;test	ComSw,mask dev
 13874                                  	;;test	word [COMSW],1
 13875                                  	;test	byte [COMSW],1
 13876 000010D2 F606[BA8A]01            	test	byte [COMSW],mask.dev
 13877 000010D7 750C                    	jnz	short catNoFiles 
 13878                                  				; filename is device, respond 'file not found'
 13879                                  	;;test	ComSw,mask baddir
 13880                                  	;;test	word [COMSW],2
 13881                                  	;test	byte [COMSW],2
 13882 000010D9 F606[BA8A]02            	test	byte [COMSW],mask.baddir
 13883 000010DE 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13884                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13885                                  				; invalid directory
 13886 000010E0 BA[3780]                	mov	dx,badcd_ptr
 13887 000010E3 EB23                    	jmp	short catErr
 13888                                  
 13889                                  catNoFiles:
 13890                                  
 13891                                  ;	Display header and force 'file not found' message.
 13892                                  
 13893 000010E5 E81107                  	call	DisplayHeader
 13894 000010E8 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13895 000010EB C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13896 000010F0 BA[FC7E]                	mov	dx,extend_buf_ptr
 13897 000010F3 A3[FC7E]                	mov	[extend_buf_ptr],ax
 13898 000010F6 EB10                    	jmp	short catErr
 13899                                  
 13900                                  catExtErr:
 13901                                  
 13902                                  ;	DOS has returned an error status. Get the extended error#, and
 13903                                  ;	set up an error message, changing 'No more files' error 
 13904                                  ;	to 'File not found' error.
 13905                                  
 13906 000010F8 E8E50B                  	call	Set_Ext_Error_Msg
 13907 000010FB 833E[FC7E]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13908 00001100 7506                    	jne	short catalog4  ; catErr
 13909 00001102 C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13910                                  catalog4:
 13911                                  
 13912                                  ;	Error exit. Error message information has been set up
 13913                                  ;	for Std_EPrintf.
 13914                                  
 13915                                  catErr:
 13916 00001108 E94518                  	jmp	cerror		; go to COMMAND error recycle point
 13917                                  
 13918                                  	; 25/04/2023
 13919                                  ;catRet:
 13920                                  	;retn
 13921                                  
 13922                                  ; ---------------------------------------------------------------------------
 13923                                  
 13924                                  ;***	SetDefaults - set default pathname, options
 13925                                  ;
 13926                                  ;	ENTRY	DS = TRANGROUP seg addr
 13927                                  ;
 13928                                  ;	EXIT	nothing
 13929                                  ;
 13930                                  ;	USED	AX,DI
 13931                                  ;
 13932                                  ;	EFFECTS
 13933                                  ;	  SrcBuf = '*',EOL - default pathname
 13934                                  ;	  PathPos = ptr to pathname
 13935                                  ;	  PathCnt = length of pathname
 13936                                  
 13937                                  	; 16/02/2023
 13938                                  SetDefaults:
 13939 0000110B BF[908C]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13940 0000110E 893E[008C]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13941                                  	;mov	al,STAR
 13942 00001112 B02A                    	mov	al,'*'
 13943 00001114 AA                      	stosb
 13944                                  	;mov	al,END_OF_LINE_IN
 13945 00001115 B00D                    	mov	al,0Dh ; cr
 13946 00001117 AA                      	stosb				; SrcBuf = '*',0Dh
 13947 00001118 C706[FE8B]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13948                                  
 13949 0000111E 31C0                    	xor	ax,ax			; AX = 0
 13950 00001120 A3[BA8A]                	mov	[COMSW],ax		; = no error
 13951 00001123 A3[FC8B]                	mov	[_Bits],ax		; = options off
 13952 00001126 A2[2D8C]                	mov	[DestBuf],al		; = no sort
 13953 00001129 C606[048C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13954 0000112E A2[058C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13955                                  peRet:	; 25/04/2023
 13956 00001131 C3                      	retn
 13957                                  
 13958                                  ; ---------------------------------------------------------------------------
 13959                                  
 13960                                  ;***	ParseEnvironment - find and parse our environment variable
 13961                                  ;
 13962                                  ;	Find our environment variable and parse it. If a parse
 13963                                  ;	error occurs, issue an error message. The parse results
 13964                                  ;	up to the error will still have effect. Always leave
 13965                                  ;	the option variables in a useable state.
 13966                                  ;
 13967                                  ;	ENTRY	DS = TRANGROUP seg addr
 13968                                  ;
 13969                                  ;	EXIT	nothing
 13970                                  ;
 13971                                  ;	USED	AX,BX,CX,DX,SI,DI
 13972                                  ;
 13973                                  ;	EFFECTS
 13974                                  ;
 13975                                  ;	  Bits may contain new option settings.
 13976                                  ;	  DestBuf may contain new series of sort codes.
 13977                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13978                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13979                                  ;	  PathPos, PathCnt updated for new pathname.
 13980                                  ;
 13981                                  ;	  If a parse error occurred, an error message will be issued.
 13982                                  
 13983                                  	; 16/02/2023
 13984                                  ParseEnvironment:
 13985 00001132 E87603                  	call	GetEnvValue		; get environment variable value
 13986 00001135 72FA                    	jc	short peRet		; name not found in environment
 13987                                  
 13988                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 13989                                  
 13990 00001137 E8B904                  	call	Parse_Line		; parse environment value
 13991 0000113A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13992                                  	;cmp	ax,END_OF_LINE
 13993 0000113D 74F2                    	je	short peRet		; successful completion
 13994                                  
 13995                                  ;	Some kind of parse error occurred.
 13996                                  ;	We're set up for a Std_EPrintf call.
 13997                                  
 13998 0000113F E8873C                  	call	std_eprintf		; display the parse error
 13999                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 14000                                  					; restore default msg class
 14001 00001142 C606[FA7E]FF            	mov	byte [msg_disp_class],0FFh ; -1
 14002                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 14003 00001147 BA[3B81]                	mov	dx,errparsenv_ptr
 14004                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 14005                                  	;call	Printf_Crlf
 14006                                  	; 25/04/2023
 14007                                  	;retn
 14008 0000114A E9763C                  	jmp	Printf_Crlf
 14009                                  					;M008;Internal handling of /? removed
 14010                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14011                                  	; 25/04/2023
 14012                                  ;peRet:
 14013                                  	;retn
 14014                                  
 14015                                  ; ---------------------------------------------------------------------------
 14016                                  
 14017                                  ;***	ParseCmdLine - parse and record command line parameters
 14018                                  ;
 14019                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14020                                  ;		DS, ES, CS = TRANGROUP seg addr
 14021                                  ;
 14022                                  ;	EXIT	CY = set if parse error occurred
 14023                                  ;
 14024                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14025                                  ;		AX = system parser error code
 14026                                  ;		DX = ptr to message block
 14027                                  ;
 14028                                  ;	USED	AX,BX,CX,DX,SI,DI
 14029                                  ;
 14030                                  ;	EFFECTS
 14031                                  ;
 14032                                  ;	  Bits may contain new option settings.
 14033                                  ;	  DestBuf may contain new series of sort codes.
 14034                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14035                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14036                                  ;	  PathPos, PathCnt updated for new pathname.
 14037                                  ;
 14038                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14039                                  ;	  Msg_Disp_Class = parse error class
 14040                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14041                                  ;	  Message block (see DX) is set up for parse error message
 14042                                  
 14043                                  	; 16/02/2023
 14044                                  ParseCmdLine:
 14045 0000114D BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14046 00001150 E8A004                  	call	Parse_Line		; parse cmd line tail
 14047 00001153 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14048                                  	;;cmp	ax,END_OF_LINE
 14049                                  	; 25/04/2023
 14050                                  	;je	short pcOk		; parse completed successfully
 14051                                  
 14052                                  ;	A parse error occurred. We're all set up for message output.
 14053                                  
 14054                                  	; 25/04/2023
 14055                                  	; cf = 1 (ax < 0FFFFh)
 14056                                  	;stc		   		; return failure
 14057                                  	;jmp	short pcRet
 14058                                  	; 25/04/2023
 14059                                  	;retn
 14060                                  pcOk:
 14061                                  	; 25/04/2023
 14062                                  	;cf = 0 (ax = 0FFFFh)
 14063                                  	;clc				; return success
 14064                                  pcRet:
 14065 00001156 C3                      	retn
 14066                                  
 14067                                  ; ---------------------------------------------------------------------------
 14068                                  
 14069                                  ;***	SetCollatingTable - set up character collating table for sorting
 14070                                  ;
 14071                                  ;	If country is other than USA, try to get a collating table
 14072                                  ;	for character sorting. For USA, use straight byte values.
 14073                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14074                                  ;	by straight byte values in the USA for better performance.
 14075                                  ;
 14076                                  ;	ENTRY	ES = TRANGROUP seg addr
 14077                                  ;
 14078                                  ;	EXIT	nothing
 14079                                  ;
 14080                                  ;	USED	AX,BX,CX,DX,DI
 14081                                  ;
 14082                                  ;	EFFECTS
 14083                                  ;
 14084                                  ;	  If collating table is set -
 14085                                  ;	    CountryPtrId = 6.
 14086                                  ;	    CountryPtr points to collating table.
 14087                                  ;
 14088                                  ;	  Otherwise -
 14089                                  ;	    CountryPtrId = 0.
 14090                                  
 14091                                  SetCollatingTable:
 14092                                  
 14093                                  ;	Begin modification M028
 14094                                  
 14095                                  	;mov	dx,offset TRANGROUP:InternatVars
 14096                                  	;			; DS:DX = ptr to international info buffer
 14097 00001157 BA[FE94]                	mov	dx,INTERNATVARS
 14098 0000115A B80038                  	mov	ax,3800h
 14099                                  	;mov	ax,INTERNATIONAL << 8
 14100                                  	;;mov	ax,INTERNATIONAL shl 8
 14101                                  				; AX = 'Get current country info'
 14102 0000115D CD21                    	int	21h		; call DOS
 14103 0000115F 7217                    	jc	short scNoTable	; error - so don't collate
 14104                                  
 14105                                  ;	BX = country code
 14106                                  
 14107 00001161 83FB01                  	cmp	bx,1
 14108 00001164 7412                    	je	short scNoTable	; we're in USA, don't collate
 14109                                  
 14110                                  ;	End modification M028
 14111                                  
 14112                                  ;*	Country code is other than USA. Try to get a collating table.
 14113                                  
 14114 00001166 B80665                  	mov	ax,6506h
 14115                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14116                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14117                                  				; AH = 'Get Extended Country Info'
 14118                                  				; AL = 'Get Pointer to Collating Table'
 14119 00001169 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14120 0000116C B90500                  	mov	cx,5		; CX = length of info buffer
 14121 0000116F 89DA                    	mov	dx,bx		; DX = country ID = default
 14122                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14123 00001171 BF[1E95]                	mov	di,CountryPtrInfo
 14124                                  				; ES:DI = ptr to info buffer
 14125 00001174 CD21                    	int	21h		; call DOS
 14126 00001176 7305                    	jnc	short scRet	; success
 14127                                  
 14128                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14129                                  
 14130                                  scNoTable:			;M028
 14131 00001178 C606[1E95]00            	mov	byte [CountryPtrId],0
 14132                                  scRet:
 14133 0000117D C3                      	retn
 14134                                  
 14135                                  ; ---------------------------------------------------------------------------
 14136                                  
 14137                                  ;***	SetOptions - check and set options
 14138                                  ;
 14139                                  ;	ENTRY	nothing
 14140                                  ;
 14141                                  ;	EXIT	nothing
 14142                                  ;
 14143                                  ;	USED	AX,BX,CX,DX
 14144                                  ;
 14145                                  ;	EFFECTS
 14146                                  ;
 14147                                  ;	  Bits may contain modified option settings.
 14148                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14149                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14150                                  ;	  PerLine is set according to /w presence.
 14151                                  
 14152                                  	; 16/02/2023
 14153                                  SetOptions:
 14154                                  
 14155                                  ;	If bare listing requested, cancel wide listings.
 14156                                  
 14157                                  	;;;test	Bits,mask bare
 14158                                  	;;test	word [_Bits],8
 14159                                  	;test	byte [_Bits],8
 14160 0000117E F606[FC8B]08            	test	byte [_Bits],mask.bare
 14161 00001183 7405                    	jz	short setopts1
 14162                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14163                                  	;;and	word [_Bits],0FFFEh
 14164                                  	;;and	byte [_Bits],0FEh
 14165 00001185 8026[FC8B]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 14166                                  setopts1:
 14167                                  ;	Set # lines per display page.
 14168                                  
 14169                                  ;M01  Obtain screen height from ROM BIOS data area
 14170                                  ;
 14171                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14172                                  
 14173 0000118A 1E                      	push	ds
 14174                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14175 0000118B B84000                  	mov	ax,40h
 14176 0000118E 8ED8                    	mov	ds,ax			;
 14177                                  	;Assume	DS:ROMBIOS_DATA
 14178                                  
 14179                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14180 00001190 A08400                  	mov	al,[84h]
 14181 00001193 1F                      	pop	ds			;
 14182                                  	;Assume	DS:Trangroup
 14183                                  
 14184 00001194 08C0                    	or	al,al			; If zero specified
 14185 00001196 7502                    	jnz	short setopts2		;
 14186                                  
 14187                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14188 00001198 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14189                                  setopts2:
 14190 0000119A 30E4                    	xor	ah,ah
 14191                                  setopts3:
 14192 0000119C FEC0                    	inc	al			; height + 1 ;M018
 14193                                  
 14194 0000119E A3[778D]                	mov	[LinPerPag],ax		; set the rows now
 14195                                  
 14196                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14197                                  
 14198                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE
 14199                                  					; IOCTL for handles
 14200 000011A1 B80C44                  	mov	ax,440Ch
 14201                                  	;mov	bx,STDOUT		; handle #
 14202 000011A4 BB0100                  	mov	bx,1
 14203                                  	;mov	ch,IOC_SC		; screen
 14204 000011A7 B503                    	mov	ch,3
 14205                                  	;mov	cl,get_generic		; get display info
 14206 000011A9 B17F                    	mov	cl,7Fh
 14207 000011AB BA[678D]                	mov	dx,Display_Ioctl	; info block
 14208 000011AE CD21                    	int	21h			; call DOS
 14209                                  
 14210 000011B0 A1[778D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14211 000011B3 A3[CB8A]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14212                                  
 14213                                  ;	Set # entries per line.
 14214                                  
 14215                                  	;mov	byte [PerLine],NORMPERLIN
 14216                                  					; # entries per line without /w
 14217 000011B6 C606[CA8A]01            	mov	byte [PerLine],1
 14218                                  	;;;test	Bits,mask wide
 14219                                  	;;test	word [_Bits],1
 14220                                  	;test	byte [_Bits],1
 14221 000011BB F606[FC8B]01            	test	byte [_Bits],mask.wide
 14222 000011C0 7405                    	jz	short setopts4
 14223                                  	;mov	byte [PerLine],WIDEPERLIN
 14224                                  					; # entries per line with /w
 14225 000011C2 C606[CA8A]05            	mov	byte [PerLine],5
 14226                                  setopts4:
 14227                                  				;M011;start;The following code checks if a drive
 14228                                  				;letter has been parsed into SrcBuf, and if
 14229                                  				;so, the correct drive number is loaded into
 14230                                  				;the first FCB, at offset 5C.
 14231                                  
 14232                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14233 000011C7 803E[918C]3A            	cmp	byte [SrcBuf+1],':'
 14234 000011CC 750A                    	jne	short soRet
 14235                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14236 000011CE A0[908C]                	mov	al,[SrcBuf]
 14237                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14238 000011D1 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14239 000011D3 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14240 000011D5 A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14241                                  						;M011;end
 14242                                  soRet:
 14243 000011D8 C3                      	retn
 14244                                  
 14245                                  ; ---------------------------------------------------------------------------
 14246                                  
 14247                                  ;***	CrunchPath - analyze supplied or default pathname
 14248                                  ;
 14249                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14250                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14251                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14252                                  ;		 must have space for another char after the delimiter.
 14253                                  ;
 14254                                  ;	EXIT	CY = clear if no error
 14255                                  ;		We are changed to directory found in pathname
 14256                                  ;		Previous directory ready to be restored via RestUDir
 14257                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14258                                  ;
 14259                                  ;		If error occurred,
 14260                                  ;		CY = set
 14261                                  ;		ComSw = error bits (see ErrorRec)
 14262                                  ;		If ComSw not set,
 14263                                  ;		Ready for DOS Get Extended Error call
 14264                                  
 14265                                  	; 16/02/2023
 14266                                  CrunchPath:
 14267 000011D9 E8E101                  	call	FileIsDevice
 14268 000011DC 7507                    	jne	short crpath1	; not a device, skip ahead
 14269                                  	;;;or	ComSw,mask dev	; signal file is device
 14270                                  	;;or	word [COMSW],1
 14271                                  	;or	byte [COMSW],1
 14272 000011DE 800E[BA8A]01            	or	byte [COMSW],mask.dev
 14273 000011E3 EB2F                    	jmp	short cpErr	; return error
 14274                                  crpath1:
 14275 000011E5 FF36[008C]              	push	word [PathPos]	; save ptr to pathname
 14276 000011E9 C606[088C]FF            	mov	byte [DirFlag],-1
 14277                                  				; tell PathCrunch not to parse file into FCB
 14278 000011EE E88714                  	call	PathCrunch	; change to directory in pathname
 14279 000011F1 C606[088C]00            	mov	byte [DirFlag],0
 14280                                  				; reset our little flag
 14281 000011F6 5E                      	pop	si		; SI = ptr to pathname
 14282 000011F7 7208                    	jc	short cpNoDir	; didn't find directory path
 14283 000011F9 741A                    	jz	short cpRet	; found directory path w/ no filename
 14284                                  				;  - leave wildcard default in FCB and return
 14285                                  
 14286                                  ;*	We found a directory, and there was a filename attached.
 14287                                  ;	DestTail = ptr to ASCIIZ filename
 14288                                  
 14289 000011FB 8B36[2A8C]              	mov	si,[DestTail]	; SI = ptr to filename
 14290 000011FF EB28                    	jmp	short cpFile	; go parse the file into FCB
 14291                                  
 14292                                  ;*	PathCrunch failed to find a directory in the pathname.
 14293                                  ;
 14294                                  ;	Msg_Numb = error code
 14295                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14296                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14297                                  
 14298                                  cpNoDir:
 14299 00001201 A1[948D]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14300 00001204 09C0                    	or	ax,ax
 14301 00001206 750C                    	jnz	short cpErr	  ; error occurred - return it
 14302 00001208 803E[288C]00            	cmp	byte [DestIsDir],0
 14303 0000120D 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14304                                  crpath3:
 14305                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14306                                  	;;or	word [COMSW],2
 14307                                  	;or	byte [COMSW],2
 14308 0000120F 800E[BA8A]02            	or	byte [COMSW],mask.baddir
 14309                                  	;jmp	short cpErr	  ; return error
 14310                                  	; 16/02/2023
 14311                                  cpErr:
 14312 00001214 F9                      	stc			  ; return error
 14313                                  cpRet:
 14314 00001215 C3                      	retn
 14315                                  
 14316                                  cpMaybe:
 14317                                  ;	SI = ptr to pathname
 14318                                  
 14319                                  	;cmp	byte [si+1],COLON_CHAR
 14320 00001216 807C013A                	cmp	byte [si+1],':'
 14321 0000121A 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14322 0000121C AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14323                                  crpath2:
 14324 0000121D 813C2E2E                	cmp	word [si],".."
 14325 00001221 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14326 00001223 807C0200                	cmp	byte [si+2],0
 14327                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14328                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14329                                  	;;;or	word [COMSW],2
 14330                                  	;;or	byte [COMSW],2
 14331                                  	;or	byte [COMSW],mask.baddir
 14332                                  	;jmp	short cpErr	  ; return error
 14333                                  	; 16/02/2023
 14334 00001227 74E6                    	je	short crpath3
 14335                                  
 14336                                  ;	The preceding code was taken from the old DIR routine.
 14337                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14338                                  ;	occurring when we're at the root directory. Too bad it
 14339                                  ;	doesn't handle problems with "..\..", etc.
 14340                                  
 14341                                  ;	We're ready to parse a filename into the FCB.
 14342                                  ;	SI = ptr to ASCIIZ filename
 14343                                  
 14344                                  cpFile:	
 14345 00001229 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14346 0000122C B80E29                  	mov	ax,290Eh
 14347                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14348                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14349                                  				; wildcards already in FCB used as defaults
 14350 0000122F CD21                    	int	21h
 14351 00001231 F8                      	clc			; return success
 14352                                  	;jmp	short cpRet
 14353                                  	; 16/02/2023
 14354 00001232 C3                      	retn
 14355                                  
 14356                                  ;cpErr:
 14357                                  ;	stc			; return error
 14358                                  ;cpRet:
 14359                                  ;	retn
 14360                                  
 14361                                  ; ---------------------------------------------------------------------------
 14362                                  
 14363                                  ;***	InstallCtrlC - install our private control-C handler
 14364                                  ;
 14365                                  ;	Put our control-c handler in front of command.com's default
 14366                                  ;	handler, to make sure the user's default directory gets restored.
 14367                                  ;	This shouldn't be necessary, but, for now, there are situations
 14368                                  ;	where the TDATA segment is left in a modified state when a
 14369                                  ;	control-c occurs.  This means that the transient will be
 14370                                  ;	reloaded, and the user's directory cannot be restored.
 14371                                  ;
 14372                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14373                                  ;
 14374                                  ;	ENTRY	nothing
 14375                                  ;
 14376                                  ;	EXIT	nothing
 14377                                  ;
 14378                                  ;	USED	AX,BX,DX
 14379                                  ;
 14380                                  ;	EFFECTS
 14381                                  ;
 14382                                  ;	  CtrlCHandler address placed in int 23 vector.
 14383                                  ;
 14384                                  ;	NOTE
 14385                                  ;
 14386                                  ;	  Command.com's basic control-c handler will be restored
 14387                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14388                                  
 14389                                  	; 16/02/2023
 14390                                  InstallCtrlC:
 14391 00001233 06                      	push	es			; preserve ES
 14392 00001234 B82335                  	mov	ax,3523h
 14393                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14394                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14395 00001237 CD21                    	int	21h
 14396 00001239 891E[2395]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14397 0000123D 8C06[2595]              	mov	[OldCtrlCHandler+2],es	 
 14398 00001241 07                      	pop	es			; restore ES
 14399                                  
 14400 00001242 BA[8719]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14401 00001245 B82325                  	mov	ax,2523h
 14402                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14403                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14404 00001248 CD21                    	int	21h
 14405 0000124A C3                      	retn
 14406                                  
 14407                                  ; ---------------------------------------------------------------------------
 14408                                  
 14409                                  ;***	ListSubds - search and list files in subdirectories
 14410                                  ;
 14411                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14412                                  ;		FCB is still set up for file searches
 14413                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14414                                  ;
 14415                                  ;	EXIT	CY = clear if no error
 14416                                  ;		FileCnt = # files found & displayed
 14417                                  ;		FileSiz = total size of files found
 14418                                  ;
 14419                                  ;		If error,
 14420                                  ;		CY = set
 14421                                  ;		Ready for DOS Get Extended Error call
 14422                                  ;
 14423                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14424                                  ;
 14425                                  ;	EFFECTS
 14426                                  ;
 14427                                  ;	  FileCntTotal, FileSizTotal are updated.
 14428                                  ;	  Subdirectories may be listed on standard output device.
 14429                                  ;
 14430                                  ;	NOTES
 14431                                  ;
 14432                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14433                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14434                                  ;	   Each name is stored ASCIIZ.
 14435                                  
 14436                                  	; 16/02/2023
 14437                                  ListSubds:
 14438                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14439 0000124B E8911A                  	call	SetRest1
 14440                                  
 14441 0000124E BB[EA8C]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14442                                  lsNode:
 14443 00001251 C60700                  	mov	byte [bx],0		; start with null child name
 14444                                  lsLoop:
 14445 00001254 E8F001                  	call	FindNextChild		; search for next subdirectory
 14446 00001257 7235                    	jc	short lsErr		; search failed - examine error
 14447                                  
 14448 00001259 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14449 0000125B E84004                  	call	ChangeDir		; enter child directory
 14450                                  
 14451                                  					; M023;start
 14452 0000125E 7306                    	jnc	short lstsd1		; check for error
 14453                                  	;cmp	ax,3
 14454 00001260 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14455 00001263 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14456                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14457                                  	; 16/02/2023			; M023;end
 14458 00001265 C3                      	retn
 14459                                  lstsd1:	
 14460 00001266 53                      	push	bx
 14461 00001267 E88B02                  	call	ListDir			; list the directory
 14462 0000126A 5B                      	pop	bx
 14463                                  
 14464                                  ;	Note we're ignoring errors returned here.
 14465                                  
 14466 0000126B 89DF                    	mov	di,bx			; DI = ptr to child's name
 14467 0000126D B90D00                  	mov	cx,13			; CX = max name length w/ null
 14468 00001270 30C0                    	xor	al,al			; AL = zero byte to look for
 14469 00001272 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14470 00001274 53                      	push	bx			; save ptr to child's name
 14471 00001275 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14472 00001277 E8D7FF                  	call	lsNode			; recurse from new node
 14473 0000127A 5B                      	pop	bx			; BX = ptr to child's name
 14474 0000127B 9C                      	pushf				; save error condition
 14475                                  	
 14476                                  	;;shove	0
 14477                                  	;mov	ax,0
 14478 0000127C 29C0                    	sub	ax,ax ; 0
 14479 0000127E 50                      	push	ax
 14480                                  	;shove	".."
 14481 0000127F B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14482 00001282 50                      	push	ax
 14483 00001283 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14484 00001285 E81604                  	call	ChangeDir		; return to parent directory
 14485 00001288 58                      	pop	ax			; restore stack
 14486 00001289 58                      	pop	ax
 14487                                  
 14488 0000128A 9D                      	popf				; restore error condition from child
 14489                                  	;jc	short lsRet		; return error
 14490                                  	;jmp	short lsLoop		; look for more children
 14491                                  	; 16/02/2023
 14492 0000128B 73C7                    	jnc	short lsLoop
 14493 0000128D C3                      	retn
 14494                                  lsErr:
 14495 0000128E E85F0A                  	call	get_ext_error_number	; AX = extended error code
 14496                                  	;cmp	ax,2
 14497 00001291 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14498 00001294 7406                    	je	short lsRet		; file not found, we're ok
 14499                                  	;cmp	ax,18
 14500 00001296 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14501 00001299 7401                    	je	short lsRet		; no more files, we're ok
 14502 0000129B F9                      	stc				; return other errors
 14503                                  lsRet:	
 14504 0000129C C3                      	retn
 14505                                  
 14506                                  ; ---------------------------------------------------------------------------
 14507                                  
 14508                                  	;break	<DIR support routines>
 14509                                  
 14510                                  ;***	SUPPORT ROUTINES
 14511                                  
 14512                                  ; ----------------------
 14513                                  
 14514                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14515                                  ;
 14516                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14517                                  ;		BX = ptr to last child's name
 14518                                  ;		BP = ptr to temp child's name
 14519                                  ;
 14520                                  ;	EXIT	nothing
 14521                                  ;
 14522                                  ;	USED	AX,CX,SI,DI
 14523                                  ;
 14524                                  ;	EFFECTS
 14525                                  ;
 14526                                  ;	  Filename pointed to by BP may be changed.
 14527                                  ;
 14528                                  ;	NOTES
 14529                                  ;
 14530                                  ;	  Potential filename replaces temp filename if:
 14531                                  ;	   it's a subdirectory file;
 14532                                  ;	   it doesn't start with a '.';
 14533                                  ;	   it's alphanumerically greater than last child's name;
 14534                                  ;	   and it's alphanumerically less than temp name.
 14535                                  
 14536                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14537                                  	; 07/06/2023
 14538                                  CheckChild:
 14539                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14540 0000129D F606[BF8B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14541 000012A2 741D                    	jz	short ccRet	; not a subdirectory file- return
 14542                                  
 14543                                  	; 16/02/2023
 14544 000012A4 BE[C88B]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14545 000012A7 803C2E                  	cmp	byte [si],'.'
 14546                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14547                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14548 000012AA 7415                    	je	short ccRet	; starts with a dot- return
 14549                                  
 14550                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14551                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14552 000012AC 89DF                    	mov	di,bx
 14553 000012AE E80404                  	call	CmpAscz		; compare candidate to last child's name
 14554 000012B1 760E                    	jna	short ccRet	; it's not above it- return
 14555                                  
 14556                                  
 14557                                  	; 07/06/2023
 14558                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14559                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14560                                  	; si = DIRBUF+FIND_BUF.PNAME
 14561 000012B3 89EF                    	mov	di,bp
 14562 000012B5 E8FD03                  	call	CmpAscz		; compare candidate to temp name
 14563 000012B8 7307                    	jnb	short ccRet	; it's not below it- return
 14564                                  
 14565                                  ;	New kid is alright. Copy to temp.
 14566                                  
 14567                                  	; 07/06/2023
 14568                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14569                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14570                                  	; si = DIRBUF+FIND_BUF.PNAME
 14571 000012BA 89EF                    	mov	di,bp
 14572 000012BC B90D00                  	mov	cx,13
 14573 000012BF F3A4                    	rep	movsb
 14574                                  ccRet:
 14575 000012C1 C3                      	retn
 14576                                  
 14577                                  ; ---------------------------------------------------------------------------
 14578                                  
 14579                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14580                                  ;
 14581                                  ;	Compare one directory entry against another according to
 14582                                  ;	the sort codes in DestBuf. One or more comparisons
 14583                                  ;	may be made of file name, extension, time/date, and
 14584                                  ;	size.  Comparisons may be made for upward or downward
 14585                                  ;	sort order.
 14586                                  ;
 14587                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14588                                  ;		ES:BP = ptr to entry to be compared against
 14589                                  ;		DestBuf contains sort codes (see DestBuf)
 14590                                  ;		DS = TRANGROUP seg addr
 14591                                  ;
 14592                                  ;	EXIT	BX = unchanged
 14593                                  ;		BP = unchanged
 14594                                  ;		Condition flags set for same, above, or below
 14595                                  ;		 comparing BX entry against BP entry.
 14596                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14597                                  ;
 14598                                  ;	USED:	AX,CX,DX,SI,DI
 14599                                  
 14600                                  	; 16/02/2023
 14601                                  CmpEntry:
 14602 000012C2 BE[2D8C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14603                                  ceLoop:
 14604 000012C5 31C0                    	xor	ax,ax		; AX = 0
 14605 000012C7 8A04                    	mov	al,[si]		; AL = sort code
 14606 000012C9 08C0                    	or	al,al
 14607 000012CB 741C                    	jz	short ceDone	; sort code is zero, we're done
 14608 000012CD 46                      	inc	si		; DS:SI = ptr to next sort code
 14609 000012CE 56                      	push	si		; save ptr to next sort code
 14610 000012CF FEC8                    	dec	al
 14611 000012D1 D0E0                    	shl	al,1
 14612                                  	;sal	al,1		; AX = index into cmp call table
 14613                                  				; CY set for downward sort order
 14614 000012D3 89C6                    	mov	si,ax		; SI = index into cmp call table
 14615 000012D5 2E8B84[EA12]            	mov	ax,[cs:si+FieldCmps]
 14616                                  				; AX = addr of compare routine
 14617 000012DA 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14618 000012DC FFD0                    	call	ax 		; do upwards sort
 14619 000012DE EB06                    	jmp	short ceNs
 14620                                  ceDn:
 14621 000012E0 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14622 000012E2 FFD0                    	call	ax		; do sort
 14623 000012E4 87DD                    	xchg	bx,bp		; swap ptrs back
 14624                                  ceNs:
 14625 000012E6 5E                      	pop	si		; SI = ptr to next sort code
 14626 000012E7 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14627                                  ceDone:
 14628                                  
 14629                                  ;	Get here either from unequal compare or sort code = 0.
 14630                                  ;	In the latter case, condition codes indicate equality,
 14631                                  ;	which is correct.
 14632                                  
 14633 000012E9 C3                      	retn
 14634                                  
 14635                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14636                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14637                                  
 14638                                  FieldCmps:		; call table of entry comparisons
 14639 000012EA [F412]                  	dw	CmpName
 14640 000012EC [FF12]                  	dw	CmpExt
 14641 000012EE [3D13]                  	dw	CmpTime
 14642 000012F0 [5913]                  	dw	CmpSize
 14643 000012F2 [5E13]                  	dw	CmpType
 14644                                  
 14645                                  ; ---------------------------------------------------------------------------
 14646                                  
 14647                                  ;***	CmpName - compare file name of two entries
 14648                                  ;***	CmpExt - compare extension of two entries
 14649                                  ;
 14650                                  ;	ENTRY	ES:BX = ptr to one entry
 14651                                  ;		ES:BP = ptr to another entry
 14652                                  ;
 14653                                  ;	EXIT	BX = unchanged
 14654                                  ;		BP = unchanged
 14655                                  ;		Condition flags set for same, above, or below
 14656                                  ;		comparing BX entry to BP entry.
 14657                                  ;
 14658                                  ;	USED:	AX,CX,DX,SI,DI
 14659                                  
 14660                                  	; 16/02/2023
 14661                                  CmpName:
 14662 000012F4 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14663 000012F6 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14664                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14665                                  	;add	si,1
 14666                                  	; 25/04/2023
 14667 000012F8 46                      	inc	si
 14668                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14669                                  	;add	di,1
 14670                                  	; 25/04/2023
 14671 000012F9 47                      	inc	di
 14672                                  	;mov	cx,size filename
 14673                                  				; CX = length of name
 14674 000012FA B90800                  	mov	cx,8
 14675 000012FD EB0C                    	jmp	short CmpStr
 14676                                  
 14677                                  CmpExt:
 14678                                  	; 07/06/2023
 14679                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14680                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14681                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14682                                  	;add	si,9
 14683                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14684                                  	;add	di,9
 14685                                  	;
 14686 000012FF BE0900                  	mov	si,9
 14687 00001302 89F7                    	mov	di,si ; mov di,9
 14688 00001304 01DE                    	add	si,bx
 14689 00001306 01EF                    	add	di,bp
 14690                                  	;
 14691                                  	;mov	cx,size fileext	; CX = length of extension field
 14692 00001308 B90300                  	mov	cx,3
 14693                                  
 14694                                  ;	Bugbug:	use symbol for subfunction code.
 14695                                  
 14696                                  CmpStr:	
 14697 0000130B 803E[1E95]06            	cmp	byte [CountryPtrId],6
 14698 00001310 7527                    	jne	short cnNoCollTable
 14699                                  				; no collating table available
 14700                                  
 14701                                  ;*	Compare strings using collating table.
 14702                                  ;
 14703                                  ;	ES:SI = ptr to 1st string
 14704                                  ;	ES:DI = ptr to 2nd string
 14705                                  ;	CX = length
 14706                                  
 14707 00001312 55                      	push	bp		; preserve BP
 14708 00001313 53                      	push	bx		; preserve BX
 14709 00001314 1E                      	push	ds		; preserve DS
 14710 00001315 C51E[1F95]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14711                                  	;assume	ds:NOTHING
 14712 00001319 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14713 0000131B 43                      	inc	bx
 14714 0000131C 43                      	inc	bx		; DS:BX = ptr to collating values
 14715                                  				; DS:[BX]-2 = size of table
 14716 0000131D 31C0                    	xor	ax,ax		; AX = 0 for starters
 14717                                  
 14718                                  ;	Bugbug:	Investigate removing collating table length checks.
 14719                                  
 14720                                  cnNextChar:
 14721 0000131F 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14722 00001322 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14723 00001323 39E8                    	cmp	ax,bp		; compare to collating table length
 14724 00001325 7301                    	jae	short cn1 	; char not in table
 14725 00001327 D7                      	xlat				
 14726                                  cn1:				; AL = AX = collating value
 14727 00001328 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14728                                  	;lods	byte ptr es:[si]
 14729 0000132A 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14730                                  				; ES:SI = ptr to next char 1st string
 14731 0000132C 39E8                    	cmp	ax,bp		; compare to collating table length
 14732 0000132E 7301                    	jae	short cn2	; char not in table
 14733 00001330 D7                      	xlat				
 14734                                  cn2:				; AL = AX = collating value
 14735 00001331 39D0                    	cmp	ax,dx		; compare collating values
 14736 00001333 E1EA                    	loope	cnNextChar	; until unequal or no more left
 14737                                  
 14738 00001335 1F                      	pop	ds		; restore DS
 14739                                  	;assume	ds:TRANGROUP
 14740 00001336 5B                      	pop	bx		; restore BX
 14741 00001337 5D                      	pop	bp		; restore BP
 14742 00001338 C3                      	retn
 14743                                  
 14744                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14745                                  ;	Don't we wish we could just do this all the time? Sigh.
 14746                                  
 14747                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14748                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14749                                  cnNoCollTable:
 14750                                  	;repe	cmps byte ptr es:[si],[di]
 14751                                  				;db 0F3h,26h,0A6h,0C3h
 14752 00001339 F3                      	repe	; 0F3h
 14753 0000133A 26                      	es	; 26h
 14754 0000133B A6                      	cmpsb	; 0A6h
 14755 0000133C C3                      	retn	; 0C3h
 14756                                  
 14757                                  ; ---------------------------------------------------------------------------
 14758                                  
 14759                                  ;***	CmpTime - compare entries by date/time
 14760                                  ;
 14761                                  ;	ENTRY	ES:BX = ptr to one entry
 14762                                  ;		ES:BP = ptr to another entry
 14763                                  ;
 14764                                  ;	EXIT	BX = unchanged
 14765                                  ;		BP = unchanged
 14766                                  ;		Condition flags set for same, above, or below
 14767                                  ;		 comparing BX entry to BP entry.
 14768                                  ;
 14769                                  ;	USED:	CX,SI,DI
 14770                                  ;
 14771                                  ;	NOTE	Filetime and filedate fields in our private entry
 14772                                  ;		structure must be adjacent and in that order.
 14773                                  
 14774                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14775                                  	; 07/06/2023
 14776                                  CmpTime:
 14777 0000133D 89DE                    	mov	si,bx
 14778 0000133F 89EF                    	mov	di,bp
 14779                                  	;add	si,filedate + size filedate - 1
 14780 00001341 83C610                  	add	si,16 ; 15+2-1
 14781                                  	;add	di,filedate + size filedate - 1
 14782 00001344 83C710                  	add	di,16 ; 15+2-1
 14783                                  	; 07/06/2023
 14784 00001347 BE1000                  	mov	si,16
 14785                                  CmpST2:		; 07/06/2023
 14786 0000134A 89F7                    	mov	di,si	; mov di,16
 14787 0000134C 01DE                    	add	si,bx
 14788 0000134E 01EF                    	add	di,bp
 14789                                  
 14790                                  	;mov	cx,size filetime + size filedate
 14791 00001350 B90400                  	mov	cx,4 ; 2+2
 14792 00001353 FD                      	std
 14793                                  	;repe	cmps byte ptr es:[si],[di]
 14794                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 14795 00001354 F3                      	repe	; 0F3h
 14796 00001355 26                      	es	; 26h
 14797 00001356 A6                      	cmpsb	; 0A6h
 14798                                  	
 14799 00001357 FC                      	cld	; 0FCh
 14800 00001358 C3                      	retn	; 0C3h
 14801                                  
 14802                                  ; ---------------------------------------------------------------------------
 14803                                  
 14804                                  ;***	CmpSize - compare entries by size
 14805                                  ;
 14806                                  ;	ENTRY	ES:BX = ptr to one entry
 14807                                  ;		ES:BP = ptr to another entry
 14808                                  ;
 14809                                  ;	EXIT	BX = unchanged
 14810                                  ;		BP = unchanged
 14811                                  ;		Condition flags set for same, above, or below
 14812                                  ;		 comparing BX entry to BP entry.
 14813                                  ;
 14814                                  ;	USED:	CX,SI,DI
 14815                                  
 14816                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14817                                  	; 07/06/2023
 14818                                  CmpSize:
 14819                                  	;mov	si,bx
 14820                                  	;mov	di,bp
 14821                                  	;;add	si,filesize + size filesize - 1
 14822                                  	;add	si,20  ; 17+4-1
 14823                                  	;;add	di,filesize + size filesize - 1
 14824                                  	;add	di,20  ; 17+4-1
 14825                                  	; 07/06/2023
 14826 00001359 BE1400                  	mov	si,20
 14827                                  	;;;
 14828 0000135C EBEC                    	jmp	short CmpST2 ; 07/06/2023
 14829                                  	;;;
 14830                                  ;CmpST2:
 14831                                  ;	mov	di,si	; mov di,20
 14832                                  ;	add	si,bx
 14833                                  ;	add	di,bp
 14834                                  ;
 14835                                  ;	;mov	cx,size filesize
 14836                                  ;	mov	cx,4
 14837                                  ;	std
 14838                                  ;	;repe	cmps byte ptr es:[si],[di]
 14839                                  ;				;db 0F3h,26h,0A6h
 14840                                  ;	repe	; 0F3h
 14841                                  ;	es	; 26h
 14842                                  ;	cmpsb	; 0A6h
 14843                                  ;
 14844                                  ;	cld
 14845                                  ;	retn
 14846                                  
 14847                                  ; ---------------------------------------------------------------------------
 14848                                  
 14849                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14850                                  ;
 14851                                  ;	ENTRY	ES:BX = ptr to one entry
 14852                                  ;		ES:BP = ptr to another entry
 14853                                  ;
 14854                                  ;	EXIT	BX = unchanged
 14855                                  ;		BP = unchanged
 14856                                  ;		Condition flags set for same, above, or below
 14857                                  ;		 comparing BX entry to BP entry.
 14858                                  ;
 14859                                  ;	USED:	AX
 14860                                  
 14861                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14862                                  CmpType:
 14863                                  	;mov	al,es:[bx].fileattr
 14864 0000135E 268A470C                	mov	al,[es:bx+12]
 14865                                  	;mov	ah,es:[bp].fileattr
 14866 00001362 268A660C                	mov	ah,[es:bp+12]
 14867                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14868                                  	;and	ax,1010h
 14869 00001366 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14870 00001369 38C4                    	cmp	ah,al
 14871 0000136B C3                      	retn
 14872                                  
 14873                                  ; ---------------------------------------------------------------------------
 14874                                  
 14875                                  ;***	DefaultAttr - set default attribute conditions
 14876                                  ;
 14877                                  ;	ENTRY	nothing
 14878                                  ;
 14879                                  ;	EXIT	CY clear
 14880                                  ;
 14881                                  ;	USED
 14882                                  ;
 14883                                  ;	EFFECTS
 14884                                  ;
 14885                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14886                                  
 14887                                  	; 16/02/2023
 14888                                  DefaultAttr:
 14889                                  	;mov	byte [AttrSpecified],6
 14890 0000136C C606[048C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14891                                  					; specify H and S
 14892 00001371 C606[058C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14893 00001376 F8                      	clc				; return success
 14894                                  dtRet:	; 18/02/2023
 14895 00001377 C3                      	retn
 14896                                  
 14897                                  ; ---------------------------------------------------------------------------
 14898                                  
 14899                                  ;***	DisplayTotals - display grand total stats
 14900                                  ;
 14901                                  ;	If we searched subdirectories, display the total # files found
 14902                                  ;	 and total size of files found.
 14903                                  ;	Display disk space remaining.
 14904                                  ;
 14905                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14906                                  ;		Bits contains setting of /s
 14907                                  ;		FCB contains drive #
 14908                                  ;
 14909                                  ;	EXIT	nothing
 14910                                  ;
 14911                                  ;	USES	AX,DX
 14912                                  ;		FileSiz
 14913                                  
 14914                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14915                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14916                                  
 14917                                  DisplayTotals:
 14918                                  	;;;test	Bits,mask subd
 14919                                  	;;test	word [_Bits],4
 14920                                  	;test	byte [_Bits],4
 14921 00001378 F606[FC8B]04            	test	byte [_Bits],mask.subd
 14922 0000137D 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14923                                  
 14924 0000137F E84D12                  	call	CRLF2			; start on new line
 14925 00001382 E8C403                  	call	UseLine
 14926                                  
 14927 00001385 BA[3881]                	mov	dx,total_ptr
 14928 00001388 E8463A                  	call	std_printf		; "Total:",cr,lf
 14929 0000138B E8BB03                  	call	UseLine
 14930                                  
 14931 0000138E A1[D38A]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14932 00001391 BE[D78A]                	mov	si,FileSizTotal
 14933 00001394 BF[CF8A]                	mov	di,FileSiz
 14934 00001397 A5                      	movsw
 14935 00001398 A5                      	movsw				; move total size to size variable
 14936 00001399 E87605                  	call	DisplayCntSiz		; display file count & size &
 14937                                  dtFree: 				;   (maybe) compression ratio
 14938 0000139C B436                    	mov	ah,36h
 14939                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14940 0000139E 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14941 000013A2 CD21                    	int	21h			; call DOS
 14942 000013A4 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14943 000013A7 74CE                    	jz	short dtRet		; can't get drive space - return
 14944 000013A9 F7E1                    	mul	cx
 14945 000013AB F7E3                    	mul	bx
 14946 000013AD A3[188C]                	mov	[Bytes_Free],ax
 14947 000013B0 8916[1A8C]              	mov	[Bytes_Free+2],dx
 14948 000013B4 BA[4A7F]                	mov	dx,bytmes_ptr
 14949 000013B7 E8173A                  	call	std_printf		; "nnn bytes free",cr,lf
 14950                                  	;call	UseLine
 14951                                  ;dtRet:
 14952                                  	;retn
 14953                                  	; 18/02/2023
 14954 000013BA E98C03                  	jmp	UseLine
 14955                                  
 14956                                  ; ---------------------------------------------------------------------------
 14957                                  
 14958                                  ;***	FileIsDevice - see if file looks like a device
 14959                                  ;
 14960                                  ;	ENTRY	PathPos = ptr to pathname
 14961                                  ;		PathCnt = length of pathname w/o terminating char
 14962                                  ;		DirBuf is DOS DTA
 14963                                  ;
 14964                                  ;	EXIT	ZR = set if file looks like a device
 14965                                  ;
 14966                                  ;	USED	AX,BX,CX,DX,DI
 14967                                  ;
 14968                                  ;	EFFECTS
 14969                                  ;
 14970                                  ;	  DTA buffer holds results of Find First function
 14971                                  ;
 14972                                  ;	NOTES
 14973                                  ;
 14974                                  ;	  We try to flag devices in two ways. First, we try
 14975                                  ;	  the DOS Find First function. It returns attribute bit 6
 14976                                  ;	  set on a successful find if it identifies a device name.
 14977                                  ;	  Unfortunately, it returns 'path not found' for a device
 14978                                  ;	  name terminated with colon, such as "CON:". So, we look
 14979                                  ;	  for any colon in the pathname after the 2nd character,
 14980                                  ;	  and flag the pathname as a device if we find one.
 14981                                  
 14982                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14983                                  FileIsDevice:
 14984 000013BD 8B16[008C]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 14985                                  
 14986 000013C1 89D7                    	mov	di,dx
 14987 000013C3 033E[FE8B]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 14988 000013C7 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 14989 000013C9 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 14990                                  
 14991 000013CB 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 14992 000013CD B44E                    	mov	ah,4Eh
 14993                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 14994 000013CF CD21                    	int	21h	 	 ; call DOS
 14995 000013D1 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 14996 000013D3 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 14997                                  
 14998                                  ;	Found a dir entry, see if Find First thinks it's a device.
 14999                                  
 15000                                  	;test	byte [DIRBUF+21],40h
 15001 000013D5 F606[BF8B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 15002 000013DA 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 15003 000013DC 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 15004                                  	;jmp	short piRet
 15005                                  	; 25/04/2023
 15006                                  piRet:
 15007 000013DE C3                      	retn
 15008                                  
 15009                                  ;	Device attribute not returned by Find First function. But
 15010                                  ;	let's check for a colon anywhere in the pathname after the
 15011                                  ;	second byte.
 15012                                  ;
 15013                                  ;	DI = ptr to byte after pathname
 15014                                  
 15015                                  piCol:
 15016 000013DF 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15017 000013E0 B03A                    	mov	al,':'
 15018                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15019 000013E2 8B0E[FE8B]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15020 000013E6 49                      	dec	cx
 15021 000013E7 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15022 000013E8 09C9                    	or	cx,cx
 15023 000013EA 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15024 000013EC 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15025 000013EE FD                      	std			 ; scan downward
 15026 000013EF F2AE                    	repne	scasb
 15027 000013F1 FC                      	cld			 ; restore default upward direction
 15028                                  
 15029                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15030                                  ;piRet:
 15031 000013F2 C3                      	retn
 15032                                  
 15033                                  ;FileIsDevice endp
 15034                                  
 15035                                  ; ---------------------------------------------------------------------------
 15036                                  
 15037                                  ;***	FindFirst - find first directory entry to display
 15038                                  ;***	FindNext - find next directory entry to display
 15039                                  ;
 15040                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15041                                  ;		AttrSpecified, AttrSelect are set
 15042                                  ;
 15043                                  ;	EXIT	CY = clear if successful
 15044                                  ;		BX = offset in TPA buffer of directory entry found
 15045                                  ;
 15046                                  ;		If unsuccessful,
 15047                                  ;		CY = set
 15048                                  ;		AX = DOS error code
 15049                                  ;		DOS Get Extended Error call will get error code
 15050                                  ;
 15051                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15052                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15053                                  ;		but DOS Get Extended Error call WON'T return the correct
 15054                                  ;		error. That's ok, because we'll see the value in AX
 15055                                  ;		and recognize it as a non-error condition.
 15056                                  ;
 15057                                  ;	USED	AX,CX,DX,SI,DI
 15058                                  ;
 15059                                  ;	EFFECTS
 15060                                  ;
 15061                                  ;	  Entries in memory may be marked as output.
 15062                                  ;	  If not sorted, entry is loaded at TPA.
 15063                                  ;
 15064                                  ;	NOTES
 15065                                  ;
 15066                                  ;	  If we don't find a qualifying file, we return after the final
 15067                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15068                                  ;	   indicate an appropriate condition.
 15069                                  
 15070                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15071                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15072                                  	
 15073                                  FindFirst:
 15074                                  	;mov	ax,offset TRANGROUP:GetFirst
 15075 000013F3 B8[CA14]                	mov	ax,GetFirst
 15076 000013F6 EB03                    	jmp	short ffFindEntry
 15077                                  
 15078                                  	; 18/02/2023
 15079                                  FindNext:
 15080                                  	;mov	ax,offset TRANGROUP:GetNext
 15081 000013F8 B8[D814]                	mov	ax,GetNext
 15082                                  
 15083                                  ;	AX = address of correct disk get routine to use.
 15084                                  
 15085                                  ffFindEntry:
 15086 000013FB 06                      	push	es			; save TRANGROUP seg addr
 15087                                  	;;;test	Bits,mask inmem
 15088                                  	;;test	word [_Bits],20h
 15089                                  	;test	byte [_Bits],20h
 15090 000013FC F606[FC8B]20            	test	byte [_Bits],mask.inmem
 15091 00001401 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15092                                  
 15093                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15094                                  ;	There will always be one, or LoadEntries would've failed.
 15095                                  
 15096 00001403 E81A00                  	call	FindInMem		; find first entry in TPA
 15097 00001406 EB16                    	jmp	short ffRet		; return what TPA search returns
 15098                                  
 15099                                  ;	Get entry from disk.
 15100                                  
 15101                                  ffDisk:
 15102 00001408 FFD0                    	call	ax			; get entry from disk
 15103 0000140A 720E                    	jc	short ffGetErr		; get & return error
 15104 0000140C 8E06[A78A]              	mov	es,[TPA]		; ES = seg addr of TPA
 15105 00001410 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15106 00001412 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15107 00001414 E85601                  	call	LoadEntry		; load entry to TPA
 15108 00001417 F8                      	clc				; return success
 15109 00001418 EB04                    	jmp	short ffRet
 15110                                  
 15111                                  ffGetErr:
 15112 0000141A E8D308                  	call	 get_ext_error_number	; AX = DOS error code
 15113 0000141D F9                      	stc
 15114                                  ffRet:
 15115 0000141E 07                      	pop	es			; ES = TRANGROUP seg addr again
 15116 0000141F C3                      	retn
 15117                                  
 15118                                  ; ---------------------------------------------------------------------------
 15119                                  
 15120                                  ;***	FindInMem - find next directory entry in TPA buffer
 15121                                  ;
 15122                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15123                                  ;
 15124                                  ;	EXIT	BX = offset in TPA of entry found
 15125                                  ;
 15126                                  ;		If no more files,
 15127                                  ;		CY = set
 15128                                  ;		AX = DOS 'no more files' error code
 15129                                  ;
 15130                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15131                                  ;
 15132                                  ;	EFFECTS
 15133                                  ;
 15134                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15135                                  
 15136                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15137                                  FindInMem:
 15138 00001420 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15139 00001424 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15140 00001426 FC                      	cld				; make sure default string direction is up
 15141                                  	
 15142 00001427 E86D00                  	call	FindOneInMem		; locate an entry
 15143 0000142A 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15144                                  
 15145                                  ;	BX = ptr to entry in TPA
 15146                                  
 15147                                  fiBest:
 15148 0000142C 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15149                                  fiNext:
 15150 0000142E E87300                  	call	FindNextInMem		; locate next entry
 15151 00001431 720C                    	jc	short fiFound		; no more, best entry so far wins
 15152                                  
 15153                                  ;	BX = ptr to next entry
 15154                                  
 15155 00001433 E88CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15156 00001436 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15157 00001438 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15158                                  
 15159                                  fiNoMore:
 15160                                  
 15161                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15162                                  
 15163                                  	;mov	ax,18
 15164 0000143A B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15165 0000143D F9                      	stc				; return error
 15166                                  	;jmp	short fiRet
 15167                                  	; 18/02/2023
 15168 0000143E C3                      	retn
 15169                                  
 15170                                  fiFound:
 15171 0000143F 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15172 00001441 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15173 00001445 F8                      	clc				; return success
 15174                                  fiRet:
 15175 00001446 C3                      	retn
 15176                                  
 15177                                  ; ---------------------------------------------------------------------------
 15178                                  
 15179                                  ;***	FindNextChild - find next subdirectory in current directory
 15180                                  ;
 15181                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15182                                  ;		DirBuf is established DTA
 15183                                  ;
 15184                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15185                                  ;
 15186                                  ;		If failure,
 15187                                  ;		CY = set
 15188                                  ;		DOS Get Extended Error call will get error
 15189                                  ;
 15190                                  ;	USED	AX,CX,DX,SI,DI,BP
 15191                                  ;
 15192                                  ;	EFFECTS
 15193                                  ;
 15194                                  ;	  DirBuf is used for find first/next calls.
 15195                                  ;
 15196                                  ;	NOTES
 15197                                  ;
 15198                                  ;	  We keep on checking files until DOS returns an error. If
 15199                                  ;	  the error is 'no more files' and the temp filename is not
 15200                                  ;	  the initial high tag, copy the temp to the child's name spot
 15201                                  ;	  and return success. Otherwise, send the error back to caller.
 15202                                  ;
 15203                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15204                                  
 15205                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15206                                  FindNextChild:
 15207 00001447 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15208                                  	;shove	00FFh			; temp filename = high tag
 15209 0000144A B8FF00                  	mov	ax,0FFh
 15210 0000144D 50                      	push	ax
 15211 0000144E 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15212                                  	;shove	"*"	
 15213 00001450 B02A                    	mov	al,'*'  ; ax = 002Ah
 15214 00001452 50                      	push	ax
 15215                                  	;;shove	".*" 
 15216                                  	;mov	ax,"*."
 15217                                  	;mov	ax,2E2Ah
 15218 00001453 B42E                    	mov	ah,'.'
 15219 00001455 50                      	push	ax
 15220 00001456 E8F704                  	call	GetDriveLtr		; AX = "d:"
 15221 00001459 50                      	push	ax
 15222 0000145A 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15223                                  
 15224                                  ;	See that the stack is restored properly at the end of this proc.
 15225                                  
 15226                                  	;mov	cx,10h
 15227 0000145C B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15228 0000145F B44E                    	mov	ah,4Eh
 15229                                  	;mov	ah,Find_First
 15230 00001461 CD21                    	int	21h			; DOS- Find First matching file
 15231 00001463 722C                    	jc	short fcRet		; return error
 15232                                  
 15233 00001465 E835FE                  	call	CheckChild		; check child against last, temp
 15234                                  fcNext:	
 15235                                  	;mov	cx,10h
 15236 00001468 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15237 0000146B B44F                    	mov	ah,4Fh
 15238                                  	;mov	ah,Find_Next
 15239 0000146D CD21                    	int	21h			; DOS- Find Next matching file
 15240 0000146F 7205                    	jc	short fcErr		; examine error
 15241                                  
 15242 00001471 E829FE                  	call	CheckChild		; check child against last, temp
 15243 00001474 EBF2                    	jmp	short fcNext		; go find another child
 15244                                  
 15245                                  fcErr:
 15246 00001476 E87708                  	call	get_ext_error_number	; AX = extended error code
 15247                                  	;cmp	ax,18
 15248 00001479 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15249 0000147C 7512                    	jne	short fcNope		; some other error- return it
 15250                                  
 15251                                  ;	We ran out of files. See if we qualified at least one.
 15252                                  
 15253 0000147E 807E00FF                	cmp	byte [bp],0FFh
 15254 00001482 740C                    	je	short fcNope		; temp filename is unused- no child
 15255                                  
 15256                                  ;	Move temp filename to child name position.
 15257                                  
 15258 00001484 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15259 00001486 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15260                                  fcMove:
 15261 00001488 AC                      	lodsb				; AL = next byte of filename
 15262 00001489 AA                      	stosb				; store byte
 15263 0000148A 08C0                    	or	al,al
 15264 0000148C 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15265 0000148E EBF8                    	jmp	short fcMove		; go move another byte
 15266                                  fcNope:
 15267 00001490 F9                      	stc				; return error
 15268                                  fcRet:
 15269 00001491 9F                      	lahf
 15270 00001492 83C414                  	add	sp,20			; restore stack
 15271 00001495 9E                      	sahf
 15272 00001496 C3                      	retn
 15273                                  
 15274                                  ; ---------------------------------------------------------------------------
 15275                                  
 15276                                  ;***	FindOneInMem - find the first available entry in TPA
 15277                                  ;***	FindNextInMem - find the next available entry in TPA
 15278                                  ;
 15279                                  ;	ENTRY	ES = TPA seg addr
 15280                                  ;		BX = ptr to entry in TPA
 15281                                  ;
 15282                                  ;	EXIT	BX = ptr to entry found
 15283                                  ;		CY = set if no more entries available in TPA
 15284                                  ;
 15285                                  ;	USED	AL
 15286                                  
 15287                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15288                                  FindOneInMem:
 15289 00001497 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15290 0000149A 3C01                    	cmp	al,1
 15291 0000149C 7406                    	je	short FindNextInMem	; entry has already been used
 15292 0000149E 3CFF                    	cmp	al,0FFh
 15293 000014A0 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15294                                  
 15295                                  ;	BX = ptr to entry that hasn't been output yet.
 15296                                  
 15297 000014A2 F8                      	clc				; return success
 15298 000014A3 C3                      	retn
 15299                                  
 15300                                  FindNextInMem:
 15301 000014A4 83C315                  	add	bx,21
 15302                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15303 000014A7 EBEE                    	jmp	short FindOneInMem	; go look at it
 15304                                  foNoMore:
 15305 000014A9 F9                      	stc				; ran out of entries, return failure
 15306 000014AA C3                      	retn
 15307                                  
 15308                                  ; ---------------------------------------------------------------------------
 15309                                  
 15310                                  ;***	GetEnvValue - get value of our environment variable
 15311                                  ;
 15312                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15313                                  ;
 15314                                  ;	EXIT	CY = set if environment variable not in environment
 15315                                  ;
 15316                                  ;		Otherwise:
 15317                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15318                                  ;
 15319                                  ;	USED	AX,BX,CX,DX,DI
 15320                                  ;		(We assume the (almost) worst, since we don't know about
 15321                                  ;		Find_Name_In_Environment.)
 15322                                  ;
 15323                                  ;	EFFECTS
 15324                                  ;
 15325                                  ;	  ScanBuf is loaded with value text
 15326                                  
 15327                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15328                                  GetEnvValue:
 15329 000014AB 06                      	push	es				; save ES
 15330                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15331 000014AC BE[8081]                	mov	si,DirEnvVar
 15332                                  	;invoke	Find_Name_In_Environment
 15333 000014AF E8610E                  	call	find_name_in_environment
 15334 000014B2 7214                    	jc	short geRet			; name not found in environment
 15335                                  
 15336                                  ;	ES:DI = ptr to value of environment variable
 15337                                  ;	We're assuming DS, CS, and SS are unchanged.
 15338                                  
 15339 000014B4 1E                      	push	ds
 15340 000014B5 06                      	push	es
 15341 000014B6 1F                      	pop	ds
 15342 000014B7 07                      	pop	es
 15343                                  
 15344                                  	;assume	ds:nothing
 15345                                  
 15346                                  ;	DS = seg addr of environment variable value (in environment segment)
 15347                                  ;	ES = TRANGROUP seg addr
 15348                                  
 15349 000014B8 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15350                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15351 000014BA BF[EA8C]                	mov	di,ScanBuf
 15352                                  geLoop:
 15353                                  ;@@:	
 15354 000014BD AC                      	lodsb
 15355 000014BE 08C0                    	or	al,al
 15356 000014C0 AA                      	stosb
 15357                                  	;loopnz	@B		; move the string, including trailing null
 15358 000014C1 E0FA                    	loopnz	geLoop
 15359                                  
 15360 000014C3 06                      	push	es
 15361 000014C4 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15362                                  	;assume	ds:TRANGROUP
 15363                                  
 15364                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15365 000014C5 BE[EA8C]                	mov	si,ScanBuf
 15366                                  geRet:
 15367 000014C8 07                      	pop	es				; restore ES
 15368 000014C9 C3                      	retn
 15369                                  
 15370                                  ; ---------------------------------------------------------------------------
 15371                                  
 15372                                  ;***	GetFirst - get first directory entry from disk
 15373                                  ;
 15374                                  ;	ENTRY	DOS DTA established at DirBuf
 15375                                  ;		FCB contains drive # and filename
 15376                                  ;		Current directory (on selected drive) is the one to search
 15377                                  ;		AttrSpecified & AttrSelect masks set
 15378                                  ;
 15379                                  ;	EXIT	CY = clear if success
 15380                                  ;		DirBuf contains extended FCB for file found
 15381                                  ;
 15382                                  ;		If unsuccessful,
 15383                                  ;		CY = set
 15384                                  ;		Ready for DOS Get Extended Error call
 15385                                  ;
 15386                                  ;	USED	AX,DX
 15387                                  ;
 15388                                  ;	EFFECTS
 15389                                  ;
 15390                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15391                                  ;	  FCB-1 = attribute mask to find all files
 15392                                  ;	  These fields should remain unmodified for GetNext calls.
 15393                                  ;
 15394                                  ;***	GetNext - get next directory entry from disk
 15395                                  ;
 15396                                  ;	ENTRY	As for GetFirst, plus
 15397                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15398                                  ;
 15399                                  ;	EXIT	As for GetFirst
 15400                                  ;
 15401                                  ;	USED	AX,DX
 15402                                  
 15403                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15404                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15405                                  GetFirst:
 15406                                  	;mov	byte [55h],0FFh	; -1
 15407 000014CA C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15408                                  	;mov	byte [5Bh],16h
 15409 000014CF C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15410                                  					; find any file
 15411                                  	; 07/06/2023
 15412                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15413 000014D4 B411                    	mov	ah,11h
 15414                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15415                                  	; 07/06/2023
 15416                                  	;int	21h			; call DOS
 15417                                  	;shl	al,1			; CY = set if error
 15418                                  	;jc	short gfRet		; return error
 15419                                  	;jmp	short gfFound		; go look at attr's
 15420                                  	; 07/06/2023
 15421 000014D6 EB02                    	jmp	short GetFrstNxt
 15422                                  GetNext:
 15423                                  	; 07/06/2023
 15424                                  	;;mov	dx,55h
 15425                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15426 000014D8 B412                    	mov	ah,12h
 15427                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15428                                  GetFrstNxt:
 15429                                  	; 07/06/2023
 15430 000014DA BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15431                                  	;
 15432 000014DD CD21                    	int	21h			; call DOS
 15433 000014DF D0E0                    	shl	al,1			; CY = set if error
 15434 000014E1 7211                    	jc	short gfRet		; return error
 15435                                  
 15436                                  ;*	Found an entry. Check attributes.
 15437                                  gfFound:
 15438                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15439                                  	;mov	al,[DIRBUF+19]
 15440 000014E3 A0[BD8B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15441 000014E6 8A26[048C]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15442 000014EA 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15443 000014EC 2226[058C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15444 000014F0 38E0                    	cmp	al,ah
 15445 000014F2 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15446                                  gfRet:
 15447 000014F4 C3                      	retn
 15448                                  
 15449                                  ; ---------------------------------------------------------------------------
 15450                                  
 15451                                  ;***	ListDir - search for and list files in the current directory
 15452                                  ;
 15453                                  ;	List header, files, and trailer for current directory on selected
 15454                                  ;	drive. Header & trailer are listed if at least one file is found.
 15455                                  ;	If no qualifying files are found, no display output occurs.
 15456                                  ;
 15457                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15458                                  ;		FCB contains selected drive # and filename spec
 15459                                  ;		Option bits, attribute masks, and sort codes set up
 15460                                  ;
 15461                                  ;	EXIT	CY = clear if no error
 15462                                  ;		FileCnt = # files found & displayed
 15463                                  ;
 15464                                  ;		If error,
 15465                                  ;		CY = set
 15466                                  ;		Ready for DOS Get Extended Error call
 15467                                  ;
 15468                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15469                                  ;		FileSiz
 15470                                  ;
 15471                                  ;	EFFECTS
 15472                                  ;
 15473                                  ;	  FileCntTotal, FileSizTotal are updated.
 15474                                  ;	  Files found are listed. A directory header and trailer are
 15475                                  ;	   displayed only if files are found.
 15476                                  
 15477                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15478                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15479                                  
 15480                                  ListDir:
 15481 000014F5 31C0                    	xor	ax,ax ; 0
 15482 000014F7 A3[CD8A]                	mov	[FileCnt],ax		; zero file count
 15483 000014FA A3[CF8A]                	mov	[FileSiz],ax		; zero file size accumulator
 15484 000014FD A3[D18A]                	mov	[FileSiz+2],ax
 15485                                  	;cmp	byte [DestBuf],0	; check for sort code
 15486                                  	; 31/07/2024
 15487 00001500 3806[2D8C]              	cmp	[DestBuf],al ; 0
 15488 00001504 740A                    	je	short ld1		; no sort
 15489 00001506 E83000                  	call	LoadEntries		; load entries for sorted listing
 15490 00001509 7305                    	jnc	short ld1		; no error - continue
 15491 0000150B E8E207                  	call	get_ext_error_number	; AX = DOS error code
 15492                                  	; 19/02/2023
 15493                                  	;stc
 15494 0000150E EB12                    	jmp	short ldErr		; return error
 15495                                  ld1:
 15496 00001510 E8E0FE                  	call	FindFirst		; find first file
 15497 00001513 720D                    	jc	short ldErr		; not found, return error
 15498                                  
 15499                                  ;	BX = offset in TPA buffer of entry found
 15500                                  
 15501 00001515 E8E102                  	call	DisplayHeader		; if at least one file, display header
 15502                                  ldNext:
 15503 00001518 E8B902                  	call	DisplayFile		; display the file entry
 15504                                  ;ldNext:
 15505 0000151B E8DAFE                  	call	FindNext		; find another file
 15506 0000151E 7202                    	jc	short ldErr		; not found
 15507                                  	;call	DisplayFile		; display entry
 15508                                  	;jmp	short ldNext		; go find another one
 15509                                  	; 19/02/2023
 15510 00001520 EBF6                    	jmp	short ldNext
 15511                                  ldErr:
 15512                                  	;cmp	ax,2
 15513 00001522 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15514 00001525 7407                    	je	short ldDone		; file not found, we're done
 15515                                  	;cmp	ax,18
 15516 00001527 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15517 0000152A 7402                    	je	short ldDone		; no more files, we're done
 15518 0000152C F9                      	stc
 15519                                  	;jmp	short ldRet
 15520                                  	; 19/02/2023
 15521 0000152D C3                      	retn
 15522                                  ldDone:
 15523 0000152E 833E[CD8A]00            	cmp	word [FileCnt],0
 15524                                  	;je	short ld2		; no files found, just return
 15525                                  	; 25/04/2023
 15526 00001533 7403                    	jz	short ldRet
 15527 00001535 E8CA03                  	call	DisplayTrailer		; display trailing info
 15528                                  	; 08/06/2023
 15529                                  	; cf=0
 15530                                  ;ld2:	
 15531                                  	;clc				; return success
 15532                                  ldRet:
 15533 00001538 C3                      	retn
 15534                                  
 15535                                  ; ---------------------------------------------------------------------------
 15536                                  
 15537                                  ;***	LoadEntries - attempt to load entries from current directory
 15538                                  ;
 15539                                  ;	Load all qualifying directory entries from the current directory
 15540                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15541                                  ;	other than 'no more files', return to caller with carry flag set.
 15542                                  ;	If we run out of buffer space, display a message that we haven't
 15543                                  ;	enough memory to sort this directory, but return without error.
 15544                                  ;	Other routines know whether or not entries have been loaded by
 15545                                  ;	the 'inmem' flag bit, which we set here.
 15546                                  ;
 15547                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15548                                  ;	this allows sorting over 3000 entries in a directory.
 15549                                  ;
 15550                                  ;	ENTRY	Tpa = buffer seg addr
 15551                                  ;		BytCnt = buffer length, in bytes
 15552                                  ;		Current directory (on selected drive) is the one to load
 15553                                  ;		FCB contains drive # and filespec
 15554                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15555                                  ;
 15556                                  ;	EXIT	CY = set if error
 15557                                  ;		If error, DOS Get Extended Error will get error info
 15558                                  ;
 15559                                  ;	USED	AX,CX,DX,SI,DI
 15560                                  ;
 15561                                  ;	EFFECTS
 15562                                  ;
 15563                                  ;	  Inmem bit of Bits = set if load succeeded.
 15564                                  ;	  Tpa buffer contains directory entries.
 15565                                  ;	  Byte after last entry = 0FFh.
 15566                                  
 15567                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15568                                  LoadEntries:
 15569 00001539 06                      	push	es			; save TRANGROUP seg addr
 15570 0000153A 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15571 0000153E 31FF                    	xor	di,di			; ES:DI = destination ptr
 15572                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15573                                  	;;and	word [_Bits],0FFDFh
 15574                                  	;and	byte [_Bits],0DFh	; not 20h
 15575 00001540 8026[FC8B]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15576                                  
 15577 00001545 E882FF                  	call	GetFirst		; look for first file
 15578 00001548 7221                    	jc	short leRet		; return any error
 15579 0000154A E82000                  	call	LoadEntry		; load entry into TPA
 15580                                  leNext:
 15581 0000154D E888FF                  	call	GetNext			; get another file
 15582 00001550 720F                    	jc	short leLoaded		; assume any error is no more files
 15583 00001552 A1[C48A]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15584 00001555 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15585                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15586 00001557 83F817                  	cmp	ax,23 ; 21+2 
 15587 0000155A 720E                    	jb	short leOk		; not enough memory left, give up
 15588 0000155C E80E00                  	call	LoadEntry		; load entry into TPA
 15589 0000155F EBEC                    	jmp	short leNext		; go get another file
 15590                                  
 15591                                  leLoaded:
 15592 00001561 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15593                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15594                                  	;;or	word [_Bits],20h
 15595                                  	;or	byte [_Bits],20h
 15596 00001565 800E[FC8B]20            	or	byte [_Bits],mask.inmem
 15597                                  	; 25/04/2023
 15598                                  	; cf = 0
 15599                                  leOk:
 15600 0000156A F8                      	clc				; return no error
 15601                                  leRet:
 15602 0000156B 07                      	pop	es			; ES = TRANGROUP seg addr again
 15603 0000156C C3                      	retn
 15604                                  
 15605                                  
 15606                                  ; ---------------------------------------------------------------------------
 15607                                  
 15608                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15609                                  ;
 15610                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15611                                  ;		DirBuf contains extended FCB of entry to load
 15612                                  ;
 15613                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15614                                  ;
 15615                                  ;	USED	AX,CX,SI
 15616                                  ;
 15617                                  ;	NOTES
 15618                                  ;
 15619                                  ;	  I could've used symbolic offsets and sizes of fields from
 15620                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15621                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15622                                  ;	   as well as our private directory entry structure.
 15623                                  ;
 15624                                  ;	  We force a zero size for subdirectory files. A zero size is
 15625                                  ;	   ordinarily returned for subdirectories, but with Novell
 15626                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15627                                  
 15628                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15629                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15630                                  LoadEntry:
 15631                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15632 0000156D BE[B28B]                	mov	si,DIRBUF+8
 15633 00001570 30C0                    	xor	al,al				; AL = 0
 15634 00001572 AA                      	stosb					; 'used' byte = false
 15635 00001573 B90B00                  	mov	cx,11
 15636 00001576 F3A4                    	rep	movsb				; transfer filename & extension
 15637 00001578 AC                      	lodsb					; AL = attrib byte
 15638 00001579 AA                      	stosb					; store attrib byte
 15639                                  	;add	si,10 ; 22-11-1
 15640                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15641 0000157A 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15642 0000157D A5                      	movsw					; transfer time
 15643 0000157E A5                      	movsw					; transfer date
 15644 0000157F 46                      	inc	si				; skip alloc unit
 15645 00001580 46                      	inc	si
 15646                                  	;and	al,10h
 15647 00001581 2410                    	and	al,ATTR_DIRECTORY
 15648 00001583 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15649 00001585 A5                      	movsw
 15650 00001586 A5                      	movsw					; transfer size
 15651 00001587 C3                      	retn
 15652                                  leSetDirSize:
 15653 00001588 31C0                    	xor	ax,ax ; 0
 15654 0000158A AB                      	stosw
 15655 0000158B AB                      	stosw					; store zero size
 15656 0000158C C3                      	retn
 15657                                  
 15658                                  ; ---------------------------------------------------------------------------
 15659                                  
 15660                                  ;***	NoOrder - turn sorting off
 15661                                  ;
 15662                                  ;	ENTRY	nothing
 15663                                  ;
 15664                                  ;	EXIT	CY clear
 15665                                  ;
 15666                                  ;	USED	AX
 15667                                  ;
 15668                                  ;	EFFECTS
 15669                                  ;
 15670                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15671                                  
 15672                                  	; 19/02/2023
 15673                                  NoOrder:
 15674 0000158D C606[2D8C]00            	mov	byte [DestBuf],0
 15675                                  				; no sort
 15676 00001592 F8                      	clc			; no error
 15677 00001593 C3                      	retn
 15678                                  
 15679                                  ; ---------------------------------------------------------------------------
 15680                                  
 15681                                  ;***	OnOffSw - record occurence of on/off option switch
 15682                                  ;
 15683                                  ;	ENTRY	DI = index into word list of switches
 15684                                  ;
 15685                                  ;	EXIT	CY clear
 15686                                  ;
 15687                                  ;	USED	AX,CX
 15688                                  ;
 15689                                  ;	EFFECTS
 15690                                  ;
 15691                                  ;	  Bits modified to indicate option state.
 15692                                  
 15693                                  	; 19/02/2023
 15694                                  OnOffSw:
 15695 00001594 89F9                    	mov	cx,di		; CX = index into word list of options
 15696 00001596 D1E9                    	shr	cx,1
 15697 00001598 D1E9                    	shr	cx,1		; CX = bit position of option
 15698 0000159A B80100                  	mov	ax,1		
 15699 0000159D D3E0                    	shl	ax,cl		; AX = bit mask of option
 15700 0000159F F7C70200                	test	di,2		; check if it is a negated option
 15701 000015A3 7405                    	jz	short oo1	; it's negated
 15702                                  	;or	Bits,ax		; turn option on
 15703 000015A5 0906[FC8B]              	or	[_Bits],ax
 15704                                  	;jmp	short ooRet
 15705                                  	; 19/02/2023
 15706                                  	;cf=0
 15707 000015A9 C3                      	retn
 15708                                  oo1:	
 15709 000015AA F7D0                    	not	ax		; AX = complemented bit mask of option
 15710                                  	;and	Bits,ax		; turn option off
 15711 000015AC 2106[FC8B]              	and	[_Bits],ax
 15712                                  ooRet:
 15713                                  	; 19/02/2023
 15714                                  	;cf=0
 15715                                  	;clc			; always return success
 15716 000015B0 C3                      	retn
 15717                                  
 15718                                  ; ---------------------------------------------------------------------------
 15719                                  
 15720                                  ;***	ParseAttr - parse and record /A option
 15721                                  ;
 15722                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15723                                  ;
 15724                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15725                                  ;
 15726                                  ;		For parse error, we set up for Std_EPrintf call:
 15727                                  ;		AX = parse error code, like system parser
 15728                                  ;		DX = ptr to message block
 15729                                  ;
 15730                                  ;	USED	AX,CX,DX,DI
 15731                                  ;
 15732                                  ;	EFFECTS
 15733                                  ;
 15734                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15735                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15736                                  ;
 15737                                  ;	  For parse error, we set up for Std_EPrintf call:
 15738                                  ;	  Msg_Disp_Class = parse error message class
 15739                                  ;	  Message block (see DX) is set up for parse error message
 15740                                  
 15741                                  	; 19/02/2023
 15742                                  ParseAttr:
 15743 000015B1 56                      	push	si			; save SI
 15744 000015B2 C606[048C]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15745                                  
 15746                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15747                                  
 15748                                  	;;mov	si,word ptr [bx].ValuePtr
 15749                                  					; SI = ptr to string after /A
 15750                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15751 000015B7 8B7704                  	mov	si,[bx+4]
 15752                                  paLoop:	
 15753 000015BA BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15754 000015BD AC                      	lodsb				; AL = next char in string
 15755 000015BE 08C0                    	or	al,al
 15756                                  	;jz	short paOk		; it's terminating null, we're done
 15757                                  	; 19/02/2023
 15758 000015C0 742F                    	jz	short paRet ; cf=0
 15759 000015C2 3C2D                    	cmp	al,'-'
 15760 000015C4 7502                    	jne	short pa1		; not '-', go look for letter
 15761 000015C6 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15762 000015C7 AC                      	lodsb				; AL = next char
 15763                                  pa1:	
 15764                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15765                                  					; DI = ptr to attrib letter list
 15766 000015C8 BF[3784]                	mov	di,AttrLtrs ; "RHSvDA"
 15767                                  	;mov	cx,6
 15768 000015CB B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15769 000015CE F2AE                    	repne	scasb			; look for our letter in the list
 15770 000015D0 751B                    	jne	short paErr		; not found, return error
 15771                                  
 15772 000015D2 F7D1                    	not	cx
 15773                                  	;add	cx,6
 15774 000015D4 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15775                                  
 15776                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15777                                  ;	starting from bit 0.
 15778                                  
 15779                                  ;	Record this attribute bit in AttrSpecified.
 15780                                  
 15781 000015D7 B001                    	mov	al,1
 15782 000015D9 D2E0                    	shl	al,cl			; AL = mask for our bit
 15783 000015DB 0806[048C]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15784                                  
 15785                                  ;	Record the selected state for this attribute in AttrSelect.
 15786                                  ;	DX = 0 or 1, the selected state for this attribute.
 15787                                  
 15788 000015DF F6D0                    	not	al			; AL = mask for all other bits
 15789 000015E1 2006[058C]              	and	[AttrSelect],al		; clear our bit
 15790 000015E5 D2E2                    	shl	dl,cl			; DL = our bit state in position
 15791 000015E7 0816[058C]              	or	[AttrSelect],dl		; set selected attr state
 15792 000015EB EBCD                    	jmp	short paLoop		; go look at next char
 15793                                  
 15794                                  ;	The attribute letter string is invalid.
 15795                                  
 15796                                  paErr:	
 15797 000015ED E87103                  	call	SetupParamError		; set message up for Std_EPrintf
 15798 000015F0 F9                      	stc		   		; return error
 15799                                  	; 19/02/2023
 15800                                  	;jmp	short paRet
 15801                                  ;paOk:
 15802                                  	;clc				; return success		
 15803                                  paRet:	
 15804 000015F1 5E                      	pop	si			; restore SI
 15805 000015F2 C3                      	retn
 15806                                  
 15807                                  ; ---------------------------------------------------------------------------
 15808                                  
 15809                                  ;***	ParseLine - parse a line of text
 15810                                  ;
 15811                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15812                                  ;	error occurs.
 15813                                  ;
 15814                                  ;	ENTRY	DS:SI = ptr to text
 15815                                  ;		CS, DS, ES = TRANGROUP seg addr
 15816                                  ;
 15817                                  ;	EXIT	AX = last return code from system parser
 15818                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15819                                  ;
 15820                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15821                                  ;		DX = ptr to message block
 15822                                  ;
 15823                                  ;	USED	BX,CX,DX,SI,DI
 15824                                  ;
 15825                                  ;	EFFECTS
 15826                                  ;
 15827                                  ;	  Bits may contain new option settings.
 15828                                  ;	  DestBuf may contain new series of sort codes.
 15829                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15830                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15831                                  ;	  PathPos, PathCnt updated for new pathname.
 15832                                  ;
 15833                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15834                                  ;	  Msg_Disp_Class = parse error class
 15835                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15836                                  ;	  Message block (see DX) is set up for parse error message
 15837                                  
 15838                                  	; 19/02/2023
 15839                                  Parse_Line:
 15840                                  	; 04/05/2023
 15841 000015F3 BF[0485]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15842 000015F6 31C9                    	xor	cx,cx			; CX = # positionals found
 15843                                  plPars:
 15844 000015F8 E8BC0B                  	call	Parse_With_Msg		; call parser
 15845 000015FB 83F8FF                  	cmp	ax,-1
 15846                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15847 000015FE 7411                    	je	short plRet		; EOL encountered, return
 15848 00001600 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15849 00001603 750C                    	jne	short plRet		; parse error occurred, return
 15850                                  
 15851                                  ;	Parse call succeeded. We have a filespec or a switch.
 15852                                  ;	DX = ptr to result buffer
 15853                                  
 15854 00001605 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15855 00001607 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15856 0000160A 7406                    	je	short plFil		; we have a filespec
 15857                                  
 15858 0000160C E85900                  	call	ParseSwitch		; else we have a switch
 15859                                  	;jc	short plRet		; error parsing switch, return
 15860                                  	;jmp	short plPars		; parse more
 15861                                  	; 19/02/2023
 15862 0000160F 73E7                    	jnc	short plPars
 15863                                  plRet:
 15864 00001611 C3                      	retn	
 15865                                  plFil:	
 15866 00001612 E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15867 00001615 EBE1                    	jmp	short plPars		; parse more
 15868                                  ;plRet:
 15869                                  ;	retn
 15870                                  
 15871                                  ; ---------------------------------------------------------------------------
 15872                                  
 15873                                  ;***	ParseOrder - parse and record /O option
 15874                                  ;
 15875                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15876                                  ;
 15877                                  ;	EXIT	CY = set if error occurs parsing order
 15878                                  ;
 15879                                  ;		For parse error, we set up for Std_EPrintf call:
 15880                                  ;		AX = parse error code, like system parser
 15881                                  ;		DX = ptr to message block
 15882                                  ;
 15883                                  ;	USED	AX,CX,DX,DI
 15884                                  ;
 15885                                  ;	EFFECTS
 15886                                  ;
 15887                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15888                                  ;
 15889                                  ;	  For parse error, we set up for Std_EPrintf call:
 15890                                  ;	  Msg_Disp_Class = parse error message class
 15891                                  ;	  Message block (see DX) is set up for parse error message
 15892                                  
 15893                                  	; 19/02/2023
 15894                                  ParseOrder:
 15895 00001617 56                      	push	si			; save SI
 15896 00001618 53                      	push	bx			; save ptr to result buffer
 15897                                  
 15898                                  	;;mov	si,word ptr [bx].ValuePtr
 15899                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15900 00001619 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15901                                  	;mov	bx,offset TRANGROUP:DestBuf
 15902                                  	; 08/06/2023 (BugFix)
 15903 0000161C BB[2D8C]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 15904 0000161F 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15905 00001621 08C0                    	or	al,al
 15906 00001623 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15907                                  
 15908                                  ;	We have /O alone. Set standard sort order.
 15909                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15910                                  
 15911 00001625 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15912 00001628 43                      	inc	bx
 15913 00001629 C60701                  	mov	byte [bx],1		; then by name
 15914 0000162C 43                      	inc	bx
 15915 0000162D C60702                  	mov	byte [bx],2		; then by extension
 15916 00001630 43                      	inc	bx
 15917 00001631 EB2F                    	jmp	short poOk		; return success
 15918                                  
 15919                                  ;	We have /O<something>. Parse sort order letters.
 15920                                  
 15921                                  poLtr:	
 15922 00001633 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15923 00001635 AC                      	lodsb				; AL = next sort order letter
 15924 00001636 08C0                    	or	al,al
 15925 00001638 7428                    	jz	short poOk		; NUL found, return success
 15926                                  
 15927 0000163A 3C2D                    	cmp	al,'-'
 15928 0000163C 7503                    	jne	short po1		; not '-', go look for letter
 15929 0000163E B280                    	mov	dl,80h			; DL = downward sort mask
 15930 00001640 AC                      	lodsb				; AL = next char
 15931                                  po1:
 15932                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15933                                  	; 08/06/2023 (BugFix)
 15934 00001641 BF[3D84]                	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
 15935 00001644 B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15936 00001647 F2AE                    	repne	scasb			; look for our letter in the list
 15937 00001649 7510                    	jne	short poErr		; not found, return error
 15938                                  
 15939 0000164B F7D9                    	neg	cx
 15940 0000164D 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15941                                  
 15942 00001650 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15943 00001652 880F                    	mov	[bx],cl			; store sort order code in buffer
 15944 00001654 43                      	inc	bx			; BX = ptr to next spot in buffer
 15945                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15946 00001655 81FB[848C]              	cmp	bx,EndDestBuf
 15947                                  	;jae	short poErr		; too many letters
 15948                                  	;
 15949                                  	;jmp	short poLtr		; go look at next char
 15950                                  	; 19/02/2023
 15951 00001659 72D8                    	jb	short poLtr
 15952                                  
 15953                                  ;	The sort order string is invalid.  
 15954                                  
 15955                                  poErr:
 15956 0000165B 5B                      	pop	bx			; BX = ptr to result buffer
 15957 0000165C E80203                  	call	SetupParamError		; set message up for Std_EPrintf
 15958 0000165F F9                      	stc				; return failure
 15959 00001660 EB04                    	jmp	short poRet
 15960                                  poOk:	
 15961 00001662 C60700                  	mov	byte [bx],0		; mark end of sort code list
 15962 00001665 5B                      	pop	bx			; BX = ptr to result buffer
 15963                                  	; 19/02/2023
 15964                                  	;cf=0
 15965                                  	;clc				; return success
 15966                                  poRet:
 15967 00001666 5E                      	pop	si			; restore SI
 15968 00001667 C3                      	retn
 15969                                  
 15970                                  ; ---------------------------------------------------------------------------
 15971                                  
 15972                                  ;***	ParseSwitch - parse a switch
 15973                                  ;
 15974                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15975                                  ;		     a switch
 15976                                  ;
 15977                                  ;	EXIT	CY = set if parse error occurred
 15978                                  ;
 15979                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15980                                  ;		AX = parse error code, like system parser
 15981                                  ;		DX = ptr to message block
 15982                                  ;
 15983                                  ;	USED	AX,BX,DX
 15984                                  ;
 15985                                  ;	EFFECTS
 15986                                  ;
 15987                                  ;	  Bits may contain new option settings.
 15988                                  ;	  DestBuf may contain new series of sort codes.
 15989                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15990                                  ;
 15991                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15992                                  ;	  Msg_Disp_Class = parse error class
 15993                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15994                                  ;	  Message block (see DX) is set up for parse error message
 15995                                  
 15996                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15997                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 15998                                  ParseSwitch:
 15999 00001668 51                      	push	cx			; save CX
 16000 00001669 57                      	push	di			; save DI
 16001                                  
 16002                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 16003                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 16004 0000166A 8B4702                  	mov	ax,[bx+2]
 16005                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16006 0000166D BF[5485]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16007 00001670 B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16008 00001673 FC                      	cld				; scan direction = upward
 16009 00001674 F2AF                    	repne	scasw			; locate synonym ptr in list
 16010                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16011 00001676 81EF[5685]              	sub	di,Dir_Sw_Ptrs+2
 16012                                  
 16013                                  ;	DI = index into word list of synonym ptrs
 16014                                  
 16015 0000167A 2EFF95[8216]            	call	word [cs:di+SwHandler]	; use same index into call table
 16016                                  
 16017 0000167F 5F                      	pop	di			; restore DI
 16018 00001680 59                      	pop	cx			; restore CX
 16019                                  
 16020 00001681 C3                      	retn
 16021                                  
 16022                                  ; ---------------------------------------------------------------------------
 16023                                  
 16024                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16025                                  ;	Simple on/off switches must occur first in both lists, and must be
 16026                                  ;	  in order of option bits in Bits, starting with bit 0.
 16027                                  
 16028                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16029                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16030                                  
 16031                                  SwHandler:
 16032 00001682 [9415]                  	dw	OnOffSw		; /-W
 16033 00001684 [9415]                  	dw	OnOffSw		; /W
 16034 00001686 [9415]                  	dw	OnOffSw		; /-P
 16035 00001688 [9415]                  	dw	OnOffSw		; /P
 16036 0000168A [9415]                  	dw	OnOffSw		; /-S
 16037 0000168C [9415]                  	dw	OnOffSw		; /S
 16038 0000168E [9415]                  	dw	OnOffSw		; /-B
 16039 00001690 [9415]                  	dw	OnOffSw		; /B
 16040 00001692 [9415]                  	dw	OnOffSw		; /-L	;M010
 16041 00001694 [9415]                  	dw	OnOffSw		; /L	;M010
 16042 00001696 [8D15]                  	dw	NoOrder		; /-O
 16043 00001698 [1716]                  	dw	ParseOrder	; /O
 16044 0000169A [6C13]                  	dw	DefaultAttr	; /-A
 16045 0000169C [B115]                  	dw	ParseAttr	; /A
 16046                                  
 16047                                  ; ---------------------------------------------------------------------------
 16048                                  
 16049                                  	;break	<DIR utility routines>
 16050                                  
 16051                                  ;***	UTILITY ROUTINES
 16052                                  ; ---------------------- 
 16053                                  
 16054                                  ; ---------------------------------------------------------------------------
 16055                                  
 16056                                  ;***	ChangeDir - change directory on target drive
 16057                                  ;
 16058                                  ;	ENTRY	FCB contains drive #
 16059                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16060                                  ;
 16061                                  ;	EXIT	Changed current directory on drive
 16062                                  ;
 16063                                  ;		If error,
 16064                                  ;		CY = set
 16065                                  ;		DOS Get Extended Error call will get error
 16066                                  ;
 16067                                  ;	USED	AX,DX,SI,DI
 16068                                  ;
 16069                                  ;	EFFECTS
 16070                                  ;
 16071                                  ;	  DirBuf is used to build "d:string".
 16072                                  
 16073                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16074                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16075                                  
 16076                                  ChangeDir:
 16077                                  	;mov	di,offset TRANGROUP:DirBuf
 16078 0000169E BF[AA8B]                	mov	di,DIRBUF
 16079 000016A1 E8AC02                  	call	GetDriveLtr	; AX = "d:"
 16080 000016A4 AB                      	stosw			; put drive specifier in buffer
 16081 000016A5 89D6                    	mov	si,dx		; SI = ptr to argument string
 16082                                  cdLoop:
 16083 000016A7 AC                      	lodsb
 16084 000016A8 AA                      	stosb			; move byte to buffer
 16085 000016A9 08C0                    	or	al,al
 16086 000016AB 75FA                    	jne	short cdLoop	; continue until null transferred
 16087                                  
 16088                                  	;mov	dx,offset TRANGROUP:DirBuf
 16089 000016AD BA[AA8B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16090                                  	;mov	ah,CHDir
 16091 000016B0 B43B                    	mov	ah,3Bh
 16092 000016B2 CD21                    	int	21h		; change directory
 16093 000016B4 C3                      	retn			; return what CHDIR returns
 16094                                  
 16095                                  ; ---------------------------------------------------------------------------
 16096                                  
 16097                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16098                                  ;
 16099                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16100                                  ;		ES:DI = ptr to another ASCIIZ string
 16101                                  ;
 16102                                  ;	EXIT	flags set after REPE CMPSB
 16103                                  ;
 16104                                  ;	USED	AL,CX,SI,DI
 16105                                  ;
 16106                                  ;	NOTES
 16107                                  ;
 16108                                  ;	Maximum run of comparison is length of DS:SI string.
 16109                                  ;	This ensures that two identical strings followed by
 16110                                  ;	random characters will compare correctly.
 16111                                  
 16112                                  	; 19/02/2023
 16113                                  CmpAscz:
 16114                                  	; 07/06/2023
 16115 000016B5 56                      	push	si ; *
 16116                                  	;
 16117 000016B6 57                      	push	di
 16118                                  
 16119 000016B7 89F7                    	mov	di,si
 16120 000016B9 30C0                    	xor	al,al
 16121 000016BB B9FFFF                  	mov	cx,0FFFFh
 16122 000016BE F2AE                    	repne	scasb
 16123 000016C0 F7D1                    	not	cx
 16124                                  
 16125 000016C2 5F                      	pop	di
 16126 000016C3 F3A6                    	repe	cmpsb
 16127                                  
 16128                                  	; 07/06/2023
 16129 000016C5 5E                      	pop	si ; *
 16130                                  	;
 16131 000016C6 C3                      	retn
 16132                                  
 16133                                  ; ---------------------------------------------------------------------------
 16134                                  
 16135                                  ;***	CopyPathname - copy pathname to our buffer
 16136                                  ;
 16137                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16138                                  ;		     a filespec
 16139                                  ;
 16140                                  ;	EXIT	nothing
 16141                                  ;
 16142                                  ;	USED	AX
 16143                                  ;
 16144                                  ;	EFFECTS
 16145                                  ;
 16146                                  ;	  SrcBuf may contain a new pathname/filespec.
 16147                                  ;	  PathPos, PathCnt updated for new pathname.
 16148                                  
 16149                                  	; 19/02/2023
 16150                                  CopyPathname:
 16151 000016C7 56                      	push	si
 16152                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16153                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16154 000016C8 C57704                  	lds	si,[bx+4]
 16155                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16156 000016CB E8D515                  	call	Move_To_SrcBuf
 16157 000016CE 5E                      	pop	si
 16158 000016CF C3                      	retn
 16159                                  
 16160                                  ; ---------------------------------------------------------------------------
 16161                                  
 16162                                  ;***	CountFile - update counters with current file
 16163                                  ;
 16164                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16165                                  ;
 16166                                  ;	EXIT	nothing
 16167                                  ;
 16168                                  ;	USED	AX,DX
 16169                                  ;
 16170                                  ;	EFFECTS
 16171                                  ;
 16172                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16173                                  
 16174                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16175                                  CountFile:
 16176 000016D0 06                      	push	es			; save TRANGROUP seg addr
 16177 000016D1 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16178                                  
 16179 000016D5 FF06[CD8A]              	inc	word [FileCnt]		; # files this directory
 16180 000016D9 FF06[D38A]              	inc	word [FileCntTotal]	; # files total
 16181 000016DD 7504                    	jnz	short cntf1
 16182 000016DF FF06[D58A]              	inc	word [FileCntTotal+2]
 16183                                  cntf1:
 16184                                  	;mov	ax,word ptr es:[bx].filesize
 16185                                  					; AX = low word of file size
 16186                                  	;mov	dx,word ptr es:[bx].filesize+2
 16187                                  					; DX = high word of file size
 16188 000016E3 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16189 000016E7 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16190 000016EB 0106[CF8A]              	add	[FileSiz],ax
 16191 000016EF 1116[D18A]              	adc	[FileSiz+2],dx		; size of this directory
 16192 000016F3 0106[D78A]              	add	[FileSizTotal],ax
 16193 000016F7 1116[D98A]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16194                                  
 16195 000016FB 07                      	pop	es			; ES = TRANGROUP seg addr again
 16196                                  dbRet:	; 19/02/2023
 16197 000016FC C3                      	retn
 16198                                  
 16199                                  ; ---------------------------------------------------------------------------
 16200                                  
 16201                                  ;***	DisplayBare - display filename in bare format
 16202                                  ;
 16203                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16204                                  ;
 16205                                  ;	EXIT	DX = # char's displayed, including dot
 16206                                  ;
 16207                                  ;	USED	AX,CX,SI,DI
 16208                                  ;
 16209                                  ;	EFFECTS
 16210                                  ;
 16211                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16212                                  ;	  If /s is on, complete pathname is displayed.
 16213                                  ;
 16214                                  ;	NOTE
 16215                                  ;
 16216                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16217                                  
 16218                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16219                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16220                                  
 16221                                  DisplayBare:
 16222                                  ;	Suppress . and .. files from bare listing.
 16223                                  
 16224 000016FD 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16225 000016FF 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16226                                  	;assume	ds:NOTHING
 16227                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16228 00001703 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16229 00001707 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16230                                  	;assume	ds:TRANGROUP
 16231 00001709 74F1                    	je	short dbRet		; it's . or .. - don't display
 16232                                  
 16233                                  	;;;test	Bits,mask subd
 16234                                  	;;test	word [_Bits],4
 16235                                  	;test	byte [_Bits],4
 16236 0000170B F606[FC8B]04            	test	byte [_Bits],mask.subd
 16237 00001710 7431                    	jz	short dbNameExt		; not /s - display filename only
 16238                                  
 16239                                  	;invoke	Build_Dir_String
 16240 00001712 E83507                  	call	build_dir_string
 16241                                  	;mov	di,offset TRANGROUP:BwdBuf
 16242 00001715 BF[AA8B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16243                                     
 16244                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16245                                  	;;test	word [_Bits],10h
 16246                                  	;test	byte [_Bits],10h
 16247 00001718 F606[FC8B]10            	test	byte [_Bits],mask.lcase
 16248                                  	;jz	@F			;M010;lowercase not needed
 16249 0000171D 7405                    	jz	short dbare1
 16250 0000171F 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16251 00001721 E87E02                  	call	LowercaseString		;M010;path string is in BwdBuf
 16252                                  dbare1:
 16253                                  ;@@:	
 16254                                  	;xor	al,al			; AL = 0
 16255                                  	; 19/02/2023
 16256 00001724 31C0                    	xor	ax,ax
 16257 00001726 B9FFFF                  	mov	cx,0FFFFh
 16258 00001729 FC                      	cld
 16259 0000172A F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16260 0000172C 4F                      	dec	di			; ES:DI = ptr to null byte
 16261                                  
 16262 0000172D 26807DFF5C              	cmp	byte [es:di-1],'\'
 16263                                  	;je	@F
 16264 00001732 7403                    	je	short dbare2		; already terminated w/ '\'
 16265                                  
 16266                                  	;mov	ax,'\'			; AX = '\',0
 16267 00001734 B05C                    	mov	al,'\'
 16268 00001736 AB                      	stosw				; add to dir string
 16269                                  ;@@:
 16270                                  dbare2:
 16271                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16272 00001737 C706[118C][AA8B]        	mov	word [string_ptr_2],BWDBUF
 16273                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16274 0000173D BA[C380]                	mov	dx,string_buf_ptr
 16275                                  	;invoke	Std_Printf		; display device & directory path
 16276 00001740 E88E36                  	call	std_printf
 16277                                  dbNameExt:
 16278 00001743 E82D00                  	call	DisplayDotForm		; display name.ext
 16279                                  	;invoke	CrLf2			; display cr/lf
 16280 00001746 E8860E                  	call	CRLF2
 16281                                  	; 19/02/2023
 16282                                  	;call	UseLine			;M007;Allow /p with /b
 16283                                  ;dbRet:
 16284                                  	;retn
 16285                                  
 16286                                  	; 19/02/2023
 16287                                  	;jmp	short UseLine
 16288                                  
 16289                                  ; ---------------------------------------------------------------------------
 16290                                  
 16291                                  ;***	UseLine - use a display line, start a new page if none left
 16292                                  ;
 16293                                  ;	ENTRY	nothing
 16294                                  ;
 16295                                  ;	EXIT	nothing
 16296                                  ;
 16297                                  ;	USED	flags
 16298                                  
 16299                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16300                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16301                                  UseLine:
 16302 00001749 FF0E[CB8A]              	dec	word [LeftOnPage]
 16303 0000174D 833E[CB8A]02            	cmp	word [LeftOnPage],2
 16304 00001752 771E                    	ja	short ulRet
 16305                                  	; 19/02/2023
 16306                                  	;call	EndPage
 16307                                  ;ulRet:
 16308                                  	;retn
 16309                                  
 16310                                  	; 19/02/2023
 16311                                  	;jmp	short EndPage
 16312                                  
 16313                                  ; ---------------------------------------------------------------------------
 16314                                  
 16315                                  ;***	EndPage - end the current display page
 16316                                  ;
 16317                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16318                                  ;		Current directory (on selected drive) is the one being listed
 16319                                  ;		Bits contains /p setting
 16320                                  ;
 16321                                  ;	EXIT	LeftOnPage = # lines left for next page
 16322                                  ;
 16323                                  ;	USED	AX,DX
 16324                                  ;
 16325                                  ;	EFFECTS
 16326                                  ;
 16327                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16328                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16329                                  
 16330                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16331                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16332                                  
 16333                                  EndPage:
 16334                                  	;;;test	Bits,mask pagd
 16335                                  	;;test	word [_Bits],2
 16336                                  	;test	byte [_Bits],2
 16337 00001754 F606[FC8B]02            	test	byte [_Bits],mask.pagd
 16338 00001759 7410                    	jz	short epNew		; paged display isn't enabled
 16339                                  
 16340 0000175B 53                      	push	bx			; save BX
 16341 0000175C 51                      	push	cx			; save CX
 16342                                  
 16343                                  	;invoke	Pause			; "Press any key to continue..."
 16344 0000175D E85302                  	call	PAUSE
 16345                                  
 16346                                  	;invoke	Build_Dir_String
 16347 00001760 E8E706                  	call	build_dir_string
 16348                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16349 00001763 BA[3E81]                	mov	dx,dircont_ptr
 16350                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16351 00001766 E85A36                  	call	Printf_Crlf
 16352                                  
 16353 00001769 59                      	pop	cx			; restore CX
 16354 0000176A 5B                      	pop	bx			; restore BX
 16355                                  epNew:	
 16356 0000176B A1[778D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16357 0000176E 48                      	dec	ax			; AX = # lines till next EndPage
 16358 0000176F A3[CB8A]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16359                                  ulRet:	
 16360                                  	; 19/02/2023
 16361 00001772 C3                      	retn
 16362                                  
 16363                                  ; ---------------------------------------------------------------------------
 16364                                  
 16365                                  ;***	DisplayDotForm - display filename in compressed dot format
 16366                                  ;
 16367                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16368                                  ;	if the filename has a nonblank extension.
 16369                                  ;
 16370                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16371                                  ;
 16372                                  ;	EXIT	DX = # char's displayed, including dot
 16373                                  ;
 16374                                  ;	USED	AX,CX,SI,DI
 16375                                  ;
 16376                                  ;	EFFECTS
 16377                                  ;
 16378                                  ;	  Filename is displayed in name.ext format.
 16379                                  ;
 16380                                  ;	NOTE
 16381                                  ;
 16382                                  ;	  We allow for bogus filenames that have blanks embedded
 16383                                  ;	  in the name or extension.
 16384                                  
 16385                                  ;	Bugbug:	might be a good performance gain if we buffered
 16386                                  ;	up the output and used DOS function 9.
 16387                                  
 16388                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16389                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16390                                  
 16391                                  DisplayDotForm:
 16392 00001773 1E                      	push	ds			; save TRANGROUP seg addr
 16393 00001774 06                      	push	es			; save ES
 16394 00001775 2EA1[A78A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16395 00001779 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16396                                  	;assume	ds:nothing
 16397 0000177B 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16398                                  
 16399                                  	; 08/06/2023
 16400                                  	;mov	di,bx			; ES:DI = ptr to entry
 16401                                  	;;;add	di,filename + size filename - 1
 16402                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16403                                  	;;mov	cx,size filename	; CX = length of name field
 16404                                  	;mov	cx,8
 16405                                  	; 08/06/2023
 16406 0000177D B90800                  	mov	cx,8
 16407 00001780 89CF                    	mov	di,cx
 16408 00001782 01DF                    	add	di,bx
 16409                                  	
 16410 00001784 B020                    	mov	al,' '
 16411 00001786 FD                      	std				; scan down
 16412 00001787 F3AE                    	repe	scasb			; scan for nonblank
 16413                                  
 16414                                  ;	Assume file name has at least one character.
 16415                                  
 16416 00001789 41                      	inc	cx			; CX = # chars in name
 16417 0000178A 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16418                                  
 16419 0000178C 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16420                                  	;;add	si,filename		; DS:SI = ptr to name
 16421                                  	;add	si,1 
 16422                                  	;		; add si,EntryStruc.filename
 16423                                  	; 25/04/2023
 16424 0000178E 46                      	inc	si
 16425                                  NextNameChar:
 16426 0000178F FC                      	cld
 16427 00001790 AC                      	lodsb				; AL = next char
 16428                                  
 16429                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16430                                  	;;test	word [ss:_Bits],10h
 16431                                  	;test	byte [ss:_Bits],10h
 16432 00001791 36F606[FC8B]10          	test	byte [ss:_Bits],mask.lcase
 16433                                  	;jz	short @F		;M010;lowercase not required
 16434 00001797 7403                    	jz	short ddf1
 16435 00001799 E8FB01                  	call	LowerCase		;M010;filename char is in AL
 16436                                  ddf1:
 16437                                  ;@@:	
 16438                                  	;invoke	Print_Char		; display it
 16439 0000179C E85C06                  	call	PRINT_CHAR
 16440 0000179F E2EE                    	loop	NextNameChar
 16441                                  
 16442                                  ;	Now do extension.
 16443                                  
 16444 000017A1 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16445                                  	;add	di,fileext + size fileext - 1
 16446 000017A3 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16447                                  	;mov	cx,size fileext		; CX = length of ext field
 16448 000017A6 B90300                  	mov	cx,3
 16449 000017A9 B020                    	mov	al,' '
 16450 000017AB FD                      	std				; scan down
 16451 000017AC F3AE                    	repe	scasb			; scan for nonblank
 16452 000017AE 7420                    	je	short ddDone		; no nonblank chars in ext
 16453                                  
 16454 000017B0 41                      	inc	cx			; CX = # chars in ext
 16455 000017B1 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16456 000017B3 42                      	inc	dx			;      including dot
 16457                                  
 16458 000017B4 B02E                    	mov	al,'.'
 16459 000017B6 E84206                  	call	PRINT_CHAR
 16460 000017B9 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16461                                  	;add	si,fileext		; DS:SI = ptr to ext
 16462 000017BB 83C609                  	add	si,9
 16463                                  
 16464                                  NextExtChar:
 16465 000017BE FC                      	cld
 16466 000017BF AC                      	lodsb				; AL = next char
 16467                                  
 16468                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16469                                  	;;test	word [cs:_Bits],10h
 16470                                  	;test	byte [cs:_Bits],10h
 16471 000017C0 2EF606[FC8B]10          	test	byte [cs:_Bits],mask.lcase
 16472                                  	;jz	short @F		;M010;lowercase not required
 16473 000017C6 7403                    	jz	short ddf2
 16474 000017C8 E8CC01                  	call	LowerCase		;M010;fileext char is in AL
 16475                                  ;@@:	
 16476                                  ddf2:
 16477                                  	;invoke	Print_Char		; display it
 16478 000017CB E82D06                  	call	PRINT_CHAR
 16479 000017CE E2EE                    	loop	NextExtChar
 16480                                  ddDone:
 16481 000017D0 07                      	pop	es			; restore ES
 16482 000017D1 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16483                                  	;assume	ds:TRANGROUP
 16484 000017D2 FC                      	cld				; leave direction flag = up
 16485 000017D3 C3                      	retn
 16486                                  
 16487                                  ; ---------------------------------------------------------------------------
 16488                                  
 16489                                  ;***	DisplayFile - display file entry, update counters
 16490                                  ;
 16491                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16492                                  ;		Bits contains /w, /p settings
 16493                                  ;
 16494                                  ;	EXIT	nothing
 16495                                  ;
 16496                                  ;	USED	AX,CX,DX,SI,DI,BP
 16497                                  ;
 16498                                  ;	EFFECTS
 16499                                  ;
 16500                                  ;	  Entry is displayed.
 16501                                  ;	  If not /b,
 16502                                  ;	    Cursor is left at end of entry on screen.
 16503                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16504                                  ;	  If /b,
 16505                                  ;	    Cursor is left at beginning of next line.
 16506                                  ;	    Cnt's and Siz's aren't updated.
 16507                                  
 16508                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16509                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16510                                  
 16511                                  DisplayFile:
 16512                                  	;;;test	Bits,mask bare
 16513                                  	;;test	word [_Bits],8
 16514                                  	;test	byte [_Bits],8
 16515 000017D4 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16516 000017D9 7405                    	jz	short dfNorm		; not /b - do normal display
 16517                                  
 16518 000017DB E81FFF                  	call	DisplayBare		; display file in bare format
 16519 000017DE EB18                    	jmp	short dfRet
 16520                                  dfNorm:	
 16521 000017E0 E87800                  	call	DisplayNext		; pos'n cursor for next entry
 16522                                  	;;;test	Bits,mask wide
 16523                                  	;;test	word [_Bits],1
 16524                                  	;test	byte [_Bits],1
 16525 000017E3 F606[FC8B]01            	test	byte [_Bits],mask.wide
 16526 000017E8 7405                    	jz	short dfFull		; full format
 16527 000017EA E83701                  	call	DisplayWide		; wide format
 16528 000017ED EB06                    	jmp	short dfCnt
 16529                                  dfFull:	
 16530 000017EF E83400                  	call	DisplayName		; display filename & extension
 16531 000017F2 E88D00                  	call	DisplayTheRest		; display size, date, time
 16532                                  dfCnt:
 16533 000017F5 E8D8FE                  	call	CountFile		; update file counters
 16534                                  dfRet:
 16535                                  dhRet:	; 19/02/2023
 16536 000017F8 C3                      	retn
 16537                                  
 16538                                  ; ---------------------------------------------------------------------------
 16539                                  
 16540                                  ;***	DisplayHeader - display directory header of working directory
 16541                                  ;
 16542                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16543                                  ;		LeftOnPage = # lines left on display page
 16544                                  ;
 16545                                  ;	EXIT	nothing
 16546                                  ;
 16547                                  ;	ERROR EXIT
 16548                                  ;
 16549                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16550                                  ;	   specification" if there's a problem obtaining the current
 16551                                  ;	   directory pathname.
 16552                                  ;
 16553                                  ;	USED	AX,DX,SI,DI
 16554                                  ;
 16555                                  ;	EFFECTS
 16556                                  ;
 16557                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16558                                  ;	   we are using for the DTA) contains the directory string.
 16559                                  ;	  LeftOnPage is adjusted.
 16560                                  
 16561                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16562                                  
 16563                                  DisplayHeader:
 16564                                  	;;;test	Bits,mask bare
 16565                                  	;;test	word [_Bits],8
 16566                                  	;test	byte [_Bits],8
 16567 000017F9 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16568 000017FE 75F8                    	jnz	short dhRet		; /b - don't display header
 16569                                  
 16570                                  	;;;test	Bits,mask subd
 16571                                  	;;test	word [_Bits],4
 16572                                  	;test	byte [_Bits],4
 16573 00001800 F606[FC8B]04            	test	byte [_Bits],mask.subd
 16574 00001805 7408                    	jz	short dhNorm		; not /s
 16575                                  
 16576                                  ;	For subdirectory listings, put a blank line before the header.
 16577                                  
 16578                                  	;invoke	Crlf2			; start with a blank line
 16579 00001807 E8C50D                  	call	CRLF2
 16580 0000180A E83CFF                  	call	UseLine
 16581 0000180D EB05                    	jmp	short dhCom
 16582                                  dhNorm:
 16583 0000180F B020                    	mov	al,' ' ; 20h
 16584                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16585 00001811 E8E705                  	call	PRINT_CHAR		; print a leading blank
 16586                                  dhCom:
 16587 00001814 E83306                  	call	build_dir_string
 16588 00001817 BA[4380]                	mov	dx,dirhead_ptr
 16589 0000181A E8B435                  	call	std_printf		; print header & cr/lf
 16590 0000181D E829FF                  	call	UseLine
 16591 00001820 E8AC0D                  	call	CRLF2			; another cr/lf
 16592                                  	;call	UseLine
 16593                                  ;dhRet:
 16594                                  	;retn
 16595                                  
 16596                                  	; 19/02/2023
 16597 00001823 E923FF                  	jmp	UseLine
 16598                                  
 16599                                  ; ---------------------------------------------------------------------------
 16600                                  
 16601                                  ;***	DisplayName - display file name & extension
 16602                                  ;
 16603                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16604                                  ;
 16605                                  ;	EXIT	nothing
 16606                                  ;
 16607                                  ;	USED	AX,CX,DX,SI,DI
 16608                                  ;
 16609                                  ;	EFFECTS
 16610                                  ;
 16611                                  ;	  Filename & extension are displayed in spread format.
 16612                                  ;	  Cursor is left at end of extension.
 16613                                  
 16614                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16615                                  	; 08/06/2023
 16616                                  DisplayName:
 16617 00001826 1E                      	push	ds			; save TRANGROUP seg addr
 16618 00001827 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16619                                  	;assume	ds:nothing
 16620 0000182B 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16621                                  	;add	si,filename		; DS:SI = ptr to filename
 16622                                  	;add	si,1  ; EntryStruc.filename
 16623                                  	; 08/06/2023
 16624 0000182D 46                      	inc	si
 16625 0000182E BF[DB8A]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16626                                  
 16627 00001831 B90800                  	mov	cx,8
 16628 00001834 FC                      	cld
 16629 00001835 F3A4                    	rep	movsb			; move filename to CharBuf
 16630 00001837 B020                    	mov	al,' '
 16631 00001839 AA                      	stosb				; add a blank
 16632                                  	;mov	cx,3
 16633                                  	; 08/06/2023
 16634 0000183A B103                    	mov	cl,3
 16635 0000183C F3A4                    	rep	movsb			; add extension
 16636 0000183E 30C0                    	xor	al,al
 16637 00001840 AA                      	stosb				; add a NULL
 16638                                  
 16639 00001841 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16640                                  	;assume	ds:TRANGROUP
 16641                                  
 16642                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16643                                  	;;test	word [_Bits],10h
 16644                                  	;test	byte [_Bits],10h
 16645 00001842 F606[FC8B]10            	test	byte [_Bits],mask.lcase
 16646 00001847 7406                    	jz	short dn1		;M010;lowercase not required
 16647 00001849 BE[DB8A]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16648 0000184C E85301                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16649                                  dn1:	
 16650 0000184F C706[118C][DB8A]        	mov	word [string_ptr_2],CHARBUF
 16651 00001855 BA[C380]                	mov	dx,string_buf_ptr
 16652                                  	;call	std_printf		; print filename & extension
 16653                                  	;retn
 16654                                  	; 19/02/2023
 16655 00001858 E97635                  	jmp	std_printf
 16656                                  
 16657                                  ; ---------------------------------------------------------------------------
 16658                                  
 16659                                  ;***	DisplayNext - move display cursor to next entry position
 16660                                  ;
 16661                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16662                                  ;		LeftOnPage = # lines can still be printed for this page
 16663                                  ;		FileCnt = # files in this dir displayed before this one
 16664                                  ;		Bits contains /w setting
 16665                                  ;
 16666                                  ;	EXIT	nothing
 16667                                  ;
 16668                                  ;	USED	AX,DX
 16669                                  ;
 16670                                  ;	EFFECTS
 16671                                  ;
 16672                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16673                                  ;	   displayed.
 16674                                  ;	  LeftOnPage may be updated.
 16675                                  
 16676                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16677                                  
 16678                                  DisplayNext:
 16679 0000185B 833E[CD8A]00            	cmp	word [FileCnt],0
 16680 00001860 7415                    	je	short dn1st		; 1st file in directory
 16681 00001862 803E[C98A]00            	cmp	byte [LeftOnLine],0
 16682 00001867 7E08                    	jng	short dnEol		; no more room on this line
 16683                                  
 16684                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16685                                  ;	we still have room for more on this line.
 16686                                  ;	Tab to next position.
 16687                                  
 16688 00001869 BA[D280]                	mov	dx,tab_ptr
 16689 0000186C E86235                  	call	std_printf
 16690 0000186F EB0C                    	jmp	short dnDone
 16691                                  dnEol:	
 16692                                  ;	Start this entry on a new line.
 16693                                  
 16694 00001871 E85B0D                  	call	CRLF2		; start on new line
 16695 00001874 E8D2FE                  	call	UseLine
 16696                                  dn1st:
 16697 00001877 A0[CA8A]                	mov	al,[PerLine]
 16698 0000187A A2[C98A]                	mov	[LeftOnLine],al	; reset # entries left on line
 16699                                  
 16700                                  dnDone:
 16701 0000187D FE0E[C98A]              	dec	byte [LeftOnLine]
 16702                                  				; reflect the entry about to be displayed
 16703 00001881 C3                      	retn
 16704                                  
 16705                                  ; ---------------------------------------------------------------------------
 16706                                  
 16707                                  ;***	DisplayTheRest - display file size/dir, date, time
 16708                                  ;
 16709                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16710                                  ;		Display cursor is at end of file extension
 16711                                  ;
 16712                                  ;	EXIT	nothing
 16713                                  ;
 16714                                  ;	USED	AX,CX,DX,SI,DI,BP
 16715                                  ;
 16716                                  ;	EFFECTS
 16717                                  ;
 16718                                  ;	  File size, date, & time are displayed.
 16719                                  
 16720                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16721                                  DisplayTheRest:
 16722 00001882 06                      	push	es			; save TRANGROUP seg addr
 16723 00001883 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16724 00001887 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16725                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16726                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16727 00001889 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16728 0000188E 7408                    	jz	short drNonDir		; not a directory file
 16729                                  
 16730                                  ;	For a directory file, display <DIR> instead of size.
 16731                                  
 16732 00001890 BA[D580]                	mov	dx,dmes_ptr
 16733 00001893 E83B35                  	call	std_printf
 16734 00001896 EB16                    	jmp	short drCom		; skip to common fields
 16735                                  
 16736                                  drNonDir:
 16737                                  ;	For a non-directory file, display file size.
 16738                                  
 16739                                  	;;mov	dx,word ptr es:[bp].filesize
 16740                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16741 00001898 268B5611                	mov	dx,[es:bp+17]
 16742 0000189C 8916[0D8C]              	mov	[File_Size_Low],dx
 16743                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16744                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16745 000018A0 268B5613                	mov	dx,[es:bp+19]
 16746 000018A4 8916[0F8C]              	mov	[File_Size_High],dx
 16747 000018A8 BA[B580]                	mov	dx,disp_file_size_ptr
 16748 000018AB E82335                  	call	std_printf
 16749                                  drCom:
 16750                                  ;	For all files, display date & time.
 16751                                  
 16752                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16753                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16754 000018AE 268B460F                	mov	ax,[es:bp+15]
 16755 000018B2 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16756 000018B4 7448                    	jz	short drDone		; no date, skip date/time display
 16757 000018B6 89C3                    	mov	bx,ax			; BX = date word
 16758 000018B8 83E01F                  	and	ax,1Fh			; AX = day of month
 16759 000018BB 88C2                    	mov	dl,al			; DL = day of month
 16760 000018BD 89D8                    	mov	ax,bx			; AX = date word
 16761 000018BF B105                    	mov	cl,5
 16762 000018C1 D3E8                    	shr	ax,cl			; shift day out
 16763 000018C3 240F                    	and	al,0Fh			; AL = month
 16764 000018C5 88C6                    	mov	dh,al			; DH = month
 16765 000018C7 88F9                    	mov	cl,bh
 16766 000018C9 D0E9                    	shr	cl,1			; CL = year - 1980
 16767 000018CB 30ED                    	xor	ch,ch			; CX = year - 1980
 16768 000018CD 83C150                  	add	cx,80			; CX = 2-digit year
 16769 000018D0 80F964                  	cmp	cl,100
 16770 000018D3 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16771 000018D5 80E964                  	sub	cl,100			; adjust for 21st century
 16772                                  dr_1:	
 16773 000018D8 86F2                    	xchg	dh,dl			; DX = month/day
 16774 000018DA 890E[1381]              	mov	[DirDat_Yr],cx		; move year to msg block
 16775 000018DE 8916[1581]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16776                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16777                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16778 000018E2 268B4E0D                	mov	cx,[es:bp+13]
 16779 000018E6 E310                    	jcxz	drPrint			; no time field - go print
 16780 000018E8 D1E9                    	shr	cx,1
 16781 000018EA D1E9                    	shr	cx,1
 16782 000018EC D1E9                    	shr	cx,1			; CH = hours
 16783 000018EE D0E9                    	shr	cl,1
 16784 000018F0 D0E9                    	shr	cl,1			; CL = minutes
 16785 000018F2 86E9                    	xchg	ch,cl			; CX = hr/min
 16786 000018F4 890E[1E81]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16787                                  drPrint:
 16788 000018F8 BA[0E81]                	mov	dx,dirdattim_ptr
 16789 000018FB E8D334                  	call	std_printf		; print date & time
 16790                                  drDone:
 16791 000018FE 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16792 000018FF 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16793                                  dtrRet:
 16794                                  	; 19/02/2023
 16795 00001901 C3                      	retn
 16796                                  
 16797                                  ; ---------------------------------------------------------------------------
 16798                                  
 16799                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16800                                  ;
 16801                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16802                                  ;		FileCnt = # files listed
 16803                                  ;		FileSiz = total size of files listed
 16804                                  ;
 16805                                  ;	EXIT	nothing
 16806                                  ;
 16807                                  ;	USED
 16808                                  ;
 16809                                  ;	EFFECTS
 16810                                  ;
 16811                                  ;	  Trailing info lines are displayed
 16812                                  
 16813                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16814                                  
 16815                                  DisplayTrailer:
 16816                                  	;;;test	Bits,mask bare
 16817                                  	;;test	word [_Bits],8
 16818                                  	;test	byte [_Bits],8
 16819 00001902 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16820 00001907 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16821                                  
 16822 00001909 E8C30C                  	call	CRLF2			; start on new line
 16823 0000190C E83AFE                  	call	UseLine
 16824 0000190F A1[CD8A]                	mov	ax,[FileCnt]		; AX = # files found
 16825                                  
 16826                                  ;	DisplayTotals uses this entry point.
 16827                                  ;
 16828                                  DisplayCntSiz:
 16829                                  ;	AX = # files
 16830                                  ;	FileSiz = dword total size of files
 16831                                  
 16832 00001912 A3[168C]                	mov	[Dir_Num],ax		; load # files
 16833 00001915 BA[3C7F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16834 00001918 E8B634                  	call	std_printf		; "nnn File(s)"
 16835                                  
 16836 0000191B BA[2A81]                	mov	dx,bytes_ptr
 16837 0000191E E8B034                  	call	std_printf		; "nnn bytes",cr,lf
 16838                                  	; 19/02/2023
 16839                                  	;call	UseLine
 16840                                  ;dtrRet:
 16841                                  	;retn
 16842                                  
 16843                                  	; 19/02/2023
 16844 00001921 E925FE                  	jmp	UseLine
 16845                                  
 16846                                  ; ---------------------------------------------------------------------------
 16847                                  
 16848                                  ;***	DisplayWide - display filename in wide format
 16849                                  ;
 16850                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16851                                  ;
 16852                                  ;	EXIT	nothing
 16853                                  ;
 16854                                  ;	USED	AX,CX,DX,SI,DI
 16855                                  ;
 16856                                  ;	EFFECTS
 16857                                  ;
 16858                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16859                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16860                                  
 16861                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16862                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16863                                  
 16864                                  DisplayWide:
 16865 00001924 1E                      	push	ds			; save TRANGROUP seg addr
 16866 00001925 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16867                                  	;assume	ds:nothing
 16868                                  
 16869                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16870                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16871 00001929 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16872 0000192D 9C                      	pushf	; 03/08/2024
 16873 0000192E 7405                    	jz	short dw1		; not a subdirectory file
 16874 00001930 B05B                    	mov	al,'['
 16875 00001932 E8C604                  	call	PRINT_CHAR		; prefix subdirectory
 16876                                  dw1:	
 16877 00001935 E83BFE                  	call	DisplayDotForm		; display name.ext
 16878                                  
 16879                                  ;	DX = # chars displayed in name.ext
 16880                                  
 16881                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16882                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16883                                  	; 03/08/2024
 16884                                  	;test	byte [bx+12],ATTR_DIRECTORY
 16885 00001938 9D                      	popf	; 03/08/2024
 16886 00001939 7405                    	jz	short dw2		; not a subdirectory file
 16887 0000193B B05D                    	mov	al,']'
 16888 0000193D E8BB04                  	call	PRINT_CHAR		; postfix subdirectory
 16889                                  dw2:
 16890                                  ;	Pad field with blanks.
 16891                                  
 16892                                  	;mov	cx,size filename + size fileext + 1
 16893 00001940 B90C00                  	mov	cx,12 ; 8+3+1
 16894                                  					; CX = field size
 16895 00001943 29D1                    	sub	cx,dx			; CX = # pad char's
 16896 00001945 E307                    	jcxz	dwDone
 16897 00001947 B020                    	mov	al,' '
 16898                                  dw3:	
 16899 00001949 E8AF04                  	call	PRINT_CHAR
 16900 0000194C E2FB                    	loop	dw3
 16901                                  dwDone:	
 16902 0000194E 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16903                                  	;assume	ds:TRANGROUP
 16904 0000194F C3                      	retn
 16905                                  
 16906                                  ; ---------------------------------------------------------------------------
 16907                                  
 16908                                  ;***	GetDriveLtr - get target drive letter
 16909                                  ;
 16910                                  ;	ENTRY	FCB contains drive #
 16911                                  ;
 16912                                  ;	EXIT	AX = "d:"
 16913                                  ;
 16914                                  ;	USED	nothing
 16915                                  
 16916                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16917                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16918                                  GetDriveLtr:
 16919 00001950 A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16920 00001953 08C0                    	or	al,al
 16921 00001955 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16922 00001957 A0[B78A]                	mov	al,[CURDRV]	; AL = current drive #
 16923 0000195A FEC0                    	inc	al		; AL = 1-based drive #
 16924                                  gdl1:	
 16925 0000195C 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16926 0000195E B43A                    	mov	ah,':'		; AX = "d:"
 16927 00001960 C3                      	retn
 16928                                  
 16929                                  ; ---------------------------------------------------------------------------
 16930                                  
 16931                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16932                                  ;
 16933                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16934                                  ;	for system parser calls. Set up a message substitution block,
 16935                                  ;	etc. for invalid value strings. I copied the procedure from
 16936                                  ;	Setup_Parse_Error_Msg.
 16937                                  ;
 16938                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16939                                  ;		
 16940                                  ;
 16941                                  ;	EXIT	AX = system parser error return code for bad param format
 16942                                  ;		DX = ptr to message description block for Std_EPrintf
 16943                                  ;
 16944                                  ;	USED	SI
 16945                                  ;
 16946                                  ;	EFFECTS
 16947                                  ;
 16948                                  ;	  Msg_Disp_Class = parse error message class
 16949                                  ;	  Message block (see DX) is set up for parse error message
 16950                                  
 16951                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16952                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16953                                  SetupParamError:
 16954 00001961 B80900                  	mov	ax,9			; parse error #
 16955 00001964 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 16956                                  	;mov	byte [msg_disp_class],2
 16957 00001969 A3[FC7E]                	mov	[extend_buf_ptr],ax
 16958                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16959 0000196C 8B7704                  	mov	si,[bx+4]
 16960 0000196F 8936[118C]              	mov	[string_ptr_2],si
 16961 00001973 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 16962                                  	;mov	byte [extend_buf_sub],1
 16963 00001978 BA[FC7E]                	mov	dx,extend_buf_ptr
 16964 0000197B C3                      	retn
 16965                                  
 16966                                  ; ---------------------------------------------------------------------------
 16967                                  
 16968                                  ;***	ZeroTotals - zero grand total file count, size
 16969                                  ;
 16970                                  ;	ENTRY	nothing
 16971                                  ;
 16972                                  ;	EXIT	nothing
 16973                                  ;
 16974                                  ;	USED	AX
 16975                                  ;
 16976                                  ;	EFFECTS
 16977                                  ;
 16978                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 16979                                  ;
 16980                                  ;	NOTES
 16981                                  ;
 16982                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 16983                                  	
 16984                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16985                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 16986                                  ZeroTotals:
 16987 0000197C BF[D38A]                	mov	di,FileCntTotal
 16988                                  
 16989                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 16990 0000197F B90800                  	mov	cx,8
 16991                                  
 16992 00001982 30C0                    	xor	al,al
 16993 00001984 F3AA                    	rep	stosb
 16994 00001986 C3                      	retn	
 16995                                  
 16996                                  ; ---------------------------------------------------------------------------
 16997                                  
 16998                                  ;***	CtrlCHandler - our own control-c handler
 16999                                  ;
 17000                                  ;	Make sure user's default directory gets restored. See notes
 17001                                  ;	at InstallCtrlCHandler.
 17002                                  ;
 17003                                  ;	ENTRY	control-c
 17004                                  ;
 17005                                  ;	EXIT	to OldCtrlCHandler
 17006                                  ;
 17007                                  ;	USED	DS,flags
 17008                                  ;
 17009                                  ;	EFFECTS
 17010                                  ;
 17011                                  ;	  Restore user's default directory.
 17012                                  ;
 17013                                  ;	NOTES
 17014                                  ;
 17015                                  ;	  This handler is only installed after calling PathCrunch,
 17016                                  ;	  which sets UserDir1, so the restoration will work.
 17017                                  ;
 17018                                  ;	  The original control-c vector will be restored, whether
 17019                                  ;	  or not this one is invoked, in the HeadFix routine.
 17020                                  
 17021                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17022                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17023                                  
 17024                                  CtrlCHandler:	;proc	far
 17025                                  
 17026                                  ;SR;
 17027                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17028                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17029                                  ;
 17030 00001987 1E                      	push	ds
 17031 00001988 0E                      	push	cs
 17032 00001989 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17033 0000198A 50                      	push	ax
 17034 0000198B 52                      	push	dx
 17035 0000198C E8FD0A                  	call	RestUDir		; restore user's default directory
 17036 0000198F 5A                      	pop	dx
 17037 00001990 58                      	pop	ax
 17038 00001991 1F                      	pop	ds
 17039 00001992 2EFF2E[2395]            	jmp	far [cs:OldCtrlCHandler]
 17040                                  					; go to previous int 23 handler
 17041                                  
 17042                                  ; ---------------------------------------------------------------------------
 17043                                  
 17044                                  ;M010;start
 17045                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17046                                  ;
 17047                                  ;	ENTRY	AL = character to be displayed
 17048                                  ;
 17049                                  ;	EXIT	AL is lowercase
 17050                                  ;
 17051                                  ;	USED	nothing
 17052                                  
 17053                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17054                                  LowerCase:
 17055 00001997 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 17056 00001999 7206                    	jb	short lcRet
 17057 0000199B 3C5A                    	cmp	al,'Z'
 17058 0000199D 7702                    	ja	short lcRet
 17059                                  
 17060 0000199F 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17061                                  lcRet:
 17062 000019A1 C3                      	retn
 17063                                  
 17064                                  ; ---------------------------------------------------------------------------
 17065                                  
 17066                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17067                                  ;
 17068                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17069                                  ;		ES = DS
 17070                                  ;
 17071                                  ;	EXIT	nothing
 17072                                  ;	
 17073                                  ;	USED	AL,SI
 17074                                  
 17075                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17076                                  LowercaseString:
 17077 000019A2 57                      	push	di			; save di
 17078 000019A3 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17079 000019A5 FC                      	cld
 17080                                  NextChar: 
 17081 000019A6 AC                      	lodsb				; get character from string into al
 17082 000019A7 08C0                    	or	al,al			; are we at end of string?
 17083 000019A9 7406                    	jz	short EndOfString
 17084                                  
 17085 000019AB E8E9FF                  	call	LowerCase		; convert character to lowercase
 17086 000019AE AA                      	stosb				; store character back into buffer
 17087 000019AF EBF5                    	jmp	short NextChar		; repeat until end of string
 17088                                  
 17089                                  EndOfString:
 17090 000019B1 5F                      	pop	di			; restore di
 17091 000019B2 C3                      	retn
 17092                                  
 17093                                  ;M010;end
 17094                                  
 17095                                  ;============================================================================
 17096                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 17097                                  ;============================================================================
 17098                                  ; 09/10/2018 - Retro DOS v3.0
 17099                                  
 17100                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 17101                                  
 17102                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17103                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 17104                                  
 17105                                  ; =============== S U B	R O U T	I N E =======================================
 17106                                  
 17107                                  PAUSE:
 17108 000019B3 BA[8E7F]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 17109 000019B6 E81834                  	call	std_printf
 17110 000019B9 E898EB                  	call	GETKEYSTROKE
 17111                                  	;call	CRLF2
 17112                                  	;retn
 17113                                  	; 19/02/2023
 17114 000019BC E9100C                  	jmp	CRLF2
 17115                                  
 17116                                  ; ---------------------------------------------------------------------------
 17117                                  
 17118                                  ;****************************************************************
 17119                                  ;*
 17120                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 17121                                  ;*
 17122                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 17123                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 17124                                  ;*		up an error message and transfer control to CERROR.
 17125                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 17126                                  ;*		entered or SLASHP_ERASE if /P entered.
 17127                                  ;*
 17128                                  ;* INPUT:	command line at offset 81H
 17129                                  ;*
 17130                                  ;* OUTPUT:	if no error:
 17131                                  ;*		FCB at 5ch set up with filename(s) entered
 17132                                  ;*		Current directory set to entered directory
 17133                                  ;*
 17134                                  ;****************************************************************
 17135                                  
 17136                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17137                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 17138                                  	; 10/06/2023
 17139                                  ERASE:
 17140                                  	; MSDOS 6.0
 17141                                  
 17142                                  	;assume	ds:trangroup,es:trangroup
 17143                                  
 17144 000019BF BE8100                  	mov	si,81h		;AC000; get command line
 17145 000019C2 C706[BA8A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 17146 000019C8 BF[F984]                	mov	di,PARSE_ERASE
 17147                                  				;AN000; Get address of PARSE_ERASE
 17148 000019CB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17149                                  erase_scan:
 17150 000019CD 31D2                    	xor	dx,dx		;AN000;
 17151 000019CF E8E507                  	call	Parse_With_Msg	;AC018; call parser
 17152                                  
 17153                                  	;cmp	ax,-1  ; 0FFFFh
 17154                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 17155                                  	;je	short good_line	;AN000; yes - done parsing
 17156                                  	;;cmp	ax,0
 17157                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 17158                                  	;and	ax,ax		;AC000; did we have an error?
 17159                                  	;jnz	short errj2	;AC000; yes exit
 17160                                  	; 10/06/2023
 17161 000019D2 40                      	inc	ax  ; cmp ax,-1
 17162 000019D3 743C                    	jz	short good_line ; 0FFFFh -> 0
 17163 000019D5 48                      	dec	ax  ; cmp ax,0	
 17164 000019D6 7566                    	jnz	short errj2  ; 1 -> 0
 17165                                  	; ax = 0
 17166                                  
 17167 000019D8 813E[5195][6C84]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 17168                                  				;AN000; was /P entered?
 17169 000019DE 741C                    	je	short set_erase_prompt
 17170                                  				;AN000; yes - go set prompt
 17171                                  ;
 17172                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 17173                                  ;
 17174 000019E0 56                      	push	si		;AC000; save position in line
 17175 000019E1 C536[5395]              	lds	si,[PARSE1_ADDR]
 17176                                  				;AC000; get address of filespec
 17177                                  	;cmp	byte [si+1],colon_char
 17178 000019E5 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 17179 000019E9 750B                    	jne	short erase_drive_ok
 17180                                  				;AC000; no - continue
 17181                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 17182 000019EB 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 17183 000019EF 7505                    	jne	short erase_drive_ok
 17184                                  				;AC000; no - continue
 17185 000019F1 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 17186                                  				;AN022; get message number in control block
 17187 000019F4 EB3D                    	jmp	short extend_setup
 17188                                  				;AC000; exit
 17189                                  erase_drive_ok:
 17190 000019F6 E8AA12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17191 000019F9 5E                      	pop	si		;AC000; get position back
 17192 000019FA EBD1                    	jmp	short erase_scan
 17193                                  				;AN000; continue parsing
 17194                                  set_erase_prompt:
 17195 000019FC 833E[BA8A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 17196 00001A01 7408                    	jz	short ok_to_set_erase_prompt
 17197                                  				;AN018; no go set switch
 17198                                  	;mov	ax,1
 17199 00001A03 B80100                  	mov	ax,MoreArgs_Ptr 
 17200                                  				;AN018; set up too many arguments
 17201 00001A06 E8BD07                  	call	setup_parse_error_msg
 17202                                  				;AN018; set up an error message
 17203 00001A09 EB33                    	jmp	short errj2	;AN018; exit
 17204                                  
 17205                                  ok_to_set_erase_prompt: 	;AN018;
 17206 00001A0B FF06[BA8A]              	inc	word [COMSW]	;AN000; indicate /p specified
 17207 00001A0F EBBC                    	jmp	short erase_scan
 17208                                  				;AN000; continue parsing
 17209                                  good_line:			;G  We know line is good
 17210 00001A11 E8640C                  	call	PathCrunch
 17211 00001A14 730D                    	jnc	short checkdr
 17212 00001A16 A1[948D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17213                                  	;cmp	ax,0		;AN022; was message flag set?
 17214 00001A19 09C0                    	or	ax,ax
 17215 00001A1B 7516                    	jnz	short extend_setup
 17216                                  				;AN022; yes - print out message
 17217                                  	;cmp	byte [DestIsDir],0
 17218 00001A1D 3806[288C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 17219 00001A21 750D                    	jnz	short badpath_err
 17220                                  				;AC022; see if they should have
 17221                                  checkdr:
 17222 00001A23 833E[BA8A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 17223 00001A28 7403                    	jz	short notest2j	;AN000; no - go to notest2
 17224 00001A2A E9081B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 17225                                  notest2j:
 17226 00001A2D E9A01A                  	jmp	notest2
 17227                                  
 17228                                  badpath_err:			;AN022; "Path not found" message
 17229 00001A30 B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 17230                                  				;AN022; set up error number
 17231                                  extend_setup:			;AN022;
 17232                                  	;mov	byte [msg_disp_class],1
 17233 00001A33 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 17234                                  				;AN022; set up extended error msg class
 17235 00001A38 BA[FC7E]                	mov	dx,extend_buf_ptr
 17236                                  				;AC022; get extended message pointer
 17237 00001A3B A3[FC7E]                	mov	[extend_buf_ptr],ax
 17238                                  				;AN022; get message number in control block
 17239                                  errj2:				;AC022; exit jump
 17240 00001A3E E90F0F                  	jmp	cerror		;AN022;
 17241                                  
 17242                                  ; 20/02/2023
 17243                                  %if 0
 17244                                  	; MSDOS 3.3
 17245                                  	mov	dx,BADARGSPTR
 17246                                  	mov	si,80h
 17247                                  	lodsb
 17248                                  	or	al,al
 17249                                  	jz	short ERRJ2
 17250                                  	call	SCANOFF
 17251                                  	cmp	al,0Dh		; Return key
 17252                                  	jz	short ERRJ2	; If so no parameters specified
 17253                                  	push	dx
 17254                                  	push	si
 17255                                  	mov	dx,FNOTFOUNDPTR
 17256                                  ERASE_SCAN:
 17257                                  	lodsb
 17258                                  	call	DELIM
 17259                                  	jz	short ERASE_CHKDELIMCHR
 17260                                  	cmp	al,0Dh
 17261                                  	jz	short GOOD_LINE
 17262                                  	jmp	short ERASE_SCAN
 17263                                  ERASE_CHKDELIMCHR:
 17264                                  	cmp	al,20h
 17265                                  	jg	short ERRJ2
 17266                                  	lodsb
 17267                                  	call	DELIM
 17268                                  	jz	short ERASE_CHKDELIMCHR
 17269                                  	cmp	al,0Dh
 17270                                  	jz	short GOOD_LINE
 17271                                  	mov	dx,BADARGSPTR
 17272                                  	jmp	short ERRJ2
 17273                                  GOOD_LINE:
 17274                                  	pop	si
 17275                                  	pop	dx
 17276                                  	push	si
 17277                                  	call	PATHCRUNCH
 17278                                  	jnc	short CHECKDR
 17279                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17280                                  	jz	short CHECKDR	   ; see if they should have
 17281                                  BADCDERR:
 17282                                  	pop	si
 17283                                  	mov	dx,BADCDPTR
 17284                                  ERRJ2:
 17285                                  	jmp	CERROR
 17286                                  CHECKDR:
 17287                                  	mov	dx,FNOTFOUNDPTR
 17288                                  	pop	cx
 17289                                  	mov	al,' '
 17290                                  	;cmp	[5Dh],al
 17291                                  	cmp	[FCB+1],al
 17292                                  	jz	short ERRJ2
 17293                                  	add	cx,3
 17294                                  	cmp	si,cx
 17295                                  	jnz	short NOTEST2J
 17296                                  	mov	al,':'
 17297                                  	cmp	[si-2],al
 17298                                  	jz	short ERRJ2
 17299                                  NOTEST2J:
 17300                                  	jmp	NOTEST2
 17301                                  %endif
 17302                                  
 17303                                  ; ---------------------------------------------------------------------------
 17304                                  
 17305                                  ; ****************************************************************
 17306                                  ; *
 17307                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17308                                  ; *
 17309                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17310                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17311                                  ; *		 Make sure the second filespec only contains a
 17312                                  ; *		 filename. If both openands are valid, attempt
 17313                                  ; *		 to rename the file.
 17314                                  ; *
 17315                                  ; * INPUT:	 command line at offset 81H
 17316                                  ; *
 17317                                  ; * OUTPUT:	 none
 17318                                  ; *
 17319                                  ; ****************************************************************
 17320                                  
 17321                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17322                                  CRENAME:
 17323                                  	; MSDOS 6.0
 17324                                  	;assume	ds:trangroup,es:trangroup
 17325                                  
 17326 00001A41 BE8100                  	mov	si,81h		;AC000; Point to command line
 17327 00001A44 BF[7085]                	mov	di,PARSE_RENAME
 17328                                  				;AN000; Get address of PARSE_RENAME
 17329 00001A47 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17330 00001A49 31D2                    	xor	dx,dx		;AN000;
 17331 00001A4B E86907                  	call	Parse_With_Msg	;AC018; call parser
 17332                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17333 00001A4E 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17334                                  ;	jz	short crename_no_parse_error
 17335                                  				;AC000; no - continue
 17336 00001A50 752C                    	jnz	short crename_parse_error
 17337                                  				;AC000; Yes, fail. (need long jump)
 17338                                  ;
 17339                                  ;  Get first file name returned from parse into our buffer
 17340                                  ;
 17341                                  crename_no_parse_error:
 17342 00001A52 56                      	push	si		;AN000; save position in line
 17343 00001A53 C536[5395]              	lds	si,[PARSE1_ADDR]
 17344                                  				;AN000; get address of filespec
 17345 00001A57 E84912                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17346 00001A5A 5E                      	pop	si		;AN000; restore position in line
 17347                                  
 17348 00001A5B 31D2                    	xor	dx,dx		;AN000; clear dx
 17349 00001A5D E85707                  	call	Parse_With_Msg	;AC018; call parser
 17350                                  	;cmp	ax,RESULT_NO_ERROR
 17351 00001A60 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17352 00001A62 751A                    	jnz	short crename_parse_error
 17353                                  				;AN000; Yes, fail.
 17354                                  ;
 17355                                  ;  Check the second file name for drive letter colon
 17356                                  ;
 17357 00001A64 56                      	push	si		;AN000; save position in line
 17358 00001A65 C536[5395]              	lds	si,[PARSE1_ADDR]
 17359                                  				;AC000; get address of path
 17360                                  	;mov	al,':'		;AC000;
 17361                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17362 00001A69 807C013A                	cmp	byte [si+1],':'
 17363 00001A6D 7511                    	jnz	short ren_no_drive
 17364                                  				;AN000; Yes, error
 17365                                  	;mov	byte [msg_disp_class],2
 17366 00001A6F C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 17367                                  				;AN000; set up parse error msg class
 17368 00001A74 BA[FC7E]                	mov	dx,extend_buf_ptr
 17369                                  				;AC000; get extended message pointer
 17370                                  	;mov	word [extend_buf_ptr],0Ah
 17371 00001A77 C706[FC7E]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17372                                  				;AN000; get "Invalid parameter" message number
 17373 00001A7D 5E                      	pop	si		;AN000;
 17374                                  crename_parse_error:		;AC022;
 17375 00001A7E EB64                    	jmp	short errj	;AC000;
 17376                                  
 17377                                  ;  Get second file name returned from parse into the fCB. Save
 17378                                  ;  character after file name so we can later check to make sure it
 17379                                  ;  isn't a path character.
 17380                                  
 17381                                  ren_no_drive:
 17382 00001A80 BF6C00                  	mov	di,FCB+10h ; 6Ch
 17383                                  				;AC000; set up to parse second file name
 17384                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17385 00001A83 B80129                  	mov	ax,2901h
 17386 00001A86 CD21                    	int	21h		;AC000; do the function
 17387 00001A88 AC                      	lodsb			;AC000; Load char after filename
 17388 00001A89 A2[208C]                	mov	[One_Char_Val],al
 17389                                  				;AN000; save char after filename
 17390 00001A8C 5E                      	pop	si		;AN000; get line position back
 17391                                  ;
 17392                                  ; We have source and target. See if any args beyond.
 17393                                  ;
 17394 00001A8D BF[7085]                	mov	di,PARSE_RENAME
 17395                                  				;AC000; get address of parse_rename
 17396 00001A90 E80E07                  	call	parse_check_eol ;AC000; are we at end of line?
 17397 00001A93 75E9                    	jnz	short crename_parse_error
 17398                                  				;AN000; no, fail.
 17399                                  
 17400 00001A95 E8E00B                  	call	PathCrunch
 17401 00001A98 BA[0D7F]                	mov	dx,BADCPMES_PTR
 17402 00001A9B 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17403 00001A9D 730F                    	jnc	short notest3
 17404 00001A9F A1[948D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17405                                  	;cmp	ax,0		;AN022; was message flag set?
 17406 00001AA2 21C0                    	and	ax,ax ; 0 ?
 17407 00001AA4 758D                    	jnz	short extend_setup
 17408                                  				;AN022; yes - print out message
 17409                                  	;cmp	byte [DestIsDir],0
 17410 00001AA6 3806[288C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17411 00001AAA 7402                    	jz	short notest3 	; see if they should have
 17412 00001AAC EB82                    	Jmp	badpath_err	;AC022; set up error
 17413                                  notest3:
 17414 00001AAE A0[208C]                	mov	al,[One_Char_Val]
 17415                                  				;AN000; move char into AX
 17416 00001AB1 BA[2B7F]                	mov	dx,INORNOT_PTR 
 17417                                  				; Load invalid fname error ptr
 17418 00001AB4 E8B30B                  	call	pathchrcmp	; Is the char in al a path sep?
 17419 00001AB7 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17420                                  				;  filename only.
 17421                                  	;mov	ah,FCB_Rename
 17422 00001AB9 B417                    	mov	ah,17h
 17423 00001ABB BA5C00                  	mov	dx,FCB ; 5Ch
 17424 00001ABE CD21                    	int	21h
 17425 00001AC0 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17426 00001AC2 7506                    	jne	short renameok
 17427                                  
 17428 00001AC4 E82902                  	call	get_ext_error_number
 17429                                  				;AN022; get extended error
 17430 00001AC7 50                      	push	ax		;AC022; Save results
 17431 00001AC8 B0FF                    	mov	al,0FFh		; Restore original error state
 17432                                  renameok:
 17433 00001ACA 50                      	push	ax
 17434 00001ACB E8BE09                  	call	RestUDir
 17435 00001ACE 58                      	pop	ax
 17436 00001ACF FEC0                    	inc	al
 17437                                  	;;retnz
 17438                                  	;jz	short rn1
 17439                                  	;retn	
 17440 00001AD1 7514                    	jnz	short ret56
 17441                                  rn1:
 17442 00001AD3 58                      	pop	ax		;AC022; get the error number back
 17443 00001AD4 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17444                                  				;AN022; error file not found?
 17445 00001AD7 7408                    	jz	short use_renerr
 17446                                  				;AN022; yes - use generic error message
 17447 00001AD9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17448                                  				;AN022; error file not found?
 17449 00001ADC 7403                    	jz	short use_renerr
 17450                                  				;AN022; yes - use generic error message
 17451 00001ADE E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17452                                  
 17453                                  use_renerr:
 17454 00001AE1 BA[0A7F]                	mov	dx,RENERR_PTR	;AC022;
 17455                                  errj:
 17456 00001AE4 E9690E                  	jmp	cerror
 17457                                  ret56:
 17458                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17459 00001AE7 C3                      	retn
 17460                                  
 17461                                  ; 20/02/2023
 17462                                  %if 0
 17463                                  	; MSDOS 3.3
 17464                                  	mov	dx,BADARGSPTR
 17465                                  	call	SCANOFF
 17466                                  	cmp	al,0Dh
 17467                                  	jz	short ERRJ2
 17468                                  	call	PATHCRUNCH
 17469                                  	mov	dx,BADCPMESPTR
 17470                                  	jz	short ERRJ2
 17471                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17472                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17473                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17474                                  	jmp	short BADCDERR
 17475                                  
 17476                                  ;  Get first file name returned from parse into our buffer
 17477                                  
 17478                                  CRENAME_NO_PARSE_ERROR:
 17479                                  	mov	si,[PATHPOS]
 17480                                  	call	SCANOFF
 17481                                  	cmp	al,0Dh
 17482                                  	mov	dx,BADARGSPTR
 17483                                  	jz	short ERRJ
 17484                                  	mov	al,':'
 17485                                  	mov	dx,BADPARMPTR
 17486                                  	cmp	[si+1],al
 17487                                  	jz	short ERRJ
 17488                                  
 17489                                  ;  Get second file name returned from parse into the FCB. Save
 17490                                  ;  character after file name so we can later check to make sure it
 17491                                  ;  isn't a path character.
 17492                                  
 17493                                  REN_NO_DRIVE:
 17494                                  	;mov	di,6Ch
 17495                                  	mov	di,FCB+10h
 17496                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17497                                  	int	21h	; DOS -	PARSE FILENAME
 17498                                  			; DS:SI	-> string to parse
 17499                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17500                                  			; AL = bit mask	to control parsing
 17501                                  	mov	al,' '
 17502                                  	;cmp	[6Dh],al
 17503                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17504                                  	jz	short ERRJ	; Error if missing parameter
 17505                                  	lodsb
 17506                                  	mov	dx,INORNOTPTR
 17507                                  	call	PATHCHRCMP
 17508                                  	jz	short ERRJ
 17509                                  	mov	ah,FCB_RENAME ; 17h
 17510                                  	mov	dx,FCB ; 5Ch
 17511                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17512                                  			; DS:DX	-> FCB
 17513                                  			; FCB contains new name	starting at byte 17h.
 17514                                  	cmp	al,0FFh		; Did an error occur??	
 17515                                  	jnz	short RENAMEOK
 17516                                  	stc
 17517                                  	mov	dx,RENERRPTR
 17518                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17519                                  	push	dx
 17520                                  	mov	al,0FFh		; Restore original error state
 17521                                  RENAMEOK:
 17522                                  	push	ax
 17523                                  	call	RESTUDIR
 17524                                  	pop	ax
 17525                                  	inc	al
 17526                                  	jz	short RENAME_ERR
 17527                                  RENAME_RETN:
 17528                                  TYPELP_RET:
 17529                                  	retn
 17530                                  RENAME_ERR:
 17531                                  	pop	dx
 17532                                  ERRJ:				; Retro DOS v3.0
 17533                                  	call	STD_EPRINTF
 17534                                  	jmp	TCOMMAND
 17535                                  
 17536                                  ; ---------------------------------------------------------------------------
 17537                                  
 17538                                  ;ERRJ:
 17539                                  ;	jmp	CERROR
 17540                                  
 17541                                  ; ---------------------------------------------------------------------------
 17542                                  
 17543                                  ;TYPELP_RET:
 17544                                  ;	retn
 17545                                  
 17546                                  %endif
 17547                                  
 17548                                  ; ---------------------------------------------------------------------------
 17549                                  
 17550                                  ;****************************************************************
 17551                                  ;*
 17552                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17553                                  ;*		standard output device
 17554                                  ;*
 17555                                  ;* SYNTAX:	TYPE filespec
 17556                                  ;*
 17557                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17558                                  ;*		1Ah and display the contents to STDOUT.
 17559                                  ;*
 17560                                  ;* INPUT:	command line at offset 81H
 17561                                  ;*
 17562                                  ;* OUTPUT:	none
 17563                                  ;*
 17564                                  ;****************************************************************
 17565                                  
 17566                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17567                                  TYPEFIL:
 17568                                  	; MSDOS 6.0	
 17569                                  	;assume	ds:trangroup,es:trangroup
 17570                                  
 17571 00001AE8 BE8100                  	mov	si,81h
 17572 00001AEB BF[E784]                	mov	di,PARSE_MRDIR
 17573                                  				;AN000; Get address of PARSE_MRDIR
 17574 00001AEE 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17575 00001AF0 31D2                    	xor	dx,dx		;AN000;
 17576 00001AF2 E8C206                  	call	Parse_With_Msg	;AC018; call parser
 17577                                  	;cmp	ax,RESULT_NO_ERROR
 17578 00001AF5 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17579 00001AF7 751E                    	jnz	short typefil_parse_error
 17580                                  				;AN000; yes - issue error message
 17581                                  
 17582 00001AF9 56                      	push	si		;AC000; save position in line
 17583 00001AFA C536[5395]              	lds	si,[PARSE1_ADDR]
 17584                                  				;AC000; get address of filespec
 17585 00001AFE E8A211                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17586 00001B01 5E                      	pop	si		;AC000; get position back
 17587 00001B02 BF[E784]                	mov	di,PARSE_MRDIR
 17588                                  				;AC000; get address of parse_mrdir
 17589 00001B05 E89906                  	call	parse_check_eol ;AC000; are we at end of line?
 17590                                  	;jz	short gottarg 	;AC000; yes - continue
 17591                                  	; 20/02/2023
 17592                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17593                                  	;jmp	cerror
 17594 00001B08 750D                    	jnz	short typefil_parse_error
 17595                                  gottarg:
 17596 00001B0A E8DD0F                  	call	SETPATH
 17597 00001B0D F606[2C8C]02            	test	byte [DestInfo],00000010b ; 2
 17598                                  				; Does the filespec contain wildcards
 17599 00001B12 7406                    	jz	short nowilds 	; No, continue processing
 17600 00001B14 BA[2B7F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17601                                  	; 20/02/2023
 17602                                  typefil_parse_error:
 17603 00001B17 E9360E                  	jmp	cerror
 17604                                  nowilds:
 17605                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17606 00001B1A B8006C                  	mov	ax,6C00h
 17607                                  	;mov	bx,read_open_mode ; 0
 17608                                  				;AN000; get open mode for TYPE
 17609 00001B1D 31C9                    	xor	cx,cx		;AN000; no special files
 17610 00001B1F 89CB                    	mov	bx,cx ; 20/02/2023
 17611 00001B21 BA0101                  	mov	dx,101h
 17612                                  	;mov	dx,read_open_flag ; 101h
 17613                                  				;AN000; set up open flags
 17614 00001B24 BE[908C]                	mov	si,SrcBuf	;AN030; get file name
 17615 00001B27 CD21                    	int	21h
 17616 00001B29 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17617                                  
 17618                                  typerr: 			;AN022;
 17619 00001B2B 0E                      	push	cs		;AN022; make sure we have local segment
 17620 00001B2C 1F                      	pop	ds		;AN022;
 17621 00001B2D E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 17622 00001B30 C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf 
 17623                                  				;AC022; get address of failed string
 17624                                  	;mov	byte [extend_buf_sub],1
 17625 00001B36 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 17626                                  				;AC022; put number of subst in control block
 17627 00001B3B E9120E                  	jmp	cerror		;AC022; exit
 17628                                  
 17629                                  typecont:
 17630 00001B3E 89C3                    	mov	bx,ax		;AC000; get Handle
 17631                                  ;M043
 17632                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17633                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17634                                  ;indicate it is a device.
 17635                                  ;
 17636                                  	;mov	ax,(IOCTL shl 8) or 0
 17637 00001B40 B80044                  	mov	ax,4400h
 17638 00001B43 CD21                    	int	21h
 17639                                  
 17640 00001B45 F6C280                  	test	dl,80h		;is it a device?
 17641 00001B48 7408                    	jz	short not_device
 17642                                  				;no, a file
 17643                                  
 17644 00001B4A C706[4D95]FFFF          	mov	word [TypeFilSiz+2],-1
 17645                                  				;indicate it is a device
 17646 00001B50 EB17                    	jmp	short dotype
 17647                                  not_device:
 17648                                  ;SR;
 17649                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17650                                  ;start of file
 17651                                  
 17652                                  	;mov	ax,(LSEEK shl 8) or 2
 17653 00001B52 B80242                  	mov	ax,4202h
 17654 00001B55 31D2                    	xor	dx,dx
 17655 00001B57 89D1                    	mov	cx,dx		;seek  to end of file
 17656 00001B59 CD21                    	int	21h
 17657                                  
 17658 00001B5B A3[4B95]                	mov	[TypeFilSiz],ax
 17659 00001B5E 8916[4D95]              	mov	[TypeFilSiz+2],dx ;store filesize
 17660                                  	;mov	ax,(LSEEK shl 8) or 0
 17661 00001B62 B80042                  	mov	ax,4200h
 17662 00001B65 31D2                    	xor	dx,dx
 17663 00001B67 CD21                    	int	21h	        ;reset file pointer to start
 17664                                  dotype:				;M043
 17665 00001B69 C606[548D]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17666 00001B6E 8E1E[A78A]              	mov	ds,[TPA]
 17667 00001B72 31D2                    	xor	dx,dx
 17668                                  	;ASSUME	DS:NOTHING
 17669                                  typelp:
 17670 00001B74 2E803E[548D]00          	cmp	byte [cs:zflag],0
 17671                                  				;AC050; Is the ^Z flag set?
 17672                                  	;retnz			; Yes, return
 17673                                  	; 17/04/2023
 17674 00001B7A 7401                    	jz	short tf1
 17675 00001B7C C3                      	retn
 17676                                  tf1:
 17677 00001B7D 2E8B0E[C48A]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17678                                  
 17679                                  ;Update the filesize left to read
 17680                                  
 17681 00001B82 2E833E[4D95]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17682                                  				;is it a device? M043
 17683 00001B88 7431                    	je	short typ_read	;yes, just read from it; M043
 17684                                  
 17685 00001B8A 2E833E[4D95]00          	cmp	word [cs:TypeFilSiz+2],0
 17686                                  				;more than 64K left?
 17687 00001B90 740D                    	jz	short lt64k	;no, do word subtraction
 17688 00001B92 2E290E[4B95]            	sub	[cs:TypeFilSiz],cx
 17689 00001B97 2E831E[4D95]00          	sbb	word [cs:TypeFilSiz+2],0
 17690                                  				;update filesize
 17691 00001B9D EB1C                          	jmp	short typ_read	;do the read
 17692                                  lt64k:
 17693 00001B9F 2E3B0E[4B95]            	cmp	cx,[cs:TypeFilSiz]
 17694                                  				;readsize <= buffer?
 17695 00001BA4 7610                    	jbe	short gtbuf	; yes, just update readsize
 17696                                  
 17697                                  ;Buffer size is larger than bytes to read
 17698                                  
 17699 00001BA6 2E8B0E[4B95]            	mov	cx,[cs:TypeFilSiz]
 17700 00001BAB E361                    	jcxz	typelp_ret
 17701 00001BAD 2EC706[4B95]0000        	mov	word [cs:TypeFilSiz],0
 17702 00001BB4 EB05                    	jmp	short typ_read
 17703                                  gtbuf:
 17704 00001BB6 2E290E[4B95]            	sub	[cs:TypeFilSiz],cx
 17705                                  				;update filesize remaining
 17706                                  typ_read:
 17707                                  	;mov	ah,read
 17708 00001BBB B43F                    	mov	ah,3Fh
 17709 00001BBD CD21                    	int	21h
 17710 00001BBF 7303                    	jnc	short tf2	;M043
 17711 00001BC1 E967FF                  	jmp	typerr		;M043
 17712                                  tf2:				;M043
 17713                                  ;M043;	jc	typerr		;AN022; Exit if error
 17714                                  
 17715 00001BC4 89C1                    	mov	cx,ax
 17716 00001BC6 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17717 00001BC8 1E                      	push	ds
 17718 00001BC9 07                      	pop	es		; Check to see if a ^Z was read.
 17719                                  	;assume es:nothing
 17720 00001BCA 31FF                    	xor	di,di
 17721 00001BCC 50                      	push	ax
 17722 00001BCD B01A                    	mov	al,1Ah
 17723 00001BCF F2AE                    	repnz	scasb
 17724 00001BD1 58                      	pop	ax
 17725 00001BD2 91                      	xchg	ax,cx
 17726                                  	;cmp	ax,0
 17727 00001BD3 21C0                    	and	ax,ax
 17728 00001BD5 7506                    	jnz	short foundz	; Yes, handle it
 17729 00001BD7 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17730 00001BDB 750A                    	jnz	short typecont2	; No ^Z, continue
 17731                                  foundz:
 17732 00001BDD 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17733 00001BDF 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17734 00001BE0 0E                      	push	cs		;  will be typed.
 17735 00001BE1 07                      	pop	es
 17736                                  	;assume es:trangroup
 17737 00001BE2 26F616[548D]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17738                                  typecont2:			;  will quit after this write.
 17739 00001BE7 53                      	push	bx
 17740 00001BE8 BB0100                  	mov	bx,1
 17741                                  	;mov	ah,Write
 17742 00001BEB B440                    	mov	ah,40h
 17743 00001BED CD21                    	int	21h
 17744 00001BEF 5B                      	pop	bx
 17745 00001BF0 720C                    	jc	short Error_outputj
 17746 00001BF2 39C8                    	cmp	ax,cx
 17747 00001BF4 7503                    	jnz	short tf3	;M043
 17748 00001BF6 E97BFF                  	jmp	typelp		;M043
 17749                                  tf3:				;M043
 17750                                  ;M043;	jz	short typelp
 17751 00001BF9 49                      	dec	cx
 17752 00001BFA 39C8                    	cmp	ax,cx
 17753                                  	;;retz			; One less byte OK (^Z)
 17754                                  	;jnz	short Error_outputj
 17755                                  ;tf4:
 17756                                  	;retn
 17757 00001BFC 7410                    	jz	short typelp_ret ; 20/02/2023
 17758                                  
 17759                                  Error_outputj:
 17760 00001BFE BB0100                  	mov	bx,1
 17761                                  	;mov	ax,IOCTL SHL 8
 17762 00001C01 B80044                  	mov	ax,4400h
 17763 00001C04 CD21                    	int	21h
 17764 00001C06 F6C280                  	test	dl,80h
 17765                                  	;test	dl,devid_ISDEV
 17766                                  	;;retnz			; If device, no error message
 17767                                  	;jnz	short tf4
 17768 00001C09 7503                    	jnz	short typelp_ret
 17769 00001C0B E9420A                  	jmp	error_output
 17770                                  typelp_ret:
 17771 00001C0E C3                      	retn
 17772                                  
 17773                                  ; 20/02/2023
 17774                                  %if 0
 17775                                  	; MSDOS 3.3
 17776                                  	mov	si,81h
 17777                                  	call	SCANOFF		; Skip to first non-delim
 17778                                  	cmp	al,0Dh
 17779                                  	jnz	short GOTTARG
 17780                                  	mov	dx,BADARGSPTR
 17781                                  
 17782                                  	;jmp	CERROR
 17783                                  	jmp	short ERRJ	; No args
 17784                                  GOTTARG:
 17785                                  	call	SETPATH
 17786                                  	test	byte [DESTINFO],2
 17787                                  	jz	short NOWILDS
 17788                                  	mov	dx,INORNOTPTR
 17789                                  
 17790                                  	;jmp	CERROR
 17791                                  	jmp	short ERRJ
 17792                                  NOWILDS:
 17793                                  	mov	ax,OPEN*256 ; 3D00h
 17794                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17795                                  			; DS:DX	-> ASCIZ filename
 17796                                  			; AL = access mode
 17797                                  			; 0 - read
 17798                                  	jnc	short TYPECONT
 17799                                  	mov	dx,FNOTFOUNDPTR
 17800                                  	cmp	ax,2
 17801                                  	jz	short ERRJ
 17802                                  	mov	dx,BADCPMESPTR
 17803                                  	stc
 17804                                  	call	GET_EXT_ERR_NUMBER
 17805                                  	
 17806                                  	;jmp	CERROR
 17807                                  	jmp	short ERRJ
 17808                                  TYPECONT:
 17809                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17810                                  	mov	bx,ax		; Handle
 17811                                  	mov	ds,[TPA]
 17812                                  	xor	dx,dx
 17813                                  TYPELP:
 17814                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17815                                  	jnz	short RENAME_RETN ; Yes, return	
 17816                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17817                                  	mov	ah,READ ; 3Fh
 17818                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17819                                  			; BX = file handle,CX = number	of bytes to read
 17820                                  			; DS:DX	-> buffer
 17821                                  	mov	cx,ax
 17822                                  	jcxz	TYPELP_RET	; exit if nothing read
 17823                                  				; Check to see if a ^Z was read.
 17824                                  	push	ds
 17825                                  	pop	es		
 17826                                  	xor	di,di
 17827                                  	push	ax
 17828                                  	mov	al,1Ah
 17829                                  	repne	scasb
 17830                                  	pop	ax
 17831                                  	xchg	ax,cx
 17832                                  	cmp	ax,0
 17833                                  	jnz	short FOUNDZ	; Yes, handle it
 17834                                  	cmp	byte [di-1],1Ah	; No, double check
 17835                                  	jnz	short TYPECONT2	; No ^Z, continue
 17836                                  FOUNDZ:
 17837                                  	sub	cx,ax		; Otherwise change cx so that only those
 17838                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17839                                  	push	cs		;  will be typed.
 17840                                  	pop	es
 17841                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17842                                  				;  will quit after this write.
 17843                                  TYPECONT2:
 17844                                  	push	bx
 17845                                  	mov	bx,1
 17846                                  	mov	ah,WRITE ; 40h
 17847                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17848                                  			; BX = file handle, CX = number of bytes to write,
 17849                                  			; DS:DX -> buffer
 17850                                  	pop	bx
 17851                                  	jc	short ERROR_OUTPUTJ
 17852                                  	cmp	ax,cx
 17853                                  	jz	short TYPELP
 17854                                  	dec	cx
 17855                                  	cmp	ax,cx		; One less byte OK (^Z)
 17856                                  	jnz	short ERROR_OUTPUTJ
 17857                                  TYPEFIL_RETN:
 17858                                  	retn
 17859                                  ERROR_OUTPUTJ:
 17860                                  	mov	bx,1
 17861                                  	mov	ax,IOCTL*256 ; 4400h
 17862                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17863                                  			; BX = file or device handle
 17864                                  	;test	dl,devid_ISDEV
 17865                                  	test	dl,80h
 17866                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17867                                  	jmp	ERROR_OUTPUT
 17868                                  %endif
 17869                                  
 17870                                  ; ---------------------------------------------------------------------------
 17871                                  
 17872                                  ; VOLUME command displays the volume ID on the specified drive
 17873                                  
 17874                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17875                                  	; 10/06/2023
 17876                                  VOLUME:
 17877                                  	; MSDOS 6.0
 17878 00001C0F BE8100                  	mov	si,81h
 17879 00001C12 BF[D584]                	mov	di,PARSE_VOL
 17880                                  				;AN000; Get address of PARSE_VOL
 17881 00001C15 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17882 00001C17 31D2                    	xor	dx,dx		;AN000;
 17883 00001C19 E89B05                  	call	Parse_With_Msg	;AC018; call parser
 17884                                  
 17885                                  	;cmp	ax,-1 ; 0FFFFh
 17886                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17887                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 17888                                  	;;cmp	ax,RESULT_NO_ERROR
 17889                                  	;;cmp	ax,0		;AC000; did we have an error?
 17890                                  	;or	ax,ax ; 0?
 17891                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 17892                                  	; 10/06/2023
 17893 00001C1C 40                      	inc	ax  ; cmp ax,-1
 17894 00001C1D 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 17895 00001C1F 48                      	dec	ax  ; cmp ax,0
 17896 00001C20 750A                    	jnz	short badvolarg ; 1 -> 0
 17897                                  	; ax = 0
 17898                                  
 17899                                  ; We have parsed off the drive. See if there are any more chars left
 17900                                  
 17901 00001C22 BF[D584]                	mov	di,PARSE_VOL
 17902                                  				;AC000; get address of parse_vol
 17903 00001C25 31D2                    	xor	dx,dx		;AC000;
 17904 00001C27 E87705                  	call	parse_check_eol ;AC000; call parser
 17905 00001C2A 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17906                                  
 17907                                  ; The line was not interpretable. Report an error.
 17908                                  
 17909                                  badvolarg:
 17910 00001C2C E9210D                  	jmp	cerror
 17911                                  
 17912                                  ; 20/02/2023
 17913                                  %if 0
 17914                                  	; MSDOS 3.3
 17915                                  	mov	si,81h
 17916                                  	call	SCANOFF		; Skip to first non-delim
 17917                                  	;mov	ah,[5Ch]
 17918                                  	mov	ah,[FCB]
 17919                                  	;mov	byte [5Ch],0
 17920                                  	mov	byte [FCB],0
 17921                                  	cmp	al,0Dh		; are we at end of line?
 17922                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17923                                  	;mov	[5Ch],ah
 17924                                  	mov	[FCB],ah
 17925                                  	lodsb
 17926                                  	lodsb
 17927                                  	cmp	al,':'
 17928                                  	jnz	short VOLUME_ERR
 17929                                  	call	SCANOFF
 17930                                  	cmp	al,0Dh
 17931                                  	jz	short OKVOLARG
 17932                                  VOLUME_ERR:
 17933                                  	mov	dx,BADDRVPTR
 17934                                  	jmp	CERROR
 17935                                  
 17936                                  ; ---------------------------------------------------------------------------
 17937                                  
 17938                                  OKVOLARG:
 17939                                  	call	CRLF2
 17940                                  	push	ds
 17941                                  	pop	es
 17942                                  	;mov	di,55h
 17943                                  	mov	di,FCB-7	; Set up extended FCB
 17944                                  	mov	al,-1
 17945                                  	stosb
 17946                                  	xor	ax,ax
 17947                                  	stosw
 17948                                  	stosw
 17949                                  	stosb
 17950                                  	mov	al,8		; Look for volume label
 17951                                  	stosb
 17952                                  	inc	di		; Skip drive byte
 17953                                  	mov	cx,11
 17954                                  	mov	al,'?'
 17955                                  	rep stosb
 17956                                  	mov	dx,DIRBUF
 17957                                  	mov	ah,Set_DMA ; 1Ah
 17958                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17959                                  			; DS:DX	-> disk	transfer buffer
 17960                                  	;mov	dx,55h
 17961                                  	mov	dx,FCB-7
 17962                                  	mov	ah,Dir_Search_First ; 11h
 17963                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17964                                  			; DS:DX	-> FCB
 17965                                  	jmp	PRINTVOL
 17966                                  %endif
 17967                                  
 17968                                  ; ---------------------------------------------------------------------------
 17969                                  
 17970                                  ;***	DisAppend - disable APPEND
 17971                                  ;
 17972                                  ;	ENTRY	nothing
 17973                                  ;
 17974                                  ;	EXIT	nothing
 17975                                  ;
 17976                                  ;	USED	AX,BX
 17977                                  ;
 17978                                  ;	EFFECTS
 17979                                  ;
 17980                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 17981                                  ;	  after the command finishes, by the HeadFix routine.
 17982                                  ;
 17983                                  ;	NOTE
 17984                                  ;
 17985                                  ;	  This routine must not be called more than once during a single
 17986                                  ;	  command cycle. The second call would permanently disable APPEND.
 17987                                  
 17988                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17989                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 17990                                  
 17991                                  	; MSDOS 6.0
 17992                                  DisAppend:
 17993 00001C2F 1E                      	push	ds			; save DS
 17994 00001C30 06                      	push	es			; save ES
 17995 00001C31 57                      	push	di
 17996                                  
 17997                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 17998 00001C32 B800B7                  	mov	ax,0B700h
 17999 00001C35 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18000 00001C37 08C0                    	or	al,al
 18001 00001C39 7423                    	jz	short daRet		; APPEND not installed, return
 18002                                  
 18003                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 18004 00001C3B B802B7                  	mov	ax,0B702h
 18005 00001C3E CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18006 00001C40 83F8FF                  	cmp	ax,0FFFFh
 18007 00001C43 7519                    	jne	short daRet		; it's not a local version, return
 18008                                  
 18009                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 18010 00001C45 B806B7                  	mov	ax,0B706h
 18011 00001C48 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18012                                  
 18013 00001C4A 8E1E[A58A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 18014                                  
 18015 00001C4E 891E[AB01]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 18016 00001C52 C606[AD01]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 18017                                  
 18018 00001C57 31DB                    	xor	bx,bx			; BX = APPEND state = off
 18019                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 18020 00001C59 B807B7                  	mov	ax,0B707h
 18021 00001C5C CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18022                                  daRet:	
 18023 00001C5E 5F                      	pop	di
 18024 00001C5F 07                      	pop	es			; restore ES
 18025 00001C60 1F                      	pop	ds			; restore DS
 18026                                  
 18027 00001C61 C3                      	retn
 18028                                  
 18029                                  ; ---------------------------------------------------------------------------
 18030                                  
 18031                                  ; Find the Volume ID on the disk.
 18032                                  
 18033                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18034                                  
 18035                                  	; MSDOS 6.0
 18036                                  OkVolArg:
 18037 00001C62 E8CAFF                  	call	DisAppend		; disable APPEND
 18038 00001C65 E86709                  	call	CRLF2
 18039                                  	;mov	al,blank			
 18040 00001C68 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18041 00001C6A E88E01                  	call	PRINT_CHAR		;AN051;  before volume message
 18042 00001C6D 1E                      	push	ds
 18043 00001C6E 07                      	pop	es
 18044                                  
 18045                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 18046                                  ; of volume_id ONLY.
 18047                                  
 18048 00001C6F BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 18049 00001C72 B0FF                    	mov	al,-1			; Tag to indicate Extention
 18050 00001C74 AA                      	stosb
 18051 00001C75 31C0                    	xor	ax,ax			; Zero padding to volume label
 18052 00001C77 AB                      	stosw
 18053 00001C78 AB                      	stosw
 18054 00001C79 AA                      	stosb
 18055 00001C7A B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 18056 00001C7C AA                      	stosb
 18057 00001C7D 47                      	inc	di			; Skip drive byte; it is already set
 18058 00001C7E B90B00                  	mov	cx,11			; fill in remainder of file
 18059 00001C81 B03F                    	mov	al,'?'
 18060 00001C83 F3AA                    	rep	stosb
 18061                                  
 18062                                  ; Set up transfer address (destination of search first information)
 18063                                  
 18064 00001C85 BA[AA8B]                	mov	dx,DIRBUF
 18065                                  	;mov	ah,Set_DMA
 18066 00001C88 B41A                    	mov	ah,1Ah
 18067 00001C8A CD21                    	int	21h
 18068                                  
 18069                                  ; Do the search
 18070                                  
 18071 00001C8C BA5500                  	mov	dx,FCB-7 ; 55h
 18072                                  	;mov	ah,Dir_Search_First
 18073 00001C8F B411                    	mov	ah,11h
 18074 00001C91 CD21                    	int	21h
 18075                                  
 18076                                  ;********************************
 18077                                  ; Print volume ID info
 18078                                  
 18079 00001C93 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 18080 00001C94 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 18081 00001C97 0440                    	add	al,'@'  ; add al,40h
 18082 00001C99 3C40                    	cmp	al,'@'
 18083 00001C9B 7505                    	jne	short drvok
 18084 00001C9D A0[B78A]                	mov	al,[CURDRV]
 18085                                  	;add	al,capital_A
 18086 00001CA0 0441                    	add	al,'A'
 18087                                  drvok:
 18088 00001CA2 A2[228C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 18089 00001CA5 58                      	pop	ax			;AC000; get return code back
 18090 00001CA6 08C0                    	or	al,al			;AC000; volume label found?
 18091 00001CA8 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 18092 00001CAA BA[F77F]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 18093 00001CAD EB13                    	jmp	short print_serial	;AC000; go print it
 18094                                  
 18095                                  Get_vol_name:
 18096 00001CAF BF[DB8A]                	mov	di,CHARBUF
 18097 00001CB2 89FA                    	mov	dx,di
 18098 00001CB4 BE[B28B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 18099 00001CB7 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 18100 00001CBA F3A4                    	rep	movsb			;AN000;  3/3/KK
 18101                                  
 18102 00001CBC 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 18103 00001CBE AA                      	stosb
 18104 00001CBF BA[0580]                	mov	dx,VolMes_Ptr		;AC000; set up message
 18105                                  
 18106                                  print_serial:
 18107                                  
 18108                                  ; Attempt to get the volume serial number from the disk. If an error
 18109                                  ; occurs, do not print volume serial number.
 18110                                  
 18111 00001CC2 52                      	push	dx			;AN000; save message offset
 18112                                  	;mov	ax,(GetSetMediaID SHL 8)
 18113 00001CC3 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 18114 00001CC6 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 18115 00001CCA BA[798D]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 18116 00001CCD CD21                    	int	21h			;AN000; do the call
 18117                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 18118                                  			; AL = 00h get serial number / 01h set serial number
 18119                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 18120                                  			; DS:DX -> disk info
 18121 00001CCF 5A                      	pop	dx			;AN000; get message offset back
 18122 00001CD0 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 18123 00001CD2 E8FC30                  	call	std_printf		;AC000; go print volume message
 18124                                  	;mov	al,blank				
 18125 00001CD5 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18126 00001CD7 E82101                  	call	PRINT_CHAR		;AN051;  before volume message
 18127 00001CDA BA[1E80]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 18128                                  printvol_end:
 18129 00001CDD E9F130                  	jmp	std_printf		;AC000; go print and exit
 18130                                  
 18131                                  ; ---------------------------------------------------------------------------
 18132                                  
 18133                                  ;****************************************************************
 18134                                  ;*
 18135                                  ;* ROUTINE:	Set_ext_error_msg
 18136                                  ;*
 18137                                  ;* FUNCTION:	Sets up extended error message for printing
 18138                                  ;*
 18139                                  ;* INPUT:	return from INT 21
 18140                                  ;*
 18141                                  ;* OUTPUT:	extended error message set up in extended error
 18142                                  ;*		buffer.
 18143                                  ;*
 18144                                  ;****************************************************************
 18145                                  	
 18146                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18147                                  
 18148                                  	; MSDOS 6.0
 18149                                  Set_Ext_Error_Msg:			;AN000;
 18150 00001CE0 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 18151 00001CE3 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 18152                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 18153 00001CE8 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 18154 00001CEB A3[FC7E]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 18155 00001CEE F9                      	stc				;AN000; make sure carry is set
 18156 00001CEF C3                      	retn				;AN000; return
 18157                                  
 18158                                  ; ---------------------------------------------------------------------------
 18159                                  
 18160                                  ;****************************************************************
 18161                                  ;*
 18162                                  ;* ROUTINE:	Get_ext_error_number
 18163                                  ;*
 18164                                  ;* FUNCTION:	Does get extended error function call
 18165                                  ;*
 18166                                  ;* INPUT:	return from INT 21
 18167                                  ;*
 18168                                  ;* OUTPUT:	AX - extended error number
 18169                                  ;*
 18170                                  ;****************************************************************
 18171                                  
 18172                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18173                                  
 18174                                  	; MSDOS 6.0
 18175                                  get_ext_error_number:			;AN022;
 18176                                  
 18177                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 18178                                  					;AN022; save registers
 18179 00001CF0 53                      	push	bx
 18180 00001CF1 51                      	push	cx
 18181 00001CF2 52                      	push	dx
 18182 00001CF3 56                      	push	si
 18183 00001CF4 57                      	push	di
 18184 00001CF5 55                      	push	bp
 18185 00001CF6 06                      	push	es
 18186 00001CF7 1E                      	push	ds
 18187                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 18188 00001CF8 B459                    	mov	ah,59h
 18189 00001CFA 31DB                    	xor	bx,bx			;AN022; clear BX
 18190 00001CFC CD21                    	int	21h			;AN022;
 18191                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 18192                                  			; BX = version code (0000h for DOS 3.x)
 18193                                  
 18194                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 18195                                  					;AN022; restore registers
 18196 00001CFE 1F                      	pop	ds
 18197 00001CFF 07                      	pop	es
 18198 00001D00 5D                      	pop	bp
 18199 00001D01 5F                      	pop	di
 18200 00001D02 5E                      	pop	si
 18201 00001D03 5A                      	pop	dx
 18202 00001D04 59                      	pop	cx
 18203 00001D05 5B                      	pop	bx
 18204                                  
 18205 00001D06 C3                      	retn				;AN022; return
 18206                                  
 18207                                  ;============================================================================
 18208                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 18209                                  ;============================================================================
 18210                                  ; 08/10/2018 - Retro DOS v3.0
 18211                                  
 18212                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 18213                                  
 18214                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18215                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 18216                                  
 18217                                  ; ---------------------------------------------------------------------------
 18218                                  
 18219                                  ; MSDOS 6.0
 18220                                  ;***	Version - display DOS version
 18221                                  ;
 18222                                  ;	SYNTAX	ver [/debug]
 18223                                  ;
 18224                                  ;		/debug - display additional DOS configuration info
 18225                                  ;
 18226                                  ;	ENTRY	command-line tail is in PSP
 18227                                  ;
 18228                                  ;	EXIT	if successful, nothing
 18229                                  ;		if parse fails,
 18230                                  ;		  parse error message is set up (for Std_EPrintf)
 18231                                  ;		    AX = system parser error code
 18232                                  ;		    DX = ptr to message block
 18233                                  ;		  we jump to CError
 18234                                  ;
 18235                                  ;	EFFECTS
 18236                                  ;	  If parse fails, a parse error message is displayed.
 18237                                  ;	  Otherwise, version message is displayed.
 18238                                  ;	  If /debug is specified, additional DOS info is displayed.
 18239                                  
 18240                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18241                                  VERSION:
 18242                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 18243                                  
 18244                                  ;	Parse command line for /debug switch.
 18245                                  
 18246 00001D07 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 18247 00001D0A BF[8D85]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 18248 00001D0D 31C9                    	xor	cx,cx			; CX = # positional param's found
 18249 00001D0F E8A504                  	call	Parse_With_Msg
 18250                                  
 18251 00001D12 B301                    	mov	bl,1			; BL = flag = /debug present
 18252                                  	;cmp	ax,RESULT_NO_ERROR
 18253                                  	;cmp	ax,0
 18254                                  	;je	short verPrintVer	; something parsed - must be /debug
 18255 00001D14 09C0                    	or	ax,ax
 18256 00001D16 740A                    	jz	short verPrintVer 
 18257 00001D18 FECB                    	dec	bl			; BL = flag = no /debug present
 18258                                  	;cmp	ax,END_OF_LINE ; -1
 18259 00001D1A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18260                                  
 18261                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18262                                  %if 0
 18263                                  	je	short verPrintVer	; reached end of line - ok
 18264                                  %else
 18265 00001D1D 7414                    	je	short not_truever_sw
 18266                                  %endif
 18267                                  
 18268                                  ;	The parse failed. Error message has been set up.
 18269                                  
 18270 00001D1F E92E0C                  	jmp	cerror
 18271                                  
 18272                                  verPrintVer:
 18273                                  
 18274                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18275                                  %if 1
 18276                                  check_t_switch:
 18277 00001D22 813E[5195][AD85]        	cmp	word [PARSE1_SYN],SLASH_T_SYN ; "/T" ; /t switch
 18278 00001D28 7509                    	jne	short not_truever_sw
 18279 00001D2A BA[BF85]                	mov	dx,RD4CMD_VER_MSG
 18280 00001D2D B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9 ; print the message
 18281 00001D2F CD21                    	int	21h
 18282 00001D31 EB43                    	jmp	short verDone
 18283                                  not_truever_sw:
 18284                                  %endif
 18285 00001D33 53                      	push	bx			; save /debug flag
 18286 00001D34 E89808                  	call	CRLF2
 18287 00001D37 E83F00                  	call	PRINT_VERSION
 18288 00001D3A E89208                  	call	CRLF2
 18289 00001D3D 5B                      	pop	bx   			; BL = /debug flag
 18290 00001D3E 08DB                    	or	bl,bl
 18291 00001D40 7434                    	jz	short verDone		; /debug is false - we're done
 18292                                  
 18293                                  ;*	For /debug, display DOS internal revision and DOS location
 18294                                  ;	(low memory, HMA, or ROM).
 18295                                  
 18296                                  ;	Bugbug:	use symbols for bitmasks below.
 18297                                  
 18298                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 18299 00001D42 B80633                  	mov	ax,3306h
 18300 00001D45 CD21                    	int	21h
 18301                                  		; DOS - 5+ Get TRUE Version Number
 18302                                  		; (BL major, BH minor, DL revision, DH flags)
 18303 00001D47 88D0                    	mov	al,dl			;revision number in dl; M013
 18304 00001D49 88F7                    	mov	bh,dh			;flags in dh now; M013
 18305                                  ;M032	and	al,7			; AL = DOS internal revision
 18306 00001D4B 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18307                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18308 00001D4D 7602                    	jbe	short ver1
 18309 00001D4F B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18310                                  ;@@:
 18311                                  ver1:
 18312 00001D51 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18313 00001D53 A2[208C]                	mov	[One_Char_Val],al
 18314 00001D56 BA[4C81]                	mov	dx,dosrev_ptr
 18315 00001D59 E87530                  	call	std_printf		; print DOS internal revision
 18316                                  
 18317 00001D5C B104                    	mov	cl,4
 18318 00001D5E D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18319 00001D60 7209                    	jc	short verRom
 18320 00001D62 D0EF                    	shr	bh,1			; CY = DOS in HMA
 18321 00001D64 720A                    	jc	short verHma
 18322                                  
 18323                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18324                                  
 18325                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18326 00001D66 BA[6081]                	mov	dx,DosLow_Ptr
 18327 00001D69 EB08                    	jmp	short verPrintLoc
 18328                                  verRom: 
 18329                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18330 00001D6B BA[5A81]                	mov	dx,DosRom_Ptr
 18331 00001D6E EB03                    	jmp	short verPrintLoc
 18332                                  verHma: 
 18333                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18334 00001D70 BA[5D81]                	mov	dx,DosHma_Ptr
 18335                                  verPrintLoc:
 18336 00001D73 E85B30                  	call	std_printf
 18337                                  verDone:
 18338 00001D76 E95608                  	jmp	CRLF2
 18339                                  
 18340                                  ; 21/02/2023
 18341                                  ;	; MSDOS 3.3
 18342                                  ;VERSION:
 18343                                  ;	call	CRLF2
 18344                                  ;	call	PRINT_VERSION
 18345                                  ;	jmp	CRLF2
 18346                                  
 18347                                  ; =============== S U B	R O U T	I N E =======================================
 18348                                  
 18349                                  	; 21/02/2023 - Retro DOS v4.0
 18350                                  PRINT_VERSION:
 18351                                  	;mov	ah,GET_VERSION ; 30h
 18352 00001D79 B430                    	mov	ah,30h
 18353 00001D7B CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18354                                  			; Return: AL = major version number (00h for DOS 1.x)
 18355 00001D7D 50                      	push	ax
 18356 00001D7E 30E4                    	xor	ah,ah
 18357 00001D80 A3[1C8C]                	mov	[Major_Ver_Num],ax
 18358 00001D83 58                      	pop	ax
 18359 00001D84 86E0                    	xchg	ah,al
 18360 00001D86 30E4                    	xor	ah,ah
 18361 00001D88 A3[1E8C]                	mov	[Minor_Ver_Num],ax
 18362 00001D8B BA[DE7F]                	mov	dx,VerMes_Ptr
 18363 00001D8E E94030                  	jmp	std_printf
 18364                                  
 18365                                  ; =============== S U B	R O U T	I N E =======================================
 18366                                  
 18367                                  	; 21/02/2023 - Retro DOS v4.0
 18368                                  PRINT_PROMPT:
 18369 00001D91 1E                      	push	ds
 18370 00001D92 0E                      	push	cs
 18371 00001D93 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 18372 00001D94 06                      	push	es
 18373 00001D95 E87805                  	call	find_prompt	; Look for prompt string
 18374 00001D98 7206                    	jc	short PP0	; Can't find one
 18375 00001D9A 26803D00                	cmp	byte [es:di],0
 18376 00001D9E 7524                    	jnz	short PP1
 18377                                  PP0:				; Use default prompt
 18378 00001DA0 E86700                  	call	PRINT_DRIVE
 18379 00001DA3 B03E                    	mov	al,'>'
 18380                                  	;mov	al,SYM
 18381 00001DA5 E85300                  	call	PRINT_CHAR
 18382 00001DA8 EB36                    	jmp	short PP5
 18383                                  ;PP1:
 18384                                  ;	mov	al,[es:di]	; Get a char
 18385                                  ;	inc	di
 18386                                  ;	or	al,al
 18387                                  ;	jz	short PP5	; Nul terminated
 18388                                  ;	; 21/02/2023
 18389                                  ;	cmp	al,'$' ; 24h
 18390                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18391                                  ;	jz	short PP2	; Nope
 18392                                  ;	call	PRINT_CHAR
 18393                                  ;	jmp	short PP1
 18394                                  PP2:
 18395 00001DAA 268A05                  	mov	al,[es:di]
 18396 00001DAD 47                      	inc	di
 18397                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18398 00001DAE BB[6982]                	mov	bx,PROMPT_TABLE-3
 18399 00001DB1 08C0                    	or	al,al
 18400 00001DB3 742B                    	jz	short PP5
 18401                                  PP3:
 18402 00001DB5 83C303                  	add	bx,3
 18403                                  	; 21/02/2023
 18404 00001DB8 E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18405                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18406 00001DBB 3A07                    	cmp	al,[bx]
 18407 00001DBD 7416                    	jz	short PP4
 18408 00001DBF 803F00                  	cmp	byte [bx],0
 18409 00001DC2 75F1                    	jnz	short PP3
 18410                                  	;jmp	short PP1
 18411                                  	; 21/02/2023
 18412                                  PP1:
 18413 00001DC4 268A05                  	mov	al,[es:di]	; Get a char
 18414 00001DC7 47                      	inc	di
 18415 00001DC8 08C0                    	or	al,al
 18416 00001DCA 7414                    	jz	short PP5	; Nul terminated
 18417                                  	; 21/02/2023
 18418 00001DCC 3C24                    	cmp	al,'$' ; 24h
 18419                                  	;cmp	al,[DOLLAR]	; Meta character
 18420 00001DCE 74DA                    	jz	short PP2	; Nope
 18421 00001DD0 E82800                  	call	PRINT_CHAR
 18422 00001DD3 EBEF                    	jmp	short PP1
 18423                                  PP4:
 18424 00001DD5 06                      	push	es
 18425 00001DD6 57                      	push	di
 18426 00001DD7 0E                      	push	cs
 18427 00001DD8 07                      	pop	es
 18428 00001DD9 FF5701                  	call	word [bx+1]
 18429 00001DDC 5F                      	pop	di
 18430 00001DDD 07                      	pop	es
 18431 00001DDE EBE4                    	jmp	short PP1
 18432                                  PP5:
 18433 00001DE0 07                      	pop	es		; Restore segments
 18434 00001DE1 1F                      	pop	ds
 18435 00001DE2 C3                      	retn
 18436                                  
 18437                                  ; ---------------------------------------------------------------------------
 18438                                  
 18439                                  PRINT_BACK:
 18440                                  	; 21/02/2023
 18441 00001DE3 BA[D880]                	mov	dx,dback_ptr
 18442 00001DE6 E9E82F                  	jmp	std_printf
 18443                                  
 18444                                  ; ---------------------------------------------------------------------------
 18445                                  
 18446                                  PRINT_EQ:
 18447 00001DE9 B03D                    	mov	al,'='
 18448 00001DEB EB0E                    	jmp	short PRINT_CHAR
 18449                                  
 18450                                  ; ---------------------------------------------------------------------------
 18451                                  
 18452                                  PRINT_ESC:
 18453 00001DED B01B                    	mov	al,1Bh
 18454 00001DEF EB0A                    	jmp	short PRINT_CHAR
 18455                                  
 18456                                  ; ---------------------------------------------------------------------------
 18457                                  
 18458                                  	; 21/02/2023
 18459                                  PRINT_G:
 18460                                  	;mov	al,[RABRACKET]
 18461 00001DF1 B03E                    	mov	al,'>' ; 3Eh
 18462 00001DF3 EB06                    	jmp	short PRINT_CHAR
 18463                                  
 18464                                  ; ---------------------------------------------------------------------------
 18465                                  
 18466                                  	; 21/02/2023
 18467                                  PRINT_L:
 18468                                  	;mov	al,[LABRACKET]
 18469 00001DF5 B03C                    	mov	al,'<' ; 3Ch
 18470 00001DF7 EB02                    	jmp	short PRINT_CHAR
 18471                                  
 18472                                  ; ---------------------------------------------------------------------------
 18473                                  
 18474                                  	; 21/02/2023
 18475                                  Print_B:
 18476                                  	;mov	al,[VBAR]
 18477 00001DF9 B07C                    	mov	al,'|' ; 7Ch
 18478                                  
 18479                                  ; =============== S U B	R O U T	I N E =======================================
 18480                                  
 18481                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18482                                  PRINT_CHAR:
 18483                                  	; MSDOS 6.0
 18484                                  
 18485                                  ;	Bugbug:	Why bother with ds,es here?
 18486                                  		
 18487 00001DFB 06                      	push	es
 18488 00001DFC 1E                      	push	ds
 18489 00001DFD 07                      	pop	es
 18490 00001DFE 57                      	push	di
 18491 00001DFF 52                      	push	dx
 18492 00001E00 88C2                    	mov	dl,al		;AC000; Get char into al
 18493                                  	;mov	ah,STD_CON_OUTPUT
 18494                                  				;AC000; print the char to stdout
 18495 00001E02 B402                    	mov	ah,2
 18496 00001E04 CD21                    	int	21h		;AC000;
 18497 00001E06 5A                      	pop	dx
 18498 00001E07 5F                      	pop	di
 18499 00001E08 07                      	pop	es
 18500 00001E09 C3                      	retn
 18501                                  
 18502                                  ;21/02/2023
 18503                                  %if 0
 18504                                  	; MSDOS 3.3
 18505                                  	push	es
 18506                                  	push	ds
 18507                                  	pop	es
 18508                                  	push	di
 18509                                  	push	dx
 18510                                  	mov	di,ONE_CHAR_VAL	
 18511                                  	stosb
 18512                                  	mov	dx,ONECHRVALPTR
 18513                                  	call	STD_PRINTF
 18514                                  	pop	dx
 18515                                  	pop	di
 18516                                  	pop	es
 18517                                  	retn
 18518                                  %endif
 18519                                  
 18520                                  ; ---------------------------------------------------------------------------
 18521                                  
 18522                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18523                                  PRINT_DRIVE:
 18524                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18525 00001E0A B419                    	mov	ah,19h
 18526 00001E0C CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18527 00001E0E 0441                    	add	al,'A'
 18528                                  	;add	al,[CAPITAL_A]
 18529                                  	;call	PRINT_CHAR
 18530                                  	;retn
 18531                                  	; 21/02/2023
 18532 00001E10 EBE9                    	jmp	short PRINT_CHAR
 18533                                  
 18534                                  ; ---------------------------------------------------------------------------
 18535                                  
 18536                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18537                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18538                                  
 18539                                  build_dir_for_prompt:
 18540 00001E12 30D2                    	xor	dl,dl
 18541 00001E14 BE[AA8B]                	mov	si,BWDBUF
 18542 00001E17 89F7                    	mov	di,si
 18543 00001E19 A0[B78A]                	mov	al,[CURDRV]
 18544 00001E1C 0441                    	add	al,'A'
 18545 00001E1E B43A                    	mov	ah,':'
 18546 00001E20 AB                      	stosw
 18547 00001E21 A0[AA8A]                	mov	al,[DIRCHAR]
 18548 00001E24 AA                      	stosb
 18549 00001E25 87F7                    	xchg	si,di
 18550 00001E27 893E[118C]              	mov	[string_ptr_2],di
 18551                                  	;mov	ah,CURRENT_DIR ; 47h
 18552 00001E2B B447                    	mov	ah,47h
 18553 00001E2D CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18554                                  			; DL = drive (0=default,1=A,etc.)
 18555                                  			; DS:SI	points to 64-byte buffer area
 18556                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18557 00001E2F BA[C380]                	mov	dx,string_buf_ptr
 18558 00001E32 7303                    	jnc	short doprint
 18559                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18560 00001E34 BA[8B7F]                	mov	dx,BADCURDRV
 18561                                  doprint:
 18562                                  	;call	std_printf
 18563                                  	;retn
 18564 00001E37 E9972F                  	jmp	std_printf
 18565                                  
 18566                                  ; =============== S U B	R O U T	I N E =======================================
 18567                                  
 18568                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18569                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18570                                  
 18571                                  build_dir_for_chdir:
 18572 00001E3A E80D00                  	call	build_dir_string
 18573 00001E3D BA[AA8B]                	mov	dx,DIRBUF
 18574 00001E40 8916[118C]              	mov	[string_ptr_2],dx
 18575                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18576                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18577 00001E44 BA[C380]                	mov	dx,string_buf_ptr
 18578                                  	;call	std_printf
 18579                                  	;retn
 18580                                  	; 21/02/2023
 18581                                  	;jmp	short doprint
 18582 00001E47 E9872F                  	jmp	std_printf
 18583                                  
 18584                                  ; =============== S U B	R O U T	I N E =======================================
 18585                                  
 18586                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18587                                  build_dir_string:
 18588 00001E4A 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18589 00001E4E 88D0                    	mov	al,dl
 18590 00001E50 0440                    	add	al,'@'	; 40h
 18591 00001E52 3C40                    	cmp	al,'@'
 18592 00001E54 7506                    	jne	short gotdrive
 18593 00001E56 0206[B78A]              	add	al,[CURDRV]
 18594 00001E5A FEC0                    	inc	al
 18595                                  gotdrive:
 18596 00001E5C 50                      	push	ax
 18597 00001E5D BE[AD8B]                	mov	si,BWDBUF+3
 18598                                  	;mov	ah,CURRENT_DIR ; 47h
 18599 00001E60 B447                    	mov	ah,47h
 18600 00001E62 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18601                                  			; DL = drive (0=default,1=A,etc.)
 18602                                  			; DS:SI	points to 64-byte buffer area
 18603 00001E64 7305                    	jnc	short dpbisok
 18604 00001E66 0E                      	push	cs
 18605 00001E67 1F                      	pop	ds
 18606 00001E68 E9ED09                  	jmp	DRVBAD
 18607                                  dpbisok:
 18608 00001E6B BF[AA8B]                	mov	di,BWDBUF
 18609 00001E6E 89FA                    	mov	dx,di
 18610 00001E70 58                      	pop	ax
 18611 00001E71 B43A                    	mov	ah,':'
 18612 00001E73 AB                      	stosw
 18613 00001E74 A0[AA8A]                	mov	al,[DIRCHAR]
 18614 00001E77 AA                      	stosb
 18615 00001E78 C3                      	retn
 18616                                  
 18617                                  ; ---------------------------------------------------------------------------
 18618                                  
 18619                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18620                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18621                                  PATH:
 18622                                  	; MSDOS 6.0
 18623 00001E79 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18624 00001E7B BF[D387]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18625 00001E7E AA                      	stosb				;AN049; Initialize PATH to null
 18626 00001E7F 4F                      	dec	di			;AN049; point to the start of buffer
 18627 00001E80 E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 18628 00001E83 7460                    	jz	short disppath		; Print the current path
 18629                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18630 00001E85 3C3B                    	cmp	al,';' ; 3Bh
 18631 00001E87 7503                    	jne	short pathslp 		;AC049;
 18632 00001E89 46                      	inc	si			;AN049; point past semicolon
 18633 00001E8A EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18634                                  pathslp:					; Get the user specified path
 18635 00001E8C AC                      	lodsb				; Get a character
 18636 00001E8D 3C0D                    	cmp	al,0Dh
 18637                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18638 00001E8F 7434                    	je	short path_eol		;AC049; yes - end of command
 18639 00001E91 E82905                  	call	testkanj		;See if DBCS
 18640 00001E94 7405                    	jz	short notkanj2		;No - continue
 18641 00001E96 AA                      	stosb				;AC049; Yes - store the first byte
 18642 00001E97 AC                      	lodsb				;skip second byte of DBCS
 18643                                  path_hold:				;AN049;
 18644 00001E98 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18645 00001E99 EBF1                    	jmp	short pathslp		;continue parsing
 18646                                  notkanj2:
 18647 00001E9B E84905                  	call	UPCONV			;upper case the character
 18648                                  
 18649 00001E9E 3C3B                    	cmp	al,';' ; 3Bh
 18650                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18651 00001EA0 74F6                    	je	short path_hold		;AC049; go store it
 18652 00001EA2 E83F07                  	call	DELIM			;delimiter?
 18653 00001EA5 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18654                                  scan_white:				;AN049; make sure were at EOL
 18655 00001EA7 AC                      	lodsb				;AN049; get a character
 18656 00001EA8 3C0D                    	cmp	al,0Dh
 18657                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18658 00001EAA 7419                    	je	short path_eol		;AN049; yes - go set path
 18659 00001EAC 3C20                    	cmp	al,' ' ; 20h
 18660                                  	;cmp	al,blank		;AN049; whitespace?
 18661 00001EAE 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18662                                  	;cmp	al,9
 18663 00001EB0 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18664 00001EB2 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18665                                  
 18666 00001EB4 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18667                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18668 00001EB7 C706[FC7E]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18669                                  	;mov	byte [msg_disp_class],2		
 18670                                  					;AN049; set up parse error msg class
 18671 00001EBD C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 18672 00001EC2 E98B0A                  	jmp	cerror			;AN049;
 18673                                  path_eol:				;AN049; Parsing was clean
 18674 00001EC5 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18675 00001EC7 AA                      	stosb				;AN049;    buffer
 18676 00001EC8 E84004                  	call	find_path		;AN049; Find PATH in environment
 18677 00001ECB E81404                  	call	delete_path		;AC049; Delete any offending name
 18678 00001ECE E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 18679 00001ED1 E89A04                  	call	move_name		;AC049; move in PATH=
 18680 00001ED4 BE[D387]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18681                                  store_path:				;AN049; Store the PATH in the environment
 18682 00001ED7 AC                      	lodsb				;AN049; Get a character
 18683                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18684 00001ED8 20C0                    	and	al,al ; al=0 ?
 18685 00001EDA 7405                    	jz	short got_paths		;AN049; yes - exit
 18686 00001EDC E82A05                  	call	store_char		;AN049; no - store character
 18687 00001EDF EBF6                    	jmp	short store_path	;AN049; continue
 18688                                  got_paths:				;AN049; we're finished
 18689 00001EE1 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18690 00001EE3 AB                      	stosw				;    	the environment
 18691 00001EE4 C3                      	retn
 18692                                  disppath:
 18693 00001EE5 E82304                  	call	find_path		;AN049;
 18694 00001EE8 E80300                  	call	print_path
 18695                                  	;call	CRLF2
 18696                                  	;retn
 18697                                  	; 21/02/2023
 18698 00001EEB E9E106                  	jmp	CRLF2
 18699                                  
 18700                                  ; 21/02/2023
 18701                                  %if 0
 18702                                  	; MSDOS 3.3
 18703                                  	call	FIND_PATH		; Find PATH in environment
 18704                                  	call	PGETARG			; Pre scan for arguments
 18705                                  	jz	short DISPPATH		; Print the current path
 18706                                  	call	DELETE_PATH		; Delete any offending name
 18707                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18708                                  	call	MOVE_NAME		; Move in PATH=
 18709                                  	call	PGETARG
 18710                                  	cmp	al,';'
 18711                                  	jz	short GOTPATHS
 18712                                  PATHSLP:
 18713                                  	lodsb
 18714                                  	cmp	al,0Dh			; End of line (CR) ?		
 18715                                  	jz	short GOTPATHS		; yes - exit
 18716                                  	;call	UPCONV	; MSDOS 6.0
 18717                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18718                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18719                                  	jz	short NOTDELIM		; go set path
 18720                                  	call	DELIM			; is it delim/null char ?
 18721                                  	jz	short GOTPATHS		; yes - exit
 18722                                  NOTDELIM:
 18723                                  	call	STORE_CHAR		; no - store character
 18724                                  	jmp	short PATHSLP
 18725                                  GOTPATHS:
 18726                                  	xor	ax,ax			; null terminate the PATH
 18727                                  	stosw				; in the environment
 18728                                  	retn
 18729                                  DISPPATH:
 18730                                  	call	PRINT_PATH
 18731                                  	call	CRLF2
 18732                                  	retn
 18733                                  %endif
 18734                                  
 18735                                  ; =============== S U B	R O U T	I N E =======================================
 18736                                  
 18737                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18738                                  print_path:
 18739 00001EEE 26803D00                	cmp	byte [es:di],0
 18740 00001EF2 750A                    	jnz	short path1
 18741                                  path0:
 18742 00001EF4 BA[5180]                	mov	dx,NULLPATH_PTR
 18743 00001EF7 0E                      	push	cs
 18744 00001EF8 07                      	pop	es
 18745 00001EF9 0E                      	push	cs
 18746 00001EFA 1F                      	pop	ds
 18747 00001EFB E9D32E                  	jmp	std_printf
 18748                                  path1:
 18749 00001EFE 06                      	push	es
 18750 00001EFF 1F                      	pop	ds
 18751 00001F00 83EF05                  	sub	di,5
 18752 00001F03 89FE                    	mov	si,di
 18753 00001F05 E8AD04                  	call	SCASB2		; Look for null
 18754                                  	;cmp	cx,0FFh ; 255
 18755                                  	; 21/02/2023
 18756                                  	;ch = 0
 18757 00001F08 80F9FF                  	cmp	cl,255
 18758 00001F0B 74E7                    	je	short path0
 18759 00001F0D 0E                      	push	cs
 18760 00001F0E 07                      	pop	es
 18761 00001F0F BF[F692]                	mov	di,Arg_Buf
 18762                                  	;mov	dx,100h ; 256
 18763                                  	;sub	dx,cx
 18764                                  	;xchg	dx,cx
 18765                                  	; 21/02/2023
 18766 00001F12 F6D9                    	neg	cl ; 256-cl
 18767 00001F14 F3A4                    	rep	movsb
 18768 00001F16 BA[9980]                	mov	dx,arg_buf_ptr
 18769 00001F19 0E                      	push	cs
 18770 00001F1A 1F                      	pop	ds
 18771 00001F1B E9B32E                  	jmp	std_printf
 18772                                  
 18773                                  ; ---------------------------------------------------------------------------
 18774                                  
 18775                                  ; ****************************************************************
 18776                                  ; *
 18777                                  ; * ROUTINE:	 CLS
 18778                                  ; *
 18779                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18780                                  ; *		 installed, send a control string to clear the
 18781                                  ; *		 screen.
 18782                                  ; *
 18783                                  ; * INPUT:	 command line at offset 81H
 18784                                  ; *
 18785                                  ; * OUTPUT:	 none
 18786                                  ; *
 18787                                  ; ****************************************************************
 18788                                  
 18789                                  	; MSDOS 6.0
 18790                                  
 18791                                  ANSI_installed	equ 0FFh
 18792                                  
 18793                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18794                                  CLS:
 18795                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18796                                  	;mov	ah,1Ah
 18797                                  	;mov	al,0			;AN000;
 18798 00001F1E B8001A                  	mov	ax,1A00h
 18799 00001F21 CD2F                    	int	2Fh			;AN000;
 18800                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18801                                  		; Return: AL = FFh if installed
 18802 00001F23 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18803 00001F25 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18804                                  
 18805                                  check_lines:
 18806                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18807 00001F27 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18808                                  	;mov	bx,stdout		;AN000; lines for stdout
 18809 00001F2A BB0100                  	mov	bx,1   ; handle
 18810                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18811                                  	;mov	ch,3   ; CON device	
 18812                                  	;;mov	cl,get_generic		;AN000; get information
 18813                                  	;mov	cl,7Fh ; minor function, get display info
 18814                                  	; 25/04/2023
 18815 00001F2D B97F03                  	mov	cx,037Fh
 18816 00001F30 BA[678D]                	mov	dx,Display_Ioctl	;AN000;
 18817 00001F33 CD21                    	int	21h			;AN000;
 18818 00001F35 720A                    	jc	short no_variable	;AN000; function had error, use default
 18819                                  		; 21/02/2023
 18820                                  		; ds:dx = parameter block
 18821                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18822                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18823                                  		;   	 01h  byte  reserved
 18824                                  		;   	 02h  word  length of following data
 18825                                  		;   	 04h  word  control flags
 18826                                  		;	       bit 0 set for blink, clear for intensity
 18827                                  		;	       bits 1 to 15 reserved
 18828                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18829                                  		;   	 07h  byte  reserved
 18830                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18831                                  		;   	 0Ah  word  pixel columns
 18832                                  		;   	 0Ch  word  pixel rows
 18833                                  		;   	 0Eh  word  character columns
 18834                                  		;   	 10h  word  character rows
 18835                                  	
 18836                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18837                                  	;				;AN000; get number of rows returned
 18838                                  	;mov	dh,al			;AN000; set number of rows
 18839                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18840                                  	;				;AN000; get number of columns returned
 18841                                  	;mov	dl,al			;AN000; set number of columns
 18842                                  	; 21/02/2023
 18843 00001F37 8A16[758D]              	mov	dl,[display_width]
 18844 00001F3B 8A36[778D]              	mov	dh,[LinPerPag]
 18845 00001F3F EB3B                    	jmp	short regcls		;AN000; go do cls
 18846                                  
 18847                                  no_variable:
 18848                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18849                                  	;mov	bx,1
 18850                                  	; bx = 1
 18851                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18852 00001F41 B80044                  	mov	ax,4400h
 18853 00001F44 CD21                    	int	21h			;AC000;
 18854 00001F46 F6C280                  	test	dl,80h
 18855                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18856 00001F49 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18857 00001F4B F6C210                  	test	dl,10h
 18858                                  	;test	dl,devid_SPECIAL	;AC000;
 18859 00001F4E 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18860                                  
 18861                                  ansicls:
 18862 00001F50 E85200                  	call	ansi_cls		;AN000; clear the screen
 18863 00001F53 EB2C                    	jmp	short cls_ret		;AN000; exit
 18864                                  
 18865                                  ; Get video mode
 18866                                  
 18867                                  cls_normal:				;AC000;
 18868                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18869 00001F55 B40F                    	mov	ah,0Fh
 18870                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18871 00001F57 CD10                    	int	10h
 18872 00001F59 3C03                    	cmp	al,3
 18873                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18874 00001F5B 760A                    	jbe	short DoAlpha
 18875 00001F5D 3C07                    	cmp	al,7
 18876                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18877 00001F5F 7406                    	je	short DoAlpha
 18878                                  
 18879                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18880                                  ; be just as bogus and set the mode that we just got. This will blank the
 18881                                  ; screen too.
 18882                                  
 18883                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18884 00001F61 B400                    	mov	ah,0
 18885                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18886 00001F63 CD10                    	int	10h
 18887 00001F65 EB1A                    	jmp	short cls_ret		;AC000; exit
 18888                                  
 18889                                  DoAlpha:
 18890                                  
 18891                                  ; Get video mode and number of columns to scroll
 18892                                  
 18893                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18894                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18895                                  ;M01   area
 18896                                  ;M01   Commented out code here is the original
 18897                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18898                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18899                                  ;M01	mov	dl,ah
 18900                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18901                                  
 18902                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18903                                  
 18904 00001F67 1E                      	push	ds
 18905                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18906 00001F68 B84000                  	mov	ax,40h
 18907 00001F6B 8ED8                    	mov	ds,ax			;  *			M01
 18908                                  
 18909                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18910 00001F6D 8A164A00                	mov	dl,[4Ah]
 18911                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18912 00001F71 8A368400                	mov	dh,[84h]
 18913 00001F75 1F                      	pop	ds			;			M01
 18914                                  
 18915 00001F76 08F6                    	or	dh,dh			; Q:ZERO		M01
 18916 00001F78 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18917                                  
 18918                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18919                                  	; 25/04/2023
 18920 00001F7A B619                    	mov	dh,25
 18921                                  regcls:
 18922 00001F7C FEC6                    	inc	dh			; height+1		M018
 18923 00001F7E E80100                  	call	reg_cls 		; go clear the screen
 18924                                  cls_ret:
 18925 00001F81 C3                      	retn				; exit
 18926                                  
 18927                                  ; ---------------------------------------------------------------------------
 18928                                  
 18929                                  ; 21/02/2023
 18930                                  %if 0
 18931                                  	; MSDOS 3.3
 18932                                  CLS:
 18933                                  	mov	bx,STDOUT ; 1
 18934                                  	mov	ax,IOCTL*256 ; 4400h
 18935                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18936                                  			; BX = file or device handle
 18937                                  	test	dl,80h	; devid_ISDEV
 18938                                  	jz	short ANSICLS	; If a file put out ANSI
 18939                                  	test	dl,10h  ; devid_SPECIAL
 18940                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18941                                  
 18942                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18943                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18944                                  			; AL = interrupt number
 18945                                  			; Return: ES:BX	= value	of interrupt vector
 18946                                  	mov	dx,es
 18947                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18948                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18949                                  			; AL = interrupt number
 18950                                  			; Return: ES:BX	= value	of interrupt vector
 18951                                  	mov	ax,es
 18952                                  	cmp	dx,ax	; If not default driver, do ANSI
 18953                                  	ja	short ANSICLS
 18954                                  
 18955                                  	mov	ah,0Fh
 18956                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18957                                  			; Return: AH = number of columns on screen
 18958                                  			; AL = current video mode
 18959                                  			; BH = current active display page
 18960                                  	cmp	al,3
 18961                                  	jbe	short DOALPHA
 18962                                  	cmp	al,7
 18963                                  	jz	short DOALPHA
 18964                                  	mov	ah,0
 18965                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18966                                  			; AL = mode
 18967                                  	retn
 18968                                  
 18969                                  DOALPHA:
 18970                                  	mov	ah,0Bh	; Set overscan to black
 18971                                  	xor	bx,bx
 18972                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18973                                  			; BH = 00h, BL = border color
 18974                                  			; BH = 01h, BL = palette (0-3)
 18975                                  	mov	ah,0Fh
 18976                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18977                                  			; Return: AH = number of columns on screen
 18978                                  			; AL = current video mode
 18979                                  			; BH = current active display page
 18980                                  	mov	dl,ah
 18981                                  	dec	dl
 18982                                  	mov	dh,24
 18983                                  	xor	ax,ax
 18984                                  	mov	cx,ax
 18985                                  	mov	bx,700h
 18986                                  	mov	ah,6
 18987                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 18988                                  			; AL = number of lines to scroll window	
 18989                                  			;	(0 = blank whole window)
 18990                                  			; BH = attributes to be	used on	blanked	lines
 18991                                  			; CH,CL	= row,column of	upper left corner of window 
 18992                                  			;	  to scroll
 18993                                  			; DH,DL	= row,column of	lower right corner of window
 18994                                  	xor	dx,dx
 18995                                  	mov	bh,0
 18996                                  	mov	ah,2
 18997                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 18998                                  			; DH,DL	= row,column (0,0 = upper left)
 18999                                  			; BH = page number
 19000                                  	retn
 19001                                  
 19002                                  ANSICLS:
 19003                                  	mov	si,CLSSTRING
 19004                                  	lodsb
 19005                                  	mov	cl,al
 19006                                  	xor	ch,ch
 19007                                  	mov	ah,RAW_CON_IO ; 6
 19008                                  CLRLOOP:
 19009                                  	lodsb
 19010                                  	mov	dl,al
 19011                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 19012                                  			; DL = character <> FFh
 19013                                  			;  Return: ZF set = no character
 19014                                  			;   ZF clear = character recieved, AL = character
 19015                                  	loop	CLRLOOP
 19016                                  	retn
 19017                                  %endif
 19018                                  
 19019                                  ; ---------------------------------------------------------------------------
 19020                                  
 19021                                  ; MSDOS 6.0
 19022                                  
 19023                                  ; ****************************************************************
 19024                                  ; *
 19025                                  ; * ROUTINE:	 REG_CLS
 19026                                  ; *
 19027                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 19028                                  ; *
 19029                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 19030                                  ; *		 DH = NUMBER OF ROWS
 19031                                  ; *
 19032                                  ; * OUTPUT:	 none
 19033                                  ; *
 19034                                  ; ****************************************************************
 19035                                  
 19036                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19037                                  reg_cls:
 19038                                  ; Set overscan to black.
 19039                                  
 19040 00001F82 FECE                    	dec	dh			; decrement rows and columns
 19041 00001F84 FECA                    	dec	dl			;  to zero base
 19042 00001F86 52                      	push	dx			; save rows,columns
 19043                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 19044 00001F87 B40B                    	mov	ah,0Bh
 19045 00001F89 31DB                    	xor	bx,bx
 19046                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19047 00001F8B CD10                    	int	10h
 19048 00001F8D 5A                      	pop	dx			;  restore rows,colums
 19049                                  
 19050 00001F8E 31C0                    	xor	ax,ax			; zero out ax
 19051 00001F90 89C1                    	mov	cx,ax			;  and cx
 19052                                  
 19053                                  ; Scroll active page
 19054                                  
 19055                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 19056 00001F92 B406                    	mov	ah,6
 19057                                  	;mov	bh,video_attribute	; attribute for blank line
 19058 00001F94 B707                    	mov	bh,7
 19059 00001F96 30DB                    	xor	bl,bl			; set BL to 0
 19060                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19061 00001F98 CD10                    	int	10h
 19062                                  
 19063                                  ; Seek to cursor to 0,0
 19064                                  
 19065                                  ;M022 following two lines added
 19066                                  	;mov	ah,get_video_state	; get current video page in BH
 19067 00001F9A B40F                    	mov	ah,0Fh
 19068                                  	;int	video_io_int
 19069 00001F9C CD10                    	int	10h
 19070                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 19071 00001F9E B402                    	mov	ah,2
 19072 00001FA0 31D2                    	xor	dx,dx			; row and column 0
 19073                                  ;M022	mov	bh,0
 19074                                  	;int	video_io_int		; do into 10h - BIOS video IO
 19075 00001FA2 CD10                    	int	10h
 19076                                  
 19077 00001FA4 C3                      	retn
 19078                                  
 19079                                  ; ---------------------------------------------------------------------------
 19080                                  
 19081                                  ; MSDOS 6.0
 19082                                  
 19083                                  ; ****************************************************************
 19084                                  ; *
 19085                                  ; * ROUTINE:	 ANSI_CLS
 19086                                  ; *
 19087                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 19088                                  ; *		 to STDOUT.
 19089                                  ; *
 19090                                  ; * INPUT:	 none
 19091                                  ; *
 19092                                  ; * OUTPUT:	 none
 19093                                  ; *
 19094                                  ; ****************************************************************
 19095                                  
 19096                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19097                                  ansi_cls:			;AC000;
 19098 00001FA5 BE[6782]                	mov	si,CLSSTRING
 19099                                  			; db 4,1Bh,'[2J'
 19100 00001FA8 AC                      	lodsb
 19101 00001FA9 88C1                    	mov	cl,al	; al = 4
 19102 00001FAB 30ED                    	xor	ch,ch
 19103                                  	;mov	ah,Raw_CON_IO
 19104 00001FAD B406                    	mov	ah,6
 19105                                  clrloop:
 19106 00001FAF AC                      	lodsb
 19107 00001FB0 88C2                    	mov	dl,al
 19108 00001FB2 CD21                    	int	21h
 19109                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 19110 00001FB4 E2F9                    	loop	clrloop
 19111 00001FB6 C3                      	retn
 19112                                  
 19113                                  ;============================================================================
 19114                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 19115                                  ;============================================================================
 19116                                  ; 08/10/2018 - Retro DOS v3.0
 19117                                  
 19118                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 19119                                  
 19120                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19121                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 19122                                  
 19123                                  ; ---------------------------------------------------------------------------
 19124                                  
 19125                                  ; ****************************************************************
 19126                                  ; *
 19127                                  ; * ROUTINE:	 CTTY - Change console
 19128                                  ; *
 19129                                  ; * SYNTAX:	 CTTY device
 19130                                  ; *
 19131                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 19132                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 19133                                  ; *		 STDERR. This routine returns to LODCOM1.
 19134                                  ; *
 19135                                  ; * INPUT:	 command line at offset 81H
 19136                                  ; *
 19137                                  ; * OUTPUT:	 none
 19138                                  ; *
 19139                                  ; ****************************************************************
 19140                                  
 19141                                  	; 21/02/2023 - Retro DOS v4.0
 19142                                  	; 10/06/2023
 19143                                  CTTY:
 19144                                  	; MSDOS 6.0
 19145 00001FB7 1E                      	push	ds			;AN000; Get local ES
 19146 00001FB8 07                      	pop	es			;AN000;
 19147 00001FB9 BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 19148 00001FBC BF[7B85]                	mov	di,PARSE_CTTY
 19149                                  					;AC000; Get address of PARSE_CTTY
 19150 00001FBF 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 19151 00001FC1 31D2                    	xor	dx,dx			;AC000;
 19152 00001FC3 E85523                  	call	cmd_parse		;AC000; call parser
 19153                                  
 19154                                  	;cmp	ax,-1 ; 0FFFFh
 19155                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19156                                  	;je	short ctty_error	;AN000; yes - error
 19157                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 19158                                  	;and	ax,ax ; ax > 0 ?
 19159                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 19160                                  	; 10/06/2023
 19161 00001FC6 40                      	inc	ax  ; cmp ax,-1
 19162 00001FC7 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 19163 00001FC9 48                      	dec	ax  ; cmp ax,0
 19164 00001FCA 7531                    	jnz	short ctty_error  ; 1 -> 0
 19165                                  	; ax = 0
 19166                                  
 19167 00001FCC 56                      	push	si			;AN000; save position in line
 19168 00001FCD C536[5395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19169 00001FD1 BF[908C]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 19170                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 19171 00001FD4 AC                      	lodsb				;AN000; get a char from buffer
 19172 00001FD5 AA                      	stosb				;AN000; store in srcbuf
 19173                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 19174 00001FD6 08C0                    	or	al,al ; al = 0 ?
 19175 00001FD8 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 19176                                  					;AN000; no - keep moving
 19177 00001FDA 5E                      	pop	si			;AN000; get line position back
 19178 00001FDB BF[7B85]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 19179 00001FDE E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 19180                                  	;jz	short nocolon 		;AN000; yes - continue
 19181                                  	; 21/02/2023
 19182 00001FE1 751A                    	jnz	short ctty_error
 19183                                  ;ctty_error:
 19184                                  	;jmp	short isbaddev		;AC000; yes - exit
 19185                                  
 19186                                  	; 21/02/2023
 19187                                  	; MSDOS 3.3
 19188                                  	;call	SETPATH
 19189                                  	;dec	si
 19190                                  	;dec	si
 19191                                  	;cmp	byte [si],':'
 19192                                  	;jnz	short NOCOLON
 19193                                  	;mov	byte [si],0
 19194                                  nocolon:
 19195                                  	; 21/02/2023
 19196                                  	; MSDOS 6.0
 19197 00001FE3 BA[908C]                	mov	dx,SrcBuf
 19198                                  ;NOCOLON:
 19199                                  	; MSDOS 3.3 & MSDOS 6.0
 19200                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 19201                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 19202 00001FE6 B8023D                  	mov	ax,3D02h ; 21/02/2023
 19203 00001FE9 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 19204                                  			; DS:DX	-> ASCIZ filename
 19205                                  			; AL = access mode
 19206                                  			; 2 - read & write
 19207 00001FEB 7210                    	jc	short isbaddev
 19208 00001FED 89C3                    	mov	bx,ax
 19209                                  	;mov	ax,IOCTL*256 ; 4400h
 19210 00001FEF B80044                  	mov	ax,4400h
 19211 00001FF2 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 19212                                  			; BX = file or device handle
 19213 00001FF4 F6C280                  	test	dl,80h
 19214 00001FF7 750C                    	jnz	short devisok
 19215                                  closedev:
 19216                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 19217 00001FF9 B43E                    	mov	ah,3Eh
 19218 00001FFB CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19219                                  			; BX = file handle
 19220                                  ctty_error:
 19221                                  isbaddev:
 19222 00001FFD BA[5780]                	mov	dx,BADDEV_PTR
 19223 00002000 E8CE2D                  	call	std_printf
 19224 00002003 EB40                    	jmp	short resret
 19225                                  
 19226                                  	;nop
 19227                                  devisok:
 19228                                  	; 21/02/2023
 19229                                  	; MSDOS 6.0
 19230 00002005 52                      	push	dx		;AN007; save device info
 19231                                  	; 08/06/2023 (BugFix)
 19232 00002006 A1[DB80]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 19233                                  	;mov	dh,util_msg_class
 19234 00002009 B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 19235 0000200B 53                      	push	bx		;AN021; save handle
 19236 0000200C E8A52E                  	call	TSYSGETMSG	;AN021; get the address of the message
 19237 0000200F 89F2                    	mov	dx,si		;AN021; get address into dx
 19238                                  	;mov	ax,(Write shl 8)
 19239 00002011 B80040                  	mov	ax,4000h	;AN007; write to device
 19240 00002014 B90200                  	mov	cx,2		;AN007; write two bytes
 19241 00002017 CD21                    	int	21h		;AN007;
 19242 00002019 5B                      	pop	bx		;AN021; get back handle
 19243 0000201A 5A                      	pop	dx		;AN007; get back device info
 19244 0000201B 72DC                    	jc	short closedev	;AN007; if error, quit
 19245                                  
 19246                                  	; MSDOS 3.3 & MSDOS 6.0
 19247 0000201D 30F6                    	xor	dh,dh
 19248 0000201F 80CA03                  	or	dl,3
 19249                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 19250                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 19251 00002022 B80144                  	mov	ax,4401h
 19252 00002025 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 19253                                  			; BX = device handle,DH = 0
 19254                                  			; DL = device information to set 
 19255                                  			;	(bits 0-7 from	function 0)
 19256 00002027 53                      	push	bx
 19257 00002028 B90300                  	mov	cx,3
 19258 0000202B 31DB                    	xor	bx,bx
 19259                                  iclloop:			; Close basic handles
 19260                                  	;mov	ah,CLOSE ; 3Eh
 19261 0000202D B43E                    	mov	ah,3Eh
 19262 0000202F CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19263                                  			; BX = file handle
 19264 00002031 43                      	inc	bx
 19265 00002032 E2F9                    	loop	iclloop
 19266 00002034 5B                      	pop	bx		; Get handle
 19267                                  	;mov	ah,XDUP ; 45h
 19268 00002035 B445                    	mov	ah,45h
 19269 00002037 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19270                                  			; BX = file handle to duplicate
 19271                                  	;mov	ah,XDUP ; 45h
 19272 00002039 B445                    	mov	ah,45h
 19273 0000203B CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19274                                  			; BX = file handle to duplicate
 19275                                  	;mov	ah,XDUP ; 45h
 19276 0000203D B445                    	mov	ah,45h
 19277 0000203F CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19278                                  			; BX = file handle to duplicate
 19279                                  	;mov	ah,CLOSE ; 3Eh
 19280 00002041 B43E                    	mov	ah,3Eh
 19281 00002043 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19282                                  			; BX = file handle
 19283                                  resret:
 19284 00002045 8E1E[A58A]              	mov	ds,[RESSEG]
 19285 00002049 1E                      	push	ds
 19286                                  	;mov	ax,[18h]
 19287 0000204A A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 19288 0000204D A3[8A01]                	mov	[Io_Save],ax
 19289                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 19290                                  	;;mov	ax,LODCOM1
 19291                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 19292                                  	;mov	ax,175h ; MSDOS 6.0
 19293 00002050 B8[7400]                	mov	ax,TrnLodCom1_Trap
 19294 00002053 50                      	push	ax
 19295                                  
 19296 00002054 CB                      	retf		; Far return
 19297                                  
 19298                                  ; ---------------------------------------------------------------------------
 19299                                  
 19300                                  ;****************************************************************
 19301                                  ;*
 19302                                  ;* ROUTINE:	CHCP - Change code page internal command
 19303                                  ;*		(added DOS 3.30 07/21/86)
 19304                                  ;*
 19305                                  ;* SYNTAX:	CHCP [xxx]
 19306                                  ;*		where xxx is a valid code page
 19307                                  ;*
 19308                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 19309                                  ;*		6402H to set the code page to xxxx. If no parameters
 19310                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19311                                  ;*		to get global code page and display it to the user.
 19312                                  ;*
 19313                                  ;* INPUT:	command line at offset 81H
 19314                                  ;*
 19315                                  ;* OUTPUT:	none
 19316                                  ;*
 19317                                  ;****************************************************************
 19318                                  
 19319                                  NLSFUNC_installed equ  0FFh
 19320                                  set_global_cp	  equ  2
 19321                                  get_global_cp	  equ  1
 19322                                  
 19323                                  	; 21/02/2023 - Retro DOS v4.0
 19324                                  	; 09/06/2023
 19325                                  	; 10/06/2023
 19326                                  CHCP:
 19327                                  	; MSDOS 6.0
 19328 00002055 1E                      	push	ds		;AN000; Get local ES
 19329 00002056 07                      	pop	es		;AN000;
 19330 00002057 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19331 0000205A BF[9284]                	mov	di,PARSE_CHCP
 19332                                  				;AN000; Get address of PARSE_CHCP
 19333 0000205D 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19334 0000205F 31D2                    	xor	dx,dx		;AC000;
 19335 00002061 E85301                  	call    Parse_With_Msg	;AC018; call parser
 19336                                  
 19337                                  	;cmp	ax,-1
 19338                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19339                                  	;;jne	short setcp	;AC000; no go get number & set code page
 19340                                  	;je	short getcp	;AC000; yes - no parm - get code page
 19341                                  ;setcp:
 19342                                  	;;cmp	ax,0
 19343                                  	;;cmp	ax,RESULT_NO_ERROR
 19344                                  	;			;AN000; did we have an error?
 19345                                  	;;jne	short cp_error	;AC018; yes - go issue message
 19346                                  	;and	ax,ax ; ax > 0 ?
 19347                                  	;jnz	short cp_error	
 19348                                  	; 10/06/2023
 19349 00002064 40                      	inc	ax  ; cmp ax,-1	
 19350 00002065 745C                    	jz	short getcp ; 0FFFFh -> 0
 19351 00002067 48                      	dec	ax  ; cmp ax,0
 19352 00002068 7556                    	jnz	short cp_error ; 1 -> 0
 19353                                  	; ax = 0
 19354                                  
 19355                                  	;;push	cx		;AN000; save positional count
 19356                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 19357                                  	;;mov	cx,[bx]		;AN000;  into cx
 19358                                  	;;mov	[system_cpage],cx
 19359                                  	;			;AN000; save user input number
 19360                                  	;;pop	cx		;AC000; restore positional count
 19361                                  	;; 21/02/2023
 19362                                  	;mov	di,[bx]
 19363                                  	;mov	[system_cpage],di
 19364                                  	; 09/06/2023	
 19365 0000206A 8B1E[5395]              	mov	bx,[PARSE1_ADDR]
 19366 0000206E 891E[0B8C]              	mov	[system_cpage],bx
 19367                                  	;
 19368 00002072 BF[9284]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19369 00002075 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 19370 00002078 7546                    	jnz	short cp_error	;AC000; no - exit
 19371                                  okset:
 19372                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19373                                  	;mov	ah,14h
 19374                                  	;mov	al,0		;AN000;
 19375 0000207A B80014                  	mov	ax,1400h
 19376 0000207D CD2F                    	int	2Fh		;AN000;
 19377                                  	;cmp	al,0FFh
 19378 0000207F 3CFF                    	cmp	al,NLSFUNC_installed
 19379                                  				;AN000;
 19380 00002081 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19381 00002083 BA[857F]                	mov	dx,NLSFUNC_PTR
 19382                                  				;AN000; no - set up error message
 19383 00002086 EB38                    	jmp	short cp_error	;AN000; error exit
 19384                                  
 19385                                  ; 21/02/2023
 19386                                  %if 0
 19387                                  	; MSDOS 3.3
 19388                                  	mov	si,81h
 19389                                  	call	SCANOFF
 19390                                  	cmp	al,0Dh ; CR
 19391                                  	jnz	short SETCP
 19392                                  	jmp	short GETCP
 19393                                  
 19394                                  	;nop
 19395                                  SETCP:
 19396                                  	xor	bx,bx
 19397                                  	mov	cx,bx
 19398                                  	mov	ax,bx
 19399                                  GET_CP_DIGIT:
 19400                                  	lodsb
 19401                                  	cmp	al,'0'
 19402                                  	jb	short CHRNOTNUMBER
 19403                                  	cmp	al,'9'
 19404                                  	ja	short CHRNOTNUMBER
 19405                                  	sub	al,'0'
 19406                                  	inc	cl
 19407                                  	cmp	cl,4
 19408                                  	ja	short CHCP_BADPARM
 19409                                  	mov	dx,bx
 19410                                  	shl	dx,1
 19411                                  	shl	dx,1
 19412                                  	add	bx,dx
 19413                                  	shl	bx,1
 19414                                  	add	bx,ax
 19415                                  	jmp	short GET_CP_DIGIT
 19416                                  CP_NEXTCHR:
 19417                                  	lodsb
 19418                                  CHRNOTNUMBER:
 19419                                  	cmp	al,' '		; SPACE
 19420                                  	jz	short CP_NEXTCHR
 19421                                  	cmp	al,9		; TAB
 19422                                  	jz	short CP_NEXTCHR
 19423                                  	cmp	al,0Dh		; CR
 19424                                  	jz	short SET_CP_TBL_NUM
 19425                                  CHCP_BADPARM:
 19426                                  	mov	dx,BADPARMPTR
 19427                                  	jmp	CERROR
 19428                                  ;GOT_NLS:
 19429                                  %endif
 19430                                  	; 21/02/2023
 19431                                  got_NLS:
 19432                                  	; MSDOS 6.0
 19433 00002088 8B1E[0B8C]              	mov	bx,[system_cpage]
 19434                                  				;AN000; get user input code page
 19435                                  ;SET_CP_TBL_NUM:
 19436                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19437                                  	;
 19438                                  	; MSDOS 3.3 & MSDOS 6.0
 19439                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19440                                  	;mov	ah,66h
 19441                                  	;;mov	al,set_global_cp 
 19442                                  	;mov	al,2		;minor - set
 19443                                  	; 26/04/2023
 19444 0000208C B80266                  	mov	ax,6602h
 19445 0000208F CD21                    	int	21h
 19446                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19447                                  		; BX = active code page
 19448                                  		; DX = system code page (active page at boot time)
 19449                                  
 19450 00002091 733F                    	jnc	short chcp_return
 19451                                  				;no error - exit
 19452                                  
 19453 00002093 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19454 00002096 7515                    	jnz	short chcp_other_error
 19455                                  
 19456                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19457 00002098 B459                    	mov	ah,59h
 19458 0000209A 31DB                    	xor	bx,bx
 19459 0000209C CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19460                                  			; BX = version code (0000h for DOS 3.x)
 19461                                  
 19462 0000209E 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19463 000020A1 7505                    	jne	short no_countrysys ; 26/04/2023
 19464                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19465 000020A3 BA[887F]                	mov	dx,INV_CODE_PAGE
 19466                                  	;jmp	cerror
 19467 000020A6 EB18                    	jmp	short cp_error
 19468                                  
 19469                                  	; 21/02/2023
 19470                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19471                                  no_countrysys:
 19472                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19473                                  ;					;AN000; set up extended error msg class
 19474                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19475                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19476                                  					;AN000; get message number in control block
 19477 000020A8 BA[6981]                	mov	dx,NoCntry_Ptr
 19478 000020AB EB13                    	jmp	short cp_error
 19479                                  
 19480                                  chcp_other_error:		; end of p716
 19481                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19482 000020AD B459                    	mov	ah,59h
 19483 000020AF 31DB                    	xor	bx,bx
 19484 000020B1 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19485                                  			; BX = version code (0000h for DOS 3.x)
 19486 000020B3 83F841                  	cmp	ax,65		;was it access denied?
 19487 000020B6 7505                    	jne	short none_set	;no - assume all failed
 19488 000020B8 BA[697F]                	mov	dx,cp_not_all_ptr
 19489                                  				;set up message
 19490                                  	;jmp	cerror		;AC000; error exit
 19491 000020BB EB03                    	jmp     short cp_error
 19492                                  none_set:
 19493 000020BD BA[5B7F]                	mov	dx,cp_not_set_ptr
 19494                                  				;set up message
 19495                                  cp_error:
 19496 000020C0 E98D08                  	jmp	cerror		;exit
 19497                                  getcp:
 19498                                  	;;mov	ah,GETSETCDPG ; 66h
 19499                                  	;mov	ah,66h		;get/set global code page function	
 19500                                  	;;mov	al,get_global_cp ; 1
 19501                                  	;mov	al,1		;minor - get
 19502                                  	; 26/04/2023
 19503 000020C3 B80166                  	mov	ax,6601h
 19504 000020C6 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19505 000020C8 891E[0B8C]              	mov	[system_cpage],bx
 19506                                  				;get active cp for output
 19507 000020CC BA[777F]                	mov	dx,cp_active_ptr
 19508 000020CF E8FF2C                  	call	std_printf	;print it out
 19509                                  chcp_return:
 19510 000020D2 C3                      	retn
 19511                                  
 19512                                  ; ---------------------------------------------------------------------------
 19513                                  
 19514                                  ; ****************************************************************
 19515                                  ; *
 19516                                  ; * ROUTINE:	 TRUENAME
 19517                                  ; *
 19518                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19519                                  ; *		 Parses the command line. If a path is found, set
 19520                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19521                                  ; *		 set SRCXNAME to the drive letter. If no path
 19522                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19523                                  ; *		 current directory. Use the NAME TRANSLATE system
 19524                                  ; *		 call to get the real name and  then display the 
 19525                                  ; *		 real name. If an error occurs issue an error
 19526                                  ; *		 message and transfer control to  CERROR.
 19527                                  ; *
 19528                                  ; * INPUT:	 command line at offset 81H
 19529                                  ; *
 19530                                  ; * OUTPUT:	 none
 19531                                  ; *
 19532                                  ; ****************************************************************
 19533                                  
 19534                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19535                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19536                                  	; 10/06/2023
 19537                                  TRUENAME:				;AN000; TRUENAME entry point
 19538 000020D3 1E                      	push	ds			;AN000; Get local ES
 19539 000020D4 07                      	pop	es			;AN000;
 19540 000020D5 BE8100                  	mov	si,81h			;AN000; Get command line
 19541 000020D8 BF[F084]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19542 000020DB 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19543 000020DD 31D2                    	xor	dx,dx			;AN000;
 19544 000020DF E8D500                  	call	Parse_With_Msg		;AC018; call parser
 19545                                  
 19546 000020E2 BF[D387]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19547                                  	;cmp	ax,0FFFFh
 19548                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19549                                  	;je	short tn_eol		;AN000; yes - go process
 19550                                  	;; 22/02/2023
 19551                                  	;;cmp	ax,0
 19552                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19553                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 19554                                  	;and	ax,ax ; ax = 0 ?
 19555                                  	;jnz	short tn_parse_error ; no, parse error
 19556                                  	; 10/06/2023
 19557 000020E5 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 19558 000020E6 7433                    	jz	short tn_eol ; ah = 0 ; *
 19559 000020E8 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 19560 000020E9 752D                    	jnz	short tn_parse_error
 19561                                  
 19562                                  	;cmp	byte [PARSE1_TYPE],6
 19563 000020EB 803E[4F95]06            	cmp	byte [PARSE1_TYPE],result_drive
 19564                                  					;AN000; was a drive entered?
 19565                                  	;je	short tn_drive		;AN000; yes - go process
 19566                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19567                                  	; 23/02/2023
 19568 000020F0 7512                    	jne	short tn_filespec
 19569                                  
 19570                                  ;tn_eol: 
 19571                                  ;	;mov	ah,0			;AN000; no parameters on line
 19572                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19573                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19574                                  ;	mov	al,'.'
 19575                                  ;	stosw				;AN000; store in srcxname
 19576                                  ;	jmp	short tn_doit		;AN000; go do command
 19577                                  
 19578                                  tn_drive:				;AN000; a drive was entered
 19579 000020F2 56                      	push	si			;AN000; save position in line
 19580 000020F3 BE[5395]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19581 000020F6 AC                      	lodsb				;AN000; get the drive number
 19582 000020F7 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19583 000020F9 AA                      	stosb				;AN000; store it in srcxname
 19584                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19585 000020FA B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19586 000020FD AB                      	stosw				;AN000;  store in srcxname
 19587                                  	;mov	al,0
 19588 000020FE B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19589 00002100 AA                      	stosb				;AN000;
 19590 00002101 5E                      	pop	si			;AN000; get line position back
 19591 00002102 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19592                                  
 19593                                  tn_filespec:				;AN000; a filespec was entered
 19594 00002104 56                      	push	si			;AN000; save position in line
 19595 00002105 C536[5395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19596                                  
 19597                                  tn_move_filename:			;AN000; put filespec in srcxname
 19598 00002109 AC                      	lodsb				;AN000; get a char from buffer
 19599 0000210A AA                      	stosb				;AN000; store in srcxname
 19600                                  	;;cmp	al,0
 19601                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19602 0000210B 08C0                    	or	al,al ; al = 0 ?
 19603 0000210D 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19604 0000210F 5E                      	pop	si			;AN000; get line position back
 19605                                  
 19606                                  tn_check_eol:				;AN000; make sure no extra parms
 19607 00002110 BF[F084]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19608 00002113 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19609 00002116 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 19610                                  tn_parse_error: 			;AN000; A parse error occurred
 19611 00002118 E93508                  	jmp	cerror			;AN000; Go to error routine
 19612                                  
 19613                                  tn_eol: 
 19614                                  	;23/02/2023
 19615                                  	;;mov	ah,0			;AN000; no parameters on line
 19616                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19617                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19618                                  	;mov	al,'.'
 19619                                  	; 10/06/2023
 19620                                  	;mov	ax,002Eh
 19621                                  	; ah = 0 ; *
 19622 0000211B B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 19623                                  	;
 19624 0000211D AB                      	stosw				;AN000; store in srcxname
 19625                                  	; 23/02/2023
 19626                                  	;jmp	short tn_doit		;AN000; go do command
 19627                                  
 19628                                  tn_doit:				;AN000;
 19629 0000211E BE[D387]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19630 00002121 BF[0489]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19631                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19632 00002124 B460                    	mov	ah,60h
 19633 00002126 CD21                    	int	21h			;AN000;
 19634 00002128 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19635                                  
 19636 0000212A E8B3FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19637 0000212D C706[118C][D387]        	mov	word [string_ptr_2],SRCXNAME
 19638                                  					;AN000; get address of failed string
 19639                                  	;mov	byte [extend_buf_sub],1
 19640 00002133 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 19641                                  					;AN000; put number of subst in control block
 19642 00002138 E91508                  	jmp	cerror			;AN000; Go to error routine
 19643                                  
 19644                                  tn_print_xname: 			;AN000;
 19645 0000213B C706[118C][0489]        	mov	word [string_ptr_2],COMBUF
 19646                                  					;AN000; Set up address of combuf
 19647 00002141 BA[C380]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19648 00002144 E88804                  	call	CRLF2			;AN000; print a crlf
 19649                                  	;call	Printf_Crlf		;AN000; print it out
 19650                                  	;retn				;AN000;
 19651                                  	; 23/02/2023
 19652 00002147 E9792C                  	jmp	Printf_Crlf
 19653                                  
 19654                                  ; ---------------------------------------------------------------------------
 19655                                  
 19656                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19657                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19658                                  _$EXIT:
 19659                                  	; MSDOS 6.0
 19660 0000214A 1E                      	push	ds			;AN000; save data segment
 19661 0000214B 8E1E[A58A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19662                                  	;assume	ds:resgroup		;AN000;
 19663                                  
 19664 0000214F 803E[8D01]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19665 00002154 740A                    	jz	short free_com		;AN045; no - free everything
 19666                                  
 19667                                  ;	We're a permanent command.
 19668                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19669                                  
 19670 00002156 833E[8E01]FF            	cmp	word [SingleCom],-1	;M034
 19671 0000215B 7412                    	je	short no_reset		;M034 ; exit singlecom
 19672 0000215D E9A4DF                  	jmp	TCOMMAND		;permanent command, recycle
 19673                                  
 19674                                  free_com:
 19675                                  	;mov	ax,(multdos shl 8 or message_2f)
 19676 00002160 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19677                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19678 00002163 B205                    	mov	dl,5
 19679 00002165 8B3E[A301]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19680 00002169 8E06[A501]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19681 0000216D CD2F                    	int	2Fh			;AN000; go set it
 19682                                  no_reset:				;AN045;
 19683 0000216F 1F                      	pop	ds			;AN000; restore local data segment
 19684                                  	;assume	ds:trangroup		;AN000;
 19685                                  ;M040
 19686                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19687                                  ;this, restores user dir if flag is set and resets the flag.
 19688                                  
 19689                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19690 00002170 E80C03                  	call	RestUDir1
 19691 00002173 8E06[A58A]              	mov	es,[RESSEG]
 19692                                  	;assume	es:resgroup
 19693                                  
 19694 00002177 26A1[2901]              	mov	ax,[es:Parent]
 19695                                  	;mov	[es:16h],ax
 19696                                  	;mov	[es:PDB_Parent_PID],ax
 19697 0000217B 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19698 0000217F 26A1[2B01]              	mov	ax,[es:OldTerm]
 19699                                  	;mov	[es:0Ah],ax
 19700                                  	;mov	[es:PDB_Exit],ax
 19701 00002183 26A30A00                	mov	[es:PDB.EXIT],ax
 19702 00002187 26A1[2D01]              	mov	ax,[es:OldTerm+2]
 19703                                  	;mov	[es:0Ch],ax
 19704                                  	;mov	[es:PDB_Exit+2],ax
 19705 0000218B 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19706                                  
 19707 0000218F 06                      	push	es
 19708 00002190 8E06[B38A]              	mov	es,[TRAN_TPA]
 19709                                  	;mov	ah,DEALLOC
 19710 00002194 B449                    	mov	ah,49h
 19711 00002196 CD21                    	int	21h			; Now running in "free" space
 19712 00002198 07                      	pop	es
 19713                                  
 19714                                  	;mov	ah,Exit
 19715 00002199 B44C                    	mov	ah,4Ch
 19716                                  	;mov	al,byte ptr RetCode
 19717 0000219B 26A0[8501]              	mov	al,[es:RetCode]
 19718 0000219F CD21                    	int	21h
 19719                                  
 19720                                  	;..........
 19721                                  
 19722                                  ; 23/02/2023
 19723                                  %if 0
 19724                                  _$EXIT:
 19725                                  	; MSDOS 3.3
 19726                                  	mov	es,[RESSEG]
 19727                                  	mov	ax,[es:PARENT]
 19728                                  	;mov	[es:16h],ax
 19729                                  	mov	[es:PDB.PARENT_PID],ax
 19730                                  	mov	ax,[es:OLDTERM]
 19731                                  	;mov	[es:0Ah],ax
 19732                                  	mov	[es:PDB.EXIT],ax
 19733                                  	mov	ax,[es:OLDTERM+2]
 19734                                  	;mov	[es:0Ch],ax
 19735                                  	mov	[es:PDB.EXIT+2],ax
 19736                                  	push	es
 19737                                  	mov	es,[TRAN_TPA]
 19738                                  	mov	ah,DEALLOC ; 49h
 19739                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19740                                  			; ES = segment address of area to be freed
 19741                                  	pop	es
 19742                                  	mov	ah,EXIT ; 4Ch
 19743                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19744                                  	mov	al,byte [es:RETCODE]
 19745                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19746                                  ;;here:
 19747                                  ;;	jmp	short here
 19748                                  %endif
 19749                                  
 19750                                  ; ---------------------------------------------------------------------------
 19751                                  
 19752                                  ; MSDOS 6.0
 19753                                  ; ****************************************************************
 19754                                  ; *
 19755                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19756                                  ; *
 19757                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19758                                  ; *		 If not end of line, set up to print parse
 19759                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19760                                  ; *		 EXPECTED!
 19761                                  ; *
 19762                                  ; * INPUT:	 DS:SI	  last output from parser
 19763                                  ; *		 ES:DI	  points to parse block
 19764                                  ; *		 CX	  last output from parser
 19765                                  ; *
 19766                                  ; * OUTPUT:	 AX	  parser return code
 19767                                  ; *
 19768                                  ; *		 if end of line found
 19769                                  ; *		     zero flag set
 19770                                  ; *		 else
 19771                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19772                                  ; *
 19773                                  ; ****************************************************************
 19774                                  
 19775                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19776                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19777                                  
 19778                                  parse_check_eol:
 19779 000021A1 31D2                    	xor	dx,dx			;AN000;
 19780 000021A3 8936[098C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19781 000021A7 E87121                  	call	cmd_parse		;AN000; call parser
 19782 000021AA 3CFF                    	cmp	al,-1 ; 0FFh
 19783                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19784 000021AC 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19785                                  	;cmp	ax,0
 19786                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19787 000021AE 21C0                    	and	ax,ax ; ax = 0 ?
 19788 000021B0 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19789 000021B2 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19790                                  ok_to_setup_pmsg:
 19791 000021B3 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19792                                  parse_good_eol:
 19793                                  parse_msg_good:	; 23/02/2023
 19794 000021B6 C3                      	retn				;AN000;
 19795                                  
 19796                                  ; ---------------------------------------------------------------------------
 19797                                  
 19798                                  ; MSDOS 6.0
 19799                                  ; ****************************************************************
 19800                                  ; *
 19801                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19802                                  ; *
 19803                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19804                                  ; *		 message is set up.
 19805                                  ; *
 19806                                  ; * INPUT:	 DS:SI	  last output from parser
 19807                                  ; *		 ES:DI	  points to parse block
 19808                                  ; *		 CX	  last output from parser
 19809                                  ; *
 19810                                  ; * OUTPUT:	 AX	  parser return code
 19811                                  ; *
 19812                                  ; *		 if no error
 19813                                  ; *		     outputs from parser
 19814                                  ; *		 else
 19815                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19816                                  ; *		     error message set up for STD_PRINTF
 19817                                  ; *
 19818                                  ; ****************************************************************
 19819                                  
 19820                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19821                                  Parse_With_Msg:
 19822 000021B7 8936[098C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19823 000021BB E85D21                  	call	cmd_parse		;AN018; call parser
 19824 000021BE 3CFF                    	cmp	al,-1 ; 0FFh
 19825                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19826 000021C0 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19827                                  	;cmp	ax,0
 19828                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19829 000021C2 09C0                    	or	ax,ax ; ax = 0 ?
 19830 000021C4 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19831                                  	; 23/02/2023
 19832                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19833                                  ;parse_msg_good:
 19834                                  	;retn				;AN018;
 19835                                  	; 23/02/2023
 19836                                  	;jmp	short setup_parse_error_msg	
 19837                                  
 19838                                  ; ---------------------------------------------------------------------------
 19839                                  
 19840                                  ; MSDOS 6.0
 19841                                  ; ****************************************************************
 19842                                  ; *
 19843                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19844                                  ; *
 19845                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19846                                  ; *		 message is set up.
 19847                                  ; *
 19848                                  ; * INPUT:	 AX	     Parse error number
 19849                                  ; *		 SI	     Set to past last parameter
 19850                                  ; *		 Parse_last  Set to start of last parameter
 19851                                  ; *
 19852                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19853                                  ; *		 error message set up for STD_PRINTF
 19854                                  ; *
 19855                                  ; ****************************************************************
 19856                                  
 19857                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19858                                  setup_parse_error_msg:
 19859 000021C6 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 19860                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19861 000021CB BA[FC7E]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19862 000021CE C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19863                                  					;AC018; terminate the parameter string
 19864 000021D1 A3[FC7E]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19865 000021D4 83F802                  	cmp	ax,2
 19866                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19867 000021D7 740D                    	je	short setup_parse_msg_ret
 19868                                  					;AN018;    no subst
 19869 000021D9 8B36[098C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19870 000021DD 8936[118C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19871 000021E1 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 19872                                  					;AC018; put number of subst in control block
 19873                                  	;mov	byte [extend_buf_sub],1
 19874                                  setup_parse_msg_ret:
 19875 000021E6 46                      	inc	si			;AN018; make sure zero flag not set
 19876 000021E7 C3                      	retn				;AC018;
 19877                                  
 19878                                  ;============================================================================
 19879                                  ; TENV.ASM, MSDOS 6.0, 1991
 19880                                  ;============================================================================
 19881                                  ; 08/10/2018 - Retro DOS v3.0
 19882                                  
 19883                                  ; TITLE	Part6 COMMAND Transient routines.
 19884                                  
 19885                                  ;	Environment utilities and misc. routines
 19886                                  
 19887                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19888                                  
 19889                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19890                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19891                                  
 19892                                  ; ---------------------------------------------------------------------------
 19893                                  
 19894                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19895                                  ADD_PROMPT:
 19896 000021E8 E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19897 000021EB E8AD01                  	call	scan_double_null
 19898                                  
 19899                                  ADD_PROMPT2:
 19900 000021EE 56                      	push	si
 19901 000021EF E89B01                  	call	GETARG
 19902 000021F2 5E                      	pop	si
 19903 000021F3 7501                    	jnz	short ADD_PROMPT3
 19904                                  ADD_PROMPT_RETN:
 19905 000021F5 C3                      	retn
 19906                                  ADD_PROMPT3:			; Pre scan for arguments
 19907 000021F6 E87501                  	call	move_name	; Move in name
 19908 000021F9 E89101                  	call	GETARG
 19909 000021FC 56                      	push	si
 19910 000021FD EB53                    	jmp	short ADD_NAME
 19911                                  
 19912                                  ;break	The SET command
 19913                                  
 19914                                  ; Input: DS:SI points to a CR terminated string
 19915                                  ; Output: carry flag is set if no room
 19916                                  ;	  otherwise name is added to environment
 19917                                  
 19918                                  DISP_ENVJ:
 19919 000021FF E9BC00                  	jmp	DISP_ENV
 19920                                  
 19921                                  ADD_NAME_TO_ENVIRONMENT:
 19922 00002202 E88801                  	call	GETARG
 19923 00002205 74F8                    	jz	short DISP_ENVJ
 19924                                  
 19925                                  ; check if line contains exactly one equals sign
 19926                                  
 19927 00002207 31DB                    	xor	bx,bx		; = count is 0
 19928 00002209 56                      	push	si		; Save pointer to beginning of line
 19929                                  EQLP:
 19930 0000220A AC                      	lodsb			; Get a char
 19931 0000220B 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19932 0000220D 740F                    	je	short QUEQ	
 19933 0000220F 3C3D                    	cmp	al,'='		; Look for = sign	
 19934 00002211 75F7                    	jne	short EQLP	; not there, get next char
 19935 00002213 FEC3                    	inc	bl		; Otherwise increment EQ count
 19936 00002215 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19937 00002218 75F0                    	jne	short EQLP
 19938 0000221A FEC7                    	inc	bh		; Set BH=1 means no parameters
 19939 0000221C EBEC                    	jmp	short EQLP	; And look for more
 19940                                  QUEQ:
 19941 0000221E 5E                      	pop	si		; Restore beginning of line
 19942 0000221F FECB                    	dec	bl		; Zero flag means only one EQ
 19943 00002221 7406                    	jz	short ONEQ	; Good line
 19944 00002223 BA[947F]                	mov	dx,SYNTMES_PTR
 19945 00002226 E92707                  	jmp	cerror
 19946                                  ONEQ:
 19947 00002229 53                      	push	bx
 19948 0000222A E8BD00                  	call	delete_name_in_environment
 19949 0000222D 5B                      	pop	bx
 19950 0000222E FECF                    	dec	bh
 19951 00002230 74C3                    	jz	short ADD_PROMPT_RETN
 19952 00002232 E86601                  	call	scan_double_null
 19953 00002235 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19954 00002237 E83401                  	call	move_name
 19955 0000223A 56                      	push	si
 19956 0000223B 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19957                                  				;  env var name
 19958                                  		
 19959                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19960                                  ; necessary in the resident for re-reading the transient. Let's look for
 19961                                  ; COMSPEC=
 19962                                  
 19963 0000223D C606[4284]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19964 00002242 BE[7881]                	mov	si,COMSPECSTR ; "COMSPEC="
 19965 00002245 B90400                  	mov	cx,4
 19966 00002248 F3A7                    	repe	cmpsw
 19967 0000224A 7504                    	jnz	short NOT_COMSPEC
 19968                                  				; Zero set => exact match
 19969 0000224C FE06[4284]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19970                                  	;mov	byte [COMSPEC_FLAG],1
 19971                                  NOT_COMSPEC:
 19972 00002250 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19973                                  ADD_NAME:
 19974 00002252 5E                      	pop	si		; Add the value of the new env var
 19975 00002253 56                      	push	si		;  to the environment.
 19976                                  ADD_NAME1:
 19977 00002254 AC                      	lodsb
 19978 00002255 3C0D                    	cmp	al,13 ; 0Dh
 19979 00002257 7405                    	je	short ADD_NAME_RET
 19980 00002259 E8AD01                  	call	store_char
 19981 0000225C EBF6                    	jmp	short ADD_NAME1
 19982                                  ADD_NAME_RET:
 19983 0000225E 5E                      	pop	si
 19984 0000225F 803E[4284]00            	cmp	byte [comspec_flag],0
 19985                                  				; If the new env var is comspec,	
 19986                                  ADD_NAME_JZ_RET:
 19987 00002264 748F                    	jz	short ADD_PROMPT_RETN 
 19988                                  				;  copy the value into the
 19989                                  				;  comspec var in the resident
 19990                                  
 19991                                  ; We have changed the COMSPEC variable. We need to update the resident
 19992                                  ; pieces necessary to reread in the info. First, skip all delimiters
 19993                                  
 19994 00002266 E87303                  	call	scanoff
 19995 00002269 8E06[A58A]              	mov	es,[RESSEG]	;  comspec var in the resident
 19996                                  
 19997                                  ; Make sure that the printer knows where the beginning of the string is
 19998                                  
 19999 0000226D BF[3601]                	mov	di,ComSpec
 20000 00002270 89FB                    	mov	bx,di
 20001                                  
 20002                                  ; Generate drive letter for display
 20003                                  
 20004 00002272 31C0                    	xor	ax,ax		;g assume no drive first
 20005 00002274 26A2[7F01]              	mov	[es:ComDrv],al
 20006                                  	; 23/02/2023
 20007                                  	; MSDOS 6.0 (& 5.0)
 20008 00002278 50                      	push	ax		;AN000; 3/3/KK
 20009 00002279 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 20010 0000227B E83F01                  	call	testkanj	;AN000; 3/3/KK	
 20011 0000227E 58                      	pop	ax		;AN000; 3/3/KK
 20012 0000227F 7518                    	jnz	short _GOTDRIVE
 20013                                  	;
 20014 00002281 807C013A                	cmp	byte [si+1],':'	; drive specified?
 20015 00002285 7512                    	jne	short _GOTDRIVE
 20016 00002287 8A04                    	mov	al,[si]		; get his specified drive
 20017                                  	; 23/02/2023
 20018 00002289 E85B01                  	call	UPCONV
 20019                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 20020 0000228C 2C41                    	sub	al,'A'		; convert to 0-based
 20021 0000228E 83C702                  	add	di,2
 20022 00002291 FEC0                    	inc	al		; convert to 1-based number
 20023 00002293 26A2[7F01]              	mov	[es:ComDrv],al
 20024                                  
 20025                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 20026                                  ; done here..
 20027                                  	;add	al,40h
 20028 00002297 0440                    	add	al,'A'-1
 20029                                  _GOTDRIVE:
 20030                                  	; 23/02/2023
 20031                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 20032                                  	;mov	[es:PUTBACKSUBSTPTR],di
 20033                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 20034 00002299 26893E[1501]            	mov	[es:PutBackComSpec],di
 20035                                  				;g point to beginning of name after drive
 20036                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 20037                                  	;mov	[es:PUTBACKDRV],al
 20038                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 20039 0000229E 26A2[1A01]              	mov	[es:PutBackDrv],al
 20040                                  
 20041                                  ; Copy chars until delim      	
 20042                                  
 20043 000022A2 89DF                    	mov	di,bx
 20044                                  COPY_COMSPEC:
 20045 000022A4 AC                      	lodsb
 20046 000022A5 E83C03                  	call	DELIM
 20047 000022A8 7407                    	jz	short COPYDONE
 20048 000022AA 3C0D                    	cmp	al,13 ; 0Dh
 20049 000022AC 7403                    	je	short COPYDONE
 20050 000022AE AA                      	stosb
 20051 000022AF EBF3                    	jmp	short COPY_COMSPEC
 20052                                  COPYDONE:
 20053 000022B1 30C0                    	xor	al,al		; Null terminate the string and quit
 20054 000022B3 AA                      	stosb
 20055                                  	;mov	byte [comspec_flag],0
 20056 000022B4 A2[4284]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 20057 000022B7 4F                      	dec	di
 20058 000022B8 26893E[7601]            	mov	[es:ComSpec_End],di
 20059 000022BD C3                      	retn
 20060                                  
 20061                                  DISP_ENV:
 20062 000022BE 8E1E[A58A]              	mov	ds,[RESSEG]
 20063 000022C2 8E1E[2703]              	mov	ds,[EnvirSeg]
 20064                                  	; assume ds:nothing
 20065 000022C6 31F6                    	xor	si,si
 20066                                  PENVLP:
 20067 000022C8 803C00                  	cmp	byte [si],0
 20068 000022CB 7497                    	jz	short ADD_NAME_JZ_RET
 20069 000022CD BF[F692]                	mov	di,Arg_Buf
 20070                                  PENVLP2:
 20071 000022D0 AC                      	lodsb
 20072 000022D1 AA                      	stosb
 20073 000022D2 08C0                    	or	al,al
 20074 000022D4 75FA                    	jnz	short PENVLP2
 20075 000022D6 BA[9980]                	mov	dx,arg_buf_ptr
 20076 000022D9 1E                      	push	ds
 20077 000022DA 06                      	push	es
 20078 000022DB 1F                      	pop	ds
 20079                                  	; assume ds:nothing
 20080 000022DC E8E42A                  	call	Printf_Crlf
 20081 000022DF 1F                      	pop	ds
 20082 000022E0 EBE6                    	jmp	short PENVLP
 20083                                  
 20084                                  ; =============== S U B	R O U T	I N E =======================================
 20085                                  
 20086                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20087                                  delete_path:
 20088 000022E2 BE[6C81]                	mov	si,PATH_TEXT ; "PATH="
 20089 000022E5 EB03                    	jmp	short delete_name_in_environment
 20090                                  
 20091                                  ; =============== S U B	R O U T	I N E =======================================
 20092                                  
 20093                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20094                                  delete_prompt:
 20095 000022E7 BE[7181]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20096                                  
 20097                                  ; ---------------------------------------------------------------------------
 20098                                  
 20099                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20100                                  delete_name_in_environment:
 20101                                  
 20102                                  ; Input: DS:SI points to a "=" terminated string
 20103                                  ; Output: carry flag is set if name not found
 20104                                  ;	  otherwise name is deleted
 20105                                  
 20106 000022EA 56                      	push	si
 20107 000022EB 1E                      	push	ds
 20108 000022EC E82C00                  	call	FIND		; ES:DI points to name
 20109 000022EF 7217                    	jc	short del1
 20110 000022F1 89FE                    	mov	si,di		; Save it
 20111 000022F3 E8BF00                  	call	SCASB2		; Scan for the nul
 20112 000022F6 87F7                    	xchg	si,di
 20113                                  ;SR;
 20114                                  ; If we have only one env string, then the double null is lost when the last
 20115                                  ;string is deleted and we have an invalid empty environment with only a 
 20116                                  ;single null. To avoid this, we will look for the double null case and then
 20117                                  ;move an extra null char.
 20118                                  ; Bugbug: The only possible problem is that the last pathstring 
 20119                                  ;will be followed by a triple null. Is this really a problem?
 20120                                  
 20121                                  	; MSDOS 6.0
 20122 000022F8 26803C00                	cmp	byte [es:si],0	;null char?
 20123 000022FC 7501                    	jnz	short not_dnull	;no, we are at a double null
 20124 000022FE 4E                      	dec	si		;point at the double null
 20125                                  not_dnull:
 20126                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20127 000022FF E86901                  	call	GETENVSIZ
 20128 00002302 29F1                    	sub	cx,si
 20129 00002304 06                      	push	es
 20130 00002305 1F                      	pop	ds		; ES:DI points to name
 20131                                  				; DS:SI points to next name
 20132 00002306 F3A4                    	rep	movsb
 20133                                  del1:
 20134 00002308 1F                      	pop	ds
 20135 00002309 5E                      	pop	si
 20136                                  find_retn:
 20137 0000230A C3                      	retn
 20138                                  
 20139                                  ; =============== S U B	R O U T	I N E =======================================
 20140                                  
 20141                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20142                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 20143                                  find_path:
 20144 0000230B BE[6C81]                	mov	si,PATH_TEXT ; "PATH="
 20145 0000230E EB03                    	jmp	short find_name_in_environment
 20146                                  
 20147                                  ; =============== S U B	R O U T	I N E =======================================
 20148                                  
 20149                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20150                                  find_prompt:
 20151 00002310 BE[7181]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20152                                  
 20153                                  ; ---------------------------------------------------------------------------
 20154                                  
 20155                                  find_name_in_environment:
 20156                                  
 20157                                  ; Input: DS:SI points to a "=" terminated string
 20158                                  ; Output: ES:DI points to the arguments in the environment
 20159                                  ;	  zero is set if name not found
 20160                                  ;	  carry flag is set if name not valid format
 20161                                  
 20162 00002313 E80500                  	call	FIND		; Find the name
 20163 00002316 72F2                    	jc	short find_retn	; Carry means not found	
 20164 00002318 E99600                  	jmp	SCASB1		; Scan for = sign
 20165                                  
 20166                                  ; ---------------------------------------------------------------------------
 20167                                  	;nop
 20168                                  
 20169                                  ; =============== S U B	R O U T	I N E =======================================
 20170                                  
 20171                                  ; On return of FIND1, ES:DI points to beginning of name
 20172                                  
 20173                                  FIND:
 20174 0000231B FC                      	cld
 20175 0000231C E84100                  	call	COUNT0		; CX = Length of name
 20176 0000231F 8E06[A58A]              	mov	es,[RESSEG]
 20177                                  	;assume es:RESGROUP
 20178 00002323 268E06[2703]            	mov	es,[es:EnvirSeg]
 20179                                  	;assume es:NOTHING
 20180 00002328 31FF                    	xor	di,di
 20181                                  find1:	
 20182 0000232A 51                      	push	cx
 20183 0000232B 56                      	push	si
 20184 0000232C 57                      	push	di
 20185                                  find11:
 20186 0000232D AC                      	lodsb
 20187                                  	; 23/02/2023 
 20188                                  	; MSDOS 6.0 (& 5.0)
 20189 0000232E E88C00                  	call	testkanj	
 20190 00002331 740F                    	jz	short notkanj3
 20191 00002333 4E                      	dec	si
 20192 00002334 AD                      	lodsw
 20193 00002335 47                      	inc	di
 20194 00002336 47                      	inc	di
 20195 00002337 263B45FE                	cmp	ax,[es:di-2]
 20196 0000233B 7511                    	jne	short find12
 20197 0000233D 49                      	dec	cx
 20198 0000233E E2ED                    	loop	find11
 20199 00002340 EB0C                    	jmp	short find12
 20200                                  notkanj3:
 20201 00002342 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 20202                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 20203 00002345 47                      	inc	di
 20204 00002346 263A45FF                	cmp	al,[es:di-1]
 20205 0000234A 7502                    	jne	short find12
 20206 0000234C E2DF                    	loop	find11
 20207                                  find12:
 20208 0000234E 5F                      	pop	di
 20209 0000234F 5E                      	pop	si
 20210 00002350 59                      	pop	cx
 20211 00002351 74B7                    	jz	short find_retn
 20212 00002353 51                      	push	cx
 20213 00002354 E85E00                  	call	SCASB2		; Scan for a nul
 20214 00002357 59                      	pop	cx
 20215 00002358 26803D00                	cmp	byte [es:di],0
 20216 0000235C 75CC                    	jnz	short find1
 20217 0000235E F9                      	stc			; Indicate not found
 20218 0000235F C3                      	retn
 20219                                  
 20220                                  ; =============== S U B	R O U T	I N E =======================================
 20221                                  
 20222                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20223                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 20224                                  COUNT0:
 20225 00002360 1E                      	push	ds
 20226 00002361 07                      	pop	es
 20227                                  	;assume es:nothing
 20228 00002362 89F7                    	mov	di,si
 20229                                  ;COUNT1:
 20230 00002364 57                      	push	di		; Count number of chars until "="
 20231 00002365 E84900                  	call	SCASB1
 20232                                  	; 23/02/2023
 20233                                  ;	jmp	short COUNTX
 20234                                  ;COUNT2:
 20235                                  ;	push	di		; Count number of chars until nul
 20236                                  ;	call	SCASB2
 20237                                  ;COUNTX:
 20238 00002368 59                      	pop	cx
 20239 00002369 29CF                    	sub	di,cx
 20240 0000236B 87F9                    	xchg	di,cx
 20241                                  move_name_retn:
 20242 0000236D C3                      	retn
 20243                                  
 20244                                  ; =============== S U B	R O U T	I N E =======================================
 20245                                  
 20246                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20247                                  move_name:
 20248 0000236E 803C0D                  	cmp	byte [si],13 ; 0Dh
 20249 00002371 74FA                    	je	short move_name_retn
 20250 00002373 AC                      	lodsb
 20251                                  	; 23/02/2023 
 20252                                  	; MSDOS 6.0 (& 5.0)
 20253 00002374 E84600                  	call	testkanj		
 20254 00002377 7409                    	jz	short notkanj1
 20255 00002379 E88D00                  	call	store_char
 20256 0000237C AC                      	lodsb
 20257 0000237D E88900                  	call	store_char
 20258 00002380 EBEC                    	jmp	short move_name
 20259                                  notkanj1: 
 20260 00002382 E86200                  	call	UPCONV
 20261                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 20262 00002385 E88100                  	call	store_char
 20263 00002388 3C3D                    	cmp	al,'='
 20264 0000238A 75E2                    	jne	short move_name
 20265                                  getarg_retn:
 20266 0000238C C3                      	retn
 20267                                  
 20268                                  ; =============== S U B	R O U T	I N E =======================================
 20269                                  
 20270                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20271                                  GETARG:
 20272 0000238D BE8000                  	mov	si,80h
 20273 00002390 AC                      	lodsb
 20274 00002391 08C0                    	or	al,al
 20275 00002393 74F7                    	jz	short getarg_retn
 20276 00002395 E84402                  	call	scanoff
 20277 00002398 3C0D                    	cmp	al,13 ; 0Dh
 20278                                  sdn_retn:
 20279 0000239A C3                      	retn
 20280                                  
 20281                                  ; =============== S U B	R O U T	I N E =======================================
 20282                                  
 20283                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 20284                                  ; there is NO double NULL, merely a string that is empty.
 20285                                  
 20286                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20287                                  scan_double_null:
 20288 0000239B 8E06[A58A]              	mov	es,[RESSEG]
 20289 0000239F 268E06[2703]            	mov	es,[es:EnvirSeg]
 20290 000023A4 31FF                    	xor	di,di
 20291                                  
 20292                                  ; Top cycle-point. If the string here is empty, then we are done
 20293                                  
 20294                                  sdn1:
 20295 000023A6 26803D00                	cmp	byte [es:di],0	; nul string?
 20296 000023AA 74EE                    	jz	short sdn_retn	; yep, all done
 20297 000023AC E80600                  	call	SCASB2
 20298 000023AF EBF5                    	jmp	short sdn1
 20299                                  
 20300                                  ; =============== S U B	R O U T	I N E =======================================
 20301                                  
 20302                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20303                                  SCASB1:
 20304 000023B1 B03D                    	mov	al,'='		; Scan for an =
 20305 000023B3 EB02                    	jmp	short SCASBX
 20306                                  
 20307                                  ; =============== S U B	R O U T	I N E =======================================
 20308                                  
 20309                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20310                                  SCASB2:
 20311 000023B5 30C0                    	xor	al,al		; Scan for a nul
 20312                                  
 20313                                  ; ---------------------------------------------------------------------------
 20314                                  
 20315                                  	; 23/02/2023
 20316                                  SCASBX:
 20317 000023B7 B90001                  	mov	cx,256
 20318 000023BA F2AE                    	repne	scasb
 20319 000023BC C3                      	retn
 20320                                  
 20321                                  ; =============== S U B	R O U T	I N E =======================================
 20322                                  
 20323                                  ; MSDOS 6.0
 20324                                  
 20325                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 20326                                  
 20327                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20328                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 20329                                  testkanj:
 20330 000023BD 1E                      	push	ds			;AN000;  3/3/KK
 20331 000023BE 56                      	push	si			;AN000;  3/3/KK
 20332 000023BF 50                      	push	ax			;AN000;  3/3/KK
 20333 000023C0 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20334 000023C5 C536[A701]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20335                                  ktlop:					;AN000;  3/3/KK
 20336 000023C9 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20337 000023CC 740E                    	je	short notlead 		;AN000;  3/3/KK
 20338 000023CE 58                      	pop	ax			;AN000;  3/3/KK
 20339 000023CF 50                      	push	ax			;AN000;  3/3/KK
 20340 000023D0 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20341 000023D2 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20342 000023D4 46                      	inc	si			;AN000;  3/3/KK
 20343 000023D5 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20344 000023D7 7607                    	jbe	short islead		;AN000;  3/3/KK
 20345 000023D9 46                      	inc	si			;AN000;  3/3/KK
 20346 000023DA EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20347                                  notlead:				;AN000;  3/3/KK
 20348 000023DC 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20349 000023DE EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20350                                  islead: 				;AN000;  3/3/KK
 20351 000023E0 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20352 000023E2 40                      	inc	ax			;AN000;  3/3/KK
 20353                                  ktret:					;AN000;  3/3/KK
 20354 000023E3 58                      	pop	ax			;AN000;  3/3/KK
 20355 000023E4 5E                      	pop	si			;AN000;  3/3/KK
 20356 000023E5 1F                      	pop	ds			;AN000;  3/3/KK
 20357 000023E6 C3                      	retn				;AN000;  3/3/KK
 20358                                  
 20359                                  ; =============== S U B	R O U T	I N E =======================================
 20360                                  
 20361                                  ; MSDOS 6.0
 20362                                  
 20363                                  ; ****************************************************************
 20364                                  ; *
 20365                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20366                                  ; *
 20367                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20368                                  ; *		 the character in AL from the file upper case table
 20369                                  ; *		 in DOS if character if above  ascii 128, else
 20370                                  ; *		 subtracts 20H if between "a" and "z".
 20371                                  ; *
 20372                                  ; * INPUT:	 AL	      char to be upper cased
 20373                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20374                                  ; *
 20375                                  ; * OUTPUT:	 AL	      upper cased character
 20376                                  ; *
 20377                                  ; ****************************************************************
 20378                                  
 20379                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20380                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20381                                  UPCONV:
 20382 000023E7 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20383 000023E9 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20384 000023EB 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20385 000023ED 1E                      	push	ds			;AN000;
 20386 000023EE 53                      	push	bx			;AN000;
 20387 000023EF 8E1E[A58A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20388                                  	;lds	bx,dword ptr FUCase_Addr+1
 20389 000023F3 C51E[9F01]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20390 000023F7 83C302                  	add	bx,2			;AN000;  skip over first word
 20391                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20392 000023FA D7                      	xlat
 20393 000023FB 5B                      	pop	bx			;AN000;
 20394 000023FC 1F                      	pop	ds			;AN000;
 20395                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20396                                  	; 24/02/2023
 20397 000023FD C3                      	retn
 20398                                  oth_fucase:				;AN000;
 20399 000023FE 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20400 00002400 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20401 00002402 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20402 00002404 7702                    	ja	short upconv_end	;AC000;
 20403 00002406 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20404                                  upconv_end:				;AN000;
 20405 00002408 C3                      	retn
 20406                                  
 20407                                  ; ---------------------------------------------------------------------------
 20408                                  
 20409                                  ; MSDOS 3.3
 20410                                  
 20411                                  	; 24/02/2023
 20412                                  ;UPCONV_MAPCALL:
 20413                                  	;			; If between "a" and "z"
 20414                                  	;cmp	al,[small_a]
 20415                                  	;jb	short UPCONV_END
 20416                                  	;cmp	al,[small_z]
 20417                                  	;ja	short UPCONV_END
 20418                                  	;sub	al,20h		; Change lower-case to upper
 20419                                  ;UPCONV_END:
 20420                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20421                                  	;			  ; 	  for (current) country
 20422                                  	;retn
 20423                                  
 20424                                  ; =============== S U B	R O U T	I N E =======================================
 20425                                  
 20426                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20427                                  
 20428                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20429                                  	; 10/06/2023
 20430                                  store_char:
 20431 00002409 51                      	push	cx
 20432 0000240A 53                      	push	bx
 20433                                  
 20434                                  	; 24/02/2023
 20435                                  	;;16/10/2018
 20436                                  	; MSDOS 6.0
 20437 0000240B 06                      	push	es		;AN056;*
 20438 0000240C 1E                      	push	ds		;AN056; Save local DS
 20439 0000240D 8E1E[A58A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20440 00002411 8E06[2703]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20441 00002415 1F                      	pop	ds		;AN056; Get local segment back
 20442                                  
 20443                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20444 00002416 E85200                  	call	GETENVSIZ
 20445 00002419 89CB                    	mov	bx,cx		; Save room for double nul
 20446 0000241B 83EB02                  	sub	bx,2
 20447 0000241E 39DF                    	cmp	di,bx
 20448 00002420 723F                    	jb	short store1
 20449 00002422 50                      	push	ax
 20450 00002423 51                      	push	cx
 20451 00002424 53                      	push	bx		; Save Size of environment
 20452 00002425 E8DCE2                  	call	FREE_TPA
 20453 00002428 5B                      	pop	bx
 20454 00002429 83C302                  	add	bx,2		; Recover true environment size
 20455                                  
 20456 0000242C 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20457 00002430 7203                    	jb	short envsiz_ok
 20458                                  bad_env_size:			;AN056;
 20459 00002432 F9                      	stc
 20460 00002433 EB16                    	jmp	short envnoset
 20461                                  	;nop
 20462                                  envsiz_ok:
 20463 00002435 B104                    	mov	cl,4
 20464 00002437 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20465 00002439 43                      	inc	bx
 20466                                  	; 24/02/2023
 20467                                  	; MSDOS 6.0
 20468 0000243A 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20469 0000243C 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20470 0000243E 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20471 00002441 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20472 00002443 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20473 00002445 73EB                    	jnb	short bad_env_size
 20474                                  				;AN056; Yes - don't do it!!!
 20475                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20476 00002447 B44A                    	mov	ah,4Ah
 20477                                  	;mov	ah,SETBLOCK ; 4Ah
 20478 00002449 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20479                                  			; ES = segment address of block	to change
 20480                                  			; BX = new size	in paragraphs
 20481                                  envnoset:
 20482 0000244B 9C                      	pushf
 20483 0000244C 06                      	push	es
 20484 0000244D 8E06[A58A]              	mov	es,[RESSEG]
 20485 00002451 E8C0E2                  	call	ALLOC_TPA
 20486 00002454 07                      	pop	es
 20487 00002455 9D                      	popf
 20488 00002456 59                      	pop	cx
 20489 00002457 58                      	pop	ax
 20490                                  	; 24/02/2023
 20491                                  	;pop	es ; MSDOS 6.0	;AN056;*	
 20492 00002458 7307                    	jnc	short store1
 20493                                  	; 10/06/2023 (BugFix)
 20494 0000245A 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20495 0000245B BA[137F]                	mov	dx,ENVERR_PTR
 20496 0000245E E9EF04                  	jmp	cerror
 20497                                  store1:	
 20498 00002461 AA                      	stosb
 20499 00002462 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20500                                  	; 24/02/2023
 20501 00002467 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20502 00002468 5B                      	pop	bx
 20503 00002469 59                      	pop	cx
 20504 0000246A C3                      	retn
 20505                                  
 20506                                  ; =============== S U B	R O U T	I N E =======================================
 20507                                  
 20508                                  	; 24/02/2023
 20509                                  GETENVSIZ:
 20510                                  
 20511                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20512                                  ;ES has environment segment
 20513                                  ;Size returned in CX, all other registers preserved
 20514                                  
 20515 0000246B 06                      	push	es
 20516 0000246C 50                      	push	ax
 20517 0000246D 8CC0                    	mov	ax,es
 20518 0000246F 48                      	dec	ax		;Point at arena
 20519 00002470 8EC0                    	mov	es,ax
 20520                                  	;mov	ax,[es:3]
 20521 00002472 26A10300                	mov	ax,[es:ARENA.size]
 20522 00002476 B104                    	mov	cl,4
 20523 00002478 D3E0                    	shl	ax,cl		;Convert to bytes
 20524 0000247A 89C1                    	mov	cx,ax
 20525 0000247C 58                      	pop	ax
 20526 0000247D 07                      	pop	es
 20527                                  getenvsiz_retn:
 20528 0000247E C3                      	retn
 20529                                  
 20530                                  ; =============== S U B	R O U T	I N E =======================================
 20531                                  
 20532                                  	; 24/02/2023
 20533                                  RestUDir1:
 20534 0000247F 1E                      	push	ds
 20535 00002480 8E1E[A58A]              	mov	ds,[RESSEG]
 20536 00002484 803E[8C01]00            	cmp	byte [RestDir],0
 20537 00002489 1F                      	pop	ds
 20538 0000248A 74F2                    	jz	short getenvsiz_retn
 20539                                  
 20540                                  ; =============== S U B	R O U T	I N E =======================================
 20541                                  
 20542                                  	; 24/02/2023
 20543                                  RestUDir:
 20544 0000248C BA[8789]                	mov	dx,USERDIR1
 20545 0000248F B43B                    	mov	ah,3Bh
 20546                                  	;mov	ah,CHDir ; 3Bh
 20547 00002491 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20548                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20549 00002493 30C0                    	xor	al,al
 20550                                  	;call	SETREST
 20551                                  	;retn
 20552                                  	; 24/02/2023
 20553 00002495 E94908                  	jmp	SETREST
 20554                                  
 20555                                  ;============================================================================
 20556                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20557                                  ;============================================================================
 20558                                  ; 07/10/2018 - Retro DOS v3.0
 20559                                  
 20560                                  ; TITLE	Part6 COMMAND Transient routines.
 20561                                  
 20562                                  ;	Environment utilities and misc. routines
 20563                                  
 20564                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20565                                  
 20566                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20567                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20568                                  
 20569                                  ; ---------------------------------------------------------------------------
 20570                                  
 20571                                  ; ****************************************************************
 20572                                  ; *
 20573                                  ; * ROUTINE:	 $CHDIR
 20574                                  ; *
 20575                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20576                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20577                                  ; *		 letter is found, get and display the current dir
 20578                                  ; *		 of the specified drive. If nothing is found, get
 20579                                  ; *		 and display the current dir of the default drive.
 20580                                  ; *
 20581                                  ; * INPUT:	 command line at offset 81H
 20582                                  ; *
 20583                                  ; * OUTPUT:	 none
 20584                                  ; *
 20585                                  ; ****************************************************************
 20586                                  
 20587                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20588                                  	; 10/06/2023
 20589                                  _$CHDIR:
 20590                                  	; MSDOS 6.0
 20591 00002498 BE8100                  	mov	si,81h
 20592 0000249B BF[F084]                	mov	di,PARSE_CHDIR
 20593                                  				;AN000; Get address of PARSE_CHDIR
 20594 0000249E 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20595 000024A0 31D2                    	xor	dx,dx		;AN000;
 20596 000024A2 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20597                                  	
 20598                                  	;cmp	ax,-1
 20599                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20600                                  	;je	short bwdj	; No args
 20601                                  	;;cmp	ax,0
 20602                                  	;;cmp	ax,RESULT_NO_ERROR
 20603                                  	;			;AC000; did we have an error?
 20604                                  	;or	ax,ax ; ax = 0 ?
 20605                                  	;jnz	short ChDirErr	;AC018; yes - exit
 20606                                  	
 20607                                  	; 10/06/2023
 20608 000024A5 40                      	inc	ax	; cmp ax,-1
 20609 000024A6 7414                    	jz	short bwdj ; 0FFFFh -> 0
 20610 000024A8 48                      	dec	ax	; cmp ax,0
 20611 000024A9 756D                    	jnz	short ChDirErr ; 1 -> 0
 20612                                  	; ax = 0	
 20613                                  
 20614                                  	;cmp	byte [PARSE1_TYPE],6
 20615 000024AB 803E[4F95]06            	cmp	byte [PARSE1_TYPE],result_drive
 20616                                  				;AC000; was a drive entered?
 20617 000024B0 7511                    	jne	short REALCD	; no
 20618                                  
 20619                                  ; D: was found. See if there is anything more.
 20620                                  
 20621 000024B2 BF[F084]                	mov	di,PARSE_CHDIR
 20622                                  				;AC000; get address of parse_chdir
 20623 000024B5 31D2                    	xor	dx,dx		;AC000;
 20624 000024B7 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 20625 000024BA 755C                    	jnz	short ChDirErr	;AC000;
 20626                                  bwdj:
 20627 000024BC E87BF9                  	call	build_dir_for_chdir
 20628                                  				; Drive only specified
 20629 000024BF E80D01                  	call	CRLF2
 20630                                  chdir_retn:
 20631 000024C2 C3                      	retn
 20632                                  
 20633                                  	; 24/02/2023
 20634                                  	; MSDOS 3.3
 20635                                  	;mov	ax,[COMSW]
 20636                                  	;or	ax,[ALLSWITCH]
 20637                                  	;mov	dx,BADPARMPTR
 20638                                  	;jnz	short CHDIR_ERR
 20639                                  	;mov	si,81h
 20640                                  	;call	SCANOFF
 20641                                  	;cmp	al,0Dh		; are we at end of line?
 20642                                  	;je	short BWDJ	; No args
 20643                                  	;inc	si
 20644                                  	;lodsb
 20645                                  	;cmp	al,':'
 20646                                  	;jne	short REALCD
 20647                                  	;push	si
 20648                                  	;call	SCANOFF
 20649                                  	;pop	si
 20650                                  	;cmp	al,0Dh		; was a drive entered?
 20651                                  	;jne	short REALCD	; no
 20652                                  ;BWDJ:
 20653                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20654                                  	;call	CRLF2
 20655                                  ;CHDIR_RETN:
 20656                                  	;retn
 20657                                  
 20658                                  	; 24/02/2023
 20659                                  	; MSDOS 6.0
 20660                                  REALCD:
 20661 000024C3 56                      	push	si		;AN000; save position in line
 20662 000024C4 C536[5395]              	lds	si,[PARSE1_ADDR]
 20663                                  				;AN000; get address of filespec
 20664 000024C8 E8D807                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20665 000024CB 5E                      	pop	si		;AN000; restore position in line
 20666 000024CC BF[F084]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20667 000024CF 31D2                    	xor	dx,dx		;AC000;
 20668 000024D1 E8CDFC                  	call	parse_check_eol ;AC000; call parser
 20669 000024D4 7542                    	jnz	short ChDirErr	;AC000;
 20670                                  	
 20671 000024D6 E81106                  	call	SETPATH
 20672 000024D9 F606[2C8C]02            	test	byte [DestInfo],2
 20673 000024DE 7518                    	jnz	short BadChDir
 20674                                  
 20675                                  	; 26/04/2023
 20676 000024E0 B43B                    	mov	ah,3Bh
 20677                                  	;mov	ah,CHDir
 20678 000024E2 CD21                    	int	21h
 20679 000024E4 73DC                    	jnc	short chdir_retn
 20680                                  	
 20681 000024E6 E807F8                  	call	get_ext_error_number
 20682                                  				;AN022; get the extended error
 20683 000024E9 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20684                                  				;AN022; see if path not found
 20685 000024EC 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20686                                  ;SR;
 20687                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20688                                  ;but is not a directory. The extended error returns "Access denied" which
 20689                                  ;is kind of confusing. Issue the old message if access denied error is 
 20690                                  ;returned
 20691                                  
 20692 000024EE 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20693 000024F1 7405                    	je	short BadChDir
 20694                                  	
 20695 000024F3 E89E00                  	call	set_ext_error_subst ;AN022;
 20696 000024F6 EB20                    	jmp	short ChDirErr	;AN022;
 20697                                  
 20698                                  BadChDir:
 20699 000024F8 BA[3780]                	mov	dx,badcd_ptr
 20700                                  ;ChDirErr:
 20701                                  ;	call	std_eprintf
 20702                                  ;mkdir_retn:
 20703                                  	;retn
 20704                                  	; 24/02/2023
 20705 000024FB EB1B                    	jmp	short ChDirErr	;AN022;
 20706                                  
 20707                                  	; 24/02/2023
 20708                                  	; MSDOS 3.3
 20709                                  ;REALCD:
 20710                                  	;call	SETPATH
 20711                                  	;test	byte [DESTINFO],2
 20712                                  	;jnz	short BADCHDIR
 20713                                  	;mov	ah,CHDir ; 3Bh
 20714                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20715                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20716                                  	;jnc	short CHDIR_RETN
 20717                                  ;BADCHDIR:
 20718                                  	;mov	dx,BADCDPTR
 20719                                  ;CHDIR_ERR:
 20720                                  	;call	STD_EPRINTF
 20721                                  ;MKDIR_RETN:
 20722                                  	;retn
 20723                                  
 20724                                  ; =============== S U B	R O U T	I N E =======================================
 20725                                  
 20726                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20727                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20728                                  _$MKDIR:
 20729                                  	; MSDOS 6.0
 20730 000024FD E86300                  	call	SETRMMK
 20731 00002500 7216                    	jc	short MkDirErr
 20732                                  
 20733 00002502 B439                    	mov	ah,39h
 20734                                  	;mov	ah,MKDIR
 20735 00002504 CD21                    	int	21h
 20736 00002506 7313                    	jnc	short mkdir_retn
 20737                                  
 20738 00002508 E8E5F7                  	call	get_ext_error_number	
 20739                                  				;AN022; get the extended error
 20740 0000250B 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20741                                  				;AN022; see if path not found
 20742 0000250E 742A                    	je	short MD_other_err
 20743                                  				;AN022; yes - issue old message
 20744 00002510 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20745                                  				;AN022; access denied?
 20746 00002513 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20747                                  	
 20748 00002515 E87C00                  	call	set_ext_error_subst
 20749                                  				;AN022;
 20750                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20751                                  	; 24/02/2023
 20752                                  ChDirErr:
 20753                                  MkDirErr:
 20754                                  RmDirErr:
 20755 00002518 E8AE28                  	call	std_eprintf
 20756                                  mkdir_retn:
 20757                                  rmdir_retn:
 20758 0000251B C3                      	retn
 20759                                  	
 20760                                  badmderr:
 20761 0000251C BA[D387]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20762 0000251F B41A                    	mov	ah,1Ah
 20763                                  	;mov	ah,Set_DMA	;AN006;
 20764 00002521 CD21                    	int	21h		;AN006;
 20765                                  	
 20766 00002523 B44E                    	mov	ah,4Eh
 20767                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20768                                  	;mov	cx,10h
 20769 00002525 B91000                  	mov	cx,ATTR_DIRECTORY
 20770                                  				;AN006;   search for directory
 20771 00002528 CD21                    	int	21h		;AN006;
 20772 0000252A 720E                    	jc	short MD_other_err
 20773                                  				;AN006; doesn't exist - must be something else
 20774                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20775                                  				;AN006; we found a file/dir
 20776                                  	;mov	dl,[SRCXNAME+21] 
 20777 0000252C 8A16[E887]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20778 00002530 F6C210                  	test	dl,ATTR_DIRECTORY
 20779                                  				;AN006; was it a directory?
 20780 00002533 7405                    	jz	short MD_other_err
 20781                                  				;AN006; no - must have been a file
 20782 00002535 BA[2781]                	mov	dx,MD_EXISTS_PTR
 20783                                  				;AN006; set up already exists error
 20784 00002538 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20785                                  MD_other_err:			;AN006;
 20786 0000253A BA[3A80]                	mov	dx,badmkd_ptr
 20787                                  ;MkDirErr:
 20788                                  	;call	std_eprintf
 20789                                  	;retn
 20790                                  	; 24/02/2023
 20791 0000253D EBD9                    	jmp	short MkDirErr
 20792                                  
 20793                                  	; 24/02/2023
 20794                                  	; MSDOS 3.3
 20795                                  	;call	SETRMMK
 20796                                  	;jb	short MKDIRERR
 20797                                  	;mov	ah,MKDIR ; 39h
 20798                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20799                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20800                                  	;jnc	short MKDIR_RETN
 20801                                  	;mov	dx,BADMKDPTR
 20802                                  	;call	GET_EXT_ERR_NUMBER
 20803                                  ;MKDIRERR:
 20804                                  	;call	STD_EPRINTF
 20805                                  	;retn
 20806                                  
 20807                                  ; =============== S U B	R O U T	I N E =======================================
 20808                                  
 20809                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20810                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20811                                  _$RMDIR:
 20812 0000253F E82100                  	call	SETRMMK
 20813 00002542 72D4                    	jb	short RmDirErr
 20814 00002544 7518                    	jnz	short badrderr
 20815                                  
 20816 00002546 B43A                    	mov	ah,3Ah
 20817                                  	;mov	ah,RMDIR ; 3Ah
 20818 00002548 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20819                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20820 0000254A 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20821                                  
 20822                                  	; 24/02/2023
 20823                                  	; MSDOS 6.0
 20824 0000254C E8A1F7                  	call	get_ext_error_number
 20825                                  				;AN022; get the extended error
 20826 0000254F 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20827                                  				;AN022; see if path not found
 20828 00002552 740A                    	je	short badrderr	;AN022; yes - issue old message
 20829 00002554 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20830                                  				;AN022; access denied?
 20831 00002557 7405                    	je	short badrderr	;AN022; yes - issue old message
 20832                                  
 20833 00002559 E83800                  	call	set_ext_error_subst
 20834                                  				;AN022;
 20835 0000255C EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20836                                  
 20837                                  	; MSDOS 6.0
 20838                                  badrderr:
 20839                                  	; 24/02/2023
 20840 0000255E BA[3D80]                	mov	dx,badrmd_ptr
 20841 00002561 EBB5                    	jmp	short RmDirErr
 20842                                  ;RmDirErr:
 20843                                  	;call	std_eprintf
 20844                                  ;;rmdir_retn
 20845                                  	;retn
 20846                                  
 20847                                  	; 24/02/2023
 20848                                  	; MSDOS 3.3
 20849                                  	;mov	dx,BADRMDPTR
 20850                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20851                                  ;RMDIRERR:
 20852                                  	;call	STD_EPRINTF
 20853                                  ;RMDIR_RETN:
 20854                                  	;retn
 20855                                  
 20856                                  ; =============== S U B	R O U T	I N E =======================================
 20857                                  
 20858                                  ; 	<Common MkDir/RmDir set up code>
 20859                                  ;****************************************************************
 20860                                  ;*
 20861                                  ;* ROUTINE:	SETRMMK
 20862                                  ;*
 20863                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20864                                  ;*		commands. Parses the command line for a required
 20865                                  ;*		filespec.
 20866                                  ;*
 20867                                  ;* INPUT:	command line at offset 81H
 20868                                  ;*
 20869                                  ;* OUTPUT:	carry clear
 20870                                  ;*		    DS:DX points to ASCIIZ argument
 20871                                  ;*		carry set
 20872                                  ;*		    DS:DX has error message pointer
 20873                                  ;*
 20874                                  ;****************************************************************
 20875                                  
 20876                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20877                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20878                                  SETRMMK:
 20879                                  	; MSDOS 6.0
 20880 00002563 BE8100                  	mov	si,81h
 20881 00002566 BF[E784]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20882 00002569 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20883 0000256B 31D2                    	xor	dx,dx		;AN000;
 20884                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20885 0000256D E847FC                  	call	Parse_With_Msg
 20886                                  	;cmp	ax,0
 20887                                  	;cmp	ax,RESULT_NO_ERROR
 20888 00002570 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20889 00002572 7519                    	jnz	short noargerr	;AC000; yes - exit
 20890                                  
 20891 00002574 BF[D387]                	mov	di,SRCXNAME
 20892                                  				;AN000; get address of srcxname
 20893 00002577 57                      	push	di		;AN000; save address
 20894 00002578 56                      	push	si		;AN000; save position in line
 20895 00002579 C536[5395]              	lds	si,[PARSE1_ADDR]
 20896                                  				;AN000; get address of path
 20897                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20898 0000257D AC                      	lodsb			;get a char from buffer
 20899 0000257E AA                      	stosb			;AN000; store in srcxname
 20900                                  	;cmp	al,0
 20901                                  	;cmp	al,END_OF_LINE_OUT
 20902 0000257F 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20903 00002581 75FA                    	jnz	short mrdir_move_filename
 20904                                  				;AC000; no - keep moving
 20905 00002583 5E                      	pop	si		;AN000; get line position back
 20906                                  
 20907                                  ; we have scanned an argument.	See if any args beyond.
 20908                                  
 20909 00002584 BF[E784]                	mov	di,PARSE_MRDIR
 20910 00002587 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20911 0000258A 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20912                                  	;retz			;yes - return no error
 20913 0000258B 7406                    	jz	short setrmmk_retn
 20914                                  noargerr:
 20915 0000258D BA[FC7E]                	mov	dx,extend_buf_ptr
 20916                                  				;AC000; get extended message pointer
 20917 00002590 31C0                    	xor	ax,ax
 20918 00002592 F9                      	stc
 20919                                  setrmmk_retn:
 20920 00002593 C3                      	retn
 20921                                  
 20922                                  	; 24/02/2023
 20923                                  	; MSDOS 3.3
 20924                                  ;SETRMMK:
 20925                                  	;mov	si,81h
 20926                                  	;call	SCANOFF
 20927                                  	;cmp	al,0Dh
 20928                                  	;je	short NOARGERR
 20929                                  	;mov	dx,si
 20930                                  ;SETRMMK1:
 20931                                  	;lodsb
 20932                                  	;call	DELIM
 20933                                  	;jz	short SETRMMK3
 20934                                  	;cmp	al,0Dh
 20935                                  	;jne	short SETRMMK1
 20936                                  	;mov	byte [si-1],0
 20937                                  ;SETRMMK2:
 20938                                  	;retn
 20939                                  ;SETRMMK3:
 20940                                  	;mov	byte [si-1],0
 20941                                  	;push	si
 20942                                  	;call	SCANOFF
 20943                                  	;pop	si
 20944                                  	;cmp	al,0Dh
 20945                                  	;je	short SETRMMK2
 20946                                  ;NOARGERR:
 20947                                  	;mov	dx,BADARGSPTR
 20948                                  	;xor	ax,ax
 20949                                  	;stc
 20950                                  ;SETRMMK_RETN:
 20951                                  	;retn
 20952                                  
 20953                                  ; =============== S U B	R O U T	I N E =======================================
 20954                                  
 20955                                  ; MSDOS 6.0
 20956                                  
 20957                                  ;****************************************************************
 20958                                  ;*
 20959                                  ;* ROUTINE:	Set_ext_error_subst
 20960                                  ;*
 20961                                  ;* FUNCTION:	Sets up substitution for extended error
 20962                                  ;*
 20963                                  ;* INPUT:	AX - extended error number
 20964                                  ;*		DX - offset of string
 20965                                  ;*
 20966                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20967                                  ;*
 20968                                  ;****************************************************************
 20969                                  
 20970                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20971                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20972                                  set_ext_error_subst:
 20973                                  	;mov	byte [msg_disp_class],1
 20974 00002594 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 20975                                  					;AN022; set up extended error msg class
 20976 00002599 8916[118C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20977                                  	;mov	byte [extend_buf_sub],1
 20978 0000259D C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 20979                                  	;AN022; put number of subst in control block
 20980 000025A2 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 20981 000025A5 A3[FC7E]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 20982                                  savudir_err_retn: ; 24/02/2023
 20983 000025A8 C3                      	retn				;AN022; return
 20984                                  
 20985                                  ; =============== S U B	R O U T	I N E =======================================
 20986                                  
 20987                                  ; <SavUDir - preserve the users current directory on a particular drive>
 20988                                  
 20989                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 20990                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 20991                                  ;   buffer
 20992                                  ;
 20993                                  ;   Inputs:	DL has 1-based drive number
 20994                                  ;		ES:DI has destination buffer (SavUDir1 only)
 20995                                  ;   Outputs:	Carry Clear
 20996                                  ;		    DS = TranGroup
 20997                                  ;		Carry Set
 20998                                  ;		    AX has error code
 20999                                  ;   Registers Modified: AX, SI
 21000                                  
 21001                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21002                                  SAVUDIR:
 21003 000025A9 BF[8789]                	mov	di,USERDIR1
 21004                                  ; --------------
 21005                                  SAVUDIR1:
 21006 000025AC 88D0                    	mov	al,dl
 21007 000025AE 0440                    	add	al,'@' ; 40h
 21008 000025B0 3C40                    	cmp	al,'@' ; 40h
 21009 000025B2 7506                    	jne	short GOTUDRV
 21010 000025B4 0206[B78A]              	add	al,[CURDRV]
 21011 000025B8 FEC0                    	inc	al		; A = 1
 21012                                  GOTUDRV:
 21013 000025BA AA                      	stosb
 21014 000025BB 8A26[AA8A]              	mov	ah,[DIRCHAR]
 21015 000025BF B03A                    	mov	al,':' ; 3Ah
 21016 000025C1 AB                      	stosw
 21017 000025C2 06                      	push	es
 21018 000025C3 1F                      	pop	ds
 21019 000025C4 89FE                    	mov	si,di
 21020 000025C6 B447                    	mov	ah,47h ; 24/02/2023
 21021                                  	;mov	ah,CURRENT_DIR	; 47h
 21022 000025C8 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 21023                                  			; DL = drive (0=default,1=A,etc.)
 21024                                  			; DS:SI	points to 64-byte buffer area
 21025 000025CA 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 21026 000025CC 0E                      	push	cs
 21027 000025CD 1F                      	pop	ds
 21028 000025CE C3                      	retn
 21029                                  
 21030                                  ; =============== S U B	R O U T	I N E =======================================
 21031                                  
 21032                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21033                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 21034                                  CRLF2:
 21035 000025CF 52                      	push	dx
 21036 000025D0 BA[DB80]                	mov	dx,acrlf_ptr
 21037 000025D3 1E                      	push	ds
 21038 000025D4 0E                      	push	cs
 21039 000025D5 1F                      	pop	ds
 21040 000025D6 E8F827                  	call	std_printf
 21041 000025D9 1F                      	pop	ds
 21042 000025DA 5A                      	pop	dx
 21043 000025DB C3                      	retn
 21044                                  
 21045                                  ; =============== S U B	R O U T	I N E =======================================
 21046                                  
 21047                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 21048                                  ; may NOT be TRANGROUP
 21049                                  
 21050                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21051                                  scanoff:
 21052 000025DC AC                      	lodsb
 21053 000025DD E80400                  	call	DELIM
 21054 000025E0 74FA                    	jz	short scanoff
 21055 000025E2 4E                      	dec	si		; Point to first non-delimiter
 21056                                  scanoff_retn:
 21057 000025E3 C3                      	retn
 21058                                  
 21059                                  ; =============== S U B	R O U T	I N E =======================================
 21060                                  
 21061                                  ; Input:    AL is character to classify
 21062                                  ; Output:   Z set if delimiter
 21063                                  ;	    NZ set otherwise
 21064                                  ; Registers modified: none
 21065                                  
 21066                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21067                                  DELIM:
 21068 000025E4 3C20                    	cmp	al,' '	 ;20h
 21069 000025E6 74FB                    	je	short scanoff_retn
 21070 000025E8 3C3D                    	cmp	al,'='  ; 3Dh
 21071 000025EA 74F7                    	je	short scanoff_retn
 21072 000025EC 3C2C                    	cmp	al,','	; 2Ch
 21073 000025EE 74F3                    	je	short scanoff_retn
 21074 000025F0 3C3B                    	cmp	al,';'	 ;3Bh
 21075 000025F2 74EF                    	je	short scanoff_retn
 21076 000025F4 3C09                    	cmp	al,9		; Check for TAB character
 21077 000025F6 74EB                    	je	short scanoff_retn
 21078 000025F8 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 21079 000025FA C3                      	retn
 21080                                  
 21081                                  
 21082                                  ; =============== S U B	R O U T	I N E =======================================
 21083                                  
 21084                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21085                                  FCB_TO_ASCZ:			
 21086                                  	; Convert DS:SI to ASCIZ ES:DI
 21087 000025FB B90800                  	mov	cx,8
 21088                                  MAINNAME:
 21089 000025FE AC                      	lodsb
 21090 000025FF 3C20                    	cmp	al,' ' ; 20h
 21091 00002601 7401                    	jz	short SKIPSPC
 21092 00002603 AA                      	stosb
 21093                                  SKIPSPC:
 21094 00002604 E2F8                    	loop	MAINNAME
 21095 00002606 AC                      	lodsb
 21096 00002607 3C20                    	cmp	al,' '
 21097 00002609 740F                    	je	short GOTNAME
 21098 0000260B 88C4                    	mov	ah,al
 21099                                  	; 24/02/2023
 21100 0000260D B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 21101                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 21102                                  	;stosb
 21103                                  	;xchg	al,ah
 21104                                  	;stosb
 21105                                  	; 24/02/2023
 21106 0000260F AB                      	stosw
 21107 00002610 B102                    	mov	cl,2
 21108                                  EXTNAME:
 21109 00002612 AC                      	lodsb
 21110 00002613 3C20                    	cmp	al,' '
 21111 00002615 7403                    	je	short GOTNAME
 21112 00002617 AA                      	stosb
 21113 00002618 E2F8                    	loop	EXTNAME
 21114                                  GOTNAME:
 21115 0000261A 30C0                    	xor	al,al
 21116 0000261C AA                      	stosb
 21117                                  STRCOMP_RETN:
 21118 0000261D C3                      	retn
 21119                                  
 21120                                  ; =============== S U B	R O U T	I N E =======================================
 21121                                  
 21122                                  ; Compare ASCIZ DS:SI with ES:DI.
 21123                                  ; SI,DI destroyed.
 21124                                  
 21125                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21126                                  STRCOMP:	
 21127 0000261E A6                      	cmpsb
 21128 0000261F 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 21129 00002621 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 21130                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 21131                                  	;jmp	short STRCOMP	; Equal so far, keep going
 21132                                  	; 24/02/2023
 21133 00002625 75F7                    	jnz	short STRCOMP
 21134 00002627 C3                      	retn
 21135                                  
 21136                                  ; =============== S U B	R O U T	I N E =======================================
 21137                                  
 21138                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21139                                  CRPRINT:
 21140 00002628 50                      	push	ax
 21141                                  	;mov	al,13	; 0Dh
 21142 00002629 B00D                    	mov	al,0Dh
 21143 0000262B 51                      	push	cx
 21144 0000262C 57                      	push	di
 21145 0000262D 89D7                    	mov	di,dx
 21146 0000262F B9FFFF                  	mov	cx,65535 ; 0FFFFh
 21147 00002632 06                      	push	es
 21148 00002633 1E                      	push	ds
 21149 00002634 07                      	pop	es
 21150 00002635 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 21151 00002637 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 21152 0000263B 07                      	pop	es
 21153 0000263C 8916[118C]              	mov	[string_ptr_2],dx
 21154                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 21155 00002640 BA[C380]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 21156 00002643 E88B27                  	call	std_printf
 21157                                  	;mov	byte [di-1],13
 21158 00002646 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 21159 0000264A 7204                    	jb	short error_output
 21160 0000264C 5F                      	pop	di
 21161 0000264D 59                      	pop	cx
 21162 0000264E 58                      	pop	ax
 21163 0000264F C3                      	retn
 21164                                  
 21165                                  ; ---------------------------------------------------------------------------
 21166                                  
 21167                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21168                                  error_output:
 21169 00002650 0E                      	push	cs
 21170 00002651 1F                      	pop	ds
 21171 00002652 8E06[A58A]              	mov	es,[RESSEG]
 21172 00002656 BA[107F]                	mov	dx,NOSPACE_PTR
 21173 00002659 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 21174 0000265F 7406                    	jz	short go_to_error
 21175 00002661 E80209                  	call	PipeOff
 21176 00002664 BA[5D80]                	mov	dx,PIPEEMES_PTR
 21177                                  go_to_error:
 21178 00002667 E9E602                  	jmp	cerror
 21179                                  
 21180                                  ; =============== S U B	R O U T	I N E =======================================
 21181                                  
 21182                                  ;---- Mod for path invocation ----
 21183                                  
 21184                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21185                                  pathchrcmp:
 21186                                  	; 18/03/2023	
 21187                                  	;push	ax
 21188                                  	;mov	ah,'/' ; 2Fh
 21189                                  	;cmp	[SWITCHAR],ah
 21190 0000266A 803E[A98A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 21191 0000266F 7404                    	je	short noslasht
 21192 00002671 3C2F                    	cmp	al,'/'
 21193 00002673 7402                    	je	short pccont
 21194                                  noslasht:
 21195 00002675 3C5C                    	cmp	al,'\' ; 5Ch
 21196                                  pccont:	
 21197                                  	;pop	ax
 21198 00002677 C3                      	retn
 21199                                  
 21200                                  ; =============== S U B	R O U T	I N E =======================================
 21201                                  
 21202                                  ; PATHCRUNCH -
 21203                                  ;
 21204                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 21205                                  ;       PathPos = ptr to string with pathname in it
 21206                                  ;       PathCnt = length of string
 21207                                  ;
 21208                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 21209                                  ;       PathCnt = length left in string
 21210                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 21211                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 21212                                  ;       If path crunched successfully,
 21213                                  ;         CY = clear
 21214                                  ;         Current directory is changed to directory in pathname
 21215                                  ;         UserDir1 contains previous directory for use by RestUDir
 21216                                  ;         RestDir = nonzero to flag later restoration of user's dir
 21217                                  ;         DestTail = ptr to beginning of filename
 21218                                  ;         If filename found in pathname,
 21219                                  ;           ZR = clear
 21220                                  ;           FCB filename fields contain filename
 21221                                  ;         If filename not found (pure directory path),
 21222                                  ;           ZR = set
 21223                                  ;           FCB filename fields are wildcarded with ?'s
 21224                                  ;       If pathcrunch failed (no ChDir's worked),
 21225                                  ;         CY = set
 21226                                  ;         Msg_Numb = extended error code
 21227                                  ;
 21228                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 21229                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 21230                                  ;       with the filename wildcarded.
 21231                                  
 21232                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21233                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 21234                                  
 21235                                  PathCrunch:
 21236                                  	; MSDOS 6.0
 21237 00002678 C706[948D]0000          	mov     word [Msg_Numb],0
 21238                                  				;AN022; Set up message flag
 21239                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21240                                  	;mov	dl,[5Ch]
 21241 0000267E 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 21242 00002682 E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 21243                                  	; MSDOS 6.0
 21244 00002685 7233                     	jc	short pcrunch_cderrj
 21245                                  				;AN022; if error on current dir - report
 21246 00002687 E86004                  	call	SETPATH		; scan past switches, whitespace
 21247                                  
 21248                                  ;       DX = ptr to pathname, NULL-terminated
 21249                                  ;       PathPos = ptr to byte after NULL at end of pathname
 21250                                  
 21251                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21252 0000268A F606[2C8C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 21253 0000268F 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 21254                                  
 21255                                  	;mov	ah,CHDir ; 3Bh
 21256 00002691 B43B                    	mov	ah,3Bh
 21257 00002693 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21258                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21259                                  	; MSDOS 6.0
 21260 00002695 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 21261                                  	
 21262 00002697 E856F6                  	call	get_ext_error_number    ;AN022; get the extended error
 21263 0000269A 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 21264 0000269D 741E                    	je	short trypeel		;AC022;    keep trying
 21265 0000269F 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 21266 000026A2 7419                    	je	short trypeel		;AC022;    keep trying
 21267 000026A4 A3[948D]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 21268 000026A7 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 21269                                  
 21270                                  	; MSDOS 3.3
 21271                                  	;jc	short trypeel
 21272                                  chdir_worked:
 21273                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21274 000026AA E83206                  	call	SetRest1	; set 'Restore Directory' flag true
 21275 000026AD B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 21276 000026AF BF5D00                  	mov	di,5Dh  ; FCB+1
 21277 000026B2 B90B00                  	mov	cx,11
 21278 000026B5 F3AA                    	rep	stosb
 21279 000026B7 30C0                    	xor	al,al		; return carry clear, zero set
 21280 000026B9 C3                      	retn
 21281                                  
 21282                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 21283 000026BA E98100                  	jmp	pcrunch_cderr	;AN022;
 21284                                  
 21285                                  trypeel:
 21286 000026BD 8B36[008C]              	mov	si,[PathPos]
 21287 000026C1 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 21288 000026C2 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 21289                                  	; 25/02/2023
 21290                                  	; MSDOS 5.0 (& 6.0)
 21291 000026C5 803E[AF8D]00            	cmp	byte [KPARSE],0
 21292 000026CA 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 21293                                  	
 21294 000026CC E89BFF                  	call	pathchrcmp
 21295 000026CF 7475                    	jz	short peelfail	; Trailing '/'
 21296                                  delstrt:
 21297 000026D1 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 21298 000026D3 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 21299 000026D5 52                      	push	dx		; save ptr to pathname
 21300                                  delloop:
 21301 000026D6 39CE                    	cmp	si,cx
 21302                                  	;jz	short BADRET
 21303                                  	; 25/02/2023
 21304 000026D8 7413                    	je	short gotdele	; no char's left, we have what we have
 21305 000026DA AC                      	lodsb			; AL = next char of pathname
 21306 000026DB E8DFFC                  	call	testkanj
 21307 000026DE 7403                    	jz	short notkanj8	; not Kanji, move along
 21308 000026E0 46                      	inc	si
 21309 000026E1 EBF3                    	jmp	short delloop	
 21310                                  
 21311                                  	; 25/02/2023
 21312                                  	; MSDOS 3.3
 21313                                  	;mov	al,[si]
 21314                                  	;call	PATHCHRCMP
 21315                                  	;jz	short TRYCD
 21316                                  	;dec	si
 21317                                  	;jmp	short delloop
 21318                                  
 21319                                  notkanj8:
 21320 000026E3 E884FF                  	call	pathchrcmp
 21321 000026E6 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 21322 000026E8 89F2                    	mov	dx,si
 21323 000026EA 4A                      	dec	dx		; DX = ptr to last delimiter found	
 21324 000026EB EBE9                    	jmp	short delloop	; go look for more
 21325                                  
 21326                                  	; 25/02/2023
 21327                                  	; MSDOS 5.0 (& 6.0)
 21328                                  gotdele:
 21329 000026ED 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 21330 000026EF 5A                      	pop	dx		; DX = ptr to pathname
 21331 000026F0 39D6                    	cmp	si,dx
 21332 000026F2 7454                    	je	short badret	; didn't find path delim
 21333 000026F4 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 21334 000026F6 89D6                    	mov	si,dx		; SI = ptr to pathname
 21335                                  delloop2:			; Set value of KPARSE
 21336 000026F8 39CE                    	cmp	si,cx
 21337 000026FA 7412                    	je	short trycd	; roll up till SI meets CX
 21338 000026FC C606[AF8D]00            	mov	byte [KPARSE],0
 21339 00002701 AC                      	lodsb
 21340 00002702 E8B8FC                  	call	testkanj
 21341 00002705 74F1                    	jz	short delloop2
 21342 00002707 46                      	inc	si
 21343 00002708 FE06[AF8D]              	inc	byte [KPARSE]
 21344 0000270C EBEA                    	jmp	short delloop2
 21345                                  
 21346                                  trycd:
 21347 0000270E 50                      	push	ax
 21348                                  	; 25/02/2023
 21349 0000270F B02E                    	mov	al,'.'
 21350                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21351                                  	; MSDOS 6.0
 21352 00002711 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21353                                  				;M019; allow continuation if '. ' or 
 21354                                  				;M019; '..' is not found.
 21355 00002714 7509                    	jne	short trycd1	;M019; '.' not found
 21356 00002716 384402                  	cmp	[si+2],al	;M019; check for '..'
 21357 00002719 7404                    	je	short trycd1	;M019; found '..'
 21358 0000271B 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21359                                  trycd1:	
 21360 0000271F 58                      	pop     ax
 21361 00002720 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21362                                  
 21363                                  	; 25/02/2023
 21364                                  	; MSDOS 3.3
 21365                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21366                                  	;pop	ax
 21367                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21368                                  
 21369                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21370 00002722 8A44FF                  	mov	al,[si-1]
 21371 00002725 3C3A                    	cmp	al,':' 		; Special case d:\file
 21372 00002727 741F                    	je	short badret
 21373                                  	; 25/02/2023
 21374                                  	; MSDOS 6.0
 21375 00002729 803E[AF8D]00            	cmp	byte [KPARSE],0
 21376 0000272E 7505                    	jnz	short notdoublesl
 21377 00002730 E837FF                  	call	pathchrcmp
 21378                                  	;jnz	short notdoublesl
 21379                                  				; Last char is 2nd KANJI byte, might be '\'
 21380                                  	; 25/02/2023
 21381 00002733 7411                    	jz	short peelfail 
 21382                                  ;peelfail:
 21383                                  	;stc
 21384                                  	;retn
 21385                                  
 21386                                  notdoublesl:
 21387 00002735 C60400                  	mov	byte [si],0
 21388                                  	;mov	ah,CHDir ; 3Bh
 21389 00002738 B43B                    	mov	ah,3Bh
 21390 0000273A CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21391                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21392 0000273C 7320                    	jnc	short cdsucc
 21393                                  
 21394                                  	; 25/02/2023
 21395                                  	; MSDOS 6.0
 21396                                  pcrunch_cderr:
 21397 0000273E E8AFF5                  	call	get_ext_error_number
 21398                                  				;AN022; get the extended error
 21399 00002741 A3[948D]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21400 00002744 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21401                                  peelfail: ; 25/02/2023
 21402 00002746 F9                      	stc			;AN022; set up carry flag
 21403                                  pcrunch_retn:
 21404 00002747 C3                      	retn
 21405                                  
 21406                                  badret:
 21407                                  	; MSDOS 3.3 & MSDOS 6.0
 21408 00002748 8A04                    	mov	al,[si]
 21409 0000274A E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21410 0000274D F9                      	stc
 21411 0000274E 75F7                    	jnz	short pcrunch_retn
 21412 00002750 30DB                    	xor	bl,bl
 21413 00002752 865C01                  	xchg	bl,[si+1]
 21414                                  	;mov	ah,CHDir ; 3Bh
 21415 00002755 B43B                    	mov	ah,3Bh
 21416 00002757 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21417                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21418                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21419                                  	; 25/02/2023
 21420 00002759 72E3                    	jc	short pcrunch_cderr
 21421                                  				;AN022; go to error exit 
 21422 0000275B 885C01                  	mov	[si+1],bl
 21423                                  cdsucc:
 21424 0000275E E87E05                  	call	SetRest1
 21425 00002761 46                      	inc	si		; Reset zero
 21426 00002762 8936[2A8C]              	mov	[DestTail],si
 21427                                  	; 25/02/2023
 21428                                  	; MSDOS 6.0
 21429 00002766 9C                      	pushf			;AN015; save flags
 21430 00002767 803E[088C]FF            	cmp	byte [DirFlag],-1
 21431                                  				;AN015; don't do parse if in DIR
 21432 0000276C 7408                    	je	short pcrunch_end
 21433                                  				;AN015;
 21434                                  	; MSDOS 3.3 & MSDOS 6.0
 21435 0000276E BF5C00                  	mov	di,FCB  ; 5Ch
 21436                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21437 00002771 B80229                  	mov	ax,2902h	
 21438 00002774 CD21                    	int	21h		; Parse with default drive
 21439                                  			; DOS -	PARSE FILENAME
 21440                                  			; DS:SI	-> string to parse
 21441                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21442                                  			; AL = bit mask	to control parsing
 21443                                  	; MSDOS 3.3
 21444                                  	;retn
 21445                                  
 21446                                  pcrunch_end:
 21447 00002776 9D                      	popf			;AN015; get flags back
 21448 00002777 C3                      	retn
 21449                                  
 21450                                  ;============================================================================
 21451                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21452                                  ;============================================================================
 21453                                  ; 05/10/2018 - Retro DOS v3.0
 21454                                  
 21455                                  ;TITLE	Part7 COMMAND Transient Routines
 21456                                  
 21457                                  ;	More misc routines
 21458                                  
 21459                                  ;---------------------------
 21460                                  ; We can get rid of this switch processing code if we can take
 21461                                  ; care of the remaining two calls to switch, later in the file.
 21462                                  ; However, I have not checked whether or not any other files use
 21463                                  ; switch -- after all, it IS public!
 21464                                  ;---------------------------
 21465                                  
 21466                                  ; 28/03/2023
 21467                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21468                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21469                                  
 21470                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21471                                  
 21472                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21473                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21474                                  
 21475                                  ; ---------------------------------------------------------------------------
 21476                                  
 21477                                  	; 25/02/2023
 21478                                  RETSW:
 21479 00002778 93                      	xchg	ax,bx		; Put switches in AX
 21480 00002779 C3                      	retn
 21481                                  
 21482                                  ; =============== S U B	R O U T	I N E =======================================
 21483                                  
 21484                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21485                                  SWITCH:
 21486 0000277A 31DB                    	xor	bx,bx		; Initialize - no switches set
 21487                                  SWLOOP:
 21488 0000277C E85DFE                  	call	scanoff		; Skip any delimiters
 21489 0000277F 3A06[A98A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21490 00002783 75F3                    	jnz	short RETSW	; No -- we're finished
 21491 00002785 81CB0080                	or	bx,8000h
 21492                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21493 00002789 46                      	inc	si		; Skip over the switch character
 21494 0000278A E84FFE                  	call	scanoff
 21495 0000278D 3C0D                    	cmp	al,0Dh
 21496 0000278F 74E7                    	je	short RETSW	; Oops
 21497 00002791 46                      	inc	si
 21498                                  
 21499                                  	; Convert lower case input to upper case
 21500                                  
 21501 00002792 E852FC                  	call	UPCONV
 21502                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21503                                  
 21504 00002795 BF[3184]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21505                                  				; ("VBAPW" (for MSDOS 3.3))
 21506 00002798 B90600                  	mov	cx,6  ; MSDOS 6.0
 21507                                  	;mov	cx,5  ; MSDOS 3.3
 21508                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21509                                  		
 21510                                  	;nop
 21511                                  		
 21512 0000279B F2AE                    	repne	scasb		; Look for matching switch
 21513 0000279D 7507                    	jnz	short BADSW
 21514 0000279F B80100                  	mov	ax,1
 21515 000027A2 D3E0                    	shl	ax,cl		; Set a bit for the switch
 21516 000027A4 09C3                    	or	bx,ax
 21517                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21518 000027A6 EBD4                    	jmp	short SWLOOP
 21519                                  ;BADSW:
 21520                                  	;jmp	short SWLOOP
 21521                                  ;DRVBAD:
 21522                                  ;	mov	dx,baddrv_ptr
 21523                                  ;	jmp	cerror
 21524                                  EXTERNALJ:
 21525 000027A8 E90501                  	jmp	EXTERNAL
 21526                                  FNDCOM:				; search the internal command table
 21527 000027AB 08C0                    	or	al,al		; Get real length of first arg
 21528 000027AD 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21529                                  				;  to be external.
 21530                                  ; barryf code starts here
 21531                                  
 21532 000027AF E82703                  	call	test_append	; see if APPEND installed
 21533 000027B2 7429                    	jz	short CONTCOM	; not loaded
 21534                                  
 21535                                  APPEND_INTERNAL:
 21536 000027B4 8A0E[2B8B]              	mov	cl,[IDLEN]
 21537 000027B8 B500                    	mov	ch,0
 21538 000027BA 890E[008C]              	mov	[PathPos],cx
 21539                                  	
 21540                                  	; 25/02/2023	
 21541                                  	; MSDOS 6.0
 21542 000027BE FE06[968D]              	inc 	byte [append_exec]
 21543                                  				;AN041; set APPEND to ON
 21544 000027C2 E8B603                  	call	IOSET		; re-direct the o'l io
 21545                                  
 21546 000027C5 BE[2B8B]                	mov	si,IDLEN	; address command name, DS already set	
 21547 000027C8 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21548                                  		
 21549                                  	; MSDOS 6.0
 21550 000027CB BF[BB4D]                	mov	di,append_parse
 21551                                  				;AN010; Get the entry point for PARSE for APPEND
 21552                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21553 000027CE B801AE                  	mov	ax,0AE01h
 21554 000027D1 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21555                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21556                                  			; DX = FFFFh, DS:SI -> buffer
 21557                                  			; Return: buffer at DS:SI filled with a	length byte
 21558                                  			; followed by the uppercase internal command
 21559                                  			; to execute (if length not 0)
 21560                                  	; 25/02/2023
 21561                                  	; INT 2Fh
 21562                                  	; 	AX = AE01h
 21563                                  	; entry:
 21564                                  	; 	DX = magic value FFFFh
 21565                                  	; 	CH = 00h
 21566                                  	; 	CL = length of command name
 21567                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21568                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21569                                  	; return:
 21570                                  	;	DS:SI buffer updated
 21571                                  	;	if length byte is nonzero, the following bytes contain
 21572                                  	;	the uppercase internal command to execute and the command line
 21573                                  	; 	buffer contains the command's parameters
 21574                                  	;	(the first DS:[SI] bytes are ignored)
 21575                                  	;
 21576                                  	; Format of COMMAND.COM command line buffer:
 21577                                  	;	Offset  Size    Description
 21578                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21579                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21580                                  	;	N BYTEs command line text, terminated by 0Dh
 21581                                  	;
 21582                                  	; Format of command name buffer:
 21583                                  	;	Offset  Size    Description
 21584                                  	;	00h     BYTE    length of command name
 21585                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21586                                  
 21587 000027D3 803E[2B8B]00            	cmp	byte [IDLEN],0 ; execute requested
 21588 000027D8 7503                    	jne	short CONTCOM
 21589 000027DA E9A300                  	jmp	CMD_DONE
 21590                                  
 21591                                  	;nop
 21592                                  CONTCOM:			; continue with internal scan
 21593 000027DD BF[B082]                	mov	di,COMTAB
 21594 000027E0 31C9                    	xor	cx,cx
 21595                                  FINDCOM:
 21596 000027E2 BE[2C8B]                	mov	si,ID		; pointer to command argument
 21597 000027E5 8A0D                    	mov	cl,[di]		; load length of internal command
 21598 000027E7 47                      	inc	di		; advance past length
 21599 000027E8 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21600 000027EA 3A0E[2B8B]              	cmp	cl,[IDLEN]	; that of the command argument
 21601 000027EE 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21602 000027F0 890E[008C]              	mov	[PathPos],cx	; store length of command
 21603 000027F4 F3A6                    	repe	cmpsb
 21604                                  ABCD:					
 21605 000027F6 9F                      	lahf			; save the good ol' flags
 21606 000027F7 01CF                    	add	di,cx		; skip over remaining internal, if any
 21607 000027F9 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21608 000027FB A2[B58A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21609 000027FE 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21610 000027FF 8B1D                    	mov	bx,[di]		; load internal command address
 21611 00002801 47                      	inc	di		; skip over the puppy
 21612 00002802 47                      	inc	di
 21613                                  		
 21614                                  	; MSDOS 6.0
 21615 00002803 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21616 00002805 47                      	inc	di
 21617 00002806 47                      	inc	di
 21618 00002807 9E                      	sahf			; remember those flags?
 21619 00002808 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21620                                  
 21621                                  ; All messages get redirected.
 21622                                  
 21623 0000280A 803E[968D]00            	cmp     byte [append_exec],0
 21624                                  				;AN041; APPEND just executed?
 21625 0000280F 7503                    	jnz 	short DONT_SET_IO
 21626                                  				;AN041; Yes - this junk is already set
 21627 00002811 E86703                  	call	IOSET		; re-direct the ol' i/o
 21628                                  
 21629                                  DONT_SET_IO:			;AN041;
 21630                                  
 21631                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21632                                  ; respond to /? only if it is the only command-line argument.
 21633                                  
 21634 00002814 A1[BA8A]                	mov	ax,[COMSW]	; AX = switches after command
 21635 00002817 0B06[C08A]              	or	ax,[AllSwitch]	; AX = all switches
 21636                                  	;and	ax,SwitchQues	
 21637 0000281B 83E020                  	and	ax,20h
 21638 0000281E 7426                    	jz	short DRIVE_CHECK
 21639                                  				; /? not in command line
 21640 00002820 F606[B58A]04            	test	byte [CHKDRV],4	
 21641                                  	;test	byte [CHKDRV],fLimitHelp
 21642 00002825 7407                    	jz	short DO_HELP	; /? allowed in combination
 21643                                  
 21644                                  ; Make sure /? is the only argument on the command line.
 21645                                  
 21646 00002827 833E[7090]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21647 0000282C 7518                    	jne	short DRIVE_CHECK
 21648                                  				; /? not only arg - ignore
 21649                                  
 21650                                  ; Note: this is all the check we need, even against things like /??.
 21651                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21652                                  
 21653                                  DO_HELP:
 21654                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21655                                  
 21656 0000282E 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21657                                      	;mov	ax,no_subst	; AL = no subst's code
 21658 00002830 B80000                  	mov	ax,0
 21659 00002833 50                      	push	ax		; build subst block on stack
 21660                                  
 21661                                  NEXT_HELP_MSG:
 21662 00002834 AD                      	lodsw			; AX = help msg # or zero
 21663 00002835 09C0                    	or	ax,ax
 21664 00002837 7409                    	jz	short HELP_DONE
 21665 00002839 50                      	push	ax		; SS:SP = ptr to subst block
 21666                                  				; (msg # and no_subst byte)
 21667                                  ;; We assume DS = SS.
 21668                                  	
 21669 0000283A 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21670 0000283C E89225                  	call	std_printf	; display help message	
 21671 0000283F 58                      	pop	ax		; remove msg # from stack
 21672 00002840 EBF2                    	jmp	short NEXT_HELP_MSG
 21673                                  
 21674                                  HELP_DONE:
 21675 00002842 58                      	pop	ax		; clean up stack
 21676 00002843 E9BED8                  	jmp	TCOMMAND	
 21677                                  
 21678                                  	; 25/02/2023
 21679                                  	; MSDOS 3.3
 21680                                  	;sahf			; remember those flags?
 21681                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21682                                  	;call	IOSET		; re-direct the ol' i/o
 21683                                  
 21684                                  DRIVE_CHECK:
 21685 00002846 F606[B58A]01            	test	byte [CHKDRV],1
 21686                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21687                                  				; did we wanna check those drives?
 21688 0000284B 7411                    	jz	short NOCHECK
 21689 0000284D A0[B88A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21690 00002850 0A06[B98A]              	or	al,[PARM2]	; us whether those drives were OK
 21691 00002854 3CFF                    	cmp	al,-1
 21692 00002856 7506                    	jne	short NOCHECK
 21693                                  	;jmp	DRVBAD
 21694                                  	; 25/02/2023
 21695                                  DRVBAD:
 21696 00002858 BA[587F]                	mov	dx,baddrv_ptr
 21697 0000285B E9F200                  	jmp	cerror
 21698                                  
 21699                                  ; The user may have omitted the space between the command and its arguments.
 21700                                  ; We need to copy the remainder of the user's command line into the buffer.
 21701                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21702                                  ; into the command line at 80.
 21703                                  
 21704                                  NOCHECK:
 21705 0000285E E85B02                  	call	cmd_copy
 21706                                  SWITCHECK:
 21707                                  	;test	byte [CHKDRV],2
 21708 00002861 F606[B58A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21709                                  				; Does the command take switches
 21710 00002866 7516                    	jnz	short REALWORK	; Yes, process the command
 21711 00002868 E82F00                  	call	noswit		; No, check to see if any switches
 21712 0000286B 7511                    	jnz	short REALWORK	; None, process the command
 21713                                  
 21714                                  	; MSDOS 6.0
 21715                                  	;mov	byte [msg_disp_class],2
 21716 0000286D C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 21717                                  				;AN000; set up parse error msg class
 21718 00002872 BA[FC7E]                	mov	dx,extend_buf_ptr	
 21719                                  				;AC000; get extended message pointer
 21720                                  	;mov	word [extend_buf_ptr],3
 21721 00002875 C706[FC7E]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21722                                  				;AN000; get "Invalid switch" message number
 21723 0000287B E9D200                  	jmp	cerror		; Print error and chill out...
 21724                                  
 21725                                  	; 25/02/2023
 21726                                  	; MSDOS 3.3
 21727                                  	;mov	dx,BADPARMPTR
 21728                                  	;jmp	CERROR
 21729                                  
 21730                                  REALWORK:
 21731 0000287E FFD3                    	call	bx		; do some real work, at last
 21732                                  
 21733                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21734                                  ; otherwise, go get another command.
 21735                                  
 21736                                  CMD_DONE:
 21737 00002880 0E                      	push	cs		; g  restore data segment
 21738 00002881 1F                      	pop	ds		; g
 21739 00002882 1E                      	push	ds
 21740 00002883 8E1E[A58A]              	mov	ds,[RESSEG]	; g  save data segment
 21741                                  	;cmp	byte [Call_Flag],1
 21742                                  				; G  Is a call in progress?
 21743 00002887 803E[9901]01            	cmp	byte [Call_Flag],call_in_progress
 21744 0000288C C606[9901]00            	mov	byte [Call_Flag],0
 21745                                  				; G  Either way, reset flag
 21746 00002891 1F                      	pop	ds		; g  get data segment back
 21747 00002892 7403                    	jz	short INCALL	; G
 21748 00002894 E96DD8                  	jmp	TCOMMAND	; chill out...
 21749                                  INCALL:
 21750 00002897 E93DDA                  	jmp	DOCOM1
 21751                                  
 21752                                  ; =============== S U B	R O U T	I N E =======================================
 21753                                  
 21754                                  	; 25/02/2023
 21755                                  noswit:
 21756 0000289A 57                      	push	di		; Save di
 21757 0000289B BF8100                  	mov	di,81h		; di = ptr to command args
 21758 0000289E BE8000                  	mov	si,80h		; Get address of length of command args
 21759 000028A1 AC                      	lodsb			; Load length
 21760 000028A2 88C1                    	mov	cl,al		; Move length to cl
 21761 000028A4 30ED                    	xor	ch,ch		; Zero ch
 21762 000028A6 2EA0[A98A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21763                                  	;cmp	al,0		; Turn off ZF
 21764                                  	; 25/02/2023
 21765 000028AA 20C0                    	and	al,al
 21766 000028AC F2AE                    	repne	scasb		; Scan for a switch character and return
 21767 000028AE 5F                      	pop	di		;  with ZF set if one was found
 21768 000028AF C3                      	retn
 21769                                  
 21770                                  ; ---------------------------------------------------------------------------
 21771                                  
 21772                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21773                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21774                                  
 21775                                  EXTERNAL:
 21776 000028B0 E82602                  	call	test_append	; check to see if append installed
 21777 000028B3 7403                    	jz	short NOT_BARRYF
 21778                                  				; no - truly external command
 21779 000028B5 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21780                                  
 21781                                  NOT_BARRYF:
 21782 000028B8 2EC606[B68A]00          	mov	byte [cs:FILTYP],0
 21783 000028BE 2E8A16[C38A]            	mov	dl,[cs:SPECDRV]
 21784 000028C3 2E8816[2B8B]            	mov	[cs:IDLEN],dl
 21785 000028C8 2EC606[238C]00          	mov	byte [cs:ROM_CALL],0
 21786 000028CE 52                      	push	dx
 21787 000028CF BA[2B8B]                	mov	dx,IDLEN
 21788 000028D2 E825DB                  	call	ROM_SCAN
 21789 000028D5 5A                      	pop	dx
 21790                                  	;jnc	short POSTSAVE
 21791 000028D6 7305                    	jnc	short DO_SCAN
 21792 000028D8 2EFE06[238C]            	inc	byte [cs:ROM_CALL]
 21793                                  	;jmp	short POSTSAVE
 21794                                  
 21795                                  	;nop
 21796                                  DO_SCAN:
 21797                                  POSTSAVE:
 21798 000028DD BF[CD89]                	mov	di,EXECPATH
 21799 000028E0 C60500                  	mov	byte [di],0	; Initialize to current directory
 21800                                  	
 21801 000028E3 2E803E[238C]00          	cmp	byte [cs:ROM_CALL],0
 21802                                  	;jz	short RESEARCH
 21803                                  	; 25/02/2023
 21804                                  	;jmp	short NEOEXECUTE
 21805 000028E9 750F                    	jnz	short NEOEXECUTE	
 21806                                  
 21807                                  	;nop
 21808                                  RESEARCH:
 21809 000028EB E87208                  	call	path_search	; find the mother (result in execpath)
 21810 000028EE 09C0                    	or	ax,ax		; did we find anything?
 21811                                  	;jz	short BADCOMJ45	; null means no (sob)
 21812                                  	; 25/02/2023
 21813 000028F0 7459                    	jz	short BADCOM
 21814 000028F2 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21815                                  				; fuckin' sixteen-bit machine ought
 21816                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21817                                  				; DISPLACEMENT!!
 21818                                  	;;jmp	short NEOEXECUTE
 21819                                  	;jmp	short EXECUTE	
 21820                                  	; 25/02/2023
 21821 000028F5 7D03                    	jnl	short EXECUTE ; jge
 21822                                  
 21823                                  	; 02H is .bat
 21824                                  
 21825                                  	;nop
 21826                                  BATCOMJ:
 21827 000028F7 E990DE                  	jmp	BATCOM
 21828                                  
 21829                                  	; 25/02/2023
 21830                                  ;BADCOMJ45:
 21831                                  	;jmp	short BADCOM
 21832                                  
 21833                                  	;nop
 21834                                  EXECUTE:
 21835                                  NEOEXECUTE:
 21836 000028FA E87E02                  	call	IOSET
 21837                                  
 21838                                  ; MSDOS 6.0
 21839                                  ;M051
 21840                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21841                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21842                                  ;After a close, this would still leave one open active resulting in sharing
 21843                                  ;errors on subsequent opens of the redirected file.
 21844                                  
 21845                                  LH_EXECUTE:			;M051	
 21846 000028FD 8E06[B38A]              	mov	es,[TRAN_TPA]
 21847                                  	;mov	ah,DEALLOC ; 49h
 21848 00002901 B449                    	mov	ah,49h
 21849 00002903 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21850                                  			; ES = segment address of area to be freed
 21851                                  				; Now running in "free" space
 21852 00002905 8E06[A58A]              	mov	es,[RESSEG]
 21853 00002909 26FE06[8401]            	inc	byte [es:ExtCom] ; Indicate external command
 21854 0000290E 26C606[8C01]00          	mov	byte [es:RestDir],0 
 21855                                  				; Since USERDIR1 is in transient, insure
 21856                                  				; this flag value for re-entry to COMMAND
 21857                                  	; MSDOS 6.0
 21858 00002914 BE[CD89]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21859 00002917 BF[4903]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21860                                  	;mov	cx,LENMSGORPATHBUF
 21861 0000291A B95000                  	mov	cx,80
 21862 0000291D FC                      	cld
 21863 0000291E F3A4                    	rep	movsb		; copy program pathname to resident
 21864                                  
 21865                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21866 00002920 BF5C00                  	mov	di,FCB ; 5Ch
 21867 00002923 89FE                    	mov	si,di
 21868                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21869 00002925 B152                    	mov	cl,82 ; 25/02/2023
 21870 00002927 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21871                                  	
 21872                                  	; 25/02/2023
 21873                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21874                                  	; MSDOS 6.0 (& 5.0)
 21875                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21876 00002929 BA[4903]                	mov	dx,SafePathBuffer
 21877 0000292C 06                      	push	es
 21878 0000292D 1F                      	pop	ds
 21879                                  
 21880                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21881 0000292E BB[2703]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21882                                  	;mov	ax,EXEC*256 ; 4B00h
 21883 00002931 B8004B                  	mov	ax,4B00h
 21884                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21885 00002934 2EF606[238C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21886 0000293A 7403                    	jz	short OK_EXEC
 21887 0000293C E934DB                  	jmp	ROM_EXEC
 21888                                  
 21889                                  OK_EXEC:
 21890                                  
 21891                                  ; we are now running in free space. Anything we do from here on may get
 21892                                  ; trashed. Move the stack (also in free space) to allocated space because
 21893                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21894                                  
 21895 0000293F 8CC1                    	mov	cx,es
 21896 00002941 8ED1                    	mov	ss,cx
 21897 00002943 BC[1E04]                	mov	sp,RStack
 21898                                  	; MSDOS 3.3
 21899                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21900                                  	; 25/02/2023
 21901                                  	; MSDOS 6.0
 21902 00002946 2EFF2E[AB8A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21903                                  
 21904                                  ; ---------------------------------------------------------------------------
 21905                                  
 21906                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21907                                  BADCOM:
 21908 0000294B 0E                      	push	cs
 21909 0000294C 1F                      	pop	ds
 21910 0000294D BA[1F7F]                	mov	dx,BADNAM_PTR
 21911                                  cerror:		
 21912 00002950 E87624                  	call	std_eprintf
 21913 00002953 E9AED7                  	jmp	TCOMMAND
 21914                                  
 21915                                  ; =============== S U B	R O U T	I N E =======================================
 21916                                  
 21917                                  ; Prescan converts the input buffer into a canonicalized form.
 21918                                  ; All redirections and pipes are removed.
 21919                                  
 21920                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21921                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21922                                  
 21923                                  PRESCAN:
 21924 00002956 31C9                    	xor	cx,cx
 21925 00002958 8E06[A58A]              	mov	es,[RESSEG]
 21926 0000295C BE[0689]                	mov	si,COMBUF+2
 21927 0000295F 89F7                    	mov	di,si
 21928                                  COUNTQUOTES:
 21929 00002961 AC                      	lodsb			; get a byte
 21930 00002962 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21931 00002964 7504                    	jne	short COUNTEND	; no, try for end of road
 21932 00002966 FEC5                    	inc	ch		; bump count
 21933 00002968 EBF7                    	jmp	short COUNTQUOTES
 21934                                  				; go get next char
 21935                                  COUNTEND:
 21936 0000296A 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21937 0000296C 75F3                    	jne	short COUNTQUOTES
 21938                                  				; no, go back for next char
 21939                                  	; 26/02/2023
 21940                                  	; MSDOS 5.0 (& 6.0)
 21941 0000296E 51                      	push	cx		; save count
 21942 0000296F 89FE                    	mov	si,di		; restore pointer to begining
 21943                                  KanjiScan:
 21944 00002971 AC                      	lodsb			; get a byte
 21945 00002972 E848FA                  	call	testkanj	; is it a leadin byte
 21946 00002975 740F                    	jz	short KanjiQuote
 21947                                  				; no, check for quotes
 21948 00002977 88C4                    	mov	ah,al		; save leadin
 21949 00002979 AC                      	lodsb			; get trailing byte
 21950 0000297A 3D2020                  	cmp	ax,2020h
 21951                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21952 0000297D 75F2                    	jne	short KanjiScan	; no, go get next
 21953 0000297F C744FE2020              	mov	word [si-2],2020h
 21954                                  				; replace with spaces
 21955 00002984 EBEB                    	jmp	short KanjiScan	; go get next char
 21956                                  	
 21957                                  KanjiQuote:
 21958 00002986 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21959 00002988 750D                    	jne	short KanjiEnd	; no, check for end
 21960 0000298A FECD                    	dec	ch		; drop count
 21961 0000298C 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21962                                  KanjiQuoteLoop:
 21963 0000298E AC                      	lodsb			; get next byte
 21964 0000298F 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21965 00002991 75FB                    	jne	short KanjiQuoteLoop
 21966                                  				; no, get another
 21967 00002993 FECD                    	dec	ch		; yes, drop count
 21968 00002995 EBDA                    	jmp	short KanjiScan	; go get next char
 21969                                  KanjiEnd:
 21970 00002997 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21971 00002999 75D6                    	jne	short KanjiScan	; go back to beginning
 21972 0000299B 59                      	pop	cx		; get back original count
 21973                                  	; 26/04/2023
 21974 0000299C 89FE                    	mov	si,di		; restore pointer to beginning
 21975                                  	
 21976                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21977                                  PRESCANLP:
 21978 0000299E AC                      	lodsb
 21979                                  	; 26/02/2023
 21980 0000299F E81BFA                  	call	testkanj
 21981 000029A2 740C                    	jz	short NOTKANJ6
 21982                                  	; MSDOS 6.0
 21983 000029A4 8805                    	mov	[di],al
 21984 000029A6 47                      	inc	di		; fake STOSB into DS
 21985 000029A7 AC                      	lodsb			; grab second byte
 21986 000029A8 8805                    	mov	[di],al		; fake stosb into DS
 21987 000029AA FEC1                    	inc	cl
 21988 000029AC FEC1                    	inc	cl
 21989 000029AE EBEE                    	jmp	short PRESCANLP
 21990                                  
 21991                                  NOTKANJ6:
 21992                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21993 000029B0 3C22                    	cmp	al,'"'	; 22h	; " character
 21994 000029B2 7510                    	jne	short TRYGREATER
 21995 000029B4 FECD                    	dec	ch
 21996 000029B6 740C                    	jz	short TRYGREATER
 21997                                  QLOOP:
 21998 000029B8 8805                    	mov	[di],al
 21999 000029BA 47                      	inc	di
 22000 000029BB FEC1                    	inc	cl
 22001 000029BD AC                      	lodsb
 22002 000029BE 3C22                    	cmp	al,'"'		; " character
 22003 000029C0 75F6                    	jne	short QLOOP
 22004 000029C2 FECD                    	dec	ch
 22005                                  TRYGREATER:
 22006 000029C4 3C3E                    	cmp	al,'>' ; 3Eh
 22007                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 22008                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 22009 000029C6 7557                    	jne	short NOOUT
 22010                                  
 22011                                  ; We have found a ">" char. We need to see if there is another ">"
 22012                                  ; following it.
 22013                                  
 22014 000029C8 3804                    	cmp	[si],al
 22015 000029CA 7506                    	jne	short NOAPPND
 22016 000029CC AC                      	lodsb
 22017 000029CD 26FE06[AE01]            	inc	byte [es:Re_Out_App] ; Flag >>
 22018                                  NOAPPND:
 22019                                  ; Now we attempt to find the file name. First, scan off all whitespace
 22020                                  
 22021 000029D2 E807FC                  	call	scanoff
 22022                                  
 22023                                  	; 26/02/2023
 22024                                  	; MSDOS 6.0
 22025 000029D5 3C3C                    	cmp	al,'<' ; 3Ch
 22026                                  	;cmp	al,labracket	;AN040; was there no filename?
 22027 000029D7 7404                    	je	short REOUT_ERRSET
 22028                                  				;AN040; yes - set up error
 22029                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22030 000029D9 3C0D                    	cmp	al,0Dh
 22031 000029DB 750D                    	jnz	short GOTREOFIL
 22032                                  
 22033                                  ; There was no file present. Set us up at end-of-line.
 22034                                  
 22035                                  REOUT_ERRSET:			;AN040; set up for an error
 22036 000029DD C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 22037 000029E0 26C706[AF01]0900        	mov	word [es:Re_OutStr],9
 22038                                  				; Cause an error later
 22039 000029E7 E9A900                  	jmp	PRESCANEND
 22040                                  
 22041                                  GOTREOFIL:
 22042 000029EA 57                      	push	di
 22043                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 22044 000029EB BF[AF01]                	mov	di,Re_OutStr
 22045 000029EE 89FB                    	mov	bx,di
 22046 000029F0 06                      	push	es
 22047                                  
 22048                                  	; 26/02/2023
 22049                                  	; MSDOS 6.0
 22050                                  SETREOUTSTR:			; Get the output redirection name
 22051                                  				; MSKK06 07/14/89
 22052 000029F1 51                      	push	cx		; save cx
 22053 000029F2 B94D00                  	mov	cx,64+13	; CX = max string length
 22054                                  SETREOUTSTR_LOOP:
 22055 000029F5 AC                      	lodsb
 22056 000029F6 3C0D                    	cmp	al,0Dh
 22057 000029F8 741A                    	je	short GOTRESTR_J
 22058 000029FA E8E7FB                  	call	DELIM
 22059 000029FD 7415                    	jz	short GOTRESTR_J
 22060 000029FF 3A06[A98A]              	cmp	al,[SWITCHAR]
 22061 00002A03 740F                    	je	short GOTRESTR_J
 22062 00002A05 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 22063 00002A07 7413                    	je	short PIPEERRSYNJ5_J
 22064                                  				;AN033; Yes - get out quick - or system crashes
 22065 00002A09 3C3C                    	cmp	al,'<' ; 3Ch
 22066                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 22067 00002A0B 7404                    	je	short ABRACKET_TERM
 22068                                  				;AN002; yes - end of string
 22069 00002A0D 3C3E                    	cmp	al,'>' ; 3Eh
 22070                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 22071 00002A0F 7506                    	jne	short NO_ABRACKET
 22072                                  				;AN002; no - not end of string
 22073                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 22074 00002A11 4E                      	dec	si		;AN002; back up over symbol
 22075 00002A12 B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 22076                                  GOTRESTR_J:
 22077 00002A14 59                      	pop	cx		; MSKK06 07/14/89
 22078 00002A15 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 22079                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 22080 00002A17 AA                      	stosb			; store it into resgroup
 22081 00002A18 E2DB                    	loop	SETREOUTSTR_LOOP
 22082                                  				; MSKK06 07/14/89
 22083 00002A1A EBF8                    	jmp	short GOTRESTR_J
 22084                                  PIPEERRSYNJ5_J:
 22085 00002A1C 59                      	pop	cx		; recover CX
 22086 00002A1D EB4B                    	jmp	short PIPEERRSYNJ5
 22087                                  
 22088                                  	; 26/02/2023
 22089                                  ;	; MSDOS 3.3
 22090                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 22091                                  ;	lodsb
 22092                                  ;	cmp	al,0Dh
 22093                                  ;	jz	short GOTRESTR
 22094                                  ;	call	DELIM
 22095                                  ;	jz	short GOTRESTR
 22096                                  ;	cmp	al,[SWITCHAR]
 22097                                  ;	je	short GOTRESTR
 22098                                  ;	cmp	al,'"'
 22099                                  ;	jne	short NO_ABRACKET
 22100                                  ;	dec	ch
 22101                                  ;NO_ABRACKET:
 22102                                  ;	stosb
 22103                                  ;	jmp	short SETREOUTSTR_LOOP
 22104                                  
 22105                                  NOOUT:
 22106                                  	; 26/02/2023
 22107                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22108 00002A1F 3C3C                    	cmp	al, '<' ; 3Ch
 22109                                  	;cmp	al,labracket	; MSDOS 6.0
 22110                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 22111 00002A21 7523                    	jne	short CHKPIPE
 22112 00002A23 89F3                    	mov	bx,si		; Save loc of "<"
 22113 00002A25 E8B4FB                  	call	scanoff
 22114                                  	; MSDOS 6.0
 22115 00002A28 3C3E                    	cmp	al,'>' ; 3Eh
 22116                                  	;cmp	al,rabracket	;AN040; was there no filename?
 22117 00002A2A 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 22118                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22119 00002A2C 3C0D                    	cmp	al,0Dh
 22120 00002A2E 750B                    	jne	short GOTREIFIL
 22121                                  REIN_ERRSET:			;AN040; set up for error
 22122 00002A30 C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 22123 00002A33 C706[508A]0900          	mov	word [RE_INSTR],9 
 22124                                  				; Cause an error later
 22125 00002A39 EB58                    	jmp	short PRESCANEND
 22126                                  GOTREIFIL:
 22127 00002A3B 57                      	push	di
 22128 00002A3C BF[508A]                	mov	di,RE_INSTR
 22129 00002A3F 89FB                    	mov	bx,di
 22130 00002A41 06                      	push	es
 22131 00002A42 0E                      	push	cs
 22132 00002A43 07                      	pop	es		; store in TRANGROUP
 22133                                  	; 26/04/2023
 22134                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 22135 00002A44 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 22136                                  				; Get the input redirection name
 22137                                  CHKPIPE:
 22138 00002A46 88C4                    	mov	ah,al
 22139                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22140 00002A48 80FC7C                  	cmp	ah,'|' ; 7Ch
 22141                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 22142                                  	;je	short ISPIPE3
 22143                                  	;; MSDOS 6.0
 22144                                  	;cmp	ah,'|' ; 7Ch
 22145                                  	;;cmp	al,vbar ; 7Ch
 22146                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 22147 00002A4B 7539                    	jne	short CONTPRESCAN
 22148                                  ISPIPE3:
 22149                                  ; Only push the echo flag if we are entering the pipe for the first time.
 22150                                  
 22151 00002A4D 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22152 00002A53 7505                    	jne	short NOECHOPUSH
 22153 00002A55 26D026[8801]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 22154                                  NOECHOPUSH:
 22155 00002A5A 26FE06[0002]            	inc	byte [es:PipeFlag]
 22156 00002A5F E87AFB                  	call	scanoff
 22157 00002A62 3C0D                    	cmp	al,0Dh
 22158 00002A64 7404                    	je	short PIPEERRSYNJ5
 22159                                  	; 26/02/2023
 22160 00002A66 3C7C                    	cmp	al,'|' ; 7Ch
 22161                                  	;cmp	al,ALTPIPECHR ; 7Ch
 22162                                  	;je	short PIPEERRSYNJ5
 22163                                  	;; MSDOS 6.0
 22164                                  	;cmp	al,'|' ; 7Ch
 22165                                  	;;cmp	al,vbar ; 7Ch
 22166                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 22167 00002A68 751C                    	jne	short CONTPRESCAN
 22168                                  
 22169                                  PIPEERRSYNJ5:
 22170 00002A6A 06                      	push	es
 22171 00002A6B 1F                      	pop	ds
 22172 00002A6C E99C02                  	jmp	PIPEERRSYN
 22173                                  
 22174                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 22175                                  ; than just a : in the redir string.
 22176                                  
 22177                                  GOTRESTR:
 22178 00002A6F 86E0                    	xchg	ah,al
 22179 00002A71 B03A                    	mov	al,':' ; 3Ah
 22180 00002A73 29FB                    	sub	bx,di		; compute negative of number of chars
 22181 00002A75 83FBFF                  	cmp	bx,-1		; is there just a :?
 22182 00002A78 7407                    	je	short NOTRAILCOL ; yep, don't change
 22183 00002A7A 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 22184 00002A7E 7501                    	jne	short NOTRAILCOL
 22185 00002A80 4F                      	dec	di		; Back up over trailing ':'
 22186                                  NOTRAILCOL:
 22187 00002A81 30C0                    	xor	al,al
 22188 00002A83 AA                      	stosb			; NUL terminate the string
 22189 00002A84 07                      	pop	es
 22190 00002A85 5F                      	pop	di		; Remember the start
 22191                                  CONTPRESCAN:
 22192 00002A86 8825                    	mov	[di],ah		; "delete" the redirection string
 22193 00002A88 47                      	inc	di
 22194 00002A89 80FC0D                  	cmp	ah,0Dh
 22195 00002A8C 7405                    	je	short PRESCANEND
 22196 00002A8E FEC1                    	inc	cl
 22197 00002A90 E90BFF                  	jmp	PRESCANLP
 22198                                  PRESCANEND:
 22199 00002A93 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22200 00002A99 7414                    	jz	short ISNOPIPE
 22201                                  
 22202                                  	; 26/02/2023
 22203                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 22204                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 22205                                  	;;			; (EndInit+160]
 22206                                  	;mov	di,offset RESGROUP:PIPESTR
 22207 00002A9B BF[A202]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 22208                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 22209                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 22210 00002A9E 26893E[A002]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 22211                                  	
 22212 00002AA3 BE[0689]                	mov	si,COMBUF+2
 22213 00002AA6 E833FB                  	call	scanoff
 22214                                  PIPESETLP:			; Transfer the pipe into the resident
 22215 00002AA9 AC                      	lodsb			; pipe buffer
 22216 00002AAA AA                      	stosb
 22217 00002AAB 3C0D                    	cmp	al,0Dh
 22218 00002AAD 75FA                    	jnz	short PIPESETLP
 22219                                  ISNOPIPE:
 22220 00002AAF 880E[0589]              	mov	[COMBUF+1],cl
 22221 00002AB3 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22222 00002AB9 0E                      	push	cs
 22223 00002ABA 07                      	pop	es
 22224 00002ABB C3                      	retn
 22225                                  
 22226                                  ; =============== S U B	R O U T	I N E =======================================
 22227                                  
 22228                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22229                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 22230                                  cmd_copy:
 22231 00002ABC BE[0689]                	mov	si,COMBUF+2
 22232 00002ABF E81AFB                  	call	scanoff		; advance past separators...
 22233 00002AC2 0336[008C]              	add	si,[PathPos]
 22234 00002AC6 BF8100                  	mov	di,81h
 22235 00002AC9 31C9                    	xor	cx,cx
 22236                                  cmdcopy:
 22237 00002ACB AC                      	lodsb
 22238 00002ACC AA                      	stosb
 22239 00002ACD 3C0D                    	cmp	al,0Dh
 22240 00002ACF 7403                    	je	short copy_done
 22241 00002AD1 41                      	inc	cx
 22242 00002AD2 EBF7                    	jmp	short cmdcopy
 22243                                  copy_done:
 22244 00002AD4 880E8000                	mov	[80h],cl
 22245 00002AD8 C3                      	retn
 22246                                  
 22247                                  ; =============== S U B	R O U T	I N E =======================================
 22248                                  
 22249                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22250                                  test_append:
 22251 00002AD9 BB[0489]                	mov	bx,COMBUF	; barry can address
 22252 00002ADC BE[2B8B]                	mov	si,IDLEN	; address command name, DS already set 	
 22253 00002ADF BAFFFF                  	mov	dx,-1
 22254 00002AE2 B800AE                  	mov	ax,0AE00h
 22255 00002AE5 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 22256                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 22257                                  			; DX = FFFFh,[BX -> command line
 22258                                  			; Return: AL = FFh if this command is a TSR extension 
 22259                                  			;		   to COMMAND.COM
 22260                                  			; AL = 00h if the command should be executed as	usual
 22261                                  	;cmp	al,0
 22262 00002AE7 08C0                    	or	al,al ; 25/02/2023
 22263 00002AE9 C3                      	retn
 22264                                  
 22265                                  	; 25/02/2023
 22266                                  	; INT 2Fh
 22267                                  	; 	AX = AE00h
 22268                                  	; entry:
 22269                                  	; 	DX = magic value FFFFh
 22270                                  	; 	CH = FFh
 22271                                  	; 	CL = length of command line tail
 22272                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22273                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22274                                  	; return:
 22275                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 22276                                  	;	AL = 00h if the command should be executed as usual
 22277                                  	;
 22278                                  	; Format of COMMAND.COM command line buffer:
 22279                                  	;	Offset  Size    Description
 22280                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22281                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22282                                  	;	N BYTEs command line text, terminated by 0Dh
 22283                                  	;
 22284                                  	; Format of command name buffer:
 22285                                  	;	Offset  Size    Description
 22286                                  	;	00h     BYTE    length of command name
 22287                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22288                                  
 22289                                  ;============================================================================
 22290                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 22291                                  ;============================================================================
 22292                                  ; 05/10/2018 - Retro DOS v3.0
 22293                                  
 22294                                  ;	More misc routines
 22295                                  
 22296                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 22297                                  
 22298                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22299                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 22300                                  
 22301                                  ; =============== S U B	R O U T	I N E =======================================
 22302                                  
 22303                                  SETPATH:
 22304                                  
 22305                                  ; ENTRY PathPos = ptr to string
 22306                                  ;       PathCnt = length of string
 22307                                  ;
 22308                                  ; EXIT  PathPos = ptr to string after pathname
 22309                                  ;       PathCnt = length of rest of string
 22310                                  ;       DX = ptr to pathname in string, made ASCIIZ
 22311                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 22312                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 22313                                  ;
 22314                                  ;       A null character is dropped at the end of the pathname. If the
 22315                                  ;       character in that spot previously was CR, it is copied into the
 22316                                  ;       following byte. So there must be at least two two character 
 22317                                  ;       positions in the buffer following the pathname.
 22318                                  
 22319                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22320                                  	; 11/06/2023
 22321                                  	; MSDOS 6.0
 22322                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 22323                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 22324                                  
 22325                                  	; 26/02/2023
 22326                                  	; MSDOS 3.3
 22327                                  	;mov	si,80h
 22328                                  	;lodsb
 22329                                  	;xor	ah,ah
 22330                                  	;mov	[PATCNT],ax
 22331                                  	;mov	[PATHPOS],si
 22332                                  GETPATH:
 22333                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22334 00002AEA C606[2C8C]00            	mov	byte [DestInfo],0
 22335 00002AEF C606[288C]00            	mov	byte [DestIsDir],0
 22336 00002AF4 8B36[008C]              	mov	si,[PathPos]	; SI = ptr to string
 22337 00002AF8 8B0E[FE8B]              	mov	cx,[PathCnt]	; CX = string length
 22338 00002AFC 89F2                    	mov	dx,si		; DX = ptr to string
 22339 00002AFE E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 22340 00002B00 51                      	push	cx		; save string length
 22341 00002B01 56                      	push	si		; save ptr to string
 22342 00002B02 E875FC                  	call	SWITCH
 22343                                  
 22344                                  ;       After Switch, SI has been scanned past any switches, and
 22345                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22346                                  
 22347 00002B05 A3[028C]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22348 00002B08 5B                      	pop	bx		; BX = ptr to original string
 22349 00002B09 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22350 00002B0B 59                      	pop	cx		; CX = string length
 22351 00002B0C 01D9                    	add	cx,bx		; CX = string length from current SI
 22352 00002B0E 89F2                    	mov	dx,si		; DX = ptr to current string
 22353                                  SKIPPATH:
 22354                                  	; 26/02/2023
 22355                                  	; MSDOS 6.0
 22356 00002B10 C606[AF8D]00            	mov	byte [KPARSE],0
 22357                                  SKIPPATH2:
 22358 00002B15 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22359 00002B17 49                      	dec	cx		; CX = length left after next char
 22360 00002B18 AC                      	lodsb			; AL = next char of string
 22361                                  				; SI = ptr to char after this one
 22362                                  	; 26/02/2023
 22363 00002B19 E8A1F8                  	call	testkanj
 22364 00002B1C 7408                    	jz	short TESTPPSEP
 22365 00002B1E 49                      	dec	cx
 22366 00002B1F 46                      	inc	si
 22367 00002B20 FE06[AF8D]              	inc	byte [KPARSE]
 22368 00002B24 EBEF                    	jmp	short SKIPPATH2
 22369                                  TESTPPSEP:
 22370 00002B26 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 22371 00002B29 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22372 00002B2B FE06[288C]              	inc	byte [DestIsDir]
 22373                                  				; DestIsDir = 1, signalling path char
 22374                                  TESTPMETA:
 22375 00002B2F 3C3F                    	cmp	al,'?'
 22376 00002B31 7505                    	jne	short TESTPSTAR	; char is not '?'
 22377 00002B33 800E[2C8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22378                                  TESTPSTAR:
 22379 00002B38 3C2A                    	cmp	al,'*'
 22380                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22381 00002B3A 7505                    	jne	short TESTPDELIM ; char is not '*'
 22382 00002B3C 800E[2C8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22383                                  TESTPDELIM:
 22384 00002B41 E8A0FA                  	call	DELIM		; compare AL to all delimiters
 22385 00002B44 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22386 00002B46 3A06[A98A]              	cmp	al,[SWITCHAR]
 22387 00002B4A 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22388                                  PATHDONEDEC:
 22389 00002B4C 4E                      	dec	si		; SI = ptr to char after pathname
 22390                                  PATHDONE:
 22391 00002B4D 30C0                    	xor	al,al		; AL = NULL
 22392 00002B4F 8604                    	xchg	al,[si]		; place NULL after pathname
 22393 00002B51 46                      	inc	si		; SI = ptr to byte after NULL
 22394 00002B52 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22395 00002B54 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22396 00002B56 8804                    	mov	[si],al		; save EOL after NULL
 22397                                  NOPSTORE:
 22398 00002B58 8936[008C]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22399 00002B5C 890E[FE8B]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22400                                  SETPATH_RETN:
 22401 00002B60 C3                      	retn
 22402                                  
 22403                                  ; ---------------------------------------------------------------------------
 22404                                  
 22405                                  PGETARG:
 22406 00002B61 BE8000                  	mov	si,80h
 22407 00002B64 AC                      	lodsb
 22408 00002B65 08C0                    	or	al,al
 22409 00002B67 74F7                    	jz	short SETPATH_RETN
 22410 00002B69 E80300                  	call	PSCANOFF
 22411 00002B6C 3C0D                    	cmp	al,0Dh
 22412 00002B6E C3                      	retn
 22413                                  
 22414                                  ; ---------------------------------------------------------------------------
 22415                                  
 22416                                  PSCANOFF:
 22417 00002B6F AC                      	lodsb
 22418 00002B70 E871FA                  	call	DELIM
 22419 00002B73 7504                    	jnz	short PSCANOFFD
 22420 00002B75 3C3B                    	cmp	al,';' ; 3Bh
 22421 00002B77 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22422                                  PSCANOFFD:
 22423 00002B79 4E                      	dec	si		; Point to first non-delimiter
 22424 00002B7A C3                      	retn
 22425                                  
 22426                                  ; =============== S U B	R O U T	I N E =======================================
 22427                                  
 22428                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22429                                  IOSET:
 22430                                  	; ALL REGISTERS PRESERVED
 22431 00002B7B 1E                      	push	ds
 22432 00002B7C 52                      	push	dx
 22433 00002B7D 50                      	push	ax
 22434 00002B7E 53                      	push	bx
 22435 00002B7F 51                      	push	cx
 22436 00002B80 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22437 00002B85 803E[0002]00            	cmp	byte [PipeFlag],0
 22438 00002B8A 750D                    	jne	short NOREDIR
 22439 00002B8C F606[9301]FF            	test	byte [IfFlag],0FFh
 22440 00002B91 7506                    	jnz	short NOREDIR
 22441 00002B93 E88C00                  	call	TESTDOREIN
 22442 00002B96 E80600                  	call	TESTDOREOUT
 22443                                  NOREDIR:
 22444 00002B99 59                      	pop	cx
 22445 00002B9A 5B                      	pop	bx
 22446 00002B9B 58                      	pop	ax
 22447 00002B9C 5A                      	pop	dx
 22448 00002B9D 1F                      	pop	ds
 22449                                  IOSET_RETN:	; 06/08/2024
 22450 00002B9E C3                      	retn
 22451                                  
 22452                                  ; =============== S U B	R O U T	I N E =======================================
 22453                                  
 22454                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22455                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22456                                  	; 06/08/2024
 22457                                  TESTDOREOUT:
 22458 00002B9F 803E[AF01]00            	cmp	byte [Re_OutStr],0
 22459                                  	;je	short NOREOUT  ; MSDOS 3.3
 22460                                  	; 26/02/2023
 22461                                  	;jne	short REOUTEXISTS
 22462                                  	;jmp	NOREOUT
 22463                                  	; 06/08/2024
 22464 00002BA4 74F8                    	jz	short IOSET_RETN
 22465                                  REOUTEXISTS:
 22466 00002BA6 803E[AE01]00            	cmp	byte [Re_Out_App],0
 22467 00002BAB 745D                    	je	short REOUTCRT
 22468                                  
 22469 00002BAD BA[AF01]                	mov	dx,Re_OutStr
 22470                                  
 22471                                  	; 26/02/2023
 22472                                  	; MSDOS 6.0
 22473                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22474 00002BB0 B8023D                  	mov	ax,3D02h
 22475                                  	; MSDOS 3.3
 22476                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22477                                  	
 22478                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22479 00002BB3 50                      	push	ax
 22480 00002BB4 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22481                                  			; DS:DX	-> ASCIZ filename
 22482                                  			; AL = access mode
 22483                                  			; 1 - write
 22484 00002BB6 5B                      	pop	bx
 22485 00002BB7 724B                    	jc	short OpenWriteError
 22486                                  
 22487                                  	; 26/02/2023
 22488                                  	; MSDOS 6.0
 22489 00002BB9 89C3                    	mov	bx,ax
 22490                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22491 00002BBB B80044                  	mov	ax,4400h
 22492 00002BBE CD21                    	int	21h			;AN035;
 22493                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22494                                  			; BX = file or device handle
 22495 00002BC0 F6C280                  	test	dl,80h
 22496                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22497 00002BC3 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22498                                  
 22499                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22500 00002BC5 B80242                  	mov	ax,4202h
 22501 00002BC8 B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22502 00002BCB 89CA                    	mov	dx,cx			;AC011;
 22503 00002BCD CD21                    	int	21h
 22504                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22505                                  			; AL = method: offset from end of file
 22506 00002BCF 0E                      	push	cs			;AN011; Get transient seg to DS
 22507 00002BD0 1F                      	pop	ds			;AN011;
 22508                                  
 22509                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22510 00002BD1 B8003F                  	mov	ax,3F00h
 22511 00002BD4 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22512 00002BD7 BA[208C]                	mov	dx,One_Char_Val		;AN011;
 22513 00002BDA CD21                    	int	21h			;AN011;
 22514                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22515                                  			; BX = file handle, CX = number of bytes to read
 22516                                  			; DS:DX -> buffer
 22517 00002BDC 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22518 00002BDE 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22519 00002BE0 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22520                                  
 22521 00002BE2 803E[208C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22522 00002BE7 8E1E[A58A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22523 00002BEB 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22524                                  	
 22525                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22526 00002BED B80142                  	mov	ax,4201h
 22527 00002BF0 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22528                                  setreout_p:	; 26/02/2023
 22529 00002BF3 89CA                    	mov	dx,cx			;AN011;
 22530 00002BF5 CD21                    	int	21h			;AN011;
 22531 00002BF7 EB20                    	jmp	short SET_REOUT
 22532                                  reout_0_length: 			;AN017; We have a 0 length file
 22533                                  	; ds = cs ; 26/02/2023
 22534                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22535                                  					;AN017; Get resident segment back
 22536                                  	; 26/02/2023
 22537 00002BF9 8E1E[A58A]              	mov	ds,[RESSEG]
 22538                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22539 00002BFD B80042                  	mov	ax,4200h
 22540 00002C00 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22541                                  	;mov	dx,cx			;AN017;
 22542                                  	;int	21h			;AN017;
 22543                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22544                                  	; 26/02/2023
 22545 00002C02 EBEF                    	jmp	short setreout_p
 22546                                  
 22547                                  	; 26/02/2023
 22548                                  	; MSDOS 3.3
 22549                                  	;xor	dx,dx
 22550                                  	;xor	cx,cx
 22551                                  	;mov	bx,ax
 22552                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22553                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22554                                  	;		; AL = method: offset from end of file
 22555                                  	;jmp	short SET_REOUT
 22556                                  
 22557                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22558                                  OpenWriteError:	
 22559                                  	;cmp	ax,5
 22560 00002C04 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22561 00002C07 F9                      	stc
 22562                                  	;;je	short REDIRERR ; MSDOS 3.3
 22563                                  	; 26/02/2023
 22564                                  	;jnz	short REOUTCRT
 22565                                  	;jmp	REDIRERR
 22566 00002C08 743B                    	je	short REDIRERR
 22567                                  
 22568                                  REOUTCRT:
 22569 00002C0A BA[AF01]                	mov	dx,Re_OutStr
 22570 00002C0D 31C9                    	xor	cx,cx
 22571                                  	;mov	ah,CREAT ; 3Ch
 22572 00002C0F B43C                    	mov	ah,3Ch
 22573 00002C11 50                      	push	ax
 22574 00002C12 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22575                                  			; CX = attributes for file
 22576                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22577 00002C14 5B                      	pop	bx
 22578                                  	;jc	short REDIRERR ; MSDOS 3.3
 22579                                  	; 26/02/2023
 22580                                  	;jnc	short NOREDIRERR
 22581                                  	;jmp	REDIRERR
 22582 00002C15 722E                    	jc	short REDIRERR
 22583                                  
 22584                                  NOREDIRERR:
 22585 00002C17 89C3                    	mov	bx,ax
 22586                                  SET_REOUT:
 22587                                  
 22588                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22589                                  ; spot. We invalidate the new JFN we got.
 22590                                  
 22591 00002C19 B0FF                    	mov	al,0FFh
 22592                                  	;xchg	al,[bx+18h]
 22593 00002C1B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22594 00002C1E A21900                  	mov	[PDB.JFN_TABLE+1],al
 22595                                  	; 06/08/2024
 22596                                  NOREOUT:
 22597                                  ;IOSET_RETN:	; 17/04/2023
 22598 00002C21 C3                      	retn
 22599                                  
 22600                                  ; =============== S U B	R O U T	I N E =======================================
 22601                                  
 22602                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22603                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22604                                  	; 06/08/2024
 22605                                  TESTDOREIN:
 22606 00002C22 2E803E[508A]00          	cmp	byte [cs:RE_INSTR],0
 22607                                  	;jz	short IOSET_RETN
 22608                                  	; 06/08/2024
 22609 00002C28 74F7                    	jz	short NOREOUT
 22610 00002C2A 1E                      	push	ds
 22611 00002C2B 0E                      	push	cs
 22612 00002C2C 1F                      	pop	ds
 22613 00002C2D BA[508A]                	mov	dx,RE_INSTR
 22614                                  	;mov	ax,OPEN*256 ; 3D00h
 22615 00002C30 B8003D                  	mov	ax,3D00h
 22616 00002C33 89C3                    	mov	bx,ax
 22617 00002C35 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22618                                  			; DS:DX	-> ASCIZ filename
 22619                                  			; AL = access mode
 22620                                  			; 0 - read
 22621 00002C37 1F                      	pop	ds
 22622                                  
 22623 00002C38 720B                    	jc	short REDIRERR
 22624                                  
 22625 00002C3A 89C3                    	mov	bx,ax
 22626 00002C3C B0FF                    	mov	al,0FFh
 22627                                  
 22628                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22629                                  ; spot. We invalidate the new JFN we got.
 22630                                  
 22631                                  	;xchg	al,[bx+18h]
 22632 00002C3E 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22633 00002C41 A21800                  	mov	[PDB.JFN_TABLE],al
 22634 00002C44 C3                      	retn
 22635                                  
 22636                                  ; ---------------------------------------------------------------------------
 22637                                  
 22638                                  ; We had some kind of error on the redirection. Figure out what the
 22639                                  ; appropriate message should be; BX has the system call that failed
 22640                                  
 22641                                  REDIRERR:
 22642 00002C45 0E                      	push	cs
 22643 00002C46 1F                      	pop	ds
 22644 00002C47 E82E00                  	call	TriageError  ; MSDOS 6.0
 22645                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22646                                  
 22647                                  ; At this point, we have recognized the network-generated access denied error.
 22648                                  ; The correct message is in DX
 22649                                  
 22650 00002C4A 83F841                  	cmp	ax,65
 22651 00002C4D 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22652 00002C4F 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22653 00002C52 7406                    	je	short OpenError
 22654 00002C54 BA[167F]                	mov	dx,FULLDIR_PTR
 22655                                  _CERRORJ:
 22656 00002C57 E9F6FC                  	jmp	cerror
 22657                                  
 22658                                  OpenError:
 22659                                  ; The system call was an OPEN. Report either file not found or path not found.
 22660                                  
 22661                                  	; 26/02/2023
 22662                                  	; MSDOS 6.0
 22663                                  	;mov	byte [cs:msg_disp_class],1
 22664 00002C5A 2EC606[FA7E]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22665                                  				;AN000; set up extended error msg class
 22666 00002C60 BA[FC7E]                	mov	dx,extend_buf_ptr
 22667                                  				;AC000; get extended message pointer
 22668 00002C63 2EA3[FC7E]              	mov	[cs:extend_buf_ptr],ax
 22669                                  				;AN000; get message number in control block
 22670 00002C67 E9E6FC                  	jmp	cerror
 22671                                  
 22672                                  	; 26/02/2023
 22673                                  	; MSDOS 3.3
 22674                                  	;mov	dx,FNOTFOUNDPTR
 22675                                  	;;cmp	ax,2
 22676                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22677                                  	;je	short _CERRORJ
 22678                                  	;mov	dx,ACCDENPTR
 22679                                  	;;cmp	ax,5 ; Access denied error
 22680                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22681                                  	;je	short _CERRORJ
 22682                                  	;	; ERROR_PATH_NOT_FOUND
 22683                                  	;mov	dx,PNOTFOUNDPTR
 22684                                  	;jmp	CERROR
 22685                                  
 22686                                  ; =============== S U B	R O U T	I N E =======================================
 22687                                  
 22688                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22689                                  ; registers
 22690                                  
 22691                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22692                                  dstrlen:
 22693 00002C6A 50                      	push	ax
 22694 00002C6B 31C9                    	xor	cx,cx
 22695 00002C6D FC                      	cld
 22696                                  dloop:
 22697 00002C6E AC                      	lodsb
 22698 00002C6F 41                      	inc	cx
 22699 00002C70 08C0                    	or	al,al
 22700 00002C72 75FA                    	jnz	short dloop
 22701 00002C74 29CE                    	sub	si,cx
 22702 00002C76 58                      	pop	ax
 22703                                  TRIAGEERR_RETN:
 22704 00002C77 C3                      	retn
 22705                                  
 22706                                  ; =============== S U B	R O U T	I N E =======================================
 22707                                  
 22708                                  ;Break	<Extended error support>
 22709                                  
 22710                                  TriageError:  ; MSDOS 6.0
 22711                                  
 22712                                  ; TriageError will examine the return from a carry-set system call and
 22713                                  ; return the correct error if applicable.
 22714                                  ;
 22715                                  ;   Inputs:	outputs from a carry-settable system call
 22716                                  ;		No system calls may be done in the interrim
 22717                                  ;   Outputs:	If carry was set on input
 22718                                  ;		   carry set on output
 22719                                  ;		   DX contains trangroup offset to printf message
 22720                                  ;		else
 22721                                  ;		   No registers changed
 22722                                  
 22723                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22724                                  
 22725                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22726                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22727                                  
 22728                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22729 00002C78 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22730 00002C7A 9C                      	pushf
 22731 00002C7B 53                      	push	bx
 22732 00002C7C 51                      	push	cx
 22733 00002C7D 56                      	push	si
 22734 00002C7E 57                      	push	di
 22735 00002C7F 55                      	push	bp
 22736 00002C80 06                      	push	es
 22737 00002C81 1E                      	push	ds
 22738 00002C82 50                      	push	ax
 22739 00002C83 52                      	push	dx
 22740 00002C84 B459                    	mov	ah,59h
 22741                                  	;mov	ah,GETEXTENDEDERROR
 22742 00002C86 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22743                                  			; BX = version code (0000h for DOS 3.x)
 22744 00002C88 59                      	pop	cx
 22745 00002C89 5B                      	pop	bx		; restore original AX
 22746 00002C8A BA[227F]                	mov	dx,ACCDEN_PTR
 22747 00002C8D 83F841                  	cmp	ax,65		; network access denied?
 22748 00002C90 7404                    	je	short NoMove	; Yes, return it.
 22749 00002C92 89D8                    	mov	ax,bx
 22750 00002C94 89CA                    	mov	dx,cx
 22751                                  NoMove:
 22752 00002C96 1F                      	pop	ds
 22753 00002C97 07                      	pop	es
 22754 00002C98 5D                      	pop	bp
 22755 00002C99 5F                      	pop	di
 22756 00002C9A 5E                      	pop	si
 22757 00002C9B 59                      	pop	cx
 22758 00002C9C 5B                      	pop	bx
 22759 00002C9D 9D                      	popf
 22760 00002C9E C3                      	retn
 22761                                  
 22762                                  ; =============== S U B	R O U T	I N E =======================================
 22763                                  
 22764                                  	; Far call from resident portion/segment of COMMAND.COM
 22765                                  
 22766                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22767                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22768                                  
 22769                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22770                                  Triage_Init:
 22771 00002C9F E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22772                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22773 00002CA2 CB                      	retf
 22774                                  
 22775                                  ; =============== S U B	R O U T	I N E =======================================
 22776                                  
 22777                                  ; MSDOS 6.0
 22778                                  
 22779                                  ; ****************************************************************
 22780                                  ; *
 22781                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22782                                  ; *
 22783                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22784                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22785                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22786                                  ; *
 22787                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22788                                  ; *		 ES    points to TRANGROUP
 22789                                  ; *
 22790                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22791                                  ; *		 PATHCNT set to length of string
 22792                                  ; *		 PATHPOS set to start of SRCBUF
 22793                                  ; *		 CX,AX	 changed
 22794                                  ; *
 22795                                  ; ****************************************************************
 22796                                  
 22797                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22798                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22799                                  Move_To_SrcBuf:
 22800 00002CA3 56                      	push	si			;AN000;  save si,di
 22801 00002CA4 57                      	push	di			;AN000;
 22802 00002CA5 51                      	push	cx			;AN000;
 22803 00002CA6 BF[908C]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22804 00002CA9 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22805 00002CAB 89C8                    	mov	ax,cx			;AN000; clear ax
 22806 00002CAD 57                      	push	di			;AN000; save start of srcbuf
 22807 00002CAE AC                      	lodsb				;AN000; get a character from DS:SI
 22808                                  mts_get_chars:				;AN000;
 22809                                  	;cmp	al,0			;AN000; was it a null char?
 22810 00002CAF 20C0                    	and 	al,al ; al = 0 ?
 22811 00002CB1 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22812 00002CB3 AA                      	stosb				;AN000; no - store it in srcbuf
 22813 00002CB4 41                      	inc	cx			;AN000; increment length count
 22814 00002CB5 AC                      	lodsb				;AN000; get a character from DS:SI
 22815 00002CB6 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22816                                  mts_end_string: 			;AN000; we've reached the end of line
 22817                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22818 00002CB8 B00D                    	mov	al,0Dh
 22819 00002CBA AA                      	stosb				;AN000;
 22820 00002CBB 5F                      	pop	di			;AN000; restore start of srcbuf
 22821 00002CBC 0E                      	push	cs			;AN000; set DS to local segment
 22822 00002CBD 1F                      	pop	ds			;AN000;
 22823 00002CBE 890E[FE8B]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22824 00002CC2 893E[008C]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22825 00002CC6 59                      	pop	cx			;AN000; restore cx,di,si
 22826 00002CC7 5F                      	pop	di			;AN000;
 22827 00002CC8 5E                      	pop	si			;AN000;
 22828 00002CC9 C3                      	retn				;AN000; exit
 22829                                  
 22830                                  ;============================================================================
 22831                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22832                                  ;============================================================================
 22833                                  ; 03/10/2018 - Retro DOS v3.0
 22834                                  
 22835                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22836                                  
 22837                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22838                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22839                                  
 22840                                  ; =============== S U B	R O U T	I N E =======================================
 22841                                  
 22842                                  	; 26/02/2023
 22843                                  SINGLETEST:
 22844 00002CCA 1E                      	push	ds
 22845 00002CCB 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22846 00002CD0 833E[8E01]00            	cmp	word [SingleCom],0
 22847 00002CD5 7406                    	jz	short TESTDONE
 22848 00002CD7 813E[8E01]FFEF          	cmp	word [SingleCom],0EFFFh
 22849                                  TESTDONE:
 22850 00002CDD 1F                      	pop	ds
 22851 00002CDE C3                      	retn
 22852                                  
 22853                                  ; =============== S U B	R O U T	I N E =======================================
 22854                                  
 22855                                  	; 26/02/2023
 22856                                  SetRest1:
 22857 00002CDF B001                    	mov	al,1
 22858                                  
 22859                                  ; ---------------------------------------------------------------------------
 22860                                  
 22861                                  SETREST:
 22862 00002CE1 1E                      	push	ds
 22863 00002CE2 8E1E[A58A]              	mov	ds,[RESSEG]
 22864 00002CE6 A2[8C01]                	mov	[RestDir],al
 22865 00002CE9 1F                      	pop	ds
 22866 00002CEA C3                      	retn
 22867                                  
 22868                                  ; =============== S U B	R O U T	I N E =======================================
 22869                                  
 22870                                  ; Note that we need to handle the same thing that RestDir handles: the
 22871                                  ; requirement that we try only once to restore the user's environment after
 22872                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22873                                  ; disappear, we just give up.
 22874                                  
 22875                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22876                                  PIPEDEL:
 22877 00002CEB 1E                      	push	ds
 22878 00002CEC 52                      	push	dx
 22879 00002CED 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22880                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22881                                  			; Pipe1 = offset RESGROUP:EndInit
 22882 00002CF2 BA[0202]                	mov	dx,Pipe1	; Clean up in case ^C
 22883                                  	;mov	ah,Unlink ; 41h
 22884 00002CF5 B441                    	mov	ah,41h
 22885 00002CF7 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22886                                  			; DS:DX	-> ASCIZ pathname of file to delete
 22887                                  			;		(no wildcards allowed)
 22888                                  
 22889                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22890                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22891 00002CF9 BA[5102]                	mov	dx,Pipe2
 22892                                  	;mov	ah,Unlink ; 41h
 22893 00002CFC B441                    	mov	ah,41h
 22894 00002CFE CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22895                                  			; DS:DX	-> ASCIZ pathname of file to delete
 22896                                  			;		(no wildcards allowed)
 22897 00002D00 5A                      	pop	dx
 22898 00002D01 E86202                  	call	PipeOff
 22899 00002D04 C606[0102]00            	mov	byte [PipeFiles],0
 22900 00002D09 1F                      	pop	ds
 22901 00002D0A C3                      	retn
 22902                                  
 22903                                  ; ---------------------------------------------------------------------------
 22904                                  
 22905                                  	; 26/02/2023
 22906                                  PIPEERRSYN:
 22907 00002D0B BA[947F]                	mov	dx,SYNTMES_PTR
 22908 00002D0E E8DAFF                  	call	PIPEDEL
 22909 00002D11 0E                      	push	cs
 22910 00002D12 1F                      	pop	ds
 22911 00002D13 E93AFC                  	jmp	cerror
 22912                                  
 22913                                  ; ---------------------------------------------------------------------------
 22914                                  
 22915                                  	; 26/02/2023
 22916                                  PIPERR:
 22917 00002D16 9C                      	pushf
 22918 00002D17 E85EFF                  	call    TriageError
 22919                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22920 00002D1A 50                      	push	ax		; Save results from TriageError
 22921 00002D1B 52                      	push	dx
 22922 00002D1C BA[5D80]                	mov	dx,PIPEEMES_PTR
 22923 00002D1F E8C9FF                  	call	PIPEDEL
 22924 00002D22 0E                      	push	cs
 22925 00002D23 1F                      	pop	ds
 22926 00002D24 E8A220                  	call	std_eprintf
 22927 00002D27 5A                      	pop	dx		; Restore results from TriageError
 22928 00002D28 58                      	pop	ax
 22929 00002D29 9D                      	popf
 22930 00002D2A 83F841                  	cmp	ax,65
 22931 00002D2D 7503                    	jne	short TCOMMANDJ
 22932 00002D2F E91EFC                  	jmp	cerror
 22933                                  
 22934                                  TCOMMANDJ:
 22935 00002D32 E9CFD3                  	jmp	TCOMMAND
 22936                                  
 22937                                  ; ---------------------------------------------------------------------------
 22938                                  
 22939                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22940                                  PIPEPROCSTRT:
 22941 00002D35 8E1E[A58A]              	mov	ds,[RESSEG]
 22942 00002D39 FE06[0102]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22943                                  
 22944                                  	; MSDOS 6.0
 22945 00002D3D 06                      	push	es
 22946 00002D3E 57                      	push	di
 22947 00002D3F 1E                      	push	ds
 22948 00002D40 56                      	push	si
 22949                                  	
 22950 00002D41 1E                      	push	ds
 22951 00002D42 06                      	push	es
 22952 00002D43 1F                      	pop	ds			;ds = TRANGROUP
 22953 00002D44 BE[B985]                	mov	si,TempVarName		;ds:si = "TEMP="
 22954                                  
 22955                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22956                                  ;so the routine is not really general
 22957                                  
 22958 00002D47 E8C9F5                  	call	find_name_in_environment
 22959                                  					;es:di points at path
 22960 00002D4A 1F                      	pop	ds			;ds = DATARES again
 22961 00002D4B 721F                    	jc	short no_temp_path
 22962                                  	
 22963 00002D4D 1E                      	push	ds
 22964 00002D4E 06                      	push	es
 22965 00002D4F 1F                      	pop	ds
 22966 00002D50 07                      	pop	es			;swap ds and es
 22967 00002D51 89FE                    	mov	si,di			;ds:si points at path
 22968                                  	
 22969 00002D53 E8AA02                  	call	skip_white		;skip white space chars
 22970                                  
 22971                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22972                                  
 22973 00002D56 E8B302                  	call	copy_pipe_path		;copy the pipe path
 22974                                  	
 22975                                  ;Check if the TEMP path is valid
 22976                                  
 22977 00002D59 06                      	push	es
 22978 00002D5A 1F                      	pop	ds			;ds = DATARES
 22979                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 22980                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 22981 00002D5B BA[0202]                	mov	dx,Pipe1
 22982                                  	;mov	ax,(CHMOD shl 8) or 0
 22983 00002D5E B80043                  	mov	ax,4300h
 22984 00002D61 CD21                    	int	21h
 22985 00002D63 7207                    	jc	short no_temp_path
 22986                                  	
 22987 00002D65 F7C11000                	test	cx,10h			;is it a directory?
 22988 00002D69 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 22989                                  	
 22990 00002D6B F9                      	stc				;no, indicate fail
 22991                                  no_temp_path:
 22992 00002D6C 5E                      	pop	si
 22993 00002D6D 1F                      	pop	ds
 22994 00002D6E 5F                      	pop	di
 22995 00002D6F 07                      	pop	es
 22996 00002D70 730B                    	jnc	short crt_temp		;path found, create tempfiles
 22997                                  
 22998                                  	; 27/02/2023
 22999                                  	; MSDOS 3.3
 23000                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 23001                                  	;				; Get current drive
 23002                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 23003                                  	;add	al,[cs:CAPITAL_A]
 23004                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 23005                                  	;mov	bx,PIPE1
 23006                                  	;mov	[bx],al
 23007                                  	;xor	ah,ah			; nul terminate path names
 23008                                  	;mov	byte [PIPE1+3],ah
 23009                                  	;mov	byte [PIPE2+3],ah
 23010                                  
 23011                                  	; MSDOS 6.0
 23012                                  ;SR;
 23013                                  ; We want to create temp files in the current directory rather than in the 
 23014                                  ;root of the drive. This is because the number of files that can be present
 23015                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 23016                                  
 23017                                  	;mov	ah,'.'
 23018                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 23019                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 23020                                  	;xor	ah,ah
 23021                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 23022                                  	;mov	[Pipe2+1],ah		;create files in current dir
 23023                                  	; 27/02/2023
 23024 00002D72 B92E00                  	mov	cx,002Eh
 23025 00002D75 890E[0202]              	mov	[Pipe1],cx
 23026 00002D79 890E[5102]              	mov	[Pipe2],cx
 23027                                  crt_temp:
 23028                                  	; MSDOS 6.0
 23029                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 23030                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 23031 00002D7D BA[0202]                	mov	dx,Pipe1
 23032                                  	; MSDOS 3.3
 23033                                  	;mov	dx,bx
 23034                                  	
 23035                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23036 00002D80 31C9                    	xor	cx,cx
 23037                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23038 00002D82 B45A                    	mov	ah,5Ah
 23039 00002D84 CD21                    	int	21h
 23040                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23041                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23042                                  		; receive generated filename
 23043                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23044 00002D86 728E                    	jc	short PIPERR	; Couldn't create
 23045                                  
 23046 00002D88 89C3                    	mov	bx,ax
 23047                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23048 00002D8A B43E                    	mov	ah,3Eh
 23049 00002D8C CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23050                                  			; BX = file handle
 23051                                  	;;mov	dx,PIPE2
 23052                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 23053 00002D8E BA[5102]                	mov	dx,Pipe2
 23054                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23055 00002D91 B45A                    	mov	ah,5Ah
 23056 00002D93 CD21                    	int	21h
 23057                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23058                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23059                                  		; receive generated filename
 23060                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23061                                  	; 17/04/2023
 23062                                  	;jc	short PIPERR
 23063                                  	; 27/02/2023
 23064 00002D95 7303                    	jnc	short pps1
 23065 00002D97 E97CFF                  	jmp	PIPERR
 23066                                  pps1:
 23067 00002D9A 89C3                    	mov	bx,ax
 23068 00002D9C B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23069 00002D9E CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23070                                  				; BX = file handle
 23071                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 23072 00002DA0 E87FFE                  	call	TESTDOREIN
 23073 00002DA3 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23074 00002DA7 833E[8E01]FF            	cmp	word [SingleCom],-1
 23075 00002DAC 7506                    	jne	short NOSINGP
 23076 00002DAE C706[8E01]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 23077                                  NOSINGP:
 23078 00002DB4 EB29                    	jmp	short FIRSTPIPE
 23079                                  
 23080                                  ; ---------------------------------------------------------------------------
 23081                                  
 23082                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23083                                  PIPEPROC:
 23084 00002DB6 8026[8801]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 23085 00002DBB 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23086 00002DBF AC                      	lodsb
 23087                                  	; 27/02/2023
 23088 00002DC0 3C7C                    	cmp	al,'|'		
 23089                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 23090                                  	;je	short ISPIPE1	; Yes
 23091                                  	;cmp	al,'|'
 23092                                  	;;cmp	al,[cs:VBAR]
 23093 00002DC2 7403                    	je	short ISPIPE1
 23094 00002DC4 E98400                  	jmp	PIPEEND		; Pipe done
 23095                                  ISPIPE1:
 23096 00002DC7 8B16[2303]              	mov	dx,[InPipePtr]	; Get the input file name
 23097                                  	;mov	ax,OPEN*256 ; 3D00h
 23098 00002DCB B8003D                  	mov	ax,3D00h
 23099 00002DCE CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23100                                  			; DS:DX	-> ASCIZ filename
 23101                                  			; AL = access mode
 23102                                  			; 0 - read
 23103                                  PIPEERRJ:
 23104 00002DD0 7303                    	jnc	short NO_PIPEERR
 23105 00002DD2 E941FF                  	jmp	PIPERR		; Lost the pipe file
 23106                                  NO_PIPEERR:
 23107 00002DD5 89C3                    	mov	bx,ax
 23108 00002DD7 B0FF                    	mov	al,0FFh
 23109                                  	;xchg	al,[bx+18h]
 23110 00002DD9 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23111 00002DDC A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 23112                                  FIRSTPIPE:
 23113 00002DDF BF[0689]                	mov	di,COMBUF+2
 23114 00002DE2 31C9                    	xor	cx,cx
 23115 00002DE4 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 23116 00002DE7 7503                    	jne	short PIPEOK1
 23117                                  PIPEERRSYNJ:
 23118 00002DE9 E91FFF                  	jmp	PIPEERRSYN
 23119                                  PIPEOK1:
 23120                                  	;;;mov	al,[cs:VBAR]
 23121                                  	; 27/02/2023
 23122                                  	;;mov	al,vbar
 23123                                  	;mov	al,'|'
 23124                                  	;cmp	[si],al		; '||'
 23125                                  	;je	short PIPEERRSYNJ
 23126 00002DEC 803C7C                  	cmp	byte [si],'|'
 23127                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 23128 00002DEF 74F8                    	je	short PIPEERRSYNJ
 23129                                  PIPECOMLP:
 23130 00002DF1 AC                      	lodsb
 23131 00002DF2 AA                      	stosb
 23132                                  	; 27/02/2023
 23133 00002DF3 E8C7F5                  	call	testkanj
 23134 00002DF6 7405                    	jz	short NOTKANJ5
 23135 00002DF8 A4                      	movsb
 23136                                  ;  Added following 2 commands to the fix pipe bug.
 23137 00002DF9 41                      	inc	cx		;AN000;  3/3/KK
 23138 00002DFA 41                      	inc	cx		;AN000;  3/3/KK
 23139 00002DFB EBF4                    	jmp	short PIPECOMLP
 23140                                  NOTKANJ5:
 23141 00002DFD 3C0D                    	cmp	al,0Dh
 23142 00002DFF 7438                    	je	short LASTPIPE
 23143 00002E01 41                      	inc	cx
 23144                                  	; 27/02/2023
 23145 00002E02 3C7C                    	cmp	al,'|'
 23146                                  	;cmp	al,ALTPIPECHR
 23147                                  	;je	short ISPIPE2
 23148                                  	;;cmp	al,[cs:VBAR]
 23149                                  	;cmp	al,vbar
 23150 00002E04 75EB                    	jne	short PIPECOMLP
 23151                                  ISPIPE2:
 23152 00002E06 26C645FF0D              	mov	byte [es:di-1],0Dh
 23153 00002E0B 49                      	dec	cx
 23154                                  	;mov	[cs:COMBUF+1],cl
 23155                                  	; 27/02/2023
 23156 00002E0C 26880E[0589]            	mov	[es:COMBUF+1],cl
 23157 00002E11 4E                      	dec	si
 23158                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23159 00002E12 8936[A002]              	mov	[PipePtr],si		; On to next pipe element
 23160                                  			; mov [EndInit+158],si
 23161 00002E16 8B16[2503]              	mov	dx,[OutPipePtr]
 23162 00002E1A 51                      	push	cx
 23163 00002E1B 31C9                    	xor	cx,cx
 23164                                  	;mov	ax,CREAT*256 ; 3C00h
 23165 00002E1D B8003C                  	mov	ax,3C00h
 23166 00002E20 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23167                                  			; CX = attributes for file
 23168                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23169 00002E22 59                      	pop	cx
 23170 00002E23 72AB                    	jc	short PIPEERRJ		; Lost the file
 23171 00002E25 89C3                    	mov	bx,ax
 23172 00002E27 B0FF                    	mov	al,0FFh
 23173                                  	;xchg	al,[bx+18h]
 23174 00002E29 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23175 00002E2C A21900                  	mov	[PDB.JFN_TABLE+1],al
 23176 00002E2F 8716[2303]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 23177 00002E33 8916[2503]              	mov	[OutPipePtr],dx
 23178 00002E37 EB0D                    	jmp	short PIPECOM
 23179                                  LASTPIPE:
 23180                                  	;mov	[cs:COMBUF+1],cl 
 23181                                  	; 27/02/2023
 23182 00002E39 26880E[0589]            	mov	[es:COMBUF+1],cl
 23183 00002E3E 4E                      	dec	si
 23184                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23185 00002E3F 8936[A002]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 23186                                  		; mov [EndInit+158],si
 23187 00002E43 E859FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 23188                                  PIPECOM:
 23189 00002E46 0E                      	push	cs
 23190 00002E47 1F                      	pop	ds
 23191 00002E48 E997D4                  	jmp	NOPIPEPROC	; Process the pipe element
 23192                                  PIPEEND:
 23193 00002E4B E89DFE                  	call	PIPEDEL
 23194 00002E4E 813E[8E01]00F0          	cmp	word [SingleCom],0F000h
 23195 00002E54 7506                    	jnz	short NOSINGP2
 23196 00002E56 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 23197                                  NOSINGP2:
 23198 00002E5C E9A5D2                  	jmp	TCOMMAND
 23199                                  
 23200                                  ; =============== S U B	R O U T	I N E =======================================
 23201                                  
 23202                                  ; Date and time are set during initialization and use
 23203                                  ; this routines since they need to do a long return
 23204                                  
 23205                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23206                                  DATINIT:
 23207 00002E5F 2E8C1E[A58A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 23208 00002E64 06                      	push	es
 23209 00002E65 1E                      	push	ds		; Going to use the previous stack
 23210 00002E66 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 23211 00002E68 8EC0                    	mov	es,ax
 23212 00002E6A 8ED8                    	mov	ds,ax
 23213 00002E6C E83F20                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 23214 00002E6F BA[FE94]                	mov	dx,INTERNATVARS
 23215 00002E72 B80038                  	mov	ax,3800h
 23216                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 23217 00002E75 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23218                                  			; get current-country info
 23219                                  			; DS:DX	-> buffer for returned info
 23220                                  	; 20/10/2018
 23221 00002E77 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 23222 00002E7D C606[0489]80            	mov	byte [COMBUF],128 ; Init COMBUF
 23223 00002E82 C706[0589]010D          	mov	word [COMBUF+1],0D01h
 23224 00002E88 E80600                  	call	DATE
 23225 00002E8B E86200                  	call	CTIME
 23226 00002E8E 1F                      	pop	ds
 23227 00002E8F 07                      	pop	es
 23228 00002E90 CB                      	retf	; far return
 23229                                  
 23230                                  ; =============== S U B	R O U T	I N E =======================================
 23231                                  
 23232                                  ; MSDOS 6.0
 23233                                  
 23234                                  ; ****************************************************************
 23235                                  ; *
 23236                                  ; * ROUTINE:	 DATE - Set system date
 23237                                  ; *
 23238                                  ; * FUNCTION:	 If a date is specified, set the system date,
 23239                                  ; *		 otherwise display the current system date and
 23240                                  ; *		 prompt the user for a new date.  If an invalid
 23241                                  ; *		 date is specified, issue an error message and
 23242                                  ; *		 prompt for a new date.  If the user enters
 23243                                  ; *		 nothing when prompted for a date, terminate.
 23244                                  ; *
 23245                                  ; * INPUT:	 command line at offset 81H
 23246                                  ; *
 23247                                  ; * OUTPUT:	 none
 23248                                  ; *
 23249                                  ; ****************************************************************
 23250                                  
 23251                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23252                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 23253                                  	; 11/06/2023
 23254                                  DATE:
 23255 00002E91 BE8100                  	mov	si,81h			; Accepting argument for date inline
 23256 00002E94 BF[B184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23257 00002E97 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23258 00002E99 31D2                    	xor	dx,dx			;AN000;
 23259 00002E9B E87D14                  	call	cmd_parse		;AC000; call parser
 23260                                  	
 23261                                  	; 27/02/2023
 23262                                  	;cmp	ax,-1
 23263                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23264                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 23265                                  	;;cmp	ax,0
 23266                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23267                                  	;;jne	short DATERR		;AN000; yes - go issue message
 23268                                  	; 26/04/2023
 23269                                  	;or	ax,ax ; ax = 0 ?
 23270                                  	;jnz	short DATERR
 23271                                  	;;jmp	short COMDAT		;AC000; we have a date
 23272                                  	; 11/06/2023
 23273 00002E9E 40                      	inc	ax  ; cmp ax,-1
 23274 00002E9F 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 23275 00002EA1 48                      	dec	ax  ; cmp ax,0
 23276 00002EA2 7541                    	jnz	short DATERR ; 1 -> 0
 23277                                  	; ax = 0
 23278                                  	
 23279                                  	; 27/02/2023
 23280                                  COMDAT:
 23281 00002EA4 8B0E[5B95]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 23282 00002EA8 8A36[5D95]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 23283 00002EAC 8A16[5E95]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 23284 00002EB0 51                      	push	cx			;AC000; save date
 23285 00002EB1 52                      	push	dx			;AC000;
 23286 00002EB2 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 23287 00002EB5 31D2                    	xor	dx,dx			;AN029;
 23288 00002EB7 E86114                  	call	cmd_parse		;AN029; call parser
 23289 00002EBA 3CFF                    	cmp	al,0FFh ; -1
 23290                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23291 00002EBC 5A                      	pop	dx			;AC000; retrieve date
 23292 00002EBD 59                      	pop	cx			;AC000;
 23293 00002EBE 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 23294                                  	; 26/04/2023
 23295                                  	;mov	ah,SET_DATE		;yes - set date
 23296 00002EC0 B42B                    	mov	ah,2Bh
 23297 00002EC2 CD21                    	int	21h
 23298                                  			; DOS - SET CURRENT DATE
 23299                                  			; DL = day, DH = month, CX = year
 23300                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 23301 00002EC4 08C0                    	or	al,al
 23302 00002EC6 751D                    	jnz	short DATERR
 23303                                  date_end:
 23304 00002EC8 C3                      	retn
 23305                                  
 23306                                  PRMTDAT:
 23307                                  	; Print "Current date is
 23308                                  
 23309 00002EC9 E81708                  	call	GetDate 		;AN000; get date for output
 23310 00002ECC 86F2                    	xchg	dh,dl			;AN000; switch month & day
 23311 00002ECE 890E[AA7F]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 23312 00002ED2 8916[AC7F]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 23313 00002ED6 BA[9A7F]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 23314 00002ED9 E8F51E                  	call	std_printf
 23315                                  
 23316                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 23317                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 23318                                  
 23319                                  GET_NEW_DATE:				;AN000;
 23320 00002EDC E8BC00                  	call	GETDAT			;AC000; prompt user for date
 23321                                  	
 23322                                  	; 11/06/2023
 23323                                  	;cmp	ax,0FFFFh ; -1
 23324                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23325                                  	;je	short date_end		;AC000; yes - exit
 23326                                  	; 26/04/2023
 23327                                  	;;cmp	ax,0
 23328                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23329                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 23330                                  	;; 27/02/2023
 23331                                  	;;jz	short COMDAT
 23332                                  	; 26/04/2023
 23333                                  	;and	ax,ax ; 0 ?
 23334                                  	;jz	short COMDAT
 23335                                  
 23336                                  	; 11/06/2023
 23337 00002EDF 40                      	inc	ax  ; cmp ax,-1
 23338 00002EE0 74E6                    	jz	short date_end ; 0FFFFh -> 0
 23339 00002EE2 48                      	dec	ax  ; cmp ax,0
 23340 00002EE3 74BF                    	jz	short COMDAT ; 1 -> 0
 23341                                  	; ax > 0
 23342                                  
 23343                                  ;COMDAT:
 23344                                  ;	....
 23345                                  DATERR:
 23346 00002EE5 E8E7F6                  	call	CRLF2			;AN028; print out a blank line
 23347 00002EE8 BA[977F]                	mov	dx,BADDAT_PTR
 23348 00002EEB E8E31E                  	call	std_printf
 23349 00002EEE EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 23350                                  
 23351                                  ; =============== S U B	R O U T	I N E =======================================
 23352                                  
 23353                                  ; MSDOS 6.0
 23354                                  
 23355                                  ; TIME gets and sets the time
 23356                                  
 23357                                  ; ****************************************************************
 23358                                  ; *
 23359                                  ; * ROUTINE:	 TIME - Set system time
 23360                                  ; *
 23361                                  ; * FUNCTION:	 If a time is specified, set the system time,
 23362                                  ; *		 otherwise display the current system time and
 23363                                  ; *		 prompt the user for a new time.  If an invalid
 23364                                  ; *		 time is specified, issue an error message and
 23365                                  ; *		 prompt for a new time.  If the user enters
 23366                                  ; *		 nothing when prompted for a time, terminate.
 23367                                  ; *
 23368                                  ; * INPUT:	 command line at offset 81H
 23369                                  ; *
 23370                                  ; * OUTPUT:	 none
 23371                                  ; *
 23372                                  ; ****************************************************************
 23373                                  
 23374                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23375                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23376                                  	; 11/06/2023
 23377                                  CTIME:
 23378 00002EF0 BE8100                  	mov	si,81h			; Accepting argument for time inline
 23379 00002EF3 BF[C384]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23380 00002EF6 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23381 00002EF8 31D2                    	xor	dx,dx			;AN000;
 23382 00002EFA E81E14                  	call	cmd_parse		;AC000; call parser
 23383                                  	
 23384                                  	; 27/02/2023
 23385                                  	;cmp	ax,-1
 23386                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23387                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 23388                                  	;;cmp	ax,0
 23389                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23390                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23391                                  	;and	ax,ax ; ax = 0 ?
 23392                                  	;jnz	short TIMERR
 23393                                  	;;jmp	short COMTIM		;AC000; we have a time
 23394                                  	; 11/06/2023
 23395 00002EFD 40                      	inc	ax  ; cmp ax,-1
 23396 00002EFE 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 23397 00002F00 48                      	dec	ax  ; cmp ax,0
 23398 00002F01 7548                    	jnz	short TIMERR ; 1 -> 0
 23399                                  	; ax = 0
 23400                                  	
 23401                                  	; 27/02/2023
 23402                                  COMTIM:
 23403 00002F03 8A2E[6395]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23404 00002F07 8A0E[6495]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23405 00002F0B 8A36[6595]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23406 00002F0F 8A16[6695]              	mov	dl,[TIME_FRACTION]	;AC000;
 23407 00002F13 51                      	push	cx			;AC000; save time
 23408 00002F14 52                      	push	dx			;AC000;
 23409 00002F15 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23410 00002F18 31D2                    	xor	dx,dx			;AN029;
 23411 00002F1A E8FE13                  	call	cmd_parse		;AN029; call parser
 23412 00002F1D 3CFF                    	cmp	al, -1
 23413                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23414 00002F1F 5A                      	pop	dx			;AC000; retieve time
 23415 00002F20 59                      	pop	cx			;AC000;
 23416 00002F21 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23417                                  SAVTIM:
 23418                                  	;mov	ah,SET_TIME
 23419 00002F23 B42D                    	mov	ah,2Dh
 23420 00002F25 CD21                    	int	21h
 23421 00002F27 08C0                    	or	al,al
 23422 00002F29 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23423                                  time_end:
 23424 00002F2B C3                      	retn
 23425                                  
 23426                                  PRMTTIM:
 23427                                  	;Printf "Current time is ... "
 23428                                  
 23429                                  	;mov	ah,Get_Time		;AC000; get the current time
 23430 00002F2C B42C                    	mov	ah,2Ch
 23431 00002F2E CD21                    	int	21h			;AC000;   Get time in CX:DX
 23432 00002F30 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23433 00002F32 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23434 00002F34 890E[CC7F]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23435 00002F38 8916[CE7F]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23436 00002F3C BA[C77F]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23437 00002F3F E88F1E                  	call	std_printf
 23438                                  
 23439                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23440                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23441                                  
 23442                                  GET_NEW_TIME:
 23443 00002F42 E8AE00                  	call	GETTIM			;AC000;
 23444                                  	
 23445                                  	; 11/06/2023
 23446                                  	;cmp	ax,-1
 23447                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23448                                  	;je	short time_end		;AC000;
 23449                                  	;;cmp	ax,0
 23450                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23451                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23452                                  	;or	ax,ax  ; ax = 0 ?
 23453                                  	;;jnz	short TIMERR
 23454                                  	; 27/02/2023
 23455                                  	;jz	short COMTIM
 23456                                  
 23457                                  	; 11/06/2023
 23458 00002F45 40                      	inc	ax  ; cmp ax,-1
 23459 00002F46 74E3                    	jz	short time_end ; 0FFFFh -> 0
 23460 00002F48 48                      	dec	ax  ; cmp ax,0
 23461 00002F49 74B8                    	jz	short COMTIM ; 1 -> 0
 23462                                  	; ax > 0
 23463                                  
 23464                                  ;COMTIM:
 23465                                  ;	....
 23466                                  TIMERR:
 23467 00002F4B E881F6                  	call	CRLF2			;AN028; print out a blank line
 23468 00002F4E BA[C47F]                	mov	dx,BadTim_Ptr
 23469 00002F51 E87D1E                  	call	std_printf		; Print error message
 23470 00002F54 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23471                                  
 23472                                  ; =============== S U B	R O U T	I N E =======================================
 23473                                  
 23474                                  ; MSDOS 6.0
 23475                                  
 23476                                  ; Set the special flag in the INIT flag to the value in CX.
 23477                                  
 23478                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23479                                  SetInitFlag:
 23480 00002F56 8E1E[A58A]              	mov	ds,[RESSEG]
 23481                                  
 23482 00002F5A 8026[FF01]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23483                                  	;and	byte [InitFlag],0FDh
 23484 00002F5F 080E[FF01]              	or	byte [InitFlag],cl
 23485 00002F63 0E                      	push	cs
 23486 00002F64 1F                      	pop	ds
 23487 00002F65 C3                      	retn
 23488                                  
 23489                                  ; =============== S U B	R O U T	I N E =======================================
 23490                                  
 23491                                  ; MSDOS 6.0
 23492                                  
 23493                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23494                                  PipeOff:
 23495 00002F66 1E                      	push	ds
 23496 00002F67 50                      	push	ax
 23497 00002F68 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 23498 00002F6D 30C0                    	xor	al,al
 23499 00002F6F 8606[0002]              	xchg	[PipeFlag],al
 23500 00002F73 08C0                    	or	al,al
 23501 00002F75 7404                    	jz	short PipeOffDone
 23502 00002F77 D02E[8801]              	shr	byte [EchoFlag],1
 23503                                  PipeOffDone:
 23504 00002F7B 58                      	pop	ax
 23505 00002F7C 1F                      	pop	ds
 23506 00002F7D C3                      	retn
 23507                                  
 23508                                  ; =============== S U B	R O U T	I N E =======================================
 23509                                  
 23510                                  ; MSDOS 6.0
 23511                                  
 23512                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23513                                  PRINT_TIME:
 23514                                  	;mov	ah,Get_Time
 23515 00002F7E B42C                    	mov	ah,2Ch
 23516 00002F80 CD21                    	int	21h			; Get time in CX:DX
 23517                                  
 23518 00002F82 06                      	push	es
 23519 00002F83 0E                      	push	cs
 23520 00002F84 07                      	pop	es
 23521 00002F85 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23522 00002F87 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23523 00002F89 2E890E[0581]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23524 00002F8E 2E8916[0781]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23525 00002F93 BA[0081]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23526 00002F96 E8381E                  	call	std_printf
 23527                                  
 23528                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23529                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23530                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23531                                  					;AC000;  pointers in control block
 23532 00002F99 07                      	pop	es
 23533 00002F9A C3                      	retn
 23534                                  
 23535                                  ; =============== S U B	R O U T	I N E =======================================
 23536                                  
 23537                                  ; MSDOS 6.0
 23538                                  
 23539                                  ; ****************************************************************
 23540                                  ; *
 23541                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23542                                  ; *
 23543                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23544                                  ; *		 INFORMATION and issues the "Enter new date"
 23545                                  ; *		 message with the proper date format. COMBUF
 23546                                  ; *		 is reset to get a date from the command line.
 23547                                  ; *		 The PARSE_DATE blocks are then reset and the
 23548                                  ; *		 PARSE function call is issued.
 23549                                  ; *
 23550                                  ; * INPUT:	 NONE
 23551                                  ; *
 23552                                  ; * OUTPUT:	 COMBUF
 23553                                  ; *		 PARSER RETURN CODES
 23554                                  ; *
 23555                                  ; ****************************************************************
 23556                                  
 23557                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23558                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23559                                  GETDAT:
 23560                                  	;mov	ax,(International SHL 8)
 23561 00002F9B B80038                  	mov	ax,3800h
 23562                                  					; Determine what format the date
 23563 00002F9E BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23564 00002FA1 CD21                    	int	21h			;  print a message describing it
 23565                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23566                                  			; get current-country info
 23567                                  			; DS:DX -> buffer for returned info
 23568 00002FA3 89D6                    	mov	si,dx
 23569 00002FA5 AD                      	lodsw
 23570 00002FA6 2E8B16[DE80]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23571 00002FAB 48                      	dec	ax
 23572 00002FAC 780C                    	js	short printformat
 23573 00002FAE 2E8B16[E180]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23574 00002FB3 7405                    	jz	short printformat
 23575 00002FB5 2E8B16[E480]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23576                                  printformat:
 23577 00002FBA 89D0                    	mov	ax,dx			;AN000; get message number of format
 23578                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23579 00002FBC B6FF                    	mov	dh,-1 ; 0FFh
 23580 00002FBE E8F31E                  	call	TSYSGETMSG		;AN000; get the address of the message
 23581 00002FC1 2E8936[BB7F]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23582 00002FC6 BA[B67F]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23583 00002FC9 E8051E                  	call	std_printf
 23584                                  	;mov	word [cs:NewDat_Format],no_subst
 23585                                  					;AN000; reset subst block
 23586 00002FCC 2EC706[BB7F]0000        	mov	word [cs:NewDat_Format],0
 23587                                  
 23588                                  	; 28/02/2023
 23589 00002FD3 BF[B184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23590                                  ; 28/02/2023
 23591                                  gettim_p:	
 23592                                  	;mov	ah,Std_Con_String_Input
 23593 00002FD6 B40A                    	mov	ah,0Ah
 23594 00002FD8 BA[0489]                	mov	dx,COMBUF
 23595 00002FDB B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23596 00002FDE E875FF                  	call	SetInitFlag		;  prompting for date.
 23597 00002FE1 CD21                    	int	21h			; Get input line
 23598 00002FE3 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23599 00002FE5 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23600 00002FE8 E8E4F5                  	call	CRLF2
 23601                                  	; 28/02/2023
 23602                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23603                                  ;gettim_p: ; 28/02/2023
 23604 00002FEB BE[0689]                	mov	si,COMBUF+2
 23605                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23606 00002FEE 31D2                    	xor	dx,dx			;AN000;
 23607                                  	;call	cmd_parse		;AC000; call parser
 23608                                  	;retn
 23609                                  	; 28/02/2023
 23610 00002FF0 E92813                  	jmp	cmd_parse
 23611                                  
 23612                                  ; =============== S U B	R O U T	I N E =======================================
 23613                                  
 23614                                  ; MSDOS 6.0
 23615                                  
 23616                                  ; ****************************************************************
 23617                                  ; *
 23618                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23619                                  ; *
 23620                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23621                                  ; *		 INFORMATION and issues the "Enter new time"
 23622                                  ; *		 message. COMBUF is reset to get a time from the
 23623                                  ; *		 command line. The PARSE_TIME blocks are then
 23624                                  ; *		 reset and the PARSE function call is issued.
 23625                                  ; *
 23626                                  ; * INPUT:	 NONE
 23627                                  ; *
 23628                                  ; * OUTPUT:	 COMBUF
 23629                                  ; *		 PARSER RETURN CODES
 23630                                  ; *
 23631                                  ; ****************************************************************
 23632                                  
 23633                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23634                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23635                                  GETTIM:
 23636 00002FF3 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23637 00002FF5 BA[D57F]                	mov	dx,NewTim_Ptr
 23638 00002FF8 E8D61D                  	call	std_printf
 23639                                  
 23640                                  	; 28/02/2023
 23641 00002FFB BF[C384]                	mov	di,PARSE_TIME
 23642 00002FFE EBD6                    	jmp	short gettim_p
 23643                                  
 23644                                  ; 28/02/2023
 23645                                  ;	;mov	ah,Std_Con_String_Input
 23646                                  ;	mov	ah,0Ah
 23647                                  ;	mov	dx,COMBUF
 23648                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23649                                  ;	call	SetInitFlag		;  prompting for time.
 23650                                  ;	int	21h			; Get input line
 23651                                  ;	; 28/02/2023
 23652                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23653                                  ;	call	SetInitFlag		;  prompting for time.
 23654                                  ;	call	CRLF2
 23655                                  ;	; 28/02/2023
 23656                                  ;	;mov	si,COMBUF+2
 23657                                  ;	; 28/02/2023
 23658                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23659                                  ;	; 28/02/2023
 23660                                  ;	jmp	short gettim_p	
 23661                                  ;	; 28/02/2023
 23662                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23663                                  ;	;xor	dx,dx			;AN000;
 23664                                  ;	;call	cmd_parse		;AC000; call parser
 23665                                  ;	;retn
 23666                                  
 23667                                  
 23668                                  ; =============== S U B	R O U T	I N E =======================================
 23669                                  
 23670                                  ; MSDOS 6.0
 23671                                  
 23672                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23673                                  ;the '=' sign in the environment variable before the actual path.
 23674                                  ;
 23675                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23676                                  ;
 23677                                  ;	EXIT:	ds:si = start of the path
 23678                                  ;
 23679                                  ;	REGISTERS AFFECTED: ax
 23680                                  
 23681                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23682                                  skip_white:
 23683 00003000 FC                      	cld
 23684                                  skw_lp:
 23685 00003001 AC                      	lodsb
 23686 00003002 3C20                    	cmp	al,' '			;blank char?
 23687 00003004 74FB                    	jz	short skw_lp		;yes, skip it
 23688 00003006 3C09                    	cmp	al,9			;tab char?
 23689 00003008 74F7                    	jz	short skw_lp		;yes, skip it
 23690 0000300A 4E                      	dec	si			;point at first non-white
 23691 0000300B C3                      	retn
 23692                                  
 23693                                  ; =============== S U B	R O U T	I N E =======================================
 23694                                  
 23695                                  ; MSDOS 6.0
 23696                                  
 23697                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23698                                  ;variable into the path buffers Pipe1 & Pipe2.
 23699                                  ;
 23700                                  ;	ENTRY:	ds:si = path to be copied
 23701                                  ;		es = RESGROUP
 23702                                  ;
 23703                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23704                                  ;
 23705                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23706                                  
 23707                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23708                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23709                                  
 23710                                  copy_pipe_path:
 23711 0000300C B9FFFF                  	mov	cx,0FFFFh ; 65535
 23712 0000300F 30C0                    	xor	al,al
 23713                                  
 23714 00003011 89F7                    	mov	di,si
 23715 00003013 06                      	push	es			;save es
 23716 00003014 1E                      	push	ds
 23717 00003015 07                      	pop	es			;es:di = path to be copied
 23718                                  	
 23719 00003016 FC                      	cld
 23720 00003017 57                      	push	di
 23721 00003018 F2AE                    	repnz	scasb			;look for the null char
 23722 0000301A 5F                      	pop	di
 23723                                  
 23724 0000301B 07                      	pop	es			;es = RESGROUP again
 23725                                  
 23726 0000301C F7D1                    	not	cx			;length including the null
 23727                                  
 23728                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23729                                  	;mov	di,offset DATARES:Pipe1
 23730 0000301E BF[0202]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23731 00003021 57                      	push	di
 23732 00003022 51                      	push	cx			
 23733 00003023 F3A4                    	rep	movsb			;copy path into Pipe1
 23734 00003025 59                      	pop	cx
 23735 00003026 5F                      	pop	di
 23736                                  
 23737 00003027 1E                      	push	ds
 23738 00003028 06                      	push	es
 23739 00003029 1F                      	pop	ds			;ds:si = Pipe1
 23740 0000302A 89FE                    	mov	si,di
 23741                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23742                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23743 0000302C BF[5102]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23744 0000302F F3A4                    	rep	movsb			;copy path into Pipe2
 23745 00003031 1F                      	pop	ds
 23746 00003032 C3                      	retn
 23747                                  
 23748                                  ; 28/02/2023
 23749                                  %if 0
 23750                                  
 23751                                  ;============================================================================
 23752                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23753                                  ;============================================================================
 23754                                  ; 05/10/2018 - Retro DOS v3.0
 23755                                  
 23756                                  ; DATE - Gets and sets the time
 23757                                  
 23758                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23759                                  
 23760                                  ; =============== S U B	R O U T	I N E =======================================
 23761                                  
 23762                                  DATE_CXDX:
 23763                                  	mov	bx,cx
 23764                                  
 23765                                  ; =============== S U B	R O U T	I N E =======================================
 23766                                  
 23767                                  P_DATE:
 23768                                  	mov	ax,bx
 23769                                  	mov	cx,dx
 23770                                  	mov	dl,100
 23771                                  	div	dl
 23772                                  	xchg	al,ah
 23773                                  	xchg	ax,dx
 23774                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23775                                  	;mov	ax,[INTERNATVARS]
 23776                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23777                                  	or	ax,ax
 23778                                  	jz	short USPDAT
 23779                                  	dec	ax
 23780                                  	jz	short EUPDAT
 23781                                  	mov	bh,0	 ; Disable leading zero suppression	
 23782                                  	call	P_YR
 23783                                  	call	P_DSEP
 23784                                  	call	P_MON
 23785                                  	call	P_DSEP
 23786                                  	call	P_DAY
 23787                                  	retn
 23788                                  
 23789                                  USPDAT:
 23790                                  	call	P_MON
 23791                                  	call	P_DSEP
 23792                                  	call	P_DAY
 23793                                  PLST:
 23794                                  	call	P_DSEP
 23795                                  	call	P_YR
 23796                                  	retn
 23797                                  
 23798                                  EUPDAT:
 23799                                  	call	P_DAY
 23800                                  	call	P_DSEP
 23801                                  	call	P_MON
 23802                                  	jmp	short PLST
 23803                                  
 23804                                  ; ---------------------------------------------------------------------------
 23805                                  
 23806                                  P_MON:
 23807                                  	mov	al,ch
 23808                                  	call	OUT2
 23809                                  	retn
 23810                                  
 23811                                  ; ---------------------------------------------------------------------------
 23812                                  
 23813                                  P_DSEP:
 23814                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23815                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23816                                  	stosb
 23817                                  	retn
 23818                                  
 23819                                  ; ---------------------------------------------------------------------------
 23820                                  
 23821                                  P_DAY:
 23822                                  	mov	al,cl
 23823                                  	call	OUT2
 23824                                  	retn
 23825                                  
 23826                                  ; ---------------------------------------------------------------------------
 23827                                  
 23828                                  P_YR:
 23829                                  	mov	al,dh
 23830                                  	or	al,al
 23831                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23832                                  	call	OUT2
 23833                                  TWODIGYR:
 23834                                  	mov	al,dl
 23835                                  	call	OUT2
 23836                                  DATE_RETN:
 23837                                  	retn
 23838                                  
 23839                                  ; =============== S U B	R O U T	I N E =======================================
 23840                                  
 23841                                  DATE:				 ; Accepting argument for date inline
 23842                                  	mov	si,81h
 23843                                  	call	SCANOFF
 23844                                  	cmp	al,0Dh
 23845                                  	jz	short PRMTDAT
 23846                                  	jmp	short COMDAT
 23847                                  
 23848                                  	;nop
 23849                                  PRMTDAT:
 23850                                  	; MSDOS 3.3
 23851                                  	mov	dx,CURDATPTR
 23852                                  	call	STD_PRINTF	; Print "Current date is "	
 23853                                  	call	PRINT_DATE
 23854                                  GETDAT:	
 23855                                  	mov	dx,NEWDATPTR
 23856                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23857                                  
 23858                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23859                                  				; Determine what format the date
 23860                                  	mov	dx,5Ch		;  should be entered in and
 23861                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23862                                  			; get current-country info
 23863                                  			; DS:DX	-> buffer for returned info
 23864                                  	mov	si,dx		;  print a message describing it
 23865                                  	lodsw
 23866                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23867                                  	dec	ax
 23868                                  	js	short PRINTFORMAT
 23869                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23870                                  	jz	short PRINTFORMAT
 23871                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23872                                  PRINTFORMAT:
 23873                                  	call	STD_PRINTF
 23874                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23875                                  	mov	dx,COMBUF
 23876                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23877                                  	call	SETINITFLAG	;  prompting for date.
 23878                                  	int	21h		; Get input line
 23879                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23880                                  	call	SETINITFLAG	;  prompting for date.
 23881                                  	call	CRLF2
 23882                                  	mov	si,COMBUF+2
 23883                                  	cmp	byte [si],0Dh
 23884                                  	jz	short DATE_RETN
 23885                                  COMDAT:
 23886                                  	;mov	ax,[INTERNATVARS]
 23887                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23888                                  	or	ax,ax
 23889                                  	jz	short USSDAT
 23890                                  	dec	ax
 23891                                  	jz	short EUSDAT
 23892                                  	call	GET_YR
 23893                                  	jc	short DATERRJ
 23894                                  	call	GET_DSEP
 23895                                  	jc	short DATERRJ
 23896                                  	call	GET_MON
 23897                                  	jc	short DATERRJ
 23898                                  	call	GET_DSEP
 23899                                  	jc	short DATERRJ
 23900                                  	call	GET_DAY
 23901                                  DAT_SET:
 23902                                  	jnc	short DATSET
 23903                                  	jmp	DATERR
 23904                                  
 23905                                  ; ---------------------------------------------------------------------------
 23906                                  
 23907                                  DATSET:
 23908                                  	lodsb
 23909                                  	cmp	al,' '
 23910                                  	jz	short DATSET
 23911                                  	cmp	al,9
 23912                                  	jz	short DATSET
 23913                                  	cmp	al,0Dh
 23914                                  	jnz	short DATERR
 23915                                  	mov	ah,SET_DATE ; 2Bh
 23916                                  	int	21h	; DOS -	SET CURRENT DATE
 23917                                  			; DL = day,DH = month,	CX = year
 23918                                  			; Return: AL = 00h if no error 
 23919                                  			; 	     = FFh if bad value sent to routine
 23920                                  	or	al,al
 23921                                  	jnz	short DATERR
 23922                                  DAT_SET_RETN:
 23923                                  	retn
 23924                                  
 23925                                  ; ---------------------------------------------------------------------------
 23926                                  
 23927                                  USSDAT:
 23928                                  	call	GET_MON
 23929                                  	jb	short DATERR
 23930                                  	call	GET_DSEP
 23931                                  DATERRJ:
 23932                                  	jc	short DATERR
 23933                                  	call	GET_DAY
 23934                                  TGET:
 23935                                  	jc	short DATERR
 23936                                  	call	GET_DSEP
 23937                                  	jc	short DATERR
 23938                                  	call	GET_YR
 23939                                  	jmp	short DAT_SET
 23940                                  
 23941                                  ; ---------------------------------------------------------------------------
 23942                                  
 23943                                  EUSDAT:
 23944                                  	call	GET_DAY
 23945                                  	jc	short DATERR
 23946                                  	call	GET_DSEP
 23947                                  	jc	short DATERR
 23948                                  	call	GET_MON
 23949                                  	jmp	short TGET
 23950                                  
 23951                                  ; =============== S U B	R O U T	I N E =======================================
 23952                                  
 23953                                  GET_MON:
 23954                                  	call	GETNUM		; Get one or two digit number
 23955                                  	jc	short DAT_SET_RETN
 23956                                  	mov	dh,ah		; Put in position
 23957                                  	retn
 23958                                  
 23959                                  
 23960                                  ; =============== S U B	R O U T	I N E =======================================
 23961                                  
 23962                                  GET_DAY:
 23963                                  		call	GETNUM
 23964                                  		mov	dl,ah		; Put in position
 23965                                  GET_DAY_RETN:
 23966                                  		retn
 23967                                  
 23968                                  ; =============== S U B	R O U T	I N E =======================================
 23969                                  
 23970                                  GET_YR:
 23971                                  	call	GETNUM
 23972                                  	jc	short GET_DAY_RETN
 23973                                  	mov	cx,1900
 23974                                  	call	GET_DSEP
 23975                                  	pushf
 23976                                  	dec	si
 23977                                  	popf
 23978                                  	jz	short BIAS
 23979                                  	cmp	byte [si],0Dh
 23980                                  	je	short BIAS
 23981                                  	cmp	byte [si],' '
 23982                                  	je	short BIAS
 23983                                  	cmp	byte [si],9
 23984                                  	je	short BIAS
 23985                                  	push	bx
 23986                                  	mov	bl,100
 23987                                  	mov	al,ah
 23988                                  	mul	bl
 23989                                  	pop	bx
 23990                                  	mov	cx,ax
 23991                                  	call	GETNUM
 23992                                  	jc	short GET_DAY_RETN
 23993                                  BIAS:
 23994                                  	mov	al,ah
 23995                                  	mov	ah,0
 23996                                  	add	cx,ax
 23997                                  BIAS_RETN:
 23998                                  	retn
 23999                                  
 24000                                  ; ---------------------------------------------------------------------------
 24001                                  
 24002                                  DATERR:
 24003                                  	mov	dx,BADDATPTR
 24004                                  	call	STD_PRINTF
 24005                                  	jmp	GETDAT
 24006                                  
 24007                                  ; =============== S U B	R O U T	I N E =======================================
 24008                                  
 24009                                  GET_DSEP:
 24010                                  	lodsb
 24011                                  	cmp	al,'/'
 24012                                  	je	short BIAS_RETN
 24013                                  	;cmp	al,'.'
 24014                                  	cmp	al,[DOT_CHR]
 24015                                  	je	short BIAS_RETN
 24016                                  	;cmp	al,'-'
 24017                                  	cmp	al,[CHAR_SUB]
 24018                                  	je	short BIAS_RETN
 24019                                  	stc
 24020                                  	retn
 24021                                  
 24022                                  ; =============== S U B	R O U T	I N E =======================================
 24023                                  
 24024                                  ; TIME gets and sets the time
 24025                                  
 24026                                  CTIME:
 24027                                  	mov	si,81h		; Accepting argument for time inline
 24028                                  	call	SCANOFF
 24029                                  	cmp	al,0Dh
 24030                                  	je	short PRMTTIM
 24031                                  	mov	bx,2E3Ah ; ":."
 24032                                  	call	INLINE
 24033                                  	jmp	COMTIM
 24034                                  
 24035                                  ; =============== S U B	R O U T	I N E =======================================
 24036                                  
 24037                                  PRINT_TIME:
 24038                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 24039                                  	int	21h	; DOS -	GET CURRENT TIME
 24040                                  			; Return: CH = hours,CL = minutes,DH = seconds
 24041                                  			; DL = hundredths of seconds
 24042                                  	push	di
 24043                                  	push	es
 24044                                  	push	cs
 24045                                  	pop	es
 24046                                  	mov	di,CHARBUF
 24047                                  	mov	bl,1	; Always 24 hour time
 24048                                  	call	P_TIME
 24049                                  	xor	ax,ax
 24050                                  	stosb
 24051                                  	mov	dx,CHARBUF
 24052                                  	mov	[STRING_PTR_2],dx
 24053                                  	mov	dx,STRINGBUF2PTR
 24054                                  	call	STD_PRINTF
 24055                                  	pop	es
 24056                                  	pop	di
 24057                                  P_TIME_RETN:
 24058                                  	retn
 24059                                  
 24060                                  ; =============== S U B	R O U T	I N E =======================================
 24061                                  
 24062                                  P_TIME:
 24063                                  	mov	al,ch	
 24064                                  	test	bl,7Fh		; Ignore high bit
 24065                                  	jnz	short T24	; 24 hr time?
 24066                                  	mov	bh,'a'		; Assume A.M.
 24067                                  	cmp	al,12		; In the afternoon?
 24068                                  	jb	short MORN
 24069                                  	mov	bh,'p'
 24070                                  	jz	short MORN
 24071                                  	sub	al,12		; Keep it to 12 hours or less
 24072                                  MORN:
 24073                                  	or	al,al		; Before 1 am?
 24074                                  	jnz	short T24
 24075                                  	mov	al,12
 24076                                  T24:
 24077                                  	push	bx
 24078                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 24079                                  	call	OUT2
 24080                                  	call	P_TSEP
 24081                                  	mov	al,cl
 24082                                  	call	OUT2
 24083                                  	pop	bx
 24084                                  	push	bx
 24085                                  	test	bl,80h
 24086                                  	jnz	short PAP	; If from DIR, go directly to am pm
 24087                                  	mov	bh,0		; Disable leading zero suppression
 24088                                  	call	P_TSEP
 24089                                  	mov	al,dh
 24090                                  	call	OUT2
 24091                                  	;mov	al,'.'
 24092                                  	mov	al,[DECIMAL_SEP]
 24093                                  	stosb
 24094                                  	mov	al,dl
 24095                                  	call	OUT2
 24096                                  PAP:
 24097                                  	pop	bx
 24098                                  	test	bl,7Fh		; Ignore high bit
 24099                                  	jnz	short P_TIME_RETN
 24100                                  	mov	al,bh
 24101                                  	stosb
 24102                                  	retn
 24103                                  
 24104                                  ; =============== S U B	R O U T	I N E =======================================
 24105                                  
 24106                                  P_TSEP:
 24107                                  	;mov	al,[TIME_SEP]
 24108                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 24109                                  	stosb
 24110                                  P_TSEP_RETN:
 24111                                  	retn
 24112                                  
 24113                                  ; ---------------------------------------------------------------------------
 24114                                  
 24115                                  PRMTTIM:
 24116                                  	mov	dx,CURTIMPTR
 24117                                  	call	STD_PRINTF	; Print "Current time is "
 24118                                  	call	PRINT_TIME
 24119                                  GETTIM:
 24120                                  	xor	cx,cx		; Initialize hours and minutes to zero
 24121                                  	mov	dx,NEWTIMPTR
 24122                                  	call	STD_PRINTF
 24123                                  	;mov	bx,':.'
 24124                                  	mov	bx,[TIMECHARS] 
 24125                                  	call	GETBUF
 24126                                  COMTIM:
 24127                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 24128                                  	jc	short TIMEERR
 24129                                  	mov	cx,dx
 24130                                  	xor	dx,dx
 24131                                  	lodsb
 24132                                  	cmp	al,0Dh
 24133                                  	je	short SAVTIM
 24134                                  	cmp	al,' '
 24135                                  	je	short GOTSEC2
 24136                                  	cmp	al,9
 24137                                  	je	short GOTSEC2
 24138                                  	cmp	al,bl
 24139                                  	je	short GOTSEC
 24140                                  	cmp	al,bh
 24141                                  	jne	short TIMEERR
 24142                                  GOTSEC:
 24143                                  	call	GETNUM
 24144                                  	jc	short TIMEERR
 24145                                  	mov	dh,ah		; Position seconds
 24146                                  	lodsb
 24147                                  	cmp	al,0Dh
 24148                                  	je	short SAVTIM
 24149                                  	cmp	al,' '
 24150                                  	je	short GOTSEC2
 24151                                  	cmp	al,9
 24152                                  	je	short GOTSEC2
 24153                                  	;cmp	al,'.'
 24154                                  	cmp	al,[DECIMAL_SEP]
 24155                                  	jne	short TIMEERR
 24156                                  	call	GETNUM
 24157                                  	jc	short TIMEERR
 24158                                  	mov	dl,ah
 24159                                  GOTSEC2:
 24160                                  	lodsb
 24161                                  	cmp	al,' '
 24162                                  	je	short GOTSEC2
 24163                                  	cmp	al,9
 24164                                  	je	short GOTSEC2
 24165                                  	cmp	al,0Dh
 24166                                  	jne	short TIMEERR
 24167                                  SAVTIM:
 24168                                  	mov	ah,SET_TIME ; 2Dh
 24169                                  	int	21h	; DOS -	SET CURRENT TIME
 24170                                  			; CH = hours,CL = minutes,DH = seconds,
 24171                                  			;		DL = hundredths of seconds
 24172                                  			; Return: AL = 00h if no error 
 24173                                  			;	     = FFh if bad value sent to routine
 24174                                  	or	al,al
 24175                                  P_TSEP_JRETN:
 24176                                  	jz	short P_TSEP_RETN ; Error in time?
 24177                                  TIMEERR:
 24178                                  	mov	dx,BADTIMPTR
 24179                                  	call	STD_PRINTF	; Print "Enter new time: "
 24180                                  	jmp	short GETTIM
 24181                                  
 24182                                  ; =============== S U B	R O U T	I N E =======================================
 24183                                  
 24184                                  GETBUF:
 24185                                  	mov	ah,Std_Con_String_Input ; 0Ah
 24186                                  	mov	dx,COMBUF
 24187                                  	mov	cx,2
 24188                                  	call	SETINITFLAG
 24189                                  	int	21h		; Get input line
 24190                                  	xor	cx,cx
 24191                                  	call	SETINITFLAG
 24192                                  	call	CRLF2
 24193                                  	mov	si,COMBUF+2
 24194                                  	cmp	byte [si],0Dh	; Check if new time entered
 24195                                  	jz	short P_TSEP_JRETN
 24196                                  
 24197                                  ; =============== S U B	R O U T	I N E =======================================
 24198                                  
 24199                                  INLINE:
 24200                                  	call	GETNUM		; Get one or two digit number
 24201                                  	jnb	short INLINE1
 24202                                  	retn
 24203                                  INLINE1:
 24204                                  	mov	dh,ah		; Put in position
 24205                                  	lodsb
 24206                                  	cmp	al,bl
 24207                                  	jz	short NEXT
 24208                                  	cmp	al,bh
 24209                                  	jz	short NEXT
 24210                                  	dec	si		; Clears zero flag
 24211                                  	clc
 24212                                  	mov	dl,0
 24213                                  	retn			; Time may have only an hour specified
 24214                                  NEXT:
 24215                                  	call	GETNUM
 24216                                  	mov	dl,ah		; Put in position
 24217                                  INLINE_RETN:
 24218                                  	retn
 24219                                  
 24220                                  ;============================================================================
 24221                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 24222                                  ;============================================================================
 24223                                  ; 05/10/2018 - Retro DOS v3.0
 24224                                  
 24225                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 24226                                  
 24227                                  ; =============== S U B	R O U T	I N E =======================================
 24228                                  
 24229                                  GETNUM:
 24230                                  	call	INDIG
 24231                                  	jb	short INLINE_RETN
 24232                                  	mov	ah,al		; Save first digit
 24233                                  	call	INDIG		; Another digit?
 24234                                  	jb	short OKRET
 24235                                  	aad			; Convert unpacked BCD to decimal
 24236                                  	mov	ah,al
 24237                                  OKRET:
 24238                                  	or	al,1
 24239                                  GETNUM_RETN:
 24240                                  	retn
 24241                                  
 24242                                  ; =============== S U B	R O U T	I N E =======================================
 24243                                  
 24244                                  INDIG:
 24245                                  	mov	al,[si]
 24246                                  	sub	al,'0'
 24247                                  	jc	short GETNUM_RETN
 24248                                  	cmp	al,10
 24249                                  	cmc
 24250                                  	jc	short GETNUM_RETN
 24251                                  	inc	si
 24252                                  	retn
 24253                                  
 24254                                  ; =============== S U B	R O U T	I N E =======================================
 24255                                  
 24256                                  OUT2:				; Output binary number as two ASCII digits
 24257                                  	aam			; Convert binary to unpacked BCD
 24258                                  	xchg	al,ah
 24259                                  	or	ax,3030h	; Add "0" bias to both digits
 24260                                  	cmp	al,'0'		; Is MSD zero?
 24261                                  	jnz	short NOSUP
 24262                                  	sub	al,bh		; Suppress leading zero if enabled
 24263                                  NOSUP:
 24264                                  	mov	bh,0		; Disable zero suppression
 24265                                  	stosw
 24266                                  	retn
 24267                                  
 24268                                  ; ---------------------------------------------------------------------------
 24269                                  	;stosb
 24270                                  	;retn
 24271                                  
 24272                                  ;============================================================================
 24273                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 24274                                  ;============================================================================
 24275                                  ; 03/10/2018 - Retro DOS v3.0
 24276                                  
 24277                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 24278                                  
 24279                                  ; =============== S U B	R O U T	I N E =======================================
 24280                                  
 24281                                  ; Set the special flag in the INIT flag to the value in CX.
 24282                                  
 24283                                  SETINITFLAG:
 24284                                  	mov	ds,[RESSEG]
 24285                                  	;and	byte [INITFLAG],0FDh
 24286                                  	and	byte [INITFLAG],~INITSPECIAL
 24287                                  	or	byte [INITFLAG],cl
 24288                                  	push	cs
 24289                                  	pop	ds
 24290                                  	retn
 24291                                  
 24292                                  ; =============== S U B	R O U T	I N E =======================================
 24293                                  
 24294                                  PIPEOFF:
 24295                                  	push	ds
 24296                                  	push	ax
 24297                                  	mov	ds,[cs:RESSEG]
 24298                                  	xor	al,al
 24299                                  	xchg	al,byte [PIPEFLAG]
 24300                                  	or	al,al
 24301                                  	jz	short PIPEOFFDONE
 24302                                  	shr	byte [ECHOFLAG],1
 24303                                  PIPEOFFDONE:
 24304                                  	pop	ax
 24305                                  	pop	ds
 24306                                  	retn
 24307                                  
 24308                                  ; ---------------------------------------------------------------------------
 24309                                  	;db    0,0,0,0,0
 24310                                  	;times 5 db 0
 24311                                  
 24312                                  align 16
 24313                                  
 24314                                  %endif
 24315                                  
 24316                                  ;============================================================================
 24317                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24318                                  ;============================================================================
 24319                                  ; 03/10/2018 - Retro DOS v3.0
 24320                                  
 24321                                  ;----------------------------------------------------------------------------
 24322                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24323                                  ; argv[argvcnt] array. The most important difference between this array and
 24324                                  ; the tradition UNIX format is the extra cparse information included with
 24325                                  ; each argument element.
 24326                                  ;---------------
 24327                                  ; ENTRY:
 24328                                  ;	BL	     special delimiter for cparse -- not implemented)
 24329                                  ;---------------
 24330                                  ; EXIT:
 24331                                  ;	CF	    set if error
 24332                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24333                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24334                                  ;	argvcnt     argument count
 24335                                  ;---------------
 24336                                  ; NOTE(S):
 24337                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24338                                  ;	*   Parseflags record contains cparse flags, as follows:
 24339                                  ;		sw_flag 	--	was this arg a switch?
 24340                                  ;		wildcard	--	whether or not it contained a * or ?
 24341                                  ;		path_sep	--	maybe it was a pathname
 24342                                  ;		unused		--	for future expansion
 24343                                  ;		special_delim	--	was there an initial special delimiter?
 24344                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24345                                  ;	*   Relationship between input, cparse output, and comtail can be
 24346                                  ;	    found in the following chart. Despite the claim of the cparse
 24347                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24348                                  ;	    tokens", such is not the case (see column two, row two).
 24349                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24350                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24351                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24352                                  ;	    documentation error.
 24353                                  ;	*   cparse also returns a switch code in BP for each switch it
 24354                                  ;	    recognizes on the command line.
 24355                                  ;	*   arglen for each token does NOT include the terminating null.
 24356                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24357                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24358                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24359                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24360                                  ;	    line parsing may result in slightly different behavior than
 24361                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24362                                  ;
 24363                                  ;	    Input		    Cparse		Command Line (80H)
 24364                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24365                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24366                                  ;	foo.bat 		foo.bat 		foo.bat
 24367                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24368                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24369                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24370                                  
 24371                                  ; =============== S U B	R O U T	I N E =======================================
 24372                                  
 24373                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24374                                  
 24375                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24376                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24377                                  
 24378                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24379                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24380                                  
 24381                                  ; 27/07/2024 - Retro DOS v4.0-v4.1-v4.2-v5.0 COMMAND.COM (PARSELINE)
 24382                                  ; PCDOS 7.1 - COMMAND.COM, transient portion/segment offset 35F5h
 24383                                  
 24384                                  PARSELINE:
 24385 00003033 50                      	push	ax			; most of these are clobbered
 24386 00003034 53                      	push	bx			; by cparse...
 24387 00003035 51                      	push	cx
 24388 00003036 52                      	push	dx
 24389 00003037 57                      	push	di
 24390 00003038 56                      	push	si
 24391 00003039 9C                      	pushf
 24392                                  	;mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24393 0000303A C706[7693]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24394 00003040 31C0                    	xor	ax,ax
 24395                                  	;;mov	cx,1348
 24396                                  	; 27/07/2024
 24397                                  	;mov	cx,1092  ; PCDOS 7.1 COMMAND.COM
 24398 00003042 B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092
 24399 00003045 A2[158C]                	mov	[cpyflag],al ; 0 ; 27/07/2024
 24400 00003048 BF[B08D]                	mov	di,ARG
 24401 0000304B F3AA                    	rep	stosb
 24402                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24403 0000304D C706[F492][7490]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24404                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24405                                  	;mov	word [ARG+ARG_UNIT.argswinfo],0
 24406 00003053 A3[7290]                	mov	[ARG+ARG_UNIT.argswinfo],ax ; 0 ; 27/07/2024
 24407                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24408                                  	;mov	word [ARG+ARG_UNIT.argvcnt],0
 24409 00003056 A3[7090]                	mov	[ARG+ARG_UNIT.argvcnt],ax ; 0 ; 27/07/2024 
 24410 00003059 BE[0689]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24411                                  
 24412                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24413                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24414                                  ; otherwise. This is done so that commands can get arg pointers into their
 24415                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24416                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24417                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24418                                  ; the command to be repeated or the transient part of command has been
 24419                                  ; reloaded.
 24420                                  
 24421 0000305C 1E                      	push	ds
 24422 0000305D 8E1E[A58A]              	mov	ds,[RESSEG]
 24423                                  	;cmp	byte [ForFlag],0
 24424 00003061 3806[9401]              	cmp	[ForFlag],al ; 0 ; 27/07/2024
 24425 00003065 1F                      	pop	ds
 24426 00003066 7510                    	jnz	short PCONT
 24427                                  	;mov	di,ARG_ARGFORCOMBUF
 24428 00003068 BF[7491]                	mov	di,ARG+ARG_UNIT.argforcombuf
 24429 0000306B 30ED                    	xor	ch,ch
 24430 0000306D 8A0E[0589]              	mov	cl,[COMBUF+1]
 24431 00003071 FEC1                    	inc	cl
 24432 00003073 F3A4                    	rep	movsb
 24433                                  	;mov	si,ARG_ARGFORCOMBUF
 24434 00003075 BE[7491]                	mov	si,ARG+ARG_UNIT.argforcombuf
 24435                                  PCONT:
 24436 00003078 BF[F692]                	mov	di,TPBUF	; destination is temporary token buffer
 24437 0000307B B320                    	mov	bl,' '		; no special delimiter, for now
 24438                                  PARSELOOP:
 24439 0000307D 8936[7893]              	mov	[COMPTR],si	; save ptr into original command buffer
 24440 00003081 31ED                    	xor	bp,bp		; switch information put here by cparse
 24441 00003083 C606[928D]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24442 00003088 E851F5                  	call	scanoff		; skip leading blanks...
 24443 0000308B E8C810                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24444 0000308E 730B                    	jnb	short MORE_PRSE
 24445 00003090 09ED                    	or	bp,bp		; Check for trailing switch character
 24446 00003092 7403                    	jz	short PARSEDONE
 24447 00003094 E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24448                                  				;   typical cause of this is that a
 24449                                  				;   switch char IMMEDIATELY preceeds
 24450                                  				;   the CR. We have an argument, but it
 24451                                  				;   is sort of an error.
 24452                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24453                                  	; 01/03/2023
 24454                                  PARSEDONE:
 24455 00003097 9D                      	popf
 24456 00003098 F8                      	clc
 24457 00003099 EB0C                    	jmp	short PARSE_EXIT
 24458                                  
 24459                                  MORE_PRSE:
 24460 0000309B C606[158C]02            	mov	byte [cpyflag],2
 24461                                  				; tell CPARSE that 1st token is done
 24462 000030A0 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24463 000030A3 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24464                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24465                                  	; 01/03/2023
 24466                                  ;PARSEDONE:
 24467                                  	;popf
 24468                                  	;clc
 24469                                  	;jmp	short PARSE_EXIT
 24470                                  
 24471                                  PARSE_ERROR:			; error entry (er, exit) point
 24472 000030A5 9D                      	popf
 24473 000030A6 F9                      	stc
 24474                                  PARSE_EXIT:			; depend on not changing CF
 24475 000030A7 5E                      	pop	si
 24476 000030A8 5F                      	pop	di
 24477 000030A9 5A                      	pop	dx
 24478 000030AA 59                      	pop	cx
 24479 000030AB 5B                      	pop	bx
 24480 000030AC 58                      	pop	ax
 24481 000030AD C3                      	retn
 24482                                  
 24483                                  ; =============== S U B	R O U T	I N E =======================================
 24484                                  
 24485                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24486                                  ;
 24487                                  ; ENTRY:
 24488                                  ;   BH			argflags
 24489                                  ;   CX			character count in argstring
 24490                                  ;   DI			pointer to argstring
 24491                                  ;   comptr		ptr to starting loc of current token in original command
 24492                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24493                                  ; EXIT:
 24494                                  ;   argbufptr		points to next free section of argbuffer
 24495                                  ;   arg.argbuf		contains null-terminated argument strings
 24496                                  ;   arg.argvcnt 	argument count
 24497                                  ;   arg.argv[]		array of flags and pointers
 24498                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24499                                  ;   CF			set if error
 24500                                  ;   AL			carry set:  error code; otherwise, zero
 24501                                  
 24502                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24503                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24504                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM 
 24505                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 24506                                  newarg:
 24507 000030AE 53                      	push	bx
 24508 000030AF 51                      	push	cx
 24509 000030B0 52                      	push	dx
 24510 000030B1 57                      	push	di
 24511 000030B2 56                      	push	si
 24512 000030B3 9C                      	pushf
 24513 000030B4 E86200                  	call	arg_switch		; if it's a switch, record switch info
 24514                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24515                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24516                                  
 24517                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24518 000030B7 833E[7090]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24519 000030BC 7D50                    	jge	short to_many_args	; exceeded array limits
 24520 000030BE 88FE                    	mov	dh,bh			
 24521                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24522 000030C0 8B1E[7090]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24523                                  	;inc	word [ARG_ARGVCNT]
 24524 000030C4 FF06[7090]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24525                                  	;mov	ax,ARG_ARGV
 24526 000030C8 B8[B08D]                	mov	ax,ARG+ARG_UNIT.argv
 24527 000030CB E87E00                  	call	argv_calc		; convert offset to pointer
 24528                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24529                                  	;mov	word [bx+7],0
 24530 000030CE C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24531                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24532                                  	;mov	[bx+5],cx
 24533 000030D3 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24534                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24535                                  	;mov	[bx+2],dh
 24536 000030D6 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24537 000030D9 8B36[F492]              	mov	si,[ARGBUF_PTR]
 24538                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24539                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24540 000030DD 8937                    	mov	[bx],si			
 24541 000030DF 0336[578D]              	add	si,[STARTEL]		; save startel from new location
 24542 000030E3 29FE                    	sub	si,di			; form pointer into argbuf
 24543                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24544                                  	;mov	[bx+3],si
 24545 000030E5 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24546 000030E8 8B36[7893]              	mov	si,[COMPTR]
 24547                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24548                                  	;mov	[bx+9],si
 24549 000030EC 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24550 000030EF 89FE                    	mov	si,di			; now save argstring in argbuffer
 24551 000030F1 8B3E[F492]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24552                                  
 24553                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24554                                  ; PCDOS 7.1 COMMAND.COM
 24555                                  %if 0
 24556                                  	add	di,cx			; sure we're not about to run off
 24557                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24558                                  	;;cmp	di,ARG_ARGBUF+255
 24559                                  	;cmp	di,ARG+ARG_UNIT.argbuf+127
 24560                                  	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24561                                  	jge	short buf_oflow		; the end of the buffer (plus null byte)
 24562                                  	sub	di,cx
 24563                                  %else
 24564                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24565                                  	;mov	bx,ARG_ARGBUF+127
 24566 000030F5 BB[F390]                	mov	bx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24567 000030F8 29FB                    	sub	bx,di	; sure we're not about to run off
 24568 000030FA 39CB                    	cmp	bx,cx
 24569 000030FC 7302                    	jnb	short newarg_@
 24570 000030FE 89D9                    	mov	cx,bx	
 24571                                  %endif
 24572                                  
 24573                                  newarg_@:	; 27/07/2024
 24574 00003100 FC                      	cld
 24575 00003101 F3A4                    	rep	movsb
 24576 00003103 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24577 00003105 AA                      	stosb
 24578 00003106 893E[F492]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24579                                  newarg_done:
 24580 0000310A 9D                      	popf
 24581 0000310B F8                      	clc
 24582 0000310C EB05                    	jmp	short newarg_exit
 24583                                  
 24584                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24585                                  ; PCDOS 7.1 COMMAND.COM
 24586                                  %if 0
 24587                                  to_many_args:
 24588                                  	mov	ax,1
 24589                                  	jmp	short newarg_error
 24590                                  buf_oflow:
 24591                                  	mov	ax,2
 24592                                  %else
 24593                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24594                                  ;buf_oflow:
 24595                                  ;	; 27/07/2024
 24596                                  ;	; PCDOS 7.1 COMMAND.COM
 24597                                  ;	sub	di,cx
 24598                                  ;	;mov	cx,ARG_ARGBUF+7Fh
 24599                                  ;	mov	cx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24600                                  ;	sub	cx,di
 24601                                  ;	jmp     short newarg_@
 24602                                  to_many_args:
 24603 0000310E B80100                  	mov	ax,1
 24604                                  %endif
 24605                                  
 24606                                  newarg_error:
 24607 00003111 9D                      	popf
 24608 00003112 F9                      	stc
 24609                                  newarg_exit:
 24610 00003113 5E                      	pop	si
 24611 00003114 5F                      	pop	di
 24612 00003115 5A                      	pop	dx
 24613 00003116 59                      	pop	cx
 24614 00003117 5B                      	pop	bx
 24615 00003118 C3                      	retn
 24616                                  
 24617                                  ; =============== S U B	R O U T	I N E =======================================
 24618                                  
 24619                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24620                                  ; event that it is, and we can recognize
 24621                                  ;
 24622                                  ; ENTRY:
 24623                                  ;   As in <newarg>.
 24624                                  ; EXIT:
 24625                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24626                                  ; NOTE(S):
 24627                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24628                                  ;	on the order of definition in the <switch_list> variable and the
 24629                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24630                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24631                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24632                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24633                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24634                                  ;   *	An ugly routine.
 24635                                  
 24636                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24637                                  arg_switch:
 24638 00003119 50                      	push	ax
 24639 0000311A 53                      	push	bx
 24640 0000311B 51                      	push	cx
 24641 0000311C 57                      	push	di
 24642 0000311D 9C                      	pushf
 24643 0000311E F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24644 00003121 741C                    	jz	short arg_no_switch0
 24645 00003123 833E[7693]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24646 00003128 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24647 0000312A 8B1E[7693]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24648                                  	;mov	ax,offset TRANGROUP:arg.argv
 24649                                  	;mov	ax,ARG_ARGV
 24650 0000312E B8[B08D]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24651 00003131 E81800                  	call	argv_calc
 24652                                  	;or	[BX].argsw_word,BP
 24653                                  	;or	[bx+7],bp
 24654 00003134 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24655                                  	;or	arg.argswinfo,BP
 24656                                  	;or	[ARG_ARGSWINFO],bp
 24657 00003137 092E[7290]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24658                                  arg_yes_switch:
 24659 0000313B 9D                      	popf
 24660 0000313C F9                      	stc
 24661 0000313D EB08                    	jmp	short arg_switch_exit
 24662                                  
 24663                                  arg_no_switch0:
 24664                                  	;mov	ax,[ARG_ARGVCNT]
 24665 0000313F A1[7090]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24666 00003142 A3[7693]                	mov	[LASTARG],ax
 24667                                  arg_no_switch1:
 24668 00003145 9D                      	popf
 24669 00003146 F8                      	clc
 24670                                  arg_switch_exit:
 24671 00003147 5F                      	pop	di
 24672 00003148 59                      	pop	cx
 24673 00003149 5B                      	pop	bx
 24674 0000314A 58                      	pop	ax
 24675 0000314B C3                      	retn
 24676                                  
 24677                                  ; =============== S U B	R O U T	I N E =======================================
 24678                                  
 24679                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24680                                  ; the supplied array.  Method used for computing the address is:
 24681                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24682                                  ; ENTRY:
 24683                                  ;   AX	    --	    base of array
 24684                                  ;   BX	    --	    array index
 24685                                  ; EXIT:
 24686                                  ;   BX	    --	    byte offset
 24687                                  
 24688                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24689                                  argv_calc:
 24690 0000314C 50                      	push	ax		; Save base
 24691 0000314D 88D8                    	mov	al,bl		; al = array index
 24692                                  	;mov	bl,11
 24693 0000314F B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24694 00003151 F6E3                    	mul	bl		; ax = base offset
 24695 00003153 5B                      	pop	bx		; Get base
 24696 00003154 01D8                    	add	ax,bx		; Add in base offset
 24697 00003156 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24698 00003157 C3                      	retn
 24699                                  
 24700                                  ; ---------------------------------------------------------------------------
 24701                                  	
 24702                                  	;db 0Ah dup(0)
 24703                                  	;times 10 db 0
 24704                                  
 24705 00003158 90<rep 8h>              align 16
 24706                                  
 24707                                  ;============================================================================
 24708                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24709                                  ;============================================================================
 24710                                  ; 03/10/2018 - Retro DOS v3.0
 24711                                  
 24712                                  ;----------------------------------------------------------------------------
 24713                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24714                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24715                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24716                                  ;    file on disk. Directories specified in the user's search path will be
 24717                                  ;    searched for a matching file, if a match is not found in the current
 24718                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24719                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24720                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24721                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24722                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24723                                  ;    (easily) modified to make no assumptions about where its input is found.
 24724                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24725                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24726                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24727                                  ;    else that wants to save the whole shebang and then process other command
 24728                                  ;    lines.
 24729                                  ;
 24730                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24731                                  ;
 24732                                  ; ENTRY:
 24733                                  ;   <Path_Search>:	    argv[0].
 24734                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24735                                  ; EXIT:
 24736                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24737                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24738                                  ; NOTE(S):
 24739                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24740                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24741                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24742                                  ;	does not function as specified; see <Parseline> for more details.
 24743                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24744                                  ;	need to know about. This extra information is stored in a switch_flag
 24745                                  ;	word with each command-line argument; the switches themselves will not
 24746                                  ;	appear in the resulting arg structure.
 24747                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24748                                  ;----------------------------------------------------------------------------
 24749                                  
 24750                                  ; =============== S U B	R O U T	I N E =======================================
 24751                                  
 24752                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24753                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24754                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24755                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24756                                  ; have a match, either in the current working directory if we were handed
 24757                                  ; a filename, or in the specified directory, given a pathname. If this call
 24758                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24759                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24760                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24761                                  ; either the first invocation of search or on one of the succeeding calls
 24762                                  ; sets up the appropriate information for copying the successful pathname
 24763                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24764                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24765                                  ;
 24766                                  ; ENTRY:
 24767                                  ;   argv[0]		--	command name and associated information
 24768                                  ; EXIT:
 24769                                  ;   AX			--	non-zero indicates type of file found
 24770                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24771                                  ; NOTE(S):
 24772                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24773                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24774                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24775                                  ;	if search returns an .exe or .bat.
 24776                                  ;   5)	Clobbers dma address.
 24777                                  
 24778                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24779                                  PATH_SEP_CHAR	EQU	';'
 24780                                  
 24781                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24782                                  
 24783                                  	;special_delim equ 128
 24784                                  	;path_sep equ 4
 24785                                  	;wildcard equ 2
 24786                                  	;sw_flag  equ 1
 24787                                  
 24788                                  ;----------------------------------------------------------------------------
 24789                                  
 24790                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24791                                  
 24792                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24793                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24794                                  
 24795                                  path_search:
 24796 00003160 53                      	push	bx
 24797 00003161 51                      	push	cx
 24798 00003162 52                      	push	dx		; could use a "stack 'em" instruction
 24799 00003163 56                      	push	si
 24800 00003164 57                      	push	di
 24801 00003165 55                      	push	bp
 24802 00003166 9C                      	pushf
 24803                                  
 24804                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24805                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24806 00003167 F606[B28D]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24807 0000316C 7403                    	jz	short path_search_ok
 24808                                  path_failure_jmp:
 24809 0000316E E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24810                                  
 24811                                  path_search_ok:
 24812 00003171 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24813 00003174 BA[7A93]                	mov	dx,FBUF		; clobber old dma value with
 24814 00003177 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24815 0000317A CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24816                                  			; DS:DX	-> disk	transfer buffer
 24817 0000317C 06                      	push	es
 24818 0000317D E88BF1                  	call	find_path	; get a handle (ES:DI) on user path
 24819 00003180 8C06[A593]              	mov	[pathinfo+0],es	; and squirrel it away
 24820 00003184 893E[A793]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24821 00003188 893E[A993]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24822 0000318C 07                      	pop	es
 24823                                  	
 24824 0000318D BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24825 00003190 BE[CD89]                	mov	si,EXECPATH
 24826 00003193 E88002                  	call	STRIP
 24827 00003196 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24828                                  		
 24829 00003198 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24830 0000319A C706[FA93][587F]        	mov	word [search_error],baddrv_ptr
 24831 000031A0 E89F01                  	call	PSEARCH		; must do at least one search
 24832 000031A3 09C0                    	or	ax,ax		; find anything?
 24833 000031A5 7469                    	jz	short path_noinit
 24834                                  				; failure ... search farther
 24835 000031A7 89C5                    	mov	bp,ax		; success... save filetype code
 24836 000031A9 BF[CD89]                	mov	di,EXECPATH
 24837                                  	;mov	si,ds:arg.argv[0].argpointer
 24838                                  	;mov	si,[ARG_ARGV]
 24839 000031AC 8B36[B08D]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24840                                  	;mov	cx,ds:arg.argv[0].argstartel
 24841                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24842 000031B0 8B0E[B38D]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24843 000031B4 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24844                                  
 24845                                  ; We have the number of bytes in the prefix (up to the final component).
 24846                                  ; We need to form the complete pathname including leading drive and current
 24847                                  ; directory.
 24848                                  ;
 24849                                  ; Is there a drive letter present?
 24850                                  
 24851 000031B6 B43A                    	mov	ah,':'
 24852 000031B8 83F902                  	cmp	cx,2		; room for drive letter?
 24853 000031BB 7205                    	jb	short adddrive	; no, stick it in
 24854 000031BD 386401                  	cmp	[si+1],	ah	; colon present?
 24855 000031C0 7408                    	je	short movedrive	; yes, just move it
 24856                                  adddrive:
 24857 000031C2 A0[B78A]                	mov	al,[CURDRV]	; get current drive
 24858 000031C5 0441                    	add	al,'A'		; convert to uppercase letter
 24859 000031C7 AB                      	stosw			; store d:
 24860 000031C8 EB05                    	jmp	short checkpath
 24861                                  
 24862                                  movedrive:
 24863 000031CA AD                      	lodsw			; move d:
 24864 000031CB AB                      	stosw
 24865 000031CC 83E902                  	sub	cx,2		; 2 bytes less to move
 24866                                  checkpath:
 24867 000031CF 0C20                    	or	al,20h
 24868 000031D1 88C2                    	mov	dl,al
 24869                                  	;sub	dl,60h
 24870 000031D3 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24871                                  
 24872                                  ; Stick in beginning path char
 24873                                  
 24874 000031D6 A0[AB93]                	mov	al,[psep_char]
 24875 000031D9 AA                      	stosb
 24876                                  
 24877                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24878                                  ; Otherwise, get current dir for DL.
 24879                                  
 24880 000031DA 83F901                  	cmp	cx,1		; is there room for path char?
 24881 000031DD 720A                    	jb	short addpath	; no, go add path
 24882 000031DF AC                      	lodsb
 24883 000031E0 49                      	dec	cx
 24884 000031E1 3A06[AB93]              	cmp	al,[psep_char]	; is there a path separator?
 24885 000031E5 741C                    	je	short movepath	; yes, go move remainder of path
 24886 000031E7 41                      	inc	cx
 24887 000031E8 4E                      	dec	si		; undo the lodsb
 24888                                  addpath:
 24889 000031E9 56                      	push	si
 24890 000031EA 89FE                    	mov	si,di		; remainder of buffer
 24891 000031EC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24892 000031EF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24893                                  			; DL = drive (0=default,1=A,etc.)
 24894                                  			; DS:SI	points to 64-byte buffer area
 24895                                  
 24896                                  ; The previous current dir will succeed a previous find_first already worked.
 24897                                  ;
 24898                                  ; Find end of string.
 24899                                  
 24900 000031F1 89F7                    	mov	di,si
 24901 000031F3 5E                      	pop	si
 24902 000031F4 A0[AB93]                	mov	al,[psep_char]
 24903 000031F7 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24904 000031FA 7407                    	jz	short movepath	; yes, no need for path char
 24905                                  scanend:
 24906                                  	;cmp	byte [di],0	; end of string?
 24907                                  	;jz	short foundend
 24908                                  	;inc	di
 24909                                  	;jmp	short scanend
 24910                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24911 000031FC 47                      	inc	di
 24912 000031FD 803D00                  	cmp	byte [di],0
 24913 00003200 75FA                    	jnz	short scanend
 24914                                  
 24915                                  ; Stick in a trailing path char.
 24916                                  
 24917                                  foundend:
 24918 00003202 AA                      	stosb
 24919                                  
 24920                                  ; Move remaining part of path. Skip leading path char if present.
 24921                                  
 24922                                  movepath:
 24923 00003203 3804                    	cmp	[si],al		; first char a path char?
 24924 00003205 7502                    	jne	short copypath
 24925                                  	; 26/04/2023
 24926 00003207 46                      	inc	si		; move past leading char
 24927 00003208 49                      	dec	cx		; drop from count
 24928                                  copypath:
 24929 00003209 E302                    	jcxz	_copydone	; no chars to move!
 24930 0000320B F3A4                    	rep	movsb
 24931                                  _copydone:
 24932 0000320D E9A100                  	jmp	path_success
 24933                                  				; run off and form complete pathname
 24934                                  path_noinit:
 24935                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24936                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24937 00003210 F606[B28D]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24938 00003215 751B                    	jnz	short path_failure
 24939                                  				; complete pathname specified ==> fail
 24940                                  	;mov	bh,';'
 24941 00003217 B73B                    	mov	bh,PATH_SEP_CHAR
 24942                                  				; semicolon terminates pathstring
 24943                                  	;mov	dx,ds:arg.argv[0].argstartel
 24944                                  				; this is where the last element starts
 24945                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24946 00003219 8B16[B38D]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24947                                  	;sub	dx,ds:arg.argv[0].argpointer
 24948                                  				; form pointer into EXECPATH,
 24949                                  	;sub	dx,[ARG_ARGV]
 24950 0000321D 2B16[B08D]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24951 00003221 81C2[CD89]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24952                                  path_loop:
 24953 00003225 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24954 00003228 89C5                    	mov	bp,ax		; save filetype code
 24955 0000322A 9F                      	lahf			; save flags, just in case
 24956 0000322B 09ED                    	or	bp,bp		; did path_crunch find anything?
 24957 0000322D 7508                    	jnz	short path_found
 24958 0000322F 9E                      	sahf			; see? needed those flags, after all!
 24959 00003230 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24960                                  path_failure:
 24961 00003232 31C0                    	xor	ax,ax
 24962 00003234 E98700                  	jmp	path_exit
 24963                                  
 24964                                  path_found:				; pathinfo[] points to winner
 24965 00003237 BF[CD89]                	mov	di,EXECPATH
 24966                                  	;mov	cx,pathinfo[4]
 24967 0000323A 8B0E[A993]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24968                                  	;mov	si,pathinfo[2]
 24969 0000323E 8B36[A793]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24970                                  
 24971                                  ;	BAS Nov 20/84
 24972                                  ;   Look at the pathname and expand . and .. if they are the first element
 24973                                  ;   in the pathname (after the drive letter)
 24974                                  
 24975 00003242 06                      	push	es
 24976                                  	;push	pathinfo[0]
 24977 00003243 FF36[A593]              	push	word [pathinfo+0]
 24978 00003247 07                      	pop	es
 24979                                  ;SR;
 24980                                  ; Oops! Gets fooled if path= \;..
 24981                                  ; We should also check if a drive letter is really present
 24982                                  ;
 24983 00003248 26807C022E              	cmp	byte [es:si+2],'.'
 24984                                  				; Look for Current dir at start of path
 24985 0000324D 7534                    	jne	short path_cpy
 24986                                  
 24987                                  	; 18/03/2023
 24988                                  	; MSDOS 6.0
 24989 0000324F 26807C013A              	cmp	byte [es:si+1],':'
 24990                                  				; does path have drive letter?
 24991 00003254 752D                    	jne	short path_cpy	; no, copy the path string
 24992                                  
 24993 00003256 51                      	push	cx		; Save pointer to end of string
 24994                                  	;mov	al,[es:si]
 24995                                  	;mov	[di],al		; Copy drive letter, :, and root char
 24996                                  	;mov	al,[es:si+1]	; to EXECPATH
 24997                                  	;mov	[di+1],al
 24998                                  	; 05/05/2023
 24999 00003257 268B04                  	mov	ax,[es:si]
 25000 0000325A 8905                    	mov	[di],ax
 25001 0000325C A0[AB93]                	mov	al,[psep_char]
 25002 0000325F 884502                  	mov	[di+2],al
 25003 00003262 56                      	push	si		; Save pointer to begining of string
 25004 00003263 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25005 00003266 80CA20                  	or	dl,20h
 25006                                  	;sub	dl,60h
 25007 00003269 80EA60                  	sub	dl,'a'-1
 25008 0000326C 89FE                    	mov	si,di		; pointer to EXECPATH
 25009 0000326E 83C603                  	add	si,3		; Don't wipe out drive and root info
 25010 00003271 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25011 00003274 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25012                                  			; DL = drive (0=default,1=A,etc.)
 25013                                  			; DS:SI	points to 64-byte buffer area
 25014 00003276 E8F1F9                  	call	dstrlen		; Determine length of present info
 25015 00003279 01CE                    	add	si,cx		; Don't copy over drive and root info
 25016 0000327B 4E                      	dec	si
 25017 0000327C 89F7                    	mov	di,si		; Point to end of target string
 25018 0000327E 5E                      	pop	si		; Restore pointer to begining of string
 25019 0000327F 83C603                  	add	si,3		; Point past drive letter, :, .
 25020 00003282 59                      	pop	cx		; Restore pointer to end of string
 25021                                  path_cpy:
 25022 00003283 07                      	pop	es
 25023 00003284 29F1                    	sub	cx,si		; yields character count
 25024 00003286 1E                      	push	ds		; time to switch segments
 25025 00003287 FF36[A593]              	push	word [pathinfo+0]
 25026                                  				; string lives in this segment
 25027 0000328B 1F                      	pop	ds
 25028 0000328C FC                      	cld
 25029                                  
 25030                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25031                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25032                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25033                                  kloop:
 25034 0000328D AC                      	lodsb			;AN000;  3/3/KK
 25035 0000328E AA                      	stosb			;AN000;  3/3/KK
 25036 0000328F E82BF1                  	call	testkanj	;AN000;  3/3/KK
 25037 00003292 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25038 00003294 49                      	dec	cx		;AN000;  3/3/KK
 25039 00003295 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25040 00003297 A4                      	movsb			;AN000;  3/3/KK
 25041 00003298 49                      	dec	cx		;AN000;  3/3/KK
 25042 00003299 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25043 0000329C 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25044                                  popdone:			;AN000;  3/3/KK
 25045 0000329E 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25046 0000329F A0[AB93]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25047 000032A2 EB0C                    	jmp	short path_store
 25048                                  				;AN000;  3/3/KK
 25049                                  _notkanj1:
 25050                                  	; 26/04/2023
 25051 000032A4 E2E7                    	loop	kloop
 25052 000032A6 1F                      	pop	ds		; return to our segment
 25053 000032A7 4F                      	dec	di		; overwrite terminator
 25054 000032A8 A0[AB93]                	mov	al,[psep_char]	; with a pathname separator
 25055 000032AB 3A45FF                  	cmp	al,[di-1]
 25056 000032AE 7401                    	je	short path_success
 25057                                  path_store:
 25058 000032B0 AA                      	stosb
 25059                                  path_success:
 25060 000032B1 BE[AD93]                	mov	si,search_best_buf
 25061 000032B4 31C9                    	xor	cx,cx
 25062                                  path_succ_loop:
 25063 000032B6 AC                      	lodsb			; append winning filename to path
 25064 000032B7 AA                      	stosb			; (including terminating null)
 25065 000032B8 08C0                    	or	al,al
 25066 000032BA 75FA                    	jnz	short path_succ_loop
 25067 000032BC 89E8                    	mov	ax,bp		; retrieve filetype code
 25068                                  path_exit:
 25069 000032BE 9D                      	popf
 25070 000032BF 5D                      	pop	bp
 25071 000032C0 5F                      	pop	di
 25072 000032C1 5E                      	pop	si		; chill out...
 25073 000032C2 5A                      	pop	dx
 25074 000032C3 59                      	pop	cx
 25075 000032C4 5B                      	pop	bx
 25076 000032C5 C3                      	retn
 25077                                  
 25078                                  ; =============== S U B	R O U T	I N E =======================================
 25079                                  
 25080                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25081                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25082                                  ;
 25083                                  ; ENTRY:
 25084                                  ; EXIT:
 25085                                  ; NOTE(S):
 25086                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25087                                  
 25088                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25089                                  STORE_PCHAR:
 25090 000032C6 50                      	push	ax
 25091 000032C7 B02F                    	mov	al,'/'		; is the pathname-element separator
 25092 000032C9 E89EF3                  	call	pathchrcmp	; a regular slash?
 25093 000032CC 7402                    	jz	short STORE_SLASH
 25094                                  				; if yes, remember slash
 25095 000032CE B05C                    	mov	al,'\'
 25096                                  	; 18/03/2023
 25097                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25098                                  	;pop	ax
 25099                                  	;retn
 25100                                  STORE_SLASH:
 25101 000032D0 A2[AB93]                	mov	[psep_char],al
 25102 000032D3 58                      	pop	ax
 25103 000032D4 C3                      	retn
 25104                                  
 25105                                  ; =============== S U B	R O U T	I N E =======================================
 25106                                  
 25107                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25108                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25109                                  ; additional separator to use for breaking up the path-string. Null is the
 25110                                  ; default. Once the user-string has been formed, search is invoked to see
 25111                                  ; what's out there.
 25112                                  ;
 25113                                  ; ENTRY:
 25114                                  ;   BH			--	additional terminator character
 25115                                  ;   SI			--	pointer into pathstring to be dissected
 25116                                  ;   DX			--	pointer to stripped filename
 25117                                  ; EXIT:
 25118                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25119                                  ;   SI			--	moves along pathstring from call to call
 25120                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25121                                  ;   [tpbuf]		--	clobbered
 25122                                  ; NOTE(S):
 25123                                  ;   *	Implicit in this code is the ability to specify when to search
 25124                                  ;	the current directory (if at all) through the PATH defined by
 25125                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25126                                  ;	current directory before the bin and etc directories of drive c).
 25127                                  
 25128                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25129                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25130                                  
 25131                                  path_crunch:
 25132 000032D5 53                      	push	bx
 25133 000032D6 51                      	push	cx
 25134 000032D7 52                      	push	dx
 25135 000032D8 57                      	push	di
 25136 000032D9 56                      	push	si
 25137                                  	;pushf	; ** ; 18/03/2023
 25138 000032DA E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25139 000032DD BF[F692]                	mov	di,TPBUF	; destination of concatenated string
 25140 000032E0 8B36[A993]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25141 000032E4 8936[A793]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25142 000032E8 1E                      	push	ds		; save old segment pointer
 25143 000032E9 FF36[A593]              	push	word [pathinfo+0]
 25144                                  				; replace with pointer to userpath's
 25145 000032ED 1F                      	pop	ds		; segment
 25146                                  	; 26/04/2023
 25147 000032EE 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK
 25148                                  path_cr_copy:
 25149 000032F0 AC                      	lodsb			; get a pathname byte
 25150 000032F1 08C0                    	or	al,al		; check for terminator(s)
 25151 000032F3 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25152 000032F5 38F8                    	cmp	al,bh
 25153 000032F7 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25154                                  	;
 25155                                  	; 18/03/2023
 25156                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25157 000032F9 E8C1F0                  	call	testkanj	;AN000; 3/3/KK
 25158 000032FC 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25159 000032FE AA                      	stosb			;AN000; 3/3/KK
 25160 000032FF A4                      	movsb			;AN000; 3/3/KK
 25161 00003300 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK
 25162 00003302 EBEC                    	jmp	short path_cr_copy
 25163                                  _notkanj2:
 25164 00003304 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25165                                  	;
 25166 00003306 AA                      	stosb
 25167 00003307 EBE7                    	jmp	short path_cr_copy
 25168                                  
 25169                                  path_seg:
 25170 00003309 1F                      	pop	ds		; restore old data segment
 25171 0000330A 8936[A993]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25172 0000330E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25173                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25174 00003310 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25175 00003312 81FF[F692]              	cmp	di,TPBUF	; was there really anything in pathstr?
 25176 00003316 7421                    	je	short path_cr_leave
 25177                                  				; if nothing was copied, pathstr empty
 25178                                  path_cr_look:
 25179 00003318 A0[AB93]                	mov	al,[psep_char]	; form complete pathname
 25180                                  	;
 25181                                  	; 18/03/2023
 25182                                  	; MSDOS 6.0
 25183 0000331B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25184 0000331D 7505                    	jnz	short path_cr_store
 25185                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25186                                  	;
 25187 0000331F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25188 00003322 7401                    	je	short path_cr_l1
 25189                                  path_cr_store:
 25190 00003324 AA                      	stosb
 25191                                  path_cr_l1:
 25192 00003325 89D6                    	mov	si,dx
 25193                                  path_cr_l2:
 25194 00003327 AC                      	lodsb			; tack the stripped filename onto
 25195 00003328 AA                      	stosb			; the end of the path, up to and
 25196 00003329 08C0                    	or	al,al		; including the terminating null
 25197 0000332B 75FA                    	jnz	short path_cr_l2
 25198 0000332D BA[F692]                	mov	dx,TPBUF	; and look for an appropriate file...
 25199 00003330 C706[FA93][5480]        	mov	word [search_error],BADPMES_PTR
 25200                                  	;invoke search
 25201 00003336 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25202                                  
 25203                                  	; 18/03/2023
 25204                                  ;path_cr_leave:
 25205                                  	;or	bl,bl		; did we finish off the pathstring?
 25206                                  	;jz	short path_cr_empty
 25207                                  	;			; null in BL means all gone...
 25208                                  	;popf	; **		; otherwise, plenty left
 25209                                  	;clc
 25210                                  	;jmp	short path_cr_exit
 25211                                  ;path_cr_empty:
 25212                                  	;popf	; **
 25213                                  	;stc
 25214                                  ;path_cr_exit:
 25215                                  
 25216                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25217                                  path_cr_leave:
 25218                                  	;popf ; ** ; 18/03/2023
 25219 00003339 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25220                                  
 25221                                  path_cr_exit:
 25222 0000333C 5E                      	pop	si
 25223 0000333D 5F                      	pop	di
 25224 0000333E 5A                      	pop	dx
 25225 0000333F 59                      	pop	cx
 25226 00003340 5B                      	pop	bx
 25227 00003341 C3                      	retn
 25228                                  
 25229                                  ;============================================================================
 25230                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25231                                  ;============================================================================
 25232                                  ; 02/10/2018 - Retro DOS v3.0
 25233                                  
 25234                                  ;----------------------------------------------------------------------------
 25235                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25236                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25237                                  ; lowest priority). Where conflicts arise, the extension with
 25238                                  ; the highest priority is favored.
 25239                                  ; ENTRY:
 25240                                  ;   DX		--	pointer to null-terminated pathname
 25241                                  ;   fbuf	--	dma buffer for findfirst/next
 25242                                  ; EXIT:
 25243                                  ;   AX		--	8)  file found with .com extension
 25244                                  ;			4)  file found with .exe extension
 25245                                  ;			2)  file found with .bat extension
 25246                                  ;			0)  no such file to be found
 25247                                  ;   (if AX is non-zero:)
 25248                                  ;   [search_best]	identical to AX
 25249                                  ;   [search_best_buf]	null-terminated filename
 25250                                  ; NOTES:
 25251                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25252                                  ;---------------
 25253                                  ; CONSTANTS:
 25254                                  ;---------------
 25255                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25256                                  SEARCH_COM		EQU	8
 25257                                  SEARCH_EXE		EQU	4
 25258                                  SEARCH_BAT		EQU	2
 25259                                  FNAME_LEN		EQU	8
 25260                                  FNAME_MAX_LEN		EQU	13
 25261                                  DOT			EQU	'.'
 25262                                  WILDCHAR		EQU	'?'
 25263                                  
 25264                                  
 25265                                  ; =============== S U B	R O U T	I N E =======================================
 25266                                  
 25267                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25268                                  
 25269                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25270                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25271                                  	
 25272                                  PSEARCH:
 25273 00003342 51                      	push	cx
 25274 00003343 52                      	push	dx
 25275 00003344 57                      	push	di
 25276 00003345 56                      	push	si
 25277                                  	;pushf	; ** ; 18/03/2023
 25278 00003346 52                      	push	dx		; check drivespec (save pname ptr)
 25279 00003347 89D7                    	mov	di,dx		; working copy of pathname
 25280 00003349 BE[BA93]                	mov	si,search_curdir_buf
 25281 0000334C 31D2                    	xor	dx,dx		; zero means current drive
 25282 0000334E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25283 00003352 7508                    	jne	short SEARCH_DIR_CHECK
 25284 00003354 8A15                    	mov	dl,[di]		; get the drive byte
 25285 00003356 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25286 00003359 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25287                                  SEARCH_DIR_CHECK:
 25288 0000335C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25289 0000335F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25290                                  			; DL = drive (0=default,1=A,etc.)
 25291                                  			; DS:SI	points to 64-byte buffer area
 25292 00003361 5A                      	pop	dx		; directory? If we can't we'll
 25293 00003362 724C                    	jc	short SEARCH_INVALID_DRIVE
 25294                                  				; assume it's a bad drive...
 25295 00003364 B91300                  	mov	cx,search_attr	; 13h
 25296                                  				; filetypes to search for
 25297 00003367 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25298 0000336A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25299                                  			; CX = search attributes
 25300                                  			; DS:DX	-> ASCIZ filespec
 25301                                  			; (drive,path, and wildcards allowed)
 25302 0000336C 7249                    	jc	short SEARCH_NO_FILE
 25303 0000336E C606[AC93]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25304 00003373 C606[AD93]00            	mov	byte [search_best_buf],ANULL
 25305                                  				; 0 ; nothing's been found, yet
 25306                                  SEARCH_LOOP:
 25307 00003378 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25308 0000337B 3A06[AC93]              	cmp	al,[search_best]
 25309                                  				; better than what we've found so far?
 25310 0000337F 7E13                    	jle	short SEARCH_NEXT
 25311                                  				; no, look for another
 25312 00003381 A2[AC93]                	mov	[search_best],al
 25313                                  				; found something... save its code
 25314                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25315                                  	;mov	si,FBUF_PNAME
 25316 00003384 BE[9893]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25317 00003387 BF[AD93]                	mov	di,search_best_buf
 25318 0000338A B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25319 0000338D FC                      	cld
 25320 0000338E F3A4                    	rep	movsb		; save complete pathname representation
 25321 00003390 3C08                    	cmp	al,SEARCH_COM	; 8
 25322                                  				; have we found the best of all?
 25323 00003392 740A                    	je	short SEARCH_DONE
 25324                                  SEARCH_NEXT:			; keep on looking
 25325 00003394 B91300                  	mov	cx,search_attr ; 13h
 25326 00003397 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25327 0000339A CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25328                                  			; [DTA]	= data block from
 25329                                  			; last AH = 4Eh/4Fh call
 25330 0000339C 73DA                    	jnc	short SEARCH_LOOP
 25331                                  SEARCH_DONE:			; it's all over with...
 25332 0000339E A0[AC93]                	mov	al,[search_best]
 25333                                  				; pick best to return with
 25334                                  	; 18/03/2023
 25335                                  	; MSDOS 6.0
 25336 000033A1 803E[668D]01            	cmp	byte [ext_entered],1
 25337                                  				;AN005; Did user request a specific ext?
 25338 000033A6 7411                    	je	short SEARCH_EXIT
 25339                                  				;AN005; no - exit
 25340 000033A8 A0[668D]                	mov	al,[ext_entered]
 25341                                  				;AN005; yes - get the real file type back
 25342 000033AB A2[AC93]                	mov	[search_best],al
 25343                                  				;AN005; save the real file type
 25344                                  	;
 25345 000033AE EB09                    	jmp	short SEARCH_EXIT
 25346                                  
 25347                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25348 000033B0 8B16[FA93]              	mov	dx,[search_error]
 25349                                  				; appropriate error message
 25350 000033B4 E81A1A                  	call	std_printf	; and pretend no file found
 25351                                  
 25352                                  SEARCH_NO_FILE:			; couldn't find a match
 25353                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25354                                  	; 18/03/2023
 25355 000033B7 31C0                    	xor	ax,ax
 25356                                  SEARCH_EXIT:
 25357                                  	;popf	; ** ; 18/03/2023
 25358 000033B9 5E                      	pop	si
 25359 000033BA 5F                      	pop	di
 25360 000033BB 5A                      	pop	dx
 25361 000033BC 59                      	pop	cx
 25362 000033BD C3                      	retn
 25363                                  
 25364                                  ; =============== S U B	R O U T	I N E =======================================
 25365                                  
 25366                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25367                                  ;
 25368                                  ; ENTRY:
 25369                                  ;   fbuf    --	dma buffer containing filename
 25370                                  ; EXIT:
 25371                                  ;   AX	    --	file code, as given in search header
 25372                                  ; NOTE(S):
 25373                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25374                                  
 25375                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25376                                  
 25377                                  SEARCH_FTYPE:
 25378 000033BE 57                      	push	di
 25379 000033BF 56                      	push	si
 25380                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25381                                  	; 18/02/2023
 25382 000033C0 31C0                    	xor	ax,ax ; ax = 0		
 25383                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25384                                  	;mov	di,FBUF_PNAME
 25385 000033C2 BF[9893]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25386 000033C5 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25387 000033C8 FC                      	cld
 25388 000033C9 F2AE                    	repnz	scasb		; search for the terminating null
 25389 000033CB 7535                    	jnz	short FTYPE_EXIT
 25390                                  				; weird... no null byte at end
 25391 000033CD 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25392                                  
 25393                                  	; Compare .COM
 25394                                  
 25395 000033D0 BE[2584]                	mov	si,comext ; ".COM"
 25396 000033D3 89F8                    	mov	ax,di
 25397 000033D5 A7                      	cmpsw
 25398 000033D6 7508                    	jnz	short FTYPE_EXE
 25399 000033D8 A7                      	cmpsw
 25400 000033D9 7505                    	jnz	short FTYPE_EXE
 25401                                  	;mov	ax,8
 25402 000033DB B80800                  	mov	ax,SEARCH_COM	; success!
 25403 000033DE EB22                    	jmp	short FTYPE_EXIT
 25404                                  
 25405                                  	; Compare .EXE
 25406                                  FTYPE_EXE:			; still looking... now for '.exe'
 25407 000033E0 89C7                    	mov	di,ax
 25408 000033E2 BE[2984]                	mov	si,exeext ; ".EXE"
 25409 000033E5 A7                      	cmpsw
 25410 000033E6 7508                    	jnz	short FTYPE_BAT
 25411 000033E8 A7                      	cmpsw
 25412 000033E9 7505                    	jnz	short FTYPE_BAT
 25413                                  	;mov	ax,4
 25414 000033EB B80400                  	mov	ax,SEARCH_EXE	; success!
 25415 000033EE EB12                    	jmp	short FTYPE_EXIT
 25416                                  
 25417                                  	; Compare .BAT
 25418                                  FTYPE_BAT:			; still looking... now for '.bat'
 25419 000033F0 89C7                    	mov	di,ax
 25420 000033F2 BE[2D84]                	mov	si,batext ; ".BAT"
 25421 000033F5 A7                      	cmpsw
 25422 000033F6 7508                    	jnz	short FTYPE_FAIL
 25423 000033F8 A7                      	cmpsw
 25424 000033F9 7505                    	jnz	short FTYPE_FAIL
 25425                                  	;mov	ax,2
 25426 000033FB B80200                  	mov	ax,SEARCH_BAT	; success!
 25427 000033FE EB02                    	jmp	short FTYPE_EXIT
 25428                                  
 25429                                  FTYPE_FAIL:			; file doesn't match what we need
 25430                                  	;mov	ax,ANULL ; 0
 25431                                  	; 18/03/2023
 25432 00003400 29C0                    	sub	ax,ax  ; ax = 0
 25433                                  FTYPE_EXIT:
 25434                                  	; 18/03/2023
 25435                                  	; MSDOS 6.0
 25436 00003402 803E[668D]01            	cmp	byte [ext_entered],1
 25437                                  				;AN005; was an extension entered?
 25438 00003407 740A                    	jz	short FTYPE_DONE
 25439                                  				;AN005; no - exit
 25440                                  	;cmp	ax,ANULL	;AN005; was any match found
 25441 00003409 21C0                    	and	ax,ax  ; ax = 0 ?
 25442 0000340B 7406                    	jz	short FTYPE_DONE
 25443                                  				;AN005; no - exit
 25444 0000340D A2[668D]                	mov	[ext_entered],al
 25445                                  				;AN005; save the match type found
 25446 00003410 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25447                                  FTYPE_DONE:
 25448 00003413 5E                      	pop	si
 25449 00003414 5F                      	pop	di
 25450 00003415 C3                      	retn
 25451                                  
 25452                                  ; =============== S U B	R O U T	I N E =======================================
 25453                                  
 25454                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25455                                  ; replacing any extension with wildcards.
 25456                                  ;
 25457                                  ; ENTRY:
 25458                                  ;	BX	--	maximum length of destination buffer
 25459                                  ;	DS:SI	--	address of destination buffer
 25460                                  ;	argv[0] --	command name to be stripped
 25461                                  ; EXIT:
 25462                                  ;	CF	--	set if failure, clear if successful
 25463                                  ; NOTE(S):
 25464                                  
 25465                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25466                                  
 25467                                  STRIP:
 25468 00003416 50                      	push	ax
 25469 00003417 53                      	push	bx
 25470 00003418 51                      	push	cx
 25471 00003419 52                      	push	dx
 25472 0000341A 57                      	push	di
 25473 0000341B 56                      	push	si
 25474                                  	;pushf	; ** ; 18/03/2023
 25475                                  		
 25476                                  	; 05/05/2023
 25477                                  	; MSDOS 6.0
 25478 0000341C C606[668D]01            	mov	byte [ext_entered],1
 25479                                  				;AN005; assume no extension on file name
 25480                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25481                                  	;mov	dx,[ARG_ARGV]
 25482                                  	;mov	dx,ds:arg.argv[0].argpointer
 25483                                  				; save pointer to beginning of argstring
 25484                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25485 00003421 8B16[B08D]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25486                                  	;mov	di,ds:arg.argv[0].argstartel
 25487                                  				; beginning of last pathname element
 25488                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25489 00003425 8B3E[B38D]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25490 00003429 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25491 0000342C 743D                    	je	short STRIP_ERROR
 25492 0000342E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25493                                  	;add	cx,ds:arg.argv[0].arglen
 25494                                  	;add	cx,[ARGV0_ARGLEN]
 25495 00003430 030E[B58D]              	add	cx,[ARG+ARGV_ELE.arglen]
 25496 00003434 29F9                    	sub	cx,di		; and then find length of last element
 25497 00003436 41                      	inc	cx		; include null as well
 25498 00003437 B02E                    	mov	al,'.'
 25499                                  	;mov	al,DOT		; let's find the filetype extension
 25500 00003439 FC                      	cld
 25501 0000343A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25502                                  
 25503                                  	; 18/03/2023
 25504                                  	; MSDOS 6.0
 25505 0000343C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25506 0000343E B000                    	mov	al,0 ; 18/03/2023
 25507                                  	;mov	byte [ext_entered],0
 25508 00003440 A2[668D]                	mov	[ext_entered],al
 25509                                  				;AN005; we found an extension
 25510                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25511                                  	;mov	al,0
 25512 00003443 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25513                                  PROCESS_EXT:
 25514                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25515 00003445 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25516 00003447 29D1                    	sub	cx,dx		; number of bytes to be copied
 25517 00003449 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25518 0000344C 39D9                    	cmp	cx,bx
 25519 0000344E 7F1B                    	jg	short STRIP_ERROR
 25520                                  				; if not, we must have a bad pathname
 25521 00003450 89F7                    	mov	di,si		; destination buffer
 25522 00003452 89D6                    	mov	si,dx		; source is beginning of pathname
 25523 00003454 FC                      	cld
 25524 00003455 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25525                                  
 25526                                  	; 18/03/2023
 25527                                  	; MSDOS 6.0
 25528 00003457 803E[668D]01            	cmp	byte [ext_entered],1
 25529                                  				;AN005; if an extension was entered
 25530 0000345C 750A                    	jne	short SKIP_WILDS
 25531                                  				;AN005;    don't set up wildcard ext.
 25532                                  
 25533                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25534 0000345E 4F                      	dec	di		; overwrite null or dot
 25535 0000345F AA                      	stosb			; with a dot
 25536 00003460 B03F                    	mov	al,'?'
 25537                                  	;mov	al,WILDCHAR	; now add wildcards
 25538 00003462 AA                      	stosb
 25539 00003463 AA                      	stosb
 25540 00003464 AA                      	stosb
 25541 00003465 B000                    	mov	al,0
 25542                                  	;mov	al,ANULL	; and a terminating null	
 25543 00003467 AA                      	stosb
 25544                                  SKIP_WILDS:
 25545                                  	;popf	; ** ; 18/03/2023
 25546 00003468 F8                      	clc
 25547 00003469 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25548                                  
 25549                                  STRIP_ERROR:
 25550                                  	;popf	; ** ; 18/03/2023
 25551 0000346B F9                      	stc
 25552                                  STRIP_EXIT:
 25553 0000346C 5E                      	pop	si
 25554 0000346D 5F                      	pop	di
 25555 0000346E 5A                      	pop	dx
 25556 0000346F 59                      	pop	cx
 25557 00003470 5B                      	pop	bx
 25558 00003471 58                      	pop	ax
 25559 00003472 C3                      	retn
 25560                                  
 25561                                  ; =============== S U B	R O U T	I N E =======================================
 25562                                  
 25563                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25564                                  ;
 25565                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25566                                  ; beginning of this area. The caller indicates how much extra space is
 25567                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25568                                  ; an offset into that area, indicating where the caller may preserve its own
 25569                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25570                                  ; ENTRY:
 25571                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25572                                  ; EXIT:
 25573                                  ;   AX	    --	segment of new area.
 25574                                  ;   CF	    --	set if unable to save a copy.
 25575                                  ; NOTE(S):
 25576                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25577                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25578                                  ;	paragraphs.
 25579                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25580                                  ;	as the caller of Save_Args requests.
 25581                                  ;   3)	AX is undefined if CF indicates an error.
 25582                                  
 25583                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25584                                  
 25585                                  SAVE_ARGS:
 25586 00003473 53                      	push	bx
 25587 00003474 51                      	push	cx
 25588 00003475 52                      	push	dx
 25589 00003476 57                      	push	di
 25590 00003477 56                      	push	si
 25591 00003478 55                      	push	bp
 25592                                  	; 01/05/2023
 25593                                  	; 26/04/2023
 25594                                  	;pushf ; **
 25595                                  	;add	bx,1363		; space for arg structure, round up
 25596 00003479 81C35304                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25597                                  			; 1092+15 ; 31/07/2024
 25598 0000347D B104                    	mov	cl,4		; to paragraph size and convert
 25599 0000347F D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25600 00003481 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25601 00003484 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25602                                  			; BX = number of 16-byte paragraphs desired
 25603 00003486 7241                    	jc	short SAVE_ERROR ; ***
 25604 00003488 89C5                    	mov	bp,ax		; save segment id
 25605 0000348A 06                      	push	es		; save TRANGROUP address
 25606 0000348B 8EC0                    	mov	es,ax		; switch to new memory segment
 25607                                  	; assume es:nothing
 25608                                  	;mov	cx,1348		; get back structure size
 25609 0000348D B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092 ; 31/07/2024
 25610 00003490 31FF                    	xor	di,di		; destination is new memory area
 25611                                  	;mov	si,ARG_ARGV
 25612 00003492 BE[B08D]                	mov	si,ARG		; source is arg structure
 25613                                  	; 09/08/2024
 25614 00003495 56                      	push	si
 25615 00003496 F3A4                    	rep	movsb		; move that sucker!
 25616                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25617                                  	;mov	cx,[ARG_ARGVCNT]
 25618 00003498 8B0E[7090]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25619 0000349C 31C0                    	xor	ax,ax		; base address for argv_calc
 25620                                  
 25621                                  ;	Bugbug:	What did they mean by this?
 25622                                  ;	Note that the replacement line produces exactly the same code.
 25623                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25624                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25625                                  
 25626                                  	;;mov	si,ARG_ARGV
 25627                                  	;mov	si,ARG
 25628                                  	; 09/08/2024
 25629 0000349E 5E                      	pop	si
 25630                                  SAVE_PTR_LOOP:
 25631 0000349F 49                      	dec	cx		; exhausted all args?
 25632 000034A0 7C24                    	jl	short SAVE_DONE
 25633 000034A2 89CB                    	mov	bx,cx		; get arg index and
 25634 000034A4 E8A5FC                  	call	argv_calc	; convert to a pointer
 25635                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25636                                  	;mov	dx,[ARG_ARGV+bx]
 25637 000034A7 8B97[B08D]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25638 000034AB 29F2                    	sub	dx,si		; adjust argpointer
 25639                                  	;mov	es:argv[BX].argpointer,dx
 25640                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25641 000034AD 268917                  	mov	[es:bx],dx
 25642                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25643                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25644 000034B0 8B97[B38D]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25645 000034B4 29F2                    	sub	dx,si		; and adjust argstartel
 25646                                  	;mov	es:argv[bx].argstartel,dx
 25647                                  	;mov	[es:bx+3],dx
 25648 000034B6 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25649                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25650                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25651 000034BA 8B97[B98D]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25652 000034BE 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25653                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25654                                  	;mov	[es:bx+9],dx
 25655 000034C0 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25656 000034C4 EBD9                    	jmp	short SAVE_PTR_LOOP
 25657                                  SAVE_DONE:
 25658 000034C6 07                      	pop	es		; back we go to TRANGROUP
 25659                                  	; assume es:nothing
 25660 000034C7 89E8                    	mov	ax,bp		; restore segment id
 25661                                  	; 26/04/2023
 25662                                  	; cf = 0 ; *
 25663                                  	;jmp	short SAVE_OK
 25664                                  
 25665                                  	; 26/04/2023
 25666                                  ;SAVE_ERROR:
 25667                                  ;	; 26/04/2023
 25668                                  ;	;popf ; **
 25669                                  ;	stc
 25670                                  ;	jmp	short SAVE_EXIT
 25671                                  
 25672                                  SAVE_OK:
 25673                                  	; 26/04/2023
 25674                                  	;popf ; **
 25675                                  	; 26/04/2023
 25676                                  	; cf = 0 ; *
 25677                                  	;clc
 25678                                  SAVE_EXIT:
 25679                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25680 000034C9 5D                      	pop	bp
 25681 000034CA 5E                      	pop	si
 25682 000034CB 5F                      	pop	di
 25683 000034CC 5A                      	pop	dx
 25684 000034CD 59                      	pop	cx
 25685 000034CE 5B                      	pop	bx
 25686                                  answ_no:	; 26/04/2023
 25687 000034CF C3                      	retn
 25688                                  
 25689                                  ;============================================================================
 25690                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25691                                  ;============================================================================
 25692                                  ; 02/10/2018 - Retro DOS v3.0
 25693                                  
 25694                                  ; Title	COMMAND Language midifiable Code Transient
 25695                                  
 25696                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25697                                  
 25698                                  ; =============== S U B	R O U T	I N E =======================================
 25699                                  
 25700                                  ; ****************************************************************
 25701                                  ; *
 25702                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25703                                  ; *
 25704                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25705                                  ; *		 user for Y/N if necessary. If an error occurs,
 25706                                  ; *		 set up an error message and go to CERROR.
 25707                                  ; *
 25708                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25709                                  ; *		 Current directory set to entered directory
 25710                                  ; *
 25711                                  ; * OUTPUT:	 none
 25712                                  ; *
 25713                                  ; ****************************************************************
 25714                                  ;
 25715                                  ; ARE YOU SURE prompt when deleting *.*
 25716                                  
 25717                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25718                                  
 25719                                  notest2:
 25720 000034D0 B90B00                  	mov	cx,11
 25721 000034D3 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25722                                  ambspec:
 25723 000034D6 AC                      	lodsb
 25724 000034D7 3C3F                    	cmp	al,'?'
 25725 000034D9 7502                    	jne	short allfil
 25726 000034DB E2F9                    	loop	ambspec
 25727                                  allfil:
 25728                                  	; 19/03/2023
 25729                                  	;cmp	cx,0
 25730 000034DD 09C9                    	or	cx,cx
 25731 000034DF 752E                    	jnz	short noprmpt
 25732                                  askagn:	
 25733 000034E1 BA[DB7F]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25734 000034E4 E8EA18                  	call	std_printf
 25735 000034E7 BE8000                  	mov	si,80h
 25736 000034EA 89F2                    	mov	dx,si
 25737 000034EC C7047800                	mov	word [si],120	; zero length
 25738                                  	;mov	ax,0C0Ah
 25739 000034F0 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25740 000034F3 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25741                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25742 000034F5 AD                      	lodsw
 25743 000034F6 08E4                    	or	ah,ah
 25744 000034F8 74E7                    	jz	short askagn
 25745 000034FA E8DFF0                  	call	scanoff
 25746                                  	; 19/03/2023
 25747                                  	; MSDOS 6.0
 25748 000034FD E80C02                  	call	char_in_xlat	; Convert to upper case
 25749                                  	;retc			; return if function not supported
 25750                                  	; 19/03/2023
 25751                                  	;jnc	short check_yn
 25752                                  ;answ_no:
 25753                                  	;retn
 25754 00003500 72CD                    	jc	short answ_no
 25755                                  
 25756                                  	; 19/03/2023
 25757                                  	; AL = 0 if it was (country depended) NO character
 25758                                  	; AL = 1 if it was (country depenced) YES character
 25759                                  
 25760                                  	; MSDOS 3.3
 25761                                  	;call	UPCONV
 25762                                  
 25763                                  	; 19/03/2023	
 25764                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25765                                  	;cmp	al,[CAPITAL_N]
 25766                                  	;jne	short CHECK_Y
 25767                                  	;retn
 25768                                  ;CHECK_Y:
 25769                                  	;cmp	al,[CAPITAL_Y]
 25770                                  	;pushf
 25771                                  	;call	CRLF2
 25772                                  	;popf
 25773                                  	;jne	short ASKAGN
 25774                                  
 25775                                  check_yn:
 25776                                  	; 19/03/2023
 25777                                  	;cmp	al,0	; NO character
 25778 00003502 08C0                    	or	al,al
 25779 00003504 74C9                    	jz	short answ_no
 25780                                  	;cmp	al,1	 ;YES character
 25781 00003506 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25782 00003508 9C                      	pushf
 25783 00003509 E8C3F0                  	call	CRLF2
 25784 0000350C 9D                      	popf
 25785 0000350D 75D2                    	jnz	short askagn
 25786                                  noprmpt:
 25787 0000350F B413                    	mov	ah,FCB_Delete ; 13h
 25788 00003511 BA5C00                  	mov	dx,FCB ; 5Ch
 25789 00003514 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25790                                  			; DS:DX	-> FCB with filename field filled with
 25791                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25792                                  			; Return: AL = 00h file	found,FFh file	not found
 25793 00003516 FEC0                    	inc	al
 25794 00003518 7403                    	jz	short eraerr
 25795                                  	; 26/04/2023
 25796                                  	;call	RestUDir
 25797                                  ;answ_no:
 25798                                  	;retn
 25799 0000351A E96FEF                  	jmp	RestUDir ; 26/04/2023
 25800                                  
 25801                                  	; 19/03/2023
 25802                                  	; MSDOS 6.0
 25803                                  eraerr:
 25804                                  	;invoke	set_ext_error_msg
 25805                                  				;AN022; set up the extended error
 25806 0000351D E8C0E7                  	call	Set_Ext_Error_Msg
 25807 00003520 52                      	push	dx		;AN022; save message
 25808                                  	;invoke	RESTUDIR
 25809 00003521 E868EF                  	call	RestUDir
 25810 00003524 5A                      	pop	dx		;AN022; restore message
 25811                                  	
 25812 00003525 833E[FC7E]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25813                                  				;AN022; convert no more files to
 25814 0000352A 7506                    	jne	short cerrorj2	;AN022;  file not found
 25815 0000352C C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25816                                  				;AN000; get message number in control block
 25817                                  cerrorj2:
 25818 00003532 E91BF4                  	jmp	cerror
 25819                                  	
 25820                                  	; 19/03/2023
 25821                                  	; MSDOS 3.3
 25822                                  ;ERAERR:	
 25823                                  	;mov	ah,Set_DMA ; 1Ah
 25824                                  	;mov	dx,FCB ; 5Ch
 25825                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25826                                  	;			; DS:DX	-> disk	transfer buffer
 25827                                  	;mov	ah,Dir_Search_First ; 11h
 25828                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25829                                  	;			; DS:DX	-> FCB
 25830                                  	;push	ax
 25831                                  	;call	RESTUDIR
 25832                                  	;pop	ax
 25833                                  	;mov	dx,FNOTFOUNDPTR
 25834                                  	;inc	al
 25835                                  	;jz	short CERRORJ
 25836                                  	;mov	dx,ACCDENPTR
 25837                                  	;jmp	CERROR
 25838                                  
 25839                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25840                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25841                                  
 25842                                  ; ****************************************************************
 25843                                  ; *
 25844                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25845                                  ; *
 25846                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25847                                  ; *		 user for Y/N where necessary. If an error occurs
 25848                                  ; *		 set up and error message and transfer control
 25849                                  ; *		 to CERROR.
 25850                                  ; *
 25851                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25852                                  ; *		 Current directory set to entered directory
 25853                                  ; *
 25854                                  ; * OUTPUT:	 none
 25855                                  ; *
 25856                                  ; ****************************************************************
 25857                                  
 25858                                  	; 19/03/2023
 25859                                  slashp_erase:				;AN000; entry point
 25860                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25861 00003535 E812E9                  	call	build_dir_string
 25862                                  
 25863 00003538 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25864                                  	;mov	dx,offset trangroup:destdir
 25865 0000353A BA[678B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25866 0000353D CD21                    	int	21h			;AN000;
 25867                                  
 25868                                  	;mov	ah,11h
 25869 0000353F B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25870 00003541 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25871 00003544 CD21                    	int	21h			;AN000;
 25872 00003546 FEC0                    	inc	al			;AN000; did an error occur
 25873                                  	;jz	short eraerr		;AN022; go to error exit
 25874                                  	; 26/04/2023
 25875 00003548 7502                    	jnz	short delete_prompt_loop
 25876                                  
 25877                                  	; 26/04/2023
 25878                                  stop_del:
 25879 0000354A EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25880                                  
 25881                                  delete_prompt_loop:			;AN000;
 25882                                  	;mov	si,offset trangroup:destdir+1
 25883 0000354C BE[688B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25884                                  	;mov	di,offset trangroup:dest
 25885 0000354F BF[378B]                	mov	di,DEST			;AN000; set up dest as target
 25886 00003552 A0[AA8A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25887 00003555 AA                      	stosb				;AN000;   of DEST
 25888                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25889 00003556 E8A2F0                  	call	FCB_TO_ASCZ
 25890                                  
 25891                                  slashp_askagn:				;AN000;
 25892 00003559 E873F0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25893                                  	;mov	dx,offset trangroup:bwdbuf
 25894 0000355C BA[AA8B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25895 0000355F 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25896 00003561 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25897                                  					;AN000; see if only D:\,0
 25898 00003565 7504                    	jnz	short not_del_root	;AN000; no continue
 25899 00003567 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25900                                  					;AN000; yes, get rid of \ ;
 25901                                  not_del_root:				;AN000;
 25902 0000356B 8916[118C]              	mov	[string_ptr_2],dx 	;AN000;
 25903                                  	;mov	dx,offset trangroup:string_buf_ptr
 25904 0000356F BA[C380]                	mov	dx,string_buf_ptr	;AN000;
 25905                                  	;invoke	std_printf		;AN000;
 25906 00003572 E85C18                  	call	std_printf
 25907                                  	;mov	dx,offset trangroup:dest
 25908 00003575 BA[378B]                	mov	dx,DEST			;AN000; print out file name string
 25909 00003578 8916[118C]              	mov	[string_ptr_2],dx 	;AN000;
 25910                                  	;mov	dx,offset trangroup:string_buf_ptr
 25911 0000357C BA[C380]                	mov	dx,string_buf_ptr	;AN000;
 25912                                  	;invoke	std_printf		;AN000;
 25913 0000357F E84F18                  	call	std_printf
 25914                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25915 00003582 BA[D87F]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25916                                  	;invoke	std_printf		;AN000;
 25917 00003585 E84918                  	call	std_printf
 25918                                  
 25919                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25920                                  ;;M029	mov	dx,si			;AN000;
 25921                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25922                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25923                                  ;;M029	int	21h			;AN000; get input from the user
 25924                                  ;;M029	lodsw				;AN000;
 25925                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25926                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25927                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25928                                  
 25929                                  ;	Get a single character input.
 25930                                  
 25931                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25932                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25933 00003588 B8010C                  	mov	ax,0C01h
 25934 0000358B CD21                    	int	21h			;M029
 25935                                  
 25936 0000358D E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25937                                  	;retc				;AN000; return if function not supported
 25938                                  	; 19/03/2023
 25939 00003590 7301                    	jnc	short slashp_check_yn
 25940                                  slashp_ans_no:
 25941 00003592 C3                      	retn
 25942                                  
 25943                                  slashp_check_yn:
 25944                                  	; 19/03/2023
 25945                                  	; AL = 0 if it was (country depended) NO character
 25946                                  	; AL = 1 if it was (country depenced) YES character
 25947                                  
 25948                                  	;cmp	al,capital_n		;AN000; was it no?
 25949                                  	;cmp	al,0
 25950 00003593 20C0                    	and	al,al ; 0
 25951 00003595 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25952                                  	;cmp	al,capital_y		;AN000; was it yes?
 25953                                  	;cmp	al,1
 25954 00003597 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25955                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25956                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25957                                  	; 19/03/2023
 25958 00003599 75BE                    	jnz	short slashp_askagn
 25959                                  
 25960                                  delete_this_file:			;AN000;
 25961 0000359B B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25962                                  	;mov	dx,offset trangroup:destdir
 25963 0000359D BA[678B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25964 000035A0 CD21                    	int	21h			;AN000;
 25965 000035A2 FEC0                    	inc	al			;AN000; did an error occur?
 25966 000035A4 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25967                                  ;
 25968                                  ;M041; Begin changes
 25969                                  ; We got an error deleting the file. If this is access denied, we can go on
 25970                                  ;to the next file after printing an error message.
 25971                                  ;
 25972                                  	;invoke	Get_ext_error_number	;see what error we got
 25973 000035A6 E847E7                  	call	get_ext_error_number
 25974 000035A9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25975                                  					;is it access denied?
 25976 000035AC 759C                    	jne	short stop_del		;no, some other error
 25977                                  	;invoke	CrLf2			;print a CR-LF
 25978 000035AE E81EF0                  	call	CRLF2
 25979                                  	;invoke set_ext_error_msg	;error message
 25980 000035B1 E82CE7                  	call	Set_Ext_Error_Msg
 25981                                  	;invoke	std_eprintf		;"Access denied"
 25982 000035B4 E81218                  	call	std_eprintf
 25983                                  	; 26/04/2023
 25984                                  	;jmp	short next_del_file	;try next file
 25985                                  	; 26/04/2023
 25986                                  ;stop_del:
 25987                                  ;;
 25988                                  ;;M041; End changes
 25989                                  ;;
 25990                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 25991                                  
 25992                                  next_del_file:				;AN000;
 25993                                  ;
 25994                                  ; M050 - begin
 25995                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 25996                                  ;       with /protect+ and /light+ makes it intercept all
 25997                                  ;       deletes. This hook does not save and restore the DTA correctly.
 25998                                  ;       They save the DWORD in a WORD by mistake! They save both the
 25999                                  ;       segment and the offset in the SAME variable (WORD)!!!
 26000                                  ;
 26001 000035B7 B41A                    	mov	ah,Set_DMA ; 1Ah
 26002                                  	;mov	dx,offset trangroup:destdir
 26003 000035B9 BA[678B]                	mov	dx,DESTDIR
 26004 000035BC CD21                    	int	21h
 26005                                  ;
 26006                                  ; M050 - end
 26007                                  
 26008 000035BE B412                    	mov	ah,Dir_Search_Next ; 12h
 26009                                  					;AN000; search for another file
 26010 000035C0 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26011 000035C3 CD21                    	int	21h			;AN000;
 26012 000035C5 FEC0                    	inc	al			;AN000; was a file found?
 26013                                  	;jz	short slash_p_exit	;AN000; no - exit
 26014                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26015                                  	; 26/04/2023
 26016 000035C7 7583                    	jnz	short delete_prompt_loop
 26017                                  
 26018                                  slash_p_exit:
 26019                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26020 000035C9 E824E7                  	call	get_ext_error_number
 26021 000035CC 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26022 000035CF 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26023 000035D1 E95FE4                  	jmp	extend_setup		;AN022; go issue error message
 26024                                  
 26025                                  good_erase_exit:
 26026                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26027 000035D4 E8B5EE                  	call	RestUDir
 26028                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26029                                  	;retn				;AN000; exit
 26030                                  	; 19/03/2023
 26031 000035D7 E9F5EF                  	jmp	CRLF2
 26032                                  
 26033                                  ; =============== S U B	R O U T	I N E =======================================
 26034                                  
 26035                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26036                                  
 26037                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26038                                  _ECHO:
 26039 000035DA E89900                  	call	ON_OFF
 26040 000035DD 7212                    	jb	short DOEMES
 26041 000035DF 8E1E[A58A]              	mov	ds,[RESSEG]
 26042 000035E3 7506                    	jnz	short ECH_OFF
 26043 000035E5 800E[8801]01            	or	byte [EchoFlag],1
 26044 000035EA C3                      	retn
 26045                                  
 26046                                  ECH_OFF:
 26047 000035EB 8026[8801]FE            	and	byte [EchoFlag],0FEh
 26048 000035F0 C3                      	retn
 26049                                  
 26050                                  	; 19/03/2023
 26051                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26052                                  ;CERRORJ:
 26053                                  	;jmp	cerror
 26054                                  
 26055                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26056                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26057                                  
 26058                                  DOEMES:
 26059                                  	; 19/03/2023
 26060                                  	; MSDOS 6.0
 26061                                  	;cmp	cl,0		;AC000; was anything on the line?
 26062 000035F1 20C9                    	and	cl,cl
 26063 000035F3 7409                    	jz	short PECHO	; just display current state.
 26064 000035F5 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26065 000035F8 E82DF0                  	call	CRPRINT
 26066 000035FB E9D1EF                  	jmp	CRLF2
 26067                                  
 26068                                  	; 19/03/2023
 26069                                  	; MSDOS 3.3
 26070                                  	;call	MOVE_TO_FIRST_ARG
 26071                                  	;jz	short PECHO
 26072                                  	;mov	dx,82h
 26073                                  	;call	CRPRINT
 26074                                  	;jmp	CRLF2
 26075                                  
 26076                                  PECHO:
 26077                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26078 000035FE 8E1E[A58A]              	mov	ds,[RESSEG]
 26079 00003602 8A1E[8801]              	mov	bl,[EchoFlag]
 26080 00003606 0E                      	push	cs
 26081 00003607 1F                      	pop	ds
 26082 00003608 80E301                  	and	bl,1
 26083 0000360B BA[7F80]                	mov	dx,EchoMes_Ptr
 26084 0000360E EB24                    	jmp	short PYN
 26085                                  
 26086                                  ; ---------------------------------------------------------------------------
 26087                                  
 26088                                  	; 19/03/2023
 26089                                  	; MSDOS 3.3
 26090                                  CERRORJ:
 26091 00003610 E93DF3                  	jmp	cerror
 26092                                  
 26093                                  ; =============== S U B	R O U T	I N E =======================================
 26094                                  
 26095                                  	; 19/03/2023
 26096                                  	; MSDOS 3.3
 26097                                  ;MOVE_TO_FIRST_ARG:
 26098                                  	;mov	si,81h
 26099                                  	;call	SCANOFF
 26100                                  	;cmp	al,0Dh
 26101                                  	;retn
 26102                                  
 26103                                  ; =============== S U B	R O U T	I N E =======================================
 26104                                  
 26105                                  CNTRLC:
 26106 00003613 E86000                  	call	ON_OFF
 26107 00003616 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26108 00003619 720C                    	jc	short PCNTRLC
 26109 0000361B 7505                    	jnz	short CNTRLC_OFF
 26110 0000361D B201                    	mov	dl,1
 26111 0000361F CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26112                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26113                                  			; DL = 00h for OFF or 01h for ON
 26114 00003621 C3                      	retn
 26115                                  
 26116                                  ; ---------------------------------------------------------------------------
 26117                                  
 26118                                  CNTRLC_OFF:
 26119 00003622 30D2                    	xor	dl,dl
 26120 00003624 CD21                    	int	21h		; Turn off ^C check
 26121 00003626 C3                      	retn
 26122                                  
 26123                                  ; ---------------------------------------------------------------------------
 26124                                  
 26125                                  PCNTRLC:
 26126                                  	; 19/03/2023
 26127                                  	; MSDOS 6.0
 26128                                  	;cmp	cl,0		;AC000; rest of line blank?
 26129 00003627 08C9                    	or	cl,cl
 26130 00003629 75E5                    	jnz	short CERRORJ 	; no, oops!
 26131                                  
 26132                                  	; 19/03/2023
 26133                                  	; MSDOS 3.3
 26134                                  	;call	MOVE_TO_FIRST_ARG
 26135                                  	;jnz	short CERRORJ
 26136                                  ;pccont:
 26137                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26138 0000362B 30C0                    	xor	al,al
 26139 0000362D CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26140 0000362F 88D3                    	mov	bl,dl
 26141 00003631 BA[6380]                	mov	dx,CtrlcMes_Ptr
 26142                                  
 26143                                  ; ---------------------------------------------------------------------------
 26144                                  
 26145                                  PYN:	; write "ON" or "OFF" state 
 26146                                  
 26147                                  	; 26/04/2023
 26148                                  	; 19/03/2023
 26149                                  	; MSDOS 3.3
 26150                                  	;call	STD_PRINTF
 26151                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26152                                  	;or	bl,bl
 26153                                  	;jnz	short PRINTVAL
 26154                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26155                                  	
 26156                                  	; 26/04/2023
 26157                                  	; 19/03/2023
 26158                                  	; MSDOS 6.0
 26159 00003634 BE[9080]                	mov	si,ONMES_PTR
 26160 00003637 08DB                    	or	bl,bl
 26161 00003639 7503                    	jnz	short PRINTVAL
 26162 0000363B BE[8D80]                	mov	si,OFFMES_PTR
 26163                                  PRINTVAL:
 26164                                  	; 19/03/2023
 26165                                  	; MSDOS 3.3
 26166                                  	;jmp	STD_PRINTF
 26167                                  
 26168                                  	; 19/03/2023
 26169                                  	; MSDOS 6.0
 26170 0000363E 52                      	push	dx		;AN000; save offset of message block
 26171 0000363F 89D3                    	mov	bx,dx		;AN000; save offset value
 26172 00003641 AD                      	lodsw			;AN000; get message number of on or off
 26173 00003642 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26174                                  				;AN000; this is a utility message
 26175 00003644 E86D18                  	call	TSYSGETMSG	;AN000; get the address of the message
 26176                                  	;add	bx,5
 26177 00003647 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26178                                  	
 26179 0000364A 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26180 0000364C 5A                      	pop	dx		;AN000; get message back
 26181 0000364D E88117                  	call	std_printf	;AC000; go print message
 26182 00003650 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26183 00003654 C3                      	retn			;AN000; exit
 26184                                  
 26185                                  ; =============== S U B	R O U T	I N E =======================================
 26186                                  
 26187                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26188                                  VERIFY:
 26189 00003655 E81E00                  	call	ON_OFF
 26190 00003658 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26191 0000365B 720A                    	jc	short PVERIFY
 26192 0000365D 7503                    	jnz	short VER_OFF
 26193 0000365F CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26194                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26195 00003661 C3                      	retn
 26196                                  
 26197                                  ; ---------------------------------------------------------------------------
 26198                                  
 26199                                  VER_OFF:
 26200 00003662 FEC8                    	dec	al
 26201 00003664 CD21                    	int	21h		; Turn off verify after write
 26202 00003666 C3                      	retn
 26203                                  
 26204                                  ; ---------------------------------------------------------------------------
 26205                                  
 26206                                  PVERIFY:
 26207                                  	; 19/03/2023
 26208                                  	; MSDOS 6.0
 26209                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26210 00003667 20C9                    	and	cl,cl
 26211 00003669 75A5                    	jnz	short CERRORJ 	; nope...
 26212                                  
 26213                                  	 ;19/03/2023
 26214                                  	; MSDOS 3.3
 26215                                  	;call	MOVE_TO_FIRST_ARG
 26216                                  	;jnz	short CERRORJ
 26217                                  
 26218 0000366B B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26219 0000366D CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26220                                  				; Return: AL = 00h if flag OFF
 26221                                  				; AL = 01h if flag ON
 26222 0000366F 88C3                    	mov	bl,al
 26223 00003671 BA[7180]                	mov	dx,VeriMes_Ptr
 26224 00003674 EBBE                    	jmp	short PYN
 26225                                  
 26226                                  ; =============== S U B	R O U T	I N E =======================================
 26227                                  
 26228                                  ; ****************************************************************
 26229                                  ; *
 26230                                  ; * ROUTINE:	 ON_OFF
 26231                                  ; *
 26232                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26233                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26234                                  ; *		 routines.
 26235                                  ; *
 26236                                  ; * INPUT:	 command line at offset 81H
 26237                                  ; *		 PARSE_BREAK control block
 26238                                  ; *
 26239                                  ; * OUTPUT:	 If carry is clear
 26240                                  ; *		    If ON is found
 26241                                  ; *		       Zero flag set
 26242                                  ; *		    If OFF is found
 26243                                  ; *		       Zero flag clear
 26244                                  ; *		 If carry set
 26245                                  ; *		    If nothing on command line
 26246                                  ; *		       CL set to zero
 26247                                  ; *		    If error
 26248                                  ; *		       CL contains error value from parse
 26249                                  ; *
 26250                                  ; ****************************************************************
 26251                                  
 26252                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26253                                  ON_OFF:
 26254 00003676 BE8100                  	mov	si,81h
 26255                                  
 26256                                  	; 19/03/2023
 26257                                  	; MSDOS 3.3
 26258                                  	;call	SCANOFF		; scan off leading blanks & equal
 26259                                  	;cmp	al,0Dh		; are we at end of line?
 26260                                  	;je	short BAD_ONF	; yes, return error
 26261                                  	;lodsw
 26262                                  	;or	ax,2020h	; convert to lowercase
 26263                                  	;cmp	ax,6E6Fh ;'on'
 26264                                  	;je	short ON_CHECK
 26265                                  	;cmp	ax,666Fh ;'of'
 26266                                  	;jne	short BAD_ONF
 26267                                  	;lodsb
 26268                                  	;or	al,20h		; convert to lowercase		
 26269                                  	;cmp	al,66h	 ; 'f'
 26270                                  	;jne	short BAD_ONF	
 26271                                  	;or	al,66h ; or al,'f'
 26272                                  	;jmp	short OFF_CHECK
 26273                                  ;ON_CHECK:
 26274                                  	;xor	al,al
 26275                                  ;OFF_CHECK:
 26276                                  	;lahf
 26277                                  	;mov	bx,ax
 26278                                  	;call	SCANOFF		; scan off leading blanks & equal
 26279                                  	;cmp	al,0Dh		; are we at end of line?	
 26280                                  	;jne	short BAD_ONF	; no, return error
 26281                                  	;mov	ax,bx
 26282                                  	;sahf
 26283                                  	;clc
 26284                                  	;retn
 26285                                  
 26286                                  	; 19/03/2023
 26287                                  	; MSDOS 6.0
 26288                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26289 00003679 AC                      	lodsb			;AN032; get a char
 26290                                  	;cmp	al,blank	;AN032; if whitespace
 26291 0000367A 3C20                    	cmp	al,20h
 26292 0000367C 74FB                    	je	short scan_on_off
 26293                                  				;AN032;    keep scanning
 26294 0000367E 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26295                                  	;cmp	al,09h
 26296 00003680 74F7                    	je	short scan_on_off
 26297                                  				;AN032;    keep scanning
 26298                                  	;cmp	al,equal_chr	;AN032; if equal char
 26299 00003682 3C3D                    	cmp	al,'=' ; 3Dh
 26300 00003684 7401                    	je	short parse_on_off
 26301                                  				;AN032;    start parsing
 26302 00003686 4E                      	dec	si		;AN032; if none of above - back up
 26303                                  
 26304                                  parse_on_off:			;AN032;    and start parsing
 26305 00003687 BF[6F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26306 0000368A 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26307 0000368C 31D2                    	xor	dx,dx		;AN000;
 26308 0000368E E88A0C                  	call	cmd_parse	;AC000; call parser
 26309                                  	;cmp	ax,-1 ; 0FFFFh
 26310 00003691 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26311 00003694 742E                    	je	short BADONF	;AC000; yes, return error
 26312                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26313                                  	;cmp	ax,0
 26314 00003696 21C0                    	and	ax,ax ; ax = 0 ?
 26315 00003698 7404                    	jz	short on_off_there
 26316                                  				;AN000; no - continue
 26317 0000369A 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26318 0000369C EB26                    	jmp	short BADONF	;AN000; return error
 26319                                  
 26320                                  on_off_there:
 26321 0000369E 803E[5095]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26322                                  				;AN014; was a valid positional present?
 26323 000036A3 7505                    	jnz	short good_on_off
 26324                                  				;AN014; yes - continue
 26325 000036A5 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26326                                  	;mov	cx,10 ; 0Ah
 26327 000036A8 EB1A                    	jmp	short BADONF	;AN014; return error
 26328                                  
 26329                                  good_on_off:				;AN014;
 26330 000036AA 31C0                    	xor	ax,ax		;AC000; set up return code for
 26331 000036AC 0A06[5095]              	or	al,[PARSE1_CODE]
 26332                                  				;AC000;    ON or OFF in AX
 26333 000036B0 9C                      	pushf			;AN000; save flags
 26334 000036B1 BF[6F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26335 000036B4 31D2                    	xor	dx,dx		;AN000;
 26336 000036B6 E8620C                  	call	cmd_parse	;AN000; call parser
 26337 000036B9 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26338                                  	;cmp	ax,-1 ; 0FFFFh
 26339 000036BC 7503                    	jne	short BADONF_flags
 26340                                  				;AN000; NO, return error
 26341 000036BE 9D                      	popf			;AN000; restore flags
 26342 000036BF F8                      	clc			;AC000; no error
 26343                                  	;jmp	short on_off_end
 26344                                  				;AN000; return to caller
 26345                                  	; 26/04/2023
 26346 000036C0 C3                      	retn
 26347                                  
 26348                                  BADONF_flags:
 26349 000036C1 89C1                    	mov	cx,ax
 26350 000036C3 9D                      	popf
 26351                                  
 26352                                  ; ---------------------------------------------------------------------------
 26353                                  
 26354                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26355                                  ; and return the error
 26356                                  
 26357                                  BADONF:
 26358 000036C4 BA[4080]                	mov	dx,bad_on_off_ptr
 26359 000036C7 F9                      	stc
 26360                                  on_off_end:
 26361 000036C8 C3                      	retn
 26362                                  
 26363                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26364                                  %if 0
 26365                                  
 26366                                  ;============================================================================
 26367                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 26368                                  ;============================================================================
 26369                                  ; 02/10/2018 - Retro DOS v3.0
 26370                                  
 26371                                  ; Print volume ID info
 26372                                  
 26373                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 26374                                  
 26375                                  ; ---------------------------------------------------------------------------
 26376                                  
 26377                                  PRINTVOL:
 26378                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 26379                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 26380                                  	add	al,'@'
 26381                                  	cmp	al,'@'
 26382                                  	jnz	short DRVOK
 26383                                  	mov	al,[CURDRV]
 26384                                  	add	al,[CAPITAL_A]
 26385                                  DRVOK:
 26386                                  	mov	[VOL_DRV],al	; get drive letter into argument
 26387                                  	pop	ax		; get return code back
 26388                                  	mov	dx,NOVOL ; "has	no label" 
 26389                                  	or	al,al		; volume label found?
 26390                                  	jnz	short PRINTVOL2	; print no volume message
 26391                                  GOODVOL:
 26392                                  	; MSDOS 3.3
 26393                                  	mov	di,CHARBUF
 26394                                  	mov	dx,di
 26395                                  	mov	si,IS	; "is "
 26396                                  	call	STRCPY
 26397                                  	dec	di
 26398                                  	mov	si,DIRBUF+8
 26399                                  	mov	cx,11
 26400                                  	rep	movsb
 26401                                  	xor	ax,ax
 26402                                  	;xor	al,al  ; MSDOS 6.0
 26403                                  	stosb			; store a zero to terminate the string
 26404                                  PRINTVOL2:
 26405                                  	mov	[VOLNAME_ADDR],dx
 26406                                  	mov	dx,VOLMESPTR
 26407                                  	jmp	PRINTF_CRLF
 26408                                  
 26409                                  	; MSDOS 6.0
 26410                                  ;drvok:
 26411                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 26412                                  ;	pop	ax		;AC000; get return code back
 26413                                  ;	or	al,al		;AC000; volume label found?
 26414                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 26415                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 26416                                  ;				;AC000; set up no volume message
 26417                                  ;	jmp	short print_serial ;AC000; go print it
 26418                                  ;
 26419                                  ;Get_vol_name:
 26420                                  ;	mov	di,offset trangroup:charbuf
 26421                                  ;	mov	dx,di
 26422                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 26423                                  ;	mov	cx,11				;AN000;  3/3/KK
 26424                                  ;	rep	movsb				;AN000;  3/3/KK
 26425                                  ;
 26426                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 26427                                  ;	stosb
 26428                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 26429                                  ;
 26430                                  ;PRINT_SERIAL:
 26431                                  ;
 26432                                  ;; Attempt to get the volume serial number from the disk.  If an error
 26433                                  ;; occurs, do not print volume serial number.
 26434                                  ;
 26435                                  ;	push	dx		;AN000; save message offset
 26436                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 26437                                  ;				;AC036; Get the volume serial info
 26438                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 26439                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 26440                                  ;	int	21h		;AN000; do the call
 26441                                  ;	pop	dx		;AN000; get message offset back
 26442                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26443                                  ;	call	std_printf	;AC000; go print volume message
 26444                                  ;	mov	al,blank	;AN051; Print out a blank
 26445                                  ;	invoke	print_char	;AN051;   before volume message
 26446                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26447                                  ;				;AN000; get serial number message
 26448                                  ;printvol_end:
 26449                                  ;	jmp	std_printf	;AC000; go print and exit
 26450                                  
 26451                                  %endif
 26452                                  
 26453                                  ;============================================================================
 26454                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26455                                  ;============================================================================
 26456                                  ; 02/10/2018 - Retro DOS v3.0
 26457                                  
 26458                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26459                                  
 26460                                  ; =============== S U B	R O U T	I N E =======================================
 26461                                  
 26462                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26463                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26464                                  	
 26465                                  PRINT_DATE:
 26466                                  	; 20/03/2023
 26467                                  	; MSDOS 3.3
 26468                                  	;push	es
 26469                                  	;push	di
 26470                                  	;push	cs
 26471                                  	;pop	es
 26472                                  	;mov	di,ARG_BUF
 26473                                  	;mov	ah,Get_Date ; 2Ah
 26474                                  	;int	21h	; DOS -	GET CURRENT DATE
 26475                                  	;		; Return: DL = day,DH = month,	CX = year
 26476                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26477                                  	;cbw
 26478                                  	;call	GETDATE
 26479                                  	;call	P_DATE
 26480                                  	;xor	al,al
 26481                                  	;stosb
 26482                                  	;mov	dx,ARG_BUF_PTR
 26483                                  	;call	STD_PRINTF
 26484                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26485                                  	;pop	es ; !!??!! 
 26486                                  	;pop	di
 26487                                  	;retn
 26488                                  
 26489                                  	; 20/03/2023
 26490                                  	; MSDOS 6.0
 26491 000036C9 06                      	push	es
 26492 000036CA 57                      	push	di
 26493 000036CB 0E                      	push	cs
 26494 000036CC 07                      	pop	es
 26495 000036CD E81300                  	call	GetDate 		; get date
 26496 000036D0 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26497 000036D2 890E[F780]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26498 000036D6 8916[F980]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26499 000036DA BA[E780]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26500 000036DD E8F116                  	call	std_printf
 26501                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26502                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26503 000036E0 5F                      	pop	di			;AC000; restore di,es
 26504 000036E1 07                      	pop	es			;AC000;
 26505 000036E2 C3                      	retn
 26506                                  
 26507                                  ; ---------------------------------------------------------------------------
 26508                                  
 26509                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26510                                  
 26511                                  ;GETDATE:
 26512                                  	; 21/03/2023
 26513                                  	; MSDOS 3.3
 26514                                  	;mov	si,ax
 26515                                  	;shl	si,1
 26516                                  	;add	si,ax
 26517                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26518                                  	;mov	bx,cx
 26519                                  	;mov	cx,3
 26520                                  	;rep	movsb
 26521                                  	;mov	al,' '
 26522                                  	;stosb
 26523                                  	;retn
 26524                                  
 26525                                  	; 21/03/2023
 26526                                  	; MSDOS 6.0
 26527                                  
 26528                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26529                                  ; for output. Date will be returned in CX,DX.
 26530                                  
 26531                                  GetDate:
 26532 000036E3 BF[F692]                	mov	di,Arg_Buf		;AC000; target for day of week
 26533 000036E6 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26534 000036E8 CD21                    	int	21h			;AC000; Get date in CX:DX
 26535 000036EA 98                      	cbw				;AC000;
 26536 000036EB 51                      	push	cx			;AN000; save date returned in
 26537 000036EC 52                      	push	dx			;AN000;  CX:DX
 26538 000036ED 89C6                    	mov	si,ax
 26539 000036EF D1E6                    	shl	si,1
 26540 000036F1 01C6                    	add	si,ax			; SI=AX*3
 26541 000036F3 89F1                    	mov	cx,si			;AN000; save si
 26542 000036F5 A1[B37F]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26543 000036F8 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26544 000036FA 57                      	push	di			;AN000; save argument buffer
 26545 000036FB E8B617                  	call	TSYSGETMSG		;AN000; get the address of the message
 26546 000036FE 5F                      	pop	di			;AN000; retrieve argument buffer
 26547 000036FF 01CE                    	add	si,cx			;AC000; get day of week
 26548 00003701 B90300                  	mov	cx,3
 26549 00003704 F3A4                      	rep	movsb
 26550 00003706 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26551 00003708 AA                      	stosb
 26552 00003709 5A                      	pop	dx			;AN000; get back date
 26553 0000370A 59                      	pop	cx			;AN000;
 26554 0000370B C3                      	retn
 26555                                  
 26556                                  ; =============== S U B	R O U T	I N E =======================================
 26557                                  
 26558                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26559                                  
 26560                                  	; MSDOS 6.0
 26561                                  
 26562                                  ; This routine determines whether the character in AL is a
 26563                                  ; Yes or No character. On return, if AL=0, the character is
 26564                                  ; No, if AL=1, the character is Yes.
 26565                                  
 26566                                  ;	assume	ds:trangroup
 26567                                  
 26568                                  char_in_xlat:	; proc	near
 26569                                  	; 21/03/2023
 26570 0000370C 88C2                    	mov	dl,al			;AC000; get character into DX
 26571 0000370E 30F6                    	xor	dh,dh			;AC000;
 26572                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26573 00003710 B82365                  	mov	ax,6523h
 26574 00003713 CD21                    	int	21h			;AC000;
 26575 00003715 C3                      	retn
 26576                                  
 26577                                  ;char_in_xlat	endp
 26578                                  
 26579                                  ;============================================================================
 26580                                  ; TENV.ASM, MSDOS 6.0, 1991
 26581                                  ;============================================================================
 26582                                  ; 02/10/2018 - Retro DOS v3.0
 26583                                  
 26584                                  ;	Environment utilities and misc. routines
 26585                                  
 26586                                  ; MSDOS 6.0
 26587                                  ; ****************************************************************
 26588                                  ; *
 26589                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26590                                  ; *
 26591                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26592                                  ; *		 the character in AL from the file upper case table
 26593                                  ; *		 in DOS if character if above  ascii 128, else
 26594                                  ; *		 subtracts 20H if between "a" and "z".
 26595                                  ; *
 26596                                  ; * INPUT:	 AL	      char to be upper cased
 26597                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26598                                  ; *
 26599                                  ; * OUTPUT:	 AL	      upper cased character
 26600                                  ; *
 26601                                  ; ****************************************************************
 26602                                  ;
 26603                                  ;assume	ds:trangroup				;AN000;
 26604                                  ;
 26605                                  ;upconv	proc	near				;AN000;
 26606                                  ;
 26607                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26608                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26609                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26610                                  ;	push	ds				;AN000;
 26611                                  ;	push	bx				;AN000;
 26612                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26613                                  ;assume	ds:resgroup				;AN000;
 26614                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26615                                  ;	add	bx,2				;AN000;  skip over first word
 26616                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26617                                  ;	pop	bx				;AN000;
 26618                                  ;	pop	ds				;AN000;
 26619                                  ;assume	ds:trangroup				;AN000;
 26620                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26621                                  ;
 26622                                  ;oth_fucase:					;AN000;
 26623                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26624                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26625                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26626                                  ;	ja	upconv_end			;AC000;
 26627                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26628                                  ;
 26629                                  ;upconv_end:					;AN000;
 26630                                  ;	ret
 26631                                  ;
 26632                                  ;upconv	endp					;AN000;
 26633                                  
 26634                                  
 26635                                  ; =============== S U B	R O U T	I N E =======================================
 26636                                  
 26637                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26638                                  
 26639                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26640                                  %if 0
 26641                                  
 26642                                  UPCONV:
 26643                                  	cmp	al,80h
 26644                                  	jb	short OTH_UCASE
 26645                                  	sub	al,80h
 26646                                  	push	ds
 26647                                  	push	bx
 26648                                  	mov	ds,[RESSEG]
 26649                                  	lds	bx,[UPPERCASETBL]
 26650                                  	add	bx,2
 26651                                  	xlat
 26652                                  	pop	bx
 26653                                  	pop	ds
 26654                                  	jmp	short UPCONV_RETN
 26655                                  
 26656                                  OTH_UCASE:
 26657                                  	cmp	al,'a'
 26658                                  	jb	short UPCONV_RETN
 26659                                  	cmp	al,'z'
 26660                                  	ja	short UPCONV_RETN
 26661                                  	sub	al,20h
 26662                                  
 26663                                  UPCONV_RETN:
 26664                                  	retn
 26665                                  
 26666                                  %endif
 26667                                  
 26668                                  ;============================================================================
 26669                                  ; COPY.ASM, MSDOS 6.0, 1991
 26670                                  ;============================================================================
 26671                                  ; 01/10/2018 - Retro DOS v3.0
 26672                                  
 26673                                  ;	title	COMMAND COPY routines.
 26674                                  
 26675                                  ;/*
 26676                                  ; *                      Microsoft Confidential
 26677                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26678                                  ; *                      All Rights Reserved.
 26679                                  ; */
 26680                                  
 26681                                  ;***	COPY.ASM
 26682                                  
 26683                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26684                                  
 26685                                  
 26686                                  ;***	MODIFICATION HISTORY
 26687                                  
 26688                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26689                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26690                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26691                                  ;	     to tokens which begin with path characters so that PARSELINE
 26692                                  ;	     will work correctly.
 26693                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26694                                  ;	     individual tokens. That distinction is no longer needed for
 26695                                  ;	     FOR loop processing.
 26696                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26697                                  ;	     1 when Cparse is called from COPY.
 26698                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26699                                  ;	     mod. It now is conditional on flag like previous mod.
 26700                                  ;11/21/83 NP  Added printf
 26701                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26702                                  ;	     be added to a token.
 26703                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26704                                  ;	     NOTE: DestHand is the destination handle. There are two
 26705                                  ;	     special values: -1 meaning destination was never opened and
 26706                                  ;	     0 which means that the destination has been openned and
 26707                                  ;	     closed.
 26708                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26709                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26710                                  ;	     lost on large and multiple file (wildcard) copies.
 26711                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26712                                  ;	     destination are not equal.
 26713                                  ;
 26714                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26715                                  ;	     first source file AND we run out of disk space before
 26716                                  ;	     completing the concatenation, restore the first source
 26717                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26718                                  ;
 26719                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26720                                  ;		instead of compatibility mode. This gives lesser sharing
 26721                                  ;		violations when files are opened for read on a copy.
 26722                                  
 26723                                  ; ---------------------------------------------------------------------------
 26724                                  ;***	COPY CODE
 26725                                  ; ---------------------------------------------------------------------------
 26726                                  
 26727                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26728                                  
 26729                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26730                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26731                                  
 26732                                  COPY:
 26733                                  	; 	Initialize internal variables.
 26734                                  
 26735 00003716 31C0                    	xor	ax,ax		; AX = 0
 26736 00003718 A3[138C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26737 0000371B A3[418D]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26738 0000371E A3[8D8C]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26739 00003721 A2[C28A]                	mov	[CFLAG],al	; 'destination file created' = false
 26740 00003724 A3[C68A]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26741 00003727 A3[BE8A]                	mov	[DestSwitch],ax	; destination switches = none
 26742 0000372A A3[578D]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26743 0000372D A3[2A8C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26744 00003730 A2[C38A]                	mov	[DestClosed],al	; 'destination file closed' = false
 26745 00003733 A2[298C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26746 00003736 A2[8C8C]                	mov	[SrcSiz],al	; length of source pathname = 0
 26747 00003739 A2[2C8C]                	mov	[DestInfo],al	; destination pathname flags = none
 26748 0000373C A2[8F8C]                	mov	[SrcInfo],al	; source pathname flags = none
 26749 0000373F A2[438D]                	mov	[INEXACT],al	; 'inexact copy' = false
 26750 00003742 A2[288C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26751 00003745 A2[8B8C]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26752 00003748 A2[8789]                	mov	[USERDIR1],al	; saved working directory = null
 26753 0000374B A2[448D]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26754 0000374E A2[B68A]                	mov	[RDEOF],al	; 'read end of file' = false
 26755 00003751 A3[E78C]                	mov	[SRCHAND],ax	; source handle = 0
 26756 00003754 A3[4C8D]                	mov	[CPDATE],ax	; copy date = 0
 26757 00003757 A3[4E8D]                	mov	[CPTIME],ax	; copy time = 0
 26758 0000375A A2[E98C]                	mov	[SRCISDEV],al	; 'source is device' = false
 26759                                  	; 23/03/2023
 26760                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26761 0000375D A2[548D]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26762 00003760 A3[508D]                	mov	[OFilePtr_Lo],ax
 26763 00003763 A3[528D]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26764 00003766 A2[488D]                	mov	[TERMREAD],al	; 'terminate read' = false
 26765 00003769 A2[068C]                	mov	[comma],al	; '"+,," found' = false
 26766 0000376C A2[078C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26767 0000376F A2[938D]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26768 00003772 A3[C08A]                	mov	[AllSwitch],ax	; all switches = none
 26769 00003775 A2[B98A]                	mov	[ArgC],al	; source/dest argument count = 0
 26770 00003778 A2[4A8D]                	mov	[PLUS],al	; '"+" in command line' = false
 26771 0000377B A2[458D]                	mov	[BINARY],al	; 'binary copy' = false
 26772 0000377E A2[498D]                	mov	[ASCII],al	; 'ascii copy' = false
 26773 00003781 A3[CD8A]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26774 00003784 A3[468D]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26775 00003787 A2[B88A]                	mov	[Concat],al	; 'concatenating' = false
 26776 0000378A A2[888C]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26777 0000378D A3[898C]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 26778                                  
 26779                                  	;	Initialize buffers with double-nulls.
 26780                                  
 26781 00003790 A3[EA8C]                	mov	[ScanBuf],ax
 26782 00003793 A3[2D8C]                	mov	[DestBuf],ax
 26783 00003796 A3[908C]                	mov	[SrcBuf],ax
 26784 00003799 A3[F08B]                	mov	[SDIRBUF],ax
 26785 0000379C A3[AA8B]                	mov	[DIRBUF],ax
 26786 0000379F A3[678B]                	mov	[DestFcb],ax
 26787                                  
 26788 000037A2 A2[4B8D]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26789                                  		
 26790 000037A5 48                      	dec	ax ; -1		; AX = 0FFFFh
 26791 000037A6 A3[848C]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26792 000037A9 A2[C88A]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26793 000037AC A2[878C]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26794 000037AF A2[288C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26795                                  		
 26796 000037B2 BE8100                  	mov	si,81h		; SI = ptr to command line
 26797                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26798                                  	; 23/03/2023
 26799 000037B5 B32B                    	mov	bl,'+'
 26800 000037B7 FE06[928D]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26801 000037BB C606[158C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26802                                  
 26803                                  	;*	Scan the command line for destination information.
 26804                                  
 26805                                  DESTSCAN:
 26806 000037C0 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26807 000037C2 BF[EA8C]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26808                                  	; 23/03/2023
 26809 000037C5 8936[098C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26810 000037C9 E88A09                  	call	cparse			; parse next object
 26811 000037CC 9C                      	pushf				; save CParse flags
 26812 000037CD FE06[4B8D]              	inc	byte [objcnt]		; count object
 26813 000037D1 F6C780                  	test	bh,80h
 26814 000037D4 7405                    	jz	short NOCOPY		; no "+" delimiter
 26815 000037D6 C606[4A8D]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26816                                  NOCOPY:
 26817 000037DB F6C701                  	test	bh,1
 26818 000037DE 742E                    	jz	short TESTP2		; not a switch
 26819                                  
 26820                                  	;	Found a switch.
 26821                                  
 26822                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26823                                  	; MSDOS 6.0
 26824 000037E0 F7C51000                	test	bp,10h
 26825                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26826 000037E4 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26827 000037E6 F606[C08A]10            	test	byte [AllSwitch],10h
 26828                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26829 000037EB 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26830                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26831                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26832 000037ED 81CD0040                	or	bp,4000h
 26833                                  NOT_SLASHV:
 26834 000037F1 092E[BE8A]              	or	[DestSwitch],bp		; assume destination
 26835 000037F5 092E[C08A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26836                                  
 26837                                  	; 23/03/2023
 26838                                  	; MSDOS 6.0
 26839                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26840 000037F9 F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26841 000037FD 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26842 000037FF 9D                      	popf				;AN018; fix up stack
 26843 00003800 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26844 00003803 E8C0E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26845 00003806 E947F1                  	jmp	cerror			;AC018; exit
 26846                                  NOT_BAD_SWITCH:
 26847 00003809 9D                      	popf				; restore CParse flags
 26848 0000380A 7231                    	jc	short CHECKDONE		; found CR
 26849 0000380C EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26850                                  TESTP2:
 26851 0000380E 9D                      	popf				; restore CParse flags
 26852 0000380F 722C                    	jc	short CHECKDONE		; found CR
 26853 00003811 F6C780                  	test	bh,80h
 26854 00003814 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26855 00003816 FE06[B98A]              	inc	byte [ArgC]		; count independent pathname args
 26856                                  GOTPLUS:
 26857 0000381A 56                      	push	si			; save cmd line ptr
 26858 0000381B A1[578D]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26859 0000381E BE[EA8C]                	mov	si,ScanBuf		; SI = ptr to path string
 26860 00003821 29F0                    	sub	ax,si			; AX = offset of last element
 26861 00003823 BF[2D8C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26862 00003826 01F8                    	add	ax,di			; AX = ptr to last element in
 26863                                  					;  destination path buffer
 26864 00003828 A3[2A8C]                	mov	[DestTail],ax		; save ptr to last element
 26865 0000382B 880E[298C]              	mov	[DestSiz],cl		; save path string length
 26866 0000382F 41                      	inc	cx			; CX = mov length (incl null)
 26867 00003830 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26868 00003832 883E[2C8C]              	mov	[DestInfo],bh		; save CParse info flags
 26869                                  	;mov	word [DestSwitch],0	; clear destination switches
 26870                                  	; 10/08/2024
 26871 00003836 890E[BE8A]              	mov	[DestSwitch],cx ; 0
 26872 0000383A 5E                      	pop	si			; SI = ptr into cmd line again
 26873 0000383B EB83                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26874                                  
 26875                                  CHECKDONE:
 26876                                  	;	We reached the CR. The destination scan is finished.
 26877                                  
 26878                                  	;	Disallow "copy file1+" as file overwriting itself.
 26879                                  	;
 26880                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26881                                  	;	equivalent to "copy file1+file2".)
 26882                                  
 26883                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26884                                  	;	through this check, since the switch would count
 26885                                  	;	as another object in ObjCnt.
 26886                                  
 26887 0000383D 803E[4A8D]01            	cmp	byte [PLUS],1		; "+" with
 26888 00003842 7514                    	jnz	short CDCONT
 26889 00003844 803E[B98A]01            	cmp	byte [ArgC],1		; one arg,
 26890 00003849 750D                    	jnz	short CDCONT
 26891 0000384B 803E[4B8D]02            	cmp	byte [objcnt],2		; two objects..
 26892 00003850 7506                    	jnz	short CDCONT
 26893 00003852 BA[257F]                	mov	dx,OVERWR_PTR
 26894 00003855 E91A06                  	jmp	COPYERR			; is file overwrite
 26895                                  
 26896                                  CDCONT:
 26897 00003858 A0[4A8D]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26898 0000385B A2[B88A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26899 0000385E D0E0                    	shl	al,1
 26900 00003860 D0E0                    	shl	al,1
 26901 00003862 A2[438D]                	mov	[INEXACT],al		; therefore making an inexact copy
 26902                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26903 00003865 A0[B98A]                	mov	al,[ArgC]		; AL = # independent arguments
 26904                                  
 26905                                  	; 23/03/2023
 26906                                  	; MSDOS 3.3		
 26907                                  	;or	al,al
 26908                                  	;jz	short CERROR4J
 26909                                  	; MSDOS 6.0
 26910 00003868 08C0                    	or	al,al
 26911 0000386A 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26912                                  		
 26913 0000386C BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26914 0000386F C706[FC7E]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26915                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26916 00003875 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26917                                  
 26918                                  	; more than 0 args; check if too many
 26919                                  TRY_TOO_MANY:
 26920 00003877 3C02                    	cmp	al,2
 26921 00003879 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26922                                  
 26923                                  	; 23/03/2023
 26924                                  	; MSDOS 6.0
 26925 0000387B BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26926 0000387E C706[FC7E]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26927                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26928                                  CERROR_PARSEJ:
 26929 00003884 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26930                                  					; parse error message	
 26931                                  CERROR4J:
 26932 00003889 E9C4F0                  	jmp	cerror
 26933                                  
 26934                                  ACOUNTOK:
 26935 0000388C BD[288C]                	mov	bp,DestVars		; BP = base of dest variables
 26936                                  
 26937 0000388F 3C01                    	cmp	al,1
 26938 00003891 7520                    	jnz	short GOT2ARGS
 26939                                  
 26940                                  	;	Only one independent pathname argument on command line.
 26941                                  	;	Set destination to d:*.*, where d: is current drive.
 26942                                  
 26943                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26944                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26945                                  
 26946 00003893 A0[B78A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26947                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26948                                  	; 23/03/2023
 26949 00003896 0441                    	add	al,'A'
 26950 00003898 B43A                    	mov	ah,':'			; AX = "d:"
 26951                                  	;mov	byte [bp+1],2
 26952 0000389A C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26953                                  
 26954 0000389E BF[2D8C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26955 000038A1 AB                      	stosw				; store "d:"
 26956                                  		
 26957 000038A2 C706[BE8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26958                                  	;mov	byte [bp+4],2		
 26959 000038A8 C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26960                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26961                                  	;mov	byte [bp+0],0		
 26962 000038AC C6460000                	mov	byte [bp],0
 26963 000038B0 E87408                  	call	SETSTARS		; add wildcards
 26964                                  GOT2ARGS:
 26965                                  	;	If destination pathname is "d:", add full wildcard filename
 26966                                  
 26967                                  	;cmp	byte [bp+1],2
 26968 000038B3 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26969 000038B7 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26970 000038B9 B03A                    	mov	al,':'  ; 3Ah
 26971 000038BB 3806[2E8C]              	cmp	byte [DestBuf+1],al
 26972 000038BF 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26973                                  	;or	byte [bp+4],2
 26974 000038C1 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26975 000038C5 BF[2F8C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26976                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26977                                  	;mov	byte [bp+0],0		
 26978 000038C8 C6460000                	mov	byte [bp],0
 26979 000038CC E85808                  	call	SETSTARS		; add wildcards
 26980                                  NOTSHORTDEST:
 26981                                  	;	If destination pathname ends with "\", try to make
 26982                                  	;	sure it's "d:\".
 26983                                  
 26984                                  	;mov	di,[bp+2]
 26985 000038CF 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 26986 000038D2 803D00                  	cmp	byte [di],0
 26987 000038D5 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 26988                                  
 26989 000038D7 BA[3780]                	mov	dx,badcd_ptr
 26990 000038DA B03A                    	mov	al,':'
 26991 000038DC 3845FE                  	cmp	[di-2],al
 26992 000038DF 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 26993                                  	;mov	byte [bp+0],2
 26994                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 26995 000038E1 C6460002                	mov	byte [bp],2
 26996                                  	;or	byte [bp+4],6
 26997 000038E5 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 26998                                  					  ;  path character
 26999 000038E9 E83B08                  	call	SETSTARS		; add wildcards
 27000                                  CHKSWTCHES:
 27001                                  	;	We have enough information about the destination for now.
 27002                                  
 27003                                  	;	Turn on verify if requested. Save the current verify flag.
 27004                                  
 27005                                  	; 23/03/2023
 27006                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 27007                                  	;mov	dx,BADPARMPTR
 27008                                  	
 27009 000038EC A1[C08A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 27010                                  
 27011                                  	; 23/03/2023
 27012                                  	; MSDOS 3.3
 27013                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27014                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27015                                  	;jnz	short CERROR4J
 27016                                  	
 27017                                  	; 23/03/2023
 27018                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27019                                  	;test	ax,SwitchV ; 10h
 27020                                  	; 18/04/2023
 27021                                  	;test	ax,10h
 27022 000038EF A810                    	test	al,10h  ; test al,SwitchV
 27023 000038F1 7414                    	jz	short NOVERIF		; no /v, no verify
 27024                                  
 27025 000038F3 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27026 000038F5 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27027                                  				; Return: AL = 00h if flag OFF
 27028                                  				; AL = 01h if flag ON
 27029 000038F7 1E                      	push	ds
 27030 000038F8 8E1E[A58A]              	mov	ds,[RESSEG]
 27031 000038FC 30E4                    	xor	ah,ah
 27032 000038FE A3[9001]                	mov	[VerVal],ax		; save current verify flag
 27033 00003901 1F                      	pop	ds
 27034 00003902 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27035 00003905 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27036                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27037                                  NOVERIF:
 27038                                  	;*	Scan for first source.
 27039                                  
 27040 00003907 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27041 00003909 BE8100                  	mov	si,81h			; SI = ptr into command line
 27042                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27043                                  	; 23/03/2023
 27044 0000390C B32B                    	mov	bl,'+' ; 2Bh
 27045                                  SCANFSRC:
 27046 0000390E BF[EA8C]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27047 00003911 E84208                  	call	cparse			; parse first source pathname
 27048 00003914 F6C701                  	test	bh,1			; switch?
 27049 00003917 75F5                    	jnz	short SCANFSRC		; yes, try again
 27050 00003919 092E[BE8A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27051                                  
 27052                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27053                                  
 27054                                  	; 23/03/2023
 27055 0000391D F7C50800                	test	bp,8
 27056                                  	;test	bp,SWITCHB
 27057 00003921 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27058 00003923 803E[B88A]00            	cmp	byte [Concat],0
 27059 00003928 7405                    	jz	short NOSETCASC		; we're not concatenating
 27060 0000392A C606[498D]04            	mov	byte [ASCII],4
 27061                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27062                                  NOSETCASC:
 27063 0000392F E8B503                  	call	SOURCE_SET		; set source variables
 27064 00003932 E84400                  	call	FRSTSRC			; set up first source copy
 27065 00003935 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27066                                  
 27067                                  ; ---------------------------------------------------------------------------
 27068                                  
 27069                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27070                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27071                                  ENDCOPY:
 27072                                  	;*	End of the road. Close destination, display # files
 27073                                  	;	copied (meaning # destinations), and go back to main
 27074                                  	;	transient COMMAND code.
 27075                                  
 27076 00003938 E8C102                  	call	CLOSEDEST
 27077                                  ENDCOPY2:
 27078 0000393B BA[2E7F]                	mov	dx,copied_ptr
 27079 0000393E 8B36[CD8A]              	mov	si,[FileCnt]
 27080 00003942 8936[138C]              	mov	[Copy_num],si
 27081 00003946 E88814                  	call	std_printf
 27082 00003949 E9B8C7                  	jmp	TCOMMAND		; stack could be messed up
 27083                                  
 27084                                  ; ---------------------------------------------------------------------------
 27085                                  
 27086                                  SRCNONEXIST:
 27087                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27088                                  	;	Otherwise, say 'file not found' and quit.
 27089                                  
 27090 0000394C 803E[B88A]00            	cmp	byte [Concat],0
 27091 00003951 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27092                                  
 27093                                  	; 24/03/2023
 27094                                  	; MSDOS 3.3
 27095                                  	;mov	dx,SRCBUF
 27096                                  	;mov	[STRING_PTR_1],dx
 27097                                  	;mov	dx,STRINGBUF1PTR
 27098                                  	;call	STD_PRINTF
 27099                                  	;mov	dx,FNOTFOUNDPTR
 27100                                  	;jmp	COPYERR
 27101                                  
 27102                                  	; 24/*03/2023
 27103                                  	; MSDOS 6.0
 27104                                  	;	Set up error message.
 27105 00003953 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27106                                  				  	; extended error msg
 27107 00003958 BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27108 0000395B C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27109                                  					; 'file not found' msg#
 27110 00003961 C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf
 27111                                  					; point at bad pathname
 27112 00003967 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27113                                  					; 1 substitution
 27114 0000396C E90305                  	jmp	COPYERR			; print msg and clean up
 27115                                  
 27116                                  ; ---------------------------------------------------------------------------
 27117                                  
 27118                                  SOURCEPROC:
 27119                                  
 27120                                  	;*	Preparatory processing for each source file.
 27121                                  	;	Called at FrstSrc for first source file.
 27122                                  
 27123 0000396F E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 27124 00003972 803E[B88A]00            	cmp	byte [Concat],0
 27125 00003977 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27126                                  
 27127                                  ; ---------------------------------------------------------------------------
 27128                                  
 27129                                  FRSTSRC:
 27130 00003979 31C0                    	xor	ax,ax
 27131 0000397B A2[C28A]                	mov	[CFLAG],al		; 'destination not created'
 27132 0000397E A3[C68A]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27133 00003981 A2[C38A]                	mov	[DestClosed],al		; 'destination not closed'
 27134                                  
 27135                                  LEAVECFLAG:
 27136 00003984 8936[418D]              	mov	[SRCPT],si		; save cmd-line ptr
 27137 00003988 BF[8789]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27138                                  						;   current dir
 27139 0000398B BD[8B8C]                	mov	bp,SrcVars		; BP = base of source variables
 27140 0000398E E84606                  	call	BUILDPATH		; cd to source dir, figure
 27141                                  						;   out stuff about source
 27142 00003991 8B36[8D8C]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27143 00003995 C3                      	retn
 27144                                  
 27145                                  ; ---------------------------------------------------------------------------
 27146                                  
 27147                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27148                                  NEXTSRC:
 27149                                  	;*	Next source. Come here after handling each pathname.
 27150                                  	;	We're done unless there are additional source pathnames
 27151                                  	;	to be appended.
 27152                                  	;
 27153                                  	;	Note that all files matching an ambiguous pathname
 27154                                  	;	are processed before coming here.
 27155                                  
 27156 00003996 803E[4A8D]00            	cmp	byte [PLUS],0
 27157                                  	;jne	short MORECP		; copying "+" sources - keep going
 27158                                  	; 26/04/2023
 27159                                  ;ENDCOPYJ2:
 27160                                  	;jmp	short ENDCOPY
 27161 0000399B 749B                    	je	short ENDCOPY
 27162                                  MORECP:
 27163 0000399D 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27164 0000399F 8B36[418D]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27165                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27166 000039A3 B32B                    	mov	bl,'+' ; 2Bh
 27167                                  SCANSRC:
 27168 000039A5 BF[EA8C]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27169 000039A8 E8AB07                  	call	cparse			; parse first source name
 27170                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27171                                  	; 26/04/2023
 27172 000039AB 728B                    	jb	short ENDCOPY
 27173                                  
 27174 000039AD F6C780                  	test	bh,80h
 27175                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27176                                  	; 26/04/2023
 27177 000039B0 7486                    	jz	short ENDCOPY
 27178                                  
 27179 000039B2 F6C701                  	test	bh,1
 27180 000039B5 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27181                                  
 27182                                  	;	ScanBuf contains the next source pathname.
 27183                                  
 27184 000039B7 E8B5FF                  	call	SOURCEPROC		; prepare this source
 27185 000039BA 803E[068C]01            	cmp	byte [comma],1		; was +,, found last time?
 27186 000039BF 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27187 000039C1 C606[078C]01            	mov	byte [plus_comma],1	; yes - set flag
 27188 000039C6 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27189                                  
 27190                                  NOSTAMP:
 27191 000039C8 C606[078C]00            	mov	byte [plus_comma],0	; reset +,, flag
 27192                                  
 27193                                  ; ---------------------------------------------------------------------------
 27194                                  
 27195                                  FIRSTENT:
 27196                                  
 27197                                  ;M047
 27198                                  ; The only case we need to worry about is when the source is wildcarded and
 27199                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27200                                  ;concatenation. We check for this case.
 27201                                  ;
 27202                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27203                                  ;right place to do this check.
 27204                                  
 27205                                  	;	This is where we enter the loop with the first source.
 27206                                  
 27207 000039CD BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27208 000039D0 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27209 000039D3 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27210                                  				; DS:SI	-> string to parse
 27211                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27212                                  				; AL = bit mask	to control parsing
 27213 000039D5 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27214 000039D8 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27215 000039DA A1[908C]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27216 000039DD 80FC3A                  	cmp	ah,':'
 27217 000039E0 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27218 000039E2 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27219                                  DRVSPEC1:
 27220 000039E4 0C20                    	or	al,20h			; AL = lowercase drive letter
 27221 000039E6 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27222                                  	;mov	[5Ch],al
 27223 000039E8 A25C00                  	mov	[FCB],al		; put drive id in FCB
 27224                                  
 27225                                  	;	FCB contains drive and filename to search.
 27226                                  		
 27227 000039EB B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'
 27228 000039ED E8FC00                  	call	SEARCH
 27229                                  SRCHDONE:
 27230 000039F0 9C                      	pushf				; save flags from Search
 27231 000039F1 E88BEA                  	call	RestUDir1		; restore users current directory
 27232 000039F4 9D                      	popf				; restore flags from search
 27233 000039F5 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27234 000039F7 E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27235                                  
 27236                                  NEXTAMBIG0:
 27237 000039FA 30C0                    	xor	al,al
 27238 000039FC 8606[C88A]              	xchg	al,[FRSTSRCH]
 27239 00003A00 08C0                    	or	al,al
 27240 00003A02 740B                    	jz	short NEXTAMBIG
 27241                                  SETNMEL:
 27242 00003A04 B90C00                  	mov	cx,12
 27243 00003A07 BF[F08B]                	mov	di,SDIRBUF
 27244 00003A0A BE[AA8B]                	mov	si,DIRBUF
 27245 00003A0D F3A4                    	rep	movsb			; save very first source name
 27246                                  NEXTAMBIG:
 27247 00003A0F 30C0                    	xor	al,al
 27248 00003A11 A2[448D]                	mov	[NOWRITE],al		; turn off nowrite
 27249 00003A14 8B3E[8D8C]              	mov	di,[SrcTail]
 27250 00003A18 BE[AB8B]                	mov	si,DIRBUF+1
 27251 00003A1B E8DDEB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27252                                  MELDO:
 27253 00003A1E 803E[B88A]00            	cmp	byte [Concat],0
 27254 00003A23 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27255 00003A25 F606[8F8C]02            	test	byte [SrcInfo],2	; wildcard - show name
 27256 00003A2A 7409                    	jz	short DOREAD
 27257                                  SHOWCPNAM:
 27258                                  	; 25/03/2023
 27259                                  	; MSDOS 3.3
 27260                                  	;mov	dx,SRCBUF
 27261                                  	;mov	[STRING_PTR_2],dx
 27262                                  	;mov	dx,STRINGBUF2PTR
 27263                                  	;call	STD_PRINTF
 27264                                  	;call	CRLF2
 27265                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27266                                  	; MSDOS 6.0 (& MSDOS 5.0
 27267 00003A2C BA[A780]                	mov	dx,file_name_ptr
 27268 00003A2F E89F13                  	call	std_printf
 27269 00003A32 E89AEB                  	call	CRLF2
 27270                                  DOREAD:
 27271 00003A35 E8C500                  	call	DOCOPY
 27272 00003A38 803E[B88A]00            	cmp	byte [Concat],0
 27273 00003A3D 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27274                                  
 27275 00003A3F E8BA01                  	call	CLOSEDEST		; close current destination
 27276 00003A42 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27277                                  
 27278 00003A44 C606[C28A]00            	mov	byte [CFLAG],0		; 'destination not created'
 27279                                  NODCLOSE:
 27280 00003A49 803E[B88A]00            	cmp	byte [Concat],0
 27281 00003A4E 740A                    	jz	short NOFLUSH
 27282                                  
 27283                                  ;	Concatenating - flush output between source files so LostErr
 27284                                  ;	stuff works correctly.
 27285                                  
 27286                                  	;invoke	FlshFil  ; MSDOS 6.0
 27287                                  	; 25/03/2023
 27288 00003A50 E8E202                  	call	FlshFil
 27289                                  	;call	FLUSHFIL ; MSDOS 3.3
 27290                                  
 27291 00003A53 F606[888C]FF            	test	byte [MELCOPY],0FFh
 27292                                  	;jz	short NOFLUSH
 27293                                  	;jmp	short DOMELCOPY
 27294                                  	; 25/03/2023
 27295 00003A58 750C                    	jnz	short DOMELCOPY
 27296                                  NOFLUSH:
 27297 00003A5A E88300                  	call	SEARCHNEXT		; try next match
 27298 00003A5D 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 27299                                  					;   this source spec
 27300 00003A5F C606[C38A]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27301 00003A64 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 27302                                  
 27303                                  DOMELCOPY:
 27304 00003A66 803E[888C]FF            	cmp	byte [MELCOPY],0FFh
 27305 00003A6B 740D                    	je	short CONTMEL
 27306 00003A6D 8B36[418D]              	mov	si,[SRCPT]
 27307 00003A71 8936[898C]              	mov	[MELSTART],si
 27308 00003A75 C606[888C]FF            	mov	byte [MELCOPY],0FFh
 27309                                  
 27310                                  CONTMEL:
 27311 00003A7A 31ED                    	xor	bp,bp
 27312 00003A7C 8B36[418D]              	mov	si,[SRCPT]
 27313                                  	;mov	bl,[PLUS_CHR]
 27314                                  	; 25/03/2023
 27315 00003A80 B32B                    	mov	bl,'+'
 27316                                  SCANSRC2:
 27317 00003A82 BF[EA8C]                	mov	di,ScanBuf
 27318 00003A85 E8CE06                  	call	cparse
 27319 00003A88 F6C780                  	test	bh,80h
 27320 00003A8B 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 27321 00003A8D F6C701                  	test	bh,1
 27322 00003A90 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27323 00003A92 E8DAFE                  	call	SOURCEPROC
 27324 00003A95 E8E7E9                  	call	RestUDir1
 27325 00003A98 BF[2B8B]                	mov	di,DESTFCB2
 27326 00003A9B B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27327 00003A9E CD21                    	int	21h		; DOS -	PARSE FILENAME
 27328                                  				; DS:SI	-> string to parse
 27329                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27330                                  				; AL = bit mask	to control parsing
 27331 00003AA0 BB[F18B]                	mov	bx,SDIRBUF+1
 27332 00003AA3 BE[2C8B]                	mov	si,DESTFCB2+1
 27333 00003AA6 8B3E[8D8C]              	mov	di,[SrcTail]
 27334                                  
 27335 00003AAA E8FB04                  	call	BUILDNAME
 27336                                  
 27337 00003AAD 803E[B88A]00            	cmp	byte [Concat],0
 27338 00003AB2 7405                    	je	short MELDOJ		; not concatenating - continue
 27339                                  
 27340                                  	;	Yes, turn off nowrite because this part of the code 
 27341                                  	;	is only reached after the first file has been dealt with.
 27342                                  
 27343 00003AB4 C606[448D]00            	mov	byte [NOWRITE],0
 27344                                  MELDOJ:
 27345 00003AB9 E962FF                  	jmp	MELDO
 27346                                  NEXTSRCJ:
 27347 00003ABC E9D7FE                  	jmp	NEXTSRC
 27348                                  
 27349                                  NEXTMEL:
 27350 00003ABF E83A01                  	call	CLOSEDEST
 27351 00003AC2 31C0                    	xor	ax,ax
 27352 00003AC4 A2[C28A]                	mov	[CFLAG],al
 27353 00003AC7 A3[C68A]                	mov	[NXTADD],ax
 27354 00003ACA A2[C38A]                	mov	[SPECDRV],al
 27355 00003ACD 8B36[898C]              	mov	si,[MELSTART]
 27356 00003AD1 8936[418D]              	mov	[SRCPT],si
 27357 00003AD5 E80800                  	call	SEARCHNEXT
 27358 00003AD8 7403                    	jz	short SETNMELJ
 27359 00003ADA E95EFE                  	jmp	ENDCOPY2
 27360                                  SETNMELJ:
 27361 00003ADD E924FF                  	jmp	SETNMEL
 27362                                  
 27363                                  ; ---------------------------------------------------------------------------
 27364                                  
 27365                                  SEARCHNEXT:
 27366 00003AE0 B412                    	mov	ah,Dir_Search_Next ; 12h
 27367 00003AE2 F606[8F8C]02            	test	byte [SrcInfo],2
 27368 00003AE7 7503                    	jnz	short SEARCH		; do search-next if ambig
 27369 00003AE9 08E4                    	or	ah,ah			; reset zero flag
 27370 00003AEB C3                      	retn
 27371                                  
 27372                                  ; ---------------------------------------------------------------------------
 27373                                  
 27374                                  SEARCH:
 27375 00003AEC 50                      	push	ax
 27376 00003AED B41A                    	mov	ah,Set_DMA ; 1Ah
 27377 00003AEF BA[AA8B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27378 00003AF2 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27379                                  			; DS:DX	-> disk	transfer buffer
 27380 00003AF4 58                      	pop	ax		; restore search first/next command
 27381 00003AF5 BA5C00                  	mov	dx,FCB ; 5Ch
 27382 00003AF8 CD21                    	int	21h		; Do the search
 27383 00003AFA 08C0                    	or	al,al
 27384 00003AFC C3                      	retn
 27385                                  
 27386                                  ; ---------------------------------------------------------------------------
 27387                                  
 27388                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27389                                  DOCOPY:
 27390 00003AFD BE[908C]                	mov	si,SrcBuf	; do name translate of source
 27391 00003B00 BF[D387]                	mov	di,SRCXNAME	; save for name comparison
 27392 00003B03 B460                    	mov	ah,xNameTrans ; 60h
 27393 00003B05 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27394                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27395                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27396 00003B07 C606[B68A]00            	mov	byte [RDEOF],0	; no EOF yet
 27397                                  
 27398                                  	; MSDOS 6.0
 27399                                  	;mov	ax,ExtOpen shl 8	; open the file
 27400                                  	; 26/03/2023
 27401 00003B0C B8006C                  	mov	ax,6C00h
 27402                                  ;M046
 27403                                  ; For reads, the sharing mode should be deny none so that any process can
 27404                                  ;open this file again in any other sharing mode. This is mainly to allow
 27405                                  ;multiple command.com's to access the same file without getting sharing
 27406                                  ;violations
 27407                                  ;
 27408                                  	;mov	bx,deny_none|read_open_mode
 27409 00003B0F BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27410 00003B12 31C9                    	xor	cx,cx			; no special files
 27411                                  	;mov	dx,read_open_flag	; set up open flags
 27412 00003B14 BA0101                  	mov	dx,101h
 27413 00003B17 CD21                    	int	21h
 27414                                  	; 26/03/2023
 27415 00003B19 7230                    	jc	short Error_On_Source
 27416                                  	;jnc	short OPENOK
 27417                                  
 27418                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27419                                  	;	They asked for it...
 27420                                  
 27421                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27422                                  
 27423                                  	; 26/03/2023
 27424                                  	; MSDOS 3.3
 27425                                  	;mov	dx,SRCBUF
 27426                                  	;mov	ax,OPEN*256 ; 3D00h
 27427                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27428                                  	;			; DS:DX	-> ASCIZ filename
 27429                                  	;			; AL = access mode
 27430                                  	;			; 0 - read
 27431                                  	;jnc	short OPENOK
 27432                                  	;call	GET_EXT_ERR_NUMBER
 27433                                  	;pushf
 27434                                  	;cmp	ax,65
 27435                                  	;jnz	short DOCOPY_ERR
 27436                                  	;mov	dx,ACCDENPTR
 27437                                  	;call	STD_PRINTF
 27438                                  ;DOCOPY_ERR:
 27439                                  	;popf
 27440                                  	;retn
 27441                                  
 27442                                  	; 26/03/2023
 27443                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27444                                  OPENOK:
 27445 00003B1B 89C3                    	mov	bx,ax
 27446 00003B1D 891E[E78C]              	mov	[SRCHAND],bx		; save handle
 27447 00003B21 B80057                  	mov	ax,File_Times*256 ; 5700h
 27448 00003B24 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27449                                  				; BX = file handle
 27450                                  
 27451 00003B26 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 27452                                  
 27453 00003B28 8916[4C8D]              	mov	[CPDATE],dx		; save date
 27454 00003B2C 890E[4E8D]              	mov	[CPTIME],cx		; save time
 27455                                  
 27456                                  	; MSDOS 6.0
 27457                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27458                                  	; 26/04/2023
 27459                                  No_Copy_Xa:
 27460                                  	; 26/03/2023
 27461                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27462                                  
 27463                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27464 00003B30 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27465 00003B33 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27466                                  				; BX = file or device handle
 27467                                  	;and	dl,devid_ISDEV ; 80h
 27468                                  	; 18/04/2023
 27469 00003B35 80E280                  	and	dl,80h ; devid_ISDEV
 27470 00003B38 8816[E98C]              	mov	[SRCISDEV],dl		; set source info
 27471 00003B3C 7436                    	jz	short COPYLP		; source not a device
 27472 00003B3E 803E[458D]00            	cmp	byte [BINARY],0
 27473 00003B43 742F                    	je	short COPYLP		; ascii device ok
 27474 00003B45 BA[6080]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27475 00003B48 E92703                  	jmp	COPYERR
 27476                                  
 27477                                  Error_On_Source:			;AN022; we have a BAD error
 27478 00003B4B E892E1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27479 00003B4E C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf
 27480                                  				;AN022; get address of failed string
 27481 00003B54 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27482                                  				;AN022; put number of subst in control block
 27483 00003B59 E86D12                  	call	std_eprintf		;AN022; print it
 27484                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27485 00003B5C 8B1E[E78C]              	mov	bx,[SRCHAND]
 27486                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27487                                  	;je	short No_Close_Src	;AN022; no - don't close
 27488 00003B60 09DB                    	or	bx,bx
 27489 00003B62 7403                    	jz	short No_Close_Src
 27490                                  	;call	CLOSESRC		;AN022; clean up
 27491                                  	; 26/03/2023
 27492 00003B64 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27493                                  No_Close_Src:				;AN022;
 27494 00003B67 803E[C28A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27495 00003B6C 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27496 00003B6E E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27497                                  EndCopyJ3:				;AN022;
 27498 00003B71 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27499                                  
 27500                                  	; 26/04/2023
 27501                                  ;No_Copy_Xa:
 27502                                  ;	; 26/03/2023
 27503                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27504                                  ;
 27505                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27506                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27507                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27508                                  ;				; BX = file or device handle
 27509                                  ;	;and	dl,devid_ISDEV ; 80h
 27510                                  ;	; 18/04/2023
 27511                                  ;	and	dl,80h ; devid_ISDEV
 27512                                  ;	mov	[SRCISDEV],dl		; set source info
 27513                                  ;	jz	short COPYLP		; source not a device
 27514                                  ;	cmp	byte [BINARY],0
 27515                                  ;	je	short COPYLP		; ascii device ok
 27516                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27517                                  ;	jmp	COPYERR
 27518                                  
 27519                                  COPYLP:
 27520                                  	; 26/03/2023
 27521 00003B74 8B1E[E78C]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27522 00003B78 8B0E[C48A]              	mov	cx,[BYTCNT]
 27523 00003B7C 8B16[C68A]              	mov	dx,[NXTADD]
 27524 00003B80 29D1                    	sub	cx,dx			; compute available space
 27525 00003B82 750E                    	jnz	short GOTROOM
 27526 00003B84 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27527                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27528 00003B87 803E[488D]00            	cmp	byte [TERMREAD],0
 27529 00003B8C 7565                    	jne	short CLOSESRC		; give up
 27530 00003B8E 8B0E[C48A]              	mov	cx,[BYTCNT]
 27531                                  GOTROOM:
 27532 00003B92 1E                      	push	ds
 27533 00003B93 8E1E[A78A]              	mov	ds,[TPA]
 27534 00003B97 B43F                    	mov	ah,READ ; 3Fh
 27535 00003B99 CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27536                                  				; BX = file handle,CX = number of bytes to read
 27537                                  				; DS:DX	-> buffer
 27538 00003B9B 1F                      	pop	ds
 27539                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27540                                  	; 26/03/2023
 27541 00003B9C 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27542 00003B9E 89C1                    	mov	cx,ax			; get count
 27543 00003BA0 E351                    	jcxz	CLOSESRC		; no more to read
 27544 00003BA2 803E[E98C]00            	cmp	byte [SRCISDEV],0
 27545 00003BA7 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27546 00003BA9 803E[498D]00            	cmp	byte [ASCII],0
 27547 00003BAE 741B                    	je	short BINREAD
 27548                                  NOTESTA:
 27549 00003BB0 89CA                    	mov	dx,cx
 27550 00003BB2 8B3E[C68A]              	mov	di,[NXTADD]
 27551 00003BB6 B01A                    	mov	al,1Ah
 27552 00003BB8 06                      	push	es
 27553 00003BB9 8E06[A78A]              	mov	es,[TPA]		; scan for EOF
 27554 00003BBD F2AE                    	repne	scasb
 27555 00003BBF 07                      	pop	es
 27556 00003BC0 7505                    	jnz	short USEALL
 27557 00003BC2 FE06[B68A]              	inc	byte [RDEOF]
 27558 00003BC6 41                      	inc	cx
 27559                                  USEALL:
 27560 00003BC7 29CA                    	sub	dx,cx
 27561 00003BC9 89D1                    	mov	cx,dx
 27562                                  BINREAD:
 27563 00003BCB 030E[C68A]              	add	cx,[NXTADD]
 27564 00003BCF 890E[C68A]              	mov	[NXTADD],cx
 27565 00003BD3 3B0E[C48A]              	cmp	cx,[BYTCNT]		; is buffer full?
 27566 00003BD7 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27567                                  	; 26/03/2023
 27568 00003BD9 E85901                  	call	FlshFil
 27569                                  	;call	FLUSHFIL
 27570 00003BDC 803E[488D]00            	cmp	byte [TERMREAD],0
 27571 00003BE1 7510                    	jne	short CLOSESRC		; give up
 27572 00003BE3 EB8F                    	jmp	short COPYLP
 27573                                  TESTDEV:
 27574 00003BE5 803E[E98C]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27575 00003BEA 7407                    	je	short CLOSESRC
 27576 00003BEC 803E[B68A]00            	cmp	byte [RDEOF],0
 27577 00003BF1 7481                    	je	short COPYLP		; on device, go till ^Z
 27578                                  CLOSESRC:
 27579 00003BF3 8B1E[E78C]              	mov	bx,[SRCHAND]
 27580                                  CLOSESRC2:
 27581 00003BF7 B43E                    	mov	ah,CLOSE ; 3Eh
 27582 00003BF9 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27583                                  				; BX = file handle
 27584                                  CLOSESRCDEST_RETN:
 27585 00003BFB C3                      	retn
 27586                                  
 27587                                  ; ---------------------------------------------------------------------------
 27588                                  
 27589                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27590                                  CLOSEDEST:
 27591                                  
 27592                                  	;	We are called to close the destination.
 27593                                  	;	We need to note whether or not there is any internal data left
 27594                                  	;	to be flushed out.
 27595                                  
 27596 00003BFC 803E[C38A]00            	cmp	byte [DestClosed],0
 27597 00003C01 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27598 00003C03 A0[BE8A]                	mov	al,[DestSwitch]
 27599 00003C06 E8C502                  	call	SETASC			; check for b or a switch
 27600 00003C09 742E                    	jz	short BINCLOS		;   on destination
 27601 00003C0B 8B1E[C68A]              	mov	bx,[NXTADD]
 27602                                  ;
 27603                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27604                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27605                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27606                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27607                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27608                                  ;performance overhead on single ASCII file copies which now always involve
 27609                                  ;2 writes instead of 1 before. Is this really that important?
 27610                                  ;
 27611                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27612                                  ;M048;	jne	short PutZ
 27613                                  
 27614                                  	; 26/03/2023
 27615                                  	; MSDOS 3.3
 27616                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27617                                  	;jne	short PUTZ
 27618                                  
 27619                                  	; 26/03/2023
 27620 00003C0F E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27621 00003C12 7402                    	jz	short NOCONC
 27622                                  CONCHNG:
 27623 00003C14 F9                      	stc
 27624 00003C15 C3                      	retn
 27625                                  
 27626                                  NOCONC:	
 27627 00003C16 31DB                    	xor	bx,bx
 27628                                  PUTZ:
 27629 00003C18 1E                      	push	ds
 27630 00003C19 8E1E[A78A]              	mov	ds,[TPA]
 27631 00003C1D C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27632 00003C21 1F                      	pop	ds
 27633 00003C22 FF06[C68A]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27634 00003C26 C606[448D]00            	mov	byte [NOWRITE],0
 27635 00003C2B A1[468D]                	mov	ax,[WRITTEN]
 27636 00003C2E 0306[C68A]              	add	ax,[NXTADD]
 27637 00003C32 7205                    	jc	short BINCLOS	; > 1
 27638 00003C34 83F801                  	cmp	ax,1
 27639 00003C37 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27640                                  BINCLOS:
 27641 00003C39 E8EC00                  	call	TRYFLUSH
 27642 00003C3C 75D6                    	jnz	short CONCHNG
 27643                                  
 27644                                  	; 26/04/2023
 27645 00003C3E 833E[468D]00            	cmp	word [WRITTEN],0
 27646                                  	; 26/03/2023
 27647 00003C43 7503                    	jnz	short NO_FORGET
 27648                                  FORGETITJ:
 27649                                  	;jz	short FORGETIT	; never wrote nothing
 27650                                  	; 26/03/2023
 27651 00003C45 E98500                  	jmp	FORGETIT ; 18/04/2023
 27652                                  NO_FORGET:			; wrote something
 27653 00003C48 8B1E[848C]              	mov	bx,[DESTHAND]
 27654 00003C4C 8B0E[4E8D]              	mov	cx,[CPTIME]
 27655 00003C50 8B16[4C8D]              	mov	dx,[CPDATE]
 27656 00003C54 803E[438D]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27657 00003C59 7431                    	je	short DODCLOSE	; if no, copy date & time
 27658 00003C5B B42C                    	mov	ah,Get_Time ; 2Ch
 27659 00003C5D CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27660                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27661                                  				; DL = hundredths of seconds
 27662 00003C5F D0E1                    	shl	cl,1
 27663 00003C61 D0E1                    	shl	cl,1		; left justify min in cl
 27664 00003C63 D1E1                    	shl	cx,1
 27665 00003C65 D1E1                    	shl	cx,1
 27666 00003C67 D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27667 00003C69 D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27668 00003C6B 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27669 00003C6D 51                      	push	cx		; save packed time
 27670 00003C6E B42A                    	mov	ah,Get_Date ; 2Ah
 27671 00003C70 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27672                                  				; Return: DL = day,DH = month,	CX = year
 27673                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27674 00003C72 81E9BC07                	sub	cx,1980
 27675 00003C76 86E9                    	xchg	ch,cl
 27676 00003C78 D1E1                    	shl	cx,1		; year to high 7 bits
 27677 00003C7A D0E6                    	shl	dh,1		; month to high 3 bits
 27678 00003C7C D0E6                    	shl	dh,1
 27679 00003C7E D0E6                    	shl	dh,1
 27680 00003C80 D0E6                    	shl	dh,1
 27681 00003C82 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27682 00003C84 80D500                  	adc	ch,0		; put that bit next to year
 27683 00003C87 08F2                    	or	dl,dh		; or low three of month into day
 27684 00003C89 88EE                    	mov	dh,ch		; get year and high bit of month
 27685 00003C8B 59                      	pop	cx
 27686                                  DODCLOSE:
 27687 00003C8C 83FB00                  	cmp	bx,0
 27688 00003C8F 7E36                    	jle	short CLOSEDONE
 27689 00003C91 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27690 00003C94 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27691                                  				; BX = file handle,CX = time to be set
 27692                                  				; DX = date to be set
 27693                                  	; 26/03/2023
 27694                                  	; MSDOS 6.0
 27695 00003C96 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27696                                  
 27697                                  	;	See if the destination has *anything* in it.
 27698                                  	;	If not, just close and delete it.
 27699                                  
 27700 00003C98 B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27701 00003C9B 31D2                    	xor	dx,dx
 27702 00003C9D 89D1                    	mov	cx,dx
 27703 00003C9F CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27704                                  			; AL = method: offset from end of file
 27705                                  	;	DX:AX is file size
 27706                                  
 27707 00003CA1 09C2                    	or	dx,ax
 27708 00003CA3 9C                      	pushf
 27709 00003CA4 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27710 00003CA7 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27711                                  			; BX = file or device handle
 27712 00003CA9 52                      	push	dx		; save them away
 27713 00003CAA B43E                    	mov	ah,CLOSE ; 3Eh
 27714 00003CAC CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27715                                  			; BX = file handle
 27716 00003CAE 5A                      	pop	dx
 27717                                  
 27718                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27719                                  	; MSDOS 6.0
 27720 00003CAF 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27721 00003CB1 9D                      	popf			;AN022; get the flags back
 27722                                  Cleanup_Err: 			;AN022;
 27723 00003CB2 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27724                                  	; 26/03/2023
 27725                                  	;call	DestDelete	;AN022; attempt to delete the target
 27726                                  	;jmp	short FILECLOSED
 27727                                  	;			;AN022; close the file
 27728                                  	; 26/03/2023
 27729                                  DestDel_fclosed:
 27730 00003CB5 E82700                  	call	DestDelete
 27731                                  FILECLOSED:
 27732 00003CB8 FE06[C38A]              	inc	byte [DestClosed]
 27733                                  RET50:
 27734 00003CBC F8                      	clc
 27735 00003CBD C3                      	retn
 27736                                  	
 27737                                  Close_Cont:			;AN022; no error - co
 27738                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27739 00003CBE 9D                      	popf
 27740 00003CBF 7506                    	jnz	short CLOSEDONE
 27741 00003CC1 F7C28000                	test	dx,80h		; is the destination a device?
 27742                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27743                                  	;call	DestDelete
 27744                                  	;jmp	short FILECLOSED
 27745                                  	; 26/03/2023
 27746 00003CC5 74EE                    	jz	short DestDel_fclosed
 27747                                  CLOSEDONE:
 27748 00003CC7 FF06[CD8A]              	inc	word [FileCnt]
 27749                                  	; 26/03/2023
 27750 00003CCB EBEB                    	jmp	short FILECLOSED
 27751                                  	
 27752                                  ;FILECLOSED:
 27753                                  ;	inc	byte [DestClosed]
 27754                                  ;RET50:
 27755                                  	;clc
 27756                                  	;retn
 27757                                  
 27758                                  FORGETIT:
 27759 00003CCD 8B1E[848C]              	mov	bx,[DESTHAND]
 27760 00003CD1 E8B8FF                  	call	DODCLOSE	 ; close the dest
 27761 00003CD4 E80800                  	call	DestDelete
 27762 00003CD7 C706[CD8A]0000          	mov	word [FileCnt],0 ; no files transferred
 27763 00003CDD EBDD                    	jmp	short RET50
 27764                                  
 27765                                  ; ---------------------------------------------------------------------------
 27766                                  
 27767                                  	; 26/03/2023
 27768                                  DestDelete:
 27769 00003CDF BA[2D8C]                	mov	dx,DestBuf
 27770 00003CE2 B441                    	mov	ah,Unlink ; 41h
 27771 00003CE4 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27772                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27773                                  			;		(no wildcards allowed)
 27774 00003CE6 C3                      	retn
 27775                                  
 27776                                  ; ---------------------------------------------------------------------------
 27777                                  
 27778                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27779                                  SOURCE_SET:
 27780 00003CE7 56                      	push	si
 27781 00003CE8 A1[578D]                	mov	ax,[STARTEL]
 27782 00003CEB BE[EA8C]                	mov	si,ScanBuf	; adjust to copy
 27783 00003CEE 29F0                    	sub	ax,si
 27784 00003CF0 BF[908C]                	mov	di,SrcBuf
 27785 00003CF3 01F8                    	add	ax,di
 27786 00003CF5 A3[8D8C]                	mov	[SrcTail],ax
 27787 00003CF8 880E[8C8C]              	mov	[SrcSiz],cl	; save its size
 27788 00003CFC 41                      	inc	cx		; include the nul
 27789 00003CFD F3A4                    	rep	movsb		; save this source
 27790 00003CFF 883E[8F8C]              	mov	[SrcInfo],bh	; save info about it
 27791 00003D03 5E                      	pop	si
 27792 00003D04 89E8                    	mov	ax,bp		; switches so far
 27793 00003D06 E8C501                  	call	SETASC		; set a,b switches accordingly
 27794 00003D09 E86EEA                  	call	SWITCH		; get any more switches on this arg
 27795                                  	;call	SETASC		; set
 27796                                  	;retn
 27797                                  	; 26/03/2023
 27798 00003D0C E9BF01                  	jmp	SETASC
 27799                                  
 27800                                  ; =============== S U B	R O U T	I N E =======================================
 27801                                  
 27802                                  ; MSDOS 6.0
 27803                                  
 27804                                  ;****************************************************************
 27805                                  ;*
 27806                                  ;* ROUTINE:	CleanupErr
 27807                                  ;*
 27808                                  ;* FUNCTION:	Issues extended error message for destination
 27809                                  ;*		if not alreay issued
 27810                                  ;*
 27811                                  ;* INPUT:	return from INT 21
 27812                                  ;*
 27813                                  ;* OUTPUT:	none
 27814                                  ;*
 27815                                  ;****************************************************************
 27816                                  
 27817                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27818                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27819                                  CleanUpErr:	; proc	near		;AN022;
 27820                                  
 27821 00003D0F 803E[938D]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27822 00003D14 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27823 00003D16 E8C7DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27824 00003D19 C706[118C][2D8C]        	mov	word [string_ptr_2],DestBuf 
 27825                                  					;AN022; get address of failed string
 27826 00003D1F C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27827                                  					;AN022; put number of subst in control block
 27828 00003D24 E8A210                  	call	std_eprintf		;AN022; issue the error message
 27829                                  CleanupErr_Cont:			;AN022;
 27830 00003D27 C3                      	retn				;AN022; return to caller
 27831                                  
 27832                                  ;CleanUpErr	endp			;AN022;
 27833                                  
 27834                                  ;============================================================================
 27835                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27836                                  ;============================================================================
 27837                                  ; 01/10/2018 - Retro DOS v3.0
 27838                                  
 27839                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27840                                  
 27841                                  ; =============== S U B	R O U T	I N E =======================================
 27842                                  
 27843                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27844                                  ;
 27845                                  ;	EXIT	ZR set if concatenate flag unchanged
 27846                                  
 27847                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27848                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27849                                  TRYFLUSH:
 27850 00003D28 A0[B88A]                	mov	al,[Concat]
 27851 00003D2B 50                      	push	ax
 27852                                  	;call	FLUSHFIL
 27853 00003D2C E80600                  	call	FlshFil
 27854 00003D2F 58                      	pop	ax
 27855 00003D30 3A06[B88A]              	cmp	al,[Concat]
 27856 00003D34 C3                      	retn
 27857                                  
 27858                                  ; =============== S U B	R O U T	I N E =======================================
 27859                                  
 27860                                  	; 26/03/2023
 27861                                  	; MSDOS 3.3
 27862                                  ;FLUSHFIL:
 27863                                  	;mov	al,[BINARY]
 27864                                  	;mov	ah,[ASCII]
 27865                                  	;push	ax
 27866                                  	;call	FLSHFIL
 27867                                  	;pop	ax
 27868                                  	;mov	[ASCII],ah
 27869                                  	;mov	[BINARY],al
 27870                                  	;retn
 27871                                  
 27872                                  ; =============== S U B	R O U T	I N E =======================================
 27873                                  
 27874                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27875                                  ;
 27876                                  ;	Inputs:
 27877                                  ;	  [NXTADD] = No. of bytes to write
 27878                                  ;	  [CFLAG] <> 0 if file has been created
 27879                                  ;	Outputs:
 27880                                  ;	  [NXTADD] = 0
 27881                                  
 27882                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27883                                  FlshFil:
 27884 00003D35 C606[488D]00            	mov	byte [TERMREAD],0
 27885 00003D3A 803E[C28A]00            	cmp	byte [CFLAG],0
 27886 00003D3F 7403                    	jz	short NotExists
 27887 00003D41 E99600                  	jmp	Exists
 27888                                  NotExists:
 27889 00003D44 E8A101                  	call	BUILDDEST		; find out all about the destination
 27890 00003D47 E8F903                  	call	COMPNAME		; source and dest. the same?
 27891 00003D4A 7519                    	jnz	short ProcDest		; if not, go ahead
 27892 00003D4C 803E[E98C]00            	cmp	byte [SRCISDEV],0
 27893 00003D51 7512                    	jnz	short ProcDest		; same name on device ok
 27894 00003D53 803E[B88A]00            	cmp	byte [Concat],0		; concatenation?
 27895 00003D58 BA[257F]                	mov	dx,OVERWR_PTR
 27896                                  	;je	short COPERR		; not concatenating - overwrite error
 27897                                  	; 26/03/2023
 27898 00003D5B 7503                    	jne	short No_Concat_Err
 27899 00003D5D E91201                  	jmp	COPYERR
 27900                                  	
 27901                                  No_Concat_Err:	; concatenating
 27902 00003D60 C606[448D]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27903                                  ProcDest:
 27904                                  	; MSDOS 6.0
 27905                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27906                                  	; 26/03/2023
 27907 00003D65 B8006C                  	mov	ax,6C00h
 27908 00003D68 BE[2D8C]                	mov	si,DestBuf		; get file name
 27909                                  ;M046
 27910                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27911                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27912                                  ;writing to the same file. Also, because we opened the source file with
 27913                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27914                                  ;would happen when we append to an existing file.
 27915                                  
 27916                                  	; 26/03/2023
 27917                                  	;mov	bx,deny_write|write_open_mode
 27918 00003D6B BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27919 00003D6E 31C9                    	xor	cx,cx			; no special files
 27920                                  	;mov	dx,write_open_flag	; set up open flags
 27921 00003D70 BA0101                  	mov	dx,101h	
 27922                                  
 27923 00003D73 803E[448D]00            	cmp	byte [NOWRITE],0
 27924 00003D78 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27925                                  	;mov	dx,creat_open_flag	; set up create flags
 27926 00003D7A BA1201                  	mov	dx,112h
 27927                                  
 27928                                  	; 26/03/2023
 27929                                  	; MSDOS 3.3
 27930                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27931                                  	;cmp	byte [NOWRITE],0
 27932                                  	;jne	short DODESTOPEN
 27933                                  	;mov	ah,CREAT ; 3Ch
 27934                                  	;xor	cx,cx
 27935                                  ;DODESTOPEN:
 27936                                  	;mov	dx,DESTBUF
 27937                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27938                                  	;		; CX = attributes for file
 27939                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27940                                  
 27941                                  ; 26/03/2023
 27942                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27943                                  ;	;mov	dx,FULDIRPTR
 27944                                  ;	;call	GET_EXT_ERR_NUMBER
 27945                                  ;	;jc	short COPERR
 27946                                  ;
 27947                                  ;	; 01/10/2018
 27948                                  ;	;jnc	short DEST_OPEN_OKAY
 27949                                  ;		
 27950                                  ;	;mov	dx,FULDIRPTR
 27951                                  ;	;call	GET_EXT_ERR_NUMBER
 27952                                  ;	;jmp	short COPERR
 27953                                  ;
 27954                                  ;	jc	short DEST_OPEN_ERROR
 27955                                  
 27956                                  	; 26/03/2023
 27957                                  DoDestOpen:
 27958 00003D7D CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27959                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27960                                  			; BH = flags
 27961                                  			; CX = create attribute
 27962                                  			; DL = action if file exists/does not exists
 27963                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27964                                  
 27965                                  ;	We assume that the error is normal.
 27966                                  ;	TriageError will correct the DX value appropriately.
 27967                                  	
 27968 00003D7F 7311                    	jnc	short Dest_Open_Okay
 27969                                  Xa_Set_Error:				;AN030; error occurred on XA
 27970 00003D81 E85CDF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27971                                  
 27972                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27973                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27974                                  Ext_Err_Set:				;AN030;
 27975 00003D84 C706[118C][2D8C]        	mov	word [string_ptr_2],DestBuf
 27976                                  					;AN000; get address of failed string
 27977 00003D8A C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27978                                  					;AN030; put number of subst in control block
 27979                                  CopErrJ2:				;AN030;
 27980 00003D8F E9E000                  	jmp	COPYERR			;AN030; go issue message
 27981                                  
 27982                                  ;DEST_OPEN_OKAY:
 27983                                  	; 26/03/2023
 27984                                  Dest_Open_Okay:
 27985 00003D92 A3[848C]                	mov	[DESTHAND],ax		; save handle
 27986 00003D95 C606[C28A]01            	mov	byte [CFLAG],1		; destination now exists
 27987 00003D9A 89C3                    	mov	bx,ax
 27988 00003D9C B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 27989 00003D9F CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 27990                                  			   	; BX = file or device handle
 27991                                  
 27992 00003DA1 8816[868C]              	mov	[DESTISDEV],dl		; set dest info
 27993                                  	; 18/04/2023
 27994 00003DA5 F6C280                  	test	dl,80h
 27995                                  	;test	dl,devid_ISDEV
 27996 00003DA8 7430                    	jz	short Exists		; Dest not a device
 27997                                  
 27998                                  ;	Destination is device.
 27999                                  
 28000 00003DAA A0[BE8A]                	mov	al,[DestSwitch]
 28001                                  	; 26/03/2023
 28002 00003DAD 240C                    	and	al,0Ch
 28003                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 28004 00003DAF 7509                    	jnz	short TestBoth
 28005 00003DB1 A0[498D]                	mov	al,[ASCII]		; neither set, use current setting
 28006 00003DB4 0A06[458D]              	or	al,[BINARY]
 28007 00003DB8 7416                    	jz	short ExSetA		; neither set, default to ascii
 28008                                  TestBoth:
 28009 00003DBA 7A1E                    	jpe	short Exists		; both are set, ignore
 28010 00003DBC A808                    	test	al,8
 28011                                  	;test	al,SWITCHB
 28012 00003DBE 741A                    	jz	short Exists
 28013                                  	;mov	ax,(IOCTL shl 8) or 1
 28014 00003DC0 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28015 00003DC3 30F6                    	xor	dh,dh
 28016                                  	; 18/04/2023
 28017 00003DC5 80CA20                  	or	dl,20h
 28018                                  	;or	dl,devid_RAW
 28019 00003DC8 8816[868C]              	mov	[DESTISDEV],dl
 28020 00003DCC CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28021                                  			; BX = device handle,DH = 0
 28022                                  			; DL = device information to set (bits 0-7 from	function 0)
 28023 00003DCE EB0A                    	jmp	short Exists
 28024                                  
 28025                                  	; 26/03/2023
 28026                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28027                                  ;DEST_OPEN_ERROR:
 28028                                  	;mov	dx,FULDIRPTR
 28029                                  	;call	GET_EXT_ERR_NUMBER
 28030                                  ;COPERR:
 28031                                  	; 26/03/2023
 28032                                  ;CopyErrj:
 28033                                  	;jmp	short COPYERR
 28034                                  
 28035                                  ExSetA:
 28036                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28037                                  
 28038 00003DD0 C606[498D]04            	mov	byte [ASCII],4
 28039                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28040 00003DD5 800E[438D]04            	or	byte [INEXACT],4
 28041                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28042                                  Exists:
 28043 00003DDA 803E[448D]00            	cmp	byte [NOWRITE],0
 28044 00003DDF 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28045 00003DE1 803E[078C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28046 00003DE6 741D                    	jz	short NoChecking
 28047 00003DE8 E85803                  	call	COMPNAME		; source and dest. the same?
 28048 00003DEB 7518                    	jnz	short NoChecking	; if not, go ahead
 28049 00003DED 803E[E98C]00            	cmp	byte [SRCISDEV],0
 28050 00003DF2 7511                    	jne	short NoChecking	; same name on device ok
 28051                                  
 28052                                  ;	At this point we know in append (would have gotten overwrite error
 28053                                  ;	on first destination create otherwise), and user trying to specify
 28054                                  ;	destination which has been scribbled already (if dest had been named
 28055                                  ;	first, NoWrite would be set).
 28056                                  
 28057 00003DF4 BA[287F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28058                                  	;invoke	Std_EprintF		;ac022;
 28059                                  	; 26/03/2023
 28060 00003DF7 E8CF0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28061                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28062 00003DFA C706[C68A]0000          	mov	word [NXTADD],0		; set return
 28063 00003E00 FE06[488D]              	inc	byte [TERMREAD]		; tell read to give up
 28064                                  Ret60:
 28065 00003E04 C3                      	retn
 28066                                  
 28067                                  NoChecking:
 28068 00003E05 8B1E[848C]              	mov	bx,[DESTHAND]		; get handle
 28069 00003E09 31C9                    	xor	cx,cx
 28070 00003E0B 870E[C68A]              	xchg	cx,[NXTADD]
 28071 00003E0F E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28072 00003E11 FF06[468D]              	inc	word [WRITTEN]		; flag that we wrote something
 28073 00003E15 803E[448D]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28074 00003E1A 7514                    	jnz	short SeekEnd
 28075 00003E1C 31D2                    	xor	dx,dx
 28076 00003E1E 1E                      	push	ds
 28077 00003E1F 8E1E[A78A]              	mov	ds,[TPA]
 28078 00003E23 B440                    	mov	ah,Write ; 40h
 28079 00003E25 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28080                                  			; BX = file handle,CX = number of bytes to write,DS:DX -> buffer
 28081 00003E27 1F                      	pop	ds
 28082 00003E28 BA[107F]                	mov	dx,NOSPACE_PTR
 28083                                  	;jc	short COPERRP		; failure
 28084                                  	; 26/03/2023
 28085                                  	; MSDOS 6.0
 28086 00003E2B 7326                    	jnc	short NoChecking2
 28087 00003E2D E951FF                  	jmp	Xa_Set_Error
 28088                                  
 28089                                  	; 18/04/2023
 28090                                  	; 26/03/2023
 28091                                  SeekEnd:
 28092 00003E30 31D2                    	xor	dx,dx
 28093 00003E32 87D1                    	xchg	dx,cx
 28094                                  	;mov	ax,(LSEEK shl 8) or 1
 28095 00003E34 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28096 00003E37 CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28097                                  				; AL = method: offset from present location
 28098                                  
 28099                                  	; 26/03/2023
 28100                                  	; MSDOS 6.0
 28101                                  
 28102                                  ;	Save the file pointer in DX:AX to restore the file
 28103                                  ;	with in case the copy should fail.
 28104                                  
 28105 00003E39 A3[508D]                	mov	[OFilePtr_Lo],ax
 28106 00003E3C 8916[528D]              	mov	[OFilePtr_Hi],dx
 28107                                  
 28108                                  	; 26/03/2023
 28109                                  	; MSDOS 3.3  MSDOS 6.0
 28110                                  
 28111 00003E40 803E[B68A]00            	cmp	byte [RDEOF],0
 28112 00003E45 740B                    	jz	short Retz60
 28113                                  
 28114                                  ;	^Z has been read - we must set the file size to the current
 28115                                  ;	file pointer location
 28116                                  
 28117 00003E47 B440                    	mov	ah,Write ; 40h
 28118 00003E49 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28119                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28120                                  
 28121                                  	; 26/03/2023
 28122                                  	; MSDOS 6.0
 28123 00003E4B 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28124                                  
 28125                                  ;	Make note that ^Z was removed, in case the
 28126                                  ;	copy should fail and we need to restore the file.
 28127                                  
 28128 00003E4D C606[548D]1A            	mov	byte [OCtrlZ],1Ah
 28129                                  Retz60:
 28130 00003E52 C3                      	retn
 28131                                  
 28132                                  NoChecking2:
 28133 00003E53 29C1                    	sub	cx,ax
 28134 00003E55 74AD                    	jz	short Ret60		; wrote all supposed to
 28135                                  	; 18/04/2023
 28136 00003E57 F606[868C]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28137                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28138 00003E5C 7414                    	jz	short COPYERR		; is a file, error
 28139 00003E5E F606[868C]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28140                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28141 00003E63 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28142 00003E65 803E[438D]00            	cmp	byte [INEXACT],0
 28143 00003E6A 7598                    	jnz	short Ret60		; inexact so ok
 28144 00003E6C 49                      	dec	cx
 28145                                  ;Retz60:
 28146 00003E6D 7495                    	jz	short Ret60		; wrote one byte less (the ^z)
 28147                                  
 28148                                  DevWrtErr:
 28149 00003E6F BA[9380]                	mov	dx,DEVWMES_PTR
 28150                                  	; 26/03/2023
 28151                                  COPYERR:
 28152                                  	;invoke	Std_EPrintF		;AC022;
 28153 00003E72 E8540F                  	call	std_eprintf  ; MSDOS 6.0
 28154                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28155                                  CopErrP:
 28156 00003E75 FE06[C38A]              	inc	byte [DestClosed]
 28157 00003E79 803E[C28A]00            	cmp	byte [CFLAG],0
 28158 00003E7E 7448                    	jz	short EndCopyJ		; never actually got it open
 28159 00003E80 8B1E[848C]              	mov	bx,[DESTHAND]
 28160 00003E84 83FB00                  	cmp	bx,0
 28161 00003E87 7E33                    	jle	short NoClose
 28162                                  
 28163                                  ;	Check to see if we should save part of the destination file.
 28164                                  
 28165                                  	; 26/03/2023
 28166                                  	; MSDOS 6.0
 28167 00003E89 8B0E[528D]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 28168 00003E8D 8B16[508D]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 28169                                  			
 28170 00003E91 89C8                    	mov	ax,cx
 28171 00003E93 09D0                    	or	ax,dx
 28172 00003E95 7421                    	jz	short ceClose		; null file ptr means nothing to save
 28173                                  
 28174                                  ;	Destination was also the first source. Do the best we can to
 28175                                  ;	restore it. Truncate it back to the size we took from it (which
 28176                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 28177                                  ;	file). If a Ctrl-Z was originally read, put it back.
 28178                                  
 28179 00003E97 B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 28180 00003E9A CD21                    	int	21h
 28181                                  
 28182 00003E9C 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 28183 00003E9E B440                    	mov	ah,Write ; 40h
 28184 00003EA0 CD21                    	int	21h			; truncate file
 28185                                  
 28186 00003EA2 803E[548D]00            	cmp	byte [OCtrlZ],0
 28187 00003EA7 7408                    	je	short ceClose0		; no ctrl-z removed from original
 28188 00003EA9 41                      	inc	cx			; CX = # bytes to write = 1
 28189 00003EAA BA[548D]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 28190 00003EAD B440                    	mov	ah,Write ; 40h
 28191 00003EAF CD21                    	int	21h			; write ctrl-z
 28192                                  ceClose0:
 28193 00003EB1 B43E                    	mov	ah,CLOSE ; 3Eh
 28194 00003EB3 CD21                    	int	21h			; close it
 28195                                  ;;	;mov	byte [CFLAG],0
 28196 00003EB5 E980FA                  	jmp	ENDCOPY			; and go home
 28197                                  
 28198                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28199                                  ceClose:
 28200 00003EB8 B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 28201 00003EBA CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28202                                  				; BX = file handle
 28203                                  NoClose:
 28204 00003EBC BA[2D8C]                	mov	dx,DestBuf
 28205 00003EBF B441                    	mov	ah,Unlink ; 41h 	; and delete it
 28206 00003EC1 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 28207                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 28208 00003EC3 C606[C28A]00            	mov	byte [CFLAG],0
 28209                                  EndCopyJ:
 28210 00003EC8 E96DFA                  	jmp	ENDCOPY
 28211                                  
 28212                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 28213 00003ECB E9B3FE                  	jmp	Xa_Set_Error
 28214                                  
 28215                                  ;============================================================================
 28216                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 28217                                  ;============================================================================
 28218                                  ; 01/10/2018 - Retro DOS v3.0
 28219                                  
 28220                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 28221                                  
 28222                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28223                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 28224                                  
 28225                                  ; =============== S U B	R O U T	I N E =======================================
 28226                                  
 28227                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 28228                                  ;
 28229                                  ;	Given switch vector in AX,
 28230                                  ;	  Set Ascii flag if /a is set
 28231                                  ;	  Clear Ascii flag if /b is set
 28232                                  ;	  Binary set if /b specified
 28233                                  ;	  Leave Ascii unchanged if neither or both are set
 28234                                  ; 	Also sets Inexact if Ascii is ever set. 
 28235                                  ;	AL = Ascii on exit, flags set
 28236                                  
 28237                                  	; 26/03/2023
 28238                                  SETASC:
 28239                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 28240 00003ECE 240C                    	and	al,0Ch ; 4+8
 28241 00003ED0 7A10                    	jpe	short LOADSW	; even parity - both or neither
 28242 00003ED2 50                      	push	ax
 28243                                  	;and	al,SWITCHB  ; 8
 28244 00003ED3 2408                    	and	al,8
 28245 00003ED5 A2[458D]                	mov	[BINARY],al
 28246 00003ED8 58                      	pop	ax
 28247                                  	;and	al,SWITCHA
 28248 00003ED9 2404                    	and	al,4	
 28249 00003EDB A2[498D]                	mov	[ASCII],al
 28250 00003EDE 0806[438D]              	or	[INEXACT],al
 28251                                  LOADSW:
 28252 00003EE2 A0[498D]                	mov	al,[ASCII]
 28253 00003EE5 08C0                    	or	al,al
 28254 00003EE7 C3                      	retn
 28255                                  
 28256                                  ; =============== S U B	R O U T	I N E =======================================
 28257                                  
 28258                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28259                                  BUILDDEST:
 28260 00003EE8 803E[288C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 28261 00003EED 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 28262 00003EEF BF[8789]                	mov	di,USERDIR1
 28263 00003EF2 BD[288C]                	mov	bp,DestVars
 28264 00003EF5 E8DF00                  	call	BUILDPATH
 28265 00003EF8 E884E5                  	call	RestUDir1
 28266                                  
 28267                                  ;	We now know all about the destination
 28268                                  
 28269                                  KNOWABOUTDEST:
 28270 00003EFB 30C0                    	xor	al,al
 28271 00003EFD 8606[878C]              	xchg	al,[FIRSTDEST]
 28272 00003F01 08C0                    	or	al,al
 28273 00003F03 7503                    	jnz	short FIRSTDST
 28274 00003F05 E98C00                  	jmp	NOFIRSTDEST
 28275                                  
 28276                                  FIRSTDST:
 28277                                  ;	Create an fcb of the original dest.
 28278                                  
 28279 00003F08 8B36[2A8C]              	mov	si,[DestTail]
 28280 00003F0C BF[678B]                	mov	di,DestFcb
 28281 00003F0F B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 28282 00003F12 CD21                    	int	21h		; DOS -	PARSE FILENAME
 28283                                  				; DS:SI	-> string to parse
 28284                                  				; ES:DI	-> buffer to fill with unopened	FCB
 28285                                  				; AL = bit mask	to control parsing
 28286 00003F14 803C00                  	cmp	byte [si],0
 28287 00003F17 7406                    	jz	short GOODPARSE
 28288                                  
 28289                                  	; 27/03/2023	
 28290                                  	; MSDOS 6.0
 28291                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 28292                                  	
 28293 00003F19 BA[167F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 28294 00003F1C E953FF                  	jmp	COPYERR			;AN052;
 28295                                  GOODPARSE:
 28296 00003F1F A1[2D8C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 28297 00003F22 80FC3A                  	cmp	ah,':'
 28298 00003F25 7402                    	jz	short DRVSPEC4
 28299 00003F27 B040                    	mov	al,'@'  ; 40h
 28300                                  DRVSPEC4:
 28301                                  ;	AX = "d:" for following FCB drive computation
 28302                                  
 28303 00003F29 8A0E[498D]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 28304 00003F2D 0C20                    	or	al,20h
 28305 00003F2F 2C60                    	sub	al,60h
 28306 00003F31 A2[678B]                	mov	[DestFcb],al		; store drive # in FCB
 28307                                  
 28308                                  ;*	Figure out what copy mode we're in.
 28309                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 28310                                  ;	+n stands for additional sources delimited by +'s.
 28311                                  ;
 28312                                  ;	copy a b	not concatenating
 28313                                  ;	copy a *	not concatenating
 28314                                  ;	copy * a	concatenating
 28315                                  ;	copy * *	not concatenating
 28316                                  ;	copy a+n b	concatenating
 28317                                  ;	copy *+n a	concatenating
 28318                                  ;	copy *+n *	concatenating, Mel Hallerman style
 28319                                  
 28320                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28321                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28322                                  
 28323 00003F34 A0[2C8C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28324 00003F37 8A26[8F8C]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28325 00003F3B 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28326 00003F3E 08C0                    	or	al,al
 28327 00003F40 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28328                                  
 28329                                  ;	Destination is wildcarded.
 28330                                  	
 28331 00003F42 38E0                    	cmp	al,ah
 28332 00003F44 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28333                                  
 28334                                  ;	Source and destination are both wildcarded.
 28335                                  
 28336 00003F46 803E[4A8D]00            	cmp	byte [PLUS],0
 28337 00003F4B 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28338                                  
 28339                                  ;	Source and destination are wildcarded, and source includes +'s.
 28340                                  ;	It's Mel Hallorman copy time.
 28341                                  
 28342 00003F4D FE06[888C]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28343 00003F51 30C0                    	xor	al,al
 28344 00003F53 EB06                    	jmp	short SETCONC
 28345                                  
 28346                                  NOTMELCOPY:
 28347 00003F55 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28348 00003F57 20E0                    	and	al,ah
 28349 00003F59 D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28350                                  					;   (implies concatenation)
 28351                                  SETCONC:
 28352 00003F5B 0A06[4A8D]              	or	al,[PLUS]		; "+" always infers concatenation
 28353                                  
 28354                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28355                                  
 28356 00003F5F A2[B88A]                	mov	[Concat],al
 28357 00003F62 D0E0                    	shl	al,1
 28358 00003F64 D0E0                    	shl	al,1
 28359 00003F66 A2[438D]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28360 00003F69 803E[458D]00            	cmp	byte [BINARY],0
 28361 00003F6E 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy
 28362                                  
 28363 00003F70 A2[498D]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode
 28364 00003F73 08C9                    	or	cl,cl
 28365 00003F75 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly
 28366 00003F77 08C0                    	or	al,al
 28367 00003F79 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28368                                  
 28369                                  ;	At this point there may already be binary read data in the read
 28370                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28371                                  ;	amount of data in the buffer correctly.
 28372                                  
 28373 00003F7B 8B0E[C68A]              	mov	cx,[NXTADD]
 28374 00003F7F E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28375 00003F81 B01A                    	mov	al,1Ah
 28376 00003F83 06                      	push	es
 28377 00003F84 31FF                    	xor	di,di
 28378 00003F86 8E06[A78A]              	mov	es,[TPA]
 28379 00003F8A F2AE                    	repne	scasb			; scan for EOF
 28380 00003F8C 07                      	pop	es
 28381 00003F8D 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28382 00003F8F 4F                      	dec	di			; point at ^z
 28383 00003F90 893E[C68A]              	mov	[NXTADD],di		; new buffer length
 28384                                  
 28385                                  NOFIRSTDEST:
 28386 00003F94 BB[AB8B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28387 00003F97 803E[B88A]00            	cmp	byte [Concat],0
 28388 00003F9C 7403                    	jz	short GOTCHRSRC		; Not a concat
 28389 00003F9E BB[F18B]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28390                                  GOTCHRSRC:
 28391 00003FA1 BE[688B]                	mov	si,DestFcb+1		; Original dest name
 28392 00003FA4 8B3E[2A8C]              	mov	di,[DestTail]		; Where to put result
 28393                                  
 28394                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28395                                  
 28396                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28397                                  BUILDNAME:
 28398 00003FA8 B90800                  	mov	cx,8
 28399                                  BUILDMAIN:
 28400 00003FAB AC                      	lodsb
 28401 00003FAC 3C3F                    	cmp	al,'?'
 28402 00003FAE 7502                    	jne	short NOTAMBIG
 28403 00003FB0 8A07                    	mov	al,[bx]
 28404                                  NOTAMBIG:
 28405 00003FB2 3C20                    	cmp	al,' '
 28406 00003FB4 7401                    	je	short NOSTORE
 28407 00003FB6 AA                      	stosb
 28408                                  NOSTORE:
 28409 00003FB7 43                      	inc	bx
 28410 00003FB8 E2F1                    	loop	BUILDMAIN
 28411 00003FBA B103                    	mov	cl,3
 28412                                  	;mov	al,' ' ; 20h
 28413                                  	;cmp	[si],al
 28414                                  	; 27/03/2023
 28415 00003FBC 803C20                  	cmp	byte [si],20h ; ' '
 28416 00003FBF 7412                    	je	short ENDDEST		; No extension
 28417                                  	;mov	al,[DOT_CHR]
 28418                                  	; 27/03/2023
 28419 00003FC1 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28420 00003FC3 AA                      	stosb
 28421                                  BUILDEXT:
 28422 00003FC4 AC                      	lodsb
 28423 00003FC5 3C3F                    	cmp	al,'?'
 28424 00003FC7 7502                    	jne	short NOTAMBIGE
 28425 00003FC9 8A07                    	mov	al,[bx]
 28426                                  NOTAMBIGE:
 28427 00003FCB 3C20                    	cmp	al,' '
 28428 00003FCD 7401                    	je	short NOSTOREE
 28429 00003FCF AA                      	stosb
 28430                                  NOSTOREE:
 28431 00003FD0 43                      	inc	bx
 28432 00003FD1 E2F1                    	loop	BUILDEXT
 28433                                  ENDDEST:
 28434 00003FD3 30C0                    	xor	al,al
 28435 00003FD5 AA                      	stosb				; NUL terminate
 28436 00003FD6 C3                      	retn
 28437                                  
 28438                                  ; =============== S U B	R O U T	I N E =======================================
 28439                                  	
 28440                                  	; 28/03/2023
 28441                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28442                                  BUILDPATH:
 28443 00003FD7 F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 28444 00003FDB 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28445 00003FDD 89EA                    	mov	dx,bp			; Set DX to spec
 28446 00003FDF 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28447                                  
 28448                                  	; 27/03/2023
 28449                                  	; MSDOS 6.0
 28450 00003FE2 57                      	push	di			;AN000;
 28451 00003FE3 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28452                                  	;mov	bx,deny_none|read_open_mode
 28453 00003FE6 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28454 00003FE9 31C9                    	xor	cx,cx			;AN000; no special files
 28455 00003FEB 89D6                    	mov	si,dx			;AN030; get file name offset
 28456                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28457 00003FED BA0101                  	mov	dx,101h
 28458 00003FF0 CD21                    	INT	21h
 28459 00003FF2 5F                      	pop	di			;AN000;
 28460 00003FF3 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28461 00003FF5 E8F8DC                  	call	get_ext_error_number	;AN022; get the extended error
 28462                                  	;cmp	ax,2
 28463 00003FF8 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28464 00003FFB 7423                    	jz	short NOTPFILE		;AN022;
 28465                                  	;cmp	ax,3
 28466 00003FFD 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28467 00004000 741E                    	jz	short NOTPFILE		;AN022;
 28468                                  	;cmp	ax,5
 28469 00004002 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28470 00004005 7419                    	jz	short NOTPFILE		;AN022;
 28471 00004007 E929DA                  	jmp	extend_setup		;AN022; exit with error
 28472                                  
 28473                                  	; 27/03/2023
 28474                                  	; MSDOS 3.3
 28475                                  	;mov	ax,OPEN*256 ; 3D00h
 28476                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28477                                  	;			; DS:DX	-> ASCIZ filename
 28478                                  	;			; AL = access mode
 28479                                  	;			; 0 - read
 28480                                  	;jc	short NOTPFILE
 28481                                  
 28482                                  PURE_FILE:
 28483 0000400A 89C3                    	mov	bx,ax
 28484 0000400C B80044                  	mov	ax,IOCTL*256 ; 4400h
 28485 0000400F CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28486                                  				; BX = file or device handle
 28487 00004011 B43E                    	mov	ah,CLOSE ;3Eh
 28488 00004013 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28489                                  				; BX = file handle
 28490                                  	; 18/04/2023
 28491 00004015 F6C280                  	test	dl,80h
 28492                                  	;test	dl,devid_ISDEV ; test dl,80h
 28493 00004018 7553                    	jnz	short ISADEV
 28494 0000401A F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28495 0000401E 744D                    	jz	short ISADEV
 28496                                  NOTPFILE:
 28497 00004020 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28498                                  	
 28499                                  	; 27/03/2023
 28500                                  	; MSDOS 6.0
 28501 00004023 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28502 00004026 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28503                                  
 28504 00004028 80FE3A                  	cmp	dh,':'
 28505 0000402B 7402                    	je	short DRVSPEC5
 28506                                  SET_DRIVE_SPEC:
 28507 0000402D B240                    	mov	dl,'@' ; 40h
 28508                                  DRVSPEC5:
 28509 0000402F 80CA20                  	or	dl,20h
 28510 00004032 80EA60                  	sub	dl,60h		; A = 1
 28511 00004035 E874E5                  	call	SAVUDIR1
 28512                                  	
 28513                                  	; 27/03/2023
 28514                                  	; MSDOS 6.0
 28515 00004038 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28516 0000403A E8B3DC                  	call	get_ext_error_number	;AN022; get the extended error
 28517 0000403D E9F3D9                  	jmp	extend_setup		;AN022; exit with error
 28518                                  
 28519                                  CURDIR_OK:
 28520 00004040 89EA                    	mov	dx,bp
 28521                                  	;add	dx,5
 28522 00004042 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28523                                  	;mov	bh,[bp+4]
 28524 00004045 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28525 00004048 80E706                  	and	bh,6
 28526 0000404B 80FF06                  	cmp	bh,6			; Ambig and path ?
 28527 0000404E 7518                    	jne	short CHECKAMB		; jmp if no
 28528                                  	;mov	si,[bp+2]
 28529 00004050 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28530 00004053 B33A                    	mov	bl,':'
 28531 00004055 385CFE                  	cmp	[si-2],bl
 28532 00004058 7506                    	jne	short KNOWNOTSPEC
 28533                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28534                                  					; Know is d:/file
 28535                                  	;mov	byte [bp+0],2
 28536 0000405A C6460002                	mov	byte [bp],2
 28537 0000405E EB05                    	jmp	short DOPCDJ
 28538                                  KNOWNOTSPEC:
 28539                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28540                                  					; Know is path/file
 28541                                  	;mov	byte [bp+0],1
 28542 00004060 C6460001                	mov	byte [bp],1
 28543 00004064 4E                      	dec	si
 28544                                  DOPCDJ:
 28545 00004065 E98300                  	jmp	DOPCD
 28546                                  CHECKAMB:
 28547 00004068 80FF02                  	cmp	bh,2
 28548 0000406B 7505                    	jnz	short CHECKCD
 28549                                  ISSIMPFILE:
 28550                                  ISADEV:
 28551                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28552                                  	;mov	byte [bp+0],0
 28553 0000406D C6460000                	mov	byte [bp],0
 28554 00004071 C3                      	retn
 28555                                  CHECKCD:
 28556 00004072 E86AEC                  	call	SetRest1
 28557 00004075 B43B                    	mov	ah,CHDir ; 3Bh
 28558 00004077 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28559                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28560 00004079 7239                    	jb	short NOTPDIR
 28561 0000407B 89D7                    	mov	di,dx
 28562 0000407D 31C0                    	xor	ax,ax
 28563 0000407F 89C1                    	mov	cx,ax
 28564 00004081 49                      	dec	cx
 28565                                  	; 14/06/2023
 28566                                  	;repne	scasb	 ; MSDOS 3.3
 28567                                  
 28568                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28569                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28570                                  	; MSDOS 6.0
 28571                                  Kloop:					;AN000;  3/3/KK
 28572 00004082 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28573 00004085 47                      	inc	di			;AN000;  3/3/KK
 28574 00004086 08C0                    	or	al,al			;AN000;  3/3/KK
 28575 00004088 740C                    	jz	short DONE		;AN000;  3/3/KK
 28576 0000408A 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28577 0000408C E82EE3                  	call	testkanj		;AN000;  3/3/KK
 28578 0000408F 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28579 00004091 47                      	inc	di			;AN000;  3/3/KK
 28580 00004092 FEC4                    	inc	ah			;AN000;  3/3/KK
 28581 00004094 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28582                                  DONE:
 28583 00004096 4F                      	dec	di
 28584 00004097 A0[AA8A]                	mov	al,[DIRCHAR]
 28585                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28586                                  	;mov	byte [bp+0],2
 28587 0000409A C6460002                	mov	byte [bp],2
 28588                                  	; 27/03/2023
 28589                                  	; MSDOS 6.0
 28590 0000409E 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28591 000040A0 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK
 28592                                  					;this is the trailing byte of ECS code
 28593                                  	;
 28594 000040A2 3A45FF                  	cmp	al,[di-1]
 28595 000040A5 7405                    	jz	short GOTSRCSLSH
 28596                                  _STORE_PCHAR:
 28597 000040A7 AA                      	stosb
 28598                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28599                                  	;mov	byte [bp+0],1
 28600 000040A8 C6460001                	mov	byte [bp],1
 28601                                  GOTSRCSLSH:
 28602                                  	;or	byte [bp+4],6
 28603 000040AC 804E0406                	or 	byte [bp+VARSTRUC.INFO],6
 28604 000040B0 E87400                  	call	SETSTARS
 28605                                  NOTPDIR_RETN:
 28606 000040B3 C3                      	retn
 28607                                  
 28608                                  	; 28/03/2023
 28609                                  NOTPDIR:
 28610                                  	; MSDOS 6.0
 28611 000040B4 E839DC                  	call	get_ext_error_number	;AN022; get the extended error
 28612                                  	;cmp	ax,3
 28613 000040B7 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28614 000040BA 7405                    	je	short NOTPDIR_TRY	;AN022;
 28615                                  	;cmp	ax,5
 28616 000040BC 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28617 000040BF 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28618                                  NOTPDIR_TRY:
 28619                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28620                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28621                                  	;mov	byte [bp+0],0
 28622 000040C1 C6460000                	mov	byte [bp],0
 28623                                  	;mov	bh,[bp+4]
 28624 000040C5 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28625 000040C8 F6C704                  	test	bh,4
 28626 000040CB 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28627                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28628                                  	;mov	byte [bp+0],2
 28629 000040CD C6460002                	mov	byte [bp],2
 28630                                  	;mov	si,[bp+2]
 28631 000040D1 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28632 000040D4 803C00                  	cmp	byte [si],0
 28633 000040D7 744B                    	je	short BADCDERRJ2	; Trailing '/'
 28634                                  	;mov	bl,[DOT_CHR]
 28635                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28636                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28637 000040D9 B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28638 000040DB 381C                    	cmp	[si],bl
 28639 000040DD 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28640 000040DF B33A                    	mov	bl,':'  ; 3Ah
 28641 000040E1 385CFE                  	cmp	[si-2],bl
 28642 000040E4 7405                    	je	short DOPCD		; Know d:/file
 28643                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28644                                  					; Know path/file
 28645                                  	;mov	byte [bp+0],1
 28646 000040E6 C6460001                	mov	byte [bp],1
 28647 000040EA 4E                      	dec	si			; Point at last '/'
 28648                                  DOPCD:
 28649 000040EB 30DB                    	xor	bl,bl
 28650 000040ED 861C                    	xchg	bl,[si]			; Stick in a NUL
 28651 000040EF E8EDEB                  	call	SetRest1
 28652                                  
 28653                                  	; 28/03/2023
 28654                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28655 000040F2 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28656 000040F4 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28657 000040F6 56                      	push	si			;AN000;  3/3/KK
 28658 000040F7 51                      	push	cx			;AN000;  3/3/KK
 28659 000040F8 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28660 000040FA 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28661                                  Kloop2: 				;AN000;  3/3/KK
 28662 000040FC AC                      	lodsb				;AN000;  3/3/KK
 28663 000040FD E8BDE2                  	call	testkanj		;AN000;  3/3/KK
 28664 00004100 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28665 00004102 AC                      	lodsb				;AN000;  3/3/KK
 28666 00004103 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28667 00004105 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28668 00004107 59                      	pop	cx			;AN000;  3/3/KK
 28669 00004108 5E                      	pop	si			;AN000;  3/3/KK
 28670 00004109 EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28671                                  					;		 trailing path sep
 28672                                  NotKanj4:				;AN000;  3/3/KK
 28673 0000410B 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28674 0000410D 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28675 0000410F 59                      	pop	cx			;AN000;  3/3/KK
 28676 00004110 5E                      	pop	si			;AN000;  3/3/KK
 28677                                  LookBack:				;AN000;  3/3/KK
 28678                                  	; 28/03/2023
 28679                                  	; MSDOS 3.3 & MSDOS 6.0
 28680 00004111 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28681 00004114 740E                    	je	short BADCDERRJ2
 28682                                  DoCdr:
 28683 00004116 B43B                    	mov	ah,CHDir ; 3Bh
 28684 00004118 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28685                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28686 0000411A 861C                    	xchg	bl,[si]
 28687 0000411C 7395                    	jnc	short NOTPDIR_RETN
 28688                                  	
 28689                                  	; 28/03/2023
 28690                                  	; MSDOS 3.3
 28691                                  ;BADCDERRJ2:
 28692                                  	;stc
 28693                                  	;jmp	BADCDERR
 28694                                  
 28695                                  	; 28/03/2023
 28696                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28697 0000411E E8CFDB                  	call	get_ext_error_number	;AN022; get the extended error
 28698                                  EXTEND_SETUPJ:				;AN022;
 28699 00004121 E90FD9                  	jmp	extend_setup		;AN022; go issue the error message
 28700                                  BADCDERRJ2:
 28701 00004124 E909D9                  	jmp	badpath_err		;AC022; go issue path not found message
 28702                                  
 28703                                  ; =============== S U B	R O U T	I N E =======================================
 28704                                  
 28705                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28706                                  SETSTARS:
 28707                                  	;mov	[bp+2],di
 28708 00004127 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28709                                  	;add	byte [bp+1],12
 28710 0000412A 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28711                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28712                                  	; 28/03/2023
 28713                                  	; MSDOS 6.0
 28714 0000412E B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28715                                  	;mov	ax,'?.' ; dot_qmark
 28716                                  
 28717 00004131 B90800                  	mov	cx,8
 28718 00004134 F3AA                    	rep	stosb
 28719 00004136 86C4                    	xchg	al,ah
 28720 00004138 AA                      	stosb
 28721 00004139 86C4                    	xchg	al,ah
 28722 0000413B B103                    	mov	cl,3
 28723 0000413D F3AA                    	rep	stosb
 28724 0000413F 30C0                    	xor	al,al
 28725 00004141 AA                      	stosb
 28726 00004142 C3                      	retn
 28727                                  
 28728                                  ; =============== S U B	R O U T	I N E =======================================
 28729                                  
 28730                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28731                                  COMPNAME:
 28732 00004143 BE[2D8C]                	mov	si,DestBuf	; do name translate of target
 28733 00004146 BF[2A88]                	mov	di,TRGXNAME	; save for name comparison
 28734 00004149 B460                    	mov	ah,xNameTrans ; 60h
 28735 0000414B CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28736                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28737                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28738 0000414D BE[D387]                	mov	si,SRCXNAME	; get name translate of source
 28739 00004150 BF[2A88]                	mov	di,TRGXNAME	; get name translate of target
 28740                                  	;call	STRCOMP
 28741                                  	;retn
 28742                                  	; 28/03/2023
 28743 00004153 E9C8E4                  	jmp	STRCOMP
 28744                                  
 28745                                  ;============================================================================
 28746                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28747                                  ;============================================================================
 28748                                  ; 30/09/2018 - Retro DOS v3.0
 28749                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28750                                  
 28751                                  ;-----------------------------------------------------------------------;
 28752                                  ; ENTRY:								;
 28753                                  ;	DS:SI	Points input buffer					;
 28754                                  ;	ES:DI	Points to the token buffer				;
 28755                                  ;	BL	Special delimiter for this call 			;
 28756                                  ;		    Always checked last 				;
 28757                                  ;		    set it to space if there is no special delimiter	;
 28758                                  ; EXIT: 								;
 28759                                  ;	DS:SI	Points to next char in the input buffer 		;
 28760                                  ;	ES:DI	Points to the token buffer				;
 28761                                  ;	[STARTEL] Points to start of last element of path in token	;
 28762                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28763                                  ;	CX	Character count 					;
 28764                                  ;	BH	Condition Code						;
 28765                                  ;			Bit 1H of BH set if switch character		;
 28766                                  ;				Token buffer contains char after	;
 28767                                  ;				switch character			;
 28768                                  ;				BP has switch bits set (ORing only)	;
 28769                                  ;			Bit 2H of BH set if ? or * in token		;
 28770                                  ;				if * found element ? filled		;
 28771                                  ;			Bit 4H of BH set if path sep in token		;
 28772                                  ;			Bit 80H of BH set if the special delimiter	;
 28773                                  ;			   was skipped at the start of this token	;
 28774                                  ;		Token buffer always starts d: for non switch tokens	;
 28775                                  ;	CARRY SET							;
 28776                                  ;	    if CR on input						;
 28777                                  ;		token buffer not altered				;
 28778                                  ;									;
 28779                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28780                                  ; MODIFIES:								;
 28781                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28782                                  ;									;
 28783                                  ;-----------------------------------------------------------------------;
 28784                                  
 28785                                  ; Modifications to cparse: recognition of right and left parentheses
 28786                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28787                                  ;
 28788                                  ; Both modifications were installed in the course of adding a coherent
 28789                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28790                                  ; structure for command-line arguments. This parser relies on cparse to
 28791                                  ; recognize individual tokens.
 28792                                  ;
 28793                                  ; To process for-loops correctly, parentheses must therefore be
 28794                                  ; recognized as tokens. The upper-case conversion code was removed so
 28795                                  ; that commands (such as for and echo) would be able to use the "original"
 28796                                  ; text of the command line.
 28797                                  ;
 28798                                  ; Note also the modification to prevent the automatic conversion of colons
 28799                                  ; into spaces WITHIN THE SOURCE TEXT!
 28800                                  ;
 28801                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28802                                  ; on the command line.
 28803                                  ;
 28804                                  ; Alan L, OS/MSDOS				    14 August 1983
 28805                                  
 28806                                  ; ---------------------------------------------------------------------------
 28807                                  
 28808                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28809                                  
 28810                                  ;FSWITCH	EQU	8000h
 28811                                  ;FBADSWITCH	EQU	4000h
 28812                                  
 28813                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28814                                  
 28815                                  ; =============== S U B	R O U T	I N E =======================================
 28816                                  		
 28817                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28818                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28819                                  
 28820                                  cparse:
 28821 00004156 31C0                    	xor	ax,ax
 28822 00004158 893E[578D]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28823 0000415C A2[5A8D]                	mov	[ELPOS],al		; Start in 8 char prefix
 28824                                  	; MSDOS 3.3
 28825                                  	;mov	[SOURCE],al		
 28826                                  	; MSDOS 6.0
 28827 0000415F A2[5B8D]                	mov	[SKPDEL], al		; No skip delimiter yet
 28828 00004162 88C7                    	mov	bh,al			; Init nothing
 28829 00004164 9C                      	pushf				; save flags
 28830 00004165 57                      	push	di			; save the token buffer addrss
 28831 00004166 31C9                    	xor	cx,cx			; no chars in token buffer
 28832 00004168 880E[068C]              	mov	[comma],cl		; reset comma flag
 28833                                  moredelim:
 28834 0000416C AC                      	lodsb
 28835 0000416D E874E4                  	call	DELIM
 28836 00004170 751D                    	jnz	short SCANCDONE
 28837 00004172 3C20                    	cmp	al,' '
 28838 00004174 74F6                    	jz	short moredelim
 28839 00004176 3C09                    	cmp	al,9
 28840 00004178 74F2                    	jz	short moredelim
 28841                                  	;xchg	al,[SOURCE]
 28842                                  	; 28/03/2023
 28843 0000417A 8606[5B8D]              	xchg	al,[SKPDEL]
 28844 0000417E 08C0                    	or	al,al
 28845 00004180 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28846 00004182 F6C780                  	test	bh,80h			; has a special char been found?
 28847 00004185 7405                    	jz	short no_comma		; no - just exit
 28848 00004187 C606[068C]01            	mov	byte [comma],1		; set comma flag
 28849                                  no_comma:
 28850 0000418C E92A01                  	jmp	x_done			; Nul argument
 28851                                  
 28852                                  SCANCDONE:
 28853                                  	; 28/03/2023
 28854                                  	; MSDOS 6.0
 28855                                  	; -----------------------------------
 28856                                  	; Mod to avoid upper-case conversion.
 28857                                  	; -----------------------------------
 28858                                  	; MSDOS 3.3
 28859                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28860                                  	;jnz	short cpcont1		; 3/3/KK
 28861                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28862                                  cpcont1:
 28863                                  	; -----------------------------------
 28864                                  	; 28/03/2023
 28865 0000418F 38D8                    	cmp	al,bl			; Special delimiter?
 28866 00004191 7505                    	jne	short nospec
 28867 00004193 80CF80                  	or	bh,80h
 28868 00004196 EBD4                    	jmp	short moredelim
 28869                                  nospec:
 28870 00004198 3C0D                    	cmp	al,0Dh			; a CR?
 28871 0000419A 7503                    	jne	short ncperror
 28872 0000419C E91501                  	jmp	cperror
 28873                                  ncperror:
 28874 0000419F 3A06[A98A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28875 000041A3 7503                    	jne	short na_switch		; yes, process...
 28876 000041A5 E91401                  	jmp	a_switch
 28877                                  na_switch:
 28878 000041A8 B23A                    	mov	dl,':'
 28879 000041AA 3814                    	cmp	[si],dl
 28880 000041AC 751D                    	jne	short anum_chard	; Drive not specified
 28881                                  	; 28/03/2023
 28882                                  	; MSDOS 6.0 
 28883 000041AE 803E[158C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28884 000041B3 7503                    	jne	short cpcont2		; 3/3/KK
 28885 000041B5 E82FE2                  	call	UPCONV			; 3/3/KK
 28886                                  cpcont2:
 28887 000041B8 E85901                  	call	move_char
 28888 000041BB AC                      	lodsb				; Get the ':'
 28889 000041BC E85501                  	call	move_char
 28890 000041BF 893E[578D]              	mov	[STARTEL],di
 28891 000041C3 C606[598D]00            	mov	byte [ELCNT],0
 28892 000041C8 E9B300                  	jmp	anum_test
 28893                                  anum_chard:
 28894 000041CB 893E[578D]              	mov	[STARTEL],di
 28895 000041CF C606[598D]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28896 000041D4 803E[158C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28897 000041D9 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28898 000041DB E88CE4                  	call	pathchrcmp		; Starts with a pathchar?
 28899 000041DE 7518                    	jnz	short anum_char		; no
 28900 000041E0 50                      	push	ax
 28901 000041E1 A0[B78A]                	mov	al,[CURDRV]		; Insert drive spec
 28902                                  	;add	al,[CAPITAL_A]
 28903                                  	; 28/03/2023
 28904                                  	; MSDOS 6.0
 28905 000041E4 0441                    	add	al,'A' ; 41h
 28906 000041E6 E82B01                  	call	move_char
 28907 000041E9 B03A                    	mov	al,':' ; 3Ah
 28908 000041EB E82601                  	call	move_char
 28909 000041EE 58                      	pop	ax
 28910 000041EF 893E[578D]              	mov	[STARTEL],di
 28911 000041F3 C606[598D]00            	mov	byte [ELCNT],0
 28912                                  anum_char:
 28913                                  	; 28/03/2023
 28914                                  	; MSDOS 6.0
 28915 000041F8 E8C2E1                  	call	testkanj		;AC048			
 28916 000041FB 7406                    	jz	short NOTKANJ		;AC048;
 28917 000041FD E81401                  	call	move_char
 28918 00004200 AC                      	lodsb
 28919 00004201 EB78                    	jmp	short notspecial
 28920                                  
 28921                                  NOTKANJ:				;AN048; If not kanji
 28922 00004203 803E[158C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28923 00004208 7503                    	jne	short TESTDOT 		;AN048;
 28924 0000420A E8DAE1                  	call	UPCONV			;AN048; upper case the char
 28925                                  TESTDOT:
 28926                                  	; 28/03/2023
 28927                                  	;cmp	al,dot_chr  ; 2Eh
 28928 0000420D 3C2E                    	cmp	al,'.'
 28929 0000420F 7509                    	jne	short testquest
 28930 00004211 FE06[5A8D]              	inc	byte [ELPOS] 		; flag in extension
 28931 00004215 C606[598D]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28932                                  testquest:
 28933 0000421A 3C3F                    	cmp	al,'?'  ; 3Fh
 28934 0000421C 7503                    	jnz	short testsplat
 28935 0000421E 80CF02                  	or	bh,2
 28936                                  testsplat:
 28937                                  	;cmp	al,[STAR]
 28938 00004221 3C2A                    	cmp	al,star	; 2Ah
 28939                                  	; 27/04/2023
 28940                                  	;cmp	al,'*' 
 28941 00004223 7530                    	jne	short testpath
 28942 00004225 80CF02                  	or	bh,2
 28943 00004228 803E[928D]00            	cmp	byte [expand_star],0
 28944 0000422D 7504                    	jne	short expand_filename
 28945 0000422F EB24                    	jmp	short testpath
 28946                                  
 28947                                  BADPERR2J:
 28948                                  	;jmp	BADPERR2
 28949                                  	; 28/03/2023
 28950                                  	; MSDOS 6.0
 28951 00004231 EB75                    	jmp	short BADPERR2
 28952                                  
 28953                                  expand_filename:
 28954 00004233 B407                    	mov	ah,7
 28955 00004235 803E[5A8D]00            	cmp	byte [ELPOS],0
 28956 0000423A 7402                    	jz	short gotelcnt
 28957 0000423C B402                    	mov	ah,2
 28958                                  gotelcnt:
 28959 0000423E B03F                    	mov	al,'?'
 28960 00004240 2A26[598D]              	sub	ah,[ELCNT]
 28961 00004244 72EB                    	jb	short BADPERR2J
 28962 00004246 86E1                    	xchg	ah,cl
 28963 00004248 E309                    	jcxz	testpathx
 28964                                  qmove:
 28965 0000424A 86E1                    	xchg	ah,cl
 28966 0000424C E8C500                  	call	move_char
 28967 0000424F 86E1                    	xchg	ah,cl
 28968 00004251 E2F7                    	loop	qmove
 28969                                  testpathx:
 28970 00004253 86E1                    	xchg	ah,cl
 28971                                  testpath:
 28972 00004255 E812E4                  	call	pathchrcmp
 28973 00004258 7521                    	jnz	short notspecial
 28974 0000425A 80CF04                  	or	bh,4
 28975 0000425D 803E[928D]00            	cmp	byte [expand_star],0
 28976 00004262 7405                    	jz	short no_err_check
 28977 00004264 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28978 00004267 7545                    	jnz	short BADPERR
 28979                                  no_err_check:
 28980 00004269 893E[578D]              	mov	[STARTEL],di	  	; New element
 28981 0000426D FF06[578D]              	inc	word [STARTEL]	  	; Point to char after /
 28982 00004271 C606[598D]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 28983 00004276 C606[5A8D]00            	mov	byte [ELPOS],0
 28984                                  notspecial:
 28985 0000427B E89600                  	call	move_char		; just an alphanum string
 28986                                  anum_test:
 28987 0000427E AC                      	lodsb
 28988                                  
 28989                                  	; 28/03/2023
 28990                                  	; MSDOS 6.0
 28991                                  	; -----------------------------------
 28992                                  	; Mod to avoid upper-case conversion.
 28993                                  	; -----------------------------------
 28994                                  	; MSDOS 3.3
 28995                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28996                                  	;jnz	short cpcont3		; 3/3/KK
 28997                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28998                                  cpcont3:
 28999                                  	; -----------------------------------
 29000                                  
 29001 0000427F E862E3                  	call	DELIM
 29002 00004282 7435                    	jz	short x_done
 29003 00004284 3C0D                    	cmp	al,0Dh
 29004 00004286 7431                    	je	short x_done
 29005 00004288 3A06[A98A]              	cmp	al,[SWITCHAR]
 29006 0000428C 742B                    	je	short x_done
 29007 0000428E 38D8                    	cmp	al,bl
 29008 00004290 7427                    	je	short x_done
 29009 00004292 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 29010                                  	; 28/03/2023
 29011                                  	; MSDOS 3.3
 29012                                  	;jnz	short ANUM_CHARJ 
 29013                                  	; MSDOS 6.0
 29014 00004294 7403                    	je	short FOO15
 29015 00004296 E95FFF                  	jmp	anum_char
 29016                                  
 29017                                  ; Modification made for parseline.
 29018                                  ; Why would it be necessary to change colons to spaces? In this
 29019                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29020                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29021                                  
 29022                                  FOO15:
 29023 00004299 803E[158C]02            	cmp	byte [cpyflag],2
 29024 0000429E 7505                    	jnz	short cpcont4
 29025 000042A0 E87100                  	call	move_char
 29026 000042A3 EBD9                    	jmp	short anum_test
 29027                                  cpcont4:
 29028 000042A5 46                      	inc	si			; Skip the ':'
 29029 000042A6 EB11                    	jmp	short x_done
 29030                                  
 29031                                  	; 28/03/2023
 29032                                  ;ANUM_CHARJ:
 29033                                  	;jmp	anum_char
 29034                                  
 29035                                  BADPERR2:
 29036 000042A8 BA[0D7F]                	mov	dx,BADCPMES_PTR
 29037 000042AB E9A2E6                  	jmp	cerror
 29038                                  
 29039                                  BADPERR:
 29040                                  	; 28/03/2023
 29041                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29042                                  BADCDERR:
 29043                                  	; MSDOS 6.0
 29044 000042AE BA[3780]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29045 000042B1 E99CE6                  	jmp	cerror			;AC022;  message
 29046                                  	
 29047                                  cperror:
 29048 000042B4 4E                      	dec	si			; adjust the pointer
 29049 000042B5 5F                      	pop	di			; retrieve token buffer address
 29050 000042B6 9D                      	popf				; restore flags
 29051 000042B7 F9                      	stc				; set the carry bit
 29052 000042B8 C3                      	retn
 29053                                  
 29054                                  x_done:
 29055 000042B9 4E                      	dec	si			; adjust for next round
 29056                                  
 29057                                  ; Mod to recognize right and left parens as integral tokens.
 29058                                  ;x_done2:
 29059 000042BA EB51                    	jmp	short out_token
 29060                                  
 29061                                  a_switch:
 29062 000042BC 80CF01                  	or	bh,1			; Indicate switch
 29063                                  	;or	bp,FSWITCH ; 8000h
 29064                                  	; 28/03/2023
 29065 000042BF 81CD0080                	or	bp,8000h
 29066 000042C3 E816E3                  	call	scanoff
 29067 000042C6 46                      	inc	si
 29068                                  	; 28/03/2023
 29069                                  	; MSDOS 6.0
 29070 000042C7 E8F3E0                  	call	testkanj		;AN057; See if DBCS lead byte
 29071 000042CA 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29072 000042CC E84500                  	call	move_char		;AN057; DBCS - store first byte
 29073 000042CF AC                      	lodsb				;AN057; get second byte
 29074 000042D0 E84100                  	call	move_char		;AN057; store second byte
 29075                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29076 000042D3 81CD0040                	or	bp,4000h
 29077 000042D7 EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29078                                  a_switch_notkanj:			;AN057;
 29079 000042D9 3C0D                    	cmp	al,0Dh
 29080 000042DB 7509                    	jne	short Store_swt
 29081 000042DD B000                    	mov	al,0
 29082 000042DF AA                      	stosb
 29083                                  	;or	bp,FBADSWITCH ; 4000h
 29084 000042E0 81CD0040                	or	bp,4000h
 29085 000042E4 EBCE                    	jmp	short cperror		; Trailing switch character error
 29086                                  					;   BP = fSwitch but no switch
 29087                                  					;   bit is set (unknown switch)
 29088                                  Store_swt:
 29089 000042E6 E82B00                  	call	move_char		; store the character
 29090                                  
 29091                                  ; This upconv call must stay. It is used to identify copy-switches
 29092                                  ; on the command line, and won't store anything into the output buffer.
 29093                                  
 29094                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29095                                  	; 28/03/2023
 29096 000042E9 E8FBE0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29097                                  	
 29098 000042EC 06                      	push	es
 29099 000042ED 57                      	push	di
 29100 000042EE 51                      	push	cx
 29101 000042EF 0E                      	push	cs
 29102 000042F0 07                      	pop	es
 29103                                  	; 28/03/2023
 29104                                  	; MSDOS 3.3
 29105                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 29106                                  	; MSDOS 6.0
 29107 000042F1 BF[3184]                	mov	di,switch_list ; "?VBAPW"
 29108                                  	; MSDOS 3.3
 29109                                  	;mov	cx,SWCOUNT ; 5
 29110                                  	; MSDOS 6.0
 29111 000042F4 B90600                  	mov	cx,6  ; SWCOUNT = 6
 29112                                  	;or	bp,FBADSWITCH  ; 4000h
 29113 000042F7 81CD0040                	or	bp,4000h
 29114 000042FB F2AE                    	repne	scasb
 29115 000042FD 750B                    	jnz	short out_tokenp
 29116                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29117 000042FF 81E5FFBF                	and	bp,0BFFFh
 29118 00004303 B80100                  	mov	ax,1
 29119 00004306 D3E0                    	shl	ax,cl
 29120 00004308 09C5                    	or	bp,ax
 29121                                  out_tokenp:
 29122 0000430A 59                      	pop	cx
 29123 0000430B 5F                      	pop	di
 29124 0000430C 07                      	pop	es
 29125                                  out_token:
 29126 0000430D B000                    	mov	al,0			; null at the end
 29127 0000430F AA                      	stosb
 29128 00004310 5F                      	pop	di			; restore token buffer pointer
 29129 00004311 9D                      	popf
 29130 00004312 F8                      	clc				; clear carry flag
 29131 00004313 C3                      	retn
 29132                                  
 29133                                  ; =============== S U B	R O U T	I N E =======================================
 29134                                  
 29135                                  	; 28/03/2023
 29136                                  move_char:
 29137 00004314 AA                      	stosb				; store char in token buffer
 29138 00004315 41                      	inc	cx			; increment char count
 29139 00004316 FE06[598D]              	inc	byte [ELCNT]		; increment element count for * substi
 29140 0000431A C3                      	retn
 29141                                  
 29142                                  ;============================================================================
 29143                                  ; PARSE.ASM, MSDOS 6.0, 1991
 29144                                  ;============================================================================
 29145                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29146                                  
 29147                                  ; -----------------------------
 29148                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 29149                                  ; -----------------------------
 29150                                  
 29151                                  ;**** Equation field
 29152                                  ;-------- Character code definition
 29153                                  
 29154                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 29155                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 29156                                  $P_Period	   equ	"."             ;AN020;
 29157                                  $P_Slash	   equ	"/"             ;AN020;
 29158                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 29159                                  $P_Comma	   equ	","             ;AN000;
 29160                                  $P_Switch	   equ	"/"             ;AN000;
 29161                                  $P_Keyword	   equ	"="             ;AN000;
 29162                                  $P_Colon	   equ	":"             ;AN000;
 29163                                  $P_Plus 	   equ	"+"             ;AN000;
 29164                                  $P_Minus	   equ	"-"             ;AN000;
 29165                                  $P_Rparen	   equ	")"             ;AN000;
 29166                                  $P_Lparen	   equ	"("             ;AN000;
 29167                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 29168                                  $P_DQuote	   equ	'"'             ;AN000;
 29169                                  $P_NULL 	   equ	0		;AN000;
 29170                                  $P_TAB		   equ	9		;AN000;
 29171                                  $P_CR		   equ	0Dh		;AN000;
 29172                                  $P_LF		   equ	0Ah		;AN000;
 29173                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 29174                                  
 29175                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 29176                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 29177                                  
 29178                                  $P_error_filespec  equ  1
 29179                                  
 29180                                  ;----------------------------------------------------------------------------
 29181                                  ; PARMS LABEL	BYTE
 29182                                  ;	DW	PARMSX
 29183                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 29184                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29185                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 29186                                  ;				; TYPICAL ARE ";", "="
 29187                                  ;				; "," & WHITESPACE ALWAYS
 29188                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29189                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 29190                                  ;----------------------------------------------------------------------------
 29191                                  
 29192                                  struc $P_PARMS_BLK			;AN000;
 29193 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 29194 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 29195 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 29196                                  endstruc 				;AN000;
 29197                                  
 29198                                  $P_Len_PARMS	   equ	4		;AN000;
 29199                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 29200                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 29201                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 29202                                  
 29203                                  ;----------------------------------------------------------------------------
 29204                                  ; PARMSX LABEL	BYTE
 29205                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 29206                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 29207                                  ;	:				; REPEATS maxp-1 TIMES
 29208                                  ;	DB	maxs			; # OF SWITCHES
 29209                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 29210                                  ;	:				; REPEATS maxs-1 TIMES
 29211                                  ;	DB	maxk			; # OF KEYWORD
 29212                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 29213                                  ;	:				; REPEATS maxk-1 TIMES
 29214                                  ;----------------------------------------------------------------------------
 29215                                  
 29216                                  struc $P_PARMSX_BLK			;AN000;
 29217 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 29218 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 29219 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 29220                                  endstruc				;AN000;
 29221                                  
 29222                                  ; 31/03/2023
 29223                                  ;----------------------------------------------------------------------------
 29224                                  ; << Control field definition >>
 29225                                  ;
 29226                                  ;CONTROL   LABEL   BYTE
 29227                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 29228                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 29229                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 29230                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 29231                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 29232                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 29233                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 29234                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 29235                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 29236                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 29237                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 29238                                  ;				; 0002H=REPEATS ALLOWED
 29239                                  ;				; 0001H=OPTIONAL
 29240                                  ;	   DW FUNCTION_FLAGS
 29241                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 29242                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 29243                                  ;				; 0010H=REMOVE ":" AT END
 29244                                  ; (tm10)			; 0020H=colon is not necessary for switch
 29245                                  ;
 29246                                  ;	   DW RESULT		; RESULT BUFFER
 29247                                  ;	   DW VALUES		; VALUE LISTS
 29248                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 29249                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 29250                                  ;	   :
 29251                                  ;
 29252                                  ;Note:
 29253                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 29254                                  ;      DATE bit simalteniously.
 29255                                  ;
 29256                                  ;      The parser examins each bit along with the following priority.
 29257                                  ;
 29258                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 29259                                  ;      FILE SPEC -> SIMPLE STRING.
 29260                                  ;
 29261                                  ;
 29262                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 29263                                  ;      in the result buffer is capitalized.
 29264                                  ;
 29265                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 29266                                  ;
 29267                                  ;
 29268                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 29269                                  ;      switch, for example, '/A', then STRING points to;
 29270                                  ;
 29271                                  ;		DB    1 	; number of following synonyms
 29272                                  ;		DB   '/A',0
 29273                                  ;
 29274                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 29275                                  ;
 29276                                  ;		DB    1 	; number of following synonyms
 29277                                  ;		DB   'CODEPAGE=',0
 29278                                  ;
 29279                                  ;
 29280                                  ;    - "..." must consist of upper case characters only because the parser
 29281                                  ;      performs pattern matching after converting input to upper case (by
 29282                                  ;      using the current country upper case table)
 29283                                  ;
 29284                                  ;
 29285                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 29286                                  ;      example /A and /B, the format will be;
 29287                                  ;
 29288                                  ;		DB    2 	; number of following synonyms
 29289                                  ;		DB    '/A',0
 29290                                  ;		DB    '/B',0
 29291                                  ;----------------------------------------------------------------------------
 29292                                  
 29293                                  ;**** Match_Flags
 29294                                  
 29295                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 29296                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 29297                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 29298                                  $P_Date_S	   equ	1000h		;AN000; Date string
 29299                                  $P_Time_S	   equ	0800h		;AN000; Time string
 29300                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 29301                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 29302                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 29303                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 29304                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 29305                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 29306                                  $P_Optional	   equ	0001h		;AN000; Optional
 29307                                  
 29308                                  ;**** Function flags
 29309                                  
 29310                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 29311                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 29312                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 29313                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 29314                                  
 29315                                  ;-------------------------------- Control block structure
 29316                                  struc $P_CONTROL_BLK
 29317 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 29318 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 29319 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 29320 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 29321 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 29322 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29323                                  endstruc
 29324                                  
 29325                                  ; 31/03/2023
 29326                                  ;----------------------------------------------------------------------------
 29327                                  ;
 29328                                  ;VALUES LABEL	BYTE
 29329                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29330                                  ;	+-
 29331                                  ;	| DB	nrng		; NUMBER OF RANGES
 29332                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29333                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29334                                  ;	|	:
 29335                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29336                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29337                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29338                                  ;	|	:
 29339                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29340                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29341                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29342                                  ;	+-	:
 29343                                  ;
 29344                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29345                                  ;
 29346                                  ;Note:
 29347                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29348                                  ;      when no choice lists are provided.
 29349                                  ;
 29350                                  ;    - STRING must consist of upper case characters only because the parser
 29351                                  ;      performs pattern matching after converting input to upper case (by
 29352                                  ;      using the current country upper case table)
 29353                                  ;----------------------------------------------------------------------------
 29354                                  
 29355                                  $P_nval_None	equ 0		;AN000; no value list ID
 29356                                  $P_nval_Range	equ 1		;AN000; range list ID
 29357                                  $P_nval_Value	equ 2		;AN000; value list ID
 29358                                  $P_nval_String	equ 3		;AN000; string list ID
 29359                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29360                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29361                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29362                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29363                                  
 29364                                  struc $P_VAL_LIST
 29365 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29366 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29367 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29368 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29369 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29370                                  endstruc
 29371                                  
 29372                                  ; 31/03/2023
 29373                                  ;----------------------------------------------------------------------------
 29374                                  ;
 29375                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29376                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29377                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29378                                  ;					;	3=STRING, 4=COMPLEX,
 29379                                  ;					;	5=FILESPEC, 6=DRIVE
 29380                                  ;					;	7=DATE, 8=TIME
 29381                                  ;					;	9=QUOTED STRING
 29382                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29383                                  ;
 29384                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29385                                  ;
 29386                                  ;       +-
 29387                                  ;       | DD	n			; VALUE IF NUMBER
 29388                                  ;       | or
 29389                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29390                                  ;       |				; (ES presents Segment address)
 29391                                  ;       | or
 29392                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29393                                  ;       | or
 29394                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29395                                  ;       | or
 29396                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29397                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29398                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29399                                  ;       | or
 29400                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29401                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29402                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29403                                  ;       |	DB HUNDREDTHS ;(0-99)
 29404                                  ;       +-
 29405                                  ;
 29406                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29407                                  ;      list.
 29408                                  ;
 29409                                  ;      YEAR: If the input value for the year is less than 100, parser
 29410                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 29411                                  ;	     the year value, he returns 1987.
 29412                                  ;----------------------------------------------------------------------------
 29413                                  
 29414                                  ;-------------------------------- Result block structure
 29415                                  struc $P_RESULT_BLK;
 29416 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 29417 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 29418 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 29419 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 29420                                  endstruc
 29421                                  
 29422                                  ;**** values for the type field in the result block
 29423                                  
 29424                                  $P_EOL		 equ 0		;AN000; End of line
 29425                                  $P_Number	 equ 1		;AN000; Number
 29426                                  $P_List_Idx	 equ 2		;AN000; List Index
 29427                                  $P_String	 equ 3		;AN000; String
 29428                                  $P_Complex	 equ 4		;AN000; Complex
 29429                                  $P_File_Spec	 equ 5		;AN000; File Spec
 29430                                  $P_Drive	 equ 6		;AN000; Drive
 29431                                  $P_Date_F	 equ 7		;AN000; Date
 29432                                  $P_Time_F	 equ 8		;AN000; Time
 29433                                  $P_Quoted_String equ 9		;AN000; Quoted String
 29434                                  
 29435                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 29436                                  
 29437                                  ;**** Return code
 29438                                  ;
 29439                                  ; following return code will be returned in the AX register.
 29440                                  
 29441                                  $P_No_Error	 equ 0		;AN000; No error
 29442                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 29443                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 29444                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 29445                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 29446                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29447                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29448                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29449                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29450                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29451                                  
 29452                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29453                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29454                                  $P_Neg		 equ 02h	;AN000; Negative value
 29455                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29456                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29457                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29458                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29459                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29460                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29461                                  
 29462                                  ;-------- Masks
 29463                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29464                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29465                                  
 29466                                  ;-------------
 29467                                  
 29468                                  struc $P_DOS_TBL
 29469 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29470 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29471 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29472                                  endstruc
 29473                                  
 29474                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29475                                  				;AN000; following parameters are set
 29476                                  				;AN000; to get casemap table.
 29477                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29478                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29479                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29480                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29481                                  				; By this call following information
 29482                                  				; is returned.
 29483                                  
 29484                                  ; 03/04/2023
 29485                                  ;-------------------------------- country dependent information
 29486                                  
 29487                                  $P_DOS_Get_CDI	equ 3800h
 29488                                  
 29489                                  struc $P_CDI
 29490 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29491 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29492 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29493 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29494 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29495 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29496 0000000E ??                      		resb 1		;AN000;
 29497 0000000F ??                      		resb 1		;AN000;
 29498 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29499 00000011 ????????                		resw 2		;AN000;
 29500 00000015 ????                    		resb 2		;AN000;
 29501 00000017 <res Ah>                		resw 5		;AN000;
 29502                                  endstruc
 29503                                  
 29504                                  $P_Date_MDY	equ 0		;AN000;
 29505                                  $P_Date_DMY	equ 1		;AN000;
 29506                                  $P_Date_YMD	equ 2		;AN000;
 29507                                  
 29508                                  ; ----------------------------
 29509                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29510                                  ; ----------------------------
 29511                                  
 29512                                  ;***********************************************************************
 29513                                  ; SysParse;
 29514                                  ;
 29515                                  ;  Function : Parser Entry
 29516                                  ;
 29517                                  ;  Input: DS:SI -> command line
 29518                                  ;	  ES:DI -> parameter block
 29519                                  ;	  psdata_seg -> psdata.inc
 29520                                  ;	  CX = operand ordinal
 29521                                  ;
 29522                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29523                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29524                                  ;		 is in DS.
 29525                                  ;
 29526                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29527                                  ;		    invalid value list. But this parser does NOT implement
 29528                                  ;		    this feature. Therefore CY always zero.
 29529                                  ;
 29530                                  ;	   CY = 0   AX = return code
 29531                                  ;		    BL = terminated delimiter code
 29532                                  ;		    CX = new operand ordinal
 29533                                  ;		    SI = set past scaned operand
 29534                                  ;		    DX = selected result buffer
 29535                                  ;
 29536                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29537                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29538                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29539                                  ;
 29540                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29541                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29542                                  ;
 29543                                  ;-------- Modification History -----------------------------------------
 29544                                  ;
 29545                                  ;  4/04/87 : Created by K. K,
 29546                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29547                                  ;	   : JMP SHORT assemble error (tm02)
 29548                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29549                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29550                                  ;	     DateSW equ 1)	      (tm04)
 29551                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29552                                  ;				      (tm05) in PSDATA.INC
 29553                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29554                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29555                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29556                                  ;	     value-list block	      (tm07)
 29557                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29558                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29559                                  ;	     (tm08)
 29560                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29561                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29562                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29563                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29564                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29565                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29566                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29567                                  ;					  (tm12)
 29568                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29569                                  ;					  (tm13)
 29570                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29571                                  ;					  (tm14)
 29572                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29573                                  ;					  (tm15)
 29574                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29575                                  ;
 29576                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29577                                  ;
 29578                                  ;  7/28/87 : Kerry S (;AN018;)
 29579                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29580                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29581                                  ;	     affected: $P_Chk_SW_Control.
 29582                                  ;
 29583                                  ;  7/29/87 : Kerry S (;AN019;)
 29584                                  ;	     Now allow the optional bit in match flags for switches.  This
 29585                                  ;	     allows the switch to be encountered with a value or without a
 29586                                  ;	     value and no error is returned.
 29587                                  ;
 29588                                  ;
 29589                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29590                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29591                                  ;	     within a date response, instead of checking just for the one
 29592                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29593                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29594                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29595                                  ;
 29596                                  ;  9/1/87  : Kerry S (;AN021)
 29597                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29598                                  ;	     the command line with the string in the control block the
 29599                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29600                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29601                                  ;	     string on the command line than in the synonym list in the control
 29602                                  ;	     block.  I put in a test for a null in the control block so the
 29603                                  ;	     string in the control block must be the same length as the string
 29604                                  ;	     preceeding the colon or equal on the command line.
 29605                                  ;
 29606                                  ;  8/28/87 : Kerry S (;AN022;)
 29607                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29608                                  ;	     problems for people who included it themselves in a segment other
 29609                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29610                                  ;	     segment.
 29611                                  ;
 29612                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29613                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29614                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29615                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29616                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29617                                  ;	     BL be used if TIME is being parsed.
 29618                                  ;
 29619                                  ;  9/24/87 : Ed K
 29620                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29621                                  ;	     invocations with their normally expanded code; made comments
 29622                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29623                                  ;
 29624                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29625                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29626                                  ;	     pointed to by non-existant CONTROL.
 29627                                  ;
 29628                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29629                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29630                                  ;	     support to frame quoted text string with single quote.
 29631                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29632                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29633                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29634                                  ;
 29635                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29636                                  ;	     quote chars within a quoted string is supposed to be reported as
 29637                                  ;	     one quote character, but is reported as two quotes.  This changed
 29638                                  ;	     two instructions in PROC $P_Quoted_Str.
 29639                                  ;
 29640                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29641                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29642                                  ;
 29643                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29644                                  ;
 29645                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29646                                  ;	     psdata buffer should have psdata_seg.
 29647                                  ;
 29648                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29649                                  ;	     positional missing.
 29650                                  ;
 29651                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29652                                  ;	     as a line delimiter, should use carriage return.
 29653                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29654                                  ;
 29655                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29656                                  ;
 29657                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29658                                  ;	     endless loop since SI is returned still pointing to start
 29659                                  ;	     of that parm.
 29660                                  ;
 29661                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29662                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29663                                  ;	     when tried to fix it on previous version, changed similar
 29664                                  ;	     but wrong place.
 29665                                  ;
 29666                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29667                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29668                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29669                                  ;
 29670                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29671                                  ;	     in a filespec, then flag an error.
 29672                                  ;
 29673                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29674                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29675                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29676                                  ;  -->	     local parser data. Why were some references to local data changed
 29677                                  ;	     to do this before, but not all ?????
 29678                                  ;
 29679                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29680                                  ;
 29681                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29682                                  ;
 29683                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29684                                  ;
 29685                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29686                                  ;
 29687                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29688                                  ;	     separator in TIME before hundredths field.
 29689                                  ;
 29690                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29691                                  ;			strings as keywords.
 29692                                  ;
 29693                                  ;***********************************************************************
 29694                                  
 29695                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29696                                  cmd_parse:
 29697                                  	;call	sysparse
 29698                                  	;retn
 29699                                  
 29700                                  ; -----------------------------------
 29701                                  
 29702                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29703                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29704                                  
 29705                                  sysparse:
 29706 0000431B 2EC706[FD85]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29707 00004322 2E890E[8786]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29708 00004327 2E8926[8986]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29709 0000432C 2E8936[8B86]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29710                                  $P_Redo_Time:				;AN039; try to parse time again
 29711 00004331 FC                      	cld				;AN000; confirm forward direction
 29712 00004332 2E890E[F085]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29713                                  	;mov	word [cs:$P_RC],$P_No_Error
 29714 00004337 2EC706[F285]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29715 0000433E 2EC706[0586]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29716                                  					;AC034; initalize synonym pointer
 29717 00004345 2EC706[F685]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29718                                  
 29719                                  ;M029 -- Begin changes
 29720                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29721                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29722                                  ;corrupts this table but does not corrupt the checksum region will leave
 29723                                  ;command.com parsing in an inconsistent state.
 29724                                  ; NB: The special characters string has been hardcoded here. If any change
 29725                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29726                                  
 29727 0000434C 2EC706[C286]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29728 00004353 2EC706[C486]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29729 0000435A 2EC706[C686]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29730 00004361 2EC706[C886]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29731                                  
 29732                                  ;M029 -- End of changes
 29733                                  
 29734 00004368 E82209                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29735 0000436B 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29736                                  
 29737                                  ;--------------------------- End of Line
 29738                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29739 0000436D B8FFFF                  	mov	ax,0FFFFh
 29740 00004370 53                      	push	bx			;AN000;
 29741                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29742 00004371 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29743                                  	
 29744                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29745 00004374 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29746 00004377 7304                    	jae	short $P_Fin		;AN000; positional found.
 29747                                  
 29748                                  	;mov	ax,2
 29749 00004379 B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29750                                  	; 27/04/2023
 29751 0000437C F8                      	clc
 29752                                  $P_Fin: 				;AN000;
 29753 0000437D 5B                      	pop	bx			;AN000;
 29754                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29755                                  	; 27/04/2023
 29756                                  	; cf = 0
 29757                                  	;clc
 29758 0000437E C3                      	retn
 29759                                  
 29760                                  ;---------------------------
 29761                                  $P_Start:				;AN000;
 29762 0000437F 2E8936[FF85]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034; save ptr to command line for later use by complex,
 29763 00004384 53                      	push	bx			;AN000; quoted string or file spec.
 29764 00004385 57                      	push	di			;AN000;
 29765 00004386 55                      	push	bp			;AN000;
 29766 00004387 8D1E[0786]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29767 0000438B 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29768                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29769 00004391 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29770                                  $P_Pack_Loop:				;AN000;
 29771 00004393 AC                      	lodsb				;AN000; Pick a operand from buffer
 29772 00004394 E8A909                  	call	$P_Chk_Switch		;AN000; Check switch character
 29773 00004397 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29774                                  
 29775 00004399 E81309                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29776 0000439C 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29777                                  
 29778 0000439E E84009                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29779 000043A1 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29780                                  
 29781 000043A3 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29782                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29783 000043A9 7505                    	jnz	short $P_Pack_End_backup_si
 29784                                  					;AN000; (tm08)
 29785 000043AB E8DF08                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29786 000043AE EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29787                                  
 29788                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29789 000043B0 2EF606[FE85]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29790                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29791 000043B6 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29792                                  
 29793 000043B8 4E                      	dec	si			;AN000; (tm08)
 29794 000043B9 EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29795                                  $P_PL01:				;AN000;
 29796 000043BB 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29797                                  	;cmp	al,'='
 29798 000043BE 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29799 000043C0 7506                    	jne	short $P_PL00 		;AN000; then
 29800                                  
 29801 000043C2 2E800E[FE85]01          	or	byte [cs:$P_Flags2],$P_equ
 29802                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29803                                  $P_PL00:				;AN000;
 29804 000043C8 43                      	inc	bx			;AN000; ready to see next byte
 29805 000043C9 E89F09                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29806 000043CC 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29807                                  
 29808 000043CE AC                      	lodsb				;AN000; if yes, store
 29809 000043CF 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29810 000043D2 43                      	inc	bx			;AN000; update pointer
 29811 000043D3 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29812                                  
 29813                                  $P_Pack_End_BY_EOL:			;AN000;
 29814 000043D5 4E                      	dec	si			;AN000; backup si pointer
 29815                                  $P_Pack_End:				;AN000;
 29816 000043D6 2E8936[F485]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29817                                  	;mov	byte [cs:bx],0
 29818 000043DB 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29819 000043DF 2E891E[0386]            	mov	[cs:$P_Save_EOB],bx
 29820                                  					;AC034; 3/17/87 keep the address for later use of complex
 29821                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29822 000043E4 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29823 000043E7 8D36[0786]              	lea	si,$P_STRING_BUF	;AC034;
 29824                                  	;cmp	byte [cs:si],'/'
 29825 000043EB 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29826 000043EF 7442                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29827                                  
 29828 000043F1 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29829 000043F5 7408                    	je	short $P_Positional_Manager
 29830                                  					;M005;if so, process as one!
 29831 000043F7 2EF606[FE85]01          	test	byte [cs:$P_Flags2],$P_equ
 29832                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29833 000043FD 7556                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29834                                  
 29835                                  $P_Positional_Manager:			;AN000; else process as positional
 29836                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29837 000043FF 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29838 00004403 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29839 00004405 2E3906[F085]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29840 0000440A 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29841                                  
 29842 0000440C 2EA1[F085]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29843 00004410 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29844 00004412 43                      	inc	bx			;AC035; add '2' to
 29845 00004413 43                      	inc	bx			;AC035;  BX reg
 29846                                  					;AN000; now bx points to 1st CONTROL
 29847 00004414 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29848 00004416 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29849 00004419 E88000                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29850 0000441C EB61                    	jmp	short $P_Return_to_Caller
 29851                                  					;AN000; and return to the caller
 29852                                  $P_Too_Many_Error:			;AN000;
 29853                                  	;mov	word [cs:$P_RC],1
 29854 0000441E 2EC706[F285]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29855                                  					;AC034; set exit code
 29856 00004425 EB58                    	jmp	short $P_Return_to_Caller
 29857                                  					;AN000; and return to the caller
 29858                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 29859                                  %if 0
 29860                                  $P_SW_Manager:				;AN000;
 29861                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29862                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29863                                  	xor	ah,ah			;AN000; ax = maxp
 29864                                  	inc	ax			;AN000;
 29865                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 29866                                  	add	bx,ax			;AN000; now bx points to maxs
 29867                                  	mov	cl,[es:bx]		;AN000;
 29868                                  	xor	ch,ch			;AN000; cx = maxs
 29869                                  	or	cx,cx			;AN000; at least one switch ?
 29870                                  	jz	short $P_SW_Not_Found 	;AN000;
 29871                                  	inc	bx			;AN000; now bx points to 1st CONTROL address
 29872                                  %else
 29873                                  $P_get_max_ptr:
 29874                                  	;mov	al,[es:bx+1]		; get maxp
 29875 00004427 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29876 0000442B 30E4                    	xor	ah,ah			; ax = maxp
 29877 0000442D 40                      	inc	ax
 29878 0000442E D1E0                    	shl	ax,1			; ax = (ax+1)*2
 29879 00004430 01C3                    	add	bx,ax			; now bx points to maxs
 29880 00004432 C3                      	retn
 29881                                  
 29882                                  $P_SW_Manager:
 29883 00004433 E8F1FF                  	call	$P_get_max_ptr
 29884 00004436 268A0F                  	mov	cl,[es:bx]
 29885 00004439 30ED                    	xor	ch,ch			; cx = maxs
 29886                                  					; at least one switch ?
 29887 0000443B E30F                    	jcxz	$P_SW_Not_Found 	; no
 29888 0000443D 43                      	inc	bx			; now bx points to 1st CONTROL address
 29889                                  %endif
 29890                                  
 29891                                  $P_SW_Mgr_Loop: 			;AN000;
 29892 0000443E 53                      	push	bx			;AN000;
 29893 0000443F 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29894 00004442 E8B700                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29895 00004445 5B                      	pop	bx			;AN000;
 29896 00004446 7337                    	jnc	short $P_Return_to_Caller
 29897                                  					;AN000; if the CONTROL is for the switch, exit
 29898 00004448 43                      	inc	bx			;AC035; add '2' to
 29899 00004449 43                      	inc	bx			;AC035;  BX reg
 29900                                  					;AN000; else bx points to the next CONTROL
 29901 0000444A E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29902                                  $P_SW_Not_Found:			;AN000;
 29903                                  	;mov	word [cs:$P_RC],3
 29904 0000444C 2EC706[F285]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29905                                  					;AC034; here no CONTROL for the switch has
 29906 00004453 EB2A                    	jmp	short $P_Return_to_Caller0
 29907                                  					;AN000; not been found, means error.
 29908                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 29909                                  %if 0
 29910                                  $P_Key_Manager:				;AN000;
 29911                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29912                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29913                                  	xor	ah,ah			;AN000; ax = maxp
 29914                                  	inc	ax			;AN000;
 29915                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 29916                                  	add	bx,ax			;AN000; now bx points to maxs
 29917                                  	mov	al,[es:bx]		;AN000;
 29918                                  	xor	ah,ah			;AN000; ax = maxs
 29919                                  	shl	ax,1			;AN000;
 29920                                  	inc	ax			;AN000; ax = ax*2+1
 29921                                  	add	bx,ax			;AN000; now bx points to maxk
 29922                                  	mov	cl,[es:bx]		;AN000;
 29923                                  	xor	ch,ch			;AN000; cx = maxk
 29924                                  	or	cx,cx			;AN000; at least one keyword ?
 29925                                  	jz	short $P_Key_Not_Found	;AN000;
 29926                                  	inc	bx			;AN000; now bx points to 1st CONTROL
 29927                                  %else
 29928                                  $P_Key_Manager:
 29929 00004455 E8CFFF                  	call	$P_get_max_ptr
 29930 00004458 268A07                  	mov	al,[es:bx]
 29931 0000445B 30E4                    	xor	ah,ah			; ax = maxs
 29932 0000445D D1E0                    	shl	ax,1
 29933 0000445F 40                      	inc	ax			; ax = ax*2+1
 29934 00004460 01C3                    	add	bx,ax			; now bx points to maxk
 29935 00004462 268A0F                  	mov	cl,[es:bx]
 29936 00004465 30ED                    	xor	ch,ch			; cx = maxk
 29937                                  					; at least one keyword ?
 29938 00004467 E30F                    	jcxz	$P_Key_Not_Found
 29939 00004469 43                      	inc	bx			; now bx points to 1st CONTROL
 29940                                  %endif
 29941                                  
 29942                                  $P_Key_Mgr_Loop:			;AN000;
 29943 0000446A 53                      	push	bx			;AN000;
 29944 0000446B 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29945 0000446E E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29946 00004471 5B                      	pop	bx			;AN000;
 29947 00004472 730B                    	jnc	short $P_Return_to_Caller
 29948                                  					;AN000; if the CONTROL is for the keyword, exit
 29949 00004474 43                      	inc	bx			;AC035; add '2' to
 29950 00004475 43                      	inc	bx			;AC035;  BX reg
 29951                                  					;AN000; else bx points to the next CONTROL
 29952 00004476 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29953                                  $P_Key_Not_Found:			;AN000;
 29954                                  	;mov	word [cs:$P_RC],4
 29955 00004478 2EC706[F285]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29956                                  					;AC034; here no CONTROL for the keyword has
 29957                                  $P_Return_to_Caller0:
 29958                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29959 0000447F 5D                      	pop	bp			;AN000;
 29960 00004480 5F                      	pop	di			;AN000;
 29961 00004481 5B                      	pop	bx			;AN000;
 29962 00004482 2E8B0E[F085]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29963 00004487 2EA1[F285]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29964 0000448B 2E8B36[F485]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29965 00004490 2E8B16[F685]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29966 00004495 2E8A1E[F885]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29967                                  $P_Single_Exit: 			;AN000;
 29968 0000449A F8                      	clc				;AN000;
 29969 0000449B C3                      	retn				;AN000;
 29970                                  
 29971                                  ;***********************************************************************
 29972                                  ; $P_Chk_Pos_Control
 29973                                  ;
 29974                                  ; Function: Parse CONTROL block for a positional
 29975                                  ;
 29976                                  ; Input:     ES:BX -> CONTROL block
 29977                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29978                                  ;
 29979                                  ; Output:    None
 29980                                  ;
 29981                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 29982                                  ;
 29983                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 29984                                  ;***********************************************************************
 29985                                  
 29986                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29987                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 29988                                  
 29989                                  $P_Chk_Pos_Control:
 29990 0000449C 50                      	push	ax			;AN000;
 29991                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29992 0000449D 268B07                  	mov	ax,[es:bx]		;AN000;
 29993                                  	;test	ax,2
 29994 000044A0 A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 29995 000044A3 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 29996                                  
 29997 000044A5 2EFF06[F085]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 29998                                  $P_CPC00:				;AN000;
 29999                                  	;cmp	byte [cs:si],0
 30000 000044AA 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 30001 000044AE 7516                    	jne	short $P_CPC01		;AN000;
 30002                                  
 30003                                  	;test	ax,1
 30004 000044B0 A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 30005 000044B3 7509                    	jnz	short $P_CPC02		;AN000;
 30006                                  
 30007 000044B5 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30008                                  					;AC034; no, then error	 3/17/87
 30009 000044BC EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 30010                                  $P_CPC02:				;AN000;
 30011                                  	; 27/04/2023
 30012                                  	;push	ax ; *			;AN000;
 30013                                  	;
 30014                                  	;;mov	al,3
 30015                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 30016                                  	;;mov	ah,0FFh
 30017                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 30018                                  	; 31/03/2023
 30019 000044BE B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30020 000044C1 E89500                  	call	$P_Fill_Result		;AN000;
 30021                                  	; 27/04/2023
 30022                                  	;pop	ax ; *			;AN000;
 30023 000044C4 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 30024                                  $P_CPC01:				;AN000;
 30025 000044C6 E81101                  	call	$P_Check_Match_Flags	;AN000;
 30026                                  $P_CPC_Exit:				;AN000;
 30027 000044C9 58                      	pop	ax			;AN000;
 30028 000044CA C3                      	retn				;AN000;
 30029                                  
 30030                                  ;***********************************************************************
 30031                                  ; $P_Chk_Key_Control
 30032                                  ;
 30033                                  ; Function: Parse CONTROL block for a keyword
 30034                                  ;
 30035                                  ; Input:     ES:BX -> CONTROL block
 30036                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30037                                  ;
 30038                                  ; Output:    CY = 1 : not match
 30039                                  ;
 30040                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30041                                  ;
 30042                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30043                                  ;***********************************************************************
 30044                                  
 30045                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30046                                  $P_Chk_Key_Control:			;AN000;
 30047 000044CB F9                      	stc				;AN000;this logic works when the KeySW
 30048 000044CC C3                      	retn				;AN000;is reset.
 30049                                  
 30050                                  ;***********************************************************************
 30051                                  ; $P_Search_KEYorSW:
 30052                                  ;
 30053                                  ; Function: Seach specified keyword or switch from CONTROL
 30054                                  ;
 30055                                  ; Input:     ES:BX -> CONTROL block
 30056                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30057                                  ;
 30058                                  ; Output:    CY = 1 : not match
 30059                                  ;
 30060                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30061                                  ;***********************************************************************
 30062                                  
 30063                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30064                                  	; 14/06/2023
 30065                                  $P_Search_KEYorSW:
 30066 000044CD 55                      	push	bp			;AN000;
 30067 000044CE 51                      	push	cx			;AN000;
 30068 000044CF 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30069                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30070                                  	; 14/06/2023
 30071                                  	;xor	ch,ch			;AN000; and set it to cx
 30072                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30073 000044D3 08C9                    	or	cl,cl
 30074 000044D5 740E                    	jz	short $P_KEYorSW_Not_Found
 30075                                  					;AN000; then indicate not found by CY
 30076 000044D7 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30077                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30078                                  $P_KEYorSW_Loop:			;AN000;
 30079 000044DB E8E703                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30080 000044DE 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30081 000044E0 E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30082 000044E3 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30083                                  $P_KEYorSW_Not_Found:			;AN000;
 30084 000044E5 F9                      	stc				;AN000; indicate not found in synonym list
 30085 000044E6 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30086                                  $P_KEYorSW_Found:			;AN000;
 30087 000044E8 2E892E[0586]            	mov	[cs:$P_Found_SYNONYM],bp
 30088                                  					;AC034; set synonym pointer
 30089                                  	; 27/04/2023
 30090                                  	; cf = 0
 30091                                  	;clc				;AN000; indicate found
 30092                                  $P_KEYorSW_Exit:			;AN000;
 30093 000044ED 59                      	pop	cx			;AN000;
 30094 000044EE 5D                      	pop	bp			;AN000;
 30095 000044EF C3                      	retn				;AN000;
 30096                                  
 30097                                  ;***********************************************************************
 30098                                  ; $P_MoveBP_NUL
 30099                                  ;***********************************************************************
 30100                                  
 30101                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30102                                  
 30103                                  $P_MoveBP_NUL:
 30104                                  $P_MBP_Loop:				;AN000;
 30105                                  	;cmp	byte [es:bp+0],0
 30106 000044F0 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30107 000044F5 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30108 000044F7 45                      	inc	bp			;AN000; until
 30109 000044F8 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30110                                  $P_MBP_Exit:				;AN000;
 30111 000044FA 45                      	inc	bp			;AN000; bp points to next to NULL
 30112 000044FB C3                      	retn				;AN000;
 30113                                  
 30114                                  ;***********************************************************************
 30115                                  ; $P_Chk_SW_Control
 30116                                  ;
 30117                                  ; Function: Parse CONTROL block for a switch
 30118                                  ;
 30119                                  ; Input:     ES:BX -> CONTROL block
 30120                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30121                                  ;
 30122                                  ; Output:    CY = 1 : not match
 30123                                  ;
 30124                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30125                                  ;
 30126                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30127                                  ;***********************************************************************
 30128                                  
 30129                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30130                                  
 30131                                  $P_Chk_SW_Control:
 30132 000044FC 2E800E[FE85]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 30133                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 30134 00004502 E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 30135 00004505 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 30136                                  
 30137 00004507 2E8026[FE85]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 30138                                  	;and	byte [cs:$P_Flags2],0EFh
 30139                                  					;AC034; reset the indicator previously set
 30140 0000450D 50                      	push	ax			;AN000;       /switch:
 30141 0000450E 2EA1[0186]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 30142 00004512 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 30143 00004514 2E0106[FF85]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 30144 00004519 58                      	pop	ax			;AN000;
 30145                                  
 30146 0000451A 2E8B36[0186]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 30147                                  	;cmp	byte [cs:si],0
 30148 0000451F 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 30149 00004523 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 30150                                  
 30151                                  	;cmp	byte [cs:si],':'
 30152 00004525 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 30153                                  					;AN000; if no, the switch terminated by colon ?
 30154 0000452A 7509                    	jne	short $P_Chk_if_data_required
 30155                                  					;AN000; if yes,
 30156                                  
 30157 0000452C 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30158                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 30159 00004533 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 30160                                  
 30161                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 30162                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 30163                                  	; 27/04/2023
 30164 00004535 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 30165 00004539 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 30166                                  
 30167                                  	;;test	word [es:bx],1 ; $P_Optional
 30168                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 30169 0000453B 26F60701                	test	byte [es:bx],$P_Optional
 30170                                  					;AN019; see if no value is valid
 30171 0000453F 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 30172                                  
 30173 00004541 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30174                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 30175 00004548 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 30176                                  
 30177                                  $P_CSW00:				;AN000;
 30178 0000454A E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 30179 0000454D F8                      	clc				;AN000; indicate match
 30180                                  	;jmp	short $P_Chk_SW_Single_Exit
 30181 0000454E C3                      	retn	; 31/03/2023		;AN000;
 30182                                  	; 31/03/2023
 30183                                  ;$P_Chk_SW_Err0: 			;AN000;
 30184                                  ;	stc				;AN000; not found in switch synonym list
 30185                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 30186                                  ;	retn	; 31/03/2023		;AN000;
 30187                                  	
 30188                                  $P_Chk_SW_Exit: 			;AN000;
 30189 0000454F 50                      	push	ax			;AN000;
 30190                                  	; 31/03/2023
 30191 00004550 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30192                                  	;;mov	al,3
 30193                                  	;;mov	ah,0FFh
 30194                                  	;mov	al,$P_String		;AN000; set
 30195                                  	;mov	ah,$P_No_Tag		;AN000;    result
 30196 00004553 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 30197 00004556 58                      	pop	ax			;AN000;
 30198 00004557 F8                      	clc				;AN000;
 30199                                  	; 31/03/2023
 30200                                  $P_Chk_SW_Err0:
 30201                                  $P_Chk_SW_Single_Exit:			;AN000;
 30202 00004558 C3                      	retn				;AN000;
 30203                                  
 30204                                  ;***********************************************************************
 30205                                  ; $P_Fill_Result
 30206                                  ;
 30207                                  ; Function: Fill the result buffer
 30208                                  ;
 30209                                  ; Input:    AH = Item tag
 30210                                  ;	    AL = type
 30211                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 30212                                  ;		  AL = 2: DX has index(offset) into value list
 30213                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 30214                                  ;		  AL = 7: DX has year, CL has month and CH has date
 30215                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 30216                                  ;			  amd CH has hundredths
 30217                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 30218                                  ;	    ES:BX -> CONTROL block
 30219                                  ;
 30220                                  ; Output:   None
 30221                                  ;
 30222                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 30223                                  ;
 30224                                  ; Vars: $P_DX(W)
 30225                                  ;***********************************************************************
 30226                                  
 30227                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30228                                  
 30229                                  $P_Fill_Result:
 30230 00004559 57                      	push	di			;AN000;
 30231 0000455A 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 30232                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 30233 0000455E 2E893E[F685]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 30234                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 30235                                  	;;mov	[es:di],al		;AN000; store type
 30236                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 30237                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 30238                                  	; 31/03/2023
 30239 00004563 268905                  	mov	[es:di],ax
 30240 00004566 50                      	push	ax			;AN000;
 30241 00004567 2EA1[0586]              	mov	ax,[cs:$P_Found_SYNONYM]
 30242                                  					;AC034; if yes,
 30243 0000456B 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 30244                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 30245 0000456F 58                      	pop	ax			;AN000;
 30246                                  $P_RLT04:				;AN000;
 30247                                  	;cmp	al,1
 30248 00004570 3C01                    	cmp	al,$P_Number		;AN000; if number
 30249 00004572 750A                    	jne	short $P_RLT00		;AN000;
 30250                                  $P_RLT02:				;AN000;
 30251 00004574 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30252                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 30253 00004578 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 30254                                  	;mov	[es:di+6],cx		;AN000;	number
 30255 0000457C EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 30256                                  $P_RLT00:				;AN000;
 30257                                  	;cmp	al,2
 30258 0000457E 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 30259 00004580 7506                    	jne	short $P_RLT01		;AN000;
 30260 00004582 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30261                                  	;mov	[es:di+4],dx		;AN000; then store list index
 30262 00004586 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 30263                                  $P_RLT01:				;AN000;
 30264                                  	;cmp	al,7
 30265 00004588 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 30266 0000458A 74E8                    	je	short $P_RLT02		;AN000;
 30267                                  	;cmp	al,8
 30268 0000458C 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 30269 0000458E 74E4                    	je	short $P_RLT02		;AN000;
 30270                                  	;cmp	al,6
 30271 00004590 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 30272 00004592 7506                    	jne	short $P_RLT03		;AN000;
 30273                                  
 30274 00004594 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 30275                                  	;mov	[es:di+4],dl		;AN000; store drive number
 30276 00004598 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 30277                                  
 30278                                  $P_RLT03:				;AN000;
 30279                                  	;cmp	al,4
 30280 0000459A 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 30281 0000459C 750F                    	jne	short $P_RLT05		;AN000;
 30282                                  
 30283 0000459E 2EA1[FF85]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 30284 000045A2 40                      	inc	ax			;AN000; skip left Parentheses
 30285 000045A3 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 30286                                  	;mov	[es:di+4],ax		;AN000; store offset
 30287 000045A7 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 30288                                  	;mov	[es:di+6],ds		;AN000; store segment
 30289 000045AB EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 30290                                  
 30291                                  $P_RLT05:				;AN000;
 30292                                  ;------------------------  AL = 3, 5, or 9
 30293 000045AD 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 30294                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 30295 000045B1 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 30296                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 30297                                  
 30298 000045B5 50                      	push	ax			;AN000;
 30299 000045B6 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 30300                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 30301 000045BB 7404                    	jz	short $P_RLT_CAP00	;AN000;
 30302                                  
 30303                                  	;mov	al,4
 30304 000045BD B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 30305 000045BF EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 30306                                  
 30307                                  $P_RLT_CAP00:				;AN000;
 30308 000045C1 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 30309                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 30310 000045C6 7405                    	jz	short $P_RLT_CAP01	;AN000;
 30311                                  
 30312                                  	;mov	al,2
 30313 000045C8 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 30314                                  $P_RLT_CAP02:				;AN000;
 30315 000045CA E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 30316                                  $P_RLT_CAP01:				;AN000;
 30317 000045CD 58                      	pop	ax			;AN000;
 30318 000045CE 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 30319                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 30320 000045D3 7403                    	jz	short $P_RLT_Exit	;AN000;
 30321                                  
 30322 000045D5 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 30323                                  $P_RLT_Exit:				;AN000;
 30324 000045D8 5F                      	pop	di			;AN000;
 30325 000045D9 C3                      	retn				;AN000;
 30326                                  
 30327                                  ;***********************************************************************
 30328                                  ; $P_Check_Match_Flags
 30329                                  ;
 30330                                  ; Function:  Check the mutch_flags and make the exit code and set the
 30331                                  ;	     result buffer
 30332                                  ;
 30333                                  ;	    Check for types in this order:
 30334                                  ;		Complex
 30335                                  ;		Date
 30336                                  ;		Time
 30337                                  ;		Drive
 30338                                  ;		Filespec
 30339                                  ;		Quoted String
 30340                                  ;		Simple String
 30341                                  ;
 30342                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30343                                  ;	     ES:BX -> CONTROL block
 30344                                  ;
 30345                                  ; Output:    None
 30346                                  ;
 30347                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 30348                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 30349                                  ;	     $P_Drive_Format
 30350                                  ;***********************************************************************
 30351                                  
 30352                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30353                                  
 30354                                  $P_Check_Match_Flags:
 30355 000045DA 2EC606[CB86]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 30356                                  					;AN033;AC034;; clear filespec error flag.
 30357 000045E0 50                      	push	ax			;AN000;
 30358                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30359 000045E1 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 30360 000045E4 09C0                    	or	ax,ax			;AC035; test ax for zero
 30361 000045E6 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 30362 000045E8 50                      	push	ax			;AN000; (tm12)
 30363 000045E9 53                      	push	bx			;AN000; (tm12)
 30364 000045EA 52                      	push	dx			;AN000; (tm12)
 30365 000045EB 57                      	push	di			;AN000; (tm12)
 30366 000045EC 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30367                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30368                                  	; 31/03/2023
 30369 000045F3 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30370                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30371                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30372 000045F6 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30373 000045F9 5F                      	pop	di			;AN000; (tm12)
 30374 000045FA 5A                      	pop	dx			;AN000; (tm12)
 30375 000045FB 5B                      	pop	bx			;AN000; (tm12)
 30376 000045FC 58                      	pop	ax			;AN000; (tm12)
 30377                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30378                                  	; 31/03/2023
 30379                                  $P_Bridge:	; 18/04/2023		;AN000;
 30380 000045FD E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30381                                  $P_Mat: 				;AN000; (tm12)
 30382                                  $P_Match01:				;AN000;
 30383                                  	;test	ax,1000h
 30384 00004600 A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30385 00004603 7412                    	jz	short $P_Match02	;AN000;
 30386 00004605 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30387                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30388 0000460C E85403                  	call	$P_Date_Format		;AN000; do process
 30389 0000460F 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30390                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30391                                  	; 18/04/2023
 30392 00004615 75E6                    	jne	short $P_Bridge		;AN000;
 30393                                  $P_Match02:				;AN000;
 30394                                  	;test	ax,800h
 30395 00004617 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30396 0000461A 7412                    	jz	short $P_Match03	;AN000;
 30397 0000461C 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30398                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30399 00004623 E85404                  	call	$P_Time_Format		;AN000; do process
 30400 00004626 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30401                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30402                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30403                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30404                                  	; 31/03/2023
 30405 0000462C 756E                    	jne	short $P_Match_Exit
 30406                                  ;$P_Bridge:				;AN000;
 30407                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30408                                  $P_Match03:				;AN000;
 30409                                  	;test	ax,8000h
 30410 0000462E A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30411 00004631 7412                    	jz	short $P_Match04	;AN000;
 30412 00004633 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30413                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30414 0000463A E82701                  	call	$P_Value		;AN000; do process
 30415 0000463D 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30416                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30417 00004643 7557                    	jne	short $P_Match_Exit	;AN000;
 30418                                  $P_Match04:				;AN000;
 30419                                  	;test	ax,4000h
 30420 00004645 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30421 00004648 7412                    	jz	short $P_Match05	;AN000;
 30422 0000464A 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30423                                  					;AC034; assume no error
 30424 00004651 E8EC00                  	call	$P_SValue		;AN000; do process
 30425 00004654 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30426                                  					;AC034; if error, examine the next type
 30427 0000465A 7540                    	jne	short $P_Match_Exit	;AN000;
 30428                                  $P_Match05:				;AN000;
 30429                                  	;test	ax,100h
 30430 0000465C A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30431 0000465F 7415                    	jz	short $P_Match06	;AN000;
 30432 00004661 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30433                                  					;AC034; assume no error
 30434 00004668 E85C05                  	call	$P_File_Format		;AN000; 1st, call file format
 30435 0000466B E8DD05                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30436 0000466E 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30437                                  					;AC034; if error, examinee the next type
 30438 00004674 7526                    	jne	short $P_Match_Exit	;AN000;
 30439                                  $P_Match06:				;AN000;
 30440                                  	;test	ax,200h
 30441 00004676 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 30442 00004679 7412                    	jz	short $P_Match07	;AN000;
 30443 0000467B 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30444                                  					;AC034; assume no error
 30445 00004682 E84205                  	call	$P_File_Format		;AN000; do process
 30446 00004685 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30447                                  					;AC034; if error, examine the next type
 30448 0000468B 750F                    	jne	short $P_Match_Exit	;AN000;
 30449                                  $P_Match07:				;AN000;
 30450                                  $P_Match08:				;AN000;
 30451                                  	;test	ax,2000h
 30452 0000468D A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 30453 00004690 740A                    	jz	short $P_Match09	;AN000;
 30454 00004692 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30455                                  					;AC034; assume no error
 30456 00004699 E8C501                  	call	$P_Simple_String	;AN000; do process
 30457                                  $P_Match09:				;AN000;
 30458                                  $P_Match_Exit:				;AN000;
 30459 0000469C 2E833E[CB86]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 30460                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 30461 000046A2 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30462 000046A4 2E833E[F285]00          	cmp	word [cs:$P_RC],$P_No_Error
 30463                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 30464 000046AA 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30465 000046AC 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30466                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 30467                                  $P_Match2_Exit: 			;AN033;
 30468 000046B3 58                      	pop	ax			;AN000;
 30469 000046B4 C3                      	retn
 30470                                  
 30471                                  ;***********************************************************************
 30472                                  ; $P_Remove_Colon;
 30473                                  ;
 30474                                  ; Function: Remove colon at end
 30475                                  ;
 30476                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 30477                                  ;
 30478                                  ; Output:   None
 30479                                  ;
 30480                                  ; Use:	$P_Chk_DBCS
 30481                                  ;***********************************************************************
 30482                                  
 30483                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30484                                  
 30485                                  $P_Remove_Colon:
 30486 000046B5 50                      	push	ax			;AN000;
 30487 000046B6 56                      	push	si			;AN000;
 30488                                  $P_RCOL_Loop:				;AN000;
 30489 000046B7 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30490 000046BA 08C0                    	or	al,al			;AN000; end of string ?
 30491 000046BC 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30492                                  
 30493 000046BE 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30494 000046C0 750E                    	jne	short $P_RCOL00		;AN000;
 30495                                  
 30496                                  	;cmp	byte [cs:si+1],0
 30497 000046C2 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30498 000046C7 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30499                                  
 30500 000046C9 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30501                                  	; 31/03/2023
 30502                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30503                                  $P_RCOL_Exit:
 30504 000046CD 5E                      	pop	si
 30505 000046CE 58                      	pop	ax
 30506 000046CF C3                      	retn
 30507                                  
 30508                                  $P_RCOL00:				;AN000;
 30509 000046D0 E89806                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30510 000046D3 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30511                                  
 30512 000046D5 46                      	inc	si			;AN000; if yes, skip trailing byte
 30513                                  $P_RCOL01:				;AN000;
 30514 000046D6 46                      	inc	si			;AN000; si points to next byte
 30515 000046D7 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30516                                  
 30517                                  	; 31/03/2023
 30518                                  ;$P_RCOL_Exit:				;AN000;
 30519                                  	;pop	si			;AN000;
 30520                                  	;pop	ax			;AN000;
 30521                                  	;retn
 30522                                  
 30523                                  ;***********************************************************************
 30524                                  ; $P_Do_CAPS_String;
 30525                                  ;
 30526                                  ; Function: Perform capitalization along with the file case map table
 30527                                  ;	    or character case map table.
 30528                                  ;
 30529                                  ; Input:    AL = 2 : Use character table
 30530                                  ;	    AL = 4 : Use file table
 30531                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30532                                  ;
 30533                                  ; Output:   None
 30534                                  ;
 30535                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30536                                  ;***********************************************************************
 30537                                  
 30538                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30539                                  
 30540                                  $P_Do_CAPS_String:
 30541 000046D9 56                      	push	si			;AN000;
 30542 000046DA 52                      	push	dx			;AN000;
 30543 000046DB 88C2                    	mov	dl,al			;AN000; save info id
 30544                                  $P_DCS_Loop:				;AN000;
 30545 000046DD 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30546 000046E0 E88806                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30547 000046E3 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30548                                  
 30549 000046E5 08C0                    	or	al,al			;AN000; end of string ?
 30550 000046E7 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30551                                  
 30552 000046E9 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30553 000046EC 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30554 000046EF EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30555                                  $P_DCS00:				;AN000;
 30556 000046F1 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30557                                  $P_DCS01:				;AN000;
 30558 000046F2 46                      	inc	si			;AN000; si point to next byte
 30559 000046F3 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30560                                  $P_DCS_Exit:				;AN000;
 30561 000046F5 5A                      	pop	dx			;AN000;
 30562 000046F6 5E                      	pop	si			;AN000;
 30563 000046F7 C3                      	retn
 30564                                  
 30565                                  ;***********************************************************************
 30566                                  ; $P_Do_CAPS_Char;
 30567                                  ;
 30568                                  ; Function: Perform capitalization along with the file case map table
 30569                                  ;	    or character case map table.
 30570                                  ;
 30571                                  ; Input:    DL = 2 : Use character table
 30572                                  ;	    DL = 4 : Use file table
 30573                                  ;	    AL = character to be capitalized
 30574                                  ;
 30575                                  ; Output:   None
 30576                                  ;
 30577                                  ; Use:	INT 21h /w AH=65h
 30578                                  ;***********************************************************************
 30579                                  
 30580                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30581                                  
 30582                                  $P_Do_CAPS_Char:
 30583 000046F8 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30584 000046FA 730B                    	jae	short $P_DCC_Go		;AN000;
 30585                                  
 30586 000046FC 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30587 000046FE 723F                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30588                                  
 30589 00004700 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30590 00004702 773B                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30591                                  
 30592 00004704 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30593                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30594                                  	; 18/04/2023
 30595 00004706 C3                      	retn
 30596                                  
 30597                                  $P_DCC_Go:				;AN000;
 30598 00004707 53                      	push	bx			;AN000;
 30599 00004708 06                      	push	es			;AN000;
 30600 00004709 57                      	push	di			;AN000;
 30601                                  	; 18/04/2023
 30602 0000470A 8D3E[BD86]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30603 0000470E 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30604 00004711 7404                    	je	short $P_DCC00		;AN000;
 30605                                  	; 27/04/2023
 30606 00004713 8D3E[B886]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 30607                                  $P_DCC00:				;AN000;
 30608 00004717 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30609 0000471A 7416                    	je	short $P_DCC01		;AN000; if no,
 30610                                  
 30611                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30612                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30613                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30614                                  
 30615 0000471C 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30616 0000471D 51                      	push	cx			;AN000;
 30617 0000471E 52                      	push	dx			;AN000;
 30618 0000471F 0E                      	push	cs			;AC036; pass current base seg into
 30619                                  					;(Note: this used to push CS. BUG...
 30620 00004720 07                      	pop	es			;AN000;   ES reg, required for
 30621                                  					;get extended country information
 30622                                  	; 31/03/2023
 30623 00004721 B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30624                                  	;mov	ah,65h
 30625 00004723 88D0                    	mov	al,dl			;AN000; upper case table
 30626                                  	;mov	bx,-1 ; 0FFFFh
 30627                                  	;mov	cx,5
 30628                                  	;mov	dx,-1
 30629 00004725 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30630 00004728 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30631                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30632 0000472B 89DA                    	mov	dx,bx
 30633                                  	;mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30634                                  					;DI already set to point to buffer
 30635 0000472D CD21                    	int	21h			;AN000; es:di point to buffer that
 30636                                  					;now has been filled in with info
 30637 0000472F 5A                      	pop	dx			;AN000;
 30638 00004730 59                      	pop	cx			;AN000;
 30639 00004731 58                      	pop	ax			;AN000;
 30640                                  
 30641                                  $P_DCC01:				;AN000;
 30642                                  
 30643                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30644                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30645                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30646                                  
 30647                                  	;mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30648                                  	;;mov	bx,[cs:di+1]		;AN000; get offset of table
 30649                                  	;mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30650                                  	;;mov	es,[cs:di+3]		;AN000; get segment of table
 30651                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30652                                  	;les	bx,[cs:di+1]
 30653 00004732 2EC45D01                	les	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30654                                  	;
 30655 00004736 43                      	inc	bx			;AC035; add '2' to
 30656 00004737 43                      	inc	bx			;AC035;  BX reg
 30657                                  					;AN000; skip length field
 30658 00004738 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30659                                  	;xlat	es:[bx] 		;AN000; perform case map
 30660                                  	; 31/03/2023
 30661 0000473A 26D7                    	es	xlat
 30662                                  
 30663 0000473C 5F                      	pop	di			;AN000;
 30664 0000473D 07                      	pop	es			;AN000;
 30665 0000473E 5B                      	pop	bx			;AN000;
 30666                                  $P_CAPS_Ret:				;AN000;
 30667 0000473F C3                      	retn
 30668                                  
 30669                                  ;***********************************************************************
 30670                                  ; $P_Value / $P_SValue
 30671                                  ;
 30672                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30673                                  ;	     and make result buffer.
 30674                                  ;	     $P_SValue is an entry point for the signed value
 30675                                  ;	     and this will simply call $P_Value after the handling
 30676                                  ;	     of the sign character, "+" or "-"
 30677                                  ;
 30678                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30679                                  ;	     ES:BX -> CONTROL block
 30680                                  ;
 30681                                  ; Output:    None
 30682                                  ;
 30683                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30684                                  ;
 30685                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30686                                  ;***********************************************************************
 30687                                  
 30688                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30689                                  $P_SValue:
 30690 00004740 50                      	push	ax			;AN000;
 30691                                  	;or	byte [cs:$P_Flags2],80h
 30692 00004741 2E800E[FE85]80          	or	byte [cs:$P_Flags2],$P_Signed
 30693                                  					;AC034; indicate a signed numeric
 30694                                  	;and	byte [cs:$P_Flags2],0FDh
 30695 00004747 2E8026[FE85]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30696                                  					;AC034; assume positive value
 30697 0000474D 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30698 00004750 3C2B                    	cmp	al,'+' ; 2Bh
 30699                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30700 00004752 740A                    	je	short $P_SVal00		;AN000;
 30701                                  
 30702 00004754 3C2D                    	cmp	al,'-' ; 2Dh
 30703                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30704 00004756 7507                    	jne	short $P_Sval01		;AN000; else
 30705                                  
 30706 00004758 2E800E[FE85]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30707                                  					;AC034; set this is negative value
 30708                                  $P_SVal00:				;AN000;
 30709 0000475E 46                      	inc	si			;AN000; skip sign char
 30710                                  $P_Sval01:				;AN000;
 30711 0000475F E80200                  	call	$P_Value		;AN000; and process value
 30712 00004762 58                      	pop	ax			;AN000;
 30713                                  $P_Check_OVF_ok: ; 11/08/2024
 30714 00004763 C3                      	retn				;AN000;
 30715                                  
 30716                                  ;***********************************************************************
 30717                                  
 30718                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30719                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30720                                  
 30721                                  	; 11/08/2024
 30722                                  $P_Value:
 30723 00004764 50                      	push	ax			;AN000;
 30724 00004765 51                      	push	cx			;AN000;
 30725 00004766 52                      	push	dx			;AN000;
 30726 00004767 56                      	push	si			;AN000;
 30727 00004768 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30728 0000476A 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30729 0000476C 53                      	push	bx			;AN000; save control pointer
 30730                                  $P_Value_Loop:				;AN000;
 30731 0000476D 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30732 00004770 08C0                    	or	al,al			;AN000; end of line ?
 30733 00004772 7436                    	jz	short $P_Value00	;AN000;
 30734                                  
 30735 00004774 E8DF00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30736 00004777 722D                    	jc	short $P_Value_Err0	;AN000;
 30737                                  
 30738                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30739                                  %if 0
 30740                                  	xor	ah,ah			;AN000;
 30741                                  	mov	bp,ax			;AN000; save binary number
 30742                                  	shl	dx,1			;AN000; to have 2*x
 30743                                  	rcl	cx,1			;AN000; shift left w/ carry
 30744                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30745                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30746                                  
 30747                                  	mov	bx,dx			;AN000; save low(2*x)
 30748                                  	mov	ax,cx			;AN000; save high(2*x)
 30749                                  	shl	dx,1			;AN000; to have 4*x
 30750                                  	rcl	cx,1			;AN000; shift left w/ carry
 30751                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30752                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30753                                  
 30754                                  	shl	dx,1			;AN000; to have 8*x
 30755                                  	rcl	cx,1			;AN000; shift left w/ carry
 30756                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30757                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30758                                  
 30759                                  	add	dx,bx			;AN000; now have 10*x
 30760                                  	adc	cx,ax			;AN000; 32bit ADD
 30761                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30762                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30763                                  
 30764                                  	add	dx,bp			;AN000; Add the current one degree decimal
 30765                                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30766                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30767                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30768                                  
 30769                                  	inc	si			;AN000; update pointer
 30770                                  	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30771                                  %else
 30772 00004779 30E4                    	xor	ah,ah
 30773 0000477B 89C5                    	mov	bp,ax			; save binary number
 30774 0000477D E81C00                  	call	$P_Check_OVF_shl32	; check Overflow (after shl32)
 30775 00004780 89D3                    	mov	bx,dx			; save low(2*x)
 30776 00004782 89C8                    	mov	ax,cx			; save high(2*x)
 30777 00004784 E81500                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 30778 00004787 E81200                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 30779 0000478A 01DA                    	add	dx,bx			; now have 10*x
 30780 0000478C 11C1                    	adc	cx,ax			; 32bit ADD
 30781 0000478E E80F00                  	call	$P_Check_OVF_@		; check OverFlow
 30782 00004791 01EA                    	add	dx,bp			; Add the current one degree decimal
 30783 00004793 83D100                  	adc	cx,0			; if carry, add 1 to high 16bit
 30784 00004796 E80700                  	call	$P_Check_OVF_@		; check Overflow
 30785 00004799 46                      	inc	si			; update pointer
 30786 0000479A EBD1                    	jmp	short $P_Value_Loop	; loop until NULL encountered
 30787                                  
 30788                                  $P_Check_OVF_shl32:
 30789 0000479C D1E2                    	shl	dx,1
 30790 0000479E D1D1                    	rcl	cx,1
 30791                                  $P_Check_OVF_@:
 30792 000047A0 E8A100                  	call	$P_Check_OVF
 30793                                  	;jc	short $P_Value_Err0_@
 30794                                  	;retn
 30795                                  	; 11/08/2024
 30796 000047A3 73BE                    	jnc	short $P_Check_OVF_ok
 30797                                  
 30798                                  $P_Value_Err0_@:
 30799                                  	;inc	sp
 30800                                  	;inc	sp
 30801                                  	; 11/08/2024
 30802 000047A5 5B                      	pop	bx
 30803                                  %endif
 30804                                  
 30805                                  $P_Value_Err0:				;AN000;
 30806 000047A6 5B                      	pop	bx			;AN000;
 30807 000047A7 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30808                                  
 30809                                  $P_Value00:				;AN000;
 30810 000047AA 5B                      	pop	bx			;AN000; restore control pointer
 30811 000047AB 2EF606[FE85]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30812                                  					;AC034; here cx,dx = 32bit value
 30813 000047B1 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30814                                  
 30815 000047B3 F7D1                    	not	cx			;AN000; +
 30816 000047B5 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30817 000047B7 83C201                  	add	dx,1			;AN000; |
 30818 000047BA 83D100                  	adc	cx,0			;AN000; +
 30819                                  $P_Value01:				;AN000; / nval =0
 30820 000047BD 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30821                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30822 000047C1 268A04                  	mov	al,[es:si]		;AN000; get nval
 30823 000047C4 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30824 000047C6 7505                    	jne	short $P_Value02	;AN000;
 30825                                  
 30826                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30827                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30828                                  	; 31/03/2023
 30829 000047C8 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30830 000047CB EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30831                                  
 30832                                  $P_Value02:				;AN000; / nval = 1
 30833 000047CD 46                      	inc	si			;AN000;
 30834 000047CE 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30835 000047D1 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30836 000047D3 745D                    	je	short $P_Value03	;AN000; (tm07)
 30837                                  
 30838 000047D5 46                      	inc	si			;AN000; si points to 1st item_tag
 30839                                  $P_Val02_Loop:				;AN000;
 30840 000047D6 2EF606[FE85]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30841                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30842 000047DC 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30843                                  
 30844 000047DE 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30845                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30846 000047E2 723B                    	jb	short $P_Val02_Next	;AN000;
 30847 000047E4 7706                    	ja	short $P_Val_In		;AN000;
 30848                                  
 30849 000047E6 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30850                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30851 000047EA 7233                    	jb	short $P_Val02_Next	;AN000;
 30852                                  
 30853                                  $P_Val_In:				;AN000;
 30854 000047EC 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30855                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30856 000047F0 772D                    	ja	short $P_Val02_Next	;AN000;
 30857 000047F2 7224                    	jb	short $P_Val_Found	;AN000;
 30858                                  
 30859 000047F4 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30860                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30861 000047F8 7725                    	ja	short $P_Val02_Next	;AN000;
 30862                                  
 30863 000047FA EB1C                    	jmp	short $P_Val_Found	;AN000;
 30864                                  
 30865                                  $P_Val02_Sign:				;AN000;
 30866 000047FC 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30867                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30868 00004800 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30869 00004802 7F06                    	jg	short $P_SVal_In	;AN000;
 30870                                  
 30871 00004804 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30872                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30873 00004808 7C15                    	jl	short $P_Val02_Next	;AN000;
 30874                                  
 30875                                  $P_SVal_In:				;AN000;
 30876 0000480A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30877                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30878 0000480E 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30879 00004810 7C06                    	jl	short $P_Val_Found	;AN000;
 30880                                  
 30881 00004812 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30882                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30883 00004816 7F07                    	jg	short $P_Val02_Next	;AN000;
 30884                                  
 30885                                  	;jmp	short $P_Val_Found	;AN000;
 30886                                  	; 27/04/2023
 30887                                  $P_Val_Found:				;AN000;
 30888 00004818 B001                    	mov	al,$P_Number ; 1	;AN000;
 30889 0000481A 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30890 0000481D EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30891                                  
 30892                                  $P_Val02_Next:				;AN000;
 30893 0000481F 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30894 00004822 FEC8                    	dec	al			;AN000; loop nrng times in AL
 30895 00004824 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30896                                  					; / Not found
 30897 00004826 2EC706[F285]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30898                                  	;mov	word [cs:$P_RC],6	;AC034;
 30899                                  	
 30900                                  	;mov	al,$P_Number ; 1	;AN000;
 30901                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30902                                  	; 31/03/2023
 30903 0000482D B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30904 00004830 EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30905                                  
 30906                                  	; 27/04/2023
 30907                                  ;$P_Val_Found:				;AN000;
 30908                                  	;mov	al,$P_Number ; 1	;AN000;
 30909                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30910                                  	;jmp	short $P_Value_Exit	;AN000;
 30911                                  
 30912                                  $P_Value03:				;AN000; / nval = 2
 30913                                  $P_Value04:				;AN000; / nval = 3 or else
 30914                                  $P_Value_Err:				;AN000;
 30915 00004832 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30916                                  					;AC034;
 30917                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30918                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30919                                  	; 31/03/2023
 30920 00004839 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30921                                  $P_Value_Exit:				;AN000;
 30922 0000483C E81AFD                  	call	$P_Fill_Result		;AN000;
 30923 0000483F 5E                      	pop	si			;AN000;
 30924 00004840 5A                      	pop	dx			;AN000;
 30925 00004841 59                      	pop	cx			;AN000;
 30926 00004842 58                      	pop	ax			;AN000;
 30927 00004843 C3                      	retn				;AN000;
 30928                                  
 30929                                  ;***********************************************************************
 30930                                  ; $P_Check_OVF
 30931                                  ;
 30932                                  ; Function:  Check if overflow is occurred with consideration of
 30933                                  ;	     signed or un-signed numeric value
 30934                                  ;
 30935                                  ; Input:     Flag register
 30936                                  ;
 30937                                  ; Output:    CY = 1  :	Overflow
 30938                                  ;
 30939                                  ; Vars:     $P_Flags(R)
 30940                                  ;***********************************************************************
 30941                                  
 30942                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30943                                  $P_Check_OVF:
 30944 00004844 9C                      	pushf				;AN000;
 30945 00004845 2EF606[FE85]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30946                                  					;AC034; is it negative value ?
 30947 0000484B 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30948 0000484D 9D                      	popf				;AN000; by the CY bit
 30949 0000484E C3                      	retn				;AN000;
 30950                                  $P_COVF:				;AN000;
 30951 0000484F 9D                      	popf				;AN000; else,
 30952 00004850 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30953 00004852 F8                      	clc				;AN000; indicate it with CY bit
 30954 00004853 C3                      	retn				;AN000; CY=0 means no overflow
 30955                                  $P_0099Err:	; 31/03/2023
 30956                                  $P_COVF00:				;AN000;
 30957 00004854 F9                      	stc				;AN000; and CY=1 means overflow
 30958                                  $P_0099Err2:	; 31/03/2023
 30959 00004855 C3                      	retn				;AN000;
 30960                                  
 30961                                  ;***********************************************************************
 30962                                  ; $P_0099;
 30963                                  ;
 30964                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30965                                  ;
 30966                                  ; Input:     AL = character code
 30967                                  ;
 30968                                  ; Output:    CY = 1 : AL is not number
 30969                                  ;	     CY = 0 : AL contains binary value
 30970                                  ;***********************************************************************
 30971                                  
 30972                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30973                                  $P_0099:
 30974 00004856 3C30                    	cmp	al,"0"                  ;AN000;
 30975                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30976                                  	; 31/03/2023
 30977 00004858 72FB                    	jb	short $P_0099Err2
 30978                                  
 30979 0000485A 3C39                    	cmp	al,"9"                  ;AN000;
 30980 0000485C 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30981                                  
 30982 0000485E 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 30983                                  	; 31/03/2023
 30984                                  	;clc				;AN000; indicate no error
 30985 00004860 C3                      	retn				;AN000;
 30986                                  	 ;31/03/2023
 30987                                  ;$P_0099Err:				;AN000;
 30988                                  ;	stc				;AN000; indicate error
 30989                                  ;	retn				;AN000;
 30990                                  
 30991                                  ;***********************************************************************
 30992                                  ; $P_Simple_String
 30993                                  ;
 30994                                  ; Function:  See value list for the simple string
 30995                                  ;	     and make result buffer.
 30996                                  ;
 30997                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30998                                  ;	     ES:BX -> CONTROL block
 30999                                  ;
 31000                                  ; Output:    None
 31001                                  ;
 31002                                  ; Use:	$P_Fill_Result, $P_String_Comp
 31003                                  ;
 31004                                  ; Vars: $P_RC(W)
 31005                                  ;***********************************************************************
 31006                                  
 31007                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31008                                  
 31009                                  $P_Simple_String:
 31010 00004861 50                      	push	ax			;AN000;
 31011 00004862 53                      	push	bx			;AN000;
 31012 00004863 52                      	push	dx			;AN000;
 31013 00004864 57                      	push	di			;AN000;
 31014 00004865 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31015                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 31016 00004869 268A05                  	mov	al,[es:di]		;AN000; get nval
 31017 0000486C 08C0                    	or	al,al			;AN000; no value list ?
 31018 0000486E 7502                    	jnz	short $P_Sim00		;AN000; then
 31019                                  	; 31/03/2023
 31020                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31021 00004870 EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 31022                                  $P_Sim00:				;AN000;
 31023 00004872 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 31024 00004874 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 31025                                  
 31026 00004876 47                      	inc	di			;AN000;
 31027 00004877 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 31028 0000487A B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 31029 0000487C F6E4                    	mul	ah			;AN000;  Skip nrng field
 31030 0000487E 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 31031 0000487F 01C7                    	add	di,ax			;AN000; di points to nnval
 31032 00004881 268A05                  	mov	al,[es:di]		;AN000; get nnval
 31033 00004884 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 31034 00004886 F6E4                    	mul	ah			;AN000; Skip nnval field
 31035 00004888 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 31036 00004889 01C7                    	add	di,ax			;AN000; di points to nstrval
 31037 0000488B 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 31038 0000488E 47                      	inc	di			;AC035; add '2' to
 31039 0000488F 47                      	inc	di			;AC035;  DI reg
 31040                                  					;AN000; di points to 1st string in list
 31041                                  $P_Sim_Loop:				;AN000;
 31042 00004890 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 31043 00004893 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 31044 00004896 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 31045                                  
 31046 00004898 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 31047 0000489B FEC8                    	dec	al			;AN000; loop nstval times in AL
 31048 0000489D 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 31049                                  					;AN000; / Not found
 31050 0000489F 2EC706[F285]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 31051                                  	;mov	[cs:$P_RC],8		;AC034;
 31052                                  	; 31/03/2023
 31053                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31054 000048A6 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 31055                                  $P_Sim_Found:				;AN000;
 31056 000048A8 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 31057 000048AC B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 31058 000048AE 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 31059 000048B1 EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 31060                                  $P_Sim01:				;AN000;
 31061 000048B3 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 31062                                  	;mov	word [cs:$P_RC],9	;AC034;
 31063                                  $P_Sim_Exit:
 31064                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31065                                  ;$P_Sim_Exit:				;AN000;
 31066                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31067                                  	; 31/03/2023
 31068 000048BA B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31069                                  $P_Sim_Exit0:				;AN000;
 31070 000048BD E899FC                  	call	$P_Fill_Result		;AN000;
 31071 000048C0 5F                      	pop	di			;AN000;
 31072 000048C1 5A                      	pop	dx			;AN000;
 31073 000048C2 5B                      	pop	bx			;AN000;
 31074 000048C3 58                      	pop	ax			;AN000;
 31075 000048C4 C3                      	retn				;AN000;
 31076                                  
 31077                                  ;***********************************************************************
 31078                                  ; $P_String_Comp:
 31079                                  ;
 31080                                  ; Function:  Compare two string
 31081                                  ;
 31082                                  ; Input:     psdata_seg:SI -> 1st string
 31083                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 31084                                  ;	     ES:BX -> CONTROL block
 31085                                  ;
 31086                                  ; Output:    CY = 1 if not match
 31087                                  ;
 31088                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 31089                                  ;
 31090                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 31091                                  ;***********************************************************************
 31092                                  
 31093                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31094                                  
 31095                                  $P_String_Comp:
 31096 000048C5 50                      	push	ax			;AN000;
 31097 000048C6 55                      	push	bp			;AN000;
 31098 000048C7 52                      	push	dx			;AN000;
 31099 000048C8 56                      	push	si			;AN000;
 31100 000048C9 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31101                                  $P_SCOM_Loop:				;AN000;
 31102 000048CB 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31103 000048CE E89A04                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31104 000048D1 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31105                                  
 31106 000048D3 E822FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31107                                  	
 31108 000048D6 2EF606[FE85]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31109                                  					;AC034; keyword search ?
 31110 000048DC 740D                    	jz	short $P_SCOM04		;AN000;
 31111                                  
 31112                                  	;cmp	al,'=' ; 3Dh
 31113 000048DE 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31114 000048E0 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31115                                  
 31116 000048E2 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31117 000048E7 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31118                                  
 31119 000048E9 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31120                                  
 31121                                  $P_SCOM04:				;AN000;
 31122 000048EB 2EF606[FE85]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31123                                  					;AC034; switch search ?
 31124 000048F1 740E                    	jz	short $P_SCOM03		;AN000;
 31125                                  
 31126 000048F3 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 31127 000048F5 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 31128                                  
 31129 000048F7 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 31130 000048FC 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 31131                                  
 31132                                  $P_SCOM05:				;AN000;   found a match
 31133 000048FE 46                      	inc	si			;AN000; si points to just after "=" or ":"
 31134 000048FF EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 31135                                  
 31136                                  $P_SCOM03:				;AN000;
 31137 00004901 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 31138 00004905 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 31139                                  
 31140 00004907 08C0                    	or	al,al			;AN000; end of line
 31141 00004909 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 31142                                  
 31143 0000490B 46                      	inc	si			;AN000; update operand pointer
 31144 0000490C 45                      	inc	bp			;AN000;    and synonym pointer
 31145 0000490D EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 31146                                  
 31147                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 31148 0000490F 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 31149 00004913 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 31150                                  
 31151 00004915 46                      	inc	si			;AN000; else, load next byte
 31152 00004916 2E8A04                  	mov	al,[cs:si]		;AN000; and
 31153 00004919 45                      	inc	bp			;AN000;
 31154 0000491A 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 31155 0000491E 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 31156                                  
 31157 00004920 46                      	inc	si			;AN000; else update operand pointer
 31158 00004921 45                      	inc	bp			;AN000; 	and synonym pointer
 31159                                  $P_SCOM01:				;AN000;
 31160 00004922 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 31161                                  
 31162                                  $P_SCOM_Differ0:			;AN000;
 31163 00004924 2EF606[FE85]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h
 31164                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 31165 0000492A 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 31166                                  
 31167                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31168                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 31169                                  	; 03/04/2023
 31170 0000492C 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31171 00004931 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 31172                                  
 31173 00004933 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 31174 00004938 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 31175                                  
 31176                                  $P_not_applicable:			;AN000;(tm10)
 31177                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31178                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 31179                                  	; 03/04/2023
 31180 0000493A 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31181 0000493E 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 31182                                  
 31183 00004940 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 31184 00004942 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 31185                                  
 31186 00004944 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 31187                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 31188                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 31189                                  	; 01/04/2023
 31190 00004949 740E                    	je	short $P_SCOM_Same
 31191                                  $P_SCOM_Differ:
 31192 0000494B F9                      	stc
 31193 0000494C EB10                    	jmp	short $P_SCOM_Exit
 31194                                  
 31195                                  $P_SCOM02:				;AN000;
 31196 0000494E 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 31197 00004950 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 31198                                  
 31199                                  	;cmp	byte [es:bp],':'
 31200 00004952 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 31201                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 31202                                  	; 01/04/2023
 31203 00004957 75F2                    	jne	short $P_SCOM_Differ
 31204                                  ;$P_SCOM_Differ: 			;AN000;
 31205                                  	;stc				;AN000; indicate not found
 31206                                  	;jmp	short $P_SCOM_Exit	;AN000;
 31207                                  
 31208                                  $P_SCOM_Same:				;AN000;
 31209 00004959 2E8936[0186]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 31210                                  	; 01/04/2023
 31211                                  	;clc
 31212                                  	; cf = 0			;AN000; indicate found
 31213                                  $P_SCOM_Exit:				;AN000;
 31214 0000495E 5E                      	pop	si			;AN000;
 31215 0000495F 5A                      	pop	dx			;AN000;
 31216 00004960 5D                      	pop	bp			;AN000;
 31217 00004961 58                      	pop	ax			;AN000;
 31218 00004962 C3                      	retn				;AN000;
 31219                                  
 31220                                  ;***********************************************************************
 31221                                  ; $P_Date_Format
 31222                                  ;
 31223                                  ; Function:  Convert a date string to DOS date format for int 21h
 31224                                  ;	     with format validation.
 31225                                  ;
 31226                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31227                                  ;	     ES:BX -> CONTROL block
 31228                                  ;
 31229                                  ; Output:    None
 31230                                  ;
 31231                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 31232                                  ;
 31233                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 31234                                  ;***********************************************************************
 31235                                  
 31236                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31237                                  	; 11/08/2024
 31238                                  $P_Date_Format:
 31239 00004963 50                      	push	ax			;AN000;
 31240 00004964 51                      	push	cx			;AN000;
 31241 00004965 52                      	push	dx			;AN000;
 31242 00004966 56                      	push	si			;AN000;
 31243 00004967 53                      	push	bx			;AN000;
 31244 00004968 56                      	push	si			;AN000;
 31245 00004969 E8A400                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 31246                                  	; 03/04/2023
 31247                                  	;pop	si			;AN000;
 31248                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31249                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31250                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31251 0000496C 31F6                    	xor	si,si
 31252 0000496E 2E8936[B086]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 31253 00004973 2E8936[B286]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 31254                                  	; 11/08/2024
 31255 00004978 2E8936[B486]            	mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 31256 0000497D 5E                      	pop	si
 31257 0000497E E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 31258                                  	;jc	short $P_DateF_Err0	;AN000;-----------------------+
 31259                                  	; 11/08/2024
 31260 00004981 727A                    	jc	short $P_DateF_Error
 31261 00004983 2EA3[B086]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 31262 00004987 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31263 00004989 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31264 0000498B E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 31265 0000498E 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 31266 00004990 2EA3[B286]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 31267 00004994 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31268 00004996 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31269 00004998 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 31270                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 31271 0000499B 7260                    	jc	short $P_DateF_Error	;AN000;
 31272 0000499D 2EA3[B486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31273 000049A1 08DB                    	or	bl,bl			;AN000; end of line ?
 31274 000049A3 7558                    	jnz	short $P_DateF_Error	;AN000;
 31275                                  $P_DateF_YMD:				;AN000;
 31276 000049A5 2E8B1E[8E86]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 31277                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 31278 000049AA 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 31279 000049AD 7422                    	je	short $P_DateF00	;AN000;
 31280 000049AF 2EA1[B086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31281 000049B3 08E4                    	or	ah,ah			;AN000;
 31282 000049B5 7546                    	jnz	short $P_DateF_Error	;AN000;
 31283 000049B7 88C1                    	mov	cl,al			;AN000; set month
 31284 000049B9 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31285 000049BD 08E4                    	or	ah,ah			;AN000; if overflow, error.
 31286 000049BF 753C                    	jnz	short $P_DateF_Error	;AN000;
 31287 000049C1 88C5                    	mov	ch,al			;AN000; set date
 31288 000049C3 2E8B16[B486]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 31289 000049C8 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 31290 000049CB 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 31291 000049CD 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 31292                                  $P_DateF01:				;AN000;
 31293 000049CF EB19                    	jmp	short $P_DateF02	;AN000;
 31294                                  $P_DateF00:				;AN000; / here format = YMD
 31295 000049D1 2E8B16[B086]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 31296 000049D6 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31297 000049DA 08E4                    	or	ah,ah			;AN000; if overflow, error
 31298 000049DC 751F                    	jnz	short $P_DateF_Error	;AN000;
 31299                                  
 31300 000049DE 88C1                    	mov	cl,al			;AN000; set month
 31301 000049E0 2EA1[B486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31302 000049E4 08E4                    	or	ah,ah			;AN000; if overflow, error
 31303 000049E6 7515                    	jnz	short $P_DateF_Error	;AN000;
 31304 000049E8 88C5                    	mov	ch,al			;AN000; set date
 31305                                  $P_DateF02:				;AN000;
 31306 000049EA 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 31307 000049ED 7304                    	jae	short $P_DateF03	;AN000;
 31308 000049EF 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 31309                                  $P_DateF03:				;AN000;
 31310 000049F3 5B                      	pop	bx			;AN000; recover CONTROL block
 31311 000049F4 5E                      	pop	si			;AN000; recover string pointer
 31312                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31313                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 31314                                  	; 03/04/2023
 31315 000049F5 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 31316 000049F8 E85EFB                  	call	$P_Fill_Result		;AN000;        buffer
 31317 000049FB EB0F                    	jmp	short $P_Date_Format_Exit
 31318                                  					;AN000;	to Date
 31319                                  $P_DateF_Error: 			;AN000;
 31320 000049FD 5B                      	pop	bx			;AN000; recover CONTROL block
 31321 000049FE 5E                      	pop	si			;AN000; recover string pointer
 31322                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31323                                  	;mov	al,$P_String ; 3	;AN000;   result
 31324                                  	; 03/04/2023
 31325 000049FF B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31326 00004A02 E854FB                  	call	$P_Fill_Result		;AN000; 	buffer
 31327                                  					;AN000; to string
 31328 00004A05 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31329                                  					;AC034; indicate syntax error
 31330                                  $P_Date_Format_Exit:			;AN000;
 31331 00004A0C 5A                      	pop	dx			;AN000;
 31332 00004A0D 59                      	pop	cx			;AN000;
 31333 00004A0E 58                      	pop	ax			;AN000;
 31334 00004A0F C3                      	retn				;AN000;
 31335                                  
 31336                                  ;***********************************************************************
 31337                                  ; $P_Set_CDI:
 31338                                  ;
 31339                                  ; Function: Read CDI from DOS if it has not been read yet
 31340                                  ;
 31341                                  ; Input:    None
 31342                                  ;
 31343                                  ; Output:   psdata_seg:SI -> CDI
 31344                                  ;
 31345                                  ; Use:	INT 21h w/ AH = 38h
 31346                                  ;***********************************************************************
 31347                                  
 31348                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31349                                  $P_Set_CDI:
 31350                                  	; 18/04/2023
 31351 00004A10 8D36[8E86]              	lea	si,$P_Country_Info	;AC034;
 31352                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 31353 00004A14 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 31354                                  					;AN000; already read ?
 31355                                  	;je	short $P_Read_CDI	;AN000;
 31356                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 31357                                  	; 03/04/2023
 31358 00004A18 750F                    	jne	short $P_Set_CDI_Exit
 31359                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 31360 00004A1A 1E                      	push	ds			;AN000;
 31361 00004A1B 52                      	push	dx			;AN000;
 31362 00004A1C 50                      	push	ax			;AN000;
 31363 00004A1D 0E                      	push	cs			;AC023;
 31364 00004A1E 1F                      	pop	ds			;AN000; set segment register
 31365                                  	;mov	ax,3800h
 31366 00004A1F B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 31367 00004A22 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 31368 00004A24 CD21                    	int	21h			;AN000;
 31369 00004A26 58                      	pop	ax			;AN000;
 31370 00004A27 5A                      	pop	dx			;AN000;
 31371 00004A28 1F                      	pop	ds			;AN000;
 31372                                  $P_Set_CDI_Exit:			;AN000;
 31373 00004A29 C3                      	retn				;AN000;
 31374                                  
 31375                                  ;***********************************************************************
 31376                                  ; $P_Get_DecNum:
 31377                                  ;
 31378                                  ; Function:  Read a character code from psdata_seg:SI until specified delimiter
 31379                                  ;	     or NULL encountered. And make a decimal number.
 31380                                  ;
 31381                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31382                                  ;
 31383                                  ; Output:    BL = delimiter code or NULL
 31384                                  ;	     AX = Decimal number
 31385                                  ;	     SI advanced to the next number
 31386                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 31387                                  ;
 31388                                  ; Use:	$P_0099
 31389                                  ;***********************************************************************
 31390                                  
 31391                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31392                                  $P_Get_DecNum:
 31393 00004A2A 51                      	push	cx			;AN000;
 31394 00004A2B 52                      	push	dx			;AN000;
 31395 00004A2C 31C9                    	xor	cx,cx			;AN000; cx will have final value
 31396                                  $P_GetNum_Loop: 			;AN000;
 31397 00004A2E 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31398 00004A31 08C0                    	or	al,al			;AN000; end of line ?
 31399 00004A33 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 31400 00004A35 2E803E[8D86]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 31401 00004A3B 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 31402                                  
 31403                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 31404                                  	;cmp	bl,$P_colon_period
 31405 00004A3D 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 31406 00004A40 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 31407                                  
 31408 00004A42 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31409 00004A44 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31410                                  
 31411                                  	; 03/04/2023
 31412 00004A46 EB08                    	jmp	short $P_Do_Time_Delim1
 31413                                  ;$P_Do_Time_Delim1:			;AN000;
 31414                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31415                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31416                                  	;
 31417                                  	;jmp	short $P_Neither_Delims ;AN023;
 31418                                  
 31419                                  $P_Do_Date_Delims:			;AN000;
 31420                                  ;Regardless of the date delimiter character specified in the country
 31421                                  ;dependent information, check for the presence of any one of these
 31422                                  ;three field delimiters: "-", "/", or ".".
 31423 00004A48 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31424 00004A4A 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31425                                  
 31426 00004A4C 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31427 00004A4E 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31428                                  
 31429                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31430 00004A50 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31431 00004A52 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31432                                  
 31433                                  $P_Neither_Delims:			;AN023;
 31434 00004A54 E8FFFD                  	call	$P_0099 		;AN000; convert it to binary
 31435 00004A57 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31436                                  
 31437 00004A59 B400                    	mov	ah,0			;AN000;
 31438 00004A5B 91                      	xchg	ax,cx			;AN000;
 31439 00004A5C BA0A00                  	mov	dx,10			;AN000;
 31440 00004A5F F7E2                    	mul	dx			;AN000; ax = ax * 10
 31441 00004A61 09D2                    	or	dx,dx			;AN000; overflow
 31442 00004A63 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31443                                  
 31444 00004A65 01C8                    	add	ax,cx			;AN000;
 31445 00004A67 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31446                                  
 31447 00004A69 91                      	xchg	ax,cx			;AN000;
 31448 00004A6A 46                      	inc	si			;AN000;
 31449 00004A6B EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31450                                  
 31451                                  $P_GetNum00:				;AN000;
 31452 00004A6D 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31453                                  	;03/04/2023
 31454                                  	; cf=0
 31455                                  	;clc				;AN000; indicate no error
 31456 00004A6F EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31457                                  
 31458                                  $P_GetNum01:				;AN000;
 31459 00004A71 46                      	inc	si			;AN000; si points to next number
 31460                                  	;03/04/2023
 31461                                  	; cf=0
 31462                                  	;clc				;AN000; indicate no error
 31463 00004A72 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31464                                  
 31465                                  $P_GetNum02:				;AN000;
 31466 00004A74 F9                      	stc				;AN000; indicate error
 31467                                  $P_GetNum_Exit: 			;AN000;
 31468 00004A75 89C8                    	mov	ax,cx			;AN000;return value
 31469 00004A77 5A                      	pop	dx			;AN000;
 31470 00004A78 59                      	pop	cx			;AN000;
 31471 00004A79 C3                      	retn				;AN000;
 31472                                  
 31473                                  ;***********************************************************************
 31474                                  ; $P_Time_Format
 31475                                  ;
 31476                                  ; Function:  Convert a time string to DOS time format for int 21h
 31477                                  ;	     with format validation.
 31478                                  ;
 31479                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31480                                  ;	     ES:BX -> CONTROL block
 31481                                  ;
 31482                                  ; Output:    None
 31483                                  ;
 31484                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 31485                                  ;
 31486                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 31487                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 31488                                  ;***********************************************************************
 31489                                  
 31490                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31491                                  	; 12/08/2024
 31492                                  $P_Time_Format:				;AN000;
 31493 00004A7A 50                      	push	ax			;AN000;
 31494 00004A7B 51                      	push	cx			;AN000;
 31495 00004A7C 52                      	push	dx			;AN000;
 31496 00004A7D 56                      	push	si			;AN000;
 31497 00004A7E 53                      	push	bx			;AN000;
 31498 00004A7F 56                      	push	si			;AN000;
 31499 00004A80 E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 31500                                  					; information before process
 31501                                  	;test	byte [cs:si+11h], 1
 31502 00004A83 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 31503                                  					;AN000; 24 hour system
 31504 00004A88 5E                      	pop	si			;AN000;
 31505 00004A89 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 31506 00004A8B E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 31507                                  $P_TimeF00:				;AN000;
 31508                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31509                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31510                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31511                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 31512                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 31513                                  	; 03/04/2023
 31514 00004A8E 31DB                    	xor	bx,bx
 31515 00004A90 2E891E[B086]            	mov	[cs:$P_1st_Val],bx ; 0
 31516 00004A95 2E891E[B286]            	mov	[cs:$P_2nd_Val],bx ; 0
 31517 00004A9A 2E891E[B486]            	mov	[cs:$P_3rd_Val],bx ; 0
 31518 00004A9F 2E891E[B686]            	mov	[cs:$P_4th_Val],bx ; 0
 31519                                  	;inc	bl
 31520                                  	;mov	[cs:$P_Got_Time],bl ; 1
 31521                                  
 31522                                  	;mov	bl,$P_colon_period
 31523                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 31524                                  					; delimiters between hours,
 31525                                  					;  minutes,seconds
 31526                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 31527 00004AA4 FEC3                    	inc	bl ; bl = 1
 31528 00004AA6 2E881E[8D86]            	mov	[cs:$P_Got_Time],bl ; 1
 31529                                  	;
 31530 00004AAB E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 31531                                  	;jc	short $P_TimeF_Err0	;AN000;
 31532                                  	; 12/08/2024
 31533 00004AAE 725A                    	jc	short $P_TimeF_Error
 31534 00004AB0 2EA3[B086]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31535 00004AB4 08DB                    	or	bl,bl			;AN000; end of line ?
 31536 00004AB6 7478                    	jz	short $P_TimeF_Rlt	;AN000;
 31537 00004AB8 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31538                                  	;jc	short $P_TimeF_Err0	;AC038; if OK
 31539                                  	; 12/08/2024
 31540 00004ABB 724D                    	jc	short $P_TimeF_Error
 31541 00004ABD 2EA3[B286]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31542 00004AC1 08DB                    	or	bl,bl			;AN000; end of line ?
 31543 00004AC3 746B                    	jz	short $P_TimeF_Rlt	;AN000;
 31544 00004AC5 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31545 00004AC7 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31546                                  	;jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31547                                  	; 12/08/2024
 31548 00004ACA 723E                    	jc	short $P_TimeF_Error
 31549 00004ACC 2EA3[B486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31550 00004AD0 08DB                    	or	bl,bl			;AN000; end of line ?
 31551 00004AD2 754F                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31552                                  					;AN039;   GO TO 4TH NUMBER
 31553                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31554 00004AD4 2EF606[FD85]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31555                                  					;AN039;    BEEN REPEATED?
 31556 00004ADA 7554                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31557                                  					;AN039;   the end of line
 31558                                  					;AN039; no, time has not been repeated
 31559 00004ADC 2E8B36[F485]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31560                                  					;AN039;   in command line
 31561 00004AE1 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31562                                  					;AN039; look at delimiter
 31563                                  					;AN039;   from command line
 31564 00004AE5 7549                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31565                                  					;AN039;  really end of line
 31566                                  					;AN039; is comma before hundredths,
 31567                                  					;AN039;   redo TIME
 31568 00004AE7 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31569                                  					;AN039; change that ambiguous
 31570                                  					;AN039;    comma to a decimal point
 31571                                  					;AN039;     parse can understand
 31572 00004AEB 2EC706[FD85]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31573                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31574 00004AF2 2E800E[FD85]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31575                                  					;AN039; is being repeated
 31576 00004AF8 2E8B0E[8786]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31577 00004AFD 2E8B26[8986]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31578                                  					;AN039;   OF STACK FROM SP
 31579 00004B02 2E8B36[8B86]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31580                                  					;AN039;   PARSE POINTER FROM SI
 31581 00004B07 E927F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31582                                  
 31583                                  	; 12/08/2024
 31584                                  $P_TimeF_Error: 			;AN000;
 31585                                  $P_TimeF_Err:				;AN000;
 31586 00004B0A 5B                      	pop	bx			;AN000; recover CONTROL block
 31587 00004B0B 5E                      	pop	si			;AN000; recover string pointer
 31588                                  	;mov	ah,$P_No_Tag		;AN000; set
 31589                                  	;mov	al,$P_String		;AN000;     result
 31590                                  	; 03/04/2023
 31591 00004B0C B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31592 00004B0F E847FA                  	call	$P_Fill_Result		;AN000; 	  buffer
 31593                                  					;AN000; to string
 31594 00004B12 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31595                                  					;AC034; return syntax error
 31596                                  $P_Time_Format_Exit:			;AN000;
 31597 00004B19 2EC606[8D86]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31598 00004B1F 5A                      	pop	dx			;AN000;
 31599 00004B20 59                      	pop	cx			;AN000;
 31600 00004B21 58                      	pop	ax			;AN000;
 31601 00004B22 C3                      	retn
 31602                                  
 31603                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31604 00004B23 E804FF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31605                                  $P_TimeF_Err0:				;AN000; Bridge
 31606 00004B26 72E2                    	jc	short $P_TimeF_Error	;AN000;
 31607                                  	;
 31608 00004B28 2EA3[B686]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31609 00004B2C 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31610 00004B2E 75DA                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31611                                  $P_TimeF_Rlt:				;AN000;
 31612 00004B30 2EA1[B086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31613 00004B34 08E4                    	or	ah,ah			;AN000; if overflow then error
 31614 00004B36 75D2                    	jnz	short $P_TimeF_Err	;AN000;
 31615                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31616 00004B38 2EF606[FD85]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31617 00004B3E 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31618                                  					;since "AM" was specified,
 31619 00004B40 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31620 00004B42 77C6                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31621 00004B44 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31622 00004B46 30C0                    	xor	al,al			;AN038; set hour = zero
 31623                                  $P_Time_notAM:				;AN038;
 31624                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31625 00004B48 2EF606[FE85]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31626 00004B4E 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31627 00004B50 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31628 00004B52 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31629 00004B54 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31630 00004B56 72B2                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31631 00004B58 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31632 00004B5A 77AE                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31633                                  $P_TimeSkip00:				;AN000;
 31634 00004B5C 88C2                    	mov	dl,al			;AN000; set hour
 31635 00004B5E 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31636 00004B62 08E4                    	or	ah,ah			;AN000; if overflow then error
 31637 00004B64 75A4                    	jnz	short $P_TimeF_Err	;AN000;
 31638 00004B66 88C6                    	mov	dh,al			;AN000; set minute
 31639 00004B68 2EA1[B486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31640 00004B6C 08E4                    	or	ah,ah			;AN000; if overflow then error
 31641 00004B6E 759A                    	jnz	short $P_TimeF_Err	;AN000;
 31642 00004B70 88C1                    	mov	cl,al			;AN000; set second
 31643 00004B72 2EA1[B686]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31644 00004B76 08E4                    	or	ah,ah			;AN000; if overflow then error
 31645 00004B78 7590                    	jnz	short $P_TimeF_Err	;AN000;
 31646 00004B7A 88C5                    	mov	ch,al			;AN000; set hundredth
 31647 00004B7C 5B                      	pop	bx			;AN000; recover CONTROL block
 31648 00004B7D 5E                      	pop	si			;AN000; recover string pointer
 31649                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31650                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31651                                  	; 03/04/2023
 31652 00004B7E B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31653 00004B81 E8D5F9                  	call	$P_Fill_Result		;AN000;        buffer
 31654 00004B84 EB93                    	jmp	short $P_Time_Format_Exit
 31655                                  					;AN000; to time
 31656                                  
 31657                                  ;***********************************************************************
 31658                                  ; $P_Time_2412:
 31659                                  ;
 31660                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31661                                  ;
 31662                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31663                                  ;
 31664                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31665                                  ;	     or "pm"
 31666                                  ;
 31667                                  ; Vars:  $P_Flags(W)
 31668                                  ;***********************************************************************
 31669                                  
 31670                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31671                                  
 31672                                  $P_Time_2412:				;AN000;
 31673 00004B86 50                      	push	ax			;AN000;
 31674 00004B87 56                      	push	si			;AN000;
 31675                                  $P_T12_Loop:				;AN000;
 31676 00004B88 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31677 00004B8B 46                      	inc	si			;AN000;     si
 31678 00004B8C 08C0                    	or	al,al			;AN000;       to
 31679 00004B8E 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31680                                  
 31681 00004B90 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31682                                  	;or	al,20h
 31683 00004B94 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31684 00004B96 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31685 00004B98 7425                    	je	short $P_T1200		;AN000;
 31686                                  
 31687 00004B9A 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31688 00004B9C 7413                    	je	short $P_T1201		;AN000;
 31689                                  
 31690 00004B9E 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31691 00004BA0 751A                    	jne	short $P_T12_Exit	;AN000;
 31692                                  
 31693 00004BA2 4E                      	dec	si			;AN000;
 31694 00004BA3 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31695                                  	;or	al,20h
 31696 00004BA7 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31697 00004BA9 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31698 00004BAB 7412                    	je	short $P_T1200		;AN000;
 31699                                  
 31700 00004BAD 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31701                                  	;je	short $P_T1201		;AN000; go process "a"
 31702                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31703                                  	; 05/04/2023
 31704 00004BAF 750B                    	jne	short $P_T12_Exit
 31705                                  
 31706                                  ;$P_T1200:				;AN000; "P" found
 31707                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31708                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31709                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31710                                  
 31711                                  $P_T1201:				;AN000; "A" found
 31712                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31713 00004BB1 2E800E[FD85]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31714                                  $P_Tclr_chr:				;AN038;
 31715 00004BB7 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31716                                  $P_T12_Exit:				;AN000;
 31717 00004BBC 5E                      	pop	si			;AN000;
 31718 00004BBD 58                      	pop	ax			;AN000;
 31719 00004BBE C3                      	retn				;AN000;
 31720                                  
 31721                                  	; 05/04/2023
 31722                                  $P_T1200:				;AN000; "P" found
 31723                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31724 00004BBF 2E800E[FE85]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31725 00004BC5 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31726                                  
 31727                                  ;***********************************************************************
 31728                                  ; $P_File_Format;
 31729                                  ;
 31730                                  ; Function:  Check if the input string is valid file spec format.
 31731                                  ;	     And set the result buffer.
 31732                                  ;
 31733                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31734                                  ;	     ES:BX -> CONTROL block
 31735                                  ;
 31736                                  ; Output:    None
 31737                                  ;
 31738                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31739                                  ;
 31740                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31741                                  ;	$P_SaveSI_Cmpx(R)
 31742                                  ;***********************************************************************
 31743                                  
 31744                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31745                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31746                                  $P_File_Format:
 31747 00004BC7 50                      	push	ax			;AN000;
 31748 00004BC8 57                      	push	di			;AN000;
 31749 00004BC9 56                      	push	si			;AN000;
 31750 00004BCA 2E8B3E[FF85]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31751 00004BCF 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31752 00004BD2 08C0                    	or	al,al			;AN000; end of line ?
 31753 00004BD4 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31754 00004BD6 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31755 00004BD9 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31756 00004BDB 2EC606[CB86]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31757                                  					;AN033;AC034;; set error flag- bad char.
 31758 00004BE1 5E                      	pop	si			;AN033;
 31759 00004BE2 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31760 00004BE6 5F                      	pop	di			;AN033;
 31761 00004BE7 EB3E                    	jmp	short $P_FileF02	;AN033;
 31762                                  $P_FileF_Err:				;AN000;
 31763 00004BE9 5E                      	pop	si			;AN000;
 31764 00004BEA 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31765 00004BEE 5F                      	pop	di			;AN000;
 31766                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31767                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31768 00004BEF 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31769 00004BF3 7532                    	jnz	short $P_FileF02	;AN000;
 31770 00004BF5 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31771                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31772 00004BFC EB29                    	jmp	short $P_FileF02	;AN000;
 31773                                  $P_FileF03:				;AN000;
 31774 00004BFE 58                      	pop	ax			;AN000; discard save si
 31775 00004BFF 56                      	push	si			;AN000; save new si
 31776                                  $P_FileF_Loop1: 			;AN000;
 31777 00004C00 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31778 00004C03 08C0                    	or	al,al			;AN000; end of line ?
 31779 00004C05 741E                    	jz	short $P_FileF_RLT	;AN000;
 31780 00004C07 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31781 00004C0A 740B                    	jz	short $P_FileF00	;AN000;
 31782 00004C0C E85C01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31783 00004C0F 7302                    	jnc	short $P_FileF01	;AN000;
 31784 00004C11 47                      	inc	di			;AN000; if yes, skip next byte
 31785 00004C12 46                      	inc	si			;AN000;
 31786                                  $P_FileF01:				;AN000;
 31787 00004C13 47                      	inc	di			;AN000;
 31788 00004C14 46                      	inc	si			;AN000;
 31789 00004C15 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31790                                  $P_FileF00:				;AN000;
 31791 00004C17 2EA2[F885]              	mov	[cs:$P_Terminator],al	;AC034;
 31792 00004C1B 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31793 00004C1F 47                      	inc	di			;AN000;
 31794 00004C20 2E893E[F485]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31795                                  $P_FileF_RLT:				;AN000;
 31796 00004C25 5E                      	pop	si			;AN000;
 31797 00004C26 5F                      	pop	di			;AN000;
 31798                                  $P_FileF02:				;AN000;
 31799 00004C27 58                      	pop	ax			;AN000; (tm14)
 31800                                  	;;test	ax,200h
 31801                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31802                                  	; 05/04/2023
 31803 00004C28 F6C402                  	test	ah,($P_File_Spc>>8)
 31804 00004C2B 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31805 00004C2D 50                      	push	ax			;AN000; (tm14)
 31806                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31807                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31808                                  	; 05/04/2023
 31809 00004C2E B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31810 00004C31 E825F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31811 00004C34 58                      	pop	ax			;AN000;
 31812                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31813 00004C35 C3                      	retn				;AN000;
 31814                                  
 31815                                  ;***********************************************************************
 31816                                  ; $P_FileSp_Chk
 31817                                  ;
 31818                                  ; Function:  Check if the input byte is one of file special characters
 31819                                  ;
 31820                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31821                                  ;	     AL = character code to be examineed
 31822                                  ;
 31823                                  ; Output:    ZF = 1 , AL is one of special characters
 31824                                  ;***********************************************************************
 31825                                  
 31826                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31827                                  $P_FileSp_Chk:
 31828 00004C36 53                      	push	bx			;AN000;
 31829 00004C37 51                      	push	cx			;AN000;
 31830                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31831 00004C38 8D1E[C286]              	lea	bx,$P_FileSp_Char
 31832 00004C3C B90900                  	mov	cx,$P_FileSp_Len ; 9
 31833                                  	;mov	cx,9			;AN000; load length of it
 31834                                  $P_FileSp_Loop: 			;AN000;
 31835 00004C3F 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31836 00004C42 7404                    	je	short $P_FileSp_Exit	;AN000;
 31837 00004C44 43                      	inc	bx			;AN000;
 31838 00004C45 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31839 00004C47 41                      	inc	cx			;AN000; reset ZF
 31840                                  $P_FileSp_Exit: 			;AN000;
 31841 00004C48 59                      	pop	cx			;AN000;
 31842 00004C49 5B                      	pop	bx			;AN000;
 31843 00004C4A C3                      	retn				;AN000;
 31844                                  
 31845                                  ;***********************************************************************
 31846                                  ; $P_Drive_Format;
 31847                                  ;
 31848                                  ; Function:  Check if the input string is valid drive only format.
 31849                                  ;	     And set the result buffer.
 31850                                  ;
 31851                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31852                                  ;	     ES:BX -> CONTROL block
 31853                                  ;
 31854                                  ; Output:    None
 31855                                  ;
 31856                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31857                                  ;
 31858                                  ; Vars: $P_RC(W)
 31859                                  ;***********************************************************************
 31860                                  
 31861                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31862                                  $P_Drive_Format:
 31863 00004C4B 50                      	push	ax			;AN000;
 31864 00004C4C 52                      	push	dx			;AN000;
 31865 00004C4D 2E8A04                  	mov	al,[cs:si]		;AN000;
 31866 00004C50 08C0                    	or	al,al			;AN000; if null string
 31867 00004C52 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31868 00004C54 E81401                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31869 00004C57 722A                    	jc	short $P_Drv_Err	;AN000;
 31870                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31871 00004C59 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31872 00004C5E 740D                    	je	short $P_DrvF00		;AN000;
 31873                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31874                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31875 00004C60 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31876 00004C64 741D                    	jz	short $P_Drv_Err	;AN000;
 31877 00004C66 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31878 00004C6B 7516                    	jne	short $P_Drv_Err	;AN000;
 31879                                  $P_DrvF00:				;AN000;
 31880 00004C6D 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31881 00004C6F 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31882 00004C71 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31883 00004C73 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31884 00004C75 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31885 00004C77 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31886 00004C79 88C2                    	mov	dl,al			;AN000; set
 31887                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31888                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31889                                  	; 05/04/2023
 31890 00004C7B B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31891 00004C7E E8D8F8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31892 00004C81 EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31893                                  $P_Drv_Err:				;AN000;
 31894 00004C83 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 31895                                  	;mov	word [cs:$P_RC],9	;AC034;
 31896                                  $P_Drv_Exit:				;AN000;
 31897 00004C8A 5A                      	pop	dx			;AN000;
 31898 00004C8B 58                      	pop	ax			;AN000;
 31899 00004C8C C3                      	retn				;AN000;
 31900                                  
 31901                                  ;***********************************************************************
 31902                                  ; $P_Skip_Delim;
 31903                                  ;
 31904                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31905                                  ;	    and comma.
 31906                                  ;
 31907                                  ; Input:    DS:SI -> Command String
 31908                                  ;	    ES:DI -> Parameter List
 31909                                  ;
 31910                                  ; Output:   CY = 1 if the end of line encounterd
 31911                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31912                                  ;	    AL = Last examineed character
 31913                                  ;
 31914                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31915                                  ;
 31916                                  ; Vars:     $P_Flags(R)
 31917                                  ;***********************************************************************
 31918                                  
 31919                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31920                                  
 31921                                  $P_Skip_Delim:				;AN000;
 31922                                  $P_Skip_Delim_Loop:			;AN000;
 31923 00004C8D AC                      	lodsb				;AN000;
 31924 00004C8E E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31925 00004C91 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31926                                  
 31927 00004C93 E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31928 00004C96 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31929                                  
 31930 00004C98 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra
 31931                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31932 00004C9E 74ED                    	jz	short $P_Skip_Delim_Loop
 31933                                  					;AN000; if no, loop
 31934 00004CA0 2EF606[FE85]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31935                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31936                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31937                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31938                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31939                                  	; 05/04/2023
 31940 00004CA6 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31941                                  $P_Exit_At_Extra:			;AN000;
 31942                                  	; cf = 0
 31943                                  	;clc				;AN000; indicate extra delim
 31944 00004CA8 C3                      	retn				;AN000;
 31945                                  
 31946                                  $P_Skip_Delim_CY:			;AN000;
 31947 00004CA9 F9                      	stc				;AN000; indicate EOL
 31948 00004CAA EB01                    	jmp	short $P_Skip_Delim_Exit
 31949                                  					;AN000;
 31950                                  $P_Skip_Delim_NCY:			;AN000;
 31951 00004CAC F8                      	clc				;AN000; indicate non delim
 31952                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31953 00004CAD 4E                      	dec	si ; *			;AN000;  backup index pointer
 31954 00004CAE C3                      	retn				;AN000;
 31955                                  	; 05/04/2023
 31956                                  ;$P_Exit_At_Extra:			;AN000;
 31957                                  	;clc				;AN000; indicate extra delim
 31958                                  	;retn				;AN000;
 31959                                  
 31960                                  ;***********************************************************************
 31961                                  ; $P_Chk_EOL;
 31962                                  ;
 31963                                  ; Function: Check if AL is one of End of Line characters.
 31964                                  ;
 31965                                  ; Input:    AL = character code
 31966                                  ;	    ES:DI -> Parameter List
 31967                                  ;
 31968                                  ; Output:   ZF = 1 if one of End of Line characters
 31969                                  ;***********************************************************************
 31970                                  
 31971                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31972                                  
 31973                                  $P_Chk_EOL:
 31974 00004CAF 53                      	push	bx			;AN000;
 31975 00004CB0 51                      	push	cx			;AN000;
 31976 00004CB1 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31977 00004CB3 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31978 00004CB5 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 31979 00004CB7 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31980 00004CB9 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 31981                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 31982 00004CBE 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 31983 00004CC0 31DB                    	xor	bx,bx			;AN000;
 31984 00004CC2 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31985                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 31986 00004CC6 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 31987 00004CC9 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 31988                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 31989 00004CCD 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 31990 00004CCF 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 31991 00004CD1 268A09                  	mov	cl,[es:bx+di]		;AN000;
 31992                                  $P_Chk_EOL_Loop:			;AN000;
 31993 00004CD4 43                      	inc	bx			;AN000;
 31994 00004CD5 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 31995 00004CD8 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31996 00004CDA E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 31997                                  $P_Chk_EOL_NZ:				;AN000;
 31998 00004CDC 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 31999                                  $P_Chk_EOL_Exit:			;AN000;
 32000 00004CDE 59                      	pop	cx			;AN000;
 32001 00004CDF 5B                      	pop	bx			;AN000;
 32002 00004CE0 C3                      	retn				;AN000;
 32003                                  
 32004                                  ;***********************************************************************
 32005                                  ; $P_Chk_Delim;
 32006                                  ;
 32007                                  ; Function: Check if AL is one of delimiter characters.
 32008                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 32009                                  ;	    blanks.
 32010                                  ;
 32011                                  ; Input:    AL = character code
 32012                                  ;	    DS:SI -> Next Character
 32013                                  ;	    ES:DI -> Parameter List
 32014                                  ;
 32015                                  ; Output:   ZF = 1 if one of delimiter characters
 32016                                  ;	    SI points to the next character
 32017                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 32018                                  ;***********************************************************************
 32019                                  
 32020                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32021                                  	; 12/08/2024
 32022                                  $P_Chk_Delim:
 32023 00004CE1 53                      	push	bx			;AN000;
 32024 00004CE2 51                      	push	cx			;AN000;
 32025 00004CE3 2EC606[F885]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 32026                                  					;AC034; Assume terminated by space
 32027 00004CE9 2E8026[FE85]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 32028                                  					;AC034;
 32029 00004CEF 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 32030 00004CF1 7434                    	je	short $P_Chk_Delim_Exit	;AN000;
 32031                                  
 32032 00004CF3 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 32033 00004CF5 7430                    	je	short $P_Chk_Delim_Exit	;AN000;
 32034                                  
 32035 00004CF7 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 32036 00004CF9 742F                    	je	short $P_Chk_Delim_Exit0
 32037                                  					;AN000;
 32038                                  $P_Chk_Delim00: 			;AN000;
 32039 00004CFB 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 32040 00004CFD 750C                    	jne	short $P_Chk_Delim01	;AN000;
 32041 00004CFF 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 32042                                  					;AN000; 2nd byte of DBCS Space ?
 32043 00004D02 7507                    	jne	short $P_Chk_Delim01	;AN000;
 32044 00004D04 B020                    	mov	al,$P_Space ; 20h	;AN000;
 32045 00004D06 46                      	inc	si			;AN000; make si point to next character
 32046 00004D07 38C0                    	cmp	al,al			;AN000; Set ZF
 32047 00004D09 EB1C                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32048                                  
 32049                                  $P_Chk_Delim01: 			;AN000;
 32050                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 32051 00004D0B 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 32052                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 32053 00004D10 7215                    	jb	short $P_Chk_Delim_Exit	;AN000;
 32054                                  
 32055 00004D12 31C9                    	xor	cx,cx			;AN000;
 32056 00004D14 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32057                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 32058                                  	;or	cx,cx			;AN000; No extra Delim character ?
 32059                                  	;jz	short $P_Chk_Delim_NZ	;AN000;
 32060                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 32061 00004D18 E30B                    	jcxz	$P_Chk_Delim_NZ
 32062                                  
 32063 00004D1A BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 32064                                  $P_Chk_Delim_Loop:			;AN000;
 32065 00004D1D 43                      	inc	bx			;AN000;
 32066 00004D1E 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 32067 00004D21 7407                    	je	short $P_Chk_Delim_Exit0
 32068                                  					;AN000;
 32069 00004D23 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 32070                                  
 32071                                  $P_Chk_Delim_NZ:			;AN000;
 32072 00004D25 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 32073                                  $P_Chk_Delim_Exit:			;AN000;
 32074 00004D27 59                      	pop	cx			;AN000;
 32075 00004D28 5B                      	pop	bx			;AN000;
 32076 00004D29 C3                      	retn				;AN000;
 32077                                  
 32078                                  $P_Chk_Delim_Exit0:			;AN000;
 32079 00004D2A 2EA2[F885]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 32080 00004D2E 2EF606[FE85]01          	test	byte [cs:$P_Flags2],$P_equ
 32081                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 32082 00004D34 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 32083                                  
 32084 00004D36 2E800E[FE85]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 32085                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 32086                                  $P_No_Set_Extra:			;AN027;
 32087 00004D3C 38C0                    	cmp	al,al			;AN000; set ZF
 32088 00004D3E EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32089                                  
 32090                                  ;***********************************************************************
 32091                                  ; $P_Chk_Switch;
 32092                                  ;
 32093                                  ; Function: Check if AL is the switch character not in first position of
 32094                                  ;	    $P_STRING_BUF
 32095                                  ;
 32096                                  ; Input:    AL = character code
 32097                                  ;	    BX = current pointer within $P_String_Buf
 32098                                  ;	    SI =>next char on command line (following the one in AL)
 32099                                  ;
 32100                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 32101                                  ;		 position, and has no chance of being part of a date string,
 32102                                  ;		 i.e. should be treated as a delimiter.
 32103                                  ;
 32104                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 32105                                  ;		 position, or is a slash but may be part of a date string, i.e.
 32106                                  ;		 should not be treated as a delimiter.
 32107                                  ;
 32108                                  ; Vars:  $P_Terminator(W)
 32109                                  ;
 32110                                  ; Use:	 $P_0099
 32111                                  ;***********************************************************************
 32112                                  
 32113                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32114                                  
 32115                                  $P_Chk_Switch:
 32116                                  	; 18/04/2023
 32117 00004D40 8D2E[0786]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 32118                                  
 32119 00004D44 39EB                    	cmp	bx,bp			;AN000;
 32120 00004D46 7418                    	je	short $P_STRUC_L2	;AN000;
 32121                                  
 32122 00004D48 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32123 00004D4A 7512                    	jne	short $P_STRUC_L5	;AN000;
 32124                                  
 32125 00004D4C F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 32126 00004D4D 50                      	push	ax			;AN020;save input char
 32127 00004D4E 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 32128 00004D52 E801FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 32129 00004D55 7205                    	jc	short $P_STRUC_L7	;AN000;
 32130                                  
 32131 00004D57 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 32132 00004D59 E8FAFA                  	call	$P_0099			;AN020;return carry set if not numeric
 32133                                  $P_STRUC_L7:				;AN000;
 32134 00004D5C 58                      	pop	ax			;AN020;restore AL to input char
 32135                                  	;jmp	short $P_STRUC_L1	;AN000;
 32136                                  	; 18/04/2023
 32137 00004D5D C3                      	retn
 32138                                  
 32139                                  $P_STRUC_L5:				;AN000;
 32140 00004D5E F8                      	clc				;AN020;not a slash
 32141                                  	;jmp	short $P_STRUC_L1	;AN000;
 32142                                  	 ;18/04/2023
 32143 00004D5F C3                      	retn
 32144                                  
 32145                                  $P_STRUC_L2:				;AN000;
 32146 00004D60 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32147                                  	;jne	short $P_STRUC_L12	;AN000;
 32148                                  	; 18/04/2023
 32149 00004D62 75FA                    	jne	short $P_STRUC_L5
 32150                                  
 32151 00004D64 2E800E[FE85]40          	or	byte [cs:$P_Flags2],$P_SW
 32152                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 32153                                  	; 18/04/2023
 32154                                  ;$P_STRUC_L12:				;AN000;
 32155                                  	;clc				;AN020;CF=0 indicating first char
 32156                                  $P_STRUC_L1:				;AN000;
 32157 00004D6A C3                      	retn				;AN000;
 32158                                  
 32159                                  ;**************************************************************************
 32160                                  ; $P_Chk_DBCS:
 32161                                  ;
 32162                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 32163                                  ;
 32164                                  ;  Input:
 32165                                  ;	  AL	= Code to be examineed
 32166                                  ;
 32167                                  ;  Output:
 32168                                  ;	  If CF is on then a lead byte of DBCS
 32169                                  ;
 32170                                  ; Use: INT 21h w/AH=63
 32171                                  ;
 32172                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 32173                                  ;***************************************************************************
 32174                                  
 32175                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32176                                  	; 12/08/2024
 32177                                  $P_Chk_DBCS:
 32178 00004D6B 1E                      	push	ds			;AN000;
 32179 00004D6C 56                      	push	si			;AN000;
 32180 00004D6D 53                      	push	bx			;AN000; (tm11)
 32181 00004D6E 2E833E[FB85]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 32182                                  					;AC034; ALREADY SET ?
 32183 00004D74 7527                    	jne	short $P_DBCS00		;AN000;
 32184 00004D76 50                      	push	ax			;AN000;
 32185 00004D77 1E                      	push	ds			;AN000; (tm11)
 32186 00004D78 51                      	push	cx			;AN000;
 32187 00004D79 52                      	push	dx			;AN000;
 32188 00004D7A 57                      	push	di			;AN000;
 32189 00004D7B 55                      	push	bp			;AN000;
 32190 00004D7C 06                      	push	es			;AN000;
 32191 00004D7D 31F6                    	xor	si,si			;AN000;
 32192 00004D7F 8EDE                    	mov	ds,si			;AN000;
 32193                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 32194 00004D81 B80063                  	mov	ax,6300h
 32195 00004D84 CD21                    	int	21h			;AN000;
 32196 00004D86 8CDB                    	mov	bx,ds			;AN000; (tm11)
 32197 00004D88 09DB                    	or	bx,bx			;AN000; (tm11)
 32198 00004D8A 07                      	pop	es			;AN000;
 32199 00004D8B 5D                      	pop	bp			;AN000;
 32200 00004D8C 5F                      	pop	di			;AN000;
 32201 00004D8D 5A                      	pop	dx			;AN000;
 32202 00004D8E 59                      	pop	cx			;AN000;
 32203 00004D8F 1F                      	pop	ds			;AN000; (tm11)
 32204 00004D90 58                      	pop	ax			;AN000;
 32205 00004D91 7424                    	jz	short $P_NON_DBCS	;AN000;
 32206                                  $P_DBCS02:				;AN000;
 32207 00004D93 2E8936[F985]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 32208 00004D98 2E891E[FB85]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 32209                                  $P_DBCS00:				;AN000;
 32210                                  	;mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 32211                                  	;mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 32212                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 32213 00004D9D 2EC536[F985]            	lds	si,[cs:$P_DBCSEV_OFF]
 32214                                  $P_DBCS_LOOP:				;AN000;
 32215 00004DA2 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 32216 00004DA5 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 32217 00004DA7 3A04                    	cmp	al,[si] 		;AN000;
 32218 00004DA9 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 32219 00004DAB 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 32220 00004DAE 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 32221 00004DB0 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 32222 00004DB1 EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 32223                                  $P_DBCS01:				;AN000;
 32224 00004DB3 46                      	inc	si			;AC035; add '2' to
 32225 00004DB4 46                      	inc	si			;AC035;  SI reg
 32226                                  					;AN000; get next vector
 32227 00004DB5 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 32228                                  
 32229                                  $P_NON_DBCS:				;AN000;
 32230                                  	; 18/04/2023
 32231                                  	; cf=0
 32232                                  	;clc				;AN000; indicate SBCS
 32233                                  $P_DBCS_EXIT:				;AN000;
 32234 00004DB7 5B                      	pop	bx			;AN000; (tm11)
 32235 00004DB8 5E                      	pop	si			;AN000;
 32236 00004DB9 1F                      	pop	ds			;AN000;
 32237 00004DBA C3                      	retn				;AN000;
 32238                                  
 32239                                  ;============================================================================
 32240                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 32241                                  ;============================================================================
 32242                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32243                                  
 32244                                  ; ****************************************************************
 32245                                  ; *
 32246                                  ; * ROUTINE:	 CMD_PARSE
 32247                                  ; *
 32248                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 32249                                  ; *		 SYSPARSE.
 32250                                  ; *
 32251                                  ; * INPUT:	 inputs to SYSPARSE
 32252                                  ; *
 32253                                  ; * OUTPUT:	 outputs from SYSPARSE
 32254                                  ; *
 32255                                  ; ****************************************************************
 32256                                  
 32257                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32258                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 32259                                  ;cmd_parse:
 32260                                  	;call	sysparse		;AN000;
 32261                                  	;retn				;AN000;
 32262                                  	; 06/04/2023
 32263                                  	;jmp	sysparse
 32264                                  
 32265                                  append_parse:
 32266 00004DBB E85DF5                  	call	sysparse		;AN010;
 32267 00004DBE CB                      	retf				;AN010;
 32268                                  
 32269                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32270                                  %if 0
 32271                                  
 32272                                  ;============================================================================
 32273                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 32274                                  ;============================================================================
 32275                                  ; 30/09/2018 - Retro DOS v3.0
 32276                                  
 32277                                  ; BREAK	<Message Printing Routine>
 32278                                  
 32279                                  ;
 32280                                  ;	MSDOS V3.00 PRINT
 32281                                  ;
 32282                                  ;	Message Printing Routine
 32283                                  ;
 32284                                  
 32285                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 32286                                  ;
 32287                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 32288                                  ;
 32289                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 32290                                  ;
 32291                                  ; Characters are output to PFHandle according to the
 32292                                  ; specifications contained in the Control String.
 32293                                  ;
 32294                                  ; The conversion characters are as follow:
 32295                                  ;
 32296                                  ;               %c - output the next argument as a character
 32297                                  ;               %s - output the next argument as a string
 32298                                  ;               %x - output the next argument as a hexidecimal number
 32299                                  ;                    using abcedf
 32300                                  ;               %X - output the next argument as a hexidecimal number
 32301                                  ;                    using ABCDEF
 32302                                  ;               %d - output the next argument as a decimal number
 32303                                  ;
 32304                                  ;
 32305                                  ; Other format specifiers that may precede the conversion character are:
 32306                                  ;
 32307                                  ;               - (minus sign) - causes the field to be left-adjusted
 32308                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 32309                                  ;               n - digit specifing the minimum field width (default to 1)
 32310                                  ;               L - specifing a long integer
 32311                                  ;
 32312                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 32313                                  ;   to an argument list.
 32314                                  ;
 32315                                  ;   ____________________
 32316                                  ;   |   Ret Addr       |      <= SP
 32317                                  ;   --------------------
 32318                                  ;   |  Ptr to Arg List |
 32319                                  ;   --------------------
 32320                                  ;
 32321                                  ;   And the argument list contains the following:
 32322                                  ;
 32323                                  ;       String_ptr                  (a pointer to the control string)
 32324                                  ;       Arg 1
 32325                                  ;       Arg 2
 32326                                  ;         .
 32327                                  ;         .
 32328                                  ;         .
 32329                                  ;       Arg n-1
 32330                                  ;       Arg n
 32331                                  ;
 32332                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 32333                                  ;   or character.
 32334                                  ;
 32335                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 32336                                  
 32337                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 32338                                  
 32339                                  ; =============== S U B	R O U T	I N E =======================================
 32340                                  
 32341                                  PRINTF_INIT:
 32342                                  	call	STD_PRINTF
 32343                                  	retf
 32344                                  
 32345                                  ; =============== S U B	R O U T	I N E =======================================
 32346                                  
 32347                                  PRINTF_CRLF:
 32348                                  	call	STD_PRINTF
 32349                                  	;call	CRLF2
 32350                                  	;retn
 32351                                  	; 07/04/2023
 32352                                  	jmp	CRLF2
 32353                                  
 32354                                  ; =============== S U B	R O U T	I N E =======================================
 32355                                  
 32356                                  STD_EPRINTF:
 32357                                  	mov	word [cs:PRINTF_HANDLE],2
 32358                                  	jmp	short new_printf
 32359                                  
 32360                                  ; =============== S U B	R O U T	I N E =======================================
 32361                                  
 32362                                  STD_PRINTF:
 32363                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 32364                                  
 32365                                  	mov	word [cs:PRINTF_HANDLE],1
 32366                                  NEW_PRINTF:				;Save the callers' registers
 32367                                  	cld
 32368                                  	push	dx
 32369                                  	push	bp
 32370                                  	mov	bp,sp
 32371                                  	push	cx
 32372                                  	push	bx
 32373                                  	push	ax
 32374                                  	push	di
 32375                                  	push	si
 32376                                  	push	es
 32377                                  	push	ds
 32378                                  	push	cs
 32379                                  	pop	es		;ES points to Printf segment
 32380                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 32381                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 32382                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 32383                                  	mov	si,[ds:bp] ; bp
 32384                                  	add	bp,2
 32385                                  	xor	bx,bx
 32386                                  	call	CLEAR_FLAGS	; initialize the world
 32387                                  
 32388                                  GET_CHAR:
 32389                                  	lodsb			;Get a character
 32390                                  	cmp	al,'%'		;Is it a conversion specifier?
 32391                                  	jz	short CONV_CHAR	;Yes - find out which one
 32392                                  	or	al,al		;Is it the end of the control string?
 32393                                  	jz	short PRINTF_DONE ;Yes - then we're done
 32394                                  PRINTF_PERCENT:				
 32395                                  	call	OUTCHR		;Otherwise store the character
 32396                                  	jmp	short GET_CHAR	;And go get another
 32397                                  
 32398                                  PRINTF_DONE:
 32399                                  	call	FLUSH
 32400                                  	pop	ds
 32401                                  	pop	es
 32402                                  	pop	si
 32403                                  	pop	di
 32404                                  	pop	ax
 32405                                  	pop	bx
 32406                                  	pop	cx
 32407                                  	pop	bp
 32408                                  	pop	dx
 32409                                  	retn
 32410                                  
 32411                                  CONV_CHAR:
 32412                                  	mov	byte [cs:PRINTF_LEFT],0
 32413                                  
 32414                                  NXT_CONV_CHAR:	
 32415                                  	;Look for any format specifiers preceeding the conversion character
 32416                                  	lodsb
 32417                                  	cmp	al,'%'			;Just print the %
 32418                                  	jz	short PRINTF_PERCENT
 32419                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 32420                                  	jz	short LEFT_ADJ
 32421                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 32422                                  	jz	short CONV_CHAR
 32423                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 32424                                  	jz	short LONG_INT
 32425                                  	cmp	al,[cs:char_l]	 ; "l"		
 32426                                  	jz	short LONG_INT
 32427                                  	cmp	al,'0'			;Is it a precision specification
 32428                                  	jb	short LOOK_CONV_CHAR
 32429                                  	cmp	al,'9'
 32430                                  	ja	short LOOK_CONV_CHAR
 32431                                  	cmp	al,'0'
 32432                                  	jnz	short NOT_PAD
 32433                                  	cmp	word [cs:PRINTF_WIDTH],0
 32434                                  	jnz	short NOT_PAD
 32435                                  	mov	ah,'0'
 32436                                  	mov	[cs:PAD_CHAR],ah
 32437                                  NOT_PAD:					;Adjust decimal place on precision
 32438                                  	push	ax
 32439                                  	mov	ax,[cs:PRINTF_WIDTH]
 32440                                  	mov	cx,10
 32441                                  	mul	cx
 32442                                  	pop	dx
 32443                                  	xor	dh,dh
 32444                                  	sub	dl,'0'
 32445                                  	add	ax,dx
 32446                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 32447                                  	jmp	short NXT_CONV_CHAR
 32448                                  
 32449                                  LEFT_ADJ:
 32450                                  	mov	byte [cs:PRINTF_LEFT],1
 32451                                  	jmp	short NXT_CONV_CHAR
 32452                                  
 32453                                  LONG_INT:
 32454                                  	or	byte [cs:PRINTF_LONG],1
 32455                                  	jmp	short NXT_CONV_CHAR
 32456                                  
 32457                                  LOOK_CONV_CHAR:
 32458                                  	and	al,0DFh
 32459                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 32460                                  	jz	short HEX_UP
 32461                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 32462                                  	jz	short DECIMAL
 32463                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 32464                                  	jz	short C_PUT_CHAR
 32465                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 32466                                  	jz	short S_PUT_STRG
 32467                                  	call	CLEAR_FLAGS
 32468                                  	jmp	GET_CHAR
 32469                                  
 32470                                  HEX_UP:
 32471                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 32472                                  	jmp	short CONV_TO_NUM
 32473                                  DECIMAL:
 32474                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 32475                                  	jmp	short CONV_TO_NUM
 32476                                  
 32477                                  C_PUT_CHAR:
 32478                                  	call	NEXT_CHRS
 32479                                  	mov	al,dl
 32480                                  	call	OUTCHR
 32481                                  	call	CLEAR_FLAGS
 32482                                  	jmp	GET_CHAR
 32483                                  
 32484                                  S_PUT_STRG:
 32485                                  	push	si			;Save pointer to control string
 32486                                  	call	NEXT_CHRS
 32487                                  	mov	si,dx
 32488                                  S_PUT_1:
 32489                                  	mov	cx,[cs:PRINTF_WIDTH]
 32490                                  	or	cx,cx
 32491                                  	jz	short S_PUT_2
 32492                                  	cmp	byte [cs:PRINTF_LEFT],0
 32493                                  	jnz	short S_PUT_2
 32494                                  	call	PAD_STRING
 32495                                  S_PUT_2:
 32496                                  	push	si
 32497                                  S_PUT_3:
 32498                                  	lodsb
 32499                                  	or	al,al
 32500                                  	jz	short S_PUT_4
 32501                                  	call	OUTCHR			;Put it into our buffer
 32502                                  	jmp	short S_PUT_3
 32503                                  S_PUT_4:
 32504                                  	pop	si
 32505                                  	cmp	byte [cs:PRINTF_LEFT],0
 32506                                  	jz	short C_S_END
 32507                                  	mov	cx,[cs:PRINTF_WIDTH]
 32508                                  	or	cx,cx
 32509                                  	jz	short C_S_END
 32510                                  	call	PAD_STRING
 32511                                  C_S_END:
 32512                                  	pop	si			;Restore control string pointer
 32513                                  	call	CLEAR_FLAGS
 32514                                  	jmp	GET_CHAR		;Go get another character	
 32515                                  
 32516                                  
 32517                                  ; =============== S U B	R O U T	I N E =======================================
 32518                                  
 32519                                  PAD_STRING:
 32520                                  	xor	dx,dx
 32521                                  	push	si
 32522                                  
 32523                                  COUNT_LOOP:
 32524                                  	lodsb
 32525                                  	or	al,al
 32526                                  	jz	short COUNT_DONE
 32527                                  	inc	dx
 32528                                  	jmp	short COUNT_LOOP
 32529                                  
 32530                                  COUNT_DONE:
 32531                                  	pop	si
 32532                                  	sub	cx,dx
 32533                                  	jbe	short COUNT_RET
 32534                                  	call	PAD
 32535                                  
 32536                                  COUNT_RET:
 32537                                  	retn
 32538                                  
 32539                                  ; ---------------------------------------------------------------------------
 32540                                  
 32541                                  CONV_TO_NUM:
 32542                                  	call	NEXT_CHRS
 32543                                  	mov	ax,dx
 32544                                  	xor	dx,dx
 32545                                  	cmp	byte [cs:PRINTF_LONG],0 
 32546                                  			;Is this is a short or long integer?
 32547                                  	jz	short NOT_LONG_INT
 32548                                  	call	NEXT_CHRS
 32549                                  
 32550                                  NOT_LONG_INT:
 32551                                  	push	bx
 32552                                  	push	si
 32553                                  	mov	si,[cs:PRINTF_BASE]
 32554                                  	mov	cx,[cs:PRINTF_WIDTH]
 32555                                  	call	PNUM
 32556                                  	pop	si
 32557                                  	pop	bx
 32558                                  	call	PAD
 32559                                  	call	CLEAR_FLAGS
 32560                                  	jmp	GET_CHAR
 32561                                  
 32562                                  
 32563                                  ; =============== S U B	R O U T	I N E =======================================
 32564                                  
 32565                                  PNUM:
 32566                                  	dec	cx
 32567                                  	push	ax
 32568                                  	mov	ax,dx
 32569                                  	xor	dx,dx
 32570                                  	div	si
 32571                                  	mov	bx,ax
 32572                                  	pop	ax
 32573                                  	div	si
 32574                                  	xchg	bx,dx
 32575                                  	push	ax
 32576                                  	or	ax,dx
 32577                                  	pop	ax
 32578                                  	jz	short DO_PAD
 32579                                  	push	bx
 32580                                  	call	PNUM
 32581                                  	pop	bx
 32582                                  	jmp	short REM
 32583                                  
 32584                                  DO_PAD:
 32585                                  	cmp	byte [cs:PRINTF_LEFT],0
 32586                                  	jnz	short REM
 32587                                  	call	PAD
 32588                                  REM:
 32589                                  	cmp	bl,10
 32590                                  	jb	short NOT_HEX
 32591                                  	add	bx,6
 32592                                  NOT_HEX:
 32593                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32594                                  	push	cx
 32595                                  	call	OUTCHR
 32596                                  	pop	cx
 32597                                  	retn
 32598                                  
 32599                                  ; =============== S U B	R O U T	I N E =======================================
 32600                                  
 32601                                  PAD:
 32602                                  	or	cx,cx
 32603                                  	jle	short PAD_DONE
 32604                                  	mov	al,[cs:PAD_CHAR]
 32605                                  PAD_LOOP:
 32606                                  	push	cx
 32607                                  	call	OUTCHR
 32608                                  	pop	cx
 32609                                  	loop	PAD_LOOP
 32610                                  PAD_DONE:
 32611                                  	retn
 32612                                  
 32613                                  ; =============== S U B	R O U T	I N E =======================================
 32614                                  
 32615                                  OUTCHR:
 32616                                  	stosb
 32617                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32618                                  	je	short FLUSH
 32619                                  OUTCHR_RETN:
 32620                                  	retn
 32621                                  
 32622                                  ; =============== S U B	R O U T	I N E =======================================
 32623                                  
 32624                                  FLUSH:
 32625                                  	mov	cx,PRINTF_BUF
 32626                                  	xchg	cx,di
 32627                                  	sub	cx,di
 32628                                  	jz	short OUTCHR_RETN
 32629                                  WRITE_CHARS:
 32630                                  	push	bx
 32631                                  	mov	bx,[cs:PRINTF_HANDLE]
 32632                                  	push	ds
 32633                                  	push	cs
 32634                                  	pop	ds
 32635                                  	mov	dx,PRINTF_BUF
 32636                                  	mov	ah,Write ; 40h
 32637                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32638                                  				; BX = file handle, CX = number	of bytes to write,
 32639                                  				; DS:DX -> buffer
 32640                                  	jnb	short FOOB2_1
 32641                                  	call	GET_EXT_ERR_NUMBER
 32642                                  	cmp	ax,6
 32643                                  	jz	short FOOB2_4
 32644                                  	jmp	short FOOB2_2
 32645                                  
 32646                                  FOOB2_1:
 32647                                  	cmp	cx,ax
 32648                                  	jz	short FOOB2_4
 32649                                  FOOB2_2:
 32650                                  	mov	bx,dx
 32651                                  	add	bx,ax
 32652                                  	cmp	byte [bx],1Ah
 32653                                  	jz	short FOOB2_4
 32654                                  	pop	ds
 32655                                  	pop	bx
 32656                                  	mov	es,[cs:RESSEG]
 32657                                  	mov	dx,NOSPACEPTR
 32658                                  	test	byte [es:PIPEFLAG],0FFh
 32659                                  	jz	short PRINT_ERR_EXIT
 32660                                  	call	PIPEOFF
 32661                                  	mov	dx,PIPEEMESPTR
 32662                                  PRINT_ERR_EXIT:	
 32663                                  	jmp	CERROR
 32664                                  
 32665                                  FOOB2_4:
 32666                                  	pop	ds
 32667                                  	pop	bx
 32668                                  	retn
 32669                                  
 32670                                  ; =============== S U B	R O U T	I N E =======================================
 32671                                  
 32672                                  NEXT_CHRS:
 32673                                  	push	si		;Save pointer to control string
 32674                                  	mov	si,bx		;Get index into argument list
 32675                                  	add	bx,2		;Increment the index
 32676                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32677                                  	mov	dx,[si]		; Get (address of the) next argument			
 32678                                  	pop	si
 32679                                  	retn
 32680                                  
 32681                                  ; =============== S U B	R O U T	I N E =======================================
 32682                                  
 32683                                  CLEAR_FLAGS:
 32684                                  	xor	ax,ax
 32685                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32686                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32687                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32688                                  	mov	al,' '			
 32689                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32690                                  	retn
 32691                                  
 32692                                  ; ---------------------------------------------------------------------------
 32693                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32694                                  
 32695                                  	; times 7 db 0
 32696                                  
 32697                                  %endif
 32698                                  
 32699                                  ;============================================================================
 32700                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32701                                  ;============================================================================
 32702                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32703                                  
 32704                                  ; ----------------------------
 32705                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32706                                  ; ----------------------------
 32707                                  
 32708                                  ;; Replacable parameters are described by a sublist structure
 32709                                  
 32710                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32711 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32712 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32713 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32714 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32715 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32716 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32717 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32718 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32719                                  endstruc
 32720                                  
 32721                                  ; ---------------------------------------------------------------------------
 32722                                  ; ---------------------------------------------------------------------------
 32723                                  
 32724                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32725                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32726                                  
 32727                                  Printf_Init:
 32728 00004DBF E80F00                  	call	std_printf
 32729 00004DC2 CB                      	retf
 32730                                  
 32731                                  Printf_Crlf:
 32732 00004DC3 E80B00                  	call	std_printf
 32733                                  	;call	CRLF2
 32734                                  	;retn
 32735                                  	; 07/04/2023
 32736 00004DC6 E906D8                  	jmp	CRLF2
 32737                                  
 32738                                  
 32739                                  ;****************************************************************
 32740                                  ;*
 32741                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32742                                  ;*
 32743                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32744                                  ;*		Set up substitutions if utility message.  Make
 32745                                  ;*		sure any changes to message variables in TDATA
 32746                                  ;*		are reset to avoid reloading the transient.
 32747                                  ;*
 32748                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32749                                  ;*		Msg_Cont_Flag	-  set to control flags
 32750                                  ;*		DS	points to transient segment
 32751                                  ;*
 32752                                  ;*		if utility message:
 32753                                  ;*		DX	points to a block with message number
 32754                                  ;*			(word), number of substitutions (byte),
 32755                                  ;*			followed by substitution list if there
 32756                                  ;*			are substitutions.  If substitutions
 32757                                  ;*			are not in transient segment they must
 32758                                  ;*			be set.
 32759                                  ;*		else
 32760                                  ;*		AX	set to message number
 32761                                  ;*
 32762                                  ;* OUTPUT:	none
 32763                                  ;*
 32764                                  ;****************************************************************
 32765                                  
 32766                                  std_eprintf:
 32767 00004DC9 C706[D187]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32768 00004DCF EB06                    	jmp	short new_printf		;AC000;
 32769                                  
 32770                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32771                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32772                                  	; 15/06/2023
 32773                                  	; 12/08/2024
 32774                                  std_printf:
 32775 00004DD1 C706[D187]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32776                                  
 32777                                  new_printf:
 32778 00004DD7 50                      	push	ax				;AN000;save registers
 32779 00004DD8 53                      	push	bx				;AN000;
 32780 00004DD9 51                      	push	cx				;AN000;
 32781 00004DDA 06                      	push	es				;AN000;get local ES
 32782 00004DDB 1E                      	push	ds				;AN000;
 32783 00004DDC 07                      	pop	es				;AN000;
 32784 00004DDD 57                      	push	di				;AN000;
 32785 00004DDE 56                      	push	si				;AN000;
 32786 00004DDF 52                      	push	dx				;AN000;
 32787                                  
 32788                                  	; 07/04/2023
 32789                                  	;mov	word [print_err_flag],0		;AN000;
 32790 00004DE0 31C9                    	xor	cx,cx
 32791 00004DE2 890E[978D]              	mov	[print_err_flag],cx ; 0
 32792                                  
 32793 00004DE6 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32794 00004DE8 AD                      	lodsw					;AN000;load message number
 32795                                  	; 15/06/2023
 32796                                  	;push	ax				;AN000;save it
 32797                                  	;lodsb					;AN000;get number of substitutions
 32798                                  	;mov	cl,al				;AN000;set up CX as # of subst
 32799                                  	;; 07/04/2023
 32800                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 32801                                  	;pop	ax				;AN000;get message number back
 32802                                  	; 15/06/2023
 32803 00004DE9 8A0C                    	mov	cl,[si]
 32804 00004DEB 46                      	inc	si
 32805                                  	
 32806                                  	;cmp	cx,0				;AN000;Any substitutions?
 32807                                  	; 07/04/2023
 32808                                  	;and	cx,cx
 32809                                  	;jz	short ready_to_print		;AN000;No - continue
 32810                                  	; 12/08/2024
 32811 00004DEC E35C                    	jcxz	ready_to_print
 32812                                  
 32813 00004DEE BF[998D]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32814 00004DF1 57                      	push	di				;AN061; save it
 32815 00004DF2 51                      	push	cx				;AN061; save number of subst
 32816                                  
 32817                                  move_subst:
 32818 00004DF3 51                      	push	cx				;AN061;save number of subst
 32819 00004DF4 89F3                    	mov	bx,si				;AN061;save start of sublist
 32820                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32821                                  	; 07/04/2023
 32822 00004DF6 B10B                    	mov	cl,parm_block_size ; 11
 32823 00004DF8 F3A4                    	rep	movsb				;AN061;move sublist
 32824                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32825 00004DFA F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32826                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32827 00004DFE 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32828                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32829                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32830 00004E00 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32831                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32832                                  	;mov	word [bx+4],0			;AN061;
 32833 00004E03 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32834                                  
 32835                                  move_subst_cont:				;AN061;
 32836 00004E06 59                      	pop	cx				;AN061;get number of subst back
 32837 00004E07 E2EA                    	loop	move_subst			;AN061;move cx sublists
 32838                                  
 32839 00004E09 59                      	pop	cx				;AN061;get number of subst
 32840 00004E0A 50                      	push	ax				;AN061;save message number
 32841 00004E0B 803E[FA7E]FF            	cmp	byte [msg_disp_class],util_msg_class
 32842                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32843 00004E10 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32844                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32845 00004E12 C606[938D]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32846 00004E17 BF[FC7E]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32847 00004E1A 31C0                    	xor	ax,ax				;AN061;clear ax register
 32848 00004E1C AB                      	stosw					;AN061;clear out message number
 32849 00004E1D AA                      	stosb					;AN061;clear out subst count
 32850                                  
 32851                                  check_fix:					;AN061;
 32852 00004E1E 58                      	pop	ax				;AN061;get message number back
 32853 00004E1F 5F                      	pop	di				;AN061;get start of sublists
 32854 00004E20 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32855 00004E22 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32856 00004E24 51                      	push	cx				;AN061;save number of subst
 32857                                  
 32858                                  set_subst:					;AN061;store the segment of the subst
 32859 00004E25 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32860                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32861 00004E29 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32862 00004E2B F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32863                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32864                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32865 00004E2F 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32866 00004E31 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32867                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32868                                  
 32869                                  subst_seg_set:					;AN061;
 32870 00004E34 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32871 00004E37 E2EC                    	loop	set_subst			;AN061;loop CX times
 32872 00004E39 59                      	pop	cx				;AN061;get number of subst back
 32873                                  
 32874 00004E3A 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32875 00004E3C 817F02[118C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32876                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32877 00004E41 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32878                                  	; 01/05/2023
 32879 00004E43 8B16[118C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32880 00004E47 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32881                                  						;AN061;put it into the subst block
 32882                                  	;mov	[bx+2],dx
 32883                                  
 32884                                  ready_to_print:
 32885 00004E4A 8B1E[D187]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32886 00004E4E 8A16[FB7E]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32887 00004E52 8A36[FA7E]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32888 00004E56 C606[FB7E]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32889                                  						;AN061;reset flags to avoid
 32890 00004E5B C606[FA7E]FF            	mov	byte [msg_disp_class],util_msg_class
 32891                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32892                                  
 32893 00004E60 1E                      	push	ds				;AN026;
 32894 00004E61 06                      	push	es				;AN026;
 32895                                  
 32896 00004E62 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32897                                  
 32898 00004E65 07                      	pop	es				;AN026; restore registers
 32899 00004E66 1F                      	pop	ds				;AN026;
 32900                                  
 32901 00004E67 7303                    	jnc	short print_success		;AN000; everything went okay
 32902 00004E69 A3[978D]                	mov	[print_err_flag],ax		;AN000;
 32903                                  
 32904                                  print_success:
 32905 00004E6C 5A                      	pop	dx				;AN061;restore dx
 32906 00004E6D 5E                      	pop	si				;AN000;restore registers
 32907 00004E6E 5F                      	pop	di				;AN000;
 32908 00004E6F 07                      	pop	es				;AN000;restore registers
 32909 00004E70 59                      	pop	cx				;AN000;
 32910 00004E71 5B                      	pop	bx				;AN000;
 32911 00004E72 58                      	pop	ax				;AN000;
 32912 00004E73 833E[978D]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32913 00004E78 7501                    	jnz	short print_err			;AN000;
 32914                                  
 32915 00004E7A C3                      	retn					;AC000;
 32916                                  
 32917                                  print_err:
 32918 00004E7B 0E                      	push	cs
 32919 00004E7C 07                      	pop	es
 32920 00004E7D 833E[D187]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32921 00004E82 7503                    	jne	short not_stderr		;AN026;no - continue
 32922 00004E84 E97DB2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32923                                  
 32924                                  not_stderr:
 32925 00004E87 A1[978D]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32926 00004E8A 8E06[A58A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32927                                  						;  right error msg, and jmp to cerror.
 32928 00004E8E 26F606[0002]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32929 00004E94 7408                    	jz	short _go_to_error
 32930 00004E96 E8CDE0                  	call	PipeOff
 32931 00004E99 BA[5D80]                	mov	dx,PIPEEMES_PTR
 32932 00004E9C EB0B                    	jmp	short print_err_exit		;AC000;
 32933                                  
 32934                                  _go_to_error:
 32935 00004E9E C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 32936                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32937 00004EA3 BA[FC7E]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32938 00004EA6 A3[FC7E]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32939                                  
 32940                                  print_err_exit: 				;AC000;
 32941 00004EA9 0E                      	push	cs
 32942 00004EAA 07                      	pop	es
 32943 00004EAB E9A2DA                  	jmp	cerror
 32944                                  
 32945                                  ;****************************************************************
 32946                                  ;*
 32947                                  ;* ROUTINE:	TSYSLOADMSG
 32948                                  ;*
 32949                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32950                                  ;*		names since these routines are also used in the
 32951                                  ;*		resident.
 32952                                  ;*
 32953                                  ;* INPUT:	Inputs to SYSLOADMSG
 32954                                  ;*
 32955                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32956                                  ;*
 32957                                  ;****************************************************************
 32958                                  
 32959                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32960                                  TSYSLOADMSG:
 32961 00004EAE 53                      	push	bx				;AN000;
 32962 00004EAF E80800                  	call	SYSLOADMSG			;AN000; call routine
 32963 00004EB2 5B                      	pop	bx				;AN000;
 32964 00004EB3 C3                      	retn					;AN000; exit
 32965                                  
 32966                                  ;****************************************************************
 32967                                  ;*
 32968                                  ;* ROUTINE:	TSYSGETMSG
 32969                                  ;*
 32970                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32971                                  ;*		names since these routines are also used in the
 32972                                  ;*		resident.
 32973                                  ;*
 32974                                  ;* INPUT:	Inputs to SYSGETMSG
 32975                                  ;*
 32976                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32977                                  ;*
 32978                                  ;****************************************************************
 32979                                  
 32980                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32981                                  TSYSGETMSG:
 32982 00004EB4 51                      	push	cx				;AN000;
 32983 00004EB5 E8B500                  	call	SYSGETMSG			;AN000; call routine
 32984 00004EB8 59                      	pop	cx				;AN000;
 32985 00004EB9 C3                      	retn					;AN000; exit
 32986                                  
 32987                                  ;============================================================================
 32988                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 32989                                  ;============================================================================
 32990                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32991                                  
 32992                                  ; ---------------------------------------------------------------------------
 32993                                  ; MODULE NAME: MSGSERV.SAL
 32994                                  ;
 32995                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 32996                                  ;
 32997                                  ; FUNCTION: This module incorporates all the messages services and
 32998                                  ;	    is called upon at build time to INCLUDE the code requested
 32999                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 33000                                  ;
 33001                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 33002                                  ;	    requested procedure.
 33003                                  ;
 33004                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 33005                                  ;	    function requested.
 33006                                  ;
 33007                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 33008                                  ;
 33009                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 33010                                  ;
 33011                                  ; INTERNAL REFERENCES: (list of included subroutines)
 33012                                  ;
 33013                                  ;	- SYSLOADMSG
 33014                                  ;	- SYSDISPMSG
 33015                                  ;	- SYSGETMSG
 33016                                  ;
 33017                                  ; EXTERNAL REFERENCES: None
 33018                                  ;
 33019                                  ; NOTES: At build time, some modules must be included. These are only included
 33020                                  ;	 once using assembler switches. Other logic is included at the request
 33021                                  ;	 of the utility.
 33022                                  ;
 33023                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 33024                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 33025                                  ;	 storage and multiple EQUates.
 33026                                  ;
 33027                                  ; REVISION HISTORY: Created MAY 1987
 33028                                  ;
 33029                                  ;     Label: DOS - - Message Retriever
 33030                                  ;	     (c) Copyright 1988 Microsoft
 33031                                  ; ---------------------------------------------------------------------------
 33032                                  
 33033                                  ;	Revision History
 33034                                  ;	================
 33035                                  ;
 33036                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 33037                                  ;				$M_DISPLAY_H_STRING to properly
 33038                                  ;				handle Ctrl-Z being passed
 33039                                  ;
 33040                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 33041                                  ;				these routines are no longer assembled.
 33042                                  ;
 33043                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 33044                                  ;				CR-LF string also gets reinitialized
 33045                                  ;				on every cycle.
 33046                                  ;
 33047                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 33048                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 33049                                  
 33050                                  ; ---------------------------------------------------------------------------
 33051                                  
 33052                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33053                                  
 33054                                  ;;; Replacable parameters are described by a sublist structure
 33055                                  ;
 33056                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 33057                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33058                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33059                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33060                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 33061                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33062                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33063                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33064                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33065                                  ;endstruc
 33066                                  
 33067                                  ;; Each class will be defined by this structure.
 33068                                  
 33069                                  struc $M_CLASS_ID		;;AN000;;
 33070 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 33071 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 33072 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 33073                                   .size:
 33074                                  endstruc
 33075                                  
 33076                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 33077                                  
 33078                                  ;; Each message will be defined by this structure.
 33079                                  
 33080                                  struc $M_ID			;;AN000;;
 33081 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 33082 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 33083                                   .size:	
 33084                                  endstruc
 33085                                  
 33086                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 33087                                  
 33088                                  ; ---------------------------
 33089                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33090                                  ; ---------------------------
 33091                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 33092                                  
 33093                                  ; --------------------------- 
 33094                                  
 33095                                  ; 07/04/2023
 33096                                  $M_NUM_CLS equ 3
 33097                                  
 33098                                  ;; Resident data area definition of variables
 33099                                  
 33100                                  struc $M_RES_ADDRS			;;AN000;;
 33101 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 33102 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 33103 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 33104 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 33105 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 33106 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 33107 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 33108 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 33109 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 33110 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 33111 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33112 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33113 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33114 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33115 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33116 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33117 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33118 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33119 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33120 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33121 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33122 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33123 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33124                                   .size:
 33125                                  endstruc				;;AN000;;
 33126                                  
 33127                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33128                                  
 33129                                  ;; Important fields of the Get Country Information call
 33130                                  
 33131                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33132 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33133                                  					;;AN000;; Go past first part of struc
 33134 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33135 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33136 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33137 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33138 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33139 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33140 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33141 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33142 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33143                                  endstruc				;;AN000;;
 33144                                  
 33145                                  ; ---------------------------------------------------------------------------
 33146                                  
 33147                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33148                                  ;;
 33149                                  ;;	PROC NAME: SYSLOADMSG
 33150                                  ;;
 33151                                  ;;	FUNCTION:
 33152                                  ;;	INPUTS:
 33153                                  ;;
 33154                                  ;;	OUTPUTS:
 33155                                  ;;
 33156                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33157                                  
 33158                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33159                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33160                                  
 33161                                  SYSLOADMSG:
 33162 00004EBA 50                      	push	ax				;;AN000;
 33163 00004EBB 53                      	push	bx				;;AN000;
 33164 00004EBC 52                      	push	dx				;;AN000;
 33165 00004EBD 06                      	push	es				;;AN000;
 33166 00004EBE 57                      	push	di				;;AN000;
 33167 00004EBF 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33168 00004EC1 8EC1                    	mov	es,cx				;;AN000;
 33169 00004EC3 31FF                    	xor	di,di				;;AN000;
 33170 00004EC5 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33171 00004EC8 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33172 00004ECA CD2F                    	int	2Fh				;;AN000;; Private interface
 33173                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33174                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33175                                  		; Return: ES:DI -> error table
 33176                                  	
 33177 00004ECC 8C06[D686]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33178                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33179 00004ED0 893E[D486]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33180                                  	;mov	[$M_RT+8],di			;;AN000;;
 33181                                  
 33182 00004ED4 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33183 00004ED7 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33184 00004ED9 CD2F                    	int	2Fh				;;AN000;; Private interface
 33185                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33186                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33187                                  		; ES:DI -> error table
 33188                                  
 33189 00004EDB 8C06[DE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33190                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33191 00004EDF 893E[DC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33192                                  	;mov	[$M_RT+16],di			;;AN000;;
 33193                                  
 33194 00004EE3 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33195 00004EE6 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33196 00004EE8 CD2F                    	int	2Fh				;;AN000;; Private interface
 33197                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33198                                  		; DL = subfunction - get ??? error table
 33199                                  		; ES:DI -> error table
 33200                                  
 33201 00004EEA 8C06[EE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33202                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33203 00004EEE 893E[EC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33204                                  	;mov	[$M_RT+32],di			;;AN000;;
 33205                                  
 33206 00004EF2 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33207 00004EF5 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33208 00004EF7 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33209                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33210                                  		; DL = subfunction - get ??? error table
 33211                                  		; ES:DI -> error table
 33212                                  
 33213 00004EF9 8C06[D286]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33214                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33215 00004EFD 893E[D086]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33216                                  	;mov	[$M_RT+4],di			;;AN001;;
 33217                                  
 33218 00004F01 E8D12F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33219                                  						;;AN000;;
 33220 00004F04 8C06[CE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33221                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33222 00004F08 893E[CC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33223                                  	;mov	[$M_RT+0],di			;;AN000;;
 33224 00004F0C 8C06[EA86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33225                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33226 00004F10 893E[E886]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33227                                  	;mov	[$M_RT+28],di			;;AN000;;
 33228                                  
 33229 00004F14 E8DC2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33230                                  
 33231 00004F17 8C06[E286]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33232                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33233 00004F1B 893E[E086]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33234                                  	;mov	[$M_RT+20],di			;;AN000;;
 33235                                  
 33236 00004F1F B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33237 00004F22 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33238 00004F24 CD2F                    	int	2Fh				;;AN001;; Private interface
 33239                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33240                                  		; DL = subfunction - get ??? error table
 33241                                  		; ES:DI -> error table
 33242                                  
 33243 00004F26 8C06[F686]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33244                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33245 00004F2A 893E[F486]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33246                                  	;mov	[$M_RT+40],di			;;AN001;;
 33247                                  
 33248                                  ;M016; M020
 33249                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33250                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33251                                  
 33252 00004F2E C706[0F87]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33253                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33254 00004F34 C606[5887]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33255                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33256 00004F39 C706[1487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33257                                  	;mov	word [$M_RT+72],0		; M020
 33258 00004F3F C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33259                                  	;mov	word [$M_RT+74],10		; M020
 33260                                  
 33261                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33262                                  	; --------------------------
 33263                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33264                                  	; --------------------------
 33265                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33266                                  
 33267                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33268 00004F45 E82A2F                  	call    $M_CLS_3			; Get addressibility to class F
 33269 00004F48 893E[F886]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33270                                  	;mov	[$M_RT+44],di
 33271                                  	
 33272 00004F4C E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33273                                  
 33274                                  	; 15/04/2023
 33275                                  	;clc					;;AN000;; Make sure carry is clear
 33276                                  	;jc	short $MIF20
 33277                                  	
 33278 00004F4F 5F                      	pop	di				;;AN000;; Restore REGS
 33279 00004F50 07                      	pop	es				;;AN000;;
 33280 00004F51 5A                      	pop	dx				;;AN000;;
 33281 00004F52 5B                      	pop	bx				;;AN000;;
 33282 00004F53 58                      	pop	ax				;;AN000;;
 33283                                  	;jmp	short $MEN20
 33284                                  	; 15/04/2023
 33285 00004F54 C3                      	retn
 33286                                  
 33287                                  	; 15/04/2023
 33288                                  ;$MIF20:
 33289                                  	;add	sp,10				;;AN000;;
 33290                                  	;stc					;;AN000;; Reset carry flag
 33291                                  ;$MEN20:
 33292                                  	;retn					;;AN000;;
 33293                                  
 33294                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33295                                  ;;
 33296                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33297                                  ;;
 33298                                  ;;  Function:	Get the DBCS vector and save it for later use
 33299                                  ;;
 33300                                  ;;  Inputs:	None
 33301                                  ;;
 33302                                  ;;  Outputs:	None
 33303                                  ;;
 33304                                  ;;  Regs Changed:
 33305                                  ;;
 33306                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33307                                  
 33308                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33309                                  
 33310                                  $M_GET_DBCS_VEC:
 33311 00004F55 50                      	push	ax				;;AN000;; Save character to check
 33312 00004F56 56                      	push	si				;;AN000;;
 33313 00004F57 1E                      	push	ds				;;AN000;;
 33314 00004F58 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33315 00004F5B CD21                    	int	21h				;;AN000;; Get environment pointer
 33316 00004F5D 1E                      	push	ds				;;AN000;; Get environment pointer
 33317 00004F5E 07                      	pop	es				;;AN000;; Get environment pointer
 33318 00004F5F 1F                      	pop	ds				;;AN000;; Get environment pointer
 33319 00004F60 7208                    	jc	short $MIF23
 33320                                  	
 33321 00004F62 8936[0887]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33322                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33323 00004F66 8C06[0A87]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33324                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33325                                  $MIF23:
 33326 00004F6A 5E                      	pop	si				;;AN000;;
 33327 00004F6B 58                      	pop	ax				;;AN000;; Retrieve character to check
 33328 00004F6C C3                      	retn					;;AN000;; Return
 33329                                  
 33330                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33331                                  ;;
 33332                                  ;;  Proc Name:	SYSGETMSG
 33333                                  ;;
 33334                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33335                                  ;;		message text to the caller based on a message number.
 33336                                  ;;		The GET function will not display the message thus assumes
 33337                                  ;;		caller will handle replaceable parameters.
 33338                                  ;;
 33339                                  ;;  Inputs:
 33340                                  ;;
 33341                                  ;;  Outputs:
 33342                                  ;;
 33343                                  ;;  Psuedocode:
 33344                                  ;;		Call $M_GET_MSG_ADDRESS
 33345                                  ;;		IF MSG_NUM exists THEN
 33346                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33347                                  ;;		   CARRY_FLAG = 0
 33348                                  ;;		ELSE
 33349                                  ;;		   CARRY_FLAG = 1
 33350                                  ;;		ENDIF
 33351                                  ;;
 33352                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33353                                  
 33354                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33355                                  	; 15/06/2023
 33356                                  
 33357                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33358                                  
 33359                                  SYSGETMSG:
 33360                                  	;; Save registers needed later
 33361 00004F6D 50                      	push	ax				;;AN000;; Save changed regs
 33362 00004F6E 06                      	push	es				;;AN000;;
 33363 00004F6F 57                      	push	di				;;AN000;;
 33364 00004F70 55                      	push	bp				;;AN000;;
 33365                                  
 33366 00004F71 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33367 00004F74 720D                    	jc	short $MIF31
 33368                                  	
 33369 00004F76 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33370                                  	;clc					;;AN000;;
 33371 00004F79 7404                    	je	short $MIF32			;;AN000;;
 33372                                  	; 15/06/2023
 33373 00004F7B F8                      	clc	
 33374                                  
 33375 00004F7C 06                      	push	es				;;AN000;;
 33376                                  	;pop	ds				;;AN000;;
 33377 00004F7D EB01                    	jmp	short $MEN32
 33378                                  $MIF32:
 33379 00004F7F 0E                      	push	cs				;;AN000;;			
 33380                                  	;pop	ds				;;AN000;;
 33381                                  $MEN32:
 33382                                  	; 07/04/2023
 33383 00004F80 1F                      	pop	ds
 33384 00004F81 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33385                                  $MIF31:
 33386 00004F83 5D                      	pop	bp				;;AN000;; Restore changed regs
 33387 00004F84 5F                      	pop	di				;;AN000;;
 33388 00004F85 07                      	pop	es				;;AN000;;
 33389 00004F86 58                      	pop	ax				;;AN000;;
 33390 00004F87 C3                      	retn					;;AN000;; Return
 33391                                  
 33392                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33393                                  ;;
 33394                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33395                                  ;;
 33396                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33397                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33398                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33399                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33400                                  ;;	REGS CHANGED: ES,DI,CX
 33401                                  ;;
 33402                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33403                                  
 33404                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33405                                  
 33406                                  $M_GET_MSG_ADDRESS:
 33407 00004F88 56                      	push	si				;;AN000;;
 33408 00004F89 53                      	push	bx				;;AN000;;
 33409 00004F8A 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33410 00004F8C 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33411                                  $MDO36:
 33412 00004F8E 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33413 00004F91 7508                    	jne	short $MIF37			;;AN000;; No			
 33414                                  	
 33415                                  	; 07/04/2023
 33416                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33417 00004F93 8BBC[F886]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33418                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33419 00004F97 89FB                    	mov	bx,di				;;AN000;;
 33420 00004F99 EB21                    	jmp	short $MEN37
 33421                                  $MIF37:
 33422 00004F9B F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33423 00004F9E 7406                    	jz	short $MIF39
 33424                                  	
 33425                                  	; 07/04/2023
 33426                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33427 00004FA0 C4BC[DC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33428                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33429                                  	
 33430                                  	; 07/04/2023
 33431                                  	;mov	bx,es ; *			;;AN000;;
 33432 00004FA4 EB14                    	jmp	short $MEN39
 33433                                  $MIF39:
 33434 00004FA6 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33435 00004FA9 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33436                                  
 33437 00004FAB 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33438 00004FAE 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33439                                  
 33440                                  	; 07/04/2023
 33441                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33442 00004FB0 C4BC[E886]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33443                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33444                                  	
 33445                                  	; 07/04/2023
 33446                                  	;mov	bx,es ; *			;;AN000;;
 33447 00004FB4 EB04                    	jmp	short $MEN41
 33448                                  $MIF41:
 33449                                  	; 07/04/2023
 33450                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33451 00004FB6 C4BC[CC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33452                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33453                                  	
 33454                                  	; 07/04/2023
 33455                                  	;mov	bx,es ; *			;;AN000;;
 33456                                  $MEN41:
 33457                                  $MEN39:
 33458                                  	; 07/04/2023
 33459 00004FBA 8CC3                    	mov	bx,es ; *
 33460                                  $MEN37:						;;AN000;;
 33461 00004FBC 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33462 00004FBF 7515                    	jne	short $MIF46			;;AN000;; No
 33463                                  
 33464 00004FC1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33465 00004FC4 7503                    	jne	short $MIF47			;;AN000;; No
 33466 00004FC6 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33467                                  	; 07/04/2023
 33468                                  	;jmp	short $MEN47 ; **-
 33469 00004FC7 EB1B                    	jmp	short $MEN36 ; **-
 33470                                  $MIF47:
 33471 00004FC9 A3[1487]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 33472                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33473 00004FCC B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33474 00004FCF BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33475 00004FD2 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33476                                  	; 28/04/2023
 33477                                  	; 07/04/2023
 33478                                  	;clc	; **+				;;AN000;;
 33479                                  ;$MEN47:
 33480                                  	;jmp	short $MEN46 ; ***
 33481 00004FD4 EB0A                    	jmp	short $MEN47 ; ***
 33482                                  $MIF46:
 33483                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33484 00004FD6 21DB                    	and	bx,bx ; 0 ?
 33485 00004FD8 7403                    	jz	short $MIF51			;;AN000;; No
 33486                                  	
 33487 00004FDA E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33488                                  $MIF51:
 33489 00004FDD 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33490                                  	; 07/04/2023
 33491                                  	;clc					;;AN000;;
 33492                                  ;$MEN46:
 33493                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33494                                  $MEN47:	; 07/04/2023	; **+
 33495 00004FE0 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33496                                  	;jnz	short $MXL2			;;AN000;; Yes
 33497                                  	;jmp	short $MDO36
 33498                                  	; 07/04/2023
 33499 00004FE2 74AA                    	jz	short $MDO36	
 33500                                  $MXL2:
 33501                                  $MEN36:
 33502 00004FE4 9C                      	pushf 					;;AN006;; Save the flag state
 33503                                  	
 33504 00004FE5 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33505                                  	;jne	short $MIF56			;;AN006;; No
 33506                                  	; 28/04/2023
 33507 00004FE8 752A                    	jne	short $M_MYRET	
 33508                                  
 33509 00004FEA 52                      	push	dx				;;AN006;; Save all needed registers
 33510 00004FEB 55                      	push	bp				;;AN006;;
 33511 00004FEC 51                      	push	cx				;;AN006;;
 33512 00004FED 06                      	push	es				;;AN006;;
 33513 00004FEE 57                      	push	di				;;AN006;;
 33514 00004FEF 50                      	push	ax				;;AN006;;
 33515                                  
 33516 00004FF0 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33517 00004FF3 CD2F                    	int	2Fh				;;AN006;;
 33518                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33519                                  		; Return: AL = 00h not installed, OK to install
 33520                                  		; 01h not installed, can't install
 33521                                  		; FFh installed
 33522                                  
 33523 00004FF5 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33524 00004FF7 58                      	pop	ax				;;AN006;; Restore msg number
 33525 00004FF8 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33526                                  
 33527 00004FFA 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33528 00004FFC B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33529 00004FFF CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33530                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33531                                  
 33532                                  	;jmp	short $MEN57			;;AN006;;
 33533                                  	; 28/04/2023
 33534 00005001 720B                    	jc	short $MEN57
 33535                                  $MIF60:
 33536 00005003 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33537 00005006 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33538                                  $MEN60:
 33539 00005009 5D                      	pop	bp				;;AN006;; Restore other Regs
 33540 0000500A 5A                      	pop	dx				;;AN006;;
 33541                                  $MIF56:
 33542                                  	; 07/04/2023
 33543                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33544 0000500B EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33545                                  
 33546                                  $MIF57:
 33547 0000500D F9                      	stc					;;AN006;; Carry conditon
 33548                                  $MEN57:
 33549                                  	; 28/04/2023
 33550                                  	;jnc	short $MIF60			;;AN006;;
 33551                                  
 33552 0000500E 5F                      	pop	di				;;AN006;;
 33553 0000500F 07                      	pop	es				;;AN006;; Restore old pointer
 33554 00005010 59                      	pop	cx				;;AN006;;
 33555 00005011 EBF6                    	jmp	short $MEN60
 33556                                  
 33557                                  ;$MIF60:
 33558                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33559                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33560                                  ;$MEN60:
 33561                                  ;	pop	bp				;;AN006;; Restore other Regs
 33562                                  ;	pop	dx				;;AN006;;
 33563                                  ;$MIF56:
 33564                                  ;	; 07/04/2023
 33565                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33566                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33567                                  
 33568                                  ; 07/04/2023
 33569                                  ; ---------------------------
 33570                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33571                                  ; ---------------------------
 33572                                  	; $M_POPF macro
 33573                                  	;jmp	short $+3
 33574                                  m_popf_iret:
 33575 00005013 CF                      	iret
 33576                                  $M_MYRET:
 33577 00005014 0E                      	push	cs
 33578 00005015 E8FBFF                  	call	m_popf_iret
 33579                                  	;;; end macro	
 33580                                  ; ---------------------------
 33581                                  
 33582 00005018 5B                      	pop	bx				;;AN000;;
 33583 00005019 5E                      	pop	si				;;AN000;;
 33584 0000501A C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33585                                  
 33586                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33587                                  
 33588                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33589                                  $M_SET_LEN_IN_CX:			
 33590 0000501B 57                      	push	di				;;AN006;; Save position
 33591 0000501C 50                      	push	ax				;;AN006;;
 33592 0000501D B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33593 00005020 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33594 00005022 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33595 00005024 F7D1                    	not	cx				;;AN006;; Change decrement into number
 33596 00005026 49                      	dec	cx				;;AN006;; Don't include the zero
 33597 00005027 58                      	pop	ax				;;AN006;;
 33598 00005028 5F                      	pop	di				;;AN006;; Restore position
 33599 00005029 C3                      	retn					;;AN006;;
 33600                                  
 33601                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33602                                  ;;
 33603                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33604                                  ;;
 33605                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33606                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33607                                  ;;		   CX contains the number of messages in class
 33608                                  ;;		   DH contains the message class
 33609                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33610                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33611                                  ;;
 33612                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33613                                  
 33614                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33615                                  	; 15/06/2023
 33616                                  $M_FIND_SPECIFIED_MSG:
 33617 0000502A 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33618 0000502D 751F                    	jne	short $MIF64
 33619 0000502F 833E[F486]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33620                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33621                                  	; 15/06/2023 (BugFix)
 33622 00005034 7418                    	je	short $MIF64
 33623                                  
 33624 00005036 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33625 00005039 750B                    	jne	short $MIF65
 33626                                  	
 33627 0000503B 50                      	push	ax				;;AN004;; Reset the special message number
 33628 0000503C A1[1487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33629                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33630 0000503F FF1E[F486]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33631                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33632 00005043 58                      	pop	ax				;;AN004;; Reset the special message number
 33633                                  	; 28/04/2023
 33634 00005044 EB04                    	jmp	short $MEN65
 33635                                  	; 18/04/2023
 33636                                  	;jmp	short $MEN64
 33637                                  $MIF65:
 33638 00005046 FF1E[F486]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33639                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33640                                  $MEN65:
 33641                                  	; 28/04/2023
 33642 0000504A 7344                    	jnc	short $MIF75
 33643                                  	;
 33644 0000504C EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33645                                  $MIF64:
 33646 0000504E 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33647 00005050 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33648 00005053 7406                    	je	short $MIF69
 33649                                  	
 33650 00005055 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33651                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33652 00005059 EB09                    	jmp	short $MEN69
 33653                                  $MIF69:
 33654                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33655                                  	;cmp	[cs:di+0],dh
 33656 0000505B 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33657 0000505E 7504                    	jne	short $MIF71
 33658                                  
 33659 00005060 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33660                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33661                                  $MIF71:						;;AN001;;
 33662                                  $MEN69:
 33663 00005064 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33664                                  	; 02/05/2023
 33665                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33666                                  $MEN64:
 33667                                  	;jnc	short $MIF75
 33668                                  	; 28/04/2023
 33669                                  	; (or instruction clears carry flag)
 33670                                  	;clc					;;AN004;; No, reset carry
 33671                                  $MDO76:
 33672 00005067 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33673 00005069 7417                    	jz	short $MEN76
 33674                                  
 33675 0000506B 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33676 0000506E 7405                    	je	short $MIF78
 33677                                  
 33678                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33679 00005070 263B05                  	cmp	ax,[es:di]
 33680 00005073 EB03                    	jmp	short $MEN78
 33681                                  $MIF78:
 33682                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33683 00005075 2E3B05                  	cmp	ax,[cs:di]
 33684                                  $MEN78:
 33685                                  	;jne	short $MIF76
 33686                                  	;jmp	short $MSR76
 33687                                  	; 07/04/2023
 33688 00005078 740B                    	je	short $MSR76 ; *
 33689                                  $MIF76:
 33690 0000507A 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33691 0000507B 7405                    	jz	short $MEN76
 33692                                  
 33693 0000507D 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33694 00005080 EBE5                    	jmp	short $MDO76			;;AN000;;
 33695                                  $MEN76:
 33696 00005082 F9                      	stc					;;AN000;;
 33697                                  ;$MSR76:	; 07/04/2023
 33698                                  	;jc	short $MIF86			;;AN000;;
 33699                                  	; 07/04/2023
 33700                                  	;jc	short $MIF91
 33701 00005083 EB11                    	jmp	short $MIF91 ;*
 33702                                  $MSR76:	; 07/04/2023 ; *	
 33703 00005085 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33704                                  	; 07/04/2023
 33705                                  	;clc					;;AN001;;
 33706 00005088 7502                    	jne	short $MIF87
 33707                                  
 33708 0000508A 0E                      	push	cs				;;AN000;;
 33709 0000508B 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33710                                  $MIF87:
 33711                                  	;add	di,[es:di+2]
 33712 0000508C 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33713                                  $MIF86:
 33714                                  ;$MIF75:
 33715                                  	; 02/05/2023
 33716                                  	;jc	short $MIF91
 33717                                  $MIF75:	; 28/04/2023
 33718 00005090 30ED                    	xor	ch,ch				;;AN000;;
 33719 00005092 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33720 00005095 47                      	inc	di				;;AN000;; Increment past length
 33721                                  $MIF91:
 33722 00005096 C606[0E87]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33723                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33724 0000509B C3                      	retn					;;AN000;; Return
 33725                                  
 33726                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33727                                  ;;
 33728                                  ;;  Proc Name:	SYSDISPMSG
 33729                                  ;;
 33730                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33731                                  ;;		requested by the caller. It also provides function to display
 33732                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33733                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33734                                  ;;		defined previous to entry.
 33735                                  ;;
 33736                                  ;;		It is assumes that a PRELOAD function has already determined
 33737                                  ;;		the addressibilty internally to the message retriever services.
 33738                                  ;;  Inputs:
 33739                                  ;;
 33740                                  ;;  Outputs:
 33741                                  ;;
 33742                                  ;;  Psuedocode:
 33743                                  ;;		Save registers needed later
 33744                                  ;;		Get address of the message requested
 33745                                  ;;		IF Message number exists THEN
 33746                                  ;;		  IF replacable parameters were specified THEN
 33747                                  ;;		     Display message with replacable parms
 33748                                  ;;		  ELSE
 33749                                  ;;		     Display string without replacable parms
 33750                                  ;;		  ENDIF
 33751                                  ;;		  IF character input was requested THEN
 33752                                  ;;		     Wait for character input
 33753                                  ;;		  ENDIF
 33754                                  ;;		  Clear CARRY FLAG
 33755                                  ;;		ELSE
 33756                                  ;;		   Set CARRY FLAG
 33757                                  ;;		ENDIF
 33758                                  ;;		Return
 33759                                  ;;
 33760                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33761                                  
 33762                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33763                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33764                                  
 33765                                  SYSDISPMSG:
 33766                                  	;; Save registers and values needed later
 33767 0000509C 50                      	push	ax				;;AN000;; Save changed REGs
 33768 0000509D 53                      	push	bx				;;AN000;;
 33769 0000509E 51                      	push	cx				;;AN000;;
 33770 0000509F 55                      	push	bp				;;AN000;;
 33771 000050A0 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33772 000050A1 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33773 000050A2 52                      	push	dx				;;AN000;; Save Input/Class request
 33774                                  
 33775 000050A3 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33776 000050A5 891E[0C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33777                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33778 000050A9 8836[1187]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33779                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33780                                  
 33781                                  	;; Get address of the message requested
 33782 000050AD E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33783 000050B0 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33784 000050B2 7420                    	jz	short $MIF93
 33785                                  						;;AN000;; Yes, Message address in ES:DI
 33786                                  	
 33787                                  	;; Test if replacable parameters were specified
 33788 000050B4 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33789 000050B6 7505                    	jnz	short $MIF94
 33790                                  
 33791                                  	;; Display string without replacable parms
 33792 000050B8 E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33793 000050BB EB03                    	jmp	short $MEN94
 33794                                  $MIF94:
 33795                                  	;; Display message with replacable parms
 33796 000050BD E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33797                                  $MEN94:
 33798 000050C0 720D                    	jc	short $MIF97
 33799 000050C2 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33800 000050C3 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33801 000050C6 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33802 000050C7 5F                      	pop	di				;;AN000;;
 33803                                  	;jmp	short $MEN97 ; ***
 33804                                  	; 08/04/2023
 33805                                  	;jmp	short $MEN93 ; **
 33806                                  
 33807                                  	; 08/04/2023
 33808                                  ;$MEN93:
 33809 000050C8 720D                    	jc	short $MIF104
 33810                                  ;$MEN97:
 33811 000050CA 5D                      	pop	bp				;;AN000;;
 33812 000050CB 59                      	pop	cx				;;AN000;;
 33813 000050CC 5B                      	pop	bx				;;AN000;;
 33814 000050CD 58                      	pop	ax				;;AN000;;
 33815 000050CE C3                      	retn
 33816                                   
 33817                                  $MIF97:
 33818                                  	; 08/04/2023
 33819                                  	;add	sp,6				;;AN000;;
 33820                                  	;stc					;;AN000;; Reset carry flag
 33821                                  ;$MEN97: ; ***
 33822                                  	;jmp	short $MEN93
 33823                                  	; 08/04/2023
 33824                                  	;jmp	short $MIF104
 33825                                  	; 08/04/2023
 33826 000050CF 83C40E                  	add	sp,14 ; 6+8
 33827 000050D2 F9                      	stc
 33828 000050D3 C3                      	retn
 33829                                  $MIF93:
 33830                                  	; 08/04/2023
 33831                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33832                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33833 000050D4 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33834 000050D5 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33835 000050D6 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33836                                  	;stc	; * 				;;AN000;; Set carry flag
 33837                                  	; 08/04/2023
 33838                                  	;jmp short $MIF104 ; *
 33839                                  
 33840                                  ;$MEN93: ; **
 33841                                  ;	jc	short $MIF104
 33842                                  ;$MEN97: ; 08/04/2023
 33843                                  ;	pop	bp				;;AN000;;
 33844                                  ;	pop	cx				;;AN000;;
 33845                                  ;	pop	bx				;;AN000;;
 33846                                  ;	pop	ax				;;AN000;;
 33847                                  ;	;jmp	short $MEN104
 33848                                  ;	; 08/04/2023
 33849                                  ;	retn
 33850                                  
 33851                                  $MIF104: ; *
 33852 000050D7 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33853 000050DA F9                      	stc					;;AN000;;
 33854                                  $MEN104:
 33855 000050DB C3                      	retn					;;AN000;; Return
 33856                                  
 33857                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33858                                  ;;
 33859                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33860                                  ;;
 33861                                  ;;	FUNCTION:  Will display or write string
 33862                                  ;;	INPUTS:    ES:DI points to beginning of message
 33863                                  ;;		   CX contains the length of string to write (if applicable)
 33864                                  ;;	OUTPUTS:   None
 33865                                  ;;	REGS Revised: None
 33866                                  ;;
 33867                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33868                                  
 33869                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33870                                  
 33871                                  $M_DISPLAY_STRING:
 33872 000050DC 50                      	push	ax				;;AN000;;
 33873 000050DD 53                      	push	bx				;;AN000;;
 33874 000050DE 52                      	push	dx				;;AN000;;
 33875 000050DF 8B1E[0C87]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33876                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33877                                  	
 33878 000050E3 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33879 000050E6 7505                    	jne	short $MIF107
 33880                                  
 33881 000050E8 E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33882 000050EB EB03                    	jmp	short $MEN107
 33883                                  $MIF107:
 33884 000050ED E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33885                                  $MEN107:
 33886 000050F0 730D                    	jnc	short $MIF110
 33887                                  	
 33888 000050F2 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33889                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33890                                  	; 08/04/2023
 33891 000050F4 31DB                    	xor	bx,bx
 33892 000050F6 CD21                    	int	21h				;;AN000;;
 33893                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33894                                  		; BX = version code (0000h for DOS 3.x)
 33895 000050F8 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33896                                  $MEN110: ; 08/04/2023 ; ***
 33897 000050FA 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33898 000050FD F9                      	stc					;;AN000;; Flag that there was an error
 33899                                  	;jmp	short $MEN110 ; ****
 33900                                  	; 08/04/2023
 33901 000050FE C3                      	retn
 33902                                  $MIF110:
 33903                                  	;cmp	bx,$M_NO_HANDLE
 33904 000050FF 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33905 00005102 7409                    	je	short $MIF112 ; *  ; cf = 0
 33906 00005104 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33907 00005106 7405                    	je	short $MIF113 ; ** ; cf = 0
 33908 00005108 E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33909                                  	;add	sp,6				;;AN001;; Clean up stack
 33910                                  	;stc					;;AN001;; Flag that there was an error
 33911                                  	; 08/04/2023
 33912 0000510B EBED                    	jmp	short $MEN110 ; ***
 33913                                  	; 08/04/2023
 33914                                  ;$MIF112:
 33915                                  ;$MEN110: ; ****
 33916                                  	;jc	short $MIF117
 33917                                  $MIF112: ; 08/04/2023	; *
 33918                                  $MIF113:	; **
 33919 0000510D 5A                      	pop	dx				;;AN000;; Restore regs
 33920 0000510E 5B                      	pop	bx				;;AN000;;
 33921 0000510F 58                      	pop	ax				;;AN000;;
 33922                                  $MIF117:
 33923 00005110 C3                      	retn
 33924                                  
 33925                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33926                                  ;;
 33927                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33928                                  ;;
 33929                                  ;;	FUNCTION:  Will display a $ terminated string
 33930                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33931                                  ;;	OUTPUTS:   None
 33932                                  ;;	REGS USED: AX,DX
 33933                                  ;;
 33934                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33935                                  
 33936                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33937                                  
 33938                                  $M_DISPLAY_$_STRING:
 33939 00005111 1E                      	push	ds				;;AN000;;
 33940 00005112 06                      	push	es				;;AN000;;
 33941 00005113 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33942                                  
 33943                                  	; 08/04/2023
 33944 00005114 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33945                                  
 33946                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33947 00005116 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33948 00005119 7518                    	jne	short $MIF119			;;AN000;; No
 33949                                  	
 33950                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33951 0000511B 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33952 0000511E CD21                    	int	21h				;;AN000;; Write character
 33953                                  		; DOS - DISPLAY OUTPUT
 33954                                  		; DL = character to send to standard output
 33955 00005120 1F                      	pop	ds				;;AN000;;
 33956 00005121 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33957 00005123 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33958 00005126 1E                      	push	ds				;;AN000;;
 33959 00005127 06                      	push	es				;;AN000;;
 33960 00005128 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33961 00005129 7316                    	jnc	short $MIF120 ; *
 33962                                  
 33963 0000512B 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33964 0000512F CD21                    	int	21h				;;AN000;; Write character
 33965                                  		; DOS - DISPLAY OUTPUT
 33966                                  		; DL = character to send to standard output
 33967                                  	; 08/04/2023
 33968                                  	;clc					;;AN000;; Clear the DBCS indicator
 33969                                  ;$MIF120:
 33970 00005131 EB0D                    	jmp	short $MEN119
 33971                                  $MIF119:
 33972                                  	; 08/04/2023
 33973                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33974                                  ;$MDO123:
 33975 00005133 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33976                                  	;jz	short $MEN123
 33977                                  	; 18/04/2023
 33978 00005135 740A                    	jz	short $MIF120 ; cf = 0
 33979                                  $MDO123: ; 08/04/2023
 33980 00005137 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 33981 0000513A CD21                    	int	21h				;;AN002;; Display the character
 33982                                  		; DOS - DISPLAY OUTPUT
 33983                                  		; DL = character to send to standard output
 33984 0000513C 47                      	inc	di				;;AN002;; Set pointer to next character
 33985 0000513D 49                      	dec	cx				;;AN002;; Count this character
 33986 0000513E 75F7                    	jnz	short $MDO123
 33987                                  ;$MEN123:
 33988                                  $MEN119:
 33989 00005140 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 33990                                  $MIF120: ; 08/04/2023 ; *
 33991 00005141 1F                      	pop	ds				;;AN000;;
 33992 00005142 C3                      	retn
 33993                                  
 33994                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33995                                  ;;
 33996                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 33997                                  ;; truncates it at the Ctrl-Z if any present.
 33998                                  ;;
 33999                                  ;;	ENTRY:	ds:dx = String to be displayed
 34000                                  ;;		cx = number of chars to be displayed
 34001                                  ;;
 34002                                  ;;	EXIT:	cx = number of chars to be displayed
 34003                                  ;;
 34004                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34005                                  
 34006                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34007                                  scan_ctrlz:
 34008 00005143 57                      	push	di
 34009 00005144 50                      	push	ax
 34010 00005145 06                      	push	es
 34011 00005146 53                      	push	bx
 34012                                  
 34013 00005147 89D7                    	mov	di,dx
 34014 00005149 1E                      	push	ds
 34015 0000514A 07                      	pop	es   			;es:di points at string
 34016                                  
 34017 0000514B 89CB                    	mov	bx,cx			;save current count
 34018                                  
 34019 0000514D B01A                    	mov	al,1Ah	; Ctrl-Z
 34020 0000514F FC                      	cld
 34021 00005150 F2AE                    	repne	scasb			;find first Ctrl-Z
 34022 00005152 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 34023                                  
 34024 00005154 29CB                    	sub	bx,cx
 34025 00005156 4B                      	dec	bx			;bx = new count to display
 34026                                  noCtrlZ:
 34027 00005157 89D9                    	mov	cx,bx			;cx = actual display count
 34028                                  
 34029 00005159 5B                      	pop	bx
 34030 0000515A 07                      	pop	es
 34031 0000515B 58                      	pop	ax
 34032 0000515C 5F                      	pop	di
 34033                                  $MIF127:	; 08/04/2023
 34034 0000515D C3                      	retn
 34035                                  
 34036                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34037                                  ;;
 34038                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 34039                                  ;;
 34040                                  ;;	FUNCTION:  Will display a string to a specified handle
 34041                                  ;;	INPUTS:    ES:DI points to beginning of message
 34042                                  ;;		   CX contains the number of bytes to write
 34043                                  ;;		   BX contains the handle to write to
 34044                                  ;;	OUPUTS:    None
 34045                                  ;;	REGS USED: AX,DX
 34046                                  ;;
 34047                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34048                                  
 34049                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34050                                  
 34051                                  $M_DISPLAY_H_STRING:
 34052 0000515E 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 34053 00005160 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 34054 00005162 74F9                    	jz	short $MIF127
 34055                                  	
 34056 00005164 1E                      	push	ds			;;AN000;;
 34057 00005165 06                      	push	es			;;AN000;;
 34058 00005166 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34059                                  	
 34060 00005167 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34061 00005169 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 34062                                  
 34063 0000516B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 34064 0000516E 7528                    	jne	short $MIF128		;;AN000;; No
 34065                                  
 34066 00005170 CD21                    	int	21h			;;AN000;; Write character
 34067                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34068                                  		; BX = file handle, CX = number of bytes to writ
 34069                                  
 34070 00005172 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34071 00005173 50                      	push	ax			;;AN000;;
 34072 00005174 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 34073 00005177 E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 34074 0000517A 58                      	pop	ax			;;AN000;;
 34075 0000517B 1E                      	push	ds			;;AN000;;
 34076 0000517C 06                      	push	es			;;AN000;;
 34077 0000517D 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34078 0000517E 7306                    	jnc	short $MIF129
 34079                                  	
 34080 00005180 F8                      	clc				;;AN000;; Clear the DBCS indicator
 34081 00005181 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34082 00005183 42                      	inc	dx			;;AN000;; Point to next character
 34083 00005184 CD21                    	int	21h			;;AN000;; Write character
 34084                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34085                                  		; BX = file handle, CX = number of bytes to write, 
 34086                                  $MIF129:
 34087                                  ;SR;
 34088                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 34089                                  ;0 chars written making the caller think there was an error writing. To 
 34090                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 34091                                  ;the char was written, thus fooling the caller.
 34092                                  
 34093 00005186 9C                      	pushf				;save flags
 34094 00005187 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 34095 0000518B 7502                    	jne	short m_popf_j		;no, continue
 34096                                  
 34097 0000518D 89C8                    	mov	ax,cx			;yes, fake as if it was written
 34098                                  m_popf_j:
 34099                                  	; 08/04/2023
 34100                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34101 0000518F EB01                    	jmp	short m_popf		;restore flags
 34102                                  
 34103                                  ; 07/04/2023
 34104                                  ; ---------------------------
 34105                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34106                                  ; ---------------------------
 34107                                  	; $M_POPF macro
 34108                                  	;jmp	short $+3
 34109                                  intret:
 34110 00005191 CF                      	iret
 34111                                  m_popf:
 34112 00005192 0E                      	push	cs
 34113 00005193 E8FBFF                  	call	intret
 34114                                  	;;; end macro	
 34115                                  ; ---------------------------
 34116                                  
 34117 00005196 EB18                    	jmp	short $MEN128
 34118                                  
 34119                                  $MIF128:
 34120                                  ;SR;
 34121                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34122                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34123                                  
 34124 00005198 55                      	push	bp			; M007
 34125 00005199 51                      	push	cx
 34126 0000519A E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34127 0000519D 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34128 0000519F 59                      	pop	cx			;get old count back ;M007
 34129                                  	
 34130 000051A0 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34131                                  	;jnc	short chk_count		;no error, adjust return count
 34132                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34133                                  	; 08/04/2023
 34134 000051A2 720B                    	jc	short m_cnt_ok
 34135                                  ;M007
 34136                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34137                                  ;return count will be much less and if this returns to the caller we can get
 34138                                  ;spurious error messages. We check here if the count returned is same as
 34139                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34140                                  ;case, we fake it as if all bytes have been written. If the return count
 34141                                  ;does not match either count, then we had some other disk error (such as
 34142                                  ;insufficient disk space) and we pass it through
 34143                                  
 34144                                  chk_count:
 34145 000051A4 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34146 000051A6 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34147 000051A8 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34148 000051AA F8                      	clc				;no error either way ;M007
 34149 000051AB 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34150 000051AD 89C8                    	mov	ax,cx			;return old count ;M007
 34151                                  m_cnt_ok:				; M007
 34152 000051AF 5D                      	pop	bp			; M007
 34153                                  $MEN128:
 34154 000051B0 1F                      	pop	ds			;;AN000;;
 34155                                  ;$MIF127: ; 08/04/2023
 34156 000051B1 C3                      	retn
 34157                                  
 34158                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34159                                  ;;
 34160                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34161                                  ;;
 34162                                  ;;	FUNCTION:  Will set registers for extended error #39
 34163                                  ;;	INPUTS:    None
 34164                                  ;;	OUPUTS:    AX,BX,CX set
 34165                                  ;;	REGS USED:
 34166                                  ;;
 34167                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34168                                  
 34169                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34170                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34171                                  $M_GET_EXT_ERR_39:
 34172 000051B2 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34173                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34174 000051B5 BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34175                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34176 000051B8 B501                    	mov	ch,1			;AN001;
 34177 000051BA C3                      	retn				;AN001;
 34178                                  
 34179                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34180                                  ;;
 34181                                  ;;	PROC NAME: $M_ADD_CRLF
 34182                                  ;;
 34183                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34184                                  ;;	INPUTS:    DX contains the Input/Class requested
 34185                                  ;;	OUTPUTS:   None
 34186                                  ;;	REGS Revised: CX,ES,DI
 34187                                  ;;
 34188                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34189                                  
 34190                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34191                                  
 34192                                  $M_ADD_CRLF:
 34193                                  	;cmp	dh,0FFh
 34194 000051BB 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34195 000051BE 7411                    	je	short $MIF134		;;AN004;; Yes
 34196 000051C0 F6C680                  	test	dh,80h ; $M_NO_CRLF_MASK ;;AN004;; Are we to supress the CR LF?
 34197 000051C3 750C                    	jnz	short $MIF135
 34198                                  					;;AN004;; No	
 34199 000051C5 1E                      	push	ds			;;AN004;;
 34200 000051C6 07                      	pop	es			;;AN004;; Set ES to data segment
 34201 000051C7 8D3E[0F87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34202                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34203 000051CB B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34204 000051CE E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34205                                  $MIF135:
 34206                                  $MIF134:
 34207 000051D1 C3                      	retn				;;AN004;; Return
 34208                                  
 34209                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34210                                  ;;
 34211                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34212                                  ;;
 34213                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34214                                  ;;	INPUTS:    AL contains the byte to be checked
 34215                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34216                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34217                                  ;;	REGS USED: All restored
 34218                                  ;;
 34219                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34220                                  
 34221                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34222                                  
 34223                                  $M_IS_IT_DBCS:
 34224 000051D2 06                      	push	es			;;AN000;; Save Extra Segment register
 34225 000051D3 57                      	push	di			;;AN000;; Save DI register
 34226                                  
 34227 000051D4 C43E[0887]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34228                                  	;les	di,[$M_RT+60]		;;AN000;;
 34229 000051D8 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34230 000051DA 7417                    	jz	short $MIF138		;;AN000;; No
 34231                                  $MDO139:
 34232 000051DC 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34233                                  					;;AN000;; Is this the terminating flag?
 34234 000051E0 F8                      	clc				;;AN000;;
 34235 000051E1 7410                    	jz	short $MEN139
 34236                                  					;;AN000;; No
 34237 000051E3 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34238 000051E6 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34239 000051E8 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34240 000051EC 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34241                                  					;;AN000;; Yes
 34242 000051EE F9                      	stc				;;AN000;; Set carry flag
 34243                                  $MIF141:
 34244 000051EF 47                      	inc	di			;;AN000;;
 34245 000051F0 47                      	inc	di			;;AN000;;
 34246 000051F1 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34247                                  $MEN139:
 34248                                  $MIF138:
 34249 000051F3 5F                      	pop	di			;;AN000;; Restore DI register
 34250 000051F4 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34251 000051F5 C3                      	retn				;;AN000;; Return
 34252                                  
 34253                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34254                                  ;;
 34255                                  ;;	PROC NAME: $M_CONVERT2ASC
 34256                                  ;;
 34257                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34258                                  ;;	INPUTS: DX:AX contains the number to be converted
 34259                                  ;;		$M_RT_DIVISOR contains the divisor
 34260                                  ;;	OUTPUTS: CX contains the number of characters
 34261                                  ;;		Top of stack  --> Last character
 34262                                  ;;				     . . .
 34263                                  ;;		Bot of stack  --> First character
 34264                                  ;;	REGS USED:
 34265                                  ;;
 34266                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34267                                  
 34268                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34269                                  	; 15/06/2023
 34270                                  $M_CONVERT2ASC:
 34271 000051F6 8F06[1287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34272                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34273                                  	
 34274 000051FA 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34275 000051FC 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34276 000051FD 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34277                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34278 000051FE F736[1687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34279                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34280 00005202 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34281                                  						;;AN000;;  and save reduced High Word in BX
 34282 00005203 F736[1687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34283                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34284                                  
 34285 00005207 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34286 0000520A 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34287 0000520C 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34288 0000520F EB03                    	jmp	short $MEN146
 34289                                  $MIF146:
 34290 00005211 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34291                                  $MEN146:
 34292 00005214 52                      	push	dx				;;AN000;; Save the digit on the stack
 34293 00005215 41                      	inc	cx				;;AN000;; Count that digit
 34294 00005216 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34295 00005218 7504                    	jnz	short $MLL149			;;AN000;; No
 34296 0000521A 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34297 0000521C 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34298                                  $MLL149:
 34299 0000521E 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34300                                  ; 28/04/2023
 34301 00005221 740A                    	je	short $MIF153
 34302                                  ;	jne	short $MIF150			;;AN000;; No
 34303                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34304                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34305                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34306                                  ;	;jne	short $MIF151
 34307                                  ;	; 09/04/2023
 34308                                  ;	jne	short $MEN150
 34309                                  ;						;;AN000;; Yes
 34310                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34311                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34312                                  ;	inc	cx				;;AN000;;
 34313                                  ;$MIF151:
 34314                                  ;	jmp	short $MEN150
 34315                                  
 34316                                  $MIF150:
 34317                                  	; 15/06/2023 (6)
 34318                                  	; MSDOS 6.0
 34319                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34320                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34321                                  	; 15/06/2023 (7)
 34322                                  	; MSDOS 6.22
 34323                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34324 00005223 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34325                                  
 34326                                  ; 28/04/2023
 34327 00005226 7405                    	je	short $MIF153
 34328                                  ;	jne	short $MIF154			;;AN000;; No
 34329                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34330                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34331                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34332                                  ;	;jne	short $MIF155			;;AN000;; No
 34333                                  ;	; 09/04/2023
 34334                                  ;	jne	short $MEN154
 34335                                  ;						;;AN000;; Yes
 34336                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34337                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34338                                  ;	inc	cx				;;AN000;;
 34339                                  ;$MIF155:
 34340                                  ;	jmp	short $MEN154
 34341                                  
 34342                                  $MIF154:
 34343                                  	; 15/06/2023 (9)
 34344                                  	; MSDOS 6.0
 34345                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh
 34346                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34347                                  	; 15/06/2023 (11)
 34348                                  	; MSDOS 6.22
 34349                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah 
 34350 00005228 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34351 0000522B 750B                    	jne	short $MIF158			;;AN000;; No
 34352                                  ; 28/04/2023
 34353                                  $MIF153:
 34354                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34355 0000522D 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34356                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34357 00005231 7505                    	jne	short $MIF159			;;AN000;; No
 34358                                  						;;AN000;; Yes
 34359 00005233 FF36[1F87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34360                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34361 00005237 41                      	inc	cx				;;AN000;;
 34362                                  $MIF159:
 34363                                  $MIF158:
 34364                                  $MEN154:
 34365                                  $MEN150:					;;AN000;;
 34366 00005238 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34367                                  						;;AN000;;  and Revised Low Word
 34368 00005239 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34369                                  	; 28/04/2023
 34370 0000523B EBC1                    	jmp	short $MDO145
 34371                                  ;$MEN145:
 34372                                  	; 28/04/2023
 34373                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34374                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34375 0000523D 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34376 0000523F FF36[1287]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34377                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34378 00005243 C3                      	retn					;;AN000;; Return
 34379                                  
 34380                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34381                                  ;;
 34382                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34383                                  ;;
 34384                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34385                                  ;;	INPUTS:    ES:DI points to beginning of message
 34386                                  ;;		   DS:SI points to first sublist structure in chain
 34387                                  ;;		   BX contains the handle to write to (if applicable)
 34388                                  ;;		   CX contains the length of string to write (before substitutions)
 34389                                  ;;		   BP contains the count of replacables
 34390                                  ;;
 34391                                  ;;	OUTPUTS:
 34392                                  ;;	REGS USED: All
 34393                                  ;;
 34394                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34395                                  
 34396                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34397                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34398                                  
 34399                                  $M_DISPLAY_MESSAGE:
 34400                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34401                                  $MDO165:
 34402 00005244 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34403 00005246 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34404                                  ;; $IF NZ					;;AN000;; No
 34405 00005248 741F                    	jz	short $MIF166			;;AN000;; Yes
 34406                                  	;mov	ah,"%"				;;AN000;; Prepare to scan for %
 34407                                  	;mov	al,0				;;AN004;;
 34408                                  	; 12/08/2024
 34409 0000524A B80025                  	mov	ax,2500h
 34410                                  ;; $DO						;;AN000;; Scan through string until %
 34411                                  $MDO167:
 34412 0000524D 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34413                                  ;; $LEAVE E,AND					;;AN000;; No
 34414 00005250 750A                    	jne	short $MLL168
 34415 00005252 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34416                                  ;; $LEAVE NE,AND				;;AN000;; No
 34417 00005256 7404                    	je	short $MLL168
 34418                                  
 34419 00005258 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34420                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34421 0000525A 750D                    	jne	short $MEN167 ; 12/08/2024
 34422                                  $MLL168:
 34423 0000525C 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34424 0000525F E870FF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34425                                  ;;; $IF C					;;AN004;; Yes
 34426 00005262 7301                    	jnc	short $MIF169
 34427 00005264 47                      	inc	di				;;AN004;; Increment past second part
 34428                                  ;;; $ENDIF					;;AN004;;
 34429                                  $MIF169:
 34430 00005265 47                      	inc	di				;;AN000;; Next character in string
 34431 00005266 42                      	inc	dx				;;AN000;; Size = Size + 1
 34432                                  	;dec	cx				;;AN000;; Decrement total size
 34433                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34434                                  	;jnz	short $MDO167
 34435                                  	; 12/08/2024
 34436 00005267 E2E4                    	loop	$MDO167
 34437                                  $MEN167:
 34438                                  ;; $ENDIF					;;AN000;;
 34439                                  $MIF166:
 34440 00005269 56                      	push	si				;;AN000;; Save beginning of sublists
 34441 0000526A 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34442 0000526C 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34443                                  ;; $IF NZ					;;AN000;; Yes
 34444 0000526E 7431                    	jz	short $MIF173
 34445 00005270 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34446                                  
 34447                                  ;; Search through sublists to find applicable one
 34448                                  
 34449 00005271 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34450                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34451                                  ;;; $IF E					;;AN000;; No
 34452 00005276 7529                    	jne	short $MIF174
 34453                                  ;;; $SEARCH					;;AN000;;
 34454                                  $MDO175:
 34455                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34456 00005278 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34457                                  	;mov	al,[si+6]
 34458 0000527B 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34459                                  	; 28/04/2023					
 34460 0000527D 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34461                                  ;;; $EXITIF E					;;AN000;;
 34462                                  	;jne	short $MIF175
 34463                                  ;;; $ORELSE					;;AN000;; No
 34464                                  	;jmp	short $MSR175
 34465                                  	; 28/04/2023
 34466 00005281 741E                    	je	short $MSR175
 34467                                  $MIF175:
 34468 00005283 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34469                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34470 00005285 7504                    	jne	short $MLL178
 34471 00005287 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34472                                  ;;; $LEAVE Z					;;AN000;; No
 34473 00005289 7404                    	jz	short $MEN175
 34474                                  $MLL178:
 34475                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34476                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34477                                  	;;add	si,[si+0]
 34478 0000528B 0334                    	add	si,[si]
 34479                                  ;;; ENDLOOP					;;AN000;; Yes
 34480 0000528D EBE9                    	jmp	short $MDO175
 34481                                  $MEN175:
 34482 0000528F 803E[1187]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34483                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34484                                  ;;;; $IF E					;;AN004;; Yes
 34485 00005294 7508                    	jne	short $MIF180
 34486 00005296 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34487 00005297 42                      	inc	dx				;;AN000;;  at the end of the message
 34488 00005298 49                      	dec	cx				;;AN000;; Adjust message length
 34489 00005299 49                      	dec	cx				;;AN000;;
 34490 0000529A 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34491 0000529B 4F                      	dec	di				;;AN000;;
 34492                                  ;;;; $ELSE					;;AN004;; No
 34493 0000529C EB03                    	jmp	short $MEN180
 34494                                  $MIF180:
 34495 0000529E BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34496                                  ;;;; $ENDIF					;;AN004;;
 34497                                  $MEN180:
 34498                                  ;;; $ENDSRCH					;;AN000;;
 34499                                  $MSR175:
 34500                                  ;; $ENDIF					;;AN000;;
 34501                                  $MIF174:
 34502                                  ; $ENDIF					;;AN000;;
 34503                                  $MIF173:
 34504                                  ;; Prepare and display this part of message
 34505                                  
 34506 000052A1 57                      	push	di				;;AN000;; Save pointer to replace number
 34507 000052A2 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34508 000052A4 E835FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34509 000052A7 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34510 000052A8 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34511                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34512                                  	;jnc	short $MXL3
 34513                                  	;jmp	$MEN165
 34514                                  	; 02/05/2023
 34515 000052A9 7214                    	jc	short $MEN165
 34516                                  $MXL3:
 34517 000052AB 51                      	push	cx				;;AN000;;
 34518                                  
 34519                                  ;; Save and reset pointer registers
 34520                                  
 34521 000052AC 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34522                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34523 000052AE 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34524                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34525                                  ; $IF NE					;;AN000;; No
 34526 000052B2 7412                    	je	short $MIF187			;;AN000;; Yes			
 34527 000052B4 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34528                                  ;; $IF NZ					;;AN000;; No
 34529 000052B6 7406                    	jz	short $MIF188			;;AN000;; Yes
 34530 000052B8 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34531 000052B9 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34532 000052BA 47                      	inc	di				;;AN000;; Go past %
 34533 000052BB 47                      	inc	di				;;AN000;; Go past replace number
 34534                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34535                                  	;jmp	short $MEN188
 34536                                  	; 28/04/2023
 34537 000052BC EB15                    	jmp	short $MEN187
 34538                                  $MIF188:
 34539 000052BE 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34540                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34541                                  $MEN188:
 34542                                  ; $ELSE 					;;AN000;;
 34543                                  	;jmp	short $MEN187
 34544                                  	; 28/04/2023
 34545                                  	; zf = 1
 34546                                  	;jmp	short $MEN165 
 34547                                  
 34548                                  ; 28/04/2023
 34549                                  $MXL4:
 34550                                  $MLL214:
 34551                                  $MEN165:
 34552 000052BF C706[1487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34553                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34554                                  						;;AN000;; Reset message number to null
 34555 000052C5 C3                      	retn					;;AN000;; Return
 34556                                  
 34557                                  $MIF187:
 34558 000052C6 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34559                                  ;; $IF Z					;;AN004;; No
 34560                                  	;jnz	short $MIF192
 34561                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34562                                  ;; $ELSE					;;AN000;; No
 34563                                  	;jmp	short $MEN192
 34564                                  	; 28/04/2023
 34565 000052C8 74F4                    	jz	short $MIF188
 34566                                  $MIF192:
 34567 000052CA 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34568                                  ;;; $IF Z					;;AN004;; No
 34569 000052CD 7502                    	jnz	short $MIF194
 34570 000052CF 31C9                    	xor	cx,cx				;;AN004;;
 34571                                  ;;; $ENDIF					;;AN000;;
 34572                                  $MIF194:
 34573 000052D1 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34574                                  ;; $ENDIF					;;AN000;;
 34575                                  $MEN192:
 34576                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34577                                  $MEN187:
 34578                                  ; $LEAVE Z					;;AN000;;
 34579 000052D3 74EA                    	jz	short $MEN165
 34580                                  	;
 34581 000052D5 55                      	push	bp				;;AN000;; Save the replace count
 34582 000052D6 57                      	push	di				;;AN000;; Save location to complete message
 34583 000052D7 06                      	push	es				;;AN000;;
 34584 000052D8 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34585 000052D9 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34586                                  
 34587                                  ;; Determine what action is required on parameter
 34588                                  
 34589 000052DB 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34590                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34591                                  ; $IF E						;;AN000;;
 34592 000052E0 753B                    	jne	short $MIF199
 34593                                  
 34594                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34595 000052E2 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34596                                  	;test	byte [si+7],0Fh			;;AN000;;
 34597                                  ;; $IF Z					;;AN000;;
 34598 000052E6 7508                    	jnz	short $MIF200
 34599                                  
 34600                                  ;; Character type requested
 34601                                  
 34602                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34603 000052E8 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34604                                  	;les	di,[si+2]
 34605 000052EB E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34606                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34607 000052EE EB28                    	jmp	short $MEN200
 34608                                  $MIF200:
 34609                                  ;; ENDIF					;;AN000;;
 34610                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34611 000052F0 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34612                                  	;test	byte [si+7],0Dh			;;AN000;;
 34613                                  ;; $IF Z,OR					;;AN000;;
 34614 000052F4 740C                    	jz	short $MLL202
 34615                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34616 000052F6 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34617                                  	;test	byte [si+7],0Eh			;;AN000;;
 34618                                  ;;; $IF Z,OR					;;AN000;;
 34619 000052FA 7406                    	jz	short $MLL202
 34620                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34621 000052FC F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34622                                  	;test	byte [si+7],0Ch			;;AN000;;
 34623                                  ;;;; $IF Z 					;;AN000;;
 34624 00005300 7508                    	jnz	short $MIF202
 34625                                  $MLL202:
 34626                                  
 34627                                  ;; Numeric type requested
 34628                                  
 34629                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34630 00005302 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34631 00005305 E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34632                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34633 00005308 EB0E                    	jmp	short $MEN202
 34634                                  $MIF202:
 34635                                  ;;;; ENDIF					;;AN000;;
 34636                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34637 0000530A F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34638                                  	;test	byte [si+7],0Bh			;;AN000;;
 34639                                  ;;;; $IF E					;;AN000;;
 34640 0000530E 7505                    	jnz	short $MIF204
 34641                                  
 34642                                  ;; Date type requested
 34643                                  
 34644 00005310 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34645                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34646 00005313 EB03                    	jmp	short $MEN204
 34647                                  $MIF204:					;;AN000;;
 34648                                  
 34649                                  ;; Time type requested (Default if we have not matched until here)
 34650                                  
 34651 00005315 E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34652                                  
 34653                                  ;;;; $ENDIF					;;AN000;;
 34654                                  $MEN204:
 34655                                  ;;; $ENDIF					;;AN000;;
 34656                                  $MEN202:
 34657                                  ;; $ENDIF					;;AN000;;
 34658                                  $MEN200:
 34659                                  
 34660                                  ;; With the replace information of the Stack, display the replaceable field
 34661                                  
 34662 00005318 E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34663                                  
 34664                                  ;; None of the above - Extended/Parse replace
 34665                                  ; $ELSE 					;;AN000;;
 34666 0000531B EB03                    	jmp	short $MEN199
 34667                                  $MIF199:
 34668 0000531D E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34669                                  ; $ENDIF					;;AN000;;
 34670                                  $MEN199:
 34671                                  
 34672                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34673                                  
 34674                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34675 00005320 7207                    	jc	short $MIF211
 34676                                  	;
 34677 00005322 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34678 00005323 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34679 00005324 5F                      	pop	di				;;AN000;;
 34680 00005325 5D                      	pop	bp				;;AN000;; Get replacment count
 34681 00005326 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34682                                  ; $ELSE						;;AN000;;
 34683 00005327 EB03                    	jmp	short $MEN211
 34684                                  $MIF211:
 34685 00005329 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34686                                  	; 28/04/2023
 34687                                  	;stc					;;AN000;;
 34688                                  ; $ENDIF					;;AN000;;
 34689                                  $MEN211:
 34690 0000532C 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34691                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34692                                  ; $ENDDO NE,OR					;;AN000;;
 34693 00005331 758C                    	jne	short $MLL214
 34694                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34695                                  	; 10/04/2023
 34696                                  	;jc	short $MXL4
 34697 00005333 E90EFF                  	jmp	$MDO165
 34698                                  
 34699                                  ; 28/04/2023
 34700                                  ;$MXL4:
 34701                                  ;$MLL214:
 34702                                  ;$MEN165:
 34703                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34704                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34705                                  ;						;;AN000;; Reset message number to null
 34706                                  ;	retn					;;AN000;; Return
 34707                                  
 34708                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34709                                  ;;
 34710                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34711                                  ;;
 34712                                  ;;	FUNCTION:
 34713                                  ;;	INPUTS:
 34714                                  ;;	OUPUTS:
 34715                                  ;;
 34716                                  ;;	REGS USED:
 34717                                  ;;
 34718                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34719                                  
 34720                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34721                                  
 34722                                  $M_EXT_PAR_REPLACE:
 34723 00005336 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34724 00005338 A1[1487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34725                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34726 0000533B C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34727                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34728 00005341 E8B2FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34729                                  $MDO215:
 34730 00005344 58                      	pop	ax				;;AN000;; Get character in register
 34731 00005345 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34732                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34733 00005349 43                      	inc	bx				;;AN000;; Increase buffer count
 34734 0000534A 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34735 0000534D 7503                    	jne	short $MIF216			;;AN000;; No
 34736 0000534F E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34737                                  $MIF216:
 34738 00005352 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34739 00005354 75EE                    	jnz	short $MDO215
 34740                                  
 34741 00005356 B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34742 00005359 8987[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34743                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34744 0000535D 43                      	inc	bx				;;AN000;; Increase buffer count
 34745 0000535E 43                      	inc	bx				;;AN000;; Increase buffer count
 34746                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34747                                  	;retn					;;AN000::
 34748                                  	; 11/04/2023
 34749                                  	;jmp	$M_FLUSH_BUF
 34750                                  
 34751                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34752                                  ;;
 34753                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34754                                  ;;
 34755                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34756                                  ;;	INPUTS: DI contains the number of bytes to display
 34757                                  ;;	OUTPUTS: BX reset to zero
 34758                                  ;;
 34759                                  ;;	REGS USED:
 34760                                  ;;
 34761                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34762                                  	
 34763                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34764                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34765                                  
 34766                                  $M_FLUSH_BUF:
 34767 0000535F 51                      	push	cx				;;AN000;; Save changed regs
 34768 00005360 06                      	push	es				;;AN000;;
 34769 00005361 57                      	push	di				;;AN000;;
 34770 00005362 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34771 00005363 07                      	pop	es				;;AN000;;
 34772 00005364 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34773 00005366 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34774 00005368 8D3E[1887]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34775                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34776 0000536C E86DFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34777 0000536F 7204                    	jc	short $MIF314
 34778 00005371 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34779 00005372 07                      	pop	es				;;AN000;;
 34780 00005373 59                      	pop	cx				;;AN000;;
 34781                                  	;jmp	short $MEN314
 34782                                  	; 11/04/2023
 34783 00005374 C3                      	retn
 34784                                  $MIF314:
 34785 00005375 83C406                  	add	sp,6				;;AN000;; Fix stack
 34786 00005378 F9                      	stc					;;AN000;;
 34787                                  $MEN314:
 34788 00005379 C3                      	retn					;;AN000;; Return
 34789                                  
 34790                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34791                                  ;;
 34792                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34793                                  
 34794                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34795                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34796                                  
 34797                                  $M_DISPLAY_REPLACE:
 34798 0000537A 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34799                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34800 0000537C 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34801                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34802 00005380 7511                    	jne	short $MIF276
 34803                                  	
 34804 00005382 C787[1887]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34805                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34806                                  	
 34807 00005388 43                      	inc	bx				;;AN000;; Increment count
 34808 00005389 43                      	inc	bx				;;AN000;; Increment count
 34809                                  	
 34810 0000538A C687[1887]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34811                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34812                                  	
 34813 0000538F 43                      	inc	bx				;;AN000;; Increment count
 34814 00005390 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34815                                  $MIF276:
 34816 00005393 5D                      	pop	bp				;;AN000;; Remember the return address
 34817 00005394 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34818 00005396 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34819                                  
 34820 00005398 880E[0E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34821                                  	;mov	[$M_RT+66],cl
 34822                                  	
 34823                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34824 0000539C 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34825                                  	;mov	al,[si+9]
 34826                                  	
 34827 0000539F 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34828 000053A1 761E                    	jna	short $MIF278
 34829 000053A3 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34830 000053A5 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34831                                  	
 34832                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34833 000053A7 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34834                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34835 000053AB 7414                    	jz	short $MIF279			;;AN000;; No
 34836                                  $MDO280:
 34837                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34838 000053AD 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34839                                  	;mov	al,[si+0Ah]
 34840 000053B0 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34841                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34842                                  	
 34843 000053B4 43                      	inc	bx				;;AN000;;
 34844 000053B5 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34845 000053B8 7503                    	jne	short $MIF281
 34846 000053BA E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34847                                  $MIF281:
 34848 000053BD FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34849 000053BF 75EC                    	jnz	short $MDO280
 34850                                  $MIF279:
 34851                                  $MIF278:
 34852                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34853 000053C1 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34854                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34855 000053C5 740C                    	je	short $MIF286
 34856                                  	
 34857                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34858 000053C7 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34859                                  	;;cmp	byte [si+8],cl
 34860 000053CA 7307                    	jnb	short $MIF287
 34861                                  
 34862                                  	; 03/05/2023
 34863                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34864                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34865                                  	;;sub	cl,[si+8]
 34866 000053CC 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34867                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34868                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34869                                  	;;mov	cl,[si+8]
 34870                                  	; 03/05/2023
 34871 000053CE 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34872 000053D1 28CA                    	sub	dl,cl
 34873                                  $MIF287:
 34874                                  $MIF286:
 34875 000053D3 09C9                    	or	cx,cx				;;AN000;;
 34876 000053D5 7424                    	jz	short $MIF290			;;AN000;;
 34877                                  $MDO291:
 34878                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34879 000053D7 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34880                                  	;test	byte [si+7],0Fh			;;AN000;;
 34881 000053DB 750C                    	jnz	short $MIF292
 34882                                  
 34883                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34884 000053DD F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34885                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34886 000053E1 7406                    	jz	short $MIF292			;;AN000;; No
 34887                                  
 34888 000053E3 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34889 000053E6 47                      	inc	di				;;AN000;; Next character in string
 34890 000053E7 EB01                    	jmp	short $MEN292
 34891                                  $MIF292:
 34892 000053E9 58                      	pop	ax				;;AN000;; Get character in register
 34893                                  $MEN292:
 34894                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34895 000053EA 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34896                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34897                                  	; 03/05/2023
 34898 000053EE 43                      	inc	bx				;;AN000;; Increase buffer count
 34899 000053EF 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34900 000053F2 7503                    	jne	short $MIF295			;;AN000;;
 34901 000053F4 E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34902                                  $MIF295:
 34903 000053F7 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34904 000053F9 75DC                    	jnz	short $MDO291
 34905                                  $MIF290:
 34906                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34907 000053FB F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34908                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34909 000053FF 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34910 00005401 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34911 00005403 7414                    	jz	short $MIF300
 34912                                  $MDO301:
 34913                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34914 00005405 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34915                                  	;mov	al,[si+0Ah]
 34916                                  
 34917                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34918 00005408 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34919                                  	; 03/05/2023
 34920                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34921                                  
 34922 0000540C 43                      	inc	bx				;;AN000;;
 34923 0000540D 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34924 00005410 7503                    	jne	short $MIF302			;;AN000;; No
 34925                                  						;;AN000;; Yes
 34926 00005412 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34927                                  $MIF302:
 34928 00005415 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34929 00005417 75EC                    	jnz	short $MDO301			;;AN000;;
 34930                                  $MIF300:
 34931                                  $MIF299:
 34932                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34933 00005419 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34934                                  	;test	byte [si+7],0Fh			;;AN000;;
 34935 0000541D 7506                    	jnz	short $MIF307
 34936                                  	
 34937                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34938 0000541F F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34939                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34940                                  	; 11/04/2023
 34941                                  	;jz	short $MIF307			;;AN000;;
 34942                                  	;jmp	short $MEN307			;;AN000;;
 34943 00005423 750C                    	jnz	short $MEN307
 34944                                  $MIF307:
 34945 00005425 08D2                    	or	dl,dl				;;AN000;;
 34946 00005427 7408                    	jz	short $MIF309			;;AN000;;
 34947                                  $MDO310:
 34948 00005429 8F06[1287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34949                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34950 0000542D FECA                    	dec	dl				;;AN000;; Are we done?
 34951 0000542F 75F8                    	jnz	short $MDO310
 34952                                  $MIF309:
 34953                                  $MEN307:
 34954 00005431 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34955 00005434 55                      	push	bp				;;AN000;; Restore the return address
 34956 00005435 C3                      	retn					;;AN000;;
 34957                                  
 34958                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34959                                  ;;
 34960                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34961                                  ;;
 34962                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34963                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34964                                  ;;		ES:DI contains the VALUE from SUBLIST
 34965                                  ;;	OUTPUTS: CX contains number of characters on stack
 34966                                  ;;		 Top of stack  --> Last character
 34967                                  ;;					. . .
 34968                                  ;;		 Bot of stack  --> First character
 34969                                  ;;
 34970                                  ;;	OTHER REGS Revised: AX
 34971                                  ;;
 34972                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34973                                  
 34974                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34975                                  
 34976                                  $M_CHAR_REPLACE:
 34977 00005436 5D                      	pop	bp				;;AN000;; Save return address
 34978                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 34979 00005437 F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 34980                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 34981 0000543B 7512                    	jnz	short $MIF317			;;AN000;; No
 34982 0000543D 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34983 00005440 50                      	push	ax				;;AN000;; Put it on the stack
 34984 00005441 41                      	inc	cx				;;AN000;; Increase the count
 34985 00005442 E88DFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 34986 00005445 7306                    	jnc	short $MIF318
 34987 00005447 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 34988 0000544B 50                      	push	ax				;;AN000;; Put it on the stack
 34989 0000544C F8                      	clc					;;AN000;; Clear the carry
 34990                                  $MIF318:
 34991 0000544D EB0D                    	jmp	short $MEN317
 34992                                  $MIF317:
 34993                                  $MDO321:
 34994 0000544F 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34995 00005452 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 34996 00005454 7404                    	jz	short $MEN321			;;AN000;; Yes
 34997 00005456 47                      	inc	di				;;AN000;; Next character
 34998 00005457 41                      	inc	cx				;;AN000;; Increment the count
 34999 00005458 EBF5                    	jmp	short $MDO321
 35000                                  $MEN321:
 35001 0000545A 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 35002                                  $MEN317:
 35003 0000545C 55                      	push	bp				;;AN000;; Restore return address
 35004 0000545D C3                      	retn					;;AN000;;	
 35005                                  
 35006                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35007                                  ;;
 35008                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 35009                                  ;;
 35010                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 35011                                  ;;		  and prepare to display
 35012                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35013                                  ;;		ES:DI contains the VALUE from SUBLIST
 35014                                  ;;	OUTPUTS: CX contains number of characters on stack
 35015                                  ;;		 Top of stack  --> Last character
 35016                                  ;;					. . .
 35017                                  ;;		 Bot of stack  --> First character
 35018                                  ;;	OTHER REGS Revised: BX,DX,AX
 35019                                  ;;
 35020                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35021                                  
 35022                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35023                                  
 35024                                  $M_BIN2ASC_REPLACE:
 35025 0000545E 5D                      	pop	bp				;;AN000;; Save return address
 35026 0000545F 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35027 00005461 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 35028 00005463 C706[1687]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 35029                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 35030                                  
 35031 00005469 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 35032                                  
 35033                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 35034 0000546B F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35035                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 35036 0000546F 7511                    	jnz	short $MIF325			;;AN000;; No
 35037                                  	
 35038 00005471 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 35039                                  
 35040                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35041 00005474 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35042                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 35043 00005478 753D                    	jnz	short $MIF326			;;AN000;; No
 35044                                  			 
 35045 0000547A A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 35046 0000547C 7433                    	jz	short $MIF327			;;AN000;; No
 35047                                  						;;AN000;; Yes				
 35048                                  	; 12/04/2023
 35049                                  	;inc	bx				;;AN000;; Remember that it was negative
 35050 0000547E 247F                    	and	al,01111111b			;;AN000;; Make it positive
 35051                                  
 35052                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 35053                                  	;jmp	short $MIF327
 35054 00005480 EB2E                    	jmp	short $MIF350 ; inc bx
 35055                                  
 35056                                  ; 12/04/2023
 35057                                  %if 0
 35058                                  
 35059                                  $MIF327:
 35060                                  $MIF335:	; 12/04/2023
 35061                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35062                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35063                                  $MIF326:
 35064                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35065                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35066                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35067                                  	jnz	short $MIF330			;;AN000;; No
 35068                                  						;;AN000;; Yes
 35069                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35070                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35071                                  $MIF330:
 35072                                  	jmp	short $MEN325
 35073                                  
 35074                                  %endif
 35075                                  
 35076                                  $MIF325:
 35077                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 35078 00005482 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35079                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 35080 00005486 7513                    	jnz	short $MIF333			;;AN000;; No
 35081                                  						;;AN000;; Yes
 35082 00005488 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 35083                                  
 35084                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35085 0000548B F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35086                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35087 0000548F 7526                    	jnz	short $MIF334			;;AN000;; No
 35088                                  						;;AN000;; Yes
 35089 00005491 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 35090 00005494 741B                    	jz	short $MIF335			;;AN000;; No
 35091                                  						;;AN000;; Yes
 35092                                  	; 12/04/2023
 35093                                  	;inc	bx				;;AN000;; Remember that it was negative
 35094 00005496 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 35095                                  
 35096                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35097                                  	;jmp	short $MIF335
 35098 00005499 EB15                    	jmp	short $MIF350 ; inc bx
 35099                                  
 35100                                  ; 12/04/2023
 35101                                  %if 0
 35102                                  
 35103                                  $MIF335:
 35104                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35105                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35106                                  $MIF334:
 35107                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 35108                                  	jnz	short $MIF338
 35109                                  
 35110                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35111                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35112                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35113                                  	jnz	short $MIF338			;;AN000;; No
 35114                                  						;;AN000;; Yes
 35115                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35116                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35117                                  $MIF338:
 35118                                  	jmp	short $MEN333			;;AN000;;
 35119                                  %endif
 35120                                  
 35121                                  $MIF333:
 35122 0000549B 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35123 0000549E 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35124                                  
 35125                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35126 000054A2 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35127                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35128 000054A6 750F                    	jnz	short $MIF341			;;AN000;; No
 35129                                  						;;AN000;; Yes
 35130 000054A8 F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35131 000054AB 7404                    	jz	short $MIF342			;;AN000;; No
 35132                                  						;;AN000;; Yes
 35133                                  	; 12/04/2023
 35134                                  	;inc	bx				;;AN000;; Remember that it was negative
 35135 000054AD 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35136                                  	
 35137                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35138                                  $MIF350:
 35139 000054B0 43                      	inc	bx
 35140                                  $MIF342:
 35141                                  	; 12/04/2023
 35142                                  $MIF327:
 35143                                  $MIF335:
 35144 000054B1 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35145                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35146                                  $MIF341:
 35147                                  $MIF326:
 35148                                  	; 18/04/2023
 35149                                  $MIF334:
 35150                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35151 000054B7 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35152                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35153 000054BB 7506                    	jnz	short $MIF345			;;AN000;; No
 35154                                  						;;AN000;; Yes
 35155 000054BD C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35156                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35157                                  $MIF345:
 35158                                  $MEN333:
 35159                                  $MEN325:
 35160 000054C3 E830FD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35161                                  
 35162 000054C6 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35163 000054C8 7405                    	jz	short $MIF349			;;AN000;; No
 35164                                  						;;AN000;; Yes
 35165 000054CA 31D2                    	xor	dx,dx				;;AN000;;
 35166 000054CC B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35167 000054CE 52                      	push	dx				;;AN000;;
 35168                                  $MIF349:
 35169 000054CF 55                      	push	bp				;;AN000;; Restore return address
 35170 000054D0 C3                      	retn					;;AN000;; Return
 35171                                  
 35172                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35173                                  ;;
 35174                                  ;;	PROC NAME: $M_DATE_REPLACE
 35175                                  ;;
 35176                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35177                                  ;;		  country format and prepare to display
 35178                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35179                                  ;;		ES:DI points at VALUE from SUBLIST
 35180                                  ;;	OUTPUTS: CX contains number of characters on stack
 35181                                  ;;		 Top of stack  --> Last character
 35182                                  ;;					. . .
 35183                                  ;;		 Bot of stack  --> First character
 35184                                  ;;	OTHER REGS Revised: DX,AX
 35185                                  ;;
 35186                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35187                                  
 35188                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35189                                  $M_DATE_REPLACE:
 35190 000054D1 5D                      	pop	bp				;;AN000;; Save return address
 35191                                  
 35192 000054D2 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35193                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35194                                  	
 35195 000054D8 E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35196                                  						;;AN000;; All O.K.?
 35197 000054DB 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35198                                  	; 12/04/2023
 35199                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35200                                  	
 35201                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35202                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35203                                  	;jne	short $MIF351
 35204                                  	; 12/04/2023
 35205 000054DD A1[1887]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35206 000054E0 09C0                    	or	ax,ax
 35207 000054E2 751D                    	jnz	short $MIF351
 35208                                  
 35209 000054E4 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35210 000054E7 E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35211                                  
 35212 000054EA FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35213                                  	;push	word [$M_RT+87]			;;AN000;;
 35214                                  	
 35215 000054EE 41                      	inc	cx				;;AN000;; Increment count
 35216 000054EF 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35217                                  
 35218 000054F1 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35219                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35220 000054F4 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35221                                  	
 35222 000054F7 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35223                                  	;push	word [$M_RT+87]			;;AN000;;
 35224                                  
 35225 000054FB 41                      	inc	cx				;;AN000;; Increment count
 35226 000054FC 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35227                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35228                                  	; 12/04/2023
 35229                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35230 000054FF EB3C                    	jmp	short $MIF354 ; **
 35231                                  $MIF351:
 35232                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35233                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35234                                  	;jne	short $MIF353
 35235                                  	; 12/04/2023
 35236                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35237 00005501 48                      	dec	ax 
 35238 00005502 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35239                                  
 35240 00005504 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35241 00005507 E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35242                                  
 35243 0000550A FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35244                                  	;push	word [$M_RT+87]			;;AN000;;
 35245                                  	
 35246 0000550E 41                      	inc	cx				;;AN000;; Increment count
 35247 0000550F 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35248                                  
 35249 00005511 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35250                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35251 00005514 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35252                                  
 35253 00005517 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35254                                  	;push	word [$M_RT+87]			;;AN000;;
 35255                                  
 35256 0000551B 41                      	inc	cx				;;AN000;;
 35257                                  	      
 35258 0000551C 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35259                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35260                                  
 35261                                  	; 12/04/2023
 35262                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35263 0000551F EB1C                    	jmp	short $MIF354 ; **
 35264                                  	; 12/04/2023
 35265                                  $MIF352:
 35266                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35267 00005521 48                      	dec	ax
 35268                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35269                                  	;xor	ax,ax
 35270                                  	;jmp	short $MIF355
 35271                                  	; 12/04/2023
 35272 00005522 751C                    	jnz	short $MIF355
 35273                                  $MIF353:
 35274                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35275                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35276                                  	;jne	short $MIF355
 35277                                  
 35278 00005524 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35279                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35280 00005527 E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35281                                  	
 35282 0000552A FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35283                                  	;push	word [$M_RT+87]			;;AN000;;
 35284                                  
 35285 0000552E 41                      	inc	cx				;;AN000;;
 35286                                  
 35287 0000552F 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35288                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35289 00005532 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35290                                  	
 35291 00005535 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35292                                  	;push	word [$M_RT+87]			;;AN000;;
 35293                                  	
 35294 00005539 41                      	inc	cx				;;AN000;;
 35295                                  
 35296 0000553A E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35297                                  	; 12/04/2023
 35298                                  $MIF354:
 35299 0000553D E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35300                                  $MIF355:
 35301 00005540 55                      	push	bp				;;AN000;; Restore return address
 35302 00005541 C3                      	retn					;;AN000;; Return
 35303                                  
 35304                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35305                                  ;;
 35306                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35307                                  
 35308                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35309                                  $M_GET_DATE:
 35310                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35311                                  	;mov	al,0 				;;AN000;; Get current country info
 35312                                  	; 12/04/2023
 35313 00005542 B80038                  	mov	ax,3800h
 35314                                  	;
 35315 00005545 8D16[1887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35316                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35317 00005549 CD21                    	int	21h				;;AN000;;
 35318 0000554B 730B                    	jnc	short $MIF357
 35319                                  	;
 35320 0000554D C706[1887]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35321                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35322 00005553 C606[2387]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35323                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35324                                  $MIF357:
 35325 00005558 C3                      	retn					;;AN000;;
 35326                                  
 35327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35328                                  ;;
 35329                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35330                                  
 35331                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35332                                  $M_YEAR:
 35333 00005559 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35334                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35335                                  
 35336                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35337 0000555C F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35338                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35339 00005560 7508                    	jnz	short $MIF359			;;AN000;; No
 35340                                  						;;AN000;; Yes
 35341 00005562 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35342 00005565 7603                    	jna	short $MIF360			;;AN000;;
 35343 00005567 B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35344                                  $MIF360:
 35345                                  $MIF359:
 35346 0000556A C3                      	retn					;;AN000;;
 35347                                  
 35348                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35349                                  ;;
 35350                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35351                                  
 35352                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35353                                  $M_CONVERTDATE:
 35354                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35355 0000556B 8F06[1887]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35356                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35357 0000556F 880E[0E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35358                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35359 00005573 E880FC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35360 00005576 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35361 00005577 3A0E[0E87]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35362 0000557B 7505                    	jne	short $MIF363			;;AN000;; No
 35363 0000557D B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35364 00005580 50                      	push	ax				;;AN000;; Save it
 35365 00005581 41                      	inc	cx				;;AN000;; Count it
 35366                                  $MIF363:
 35367 00005582 41                      	inc	cx				;;AN000;; Restore CX
 35368 00005583 FF36[1887]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35369                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35370 00005587 C3                      	retn
 35371                                  
 35372                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35373                                  ;;
 35374                                  ;;	PROC NAME: $M_TIME_REPLACE
 35375                                  ;;
 35376                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35377                                  ;;		  and prepare to display
 35378                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35379                                  ;;		ES:DI points at VALUE from SUBLIST
 35380                                  ;;	OUTPUTS: CX contains number of characters on stack
 35381                                  ;;		 Top of stack  --> Last character
 35382                                  ;;					. . .
 35383                                  ;;		 Bot of stack  --> First character
 35384                                  ;;	REGS USED: BP,CX,AX
 35385                                  ;;
 35386                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35387                                  
 35388                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35389                                  	; 13/08/2024							     ;;
 35390                                  $M_TIME_REPLACE:
 35391 00005588 5D                      	pop	bp				;;AN000;; Save return address
 35392                                  
 35393 00005589 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35394                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35395                                  
 35396 0000558F E87700                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35397                                  
 35398                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35399 00005592 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35400                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35401 00005596 741A                    	jz	short $MIF365			;;AN000;; No
 35402                                  						;;AN000;; Yes
 35403 00005598 803E[2987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35404                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35405 0000559D 7513                    	jne	short $MIF366			;;AN000;; No
 35406                                  						;;AN000;; Yes
 35407 0000559F 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35408                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35409 000055A2 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35410 000055A4 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35411 000055A6 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35412 000055A8 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35413                                  $MLL367:
 35414 000055AA B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35415                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35416                                  	;inc	cx				;;AN000;;
 35417                                  	;jmp	short $MEN367			;;AN000;;
 35418                                  	; 12/04/2023
 35419 000055AC EB02                    	jmp	short $MEN367 ; *
 35420                                  $MIF367:
 35421 000055AE B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35422                                  $MEN367:	; * ; 12/04/2023
 35423 000055B0 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35424 000055B1 41                      	inc	cx				;;AN000;;
 35425                                  ;$MEN367:
 35426                                  $MIF366:
 35427                                  $MIF365:					;;AN000;;
 35428 000055B2 31C0                    	xor	ax,ax				;;AN000;;
 35429                                  	;xor	dx,dx				;;AN000;;
 35430                                  	; 13/08/2024
 35431 000055B4 99                      	cwd	; PCDOS 7.1 COMMAND.COM
 35432                                  	
 35433                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35434 000055B5 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35435                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35436 000055B9 740B                    	jz	short $MIF372			;;AN000;;
 35437                                  
 35438 000055BB 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35439                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35440 000055BE E8AAFF                  	call	$M_CONVERTTIME			;;AN000;;
 35441                                  
 35442 000055C1 FF36[2187]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35443                                  	;push	word [$M_RT+85]			;;AN000;;
 35444 000055C5 41                      	inc	cx				;;AN000;;
 35445                                  $MIF372:
 35446                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35447 000055C6 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35448                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35449 000055CA 7506                    	jnz	short $MLL374			;;AN000;; No
 35450                                  
 35451                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35452 000055CC F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35453                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35454 000055D0 740B                    	jz	short $MIF374			;;AN000;; No
 35455                                  $MLL374:
 35456 000055D2 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35457                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35458 000055D5 E893FF                  	call	$M_CONVERTTIME			;;AN000;;
 35459                                  
 35460 000055D8 FF36[2587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35461                                  	;push	word [$M_RT+89]			;;AN000;;
 35462 000055DC 41                      	inc	cx				;;AN000;;
 35463                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35464 000055DD 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35465                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35466 000055E0 E888FF                  	call	$M_CONVERTTIME			;;AN000;;
 35467                                  
 35468 000055E3 FF36[2587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35469                                  	;push	word [$M_RT+89]			;;AN000;;
 35470 000055E7 41                      	inc	cx				;;AN000;;
 35471                                  
 35472 000055E8 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35473                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35474                                  
 35475                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35476 000055EB F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35477                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35478 000055EF 7413                    	jz	short $MIF376			;;AN000;; No
 35479                                  
 35480 000055F1 803E[2987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35481                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35482 000055F6 750C                    	jne	short $MIF377			;;AN000;; No
 35483                                  
 35484 000055F8 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35485 000055FA 7C02                    	jnge	short $MIF378 ; jl
 35486 000055FC 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35487                                  $MIF378:
 35488                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35489                                  	;jne	short $MIF380			;;AN000;; No
 35490                                  	; 12/04/2023
 35491 000055FE 20C0                    	and	al,al
 35492 00005600 7502                    	jnz	short $MIF380	
 35493 00005602 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35494                                  $MIF380:
 35495                                  $MIF377:
 35496                                  $MIF376:
 35497 00005604 E8EFFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35498 00005607 55                      	push	bp				;;AN000;; Restore return address
 35499 00005608 C3                      	retn					;;AN000;; Return
 35500                                  
 35501                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35502                                  ;;
 35503                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35504                                  
 35505                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35506                                  $M_GET_TIME:
 35507                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35508                                  	;mov	al,0 				;;AN000;; Get current country info
 35509                                  	; 12/04/2023
 35510 00005609 B80038                  	mov	ax,3800h
 35511                                  	;
 35512 0000560C 8D16[1887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35513                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35514 00005610 CD21                    	int	21h				;;AN000;;
 35515 00005612 7310                    	jnc	short $MIF384
 35516                                  
 35517 00005614 C706[2987]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35518                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35519 0000561A C606[2587]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35520                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35521 0000561F C606[2187]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35522                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35523                                  $MIF384:
 35524 00005624 C3                      	retn					;;AN000;;
 35525                                  
 35526                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35527                                  ;;
 35528                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35529                                  
 35530                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35531                                  
 35532                                  ; 12/04/2023 
 35533                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35534                                  %if 0
 35535                                  $M_CONVERTTIME:
 35536                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35537                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35538                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35539                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35540                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35541                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35542                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35543                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35544                                  	jne	short $MIF386			;;AN000;; No
 35545                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35546                                  	push	ax				;;AN000;; Save it
 35547                                  	inc	cx				;;AN000;; Count itount it
 35548                                  $MIF386:
 35549                                  	inc	cx				;;AN000;; Restore CX
 35550                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35551                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35552                                  	retn
 35553                                  %endif
 35554                                  
 35555                                  ; ----------------------------
 35556                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35557                                  ; ----------------------------
 35558                                  ; include msgdcl.inc
 35559                                  ; ----------------------------
 35560                                  
 35561                                  ;============================================================================
 35562                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 35563                                  ;============================================================================
 35564                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35565                                  
 35566                                  ; This is a new module added to support loading programs into UMBs provided
 35567                                  ; by DOS 5.0. 
 35568                                  ; ---------------------------------------------------------------------------
 35569                                  ; Usage:
 35570                                  ;
 35571                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 35572                                  ;
 35573                                  ; <filespec> has to be a filename that is not wildcarded.
 35574                                  
 35575                                  ; ---------------------------------------------------------------------------
 35576                                  ;
 35577                                  ;	Revision History
 35578                                  ;	================
 35579                                  ;
 35580                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35581                                  ;				loading and high and also remember
 35582                                  ;				current UMB state.
 35583                                  ;
 35584                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35585                                  ;				to loadhigh batch files and invalid
 35586                                  ;				filename on Loadhigh command line.
 35587                                  ;
 35588                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35589                                  ;				after the program name also as part
 35590                                  ;				of the command line being passed to
 35591                                  ;				the program to be invoked.
 35592                                  ;
 35593                                  ; ---------------------------------------------------------------------------
 35594                                  
 35595                                  ; ---------------------------------------------------------------------------
 35596                                  ;
 35597                                  ;	include highload.inc		; Grab code for ParseVar and such
 35598                                  
 35599                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35600                                  
 35601                                  ;
 35602                                  ; ---------------------------------------------------------------------------
 35603                                  
 35604                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35605                                  ;
 35606                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35607                                  ;		CS = DS = SS = TRANGROUP
 35608                                  ;
 35609                                  ;	EXIT	None
 35610                                  ;
 35611                                  ;	USED	ax, bx, cx, dx, si, di, es
 35612                                  ;
 35613                                  ;	ERROR EXITS
 35614                                  ;		Message pointers are setup at the error locations and then
 35615                                  ;	we jump back to CERROR which is the transient error recycle point.
 35616                                  ;	Apart from parse errors, the other errors handled are too many
 35617                                  ;	switches anf invalid filenames.
 35618                                  ;
 35619                                  ;	EFFECTS
 35620                                  ;		The allocation strategy and the state of the arena chain are
 35621                                  ;	put in the requested state according to the given options. If a 
 35622                                  ;	filename is also given, it is executed as well.
 35623                                  ; ---------------------------------------------------------------------------
 35624                                  
 35625                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35626                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35627                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35628                                  LoadHigh:
 35629 00005625 1E                      	push	ds
 35630 00005626 07                      	pop	es
 35631                                  
 35632 00005627 E86700                  	call	SkipLhDelims
 35633                                  
 35634                                  ;Get command tail to be passed to the program. This includes any whitespace
 35635                                  ;chars between the program name and its parameters as well.
 35636                                  ;On return, ds:si points at the start of the command tail.
 35637                                  
 35638 0000562A 56                      	push	si
 35639 0000562B E81400                  	call	ParseLhCmd
 35640 0000562E 5E                      	pop	si
 35641 0000562F 720E                    	jc	short LhErr
 35642                                  	
 35643 00005631 E87500                  	call	SetupCmdLine		;setup pgm's command line
 35644                                  
 35645 00005634 E8C800                  	call	SetupPath		;setup path for file
 35646 00005637 7206                    	jc	short LhErr		;file not found
 35647                                  
 35648                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35649                                  ;be reset after return from the Exec
 35650                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35651                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35652                                  
 35653 00005639 E8A600                  	call	HideUMBs		;prepare upper-memory for load
 35654                                  
 35655 0000563C E9BED2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35656                                  
 35657                                  LhErr:
 35658                                  ;The error message has been setup at this stage
 35659                                  
 35660 0000563F E90ED3                  	jmp	cerror			;print error message and recycle 
 35661                                  
 35662                                  ; ---------------------------------------------------------------------------
 35663                                  					
 35664                                  ;*** 	ParseLhCmd - parses any command-line options
 35665                                  ;
 35666                                  ;	ENTRY	None
 35667                                  ;
 35668                                  ;	EXIT	Carry clear -- command line parsed successfully
 35669                                  ;		Carry set -- appropriate error message setup
 35670                                  ;
 35671                                  ;	USED	ax, si
 35672                                  ;
 35673                                  ;	EFFECTS
 35674                                  ;		Options set up (see highvar.inc)
 35675                                  ;		Filename to be executed setup
 35676                                  ;
 35677                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35678                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35679                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35680                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35681                                  ;	prepare the command-line for that program.
 35682                                  ; ---------------------------------------------------------------------------
 35683                                  
 35684                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35685                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35686                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35687                                  	; 11/06/2023
 35688                                  ParseLhCmd:
 35689                                  	;mov	si,81h
 35690 00005642 BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35691                                  
 35692 00005645 C706[BA8A]0000          	mov	word [COMSW],0
 35693 0000564B BF[B085]                	mov	di,Parse_LoadHi
 35694 0000564E 31C9                    	xor	cx,cx
 35695 00005650 E864CB                  	call	Parse_With_Msg
 35696                                  
 35697                                  	; 11/06/2023
 35698                                  	;cmp	ax,0FFFFh ; -1
 35699                                  	;jz	short PLhCmd2
 35700                                  	;cmp	ax,0
 35701                                  	;jnz	short PLhCmd1
 35702                                  	; 11/06/2023
 35703 00005653 40                      	inc	ax ; cmp ax,-1
 35704 00005654 7408                    	jz	short PLhCmd2 ; 0FFFFh -> 0
 35705 00005656 48                      	dec	ax ; cmp ax,0
 35706 00005657 7504                    	jnz	short PLhCmd1 ; 1 -> 0
 35707                                  	; ax = 0
 35708                                  
 35709 00005659 89D3                    	mov	bx,dx
 35710                                  	; 14/04/2023
 35711                                  	;call	LhCopyFilename
 35712                                  	;; 13/04/2023
 35713                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35714                                  	;;jmp	short PLhCmd2
 35715                                  	;retn
 35716                                  	; 14/04/2023
 35717 0000565B EB02                    	jmp	short LhCopyFilename
 35718                                  PLhCmd1:
 35719 0000565D F9                      	stc
 35720                                  PLhCmd2:
 35721 0000565E C3                      	retn
 35722                                  
 35723                                  ; ---------------------------------------------------------------------------
 35724                                  
 35725                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35726                                  
 35727                                  ; ---------------------------------------------------------------------------
 35728                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35729                                  ; ---------------------------------------------------------------------------
 35730                                  
 35731                                  	; 13/04/2023
 35732                                  	; MSDOS 5.0 COMMAND.COM only !
 35733                                  	; (Procedure names are not from original Microsoft source code!)
 35734                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35735                                  ;set_strategy:
 35736                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35737                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35738                                  	;		; AL = function code: get allocation strategy
 35739                                  	;mov	bx,ax
 35740                                  	;or	bx,80h
 35741                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35742                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35743                                  	;		; AL = function code: set allocation strategy
 35744                                  	;retn
 35745                                  
 35746                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35747                                  ;set_umblink:
 35748                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35749                                  	;mov	bx,1
 35750                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35751                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35752                                  	;retn
 35753                                  
 35754                                  ; ---------------------------------------------------------------------------
 35755                                  
 35756                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35757                                  ;
 35758                                  ;	ENTRY	ds:si points at primary argument (filename)
 35759                                  ;
 35760                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35761                                  ;				already contain an appropriate error number.
 35762                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35763                                  ;				points to first character (most likely space)
 35764                                  ;				after filename.
 35765                                  ;
 35766                                  ;	USED	ax, si
 35767                                  ;
 35768                                  ;	EFFECTS
 35769                                  ;		ExecPath contains the filename
 35770                                  ;
 35771                                  ; If there are any wildcards in the filename, then we have an error
 35772                                  ; ---------------------------------------------------------------------------
 35773                                  
 35774                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35775                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35776                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35777                                  LhCopyFilename:
 35778 0000565F 1E                      	push	ds
 35779 00005660 56                      	push	si
 35780 00005661 57                      	push	di
 35781 00005662 C57704                  	lds	si,[bx+4]
 35782 00005665 BF[CD89]                	mov	di,EXECPATH
 35783                                  lhcpfn1:
 35784 00005668 AC                      	lodsb
 35785 00005669 3C2A                    	cmp	al,2Ah ; '*'
 35786 0000566B 740D                    	jz	short lhfilerr
 35787 0000566D 3C3F                    	cmp	al,3Fh ; '?'
 35788 0000566F 7409                    	jz	short lhfilerr
 35789 00005671 AA                      	stosb
 35790 00005672 08C0                    	or	al,al
 35791 00005674 75F2                    	jnz	short lhcpfn1
 35792                                  	; 14/04/2023
 35793                                  	; cf = 0
 35794                                  	;clc
 35795                                  lhfilerr2:
 35796 00005676 5F                      	pop	di
 35797 00005677 5E                      	pop	si
 35798 00005678 1F                      	pop	ds
 35799 00005679 C3                      	retn
 35800                                  lhfilerr:
 35801 0000567A BA[6681]                	mov	dx,LhInvFil_Ptr
 35802 0000567D F9                      	stc
 35803 0000567E EBF6                    	jmp	short lhfilerr2
 35804                                  
 35805                                  ; ---------------------------------------------------------------------------
 35806                                  	
 35807                                  	; 14/04/2023
 35808                                  	; 13/04/2023
 35809                                  	; MSDOS 5.0 COMMAND.COM only !
 35810                                  	; (Procedure name is not from original Microsoft source code!)
 35811                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35812                                  set_strategy:
 35813 00005680 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35814 00005683 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35815                                  			; AL = function code: get allocation strategy
 35816 00005685 89C3                    	mov	bx,ax
 35817 00005687 81CB8000                	or	bx,80h
 35818 0000568B B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35819 0000568E CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35820                                  			; AL = function code: set allocation strategy
 35821 00005690 C3                      	retn
 35822                                  
 35823                                  ; ---------------------------------------------------------------------------
 35824                                  
 35825                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35826                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35827                                  	; MSDOS 5.0 COMMAND.COM only !
 35828                                  	; (Procedure name is not from original Microsoft source code!)
 35829                                  SkipLhDelims:
 35830 00005691 BE8100                  	mov	si,81h
 35831 00005694 E845CF                  	call	scanoff
 35832                                  stfn1:
 35833 00005697 AC                      	lodsb
 35834 00005698 E849CF                  	call	DELIM
 35835 0000569B 740A                    	jz	short stfn2
 35836 0000569D 3C0D                    	cmp	al,0Dh
 35837 0000569F 7406                    	jz	short stfn2
 35838 000056A1 3A06[A98A]              	cmp	al,[SWITCHAR]
 35839 000056A5 75F0                    	jnz	short stfn1
 35840                                  stfn2:
 35841 000056A7 4E                      	dec	si
 35842 000056A8 C3                      	retn
 35843                                  
 35844                                  ; ---------------------------------------------------------------------------
 35845                                  
 35846                                  ;***	SetupCmdLine -- prepare command line for the program
 35847                                  ;
 35848                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35849                                  ;
 35850                                  ;	EXIT	None
 35851                                  ;
 35852                                  ;	USED
 35853                                  ;
 35854                                  ;	EFFECTS		
 35855                                  ;		The rest of the command line following the pgm name is 
 35856                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35857                                  ;	and a new command line length is put in
 35858                                  ; ---------------------------------------------------------------------------
 35859                                  
 35860                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35862                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35863                                  SetupCmdLine:
 35864                                  	;mov	di,81h
 35865 000056A9 BF8100                  	mov	di,iCmdLine
 35866 000056AC 30C9                    	xor	cl,cl
 35867 000056AE FEC9                    	dec	cl			;just CR means count = 0
 35868                                  SetCmdL1:
 35869 000056B0 AC                      	lodsb
 35870 000056B1 AA                      	stosb
 35871 000056B2 FEC1                    	inc	cl			;update count
 35872                                  	; 14/04/2023
 35873                                  	; * ; MSDOS 6.0 only !
 35874                                  	;or	al,al	; *
 35875                                  	;jz	short SetCmdL2 ; *
 35876 000056B4 3C0D                    	cmp	al,0Dh			;carriage return?
 35877 000056B6 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35878                                  SetCmdL2:
 35879 000056B8 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35880 000056BD C3                      	retn
 35881                                  
 35882                                  ; ---------------------------------------------------------------------------
 35883                                  
 35884                                  ;***	LhSetupErrMsg -- Sets up error messages
 35885                                  ;
 35886                                  ;	ENTRY	ax = error message number
 35887                                  ;
 35888                                  ;	EXIT	None
 35889                                  ;
 35890                                  ;	USED	dx
 35891                                  ;
 35892                                  ;	EFFECTS
 35893                                  ;		Everything setup to display error message
 35894                                  ; ---------------------------------------------------------------------------
 35895                                  	
 35896                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35897                                  LhSetupErrMsg:
 35898 000056BE C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35899 000056C3 BA[FC7E]                	mov	dx,extend_buf_ptr
 35900 000056C6 A3[FC7E]                	mov	[extend_buf_ptr],ax
 35901 000056C9 C3                      	retn
 35902                                  
 35903                                  ; ---------------------------------------------------------------------------
 35904                                  
 35905                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35906                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35907                                  	; MSDOS 5.0 COMMAND.COM only !
 35908                                  	; (Procedure name is not from original Microsoft source code!)
 35909                                  check_umblink:
 35910 000056CA B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35911 000056CD CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35912                                  			 ; AL = function code: get allocation strategy
 35913 000056CF 88C3                    	mov	bl,al
 35914 000056D1 B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35915 000056D4 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35916                                  			; AL = function code: (DOS 5beta) get UMB link state
 35917 000056D6 88C7                    	mov	bh,al
 35918 000056D8 93                      	xchg	ax,bx
 35919 000056D9 D0C0                    	rol	al,1
 35920 000056DB 2401                    	and	al,1
 35921 000056DD D0E4                    	shl	ah,1
 35922 000056DF 08E0                    	or	al,ah
 35923 000056E1 C3                      	retn
 35924                                  
 35925                                  ; ---------------------------------------------------------------------------
 35926                                  
 35927                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35928                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35929                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35930                                  HideUMBs:
 35931 000056E2 1E                      	push	ds
 35932 000056E3 E8E4FF                  	call	check_umblink
 35933 000056E6 8E1E[A58A]              	mov	ds,[RESSEG]
 35934 000056EA A2[2004]                	mov	[fInHigh],al
 35935 000056ED 800E[2004]80            	or	byte [fInHigh],80h
 35936 000056F2 1F                      	pop	ds
 35937 000056F3 E88AFF                  	call	set_strategy
 35938                                  	;call	set_umblink
 35939                                  	;retn
 35940                                  	; 14/04/023
 35941                                  	;jmp	short set_umblink
 35942                                  
 35943                                  ; ---------------------------------------------------------------------------
 35944                                  
 35945                                  	; 14/04/2023
 35946                                  	; 13/04/2023
 35947                                  	; MSDOS 5.0 COMMAND.COM only !
 35948                                  	; (Procedure name is not from original Microsoft source code!)
 35949                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35950                                  set_umblink:
 35951 000056F6 B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35952 000056F9 BB0100                  	mov	bx,1
 35953 000056FC CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35954                                  			; AL = function code: (DOS 5beta) set UMB link state
 35955 000056FE C3                      	retn
 35956                                  
 35957                                  ; ---------------------------------------------------------------------------
 35958                                  
 35959                                  ;***	SetupPath -- Do path search for the file to be executed
 35960                                  ;
 35961                                  ;	ENTRY	None
 35962                                  ;
 35963                                  ;	EXIT	Carry set if file not found or not executable file
 35964                                  ;
 35965                                  ;	EFFECTS
 35966                                  ;		ExecPath contains the full path of the file to be executed
 35967                                  ; ---------------------------------------------------------------------------
 35968                                  
 35969                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35970                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35971                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35972                                  SetupPath:
 35973                                  
 35974                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35975                                  ;because the path search routine that we are about to invoke expects the
 35976                                  ;filename to search for to be argv[0].
 35977                                  ;
 35978                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 35979                                  ;over it by doing the whole move again (smaller, of course, this time).
 35980                                  
 35981                                  	;mov	ax,arg.argvcnt		;total number of arguments
 35982                                  	; 14/04/2023
 35983                                  	;mov	ax,[ARG_ARGVCNT]
 35984 000056FF A1[7090]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 35985                                  
 35986 00005702 48                      	dec	ax			;less one - skip "LoadHigh"
 35987                                  	;mov	bx,SIZE Argv_ele
 35988 00005703 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 35989                                  	;mov	bx,11
 35990 00005706 F7E3                    	mul	bx			;dx:ax = size of argument lists
 35991                                  
 35992                                  	; 14/04/2023
 35993 00005708 89C1                    	mov	cx,ax			;size to move
 35994                                  
 35995                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 35996                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 35997 0000570A BF[B08D]                	mov	di,ARG	
 35998 0000570D 89FE                    	mov	si,di			;
 35999                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 36000 0000570F 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 36001                                  	
 36002                                  	; 14/04/2023
 36003                                  	;mov	cx,ax
 36004                                  
 36005 00005712 FC                      	cld
 36006 00005713 F3A4                    	rep	movsb			;Move the argument list
 36007                                  	
 36008                                  	;dec	arg.argvcnt		;Fake one less argument, and
 36009                                  	;dec	word [ARG_ARGVCNT]
 36010 00005715 FF0E[7090]              	dec	word [ARG+ARG_UNIT.argvcnt]
 36011                                  	
 36012                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 36013                                  
 36014 00005719 E844DA                  	call	path_search		;look in the path
 36015                                  
 36016                                  ;ax = 0, no file found
 36017                                  ;ax < 4, batch file found -- cant be executed
 36018                                  ;ax = 4,8 => .com or .exe file found
 36019                                  
 36020 0000571C 09C0                    	or	ax,ax			;any file found?
 36021 0000571E 740B                    	jz	short no_exec_file	;no, error
 36022                                  
 36023 00005720 83F804                  	cmp	ax,4			;executable file?
 36024                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 36025                                  	;clc
 36026                                  	;retn
 36027                                  	; 14/04/2023
 36028 00005723 7201                    	jb	short no_exec_bat
 36029 00005725 C3                      	retn 
 36030                                  
 36031                                  no_exec_bat:
 36032 00005726 BA[6381]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 36033 00005729 EB06                    	jmp	short lhsp_errret	;return error; M016
 36034                                  
 36035                                  no_exec_file:
 36036 0000572B B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 36037 0000572E E88DFF                  	call	LhSetupErrMsg		;setup error message
 36038                                  lhsp_errret:				; M016
 36039 00005731 F9                      	stc
 36040 00005732 C3                      	retn
 36041                                  
 36042                                  ;============================================================================
 36043                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 36044                                  ;============================================================================
 36045                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36046                                  
 36047                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 36048                                  
 36049                                  ; ---------------------------------------------------------------------------
 36050                                  ; Class 3 message table/structure
 36051                                  ; ---------------------------------------------------------------------------
 36052                                  
 36053                                  $M_CLASS_3_STRUC:
 36054 00005733 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 36055 00005734 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 36056 00005736 A2                      	db 162			; Total number of messages
 36057                                  $M_ID_3_1:
 36058                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 36059 00005737 FC03                    	dw 1020			; Message Number = 1020
 36060 00005739 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 36061                                  $M_ID_3_2:
 36062 0000573B F703                    	dw 1015			; Message Number = 1015
 36063 0000573D 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 36064                                  $M_ID_3_3:	; 26/04/2023
 36065 0000573F EC03B402                	dw 1004,MSG_1004-$ ; 692
 36066 00005743 0204CA02                	dw 1026,MSG_1026-$ ; 714
 36067 00005747 0704DA02                	dw 1031,MSG_1031-$ ; 730
 36068 0000574B 0B04E502                	dw 1035,MSG_1035-$ ; 741
 36069 0000574F 2604F002                	dw 1062,MSG_1062-$ ; 752
 36070 00005753 0404FB02                	dw 1028,MSG_1028-$ ; 763
 36071 00005757 15041903                	dw 1045,MSG_1045-$ ; 793
 36072 0000575B 11043203                	dw 1041,MSG_1041-$ ; 818
 36073 0000575F 12045003                	dw 1042,MSG_1042-$ ; 848
 36074                                  $M_ID_3_12:
 36075 00005763 13046703                	dw 1043,MSG_1043-$ ; 871
 36076 00005767 EA038303                	dw 1002,MSG_1002-$ ; 899
 36077 0000576B EB03A703                	dw 1003,MSG_1003-$ ; 935
 36078 0000576F EF03BF03                	dw 1007,MSG_1007-$ ; 959
 36079 00005773 F003D603                	dw 1008,MSG_1008-$ ; 982
 36080 00005777 F103E803                	dw 1009,MSG_1009-$ ; 1000
 36081 0000577B F203F903                	dw 1010,MSG_1010-$ ; 1017
 36082 0000577F F3031504                	dw 1011,MSG_1011-$ ; 1045
 36083 00005783 F6032C04                	dw 1014,MSG_1014-$ ; 1068
 36084 00005787 F8033904                	dw 1016,MSG_1016-$ ; 1081
 36085 0000578B F9035F04                	dw 1017,MSG_1017-$ ; 1119
 36086 0000578F FA038004                	dw 1018,MSG_1018-$ ; 1152
 36087                                  $M_ID_3_24:
 36088 00005793 FB039004                	dw 1019,MSG_1019-$ ; 1168
 36089 00005797 FD039804                	dw 1021,MSG_1021-$ ; 1176
 36090 0000579B FE03B204                	dw 1022,MSG_1022-$ ; 1202
 36091 0000579F FF03D504                	dw 1023,MSG_1023-$ ; 1237
 36092 000057A3 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 36093 000057A7 01041005                	dw 1025,MSG_1025-$ ; 1296
 36094 000057AB 03042405                	dw 1027,MSG_1027-$ ; 1316
 36095 000057AF 05044105                	dw 1029,MSG_1029-$ ; 1345
 36096 000057B3 06044F05                	dw 1030,MSG_1030-$ ; 1359
 36097 000057B7 08045A05                	dw 1032,MSG_1032-$ ; 1370
 36098 000057BB 09046E05                	dw 1033,MSG_1033-$ ; 1390
 36099 000057BF 0A048005                	dw 1034,MSG_1034-$ ; 1408
 36100 000057C3 0C049205                	dw 1036,MSG_1036-$ ; 1426
 36101 000057C7 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 36102 000057CB 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 36103 000057CF 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 36104                                  $M_ID_3_40:
 36105 000057D3 1004F805                	dw 1040,MSG_1040-$ ; 1528
 36106 000057D7 14040906                	dw 1044,MSG_1044-$ ; 1545
 36107 000057DB 16041906                	dw 1046,MSG_1046-$ ; 1561
 36108 000057DF 17044C06                	dw 1047,MSG_1047-$ ; 1612
 36109 000057E3 18046106                	dw 1048,MSG_1048-$ ; 1633
 36110 000057E7 19046F06                	dw 1049,MSG_1049-$ ; 1647
 36111 000057EB 1A047506                	dw 1050,MSG_1050-$ ; 1653
 36112 000057EF 1B049006                	dw 1051,MSG_1051-$ ; 1680
 36113 000057F3 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 36114 000057F7 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 36115 000057FB 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 36116                                  $M_ID_3_51:
 36117 000057FF 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 36118 00005803 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 36119 00005807 21040A07                	dw 1057,MSG_1057-$ ; 1802
 36120 0000580B 23041307                	dw 1059,MSG_1059-$ ; 1811
 36121 0000580F 24041407                	dw 1060,MSG_1060-$ ; 1812
 36122 00005813 25041407                	dw 1061,MSG_1061-$ ; 1812
 36123 00005817 27042A07                	dw 1063,MSG_1063-$ ; 1834
 36124 0000581B 28042907                	dw 1064,MSG_1064-$ ; 1833
 36125 0000581F 29042807                	dw 1065,MSG_1065-$ ; 1832
 36126 00005823 2A042707                	dw 1066,MSG_1066-$ ; 1831
 36127 00005827 2B042607                	dw 1067,MSG_1067-$ ; 1830
 36128 0000582B 2C042407                	dw 1068,MSG_1068-$ ; 1828
 36129 0000582F 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 36130 00005833 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 36131 00005837 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 36132 0000583B 30042907                	dw 1072,MSG_1072-$ ; 1833
 36133                                  $M_ID_3_67:
 36134 0000583F 31042E07                	dw 1073,MSG_1073-$ ; 1838
 36135 00005843 32043307                	dw 1074,MSG_1074-$ ; 1843
 36136 00005847 33043807                	dw 1075,MSG_1075-$ ; 1848
 36137 0000584B 34043A07                	dw 1076,MSG_1076-$ ; 1850
 36138 0000584F 35043907                	dw 1077,MSG_1077-$ ; 1849
 36139 00005853 36043D07                	dw 1078,MSG_1078-$ ; 1853
 36140 00005857 37045407                	dw 1079,MSG_1079-$ ; 1876
 36141 0000585B 38045B07                	dw 1080,MSG_1080-$ ; 1883
 36142 0000585F 39046D07                	dw 1081,MSG_1081-$ ; 1901
 36143 00005863 3C049407                	dw 1084,MSG_1084-$ ; 1940
 36144 00005867 4204A007                	dw 1090,MSG_1090-$ ; 1952
 36145 0000586B 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 36146 0000586F 4404B407                	dw 1092,MSG_1092-$ ; 1972
 36147 00005873 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 36148 00005877 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 36149 0000587B 4704E807                	dw 1095,MSG_1095-$ ; 2024
 36150 0000587F 48040108                	dw 1096,MSG_1096-$ ; 2049
 36151                                  $M_ID_3_84:
 36152 00005883 B0042E08                	dw 1200,MSG_1200-$ ; 2094
 36153 00005887 14052B08                	dw 1300,MSG_1300-$ ; 2091
 36154 0000588B 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 36155 0000588F 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 36156 00005893 3C055709                	dw 1340,MSG_1340-$ ; 2391
 36157 00005897 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 36158 0000589B 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 36159 0000589F 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 36160 000058A3 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 36161 000058A7 7905420B                	dw 1401,MSG_1401-$ ; 2882
 36162 000058AB 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 36163 000058AF 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 36164 000058B3 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 36165 000058B7 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 36166 000058BB A005630D                	dw 1440,MSG_1440-$ ; 3427
 36167 000058BF A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 36168                                  $M_ID_3_100:
 36169 000058C3 B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 36170 000058C7 B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 36171 000058CB B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 36172 000058CF C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 36173 000058D3 C905D90F                	dw 1481,MSG_1481-$ ; 4057
 36174 000058D7 CA053310                	dw 1482,MSG_1482-$ ; 4147
 36175 000058DB CB059110                	dw 1483,MSG_1483-$ ; 4241
 36176 000058DF CC050811                	dw 1484,MSG_1484-$ ; 4360
 36177 000058E3 CD05C411                	dw 1485,MSG_1485-$ ; 4548
 36178 000058E7 CE055C12                	dw 1486,MSG_1486-$ ; 4700
 36179 000058EB CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 36180 000058EF D0055213                	dw 1488,MSG_1488-$ ; 4946
 36181                                  $M_ID_3_112:
 36182 000058F3 DC05E113                	dw 1500,MSG_1500-$ ; 5089
 36183 000058F7 F0051C14                	dw 1520,MSG_1520-$ ; 5148
 36184 000058FB 04065614                	dw 1540,MSG_1540-$ ; 5206
 36185 000058FF 0506B014                	dw 1541,MSG_1541-$ ; 5296
 36186 00005903 06061815                	dw 1542,MSG_1542-$ ; 5400
 36187 00005907 18065015                	dw 1560,MSG_1560-$ ; 5456
 36188 0000590B 19068415                	dw 1561,MSG_1561-$ ; 5508
 36189 0000590F 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 36190 00005913 1B062916                	dw 1563,MSG_1563-$ ; 5673
 36191 00005917 1C065016                	dw 1564,MSG_1564-$ ; 5712
 36192 0000591B 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 36193 0000591F 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 36194 00005923 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 36195 00005927 20065A17                	dw 1568,MSG_1568-$ ; 5978
 36196 0000592B 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 36197                                  $M_ID_3_127:
 36198 0000592F 4006E717                	dw 1600,MSG_1600-$ ; 6119
 36199 00005933 41060018                	dw 1601,MSG_1601-$ ; 6144
 36200 00005937 42065018                	dw 1602,MSG_1602-$ ; 6224
 36201 0000593B 54069A18                	dw 1620,MSG_1620-$ ; 6298
 36202 0000593F 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 36203 00005943 56066C19                	dw 1622,MSG_1622-$ ; 6508
 36204 00005947 6806B419                	dw 1640,MSG_1640-$ ; 6580
 36205 0000594B 6906E519                	dw 1641,MSG_1641-$ ; 6629
 36206 0000594F 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 36207 00005953 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 36208 00005957 A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 36209 0000595B B806781B                	dw 1720,MSG_1720-$ ; 7032
 36210 0000595F CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 36211 00005963 CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 36212 00005967 E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 36213 0000596B F406D71C                	dw 1780,MSG_1780-$ ; 7383
 36214                                  $M_ID_3_143:
 36215 0000596F 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 36216 00005973 0907891D                	dw 1801,MSG_1801-$ ; 7561
 36217 00005977 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 36218 0000597B 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 36219 0000597F 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 36220 00005983 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 36221 00005987 4507461F                	dw 1861,MSG_1861-$ ; 8006
 36222 0000598B 4607891F                	dw 1862,MSG_1862-$ ; 8073
 36223 0000598F 47070320                	dw 1863,MSG_1863-$ ; 8195
 36224 00005993 4807A220                	dw 1864,MSG_1864-$ ; 8354
 36225 00005997 49070521                	dw 1865,MSG_1865-$ ; 8453
 36226 0000599B 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 36227 0000599F 5807D021                	dw 1880,MSG_1880-$ ; 8656
 36228 000059A3 59074422                	dw 1881,MSG_1881-$ ; 8772
 36229 000059A7 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 36230 000059AB 5B071123                	dw 1883,MSG_1883-$ ; 8977
 36231 000059AF 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 36232 000059B3 8007C423                	dw 1920,MSG_1920-$ ; 9156
 36233 000059B7 8107F023                	dw 1921,MSG_1921-$ ; 9200
 36234                                  $M_ID_3_162:
 36235 000059BB 8207                    	dw 1922			; Message Number = 1922
 36236 000059BD 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 36237                                  
 36238                                  ; ---------------------------------------------------------------------------
 36239                                  ; Class 3 messages
 36240                                  ; ---------------------------------------------------------------------------
 36241                                  	
 36242                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36243                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 36244                                  
 36245                                  MSG_1020:	; COMMON4
 36246 000059BF 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 36247 000059C0 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 36247 000059C9 667265650D0A       
 36248                                  MSG_1015:	; COMMON18
 36249 000059CF 23                      	db 35
 36250 000059D0 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 36250 000059D9 6F7420626520636F70-
 36250 000059E2 696564206F6E746F20-
 36250 000059EB 697473656C660D0A   
 36251                                  MSG_1004:	; COMMON20
 36252 000059F3 19                      	db 25
 36253 000059F4 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 36253 000059FD 656E74206469736B20-
 36253 00005A06 73706163650D0A     
 36254                                  MSG_1026:	; COMMON22
 36255 00005A0D 13                      	db 19
 36256 00005A0E 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 36256 00005A17 6F646520706167650D-
 36256 00005A20 0A                 
 36257                                  MSG_1031:	; COMMON23
 36258 00005A21 0E                      	db 14
 36259 00005A22 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 36259 00005A2B 6174650D0A         
 36260                                  MSG_1035:	; COMMON24
 36261 00005A30 0E                      	db 14
 36262 00005A31 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 36262 00005A3A 696D650D0A         
 36263                                  MSG_1062:	; COMMON25
 36264 00005A3F 0E                      	db 14
 36265 00005A40 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 36265 00005A49 6174680D0A         
 36266                                  MSG_1028:	; COMMON28
 36267 00005A4E 21                      	db 33
 36268 00005A4F 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 36268 00005A58 206B657920746F2063-
 36268 00005A61 6F6E74696E7565202E-
 36268 00005A6A 202E202E0D0A       
 36269                                  MSG_1045:	; COMMON32
 36270 00005A70 1C                      	db 28
 36271 00005A71 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 36271 00005A7A 206372656174652064-
 36271 00005A83 69726563746F72790D-
 36271 00005A8C 0A                 
 36272                                  MSG_1041:	; COMMON33
 36273 00005A8D 21                      	db 33
 36274 00005A8E 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 36274 00005A97 206472697665202531-
 36274 00005AA0 20686173206E6F206C-
 36274 00005AA9 6162656C0D0A       
 36275                                  MSG_1042:	; COMMON34
 36276 00005AAF 1A                      	db 26
 36277 00005AB0 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 36277 00005AB9 206472697665202531-
 36277 00005AC2 2069732025320D0A   
 36278                                  MSG_1043:	; COMMON36
 36279 00005ACA 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 36280 00005ACB 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 36280 00005AD4 7269616C204E756D62-
 36280 00005ADD 65722069732025312D-
 36280 00005AE6 25320D0A           
 36281                                  MSG_1002:
 36282 00005AEA 27                              db 39
 36283 00005AEB 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 36283 00005AF4 2066696C65206E616D-
 36283 00005AFD 65206F722066696C65-
 36283 00005B06 206E6F7420666F756E-
 36283 00005B0F 640D0A             
 36284                                  MSG_1003:
 36285 00005B12 1B                      	db 27
 36286 00005B13 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 36286 00005B1C 617468206F72206669-
 36286 00005B25 6C65206E616D650D0A 
 36287                                  MSG_1007:
 36288 00005B2E 1A                      	db 26
 36289 00005B2F 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 36289 00005B38 7669726F6E6D656E74-
 36289 00005B41 2073706163650D0A   
 36290                                  MSG_1008:
 36291 00005B49 15                      	db 21
 36292 00005B4A 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 36292 00005B53 74696F6E206572726F-
 36292 00005B5C 720D0A             
 36293                                  MSG_1009:
 36294 00005B5F 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 36295 00005B60 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 36295 00005B69 65206D697373696E67-
 36295 00005B72 0D0A               
 36296                                  MSG_1010:
 36297 00005B74 1F                      	db 31
 36298 00005B75 0D0A                    	db 0Dh,0Ah
 36299 00005B77 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 36299 00005B80 736B20776974682062-
 36299 00005B89 617463682066696C65-
 36299 00005B92 0D0A               
 36300                                  MSG_1011:
 36301 00005B94 1A                      	db 26
 36302 00005B95 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 36302 00005B9E 6E64206F722066696C-
 36302 00005BA7 65206E616D650D0A   
 36303                                  MSG_1014:	; EXTEND5
 36304 00005BAF 10                      	db 16
 36305 00005BB0 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 36305 00005BB9 6E696564200D0A     
 36306                                  MSG_1016:
 36307 00005BC0 29                      	db 41
 36308 00005BC1 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 36308 00005BCA 662064657374696E61-
 36308 00005BD3 74696F6E206C6F7374-
 36308 00005BDC 206265666F72652063-
 36308 00005BE5 6F70790D0A         
 36309                                  MSG_1017:
 36310 00005BEA 24                      	db 36
 36311 00005BEB 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 36311 00005BF4 696C656E616D65206F-
 36311 00005BFD 722066696C65206E6F-
 36311 00005C06 7420666F756E640D0A 
 36312                                  MSG_1018:
 36313 00005C0F 13                      	db 19
 36314 00005C10 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 36314 00005C19 2920636F706965640D-
 36314 00005C22 0A                 
 36315                                  MSG_1019:
 36316 00005C23 0B                      	db 11
 36317 00005C24 25312066696C652873-     	db '%1 file(s) '
 36317 00005C2D 2920               
 36318                                  MSG_1021:	; EXTEND15
 36319 00005C2F 1D                      	db 29
 36320 00005C30 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 36320 00005C39 726976652073706563-
 36320 00005C42 696669636174696F6E-
 36320 00005C4B 0D0A               
 36321                                  MSG_1022:
 36322 00005C4D 26                      	db 38
 36323 00005C4E 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 36323 00005C57 202531206E6F742070-
 36323 00005C60 726570617265642066-
 36323 00005C69 6F722073797374656D-
 36323 00005C72 0D0A               
 36324                                  MSG_1023:
 36325 00005C74 2B                      	db 43
 36326 00005C75 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 36326 00005C7E 202531206E6F742070-
 36326 00005C87 726570617265642066-
 36326 00005C90 6F7220616C6C206465-
 36326 00005C99 76696365730D0A     
 36327                                  MSG_1024:
 36328 00005CA0 16                      	db 22
 36329 00005CA1 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 36329 00005CAA 646520706167653A20-
 36329 00005CB3 25310D0A           
 36330                                  MSG_1025:
 36331 00005CB7 17                      	db 23
 36332 00005CB8 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 36332 00005CC1 6F7420696E7374616C-
 36332 00005CCA 6C65640D0A         
 36333                                  MSG_1027:
 36334 00005CCF 20                      	db 32
 36335 00005CD0 43757272656E742064-     	db 'Current drive is no longer valid'
 36335 00005CD9 72697665206973206E-
 36335 00005CE2 6F206C6F6E67657220-
 36335 00005CEB 76616C6964         
 36336                                  MSG_1029:
 36337 00005CF0 11                      	db 17
 36338 00005CF1 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 36338 00005CFA 20666F756E640D0A   
 36339                                  MSG_1030:
 36340 00005D02 0E                      	db 14
 36341 00005D03 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 36341 00005D0C 726F720D0A         
 36342                                  MSG_1032:
 36343 00005D11 17                      	db 23
 36344 00005D12 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 36344 00005D1B 617465206973202531-
 36344 00005D24 2025320D0A         
 36345                                  MSG_1033:
 36346 00005D29 15                      	db 21
 36347 00005D2A 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 36347 00005D33 576564546875467269-
 36347 00005D3C 536174             
 36348                                  MSG_1034:
 36349 00005D3F 15                      	db 21
 36350 00005D40 456E746572206E6577-     	db 'Enter new date (%1): '
 36350 00005D49 206461746520282531-
 36350 00005D52 293A20             
 36351                                  MSG_1036:
 36352 00005D55 14                      	db 20
 36353 00005D56 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 36353 00005D5F 696D65206973202531-
 36353 00005D68 0D0A               
 36354                                  MSG_1037:
 36355 00005D6A 10                      	db 16
 36356 00005D6B 456E746572206E6577-     	db 'Enter new time: '
 36356 00005D74 2074696D653A20     
 36357                                  MSG_1038:
 36358 00005D7B 12                              db 18
 36359 00005D7C 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 36359 00005D85 74652028592F4E293F 
 36360                                  MSG_1039:
 36361 00005D8E 3C                              db 60
 36362 00005D8F 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 36362 00005D98 20696E206469726563-
 36362 00005DA1 746F72792077696C6C-
 36362 00005DAA 2062652064656C6574-
 36362 00005DB3 6564210D0A         
 36363 00005DB8 41726520796F752073-     	db 'Are you sure (Y/N)?'
 36363 00005DC1 7572652028592F4E29-
 36363 00005DCA 3F                 
 36364                                  MSG_1040:
 36365 00005DCB 14                      	db 20
 36366 00005DCC 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 36366 00005DD5 7273696F6E2025312E-
 36366 00005DDE 2532               
 36367                                  MSG_1044:
 36368 00005DE0 13                      	db 19
 36369 00005DE1 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 36369 00005DEA 69726563746F72790D-
 36369 00005DF3 0A                 
 36370                                  MSG_1046:
 36371 00005DF4 36                      	db 54
 36372 00005DF5 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 36372 00005DFE 6174682C206E6F7420-
 36372 00005E07 6469726563746F7279-
 36372 00005E10 2C0D0A             
 36373 00005E13 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 36373 00005E1C 6F7279206E6F742065-
 36373 00005E25 6D7074790D0A       
 36374                                  MSG_1047:
 36375 00005E2B 18                      	db 24
 36376 00005E2C 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 36376 00005E35 696679204F4E206F72-
 36376 00005E3E 204F46460D0A       
 36377                                  MSG_1048:
 36378 00005E44 11                      	db 17
 36379 00005E45 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 36379 00005E4E 206F662025310D0A   
 36380                                  MSG_1049:
 36381 00005E56 09                      	db 9
 36382 00005E57 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 36383                                  MSG_1050:
 36384 00005E60 1E                      	db 30
 36385 00005E61 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 36385 00005E6A 7269766520696E2073-
 36385 00005E73 656172636820706174-
 36385 00005E7C 680D0A             
 36386                                  MSG_1051:
 36387 00005E7F 10                      	db 16
 36388 00005E80 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 36388 00005E89 65766963650D0A     
 36389                                  MSG_1052:
 36390 00005E90 16                      	db 22
 36391 00005E91 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 36391 00005E9A 74206265206E657374-
 36391 00005EA3 65640D0A           
 36392                                  MSG_1053:
 36393 00005EA7 25                      	db 37
 36394 00005EA8 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 36394 00005EB1 6174652066696C6520-
 36394 00005EBA 6572726F7220647572-
 36394 00005EC3 696E6720706970650D-
 36394 00005ECC 0A                 
 36395                                  MSG_1054:
 36396 00005ECD 26                      	db 38
 36397 00005ECE 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 36397 00005ED7 2062696E6172792072-
 36397 00005EE0 656164732066726F6D-
 36397 00005EE9 206120646576696365-
 36397 00005EF2 0D0A               
 36398                                  
 36399                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 36400                                  MSG_1055:
 36401 00005EF4 0D                      	db 13
 36402 00005EF5 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 36402 00005EFE 25310D0A           
 36403                                  MSG_1056:
 36404 00005F02 0E                      	db 14
 36405 00005F03 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 36405 00005F0C 2025310D0A         
 36406                                  MSG_1057:
 36407 00005F11 0C                      	db 12
 36408 00005F12 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 36408 00005F1B 310D0A             
 36409                                  MSG_1059:
 36410 00005F1E 04                      	db 4
 36411 00005F1F 6F666600                	db 'off',0
 36412                                  MSG_1060:
 36413 00005F23 03                      	db 3
 36414 00005F24 6F6E00                  	db 'on',0
 36415                                  MSG_1061:
 36416 00005F27 19                      	db 25
 36417 00005F28 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 36417 00005F31 74696E6720746F2064-
 36417 00005F3A 65766963650D0A     
 36418                                  MSG_1063:
 36419 00005F41 02                      	db 2
 36420 00005F42 2531                    	db '%1'
 36421                                  MSG_1064:
 36422 00005F44 02                      	db 2
 36423 00005F45 2531                    	db '%1'
 36424                                  MSG_1065:
 36425 00005F47 02                      	db 2
 36426 00005F48 2531                    	db '%1'
 36427                                  MSG_1066:
 36428 00005F4A 02                      	db 2
 36429 00005F4B 2531                    	db '%1'
 36430                                  MSG_1067:
 36431 00005F4D 01                      	db 1
 36432 00005F4E 09                      	db 9
 36433                                  MSG_1068:
 36434 00005F4F 0A                      	db 10
 36435 00005F50 203C4449523E202020-     	db ' <DIR>    '
 36435 00005F59 20                 
 36436                                  MSG_1069:
 36437 00005F5A 03                      	db 3
 36438 00005F5B 082008                  	db 8, 20h, 8
 36439                                  MSG_1070:	; CRLF
 36440 00005F5E 02                      	db 2
 36441 00005F5F 0D                      	db 0Dh
 36442 00005F60 0A                      	db 0Ah
 36443                                  MSG_1071:
 36444 00005F61 02                      	db 2
 36445 00005F62 2531                    	db '%1'
 36446                                  MSG_1072:
 36447 00005F64 08                      	db 8
 36448 00005F65 6D6D2D64642D7979        	db 'mm-dd-yy'
 36449                                  MSG_1073:
 36450 00005F6D 08                      	db 8
 36451 00005F6E 64642D6D6D2D7979        	db 'dd-mm-yy'
 36452                                  MSG_1074:
 36453 00005F76 08                      	db 8
 36454 00005F77 79792D6D6D2D6464        	db 'yy-mm-dd'
 36455                                  MSG_1075:
 36456 00005F7F 05                      	db 5
 36457 00005F80 2531202532              	db '%1 %2'
 36458                                  MSG_1076:
 36459 00005F85 02                      	db 2
 36460 00005F86 2531                    	db '%1'
 36461                                  MSG_1077:
 36462 00005F88 07                      	db 7
 36463 00005F89 20253120202532          	db ' %1  %2'
 36464                                  MSG_1078:
 36465 00005F90 1A                      	db 26
 36466 00005F91 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 36466 00005F9A 20616C726561647920-
 36466 00005FA3 6578697374730D0A   
 36467                                  MSG_1079:
 36468 00005FAB 0A                      	db 10
 36469 00005FAC 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 36469 00005FB5 0A                 
 36470                                  MSG_1080:
 36471 00005FB6 15                      	db 21
 36472 00005FB7 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 36472 00005FC0 6573206C6973746564-
 36472 00005FC9 3A0D0A             
 36473                                  MSG_1081:
 36474 00005FCC 2A                      	db 42
 36475 00005FCD 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 36475 00005FD6 63757272656420696E-
 36475 00005FDF 20656E7669726F6E6D-
 36475 00005FE8 656E74207661726961-
 36475 00005FF1 626C65290D0A       
 36476                                  MSG_1084:
 36477 00005FF7 0F                      	db 15
 36478 00005FF8 28636F6E74696E7569-     	db '(continuing %1)'
 36478 00006001 6E6720253129       
 36479                                  MSG_1090:
 36480 00006007 0D                      	db 13
 36481 00006008 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 36481 00006011 25310D0A           
 36482                                  MSG_1091:
 36483 00006015 0D                      	db 13
 36484 00006016 444F5320697320696E-     	db 'DOS is in ROM'
 36484 0000601F 20524F4D           
 36485                                  MSG_1092:
 36486 00006023 0D                      	db 13
 36487 00006024 444F5320697320696E-     	db 'DOS is in HMA'
 36487 0000602D 20484D41           
 36488                                  MSG_1093:
 36489 00006031 14                      	db 20
 36490 00006032 444F5320697320696E-     	db 'DOS is in low memory'
 36490 0000603B 206C6F77206D656D6F-
 36490 00006044 7279               
 36491                                  MSG_1094:
 36492 00006046 1C                      	db 28
 36493 00006047 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 36493 00006050 616468696768206261-
 36493 00006059 7463682066696C650D-
 36493 00006062 0A                 
 36494                                  MSG_1095:
 36495 00006063 1C                      	db 28
 36496 00006064 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 36496 0000606D 20496E76616C696420-
 36496 00006076 66696C656E616D650D-
 36496 0000607F 0A                 
 36497                                  MSG_1096:
 36498 00006080 30                      	db 48
 36499 00006081 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 36499 0000608A 656E20737065636966-
 36499 00006093 69656420636F756E74-
 36499 0000609C 727920696E666F726D-
 36499 000060A5 6174696F6E2066696C-
 36499 000060AE 650D0A             
 36500                                  
 36501                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 36502                                  MSG_1200:
 36503 000060B1 00                      	db 0	; /? unimplemented
 36504                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 36505                                  MSG_1300:
 36506 000060B2 86                      	db 134
 36507 000060B3 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 36507 000060BC 6C6561727320657874-
 36507 000060C5 656E64656420435452-
 36507 000060CE 4C2B4320636865636B-
 36507 000060D7 696E672E0D0A       
 36508 000060DD 0D0A                    	db 0Dh,0Ah
 36509 000060DF 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 36509 000060E8 207C204F46465D0D0A 
 36510 000060F1 0D0A                    	db 0Dh,0Ah
 36511 000060F3 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 36511 000060FC 4B20776974686F7574-
 36511 00006105 206120706172616D65-
 36511 0000610E 74657220746F206469-
 36511 00006117 73706C617920746865-
 36511 00006120 2063757272656E7420-
 36511 00006129 425245414B20736574-
 36511 00006132 74696E672E0D0A     
 36512                                  MSG_1320:
 36513 00006139 3F                      	db 63
 36514 0000613A 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 36514 00006143 6F7220736574732074-
 36514 0000614C 686520616374697665-
 36514 00006155 20636F646520706167-
 36514 0000615E 65206E756D6265722E-
 36514 00006167 0D0A               
 36515 00006169 0D0A                    	db 0Dh,0Ah
 36516 0000616B 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 36516 00006174 5D0D0A             
 36517 00006177 0D0A                    	db 0Dh,0Ah
 36518                                  MSG_1321:
 36519 00006179 70                      	db 112
 36520 0000617A 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 36520 00006183 706563696669657320-
 36520 0000618C 6120636F6465207061-
 36520 00006195 6765206E756D626572-
 36520 0000619E 2E0D0A             
 36521 000061A1 0D0A                    	db 0Dh,0Ah
 36522 000061A3 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 36522 000061AC 20776974686F757420-
 36522 000061B5 6120706172616D6574-
 36522 000061BE 657220746F20646973-
 36522 000061C7 706C61792074686520-
 36522 000061D0 61637469766520636F-
 36522 000061D9 64652070616765206E-
 36522 000061E2 756D6265722E0D0A   
 36523                                  MSG_1340:
 36524 000061EA 5B                      	db 91
 36525 000061EB 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 36525 000061F4 746865206E616D6520-
 36525 000061FD 6F66206F7220636861-
 36525 00006206 6E6765732074686520-
 36525 0000620F 63757272656E742064-
 36525 00006218 69726563746F72792E-
 36525 00006221 0D0A               
 36526 00006223 0D0A                    	db 0Dh,0Ah
 36527 00006225 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 36527 0000622E 6976653A5D5B706174-
 36527 00006237 685D0D0A           
 36528 0000623B 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 36528 00006244 0D0A               
 36529                                  MSG_1341:
 36530 00006246 62                      	db 98
 36531 00006247 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 36531 00006250 3A5D5B706174685D0D-
 36531 00006259 0A                 
 36532 0000625A 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 36533 00006262 0D0A                    	db 0Dh,0Ah
 36534 00006264 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 36534 0000626D 656369666965732074-
 36534 00006276 68617420796F752077-
 36534 0000627F 616E7420746F206368-
 36534 00006288 616E676520746F2074-
 36534 00006291 686520706172656E74-
 36534 0000629A 206469726563746F72-
 36534 000062A3 792E               
 36535 000062A5 0D0A                    	db 0Dh,0Ah
 36536 000062A7 0D0A                    	db 0Dh,0Ah
 36537                                  MSG_1342:
 36538 000062A9 91                      	db 145
 36539 000062AA 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 36539 000062B3 726976653A20746F20-
 36539 000062BC 646973706C61792074-
 36539 000062C5 68652063757272656E-
 36539 000062CE 74206469726563746F-
 36539 000062D7 727920696E20746865-
 36539 000062E0 207370656369666965-
 36539 000062E9 6420               
 36540 000062EB 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 36541 000062F3 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 36541 000062FC 6974686F7574207061-
 36541 00006305 72616D657465727320-
 36541 0000630E 746F20646973706C61-
 36541 00006317 792074686520637572-
 36541 00006320 72656E742064726976-
 36541 00006329 6520616E6420646972-
 36541 00006332 6563746F72792E0D0A 
 36542                                  MSG_1360:
 36543 0000633B 1B                      	db 27
 36544 0000633C 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 36544 00006345 652073637265656E2E-
 36544 0000634E 0D0A               
 36545 00006350 0D0A                    	db 0Dh,0Ah
 36546 00006352 434C530D0A              	db 'CLS',0Dh,0Ah
 36547                                  MSG_1400:
 36548 00006357 91                      	db 145
 36549 00006358 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 36549 00006361 65206F72206D6F7265-
 36549 0000636A 2066696C657320746F-
 36549 00006373 20616E6F7468657220-
 36549 0000637C 6C6F636174696F6E2E-
 36549 00006385 0D0A               
 36550 00006387 0D0A                    	db 0Dh,0Ah
 36551 00006389 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 36551 00006392 7C202F425D20736F75-
 36551 0000639B 726365205B2F41207C-
 36551 000063A4 202F425D205B2B2073-
 36551 000063AD 6F75726365205B2F41-
 36551 000063B6 207C202F425D205B2B-
 36551 000063BF 202E2E2E5D5D205B64-
 36551 000063C8 657374696E6174696F-
 36551 000063D1 6E0D0A             
 36552 000063D4 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 36552 000063DD 425D5D205B2F565D0D-
 36552 000063E6 0A                 
 36553 000063E7 0D0A                    	db 0Dh,0Ah
 36554                                  MSG_1401:
 36555 000063E9 68                      	db 104
 36556 000063EA 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 36556 000063F3 202020202020537065-
 36556 000063FC 636966696573207468-
 36556 00006405 652066696C65206F72-
 36556 0000640E 2066696C657320746F-
 36556 00006417 20626520636F706965-
 36556 00006420 642E0D0A           
 36557 00006424 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 36557 0000642D 202020202020496E64-
 36557 00006436 69636174657320616E-
 36557 0000643F 204153434949207465-
 36557 00006448 78742066696C652E0D-
 36557 00006451 0A                 
 36558                                  MSG_1402:
 36559 00006452 76                      	db 118
 36560 00006453 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 36560 0000645C 202020202020496E64-
 36560 00006465 696361746573206120-
 36560 0000646E 62696E617279206669-
 36560 00006477 6C652E0D0A         
 36561 0000647C 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 36561 00006485 74696F6E2020537065-
 36561 0000648E 636966696573207468-
 36561 00006497 65206469726563746F-
 36561 000064A0 727920616E642F6F72-
 36561 000064A9 2066696C656E616D65-
 36561 000064B2 20666F722074686520-
 36561 000064BB 6E65772066696C6528-
 36561 000064C4 73292E0D0A         
 36562                                  MSG_1403:	
 36563 000064C9 41                      	db 65
 36564 000064CA 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 36564 000064D3 202020202020566572-
 36564 000064DC 696669657320746861-
 36564 000064E5 74206E65772066696C-
 36564 000064EE 657320617265207772-
 36564 000064F7 697474656E20636F72-
 36564 00006500 726563746C792E0D0A 
 36565 00006509 0D0A                    	db 0Dh,0Ah
 36566                                  MSG_1404:
 36567 0000650B 87                      	db 135
 36568 0000650C 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 36568 00006515 2066696C65732C2073-
 36568 0000651E 706563696679206120-
 36568 00006527 73696E676C65206669-
 36568 00006530 6C6520666F72206465-
 36568 00006539 7374696E6174696F6E-
 36568 00006542 2C20627574206D756C-
 36568 0000654B 7469706C652066696C-
 36568 00006554 65730D0A           
 36569 00006558 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 36569 00006561 6520287573696E6720-
 36569 0000656A 77696C646361726473-
 36569 00006573 206F722066696C6531-
 36569 0000657C 2B66696C65322B6669-
 36569 00006585 6C653320666F726D61-
 36569 0000658E 74292E0D0A         
 36570                                  MSG_1420:
 36571 00006593 8A                      	db 138
 36572 00006594 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 36572 0000659D 6865207465726D696E-
 36572 000065A6 616C20646576696365-
 36572 000065AF 207573656420746F20-
 36572 000065B8 636F6E74726F6C2079-
 36572 000065C1 6F7572207379737465-
 36572 000065CA 6D2E0D0A           
 36573 000065CE 0D0A                    	db 0Dh,0Ah
 36574 000065D0 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 36574 000065D9 63650D0A           
 36575 000065DD 0D0A                    	db 0Dh,0Ah
 36576 000065DF 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 36576 000065E8 202054686520746572-
 36576 000065F1 6D696E616C20646576-
 36576 000065FA 69636520796F752077-
 36576 00006603 616E7420746F207573-
 36576 0000660C 652C20737563682061-
 36576 00006615 7320434F4D312E0D0A 
 36577                                  MSG_1440:
 36578 0000661E 2D                      	db 45
 36579 0000661F 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 36579 00006628 6F7220736574732074-
 36579 00006631 686520646174652E0D-
 36579 0000663A 0A                 
 36580 0000663B 0D0A                    	db 0Dh,0Ah
 36581 0000663D 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 36581 00006646 655D0D0A           
 36582 0000664A 0D0A                    	db 0Dh,0Ah
 36583                                  MSG_1441:
 36584 0000664C 83                      	db 131
 36585 0000664D 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 36585 00006656 20776974686F757420-
 36585 0000665F 706172616D65746572-
 36585 00006668 7320746F2064697370-
 36585 00006671 6C6179207468652063-
 36585 0000667A 757272656E74206461-
 36585 00006683 74652073657474696E-
 36585 0000668C 6720616E640D0A     
 36586 00006693 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 36586 0000669C 666F722061206E6577-
 36586 000066A5 206F6E652E20205072-
 36586 000066AE 65737320454E544552-
 36586 000066B7 20746F206B65657020-
 36586 000066C0 7468652073616D6520-
 36586 000066C9 646174652E0D0A     
 36587                                  MSG_1460:	
 36588 000066D0 64                      	db 100
 36589 000066D1 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36589 000066DA 6E65206F72206D6F72-
 36589 000066E3 652066696C65732E0D-
 36589 000066EC 0A                 
 36590 000066ED 0D0A                    	db 0Dh,0Ah
 36591 000066EF 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36591 000066F8 653A5D5B706174685D-
 36591 00006701 66696C656E616D6520-
 36591 0000670A 5B2F505D0D0A       
 36592 00006710 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36592 00006719 6976653A5D5B706174-
 36592 00006722 685D66696C656E616D-
 36592 0000672B 65205B2F505D0D0A   
 36593 00006733 0D0A                    	db 0Dh,0Ah
 36594                                  MSG_1461:
 36595 00006735 83                      	db 131
 36596 00006736 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36596 0000673F 5D5B706174685D6669-
 36596 00006748 6C656E616D65202053-
 36596 00006751 706563696669657320-
 36596 0000675A 7468652066696C6528-
 36596 00006763 732920746F2064656C-
 36596 0000676C 6574652E2020537065-
 36596 00006775 63696679206D756C74-
 36596 0000677E 69706C650D0A       
 36597 00006784 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36597 0000678D 202020202020202020-
 36597 00006796 202020202020202066-
 36597 0000679F 696C65732062792075-
 36597 000067A8 73696E672077696C64-
 36597 000067B1 63617264732E0D0A   
 36598                                  MSG_1462:
 36599 000067B9 4F                      	db 79
 36600 000067BA 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36600 000067C3 202020202020202020-
 36600 000067CC 202020202020202050-
 36600 000067D5 726F6D70747320666F-
 36600 000067DE 7220636F6E6669726D-
 36600 000067E7 6174696F6E20626566-
 36600 000067F0 6F72652064656C6574-
 36600 000067F9 696E67206561636820-
 36600 00006802 66696C652E0D0A     
 36601                                  MSG_1480:
 36602 00006809 A2                      	db 162
 36603 0000680A 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36603 00006813 61206C697374206F66-
 36603 0000681C 2066696C657320616E-
 36603 00006825 642073756264697265-
 36603 0000682E 63746F726965732069-
 36603 00006837 6E2061206469726563-
 36603 00006840 746F72792E0D0A     
 36604 00006847 0D0A                    	db 0Dh,0Ah
 36605 00006849 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36605 00006852 653A5D5B706174685D-
 36605 0000685B 5B66696C656E616D65-
 36605 00006864 5D205B2F505D205B2F-
 36605 0000686D 575D205B2F415B5B3A-
 36605 00006876 5D6174747269627574-
 36605 0000687F 65735D5D0D0A       
 36606 00006885 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36606 0000688E 736F72746F72646572-
 36606 00006897 5D5D205B2F535D205B-
 36606 000068A0 2F425D205B2F4C5D0D-
 36606 000068A9 0A                 
 36607 000068AA 0D0A                    	db 0Dh,0Ah
 36608                                  MSG_1481:
 36609 000068AC 5D                      	db 93
 36610 000068AD 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36610 000068B6 5D5B706174685D5B66-
 36610 000068BF 696C656E616D655D0D-
 36610 000068C8 0A                 
 36611 000068C9 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36611 000068D2 202020202053706563-
 36611 000068DB 696669657320647269-
 36611 000068E4 76652C206469726563-
 36611 000068ED 746F72792C20616E64-
 36611 000068F6 2F6F722066696C6573-
 36611 000068FF 20746F206C6973742E-
 36611 00006908 0D0A               
 36612                                  MSG_1482:
 36613 0000690A 61                      	db 97
 36614 0000690B 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36614 00006914 202020202050617573-
 36614 0000691D 657320616674657220-
 36614 00006926 656163682073637265-
 36614 0000692F 656E66756C206F6620-
 36614 00006938 696E666F726D617469-
 36614 00006941 6F6E2E0D0A         
 36615 00006946 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36615 0000694F 202020202055736573-
 36615 00006958 2077696465206C6973-
 36615 00006961 7420666F726D61742E-
 36615 0000696A 0D0A               
 36616                                  MSG_1483:	
 36617 0000696C 7A                      	db 122
 36618 0000696D 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36618 00006976 202020202044697370-
 36618 0000697F 6C6179732066696C65-
 36618 00006988 732077697468207370-
 36618 00006991 656369666965642061-
 36618 0000699A 747472696275746573-
 36618 000069A3 2E0D0A             
 36619 000069A6 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36619 000069AF 746573202020442020-
 36619 000069B8 4469726563746F7269-
 36619 000069C1 657320202020202020-
 36619 000069CA 202020202020202020-
 36619 000069D3 522020526561642D6F-
 36619 000069DC 6E6C792066696C6573-
 36619 000069E5 0D0A               
 36620                                  MSG_1484:
 36621 000069E7 BF                      	db 191
 36622 000069E8 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36622 000069F1 202020202020482020-
 36622 000069FA 48696464656E206669-
 36622 00006A03 6C6573202020202020-
 36622 00006A0C 202020202020202020-
 36622 00006A15 41202046696C657320-
 36622 00006A1E 726561647920666F72-
 36622 00006A27 20617263686976696E-
 36622 00006A30 670D0A             
 36623 00006A33 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36623 00006A3C 202020202020532020-
 36623 00006A45 53797374656D206669-
 36623 00006A4E 6C6573202020202020-
 36623 00006A57 202020202020202020-
 36623 00006A60 2D2020507265666978-
 36623 00006A69 206D65616E696E6720-
 36623 00006A72 226E6F74220D0A     
 36624 00006A79 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36624 00006A82 20202020204C697374-
 36624 00006A8B 2062792066696C6573-
 36624 00006A94 20696E20736F727465-
 36624 00006A9D 64206F726465722E0D-
 36624 00006AA6 0A                 
 36625                                  MSG_1485:
 36626 00006AA7 9B                      	db 155
 36627 00006AA8 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36627 00006AB1 6572202020204E2020-
 36627 00006ABA 4279206E616D652028-
 36627 00006AC3 616C70686162657469-
 36627 00006ACC 632920202020202020-
 36627 00006AD5 53202042792073697A-
 36627 00006ADE 652028736D616C6C65-
 36627 00006AE7 737420666972737429-
 36627 00006AF0 0D0A               
 36628 00006AF2 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36628 00006AFB 202020202020452020-
 36628 00006B04 427920657874656E73-
 36628 00006B0D 696F6E2028616C7068-
 36628 00006B16 616265746963292020-
 36628 00006B1F 442020427920646174-
 36628 00006B28 6520262074696D6520-
 36628 00006B31 286561726C69657374-
 36628 00006B3A 206669727374290D0A 
 36629                                  MSG_1486:
 36630 00006B43 96                      	db 150
 36631 00006B44 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36631 00006B4D 202020202020472020-
 36631 00006B56 47726F757020646972-
 36631 00006B5F 6563746F7269657320-
 36631 00006B68 666972737420202020-
 36631 00006B71 2D2020507265666978-
 36631 00006B7A 20746F207265766572-
 36631 00006B83 7365206F726465720D-
 36631 00006B8C 0A                 
 36632 00006B8D 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36632 00006B96 202020202044697370-
 36632 00006B9F 6C6179732066696C65-
 36632 00006BA8 7320696E2073706563-
 36632 00006BB1 696669656420646972-
 36632 00006BBA 6563746F727920616E-
 36632 00006BC3 6420616C6C20737562-
 36632 00006BCC 6469726563746F7269-
 36632 00006BD5 65732E0D0A         
 36633                                  MSG_1487:
 36634 00006BDA 66                      	db 102
 36635 00006BDB 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36635 00006BE4 202020202055736573-
 36635 00006BED 206261726520666F72-
 36635 00006BF6 6D617420286E6F2068-
 36635 00006BFF 656164696E6720696E-
 36635 00006C08 666F726D6174696F6E-
 36635 00006C11 206F722073756D6D61-
 36635 00006C1A 7279292E0D0A       
 36636 00006C20 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36636 00006C29 202020202055736573-
 36636 00006C32 206C6F776572636173-
 36636 00006C3B 652E0D0A           
 36637 00006C3F 0D0A                    	db 0Dh,0Ah
 36638                                  MSG_1488:
 36639 00006C41 92                      	db 146
 36640 00006C42 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36640 00006C4B 6D6179206265207072-
 36640 00006C54 6573657420696E2074-
 36640 00006C5D 686520444952434D44-
 36640 00006C66 20656E7669726F6E6D-
 36640 00006C6F 656E74207661726961-
 36640 00006C78 626C652E20204F7665-
 36640 00006C81 72726964650D0A     
 36641 00006C88 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36641 00006C91 697463686573206279-
 36641 00006C9A 20707265666978696E-
 36641 00006CA3 6720616E7920737769-
 36641 00006CAC 746368207769746820-
 36641 00006CB5 2D202868797068656E-
 36641 00006CBE 292D2D666F72206578-
 36641 00006CC7 616D706C652C202F2D-
 36641 00006CD0 572E0D0A           
 36642                                  MSG_1500:
 36643 00006CD4 3E                      	db 62
 36644 00006CD5 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36644 00006CDE 20434F4D4D414E442E-
 36644 00006CE7 434F4D2070726F6772-
 36644 00006CF0 616D2028636F6D6D61-
 36644 00006CF9 6E6420696E74657270-
 36644 00006D02 7265746572292E0D0A 
 36645 00006D0B 0D0A                    	db 0Dh,0Ah
 36646 00006D0D 455849540D0A            	db 'EXIT',0Dh,0Ah
 36647                                  MSG_1520:
 36648 00006D13 3D                      	db 61
 36649 00006D14 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36649 00006D1D 206469726563746F72-
 36649 00006D26 792E0D0A           
 36650 00006D2A 0D0A                    	db 0Dh,0Ah
 36651 00006D2C 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36651 00006D35 6976653A5D70617468-
 36651 00006D3E 0D0A               
 36652 00006D40 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36652 00006D49 3A5D706174680D0A   
 36653                                  MSG_1540:
 36654 00006D51 5D                      	db 93
 36655 00006D52 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36655 00006D5B 6F7220736574732061-
 36655 00006D64 207365617263682070-
 36655 00006D6D 61746820666F722065-
 36655 00006D76 786563757461626C65-
 36655 00006D7F 2066696C65732E0D0A 
 36656 00006D88 0D0A                    	db 0Dh,0Ah
 36657 00006D8A 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36657 00006D93 6976653A5D70617468-
 36657 00006D9C 5B3B2E2E2E5D5D0D0A 
 36658 00006DA5 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36659 00006DAD 0D0A                    	db 0Dh,0Ah
 36660                                  MSG_1541:
 36661 00006DAF 6B                      	db 107
 36662 00006DB0 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36662 00006DB9 203B20746F20636C65-
 36662 00006DC2 617220616C6C207365-
 36662 00006DCB 617263682D70617468-
 36662 00006DD4 2073657474696E6773-
 36662 00006DDD 20616E642064697265-
 36662 00006DE6 6374204D532D444F53-
 36662 00006DEF 20746F207365617263-
 36662 00006DF8 680D0A             
 36663 00006DFB 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36663 00006E04 68652063757272656E-
 36663 00006E0D 74206469726563746F-
 36663 00006E16 72792E0D0A         
 36664                                  MSG_1542:
 36665 00006E1B 3B                      	db 59
 36666 00006E1C 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36666 00006E25 20776974686F757420-
 36666 00006E2E 706172616D65746572-
 36666 00006E37 7320746F2064697370-
 36666 00006E40 6C6179207468652063-
 36666 00006E49 757272656E74207061-
 36666 00006E52 74682E0D0A         
 36667                                  MSG_1560:
 36668 00006E57 37                      	db 55
 36669 00006E58 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36669 00006E61 6865204D532D444F53-
 36669 00006E6A 20636F6D6D616E6420-
 36669 00006E73 70726F6D70742E0D0A 
 36670 00006E7C 0D0A                    	db 0Dh,0Ah
 36671 00006E7E 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36671 00006E87 6578745D0D0A       
 36672 00006E8D 0D0A                    	db 0Dh,0Ah
 36673                                  MSG_1561:
 36674 00006E8F 7C                      	db 124
 36675 00006E90 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36675 00006E99 205370656369666965-
 36675 00006EA2 732061206E65772063-
 36675 00006EAB 6F6D6D616E64207072-
 36675 00006EB4 6F6D70742E0D0A     
 36676 00006EBB 0D0A                    	db 0Dh,0Ah
 36677 00006EBD 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36677 00006EC6 6E206265206D616465-
 36677 00006ECF 207570206F66206E6F-
 36677 00006ED8 726D616C2063686172-
 36677 00006EE1 61637465727320616E-
 36677 00006EEA 642074686520666F6C-
 36677 00006EF3 6C6F77696E67207370-
 36677 00006EFC 656369616C20636F64-
 36677 00006F05 65733A0D0A         
 36678 00006F0A 0D0A                    	db 0Dh,0Ah
 36679                                  MSG_1562:
 36680 00006F0C 2F                      	db 47
 36681 00006F0D 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36681 00006F16 28657175616C207369-
 36681 00006F1F 676E290D0A         
 36682 00006F24 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36682 00006F2D 28646F6C6C61722073-
 36682 00006F36 69676E290D0A       
 36683                                  MSG_1563:
 36684 00006F3C 2A                      	db 42
 36685 00006F3D 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36685 00006F46 7272656E742074696D-
 36685 00006F4F 650D0A             
 36686 00006F52 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36686 00006F5B 7272656E7420646174-
 36686 00006F64 650D0A             
 36687                                  MSG_1564:
 36688 00006F67 3D                      	db 61
 36689 00006F68 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36689 00006F71 7272656E7420647269-
 36689 00006F7A 766520616E64207061-
 36689 00006F83 74680D0A           
 36690 00006F87 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36690 00006F90 2D444F532076657273-
 36690 00006F99 696F6E206E756D6265-
 36690 00006FA2 720D0A             
 36691                                  MSG_1565:
 36692 00006FA5 34                      	db 52
 36693 00006FA6 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36693 00006FAF 7272656E7420647269-
 36693 00006FB8 76650D0A           
 36694 00006FBC 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36694 00006FC5 28677265617465722D-
 36694 00006FCE 7468616E207369676E-
 36694 00006FD7 290D0A             
 36695                                  MSG_1566:
 36696 00006FDA 2C                      	db 44
 36697 00006FDB 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36697 00006FE4 286C6573732D746861-
 36697 00006FED 6E207369676E290D0A 
 36698 00006FF6 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36698 00006FFF 2870697065290D0A   
 36699                                  MSG_1567:
 36700 00007007 79                      	db 121
 36701 00007008 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36701 00007011 636B73706163652028-
 36701 0000701A 657261736573207072-
 36701 00007023 6576696F7573206368-
 36701 0000702C 61726163746572290D-
 36701 00007035 0A                 
 36702 00007036 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36702 0000703F 6361706520636F6465-
 36702 00007048 202841534349492063-
 36702 00007051 6F6465203237290D0A 
 36703 0000705A 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36703 00007063 727269616765207265-
 36703 0000706C 7475726E20616E6420-
 36703 00007075 6C696E65666565640D-
 36703 0000707E 0A                 
 36704 0000707F 0D0A                    	db 0Dh,0Ah
 36705                                  MSG_1568:
 36706 00007081 4C                      	db 76
 36707 00007082 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36707 0000708B 505420776974686F75-
 36707 00007094 7420706172616D6574-
 36707 0000709D 65727320746F207265-
 36707 000070A6 736574207468652070-
 36707 000070AF 726F6D707420746F20-
 36707 000070B8 746865206465666175-
 36707 000070C1 6C742073657474696E-
 36707 000070CA 672E0D0A           
 36708                                  MSG_1580:
 36709 000070CE 47                      	db 71
 36710 000070CF 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36710 000070D8 64656C657465732920-
 36710 000070E1 61206469726563746F-
 36710 000070EA 72792E0D0A         
 36711 000070EF 0D0A                    	db 0Dh,0Ah
 36712 000070F1 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36712 000070FA 6976653A5D70617468-
 36712 00007103 0D0A               
 36713 00007105 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36713 0000710E 3A5D706174680D0A   
 36714                                  MSG_1600:
 36715 00007116 1C                      	db 28
 36716 00007117 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36716 00007120 2066696C65206F7220-
 36716 00007129 66696C65732E0D0A   
 36717 00007131 0D0A                    	db 0Dh,0Ah
 36718                                  MSG_1601:
 36719 00007133 53                      	db 83
 36720 00007134 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36720 0000713D 726976653A5D5B7061-
 36720 00007146 74685D66696C656E61-
 36720 0000714F 6D65312066696C656E-
 36720 00007158 616D65320D0A       
 36721 0000715E 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36721 00007167 653A5D5B706174685D-
 36721 00007170 66696C656E616D6531-
 36721 00007179 2066696C656E616D65-
 36721 00007182 320D0A             
 36722 00007185 0D0A                    	db 0Dh,0Ah
 36723                                  MSG_1602:
 36724 00007187 4D                      	db 77
 36725 00007188 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36725 00007191 20796F752063616E6E-
 36725 0000719A 6F7420737065636966-
 36725 000071A3 792061206E65772064-
 36725 000071AC 72697665206F722070-
 36725 000071B5 61746820666F722079-
 36725 000071BE 6F7572206465737469-
 36725 000071C7 6E6174696F6E206669-
 36725 000071D0 6C652E0D0A         
 36726                                  MSG_1620:
 36727 000071D5 57                      	db 87
 36728 000071D6 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36728 000071DF 20736574732C206F72-
 36728 000071E8 2072656D6F76657320-
 36728 000071F1 4D532D444F5320656E-
 36728 000071FA 7669726F6E6D656E74-
 36728 00007203 207661726961626C65-
 36728 0000720C 732E0D0A           
 36729 00007210 0D0A                    	db 0Dh,0Ah
 36730 00007212 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36730 0000721B 61626C653D5B737472-
 36730 00007224 696E675D5D0D0A     
 36731 0000722B 0D0A                    	db 0Dh,0Ah
 36732                                  MSG_1621:
 36733 0000722D 81                      	db 129
 36734 0000722E 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36734 00007237 652020537065636966-
 36734 00007240 696573207468652065-
 36734 00007249 6E7669726F6E6D656E-
 36734 00007252 742D7661726961626C-
 36734 0000725B 65206E616D652E0D0A 
 36735 00007264 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36735 0000726D 202020537065636966-
 36735 00007276 696573206120736572-
 36735 0000727F 696573206F66206368-
 36735 00007288 617261637465727320-
 36735 00007291 746F2061737369676E-
 36735 0000729A 20746F207468652076-
 36735 000072A3 61726961626C652E0D-
 36735 000072AC 0A                 
 36736 000072AD 0D0A                    	db 0Dh,0Ah
 36737                                  MSG_1622:
 36738 000072AF 4B                      	db 75
 36739 000072B0 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36739 000072B9 776974686F75742070-
 36739 000072C2 6172616D6574657273-
 36739 000072CB 20746F20646973706C-
 36739 000072D4 617920746865206375-
 36739 000072DD 7272656E7420656E76-
 36739 000072E6 69726F6E6D656E7420-
 36739 000072EF 7661726961626C6573-
 36739 000072F8 2E0D0A             
 36740                                  MSG_1640:
 36741 000072FB 34                      	db 52
 36742 000072FC 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36742 00007305 6F7220736574732074-
 36742 0000730E 68652073797374656D-
 36742 00007317 2074696D652E0D0A   
 36743 0000731F 0D0A                    	db 0Dh,0Ah
 36744 00007321 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36744 0000732A 655D0D0A           
 36745 0000732E 0D0A                    	db 0Dh,0Ah
 36746                                  MSG_1641:
 36747 00007330 83                      	db 131
 36748 00007331 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36748 0000733A 2077697468206E6F20-
 36748 00007343 706172616D65746572-
 36748 0000734C 7320746F2064697370-
 36748 00007355 6C6179207468652063-
 36748 0000735E 757272656E74207469-
 36748 00007367 6D652073657474696E-
 36748 00007370 6720616E6420612070-
 36748 00007379 726F6D70740D0A     
 36749 00007380 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36749 00007389 206F6E652E20205072-
 36749 00007392 65737320454E544552-
 36749 0000739B 20746F206B65657020-
 36749 000073A4 7468652073616D6520-
 36749 000073AD 74696D652E0D0A     
 36750                                  MSG_1660:
 36751 000073B4 46                      	db 70
 36752 000073B5 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36752 000073BE 74686520636F6E7465-
 36752 000073C7 6E7473206F66206120-
 36752 000073D0 746578742066696C65-
 36752 000073D9 2E0D0A             
 36753 000073DC 0D0A                    	db 0Dh,0Ah
 36754 000073DE 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36754 000073E7 76653A5D5B70617468-
 36754 000073F0 5D66696C656E616D65-
 36754 000073F9 0D0A               
 36755                                  MSG_1680:
 36756 000073FB 25                      	db 37
 36757 000073FC 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36757 00007405 746865204D532D444F-
 36757 0000740E 532076657273696F6E-
 36757 00007417 2E0D0A             
 36758 0000741A 0D0A                    	db 0Dh,0Ah
 36759 0000741C 5645520D0A              	db 'VER',0Dh,0Ah
 36760                                  MSG_1700:
 36761 00007421 B1                      	db 177
 36762 00007422 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36762 0000742B 444F53207768657468-
 36762 00007434 657220746F20766572-
 36762 0000743D 696679207468617420-
 36762 00007446 796F75722066696C65-
 36762 0000744F 732061726520777269-
 36762 00007458 7474656E20636F7272-
 36762 00007461 6563746C7920746F20-
 36762 0000746A 610D0A             
 36763 0000746D 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36764 00007474 0D0A                    	db 0Dh,0Ah
 36765 00007476 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36765 0000747F 4E207C204F46465D0D-
 36765 00007488 0A                 
 36766 00007489 0D0A                    	db 0Dh,0Ah
 36767 0000748B 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36767 00007494 465920776974686F75-
 36767 0000749D 74206120706172616D-
 36767 000074A6 6574657220746F2064-
 36767 000074AF 6973706C6179207468-
 36767 000074B8 652063757272656E74-
 36767 000074C1 205645524946592073-
 36767 000074CA 657474696E672E0D0A 
 36768                                  MSG_1720:
 36769 000074D3 52                      	db 82
 36770 000074D4 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36770 000074DD 746865206469736B20-
 36770 000074E6 766F6C756D65206C61-
 36770 000074EF 62656C20616E642073-
 36770 000074F8 657269616C206E756D-
 36770 00007501 6265722C2069662074-
 36770 0000750A 686579206578697374-
 36770 00007513 2E0D0A             
 36771 00007516 0D0A                    	db 0Dh,0Ah
 36772 00007518 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36772 00007521 653A5D0D0A         
 36773                                  MSG_1740:
 36774 00007526 5B                      	db 91
 36775 00007527 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36775 00007530 206261746368207072-
 36775 00007539 6F6772616D2066726F-
 36775 00007542 6D20616E6F74686572-
 36775 0000754B 2E0D0A             
 36776 0000754E 0D0A                    	db 0Dh,0Ah
 36777 00007550 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36777 00007559 76653A5D5B70617468-
 36777 00007562 5D66696C656E616D65-
 36777 0000756B 205B62617463682D70-
 36777 00007574 6172616D6574657273-
 36777 0000757D 5D0D0A             
 36778 00007580 0D0A                    	db 0Dh,0Ah
 36779                                  MSG_1741:
 36780 00007582 72                      	db 114
 36781 00007583 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36781 0000758C 6172616D6574657273-
 36781 00007595 202020537065636966-
 36781 0000759E 69657320616E792063-
 36781 000075A7 6F6D6D616E642D6C69-
 36781 000075B0 6E6520696E666F726D-
 36781 000075B9 6174696F6E20726571-
 36781 000075C2 756972656420627920-
 36781 000075CB 7468650D0A         
 36782 000075D0 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36782 000075D9 202020202020202020-
 36782 000075E2 202020626174636820-
 36782 000075EB 70726F6772616D2E0D-
 36782 000075F4 0A                 
 36783                                  MSG_1760:
 36784 000075F5 4C                      	db 76
 36785 000075F6 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36785 000075FF 6F6D6D656E74732028-
 36785 00007608 72656D61726B732920-
 36785 00007611 696E20612062617463-
 36785 0000761A 682066696C65206F72-
 36785 00007623 20434F4E4649472E53-
 36785 0000762C 59532E0D0A         
 36786 00007631 0D0A                    	db 0Dh,0Ah
 36787 00007633 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36787 0000763C 656E745D0D0A       
 36788                                  MSG_1780:
 36789 00007642 6B                      	db 107
 36790 00007643 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36790 0000764C 70726F63657373696E-
 36790 00007655 67206F662061206261-
 36790 0000765E 7463682070726F6772-
 36790 00007667 616D20616E64206469-
 36790 00007670 73706C617973207468-
 36790 00007679 65206D657373616765-
 36790 00007682 2022               
 36791 00007684 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36791 0000768D 0D0A               
 36792 0000768F 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36792 00007698 6E74696E75652E2E2E-
 36792 000076A1 2E220D0A           
 36793 000076A5 0D0A                    	db 0Dh,0Ah
 36794 000076A7 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36795                                  MSG_1800:
 36796 000076AE 4D                      	db 77
 36797 000076AF 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36797 000076B8 6D657373616765732C-
 36797 000076C1 206F72207475726E73-
 36797 000076CA 20636F6D6D616E642D-
 36797 000076D3 6563686F696E67206F-
 36797 000076DC 6E206F72206F66662E-
 36797 000076E5 0D0A               
 36798 000076E7 0D0A                    	db 0Dh,0Ah
 36799 000076E9 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36799 000076F2 4E207C204F46465D0D-
 36799 000076FB 0A                 
 36800                                  MSG_1801:
 36801 000076FC 57                      	db 87
 36802 000076FD 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36802 00007706 6573736167655D0D0A 
 36803 0000770F 0D0A                    	db 0Dh,0Ah
 36804 00007711 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36804 0000771A 20776974686F757420-
 36804 00007723 706172616D65746572-
 36804 0000772C 7320746F2064697370-
 36804 00007735 6C6179207468652063-
 36804 0000773E 757272656E74206563-
 36804 00007747 686F2073657474696E-
 36804 00007750 672E               
 36805 00007752 0D0A                    	db 0Dh,0Ah
 36806                                  MSG_1820:
 36807 00007754 47                      	db 71
 36808 00007755 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36808 0000775E 532D444F5320746F20-
 36808 00007767 61206C6162656C6C65-
 36808 00007770 64206C696E6520696E-
 36808 00007779 206120626174636820-
 36808 00007782 70726F6772616D2E0D-
 36808 0000778B 0A                 
 36809 0000778C 0D0A                    	db 0Dh,0Ah
 36810 0000778E 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36810 00007797 6C0D0A             
 36811 0000779A 0D0A                    	db 0Dh,0Ah
 36812                                  MSG_1821:
 36813 0000779C 8A                      	db 138
 36814 0000779D 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36814 000077A6 205370656369666965-
 36814 000077AF 732061207465787420-
 36814 000077B8 737472696E67207573-
 36814 000077C1 656420696E20746865-
 36814 000077CA 206261746368207072-
 36814 000077D3 6F6772616D20617320-
 36814 000077DC 61206C6162656C2E0D-
 36814 000077E5 0A                 
 36815 000077E6 0D0A                    	db 0Dh,0Ah
 36816 000077E8 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36816 000077F1 61206C6162656C206F-
 36816 000077FA 6E2061206C696E6520-
 36816 00007803 627920697473656C66-
 36816 0000780C 2C20626567696E6E69-
 36816 00007815 6E6720776974682061-
 36816 0000781E 20636F6C6F6E2E0D0A 
 36817                                  MSG_1840:
 36818 00007827 4A                      	db 74
 36819 00007828 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36819 00007831 686520706F73697469-
 36819 0000783A 6F6E206F6620726570-
 36819 00007843 6C61636561626C6520-
 36819 0000784C 706172616D65746572-
 36819 00007855 7320696E2061206261-
 36819 0000785E 7463682066696C652E-
 36819 00007867 0D0A               
 36820 00007869 0D0A                    	db 0Dh,0Ah
 36821 0000786B 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36822                                  MSG_1860:
 36823 00007872 5A                      	db 90
 36824 00007873 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36824 0000787C 636F6E646974696F6E-
 36824 00007885 616C2070726F636573-
 36824 0000788E 73696E6720696E2062-
 36824 00007897 617463682070726F67-
 36824 000078A0 72616D732E0D0A     
 36825 000078A7 0D0A                    	db 0Dh,0Ah
 36826 000078A9 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36826 000078B2 4552524F524C455645-
 36826 000078BB 4C206E756D62657220-
 36826 000078C4 636F6D6D616E640D0A 
 36827                                  MSG_1861:
 36828 000078CD 46                      	db 70
 36829 000078CE 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36829 000078D7 737472696E67313D3D-
 36829 000078E0 737472696E67322063-
 36829 000078E9 6F6D6D616E640D0A   
 36830 000078F1 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36830 000078FA 45584953542066696C-
 36830 00007903 656E616D6520636F6D-
 36830 0000790C 6D616E640D0A       
 36831 00007912 0D0A                    	db 0Dh,0Ah
 36832                                  MSG_1862:
 36833 00007914 7D                      	db 125
 36834 00007915 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36834 0000791E 202020202020202020-
 36834 00007927 202053706563696669-
 36834 00007930 65732074686174204D-
 36834 00007939 532D444F532073686F-
 36834 00007942 756C64206361727279-
 36834 0000794B 206F75742074686520-
 36834 00007954 636F6D6D616E64206F-
 36834 0000795D 6E6C790D0A         
 36835 00007962 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36835 0000796B 202020202020202020-
 36835 00007974 202069662074686520-
 36835 0000797D 636F6E646974696F6E-
 36835 00007986 2069732066616C7365-
 36835 0000798F 2E0D0A             
 36836                                  MSG_1863:
 36837 00007992 A2                      	db 162
 36838 00007993 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36838 0000799C 56454C206E756D6265-
 36838 000079A5 722053706563696669-
 36838 000079AE 657320612074727565-
 36838 000079B7 20636F6E646974696F-
 36838 000079C0 6E2069662074686520-
 36838 000079C9 6C6173742070726F67-
 36838 000079D2 72616D2072756E2072-
 36838 000079DB 657475726E65640D0A 
 36839 000079E4 202020202020202020-     	db '                    '
 36839 000079ED 202020202020202020-
 36839 000079F6 2020               
 36840 000079F8 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36840 00007A01 6F646520657175616C-
 36840 00007A0A 20746F206F72206772-
 36840 00007A13 656174657220746861-
 36840 00007A1C 6E20746865206E756D-
 36840 00007A25 626572207370656369-
 36840 00007A2E 666965642E0D0A     
 36841                                  MSG_1864:
 36842 00007A35 66                      	db 102
 36843 00007A36 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36843 00007A3F 202020202020202020-
 36843 00007A48 202053706563696669-
 36843 00007A51 65732074686520636F-
 36843 00007A5A 6D6D616E6420746F20-
 36843 00007A63 6361727279206F7574-
 36843 00007A6C 206966207468652063-
 36843 00007A75 6F6E646974696F6E20-
 36843 00007A7E 69730D0A           
 36844 00007A82 202020202020202020-     	db '                    met.',0Dh,0Ah
 36844 00007A8B 202020202020202020-
 36844 00007A94 20206D65742E0D0A   
 36845                                  MSG_1865:
 36846 00007A9C 6A                      	db 106
 36847 00007A9D 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36847 00007AA6 3D3D737472696E6732-
 36847 00007AAF 202053706563696669-
 36847 00007AB8 657320612074727565-
 36847 00007AC1 20636F6E646974696F-
 36847 00007ACA 6E2069662074686520-
 36847 00007AD3 737065636966696564-
 36847 00007ADC 207465787420737472-
 36847 00007AE5 696E67730D0A       
 36848 00007AEB 202020202020202020-     	db '                    match.',0Dh,0Ah
 36848 00007AF4 202020202020202020-
 36848 00007AFD 20206D617463682E0D-
 36848 00007B06 0A                 
 36849                                  MSG_1866:
 36850 00007B07 67                      	db 103
 36851 00007B08 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36851 00007B11 696C656E616D652020-
 36851 00007B1A 202053706563696669-
 36851 00007B23 657320612074727565-
 36851 00007B2C 20636F6E646974696F-
 36851 00007B35 6E2069662074686520-
 36851 00007B3E 737065636966696564-
 36851 00007B47 2066696C656E616D65-
 36851 00007B50 0D0A               
 36852 00007B52 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36852 00007B5B 202020202020202020-
 36852 00007B64 20206578697374732E-
 36852 00007B6D 0D0A               
 36853                                  MSG_1880:
 36854 00007B6F 77                      	db 119
 36855 00007B70 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36855 00007B79 656369666965642063-
 36855 00007B82 6F6D6D616E6420666F-
 36855 00007B8B 722065616368206669-
 36855 00007B94 6C6520696E20612073-
 36855 00007B9D 6574206F662066696C-
 36855 00007BA6 65732E0D0A         
 36856 00007BAB 0D0A                    	db 0Dh,0Ah
 36857 00007BAD 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36857 00007BB6 61626C6520494E2028-
 36857 00007BBF 7365742920444F2063-
 36857 00007BC8 6F6D6D616E64205B63-
 36857 00007BD1 6F6D6D616E642D7061-
 36857 00007BDA 72616D65746572735D-
 36857 00007BE3 0D0A               
 36858 00007BE5 0D0A                    	db 0Dh,0Ah
 36859                                  MSG_1881:
 36860 00007BE7 7D                      	db 125
 36861 00007BE8 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36861 00007BF1 6C6520205370656369-
 36861 00007BFA 666965732061207265-
 36861 00007C03 706C61636561626C65-
 36861 00007C0C 20706172616D657465-
 36861 00007C15 722E0D0A           
 36862 00007C19 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36862 00007C22 202020205370656369-
 36862 00007C2B 666965732061207365-
 36862 00007C34 74206F66206F6E6520-
 36862 00007C3D 6F72206D6F72652066-
 36862 00007C46 696C65732E20205769-
 36862 00007C4F 6C646361726473206D-
 36862 00007C58 617920626520757365-
 36862 00007C61 642E0D0A           
 36863                                  MSG_1882:
 36864 00007C65 56                      	db 86
 36865 00007C66 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36865 00007C6F 202020205370656369-
 36865 00007C78 666965732074686520-
 36865 00007C81 636F6D6D616E642074-
 36865 00007C8A 6F206361727279206F-
 36865 00007C93 757420666F72206561-
 36865 00007C9C 63682066696C652E0D-
 36865 00007CA5 0A                 
 36866 00007CA6 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36866 00007CAF 2D706172616D657465-
 36866 00007CB8 72730D0A           
 36867                                  MSG_1883:
 36868 00007CBC A2                      	db 162
 36869 00007CBD 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36869 00007CC6 202020205370656369-
 36869 00007CCF 666965732070617261-
 36869 00007CD8 6D6574657273206F72-
 36869 00007CE1 207377697463686573-
 36869 00007CEA 20666F722074686520-
 36869 00007CF3 737065636966696564-
 36869 00007CFC 20636F6D6D616E642E-
 36869 00007D05 0D0A               
 36870 00007D07 0D0A                    	db 0Dh,0Ah
 36871 00007D09 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36871 00007D12 6520464F5220636F6D-
 36871 00007D1B 6D616E6420696E2061-
 36871 00007D24 206261746368207072-
 36871 00007D2D 6F6772616D2C207370-
 36871 00007D36 656369667920252576-
 36871 00007D3F 61726961626C652069-
 36871 00007D48 6E7374656164206F66-
 36871 00007D51 0D0A               
 36872 00007D53 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36872 00007D5C 2E0D0A             
 36873                                  MSG_1900:
 36874 00007D5F 17                      	db 23
 36875 00007D60 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36875 00007D69 636F6D6D616E64206E-
 36875 00007D72 616D650D0A         
 36876                                  MSG_1920:
 36877 00007D77 2F                      	db 47
 36878 00007D78 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36878 00007D81 726F6772616D20696E-
 36878 00007D8A 746F20746865207570-
 36878 00007D93 706572206D656D6F72-
 36878 00007D9C 7920617265612E0D0A 
 36879 00007DA5 0D0A                    	db 0Dh,0Ah
 36880                                  MSG_1921:
 36881 00007DA7 58                      	db 88
 36882 00007DA8 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36882 00007DB1 5B64726976653A5D5B-
 36882 00007DBA 706174685D66696C65-
 36882 00007DC3 6E616D65205B706172-
 36882 00007DCC 616D65746572735D0D-
 36882 00007DD5 0A                 
 36883 00007DD6 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36883 00007DDF 3A5D5B706174685D66-
 36883 00007DE8 696C656E616D65205B-
 36883 00007DF1 706172616D65746572-
 36883 00007DFA 735D0D0A           
 36884 00007DFE 0D0A                    	db 0Dh,0Ah
 36885                                  MSG_1922:
 36886 00007E00 71                      	db 113
 36887 00007E01 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36887 00007E0A 657273202020537065-
 36887 00007E13 63696669657320616E-
 36887 00007E1C 7920636F6D6D616E64-
 36887 00007E25 2D6C696E6520696E66-
 36887 00007E2E 6F726D6174696F6E20-
 36887 00007E37 726571756972656420-
 36887 00007E40 6279207468650D0A   
 36888 00007E48 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36888 00007E51 20202020202070726F-
 36888 00007E5A 6772616D20796F7520-
 36888 00007E63 77616E7420746F206C-
 36888 00007E6C 6F61642E0D0A       
 36889                                  
 36890                                  ; ---------------------------------------------------------------------------
 36891                                  
 36892                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36893                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36894                                  
 36895                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36896                                  
 36897                                  $M_CLS_3:
 36898 00007E72 0E                      	push	cs		; CLASS_F
 36899 00007E73 07                      	pop	es
 36900 00007E74 8D3E[3357]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36901                                  	; 15/04/2023
 36902                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36903                                  	; 06/08/2024
 36904 00007E78 81C14527                	add	cx,$-$M_CLASS_3_STRUC
 36905 00007E7C C3                      	retn
 36906                                  
 36907                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36908                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36909                                  
 36910                                  ; ---------------------------------------------------------------------------
 36911                                  ; Class 1 messages
 36912                                  ; ---------------------------------------------------------------------------
 36913                                  	
 36914                                  $M_CLASS_1_STRUC:
 36915 00007E7D 01                      	db 1			; $M_CLASS_ID
 36916 00007E7E 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36917 00007E80 04                      	db 4			; Class_1_MessageCount
 36918                                  $M_ID_1_1:
 36919 00007E81 0200                    	dw 2			; Message Number = 2
 36920 00007E83 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36921                                  $M_ID_1_2:
 36922 00007E85 0300                    	dw 3			; Message Number = 3
 36923 00007E87 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36924                                  $M_ID_1_3:
 36925 00007E89 0800                    	dw 8			; Message Number = 8
 36926 00007E8B 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36927                                  $M_ID_1_4:
 36928 00007E8D FFFF                    	dw 0FFFFh		; Message Number = -1
 36929 00007E8F 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36930                                  
 36931                                  ; ---------------------------------------------------------------------------
 36932                                  
 36933                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36934                                  EXTEND2:
 36935 00007E91 0E                      	db 14
 36936 00007E92 46696C65206E6F7420-     	db 'File not found'
 36936 00007E9B 666F756E64         
 36937                                  EXTEND3:
 36938 00007EA0 0E                      	db 14
 36939 00007EA1 50617468206E6F7420-     	db 'Path not found'
 36939 00007EAA 666F756E64         
 36940                                  EXTEND8:
 36941 00007EAF 13                      	db 19
 36942 00007EB0 496E73756666696369-     	db 'Insufficient memory'
 36942 00007EB9 656E74206D656D6F72-
 36942 00007EC2 79                 
 36943                                  EXTEND999:
 36944 00007EC3 11                      	db 17
 36945 00007EC4 457874656E64656420-     	db 'Extended Error %1'
 36945 00007ECD 4572726F72202531   
 36946                                  
 36947                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36948                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36949                                  
 36950                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36951                                  $M_MSGSERV_1:
 36952 00007ED5 0E                      	push	cs
 36953 00007ED6 07                      	pop	es
 36954 00007ED7 8D3E[7D7E]              	lea	di,$M_CLASS_1_STRUC
 36955                                  	; 15/04/2023
 36956                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36957 00007EDB C3                      	retn
 36958                                  
 36959                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36960                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36961                                  
 36962                                  ; ---------------------------------------------------------------------------
 36963                                  ; Class 2 messages
 36964                                  ; ---------------------------------------------------------------------------
 36965                                  	
 36966                                  $M_CLASS_2_STRUC:
 36967 00007EDC 02                      	db 2			; $M_CLASS_ID
 36968 00007EDD 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36969 00007EDF 01                      	db 1			; Class_2_MessageCount
 36970                                  $M_ID_2_1:
 36971 00007EE0 FFFF                    	dw 0FFFFh		; Message Number = -1
 36972 00007EE2 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36973                                  ; ---------------------------------------------------------------------------
 36974                                  
 36975                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36976                                  PARSE999:
 36977 00007EE4 0E                      	db 14
 36978 00007EE5 506172736520457272-     	db 'Parse Error %1'
 36978 00007EEE 6F72202531         
 36979                                  
 36980                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36981                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 36982                                  
 36983                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36984                                  $M_MSGSERV_2:
 36985 00007EF3 0E                      	push	cs
 36986 00007EF4 07                      	pop	es
 36987 00007EF5 8D3E[DC7E]              	lea	di,$M_CLASS_2_STRUC
 36988                                  	; 15/04/2023
 36989                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 36990 00007EF9 C3                      	retn
 36991                                  
 36992                                  ;============================================================================
 36993                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 36994                                  ;============================================================================
 36995                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36996                                  
 36997                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 36998                                  
 36999                                  ;****************************************************
 37000                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 37001                                  ;****************************************************
 37002                                  
 37003                                  msg_disp_class:
 37004 00007EFA FF                      	db	util_msg_class ; 0FFh
 37005                                  msg_cont_flag:
 37006 00007EFB 00                      	db	no_cont_flag ; 0
 37007                                  
 37008                                  ;  extended error string output
 37009                                  extend_buf_ptr:
 37010 00007EFC 0000                    	dw	0			;AN000;set to no message
 37011                                  extend_buf_sub:
 37012 00007EFE 00                      	db	0			;AN000;set to no substitutions
 37013 00007EFF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37014 00007F00 00                      	db	0			;AN000;reserved
 37015                                  extend_buf_off:
 37016 00007F01 [118C]                  	dw	string_ptr_2		;AN000;offset of arg
 37017                                  extend_buf_seg:
 37018 00007F03 0000                    	dw	0			;AN000;segment of arg
 37019 00007F05 00                      	db	0			;AN000;first subst
 37020 00007F06 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37021 00007F07 80                      	db	128			;AN000;maximum width
 37022 00007F08 00                      	db	0			;AN000;minimum width
 37023 00007F09 20                      	db	blank ; 20h		;AN000;pad character
 37024                                  
 37025                                  ;  "Duplicate file name or file not found"
 37026                                  RENERR_PTR:
 37027 00007F0A EA03                    	dw	1002			;AN000;message number
 37028 00007F0C 00                      	db	no_subst ; 0		;AN000;number of subst
 37029                                  
 37030                                  ;  "Invalid path or file name"
 37031                                  BADCPMES_PTR:
 37032 00007F0D EB03                    	dw	1003			;AN000;message number
 37033 00007F0F 00                      	db	no_subst ; 0		;AN000;number of subst
 37034                                  
 37035                                  ;  "Insufficient disk space"
 37036                                  NOSPACE_PTR:
 37037 00007F10 EC03                    	dw	1004			;AN000;message number
 37038 00007F12 00                      	db	no_subst ; 0		;AN000;number of subst
 37039                                  
 37040                                  ;  "Out of environment space"
 37041                                  ENVERR_PTR:
 37042 00007F13 EF03                    	dw	1007			;AN000;message number
 37043 00007F15 00                      	db	no_subst ; 0		;AN000;number of subst
 37044                                  
 37045                                  ;  "File creation error"
 37046                                  FULLDIR_PTR:
 37047 00007F16 F003                    	dw	1008			;AN000;message number
 37048 00007F18 00                      	db	no_subst ; 0		;AN000;number of subst
 37049                                  
 37050                                  ;  "Batch file missing",13,10
 37051                                  BADBAT_PTR:
 37052 00007F19 F103                    	dw	1009			;AN000;message number
 37053 00007F1B 00                      	db	no_subst ; 0		;AN000;number of subst
 37054                                  
 37055                                  ;  "Insert disk with batch file",13,10
 37056                                  NEEDBAT_PTR:
 37057 00007F1C F203                    	dw	1010			;AN000;message number
 37058 00007F1E 00                      	db	no_subst ; 0		;AN000;number of subst
 37059                                  
 37060                                  ;  "Bad command or file name",13,10
 37061                                  BADNAM_PTR:
 37062 00007F1F F303                    	dw	1011			;AN000;message number
 37063 00007F21 00                      	db	no_subst ; 0		;AN000;number of subst
 37064                                  
 37065                                  ;  "Access denied",13,10
 37066                                  ACCDEN_PTR:
 37067 00007F22 F603                    	dw	1014			;AN000;message number
 37068 00007F24 00                      	db	no_subst ; 0		;AN000;number of subst
 37069                                  
 37070                                  ;  "File cannot be copied onto itself",13,10
 37071                                  OVERWR_PTR:
 37072 00007F25 F703                    	dw	1015			;AN000;message number
 37073 00007F27 00                      	db	no_subst ; 0		;AN000;number of subst
 37074                                  
 37075                                  ;  "Content of destination lost before copy",13,10
 37076                                  LOSTERR_PTR:
 37077 00007F28 F803                    	dw	1016			;AN000;message number
 37078 00007F2A 00                      	db	no_subst ; 0		;AN000;number of subst
 37079                                  
 37080                                  ;  "Invalid filename or file not found",13,10
 37081                                  INORNOT_PTR:
 37082 00007F2B F903                    	dw	1017			;AN000;message number
 37083 00007F2D 00                      	db	no_subst		;AN000;number of subst
 37084                                  
 37085                                  ;  "%1 File(s) copied",13,10
 37086                                  copied_ptr:
 37087 00007F2E FA03                    	dw	1018			;AN000;message number
 37088 00007F30 01                      	db	1			;AN000;number of subst
 37089 00007F31 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37090 00007F32 00                      	db	0			;AN000;reserved
 37091 00007F33 [138C]                  	dw	Copy_num		;AN000;offset of arg
 37092 00007F35 0000                    	dw	0			;AN000;segment of arg
 37093 00007F37 01                      	db	1			;AN000;first subst
 37094 00007F38 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37095                                  					;AN000;binary to decimal
 37096 00007F39 09                      	db	9			;AN000;maximum width
 37097 00007F3A 09                      	db	9			;AN000;minimum width
 37098 00007F3B 20                      	db	blank ; 20h		;AN000;pad character
 37099                                  
 37100                                  ;  "%1 File(s) "
 37101                                  dirmes_ptr:
 37102 00007F3C FB03                    	dw	1019			;AN000;message number
 37103 00007F3E 01                      	db	1			;AN000;number of subst
 37104 00007F3F 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37105 00007F40 00                      	db	0			;AN000;reserved
 37106 00007F41 [168C]                  	dw	Dir_Num			;AN000;offset of arg
 37107 00007F43 0000                    	dw	0			;AN000;segment of arg
 37108 00007F45 01                      	db	1			;AN000;first subst
 37109 00007F46 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37110                                  					;AN000;binary to decimal
 37111 00007F47 09                      	db	9			;AN000;maximum width
 37112 00007F48 09                      	db	9			;AN000;minimum width
 37113 00007F49 20                      	db	blank ; 20h		;AN000;pad character
 37114                                  
 37115                                  ;  "%1 bytes free",13,10
 37116                                  bytmes_ptr:
 37117 00007F4A FC03                    	dw	1020			;AN000;message number
 37118 00007F4C 01                      	db	1			;AN000;number of subst
 37119 00007F4D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37120 00007F4E 00                      	db	0			;AN000;reserved
 37121 00007F4F [188C]                  	dw	Bytes_Free		;AN000;offset of arg
 37122 00007F51 0000                    	dw	0			;AN000;segment of arg
 37123 00007F53 01                      	db	1			;AN000;first subst
 37124 00007F54 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37125                                  					;AN000;long binary to decimal
 37126 00007F55 1C                      	db	28			;AN000;maximum width
 37127 00007F56 1C                      	db	28			;AN000;minimum width
 37128 00007F57 20                      	db	blank ; 20h		;AN000;pad character
 37129                                  
 37130                                  ;  "Invalid drive specification",13,10
 37131                                  baddrv_ptr:
 37132 00007F58 FD03                    	dw	1021			;AN000;message number
 37133 00007F5A 00                      	db	no_subst ; 0		;AN000;number of subst
 37134                                  
 37135                                  ;  "Code page %1 not prepared for system",13,10
 37136                                  cp_not_set_ptr:
 37137 00007F5B FE03                    	dw	1022			;AN000;message number
 37138 00007F5D 01                      	db	1			;AN000;number of subst
 37139 00007F5E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37140 00007F5F 00                      	db	0			;AN000;reserved
 37141 00007F60 [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37142 00007F62 0000                    	dw	0			;AN000;segment of arg
 37143 00007F64 01                      	db	1			;AN000;first subst
 37144 00007F65 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37145                                  					;AN000;binary to decimal
 37146 00007F66 05                      	db	5			;AN000;maximum width
 37147 00007F67 01                      	db	1			;AN000;minimum width
 37148 00007F68 20                      	db	blank ; 20h		;AN000;pad character
 37149                                  
 37150                                  ;  "Code page %1 not prepared for all devices",13,10
 37151                                  cp_not_all_ptr:
 37152 00007F69 FF03                    	dw	1023			;AN000;message number
 37153 00007F6B 01                      	db	1			;AN000;number of subst
 37154 00007F6C 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37155 00007F6D 00                      	db	0			;AN000;reserved
 37156 00007F6E [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37157 00007F70 0000                    	dw	0			;AN000;segment of arg
 37158 00007F72 01                      	db	1			;AN000;first subst
 37159 00007F73 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37160                                  					;AN000;binary to decimal
 37161 00007F74 05                      	db	5			;AN000;maximum width
 37162 00007F75 01                      	db	1			;AN000;minimum width
 37163 00007F76 20                      	db	blank ; 20h		;AN000;pad character
 37164                                  
 37165                                  ;  "Active code page: %1",13,10
 37166                                  cp_active_ptr:
 37167 00007F77 0004                    	dw	1024			;AN000;message number
 37168 00007F79 01                      	db	1			;AN000;number of subst
 37169 00007F7A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37170 00007F7B 00                      	db	0			;AN000;reserved
 37171 00007F7C [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37172 00007F7E 0000                    	dw	0			;AN000;segment of arg
 37173 00007F80 01                      	db	1			;AN000;first subst
 37174 00007F81 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37175                                  					;AN000;binary to decimal
 37176 00007F82 05                      	db	5			;AN000;maximum width
 37177 00007F83 01                      	db	1			;AN000;minimum width
 37178 00007F84 20                      	db	blank ; 20h		;AN000;pad character
 37179                                  
 37180                                  ;  "NLSFUNC not installed",13,10
 37181                                  NLSFUNC_PTR:
 37182 00007F85 0104                    	dw	1025			;AN000;message number
 37183 00007F87 00                      	db	no_subst ; 0		;AN000;number of subst
 37184                                  
 37185                                  ;  "Invalid code page",13,10
 37186                                  INV_CODE_PAGE:
 37187 00007F88 0204                    	dw	1026			;AN000;message number
 37188 00007F8A 00                      	db	no_subst ; 0		;AN000;number of subst
 37189                                  
 37190                                  ;  "Current drive is no longer valid"
 37191                                  BADCURDRV:
 37192 00007F8B 0304                    	dw	1027			;AN000;message number
 37193 00007F8D 00                      	db	no_subst ; 0		;AN000;number of subst
 37194                                  
 37195                                  ;  "Press any key to continue"
 37196                                  PAUSEMES_PTR:
 37197 00007F8E 0404                    	dw	1028			;AN000;message number
 37198 00007F90 00                      	db	no_subst ; 0		;AN000;number of subst
 37199                                  
 37200                                  ;  "Label not found",13,10
 37201                                  BADLAB_PTR:
 37202 00007F91 0504                    	dw	1029			;AN000;message number
 37203 00007F93 00                      	db	no_subst ; 0		;AN000;number of subst
 37204                                  
 37205                                  ;  "Syntax error",13,10
 37206                                  SYNTMES_PTR:
 37207 00007F94 0604                    	dw	1030			;AN000;message number
 37208 00007F96 00                      	db	no_subst ; 0		;AN000;number of subst
 37209                                  
 37210                                  ;  "Invalid date",13,10
 37211                                  BADDAT_PTR:
 37212 00007F97 0704                    	dw	1031			;AN000;message number
 37213 00007F99 00                      	db	no_subst ; 0		;AN000;number of subst
 37214                                  
 37215                                  ;  "Current date is %1 %2",13,10
 37216                                  CurDat_Ptr:
 37217 00007F9A 0804                    	dw	1032			;AN000;message number
 37218 00007F9C 02                      	db	2			;AN000;number of subst
 37219 00007F9D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37220 00007F9E 00                      	db	0			;AN000;reserved
 37221 00007F9F [F692]                  	dw	Arg_Buf			;AN000;offset of arg
 37222 00007FA1 0000                    	dw	0			;AN000;segment of arg
 37223 00007FA3 01                      	db	1			;AN000;first subst
 37224 00007FA4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37225 00007FA5 03                      	db	3			;AN000;maximum width
 37226 00007FA6 03                      	db	3			;AN000;minimum width
 37227 00007FA7 20                       	db	blank ; 20h		;AN000;pad character
 37228 00007FA8 0B                      	db	parm_block_size 	;AN000;size of sublist
 37229 00007FA9 00                      	db	0			;AN000;reserved
 37230                                  CurDat_yr:
 37231 00007FAA 0000                    	dw	0			;AN000;year
 37232                                  CurDat_mo_day:
 37233 00007FAC 0000                    	dw	0			;AN000;month,day
 37234 00007FAE 02                      	db	2			;AN000;second subst
 37235 00007FAF 34                      	db	34h ; DATE_MDY_4	;AN000;date
 37236 00007FB0 0A                      	db	10			;AN000;maximum width
 37237 00007FB1 0A                      	db	10			;AN000;minimum width
 37238 00007FB2 20                      	db	blank ; 20h		;AN000;pad character
 37239                                  
 37240                                  ;  "SunMonTueWedThuFriSat"
 37241                                  WeekTab:
 37242 00007FB3 0904                    	dw	1033			;AN000;message number
 37243 00007FB5 00                      	db	no_subst ; 0		;AN000;number of subst
 37244                                  
 37245                                  ;  "Enter new date (%1):"
 37246                                  
 37247                                  NewDat_Ptr:
 37248 00007FB6 0A04                    	dw	1034			;AN000;message number
 37249 00007FB8 01                      	db	1			;AN000;number of subst
 37250 00007FB9 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37251 00007FBA 00                      	db	0			;AN000;reserved
 37252                                  NewDat_Format:
 37253 00007FBB 0000                    	dw	0			;AN000;offset of replacement
 37254 00007FBD 0000                    	dw	0			;AN000;segment of arg
 37255 00007FBF 01                      	db	1			;AN000;first subst
 37256 00007FC0 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37257 00007FC1 08                      	db	8			;AN000;maximum width
 37258 00007FC2 08                      	db	8			;AN000;minimum width
 37259 00007FC3 20                      	db	blank ; 20h		;AN000;pad character
 37260                                  
 37261                                  ;  "Invalid time",13,10
 37262                                  
 37263                                  BadTim_Ptr:
 37264 00007FC4 0B04                    	dw	1035			;AN000;message number
 37265 00007FC6 00                      	db	no_subst ; 0		;AN000;number of subst
 37266                                  
 37267                                  ;  "Current time is %1",13,10
 37268                                  CurTim_Ptr:
 37269 00007FC7 0C04                    	dw	1036			;AN000;message number
 37270 00007FC9 01                      	db	1			;AN000;number of subst
 37271 00007FCA 0B                      	db	parm_block_size 	;AN000;size of sublist
 37272 00007FCB 00                      	db	0			;AN000;reserved
 37273                                  CurTim_hr_min:
 37274 00007FCC 0000                    	dw	0			;AN000;hours,minutes
 37275                                  CurTim_Sec_hn:
 37276 00007FCE 0000                    	dw	0			;AN000;seconds,hundredths
 37277 00007FD0 01                      	db	1			;AN000;first subst
 37278 00007FD1 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 37279                                  					;AC059;time
 37280 00007FD2 0C                      	db	12			;AC059;maximum width
 37281 00007FD3 0C                      	db	12			;AC059;minimum width
 37282 00007FD4 20                      	db	blank ; 20h		;AN000;pad character
 37283                                  
 37284                                  ;  "Enter new time:"
 37285                                  NewTim_Ptr:
 37286 00007FD5 0D04                    	dw	1037			;AN000;message number
 37287 00007FD7 00                      	db	no_subst ; 0		;AN000;number of subst
 37288                                  
 37289                                  ;  ",    Delete (Y/N)?",13,10
 37290                                  Del_Y_N_Ptr:
 37291 00007FD8 0E04                    	dw	1038			;AN000;message number
 37292 00007FDA 00                      	db	no_subst ; 0		;AN000;number of subst
 37293                                  
 37294                                  ;  "All files in directory will be deleted!",13,10
 37295                                  ;  "Are you sure (Y/N)?",13,10
 37296                                  SureMes_Ptr:
 37297 00007FDB 0F04                    	dw	1039			;AN000;message number
 37298 00007FDD 00                      	db	no_subst ; 0		;AN000;number of subst
 37299                                  
 37300                                  ;  "Microsoft DOS Version %1.%2",13,10
 37301                                  VerMes_Ptr:
 37302 00007FDE 1004                    	dw	1040			;AN000;message number
 37303 00007FE0 02                      	db	2			;AN000;number of subst
 37304 00007FE1 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37305 00007FE2 00                      	db	0			;AN000;reserved
 37306 00007FE3 [1C8C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 37307 00007FE5 0000                    	dw	0			;AN000;segment of arg
 37308 00007FE7 01                      	db	1			;AN000;first subst
 37309 00007FE8 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37310                                  					;AN000;binary to decimal
 37311 00007FE9 01                      	db	1			;AN000;maximum width
 37312 00007FEA 01                      	db	1			;AN000;minimum width
 37313 00007FEB 20                      	db	blank ; 20h		;AN000;pad character
 37314 00007FEC 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37315 00007FED 00                      	db	0			;AN000;reserved
 37316 00007FEE [1E8C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 37317 00007FF0 0000                    	dw	0			;AN000;segment of arg
 37318 00007FF2 02                      	db	2			;AN000;second subst
 37319 00007FF3 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37320                                  					;AN000;binary to decimal
 37321 00007FF4 02                      	db	2			;AN000;maximum width
 37322 00007FF5 02                      	db	2			;AN000;minimum width
 37323 00007FF6 30                      	db	'0' ; 30h		;AN000;pad character
 37324                                  
 37325                                  ;  "Volume in drive %1 has no label",13,10
 37326                                  VolMes_Ptr_2:
 37327 00007FF7 1104                    	dw	1041			;AN000;message number
 37328 00007FF9 01                      	db	1			;AN000;number of subst
 37329 00007FFA 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37330 00007FFB 00                      	db	0			;AN000;reserved
 37331 00007FFC [228C]                  	dw	vol_drv			;AN000;offset of drive
 37332 00007FFE 0000                    	dw	0			;AN000;segment of arg
 37333 00008000 01                      	db	1			;AN000;first subst
 37334 00008001 00                      	db	0 ; Char_field_Char 	;AN000;character
 37335 00008002 80                      	db	128			;AN000;maximum width
 37336 00008003 01                      	db	1			;AN000;minimum width
 37337 00008004 20                      	db	blank ; 20h		;AN000;pad character
 37338                                  
 37339                                  ;  "Volume in drive %1 is %2",13,10
 37340                                  VolMes_Ptr:
 37341 00008005 1204                    	dw	1042			;AN000;message number
 37342 00008007 02                      	db	2			;AN000;number of subst
 37343 00008008 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37344 00008009 00                      	db	0			;AN000;reserved
 37345 0000800A [228C]                  	dw	vol_drv			;AN000;offset of drive
 37346 0000800C 0000                    	dw	0			;AN000;segment of arg
 37347 0000800E 01                      	db	1			;AN000;first subst
 37348 0000800F 00                      	db	00000000b		;AN000;character
 37349 00008010 80                      	db	128			;AN000;maximum width
 37350 00008011 01                      	db	1			;AN000;minimum width
 37351 00008012 20                      	db	blank ; 20h		;AN000;pad character
 37352 00008013 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37353 00008014 00                      	db	0			;AN000;reserved
 37354 00008015 [DB8A]                  	dw	CHARBUF			;AN000;offset of string
 37355 00008017 0000                    	dw	0			;AN000;segment of arg
 37356 00008019 02                      	db	2			;AN000;second subst
 37357 0000801A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37358 0000801B 80                      	db	128			;AN000;maximum width
 37359 0000801C 01                      	db	1			;AN000;minimum width
 37360 0000801D 20                      	db	blank ; 20h		;AN000;pad character
 37361                                  
 37362                                  ;  "Volume Serial Number is %1-%2",13,10
 37363                                  VolSerMes_Ptr:
 37364 0000801E 1304                    	dw	1043			;AN000;message number
 37365 00008020 02                      	db	2			;AN000;number of subst
 37366 00008021 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37367 00008022 00                      	db	0			;AN000;reserved
 37368 00008023 [7D8D]                  	dw	vol_serial+2		;AN000;offset of serial
 37369 00008025 0000                    	dw	0			;AN000;segment of arg
 37370 00008027 01                      	db	1			;AN000;first subst
 37371 00008028 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 37372                                  					;AN000;binary to hex
 37373 00008029 04                      	db	4			;AN000;maximum width
 37374 0000802A 04                      	db	4			;AN000;minimum width
 37375 0000802B 30                      	db	'0' ; 30h		;AN000;pad character
 37376 0000802C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37377 0000802D 00                      	db	0			;AN000;reserved
 37378 0000802E [7B8D]                  	dw	vol_serial		;AN000;offset of serial
 37379 00008030 0000                    	dw	0			;AN000;segment of arg
 37380 00008032 02                      	db	2			;AN000;second subst
 37381 00008033 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 37382                                  					;AN000;binary to hex
 37383 00008034 04                      	db	4			;AN000;maximum width
 37384 00008035 04                      	db	4			;AN000;minimum width
 37385 00008036 30                      	db	'0' ; 30h		;AN000;pad character
 37386                                  
 37387                                  ;  "Invalid directory",13,10
 37388                                  badcd_ptr:
 37389 00008037 1404                    	dw	1044			;AN000;message number
 37390 00008039 00                      	db	no_subst ; 0		;AN000;number of subst
 37391                                  
 37392                                  ;  "Unable to create directory",13,10
 37393                                  badmkd_ptr:
 37394 0000803A 1504                    	dw	1045			;AN000;message number
 37395 0000803C 00                      	db	no_subst ; 0		;AN000;number of subst
 37396                                  
 37397                                  ;  "Invalid path, not directory,",13,10
 37398                                  ;  "or directory not empty",13,10
 37399                                  badrmd_ptr:
 37400 0000803D 1604                    	dw	1046			;AN000;message number
 37401 0000803F 00                      	db	no_subst ; 0		;AN000;number of subst
 37402                                  
 37403                                  ;  "Must specify ON or OFF",13,10
 37404                                  bad_on_off_ptr:
 37405 00008040 1704                    	dw	1047			;AN000;message number
 37406 00008042 00                      	db	no_subst ; 0		;AN000;number of subst
 37407                                  
 37408                                  ;  "Directory of %1",13,10
 37409                                  dirhead_ptr:
 37410 00008043 1804                    	dw	1048			;AN000;message number
 37411 00008045 01                      	db	1			;AN000;number of subst
 37412 00008046 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37413 00008047 00                      	db	0			;AN000;reserved
 37414 00008048 [AA8B]                  	dw	BWDBUF			;AN000;offset of arg
 37415 0000804A 0000                    	dw	0			;AN000;segment of arg
 37416 0000804C 01                      	db	1			;AN000;first subst
 37417 0000804D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37418 0000804E 80                      	db	128			;AN000;maximum width
 37419 0000804F 00                      	db	0			;AN000;minimum width
 37420 00008050 20                      	db	blank ; 20h		;AN000;pad character
 37421                                  
 37422                                  ;  "No Path",13,10
 37423                                  NULLPATH_PTR:
 37424 00008051 1904                    	dw	1049			;AN000;message number
 37425 00008053 00                      	db	no_subst ; 0		;AN000;number of subst
 37426                                  
 37427                                  ;  "Invalid drive in search path",13,10
 37428                                  BADPMES_PTR:
 37429 00008054 1A04                    	dw	1050			;AN000;message number
 37430 00008056 00                      	db	no_subst ; 0		;AN000;number of subst
 37431                                  
 37432                                  ;  "Invalid device",13,10
 37433                                  BADDEV_PTR:
 37434 00008057 1B04                    	dw	1051			;AN000;message number
 37435 00008059 00                      	db	no_subst ; 0		;AN000;number of subst
 37436                                  
 37437                                  ;  "FOR cannot be nested",13,10
 37438                                  FORNESTMES_PTR:
 37439 0000805A 1C04                    	dw	1052			;AN000;message number
 37440 0000805C 00                      	db	no_subst ; 0		;AN000;number of subst
 37441                                  
 37442                                  ;  "Intermediate file error during pipe",13,10
 37443                                  PIPEEMES_PTR:
 37444 0000805D 1D04                    	dw	1053			;AN000;message number
 37445 0000805F 00                      	db	no_subst ; 0		;AN000;number of subst
 37446                                  
 37447                                  ;  "Cannot do binary reads from a device",13,10
 37448                                  INBDEV_PTR:
 37449 00008060 1E04                    	dw	1054			;AN000;message number
 37450 00008062 00                      	db	no_subst ; 0		;AN000;number of subst
 37451                                  
 37452                                  ;  "BREAK is %1",13,10
 37453                                  CtrlcMes_Ptr:
 37454 00008063 1F04                    	dw	1055			;AN000;message number
 37455 00008065 01                      	db	1			;AN000;number of subst
 37456 00008066 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37457 00008067 00                      	db	0			;AN000;reserved
 37458 00008068 0000                    	dw	0			;AN000;offset of on/off (new)
 37459 0000806A 0000                    	dw	0			;AN000;segment of arg
 37460 0000806C 01                      	db	1			;AN000;first subst
 37461 0000806D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37462 0000806E 80                      	db	128			;AN000;maximum width
 37463 0000806F 01                      	db	1			;AN000;minimum width
 37464 00008070 20                      	db	blank ; 20h		;AN000;pad character
 37465                                  
 37466                                  ;  "VERIFY is %1",13,10
 37467                                  VeriMes_Ptr:
 37468 00008071 2004                    	dw	1056			;AN000;message number
 37469 00008073 01                      	db	1			;AN000;number of subst
 37470 00008074 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37471 00008075 00                      	db	0			;AN000;reserved
 37472 00008076 0000                    	dw	0			;AN000;offset of on/off (new)
 37473 00008078 0000                    	dw	0			;AN000;segment of arg
 37474 0000807A 01                      	db	1			;AN000;first subst
 37475 0000807B 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37476 0000807C 80                      	db	128			;AN000;maximum width
 37477 0000807D 01                      	db	1			;AN000;minimum width
 37478 0000807E 20                      	db	blank ; 20h		;AN000;pad character
 37479                                  
 37480                                  ;  "ECHO is %1",13,10
 37481                                  EchoMes_Ptr:
 37482 0000807F 2104                    	dw	1057			;AN000;message number
 37483 00008081 01                      	db	1			;AN000;number of subst
 37484 00008082 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37485 00008083 00                      	db	0			;AN000;reserved
 37486 00008084 0000                    	dw	0			;AN000;offset of on/off (new)
 37487 00008086 0000                    	dw	0			;AN000;segment of arg
 37488 00008088 01                      	db	1			;AN000;first subst
 37489 00008089 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37490 0000808A 80                      	db	128			;AN000;maximum width
 37491 0000808B 01                      	db	1			;AN000;minimum width
 37492 0000808C 20                      	db	blank ; 20h		;AN000;pad character
 37493                                  
 37494                                  ;  "off"
 37495                                  OFFMES_PTR:
 37496 0000808D 2304                    	dw	1059			;AN000;message number
 37497 0000808F 00                      	db	no_subst		;AN000;number of subst
 37498                                  
 37499                                  ;  "on"
 37500                                  ONMES_PTR:
 37501 00008090 2404                    	dw	1060			;AN000;message number
 37502 00008092 00                      	db	no_subst ; 0		;AN000;number of subst
 37503                                  
 37504                                  ;  "Error writing to device",13,10
 37505                                  DEVWMES_PTR:
 37506 00008093 2504                    	dw	1061			;AN000;message number
 37507 00008095 00                      	db	no_subst ; 0		;AN000;number of subst
 37508                                  
 37509                                  ;  "Invalid path",13,10
 37510                                  INVAL_PATH_PTR:
 37511 00008096 2604                    	dw	1062			;AN000;message number
 37512 00008098 00                      	db	no_subst ; 0		;AN000;number of subst
 37513                                  
 37514                                  ;  unformatted string output
 37515                                  arg_buf_ptr:
 37516 00008099 2704                    	dw	1063			;AN000;message number
 37517 0000809B 01                      	db	1			;AN000;number of subst
 37518 0000809C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37519 0000809D 00                      	db	0			;AN000;reserved
 37520 0000809E [F692]                  	dw	Arg_Buf 		;AN000;offset of arg
 37521 000080A0 0000                    	dw	0			;AN000;segment of arg
 37522 000080A2 01                      	db	1			;AN000;first subst
 37523 000080A3 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37524 000080A4 80                      	db	128			;AN000;maximum width
 37525 000080A5 00                      	db	0			;AN000;minimum width
 37526 000080A6 20                      	db	blank ; 20h		;AN000;pad character
 37527                                  
 37528                                  ;  file name output
 37529                                  file_name_ptr:
 37530 000080A7 2804                    	dw	1064			;AN000;message number
 37531 000080A9 01                      	db	1			;AN000;number of subst
 37532 000080AA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37533 000080AB 00                      	db	0			;AN000;reserved
 37534 000080AC [908C]                  	dw	SrcBuf			;AN000;offset of arg
 37535 000080AE 0000                    	dw	0			;AN000;segment of arg
 37536 000080B0 01                      	db	1			;AN000;first subst
 37537 000080B1 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37538 000080B2 80                      	db	128			;AN000;maximum width
 37539 000080B3 00                      	db	0			;AN000;minimum width
 37540 000080B4 20                      	db	blank ; 20h		;AN000;pad character
 37541                                  
 37542                                  ;  file size output for dir
 37543                                  disp_file_size_ptr:
 37544 000080B5 2904                    	dw	1065			;AN000;message number
 37545 000080B7 01                      	db	1			;AN000;number of subst
 37546 000080B8 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37547 000080B9 00                      	db	0			;AN000;reserved
 37548 000080BA [0D8C]                  	dw	File_Size_Low		;AN000;offset of arg
 37549 000080BC 0000                    	dw	0			;AN000;segment of arg
 37550 000080BE 01                      	db	1			;AN000;first subst
 37551 000080BF B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37552                                  					;AN000;long binary to decimal
 37553 000080C0 0A                      	db	10			;AN000;maximum width
 37554 000080C1 0A                      	db	10			;AN000;minimum width
 37555 000080C2 20                      	db	blank ; 20h		;AN000;pad character
 37556                                  
 37557                                  ;  unformatted string output
 37558                                  ; %s
 37559                                  string_buf_ptr:
 37560 000080C3 2A04                    	dw	1066			;AN000;message number
 37561 000080C5 01                      	db	1			;AN000;number of subst
 37562 000080C6 0B                      	db	parm_block_size 	;AN000;size of sublist
 37563 000080C7 00                      	db	0			;AN000;reserved
 37564 000080C8 [118C]                  	dw	string_ptr_2		;AN000;offset of arg
 37565 000080CA 0000                    	dw	0			;AN000;segment of arg
 37566 000080CC 01                      	db	1			;AN000;first subst
 37567 000080CD 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37568 000080CE 80                      	db	128			;AN000;maximum width
 37569 000080CF 00                      	db	0			;AN000;minimum width
 37570 000080D0 20                      	db	blank ; 20h		;AN000;pad character
 37571 000080D1 00                      	db	0			;AN000;
 37572                                  
 37573                                  ;  tab character
 37574                                  tab_ptr:
 37575 000080D2 2B04                    	dw	1067			;AN000;message number
 37576 000080D4 00                      	db	no_subst ; 0		;AN000;number of subst
 37577                                  
 37578                                  ;  " <DIR>   "
 37579                                  dmes_ptr:
 37580 000080D5 2C04                    	dw	1068			;AN000;message number
 37581 000080D7 00                      	db	no_subst ; 0		;AN000;number of subst
 37582                                  
 37583                                  ;  destructive back space
 37584                                  dback_ptr:
 37585 000080D8 2D04                    	dw	1069			;AN000;message number
 37586 000080DA 00                      	db	no_subst ; 0		;AN000;number of subst
 37587                                  
 37588                                  ;  carriage return / line feed
 37589                                  acrlf_ptr:
 37590 000080DB 2E04                    	dw	1070			;AN000;message number
 37591 000080DD 00                      	db	no_subst ; 0		;AN000;number of subst
 37592                                  
 37593                                  ;  "mm-dd-yy"
 37594                                  usadat_ptr:
 37595 000080DE 3004                    	dw	1072			;AN000;message number
 37596 000080E0 00                      	db	no_subst ; 0		;AN000;number of subst
 37597                                  
 37598                                  ;  "dd-mm-yy"
 37599                                  eurdat_ptr:
 37600 000080E1 3104                    	dw	1073			;AN000;message number
 37601 000080E3 00                      	db	no_subst ; 0		;AN000;number of subst
 37602                                  
 37603                                  ;  "yy-mm-dd"
 37604                                  japdat_ptr:
 37605 000080E4 3204                    	dw	1074			;AN000;message number
 37606 000080E6 00                      	db	no_subst ; 0		;AN000;number of subst
 37607                                  
 37608                                  ;  date string for prompt
 37609                                  promptdat_ptr:
 37610 000080E7 3304                    	dw	1075			;AN000;message number
 37611 000080E9 02                      	db	2			;AN000;number of subst
 37612 000080EA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37613 000080EB 00                      	db	0			;AN000;reserved
 37614 000080EC [F692]                  	dw	Arg_Buf			;AN000;offset of arg
 37615 000080EE 0000                    	dw	0			;AN000;segment of arg
 37616 000080F0 01                      	db	1			;AN000;first subst
 37617 000080F1 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37618 000080F2 03                      	db	3			;AN000;maximum width
 37619 000080F3 03                      	db	3			;AN000;minimum width
 37620 000080F4 20                       	db	blank ; 20h		;AN000;pad character
 37621 000080F5 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37622 000080F6 00                      	db	0			;AN000;reserved
 37623                                  promptDat_yr:
 37624 000080F7 0000                    	dw	0			;AN000;year
 37625                                  promptDat_moday:
 37626 000080F9 0000                    	dw	0			;AN000;month,day
 37627 000080FB 02                      	db	2			;AN000;second subst
 37628 000080FC 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37629 000080FD 0A                      	db	10			;AN000;maximum width
 37630 000080FE 08                      	db	8			;AN000;minimum width
 37631 000080FF 20                      	db	blank ; 20h		;AN000;pad character
 37632                                  
 37633                                  ;  Time for prompt
 37634                                  promtim_ptr:
 37635 00008100 3404                    	dw	1076			;AN000;message number
 37636 00008102 01                      	db	1			;AN000;number of subst
 37637 00008103 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37638 00008104 00                      	db	0			;AN000;reserved
 37639                                  PromTim_hr_min:
 37640 00008105 0000                    	dw	0			;AN000;hours,minutes
 37641                                  PromTim_Sec_hn:
 37642 00008107 0000                    	dw	0			;AN000;seconds,hundredths
 37643 00008109 01                      	db	1			;AN000;first subst
 37644 0000810A A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37645                                  					;AC013;time
 37646 0000810B 0B                      	db	11			;AN000;maximum width
 37647 0000810C 0B                      	db	11			;AC013;minimum width
 37648 0000810D 20                      	db	blank ; 20h		;AN000;pad character
 37649                                  
 37650                                  ;  Date and time for DIR
 37651                                  dirdattim_ptr:
 37652 0000810E 3504                    	dw	1077			;AN000;message number
 37653 00008110 02                      	db	2			;AN000;number of subst
 37654 00008111 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37655 00008112 00                      	db	0			;AN000;reserved
 37656                                  DirDat_Yr:
 37657 00008113 0000                    	dw	0			;AN000;year
 37658                                  DirDat_Mo_Day:
 37659 00008115 0000                    	dw	0			;AN000;month,day
 37660 00008117 01                      	db	1			;AN000;first subst
 37661 00008118 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37662                                  					;AN000;date
 37663 00008119 0A                      	db	10			;AN000;maximum width
 37664 0000811A 08                      	db	8			;AN000;minimum width
 37665 0000811B 20                      	db	blank ; 20h		;AN000;pad character
 37666 0000811C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37667 0000811D 00                      	db	0			;AN000;reserved
 37668                                  DirTim_Hr_Min:
 37669 0000811E 0000                    	dw	0			;AN000;hours,minutes
 37670                                  DirTim_Sec_hn:
 37671 00008120 0000                    	dw	0			;AN000;seconds,hundredths
 37672 00008122 02                      	db	2			;AN000;second subst
 37673 00008123 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37674                                  					;AN000;time
 37675 00008124 06                      	db	6			;AN000;maximum width
 37676 00008125 06                      	db	6			;AN000;minimum width
 37677 00008126 20                      	db	blank ; 20h		;AN000;pad character
 37678                                  
 37679                                  ;  "Directory already exists"
 37680                                  MD_EXISTS_PTR:
 37681 00008127 3604                    	dw	1078			;AN000;message number
 37682 00008129 00                      	db	no_subst		;AN000;number of subst
 37683                                  
 37684                                  ;  "%1 bytes",13,10
 37685                                  bytes_ptr:
 37686 0000812A 3704                    	dw	1079			; message number
 37687 0000812C 01                      	db	1			; number of subst
 37688 0000812D 0B                              db	parm_block_size ; 11	; size of sublist
 37689 0000812E 00                              db	0			; reserved
 37690 0000812F [CF8A]                          dw	FileSiz			; offset of arg
 37691 00008131 0000                            dw	0			; segment of arg
 37692 00008133 01                              db	1			; first subst
 37693 00008134 B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37694                                  					; long binary to decimal
 37695 00008135 0A                              db	10			; maximum width
 37696 00008136 0A                              db	10			; minimum width
 37697 00008137 20                              db	blank ; 20h		; pad character
 37698                                  
 37699                                  ;  "Total:",13,10
 37700                                  total_ptr:
 37701 00008138 3804                    	dw	1080			; message number
 37702 0000813A 00                      	db	no_subst ; 0		; number of subst
 37703                                  
 37704                                  ;  "Error parsing environment variable:",13,10
 37705                                  errparsenv_ptr:
 37706 0000813B 3904                    	dw	1081			; message number
 37707 0000813D 00                      	db	no_subst ; 0		; number of subst
 37708                                  
 37709                                  ;  "(continuing %1)",13,10
 37710                                  dircont_ptr:
 37711 0000813E 3C04                    	dw	1084			;AN000;message number
 37712 00008140 01                      	db	1			;AN000;number of subst
 37713 00008141 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37714 00008142 00                      	db	0			;AN000;reserved
 37715 00008143 [AA8B]                  	dw	BWDBUF			;AN000;offset of arg
 37716 00008145 0000                    	dw	0			;AN000;segment of arg
 37717 00008147 01                      	db	1			;AN000;first subst
 37718 00008148 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37719 00008149 80                      	db	128			;AN000;maximum width
 37720 0000814A 00                      	db	0			;AN000;minimum width
 37721 0000814B 20                      	db	blank ; 20h		;AN000;pad character
 37722                                  
 37723                                  ;  "Revision %1",CR,LF
 37724                                  dosrev_ptr:
 37725 0000814C 4204                    	dw	1090
 37726 0000814E 01                      	db	1			; one substitution
 37727 0000814F 0B                      	db	parm_block_size ; 11
 37728 00008150 00                      	db	0
 37729 00008151 [208C]                  	dw	One_Char_Val		; ptr to char
 37730 00008153 0000                    	dw	0			; segment addr?
 37731 00008155 01                      	db	1			; 1st substitution
 37732 00008156 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37733 00008157 01                      	db	1			; max width
 37734 00008158 01                      	db	1			; min width
 37735 00008159 20                      	db	blank ; 20h		; pad char
 37736                                  
 37737                                  ;  "DOS is in ROM"
 37738                                  DosRom_Ptr:
 37739 0000815A 4304                    	dw	1091
 37740 0000815C 00                      	db	no_subst ; 0		
 37741                                  
 37742                                  ;  "DOS is in HMA"
 37743                                  DosHma_Ptr:
 37744 0000815D 4404                    	dw	1092
 37745 0000815F 00                      	db	no_subst ; 0		
 37746                                  
 37747                                  ;  "DOS is in low memory"
 37748                                  DosLow_Ptr:
 37749 00008160 4504                    	dw	1093
 37750 00008162 00                      	db	no_subst ; 0		
 37751                                  
 37752                                  ;  "Cannot Loadhigh batch file" ;M016
 37753                                  NoExecBat_Ptr:
 37754 00008163 4604                    	dw	1094			; M016
 37755 00008165 00                      	db	no_subst ; 0		; M016
 37756                                  
 37757                                  ;  "LoadHigh: Invalid filename" ; M016
 37758                                  LhInvFil_Ptr:
 37759 00008166 4704                    	dw	1095			; M016
 37760 00008168 00                      	db	no_subst ; 0		; M016
 37761                                  
 37762                                  ;  "Could not open specified country information file" ; M045
 37763                                  NoCntry_Ptr:
 37764 00008169 4804                    	dw	1096			; M045
 37765 0000816B 00                      	db	no_subst ; 0		; M045
 37766                                  
 37767                                  ; 15/04/2023
 37768                                  ; MSDOS 6.0 COMMAND.COM only !
 37769                                  %if 0
 37770                                  
 37771                                  ;* The next four errors emulate those reported by the normal parse
 37772                                  ;  mechanism, with a little more accurate wording; that parser has been
 37773                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37774                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37775                                  ;  parser, so they've been added here.
 37776                                  
 37777                                  ;  "LoadHigh: Invalid argument"
 37778                                  LhInvArg_Ptr:
 37779                                  	dw	1097
 37780                                  	db	no_subst ; 0		
 37781                                  
 37782                                  ;  "Required parameter missing"
 37783                                  ReqParmMiss:
 37784                                  	dw	1098
 37785                                  	db	no_subst ; 0		
 37786                                  
 37787                                  ;  "Unrecognized switch"
 37788                                  LhInvSwt_Ptr:
 37789                                  	dw	1099
 37790                                  	db	no_subst ; 0		
 37791                                  
 37792                                  ;  "A bad UMB number has been specified"
 37793                                  LhBadUMB_Ptr:
 37794                                  	dw	1100
 37795                                  	db	no_subst ; 0
 37796                                  %endif		
 37797                                  
 37798                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37799                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37800                                  ; ---------------------------------------------------------------------------
 37801                                  
 37802                                  PATH_TEXT:
 37803 0000816C 504154483D              	db	"PATH="
 37804                                  PROMPT_TEXT:
 37805 00008171 50524F4D50543D          	db	"PROMPT="
 37806                                  COMSPECSTR:
 37807 00008178 434F4D535045433D        	db	"COMSPEC="
 37808                                  DirEnvVar:
 37809 00008180 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37810                                  
 37811                                  ; 15/04/2023
 37812                                  %if 0
 37813                                  
 37814                                  ;============================================================================
 37815                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37816                                  ;============================================================================
 37817                                  ; 30/09/2018 - Retro DOS v3.0
 37818                                  
 37819                                  ; TITLE	COMMAND Transient Initialized DATA
 37820                                  
 37821                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37822                                  ;initial values at the beginning of each command cycle. It is
 37823                                  ;included in the transient checksum area. If values in TRANDATA
 37824                                  ;change, the transient will be reloaded for the next command cycle.
 37825                                  
 37826                                  align 16
 37827                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37828                                  
 37829                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37830                                  _3740h:		db '%S',0
 37831                                  ARG_BUF_PTR:	dw _3740h
 37832                                  		dw _3747h
 37833                                  _3747h:		dw ARG_BUF ; _43E8h
 37834                                  _3749h:		db '%S ',0
 37835                                  STRINGBUF1PTR:	dw _3749h
 37836                                  		dw STRING_PTR_1 ; _4468h
 37837                                  _3751h:		db '%9ld',0
 37838                                  FSIZEMESPTR:	dw _3751h
 37839                                  		dw FILESIZE_L ; _446Ah
 37840                                  		dw FILESIZE_H ; _446Ch
 37841                                  _375Ch:		db '%S',0
 37842                                  STRINGBUF2PTR:	dw _375Ch
 37843                                  		dw STRING_PTR_2 ; _446Eh
 37844                                  _3763h:		db 9,0
 37845                                  TABPTR:		dw _3763h
 37846                                  _3767h:		db 0Dh,0Ah
 37847                                  		db 'Batch file missing',0Dh,0Ah,0
 37848                                  BADPATHPTR:	dw _3767h
 37849                                  _3780h:		db 0Dh,0Ah
 37850                                  		db 'Insert disk with batch file',0Dh,0Ah
 37851                                  		db 'and press any key when ready',0Dh,0Ah,0
 37852                                  INSERTDSKPTR:	dw _3780h
 37853                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37854                                  BADNAMPTR:	dw _37C0h
 37855                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37856                                  RENERRPTR:	dw _37DDh
 37857                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37858                                  FNOTFOUNDPTR:	dw _3807h
 37859                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37860                                  PNOTFOUNDPTR:	dw _381Ah
 37861                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37862                                  ACCDENPTR:	dw _382Dh
 37863                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37864                                  NOSPACEPTR:	dw _383Fh
 37865                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37866                                  ENVERRPTR:	dw _385Bh
 37867                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37868                                  FULDIRPTR:	dw 3878h
 37869                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37870                                  OVERWRPTR:	dw _3890h
 37871                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37872                                  LOSTERRPTR:	dw _38B6h
 37873                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37874                                  INORNOTPTR:	dw _38E2h
 37875                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37876                                  COPIEDPTR:	dw _3909h
 37877                                  		dw COPY_NUM ; _4470h
 37878                                  _3922h:		db '%9d File(s) ',0
 37879                                  DIRMESPTR:	dw _3922h
 37880                                  		dw DIR_NUM  ; _4477h
 37881                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37882                                  BYTEMESPTR:	dw _3933h
 37883                                  		dw BYTES_FREE   ; _4479h
 37884                                  		dw BYTES_FREE+2 ; _447Bh
 37885                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37886                                  BADDRVPTR:	dw _394Bh
 37887                                  _396Bh:		db 0Dh,0Ah
 37888                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37889                                  CPNOTSETPTR:	dw _396Bh
 37890                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37891                                  _3999h:		db 0Dh,0Ah
 37892                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37893                                  CPNOTALLPTR:	dw _3999h
 37894                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37895                                  _39CCh:		db 0Dh,0Ah
 37896                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37897                                  CPACTIVEPTR:	dw _39CCh
 37898                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37899                                  _39EAh:		db 'Current drive is no longer valid',0
 37900                                  BADCURDRVPTR:	dw _39EAh
 37901                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37902                                  PAUSEMESPTR:	dw _3A0Dh
 37903                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37904                                  BADPARMPTR:	dw _3A2Eh
 37905                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37906                                  _3A59h:		db 0Dh,0Ah
 37907                                  		db 'Invalid date',0
 37908                                  BADDATPTR:	dw _3A59h
 37909                                  _3A6Ah:		db 'Current date is ',0
 37910                                  CURDATPTR:	dw _3A6Ah
 37911                                  _3A7Dh:		db 0Dh,0Ah
 37912                                  		db 'Enter new date ',0
 37913                                  NEWDATPTR:	dw _3A7Dh
 37914                                  _3A91h:		db '(mm-dd-yy): ',0
 37915                                  USADATPTR:	dw _3A91h
 37916                                  _3AA0h:		db '(dd-mm-yy): ',0
 37917                                  EURDATPTR:	dw _3AA0h
 37918                                  _3AAFh:		db '(yy-mm-dd): ',0
 37919                                  JAPDATPTR:	dw _3AAFh
 37920                                  _3ABEh:		db 0Dh,0Ah
 37921                                  		db 'Invalid time ',0
 37922                                  BADTIMPTR:	dw _3ABEh
 37923                                  _3AD0h:		db 'Current time is ',0
 37924                                  CURTIMPTR:	dw _3AD0h
 37925                                  _3AE3h:		db 0Dh,0Ah
 37926                                  		db 'Enter new time: ',0
 37927                                  NEWTIMPTR:	dw _3AE3h
 37928                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37929                                  SUREMESPTR:	dw _3AF8h
 37930                                  _3B0Eh:		db ' <DIR>   ',0
 37931                                  DMESPTR:	dw _3B0Eh
 37932                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37933                                  VERMESPTR:	dw _3B1Ah
 37934                                  		dw MAJOR_VER_NUM ; _447Dh
 37935                                  		dw MINOR_VER_NUM ; _447Fh
 37936                                  _3B4Dh:		db '%C',0
 37937                                  ONECHRVALPTR:	dw _3B4Dh
 37938                                  		dw ONE_CHAR_VAL	; _4481h
 37939                                  _3B54h:		db ' Volume in drive %c %s',0
 37940                                  VOLMESPTR:	dw _3B54h
 37941                                  		dw VOL_DRV ; _4484h
 37942                                  		dw VOLNAME_ADDR ; _4482h
 37943                                  IS:		db 'is ',0
 37944                                  NOVOL:		db 'has no label',0
 37945                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37946                                  BADCDPTR:	dw _3B82h
 37947                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37948                                  BADMKDPTR:	dw _3B98h
 37949                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37950                                  		db 'or directory not empty',0Dh,0Ah,0
 37951                                  BADRMDPTR:	dw _3BB7h
 37952                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37953                                  BADONOFFPTR:	dw _3BF0h
 37954                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37955                                  DIRHEADPTR:	dw _3C0Bh
 37956                                  		dw VOL_DIR ; _4485h
 37957                                  _3C23h:		db 'No Path',0
 37958                                  NULLPATHPTR:	dw _3C23h
 37959                                  PATH_TEXT:	db 'PATH='
 37960                                  PROMPT_TEXT:	db 'PROMPT='
 37961                                  COMSPEC_TEXT:	db 'COMSPEC='
 37962                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37963                                  BADPMESPTR:	dw _3C41h
 37964                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37965                                  BADDEVPTR:	dw _3C62h
 37966                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37967                                  BADLABPTR:	dw _3C75h
 37968                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37969                                  SYNTMESPTR:	dw _3C89h
 37970                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37971                                  FORNESTMESTR:	dw _3C9Ah
 37972                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37973                                  INSFMEMMESPTR:	dw _3CB4h
 37974                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37975                                  PIPEEMESPTR:	dw _3CCCh
 37976                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37977                                  INBDEVPTR:	dw _3CF4h
 37978                                  _3D1Dh:		db 'BREAK is ',0
 37979                                  CTRLMESPTR:	dw _3D1Dh
 37980                                  _3D29h:		db 'VERIFY is ',0
 37981                                  VERIMESPTR:	dw _3D29h
 37982                                  _3D36h:		db 'ECHO is ',0
 37983                                  ECHOMESPTR:	dw _3D36h
 37984                                  _3D41h:		db 'off',0Dh,0Ah,0
 37985                                  OFFMESPTR:	dw _3D41h
 37986                                  _3D49h:		db 'on',0Dh,0Ah,0
 37987                                  ONMESPTR:	dw _3D49h
 37988                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 37989                                  BADCPMESPTR:	dw _3D50h
 37990                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 37991                                  BADARGSPTR:	dw _3D6Eh
 37992                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 37993                                  DEVWMESPTR:	dw _3D8Fh
 37994                                  _3DABh:		db 0Dh,0Ah,0
 37995                                  ACRLFPTR:	dw _3DABh
 37996                                  _3DB0h:		db 8
 37997                                  		db 20h
 37998                                  		db 8
 37999                                  		db 0
 38000                                  DBACKPTR:	dw _3DB0h
 38001                                  small_y:	db 'y'
 38002                                  small_n:	db 'n'
 38003                                  CAPITAL_Y:	db 'Y'
 38004                                  CAPITAL_N:	db 'N'
 38005                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 38006                                  PROMPT_TABLE:
 38007                                  		db 'B' ; 42h
 38008                                  		dw PRINT_B
 38009                                  		db 'D' ; 44h
 38010                                  		dw PRINT_DATE
 38011                                  		db 'E' ; 45h
 38012                                  		dw PRINT_ESC
 38013                                  		db 'G' ; 47h
 38014                                  		dw PRINT_G
 38015                                  		db 'H' ; 48h
 38016                                  		dw PRINT_BACK
 38017                                  		db 'L' ; 4Ch
 38018                                  		dw PRINT_L
 38019                                  		db 'N' ; 4Eh
 38020                                  		dw PRINT_DRIVE
 38021                                  		db 'P' ; 50h
 38022                                  		dw BUILD_DIR_FOR_PROMPT
 38023                                  		db 'Q' ; 51h
 38024                                  		dw PRINT_EQ
 38025                                  		db 'T' ; 54h
 38026                                  		dw PRINT_TIME
 38027                                  		db 'V' ; 56h
 38028                                  		dw PRINT_VERSION
 38029                                  		db '_' ; 5Fh
 38030                                  		dw CRLF2
 38031                                  		db '$' ; 24h
 38032                                  		dw PRINT_CHAR
 38033                                  		db 0
 38034                                  
 38035                                  		; Table of IF conditionals
 38036                                  IFTAB:
 38037                                  		db 3	; First byte is count
 38038                                  		db 'NOT'
 38039                                  		dw IFNOT
 38040                                  		db 10
 38041                                  		db 'ERRORLEVEL'
 38042                                  		dw IFERLEV
 38043                                  		db 5
 38044                                  		db 'EXIST'
 38045                                  		dw IFEXISTS
 38046                                  		db 0
 38047                                  
 38048                                  		; Table for internal command names
 38049                                  
 38050                                  COMTAB:		db 3
 38051                                  		db 'DIR'
 38052                                  		db 3
 38053                                  		dw CATALOG
 38054                                  		db 4
 38055                                  		db 'CALL'
 38056                                  		db 2
 38057                                  		dw _$CALL
 38058                                  		db 4
 38059                                  		db 'CHCP'
 38060                                  		db 2
 38061                                  		dw CHCP
 38062                                  		db 6
 38063                                  		db 'RENAME'
 38064                                  		db 1
 38065                                  		dw CRENAME
 38066                                  		db 3
 38067                                  		db 'REN'
 38068                                  		db 1
 38069                                  		dw CRENAME
 38070                                  		db 5
 38071                                  		db 'ERASE'
 38072                                  		db 1
 38073                                  		dw ERASE
 38074                                  		db 3
 38075                                  		db 'DEL'
 38076                                  		db 1
 38077                                  		dw ERASE
 38078                                  		db 4
 38079                                  		db 'TYPE'
 38080                                  		db 1
 38081                                  		dw TYPEFIL
 38082                                  		db 3
 38083                                  		db 'REM'
 38084                                  		db 2
 38085                                  		dw TCOMMAND
 38086                                  		db 4
 38087                                  		db 'COPY'
 38088                                  		db 3
 38089                                  		dw COPY
 38090                                  		db 5
 38091                                  		db 'PAUSE'
 38092                                  		db 2
 38093                                  		dw PAUSE
 38094                                  		db 4
 38095                                  		db 'DATE'
 38096                                  		db 2
 38097                                  		dw DATE
 38098                                  		db 4
 38099                                  		db 'TIME'
 38100                                  		db 0
 38101                                  		dw CTIME
 38102                                  		db 3
 38103                                  		db 'VER'
 38104                                  		db 0
 38105                                  		dw VERSION
 38106                                  		db 3
 38107                                  		db 'VOL'
 38108                                  		db 1
 38109                                  		dw VOLUME
 38110                                  		db 2
 38111                                  		db 'CD'
 38112                                  		db 1
 38113                                  		dw _$CHDIR
 38114                                  		db 5
 38115                                  		db 'CHDIR'
 38116                                  		db 1
 38117                                  		dw _$CHDIR
 38118                                  		db 2
 38119                                  		db 'MD'
 38120                                  		db 1
 38121                                  		dw _$MKDIR
 38122                                  		db 5
 38123                                  		db 'MKDIR'
 38124                                  		db 1
 38125                                  		dw _$MKDIR
 38126                                  		db 2
 38127                                  		db 'RD'
 38128                                  		db 1
 38129                                  		dw _$RMDIR
 38130                                  		db 5
 38131                                  		db 'RMDIR'
 38132                                  		db 1
 38133                                  		dw _$RMDIR
 38134                                  		db 5
 38135                                  		db 'BREAK'
 38136                                  		db 0
 38137                                  		dw CNTRLC
 38138                                  		db 6
 38139                                  		db 'VERIFY'
 38140                                  		db 0
 38141                                  		dw VERIFY
 38142                                  		db 3
 38143                                  		db 'SET'
 38144                                  		db 2
 38145                                  		dw ADD_NAME_TO_ENVIRONMENT
 38146                                  		db 6
 38147                                  		db 'PROMPT'
 38148                                  		db 2
 38149                                  		dw ADD_PROMPT
 38150                                  		db 4
 38151                                  		db 'PATH'
 38152                                  		db 2
 38153                                  		dw PATH
 38154                                  		db 4
 38155                                  		db 'EXIT'
 38156                                  		db 0
 38157                                  		dw _$EXIT
 38158                                  		db 4
 38159                                  		db 'CTTY'
 38160                                  		db 3
 38161                                  		dw CTTY
 38162                                  		db 4
 38163                                  		db 'ECHO'
 38164                                  		db 2
 38165                                  		dw _ECHO
 38166                                  		db 4
 38167                                  		db 'GOTO'
 38168                                  		db 2
 38169                                  		dw _GOTO
 38170                                  		db 5
 38171                                  		db 'SHIFT'
 38172                                  		db 2
 38173                                  		dw _SHIFT
 38174                                  		db 2
 38175                                  		db 'IF'
 38176                                  		db 2
 38177                                  		dw _$IF
 38178                                  		db 3
 38179                                  		db 'FOR'
 38180                                  		db 2
 38181                                  		dw _$FOR
 38182                                  		db 3
 38183                                  		db 'CLS'
 38184                                  		db 0
 38185                                  		dw CLS
 38186                                  		db 0
 38187                                  
 38188                                  CAPITAL_A:	db 'A'
 38189                                  VBAR:		db '|'
 38190                                  LABRACKET:	db '<' ; 3Ch
 38191                                  RABRACKET:	db '>' ; 3Eh
 38192                                  DOLLAR:		db '$'
 38193                                  LPAREN:		db '('
 38194                                  RPAREN:		db ')'
 38195                                  NULLRPAREN:	db ')' ; 29h
 38196                                  		db 0
 38197                                  IN_WORD:	db 'I','N'
 38198                                  DO_WORD	:	db 'D','O'
 38199                                  STAR:		db '*'
 38200                                  CHAR_SUB:	db '-' 
 38201                                  PLUS_CHR:	db '+'
 38202                                  CHAR_L:		db 'L'
 38203                                  char_l:		db 'l'
 38204                                  small_a:	db 'a'
 38205                                  small_z:	db 'z'
 38206                                  CHAR_D:		db 'D'
 38207                                  CHAR_C:		db 'C'
 38208                                  CHAR_S:		db 'S'
 38209                                  CHAR_X:		db 'X'
 38210                                  DOT_CHR:	db '.' 
 38211                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 38212                                  		db ','
 38213                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 38214                                  MNCHR:		db 'p'
 38215                                  SYSTEM_CPAGE:	db 0
 38216                                  		db 0
 38217                                  
 38218                                  COMEXT:		db '.COM'
 38219                                  EXEEXT:		db '.EXE'
 38220                                  BATEXT:		db '.BAT'
 38221                                  SWITCH_LIST:	db 'VBAPW'
 38222                                  BATBUFLEN:	dw BATLEN ; 32
 38223                                  
 38224                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 38225                                  
 38226                                  TRANDATAEND:
 38227                                  
 38228                                  %endif
 38229                                  
 38230                                  ;============================================================================
 38231                                  ; TDATA.ASM, MSDOS 6.0, 1991
 38232                                  ;============================================================================
 38233                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38234                                  
 38235                                  	; 15/04/2023
 38236 00008187 00                      	db	0
 38237                                  align 2
 38238                                  
 38239                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 38240                                  ; ---------------------------------------------------------------------------
 38241 00008188 00                      	db 0
 38242                                  ; Lists of help message numbers for internal commands and /?
 38243                                  
 38244                                  ;;NoHelpMsgs:
 38245 00008189 B0040000                	dw	1200,0		;M014
 38246                                  BreakHelpMsgs:
 38247 0000818D 14050000                	dw	1300,0
 38248                                  ChcpHelpMsgs:
 38249 00008191 280529050000            	dw	1320,1321,0
 38250                                  CdHelpMsgs:
 38251 00008197 3C053D053E050000        	dw	1340,1341,1342,0
 38252                                  ClsHelpMsgs:
 38253 0000819F 50050000                	dw	1360,0
 38254                                  CopyHelpMsgs:
 38255 000081A3 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 38255 000081AC 050000             
 38256                                  CttyHelpMsgs:
 38257 000081AF 8C050000                	dw	1420,0
 38258                                  DateHelpMsgs:
 38259 000081B3 A005A1050000            	dw	1440,1441,0
 38260                                  DelHelpMsgs:
 38261 000081B9 B405B505B6050000        	dw	1460,1461,1462,0
 38262                                  DirHelpMsgs:
 38263 000081C1 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 38263 000081CA 05CD05CE05CF05D005 
 38264                                  	; MSDOS 6.0 COMMAND.COM
 38265                                  	;dw	1489,1490,1491,1492
 38266 000081D3 0000                    	dw	0
 38267                                  ExitHelpMsgs:
 38268 000081D5 DC050000                	dw	1500,0
 38269                                  MdHelpMsgs:
 38270 000081D9 F0050000                	dw	1520,0
 38271                                  PathHelpMsgs:
 38272 000081DD 0406050606060000        	dw	1540,1541,1542,0
 38273                                  PromptHelpMsgs:
 38274 000081E5 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 38274 000081EE 061D061E061F062006-
 38274 000081F7 0000               
 38275                                  RdHelpMsgs:
 38276 000081F9 2C060000                	dw	1580,0
 38277                                  RenHelpMsgs:
 38278 000081FD 4006410642060000        	dw	1600,1601,1602,0
 38279                                  SetHelpMsgs:
 38280 00008205 5406550656060000        	dw	1620,1621,1622,0
 38281                                  TimeHelpMsgs:
 38282 0000820D 680669060000            	dw	1640,1641,0
 38283                                  TypeHelpMsgs:
 38284 00008213 7C060000                	dw	1660,0
 38285                                  VerHelpMsgs:
 38286 00008217 90060000                	dw	1680,0
 38287                                  VerifyHelpMsgs:
 38288 0000821B A4060000                	dw	1700,0
 38289                                  VolHelpMsgs:
 38290 0000821F B8060000                	dw	1720,0
 38291                                  CallHelpMsgs:
 38292 00008223 CC06CD060000            	dw	1740,1741,0	;M014
 38293                                  RemHelpMsgs:
 38294 00008229 E0060000                	dw	1760,0		;M014
 38295                                  PauseHelpMsgs:
 38296 0000822D F4060000                	dw	1780,0		;M014
 38297                                  EchoHelpMsgs:
 38298 00008231 080709070000            	dw	1800,1801,0	;M014
 38299                                  GotoHelpMsgs:
 38300 00008237 1C071D070000            	dw	1820,1821,0	;M014
 38301                                  ShiftHelpMsgs:
 38302 0000823D 30070000                	dw	1840,0		;M014
 38303                                  IfHelpMsgs:
 38304 00008241 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 38304 0000824A 0749074A070000     
 38305                                  ForHelpMsgs:
 38306 00008251 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 38306 0000825A 00                 
 38307                                  TruenameHelpMsgs:
 38308 0000825B 6C070000                	 dw	1900,0		;M014
 38309                                  LoadhighHelpMsgs:
 38310 0000825F 800781078207            	dw	1920,1921,1922
 38311                                  	; MSDOS 6.0 COMMAND.COM
 38312                                  	;dw	1923,1924,1925,1926,1927 ;M014
 38313 00008265 0000                    	dw	0
 38314                                  
 38315                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 38316                                  CLSSTRING:
 38317 00008267 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 38318                                  
 38319                                  PROMPT_TABLE:
 38320 0000826C 42                      	db	"B"
 38321 0000826D [F91D]                  	dw	Print_B
 38322 0000826F 44                      	db	"D"
 38323 00008270 [C936]                  	dw	PRINT_DATE
 38324 00008272 45                      	db	"E"
 38325 00008273 [ED1D]                  	dw	PRINT_ESC
 38326 00008275 47                      	db	"G"
 38327 00008276 [F11D]                  	dw	PRINT_G
 38328 00008278 48                      	db	"H"
 38329 00008279 [E31D]                  	dw	PRINT_BACK
 38330 0000827B 4C                      	db	"L"
 38331 0000827C [F51D]                  	dw	PRINT_L
 38332 0000827E 4E                      	db	"N"
 38333 0000827F [0A1E]                  	dw	PRINT_DRIVE
 38334 00008281 50                      	db	"P"
 38335 00008282 [121E]                  	dw	build_dir_for_prompt
 38336 00008284 51                      	db	"Q"
 38337 00008285 [E91D]                  	dw	PRINT_EQ
 38338 00008287 54                      	db	"T"
 38339 00008288 [7E2F]                  	dw	PRINT_TIME
 38340 0000828A 56                      	db	"V"
 38341 0000828B [791D]                  	dw	PRINT_VERSION
 38342 0000828D 5F                      	db	"_"
 38343 0000828E [CF25]                  	dw	CRLF2
 38344 00008290 24                      	db	"$"
 38345 00008291 [FB1D]                  	dw	PRINT_CHAR
 38346 00008293 00                      	db	0			; NUL TERMINATED
 38347                                  
 38348                                  ; Table of IF conditionals
 38349                                  IFTAB:
 38350 00008294 034E4F54                	db	3,"NOT"			; First byte is count
 38351 00008298 [E00A]                  	dw	IFNOT
 38352 0000829A 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 38352 000082A3 454C               
 38353 000082A5 [9F0B]                  	dw	IFERLEV
 38354 000082A7 054558495354            	db	5,"EXIST"
 38355 000082AD [340B]                  	dw	IFEXISTS
 38356 000082AF 00                      	db	0
 38357                                  
 38358                                  ; Table for internal command names
 38359                                  COMTAB:
 38360 000082B0 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 38361 000082B5 [6410]                  	dw	CATALOG			; In TCMD1.ASM
 38362 000082B7 [C181]                  	dw	DirHelpMsgs
 38363                                  
 38364 000082B9 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 38365 000082BF [140C]                  	dw	_$CALL			; In TBATCH2.ASM
 38366 000082C1 [2382]                  	dw	CallHelpMsgs
 38367                                  
 38368 000082C3 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 38369 000082C9 [5520]                  	dw	CHCP			; In TCMD2B.ASM
 38370 000082CB [9181]                  	dw	ChcpHelpMsgs
 38371                                  
 38372 000082CD 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38373 000082D5 [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38374 000082D7 [FD81]                  	dw	RenHelpMsgs
 38375                                  
 38376 000082D9 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38377 000082DE [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38378 000082E0 [FD81]                  	dw	RenHelpMsgs
 38379                                  	
 38380 000082E2 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 38381 000082E9 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38382 000082EB [B981]                  	dw	DelHelpMsgs
 38383                                  	
 38384 000082ED 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 38385 000082F2 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38386 000082F4 [B981]                  	dw	DelHelpMsgs
 38387                                  	
 38388 000082F6 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38389 000082FC [E81A]                  	dw	TYPEFIL			; In TCMD1.ASM
 38390 000082FE [1382]                  	dw	TypeHelpMsgs
 38391                                  	
 38392 00008300 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 38393 00008305 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 38394 00008307 [2982]                  	dw	RemHelpMsgs
 38395                                  	
 38396 00008309 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 38397 0000830F [1637]                  	dw	COPY			; In COPY.ASM
 38398 00008311 [A381]                  	dw	CopyHelpMsgs
 38399                                  	
 38400 00008313 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 38401 0000831A [B319]                  	dw	PAUSE			; In TCMD1.ASM
 38402 0000831C [2D82]                  	dw	PauseHelpMsgs
 38403                                  	
 38404 0000831E 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 38405 00008324 [912E]                  	dw	DATE			; In TPIPE.ASM
 38406 00008326 [B381]                  	dw	DateHelpMsgs
 38407                                  	
 38408 00008328 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 38409 0000832E [F02E]                  	dw	CTIME			; In TPIPE.ASM
 38410 00008330 [0D82]                  	dw	TimeHelpMsgs
 38411                                  	
 38412 00008332 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 38413 00008337 [071D]                  	dw	VERSION			; In TCMD2.ASM
 38414 00008339 [1782]                  	dw	VerHelpMsgs
 38415                                  	
 38416 0000833B 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38417 00008340 [0F1C]                  	dw	VOLUME			; In TCMD1.ASM
 38418 00008342 [1F82]                  	dw	VolHelpMsgs
 38419                                  	
 38420 00008344 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38421 00008348 [9824]                  	dw	_$CHDIR			; In TENV.ASM
 38422 0000834A [9781]                  	dw	CdHelpMsgs
 38423                                  	
 38424 0000834C 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38425 00008353 [9824]                  	dw	_$CHDIR			; In TENV.ASM
 38426 00008355 [9781]                  	dw	CdHelpMsgs
 38427                                  	
 38428 00008357 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38429 0000835B [FD24]                  	dw	_$MKDIR			; In TENV.ASM
 38430 0000835D [D981]                  	dw	MdHelpMsgs
 38431                                  	
 38432 0000835F 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38433 00008366 [FD24]                  	dw	_$MKDIR			; In TENV.ASM
 38434 00008368 [D981]                  	dw	MdHelpMsgs
 38435                                  	
 38436 0000836A 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38437 0000836E [3F25]                  	dw	_$RMDIR			; In TENV.ASM
 38438 00008370 [F981]                  	dw	RdHelpMsgs
 38439                                  	
 38440 00008372 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38441 00008379 [3F25]                  	dw	_$RMDIR			; In TENV.ASM
 38442 0000837B [F981]                  	dw	RdHelpMsgs
 38443                                  	
 38444 0000837D 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 38445 00008384 [1336]                  	dw	CNTRLC			; In TUCODE.ASM
 38446 00008386 [8D81]                  	dw	BreakHelpMsgs
 38447                                  	
 38448 00008388 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 38449 00008390 [5536]                  	dw	VERIFY			; In TUCODE.ASM
 38450 00008392 [1B82]                  	dw	VerifyHelpMsgs
 38451                                  	
 38452 00008394 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 38453 00008399 [0222]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 38454 0000839B [0582]                  	dw	SetHelpMsgs
 38455                                  	
 38456 0000839D 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 38457 000083A5 [E821]                  	dw	ADD_PROMPT		; In TENV.ASM
 38458 000083A7 [E581]                  	dw	PromptHelpMsgs
 38459                                  	
 38460 000083A9 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 38461 000083AF [791E]                  	dw	PATH			; In TCMD2.ASM
 38462 000083B1 [DD81]                  	dw	PathHelpMsgs
 38463                                  	
 38464 000083B3 044558495400            	db	4,"EXIT",0
 38465 000083B9 [4A21]                  	dw	_$EXIT			; In TCMD2.ASM
 38466 000083BB [D581]                  	dw	ExitHelpMsgs
 38467                                  	
 38468 000083BD 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 38469 000083C3 [B71F]                  	dw	CTTY			; In TCMD2.ASM
 38470 000083C5 [AF81]                  	dw	CttyHelpMsgs
 38471                                  	
 38472 000083C7 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 38473 000083CD [DA35]                  	dw	_ECHO			; In TUCODE.ASM
 38474 000083CF [3182]                  	dw	EchoHelpMsgs
 38475                                  	
 38476 000083D1 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 38477 000083D7 [480C]                  	dw	_GOTO			; In TBATCH.ASM
 38478 000083D9 [3782]                  	dw	GotoHelpMsgs
 38479                                  	
 38480 000083DB 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 38481 000083E2 [CD0B]                  	dw	_SHIFT			; In TBATCH.ASM
 38482 000083E4 [3D82]                  	dw	ShiftHelpMsgs
 38483                                  	
 38484 000083E6 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 38485 000083EA [790A]                  	dw	_$IF			; In TBATCH.ASM
 38486 000083EC [4182]                  	dw	IfHelpMsgs
 38487                                  	
 38488 000083EE 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 38489 000083F3 [FD0E]                  	dw	_$FOR			; In TBATCH.ASM
 38490 000083F5 [5182]                  	dw	ForHelpMsgs
 38491                                  	
 38492 000083F7 03434C5300              	db	3,"CLS",0
 38493 000083FC [1E1F]                  	dw	CLS			; In TCMD2.ASM
 38494 000083FE [9F81]                  	dw	ClsHelpMsgs
 38495                                  	
 38496 00008400 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 38496 00008409 03                 
 38497 0000840A [D320]                  	dw	TRUENAME		;AN000;
 38498 0000840C [5B82]                  	dw	TruenameHelpMsgs
 38499                                  	
 38500 0000840E 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 38500 00008417 02                 
 38501 00008418 [2556]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38502 0000841A [5F82]                  	dw	LoadhighHelpMsgs	; M003
 38503                                  	
 38504 0000841C 024C4802                	db	2,"LH",fSwitchAllowed ; 2 ; Short form; M003
 38505 00008420 [2556]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38506 00008422 [5F82]                  	dw	LoadhighHelpMsgs	; M003
 38507                                  	
 38508 00008424 00                      	db	0			; Terminate command table
 38509                                  
 38510                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 38511                                  
 38512 00008425 2E434F4D                comext:	db	".COM"
 38513 00008429 2E455845                exeext:	db	".EXE"
 38514 0000842D 2E424154                batext:	db	".BAT"
 38515                                  
 38516                                  switch_list:
 38517 00008431 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 38518                                  
 38519                                  AttrLtrs:
 38520 00008437 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 38521                                  
 38522                                  ;	Attribute letters in AttrLtrs must appear in the order that
 38523                                  ;	attribute bits occur in the attribute byte returned by
 38524                                  ;	directory searches, starting with bit 0.
 38525                                  ;	The volume label attribute is lowercased to keep it from
 38526                                  ;	being matched (by an uppercase comparison).
 38527                                  
 38528                                  OrderLtrs:
 38529 0000843D 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 38530                                  	; MSDOS 6.0 COMMAND.COM
 38531                                  	;db	"NEDSGC"		; sort order letters for DIR
 38532                                  
 38533                                  ;	Sort order letters stand for file name, extension,
 38534                                  ;	date/time, size, grouped (directory files before others),
 38535                                  ;	and compression ratio. DIR routines rely on the specific
 38536                                  ;	order of the letters in this list.
 38537                                  
 38538                                  comspec_flag:
 38539 00008442 00                      	db	0                       ;AN071;
 38540                                  
 38541                                  BATBUFLEN:
 38542 00008443 2000                    	dw	BatLen ; 32
 38543                                  
 38544                                  ; *****************************************************
 38545                                  ; EMG 4.00
 38546                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 38547                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 38548                                  ; *****************************************************
 38549                                  
 38550                                  ; COMMON PARSE BLOCKS
 38551                                  
 38552                                  ; Indicates no value list for PARSE.
 38553                                  
 38554                                  NO_VALUES:
 38555 00008445 0000                    	dw	0			;AN000;  no values
 38556                                  
 38557                                  NULL_VALUE_LIST:  ; for unvalidated value
 38558 00008447 00                       	db	0                       ; no value lists
 38559                                  
 38560                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38561                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 38562                                  
 38563                                  ; PARSE control block for a required file specification (upper cased)
 38564                                  
 38565                                  FILE_REQUIRED:
 38566 00008448 0002                    	dw	0200h			;AN000;  filespec - required
 38567 0000844A 0100                    	dw	1			;AN000;  capitalize - file table
 38568 0000844C [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38569 0000844E [4584]                  	dw	NO_VALUES		;AN000;
 38570 00008450 00                      	db	0			;AN000;  no keywords
 38571                                  
 38572                                  ; PARSE control block for an optional file specification (upper cased)
 38573                                  ; or drive number
 38574                                  
 38575                                  FILE_OPTIONAL:
 38576 00008451 0103                    	dw	0301h			;AN000;  filespec or drive number
 38577                                  					;	 optional
 38578 00008453 0100                    	dw	1			;AN000;  capitalize - file table
 38579 00008455 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38580 00008457 [4584]                  	dw	NO_VALUES		;AN000;
 38581 00008459 00                      	db	0			;AN000;  no keywords
 38582                                  
 38583                                  ; PARSE control block for an optional file specification (upper cased)
 38584                                  
 38585                                  FILE_OPTIONAL2:
 38586 0000845A 0102                    	dw	0201h                   ;AN000;  filespec optional
 38587 0000845C 0100                    	dw	1                       ;AN000;  capitalize - file table
 38588 0000845E [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38589 00008460 [4584]                  	dw	NO_VALUES		;AN000;
 38590 00008462 00                      	db	0			;AN000;  no keywords
 38591                                  
 38592                                  ; PARSE control block for an optional /P switch
 38593                                  
 38594                                  SLASH_P_SWITCH:
 38595 00008463 0000                    	dw	0			;AN000;  no match flags
 38596 00008465 0200                    	dw	2			;AN000;  capitalize - char table
 38597 00008467 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38598 00008469 [4584]                  	dw	NO_VALUES		;AN000;
 38599 0000846B 01                      	db	1			;AN000;  1 keyword
 38600                                  SLASH_P_SYN:
 38601 0000846C 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38602                                  
 38603                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38604                                  
 38605                                  ; The following parse control block can be used for any command which
 38606                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38607                                  ; the equal sign as an additional delimiter. Returns verified result
 38608                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38609                                  ; internal commands.
 38610                                  
 38611                                  PARSE_BREAK:
 38612 0000846F [7284]                  	dw	BREAK_PARMS		;AN000;
 38613 00008471 00                      	db	0			;AN032; no extra delimiter
 38614                                  
 38615                                  BREAK_PARMS:
 38616 00008472 0001                    	db	0,1			;AN000;  1 positional parm
 38617 00008474 [7884]                  	dw	BREAK_CONTROL1		;AN000;
 38618 00008476 00                      	db	0			;AN000;  no switches
 38619 00008477 00                      	db	0			;AN000;  no keywords
 38620                                  
 38621                                  BREAK_CONTROL1:
 38622 00008478 0120                    	dw	2001h			;AN000;  string value - optional
 38623 0000847A 0200                    	dw	2			;AN000;  capitalize - char table
 38624 0000847C [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38625 0000847E [8184]                  	dw	BREAK_VALUES		;AN000;
 38626 00008480 00                      	db	0			;AN000;  no keywords
 38627                                  
 38628                                  BREAK_VALUES:
 38629 00008481 03                      	db	3			;AN000;
 38630 00008482 00                      	db	0			;AN000;  no ranges
 38631 00008483 00                      	db	0			;AN000;  no numeric values
 38632 00008484 02                      	db	2			;AN000;  2 string values
 38633 00008485 00                      	db	0			;AN000;  returned if ON
 38634 00008486 [8B84]                  	dw	BREAK_ON		;AN000;  point to ON string
 38635 00008488 66                      	db	'f'                     ;AN000;  returned if OFF
 38636 00008489 [8E84]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38637                                  
 38638                                  BREAK_ON:
 38639 0000848B 4F4E00                  	db	"ON",0                  ;AN000;
 38640                                  BREAK_OFF:
 38641 0000848E 4F464600                	db	"OFF",0                 ;AN000;
 38642                                  
 38643                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38644                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38645                                  
 38646                                  ; PARSE BLOCK FOR CHCP
 38647                                  
 38648                                  ; The following parse control block can be used for any command which
 38649                                  ; needs only one optional three digit decimal parameter for operands.
 38650                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38651                                  ; CHCP internal command.
 38652                                  
 38653                                  CHCP_MINVAL	EQU	100			;AN000;
 38654                                  CHCP_MAXVAL	EQU	999			;AN000;
 38655                                  
 38656                                  PARSE_CHCP:
 38657 00008492 [9584]                  	dw	CHCP_PARMS			;AN000;
 38658 00008494 00                      	db	0				;AN000;  no extra delimiter
 38659                                  CHCP_PARMS:
 38660 00008495 0001                    	db	0,1				;AN000;  1 positional parm
 38661 00008497 [9B84]                  	dw	CHCP_CONTROL1			;AN000;
 38662 00008499 00                      	db	0				;AN000;  no switches
 38663 0000849A 00                      	db	0				;AN000;  no keywords
 38664                                  
 38665                                  CHCP_CONTROL1:
 38666 0000849B 0180                    	dw	8001h				;AN000;  numeric value - optional
 38667 0000849D 0000                    	dw	0				;AN000;  no function flags
 38668 0000849F [4F95]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38669 000084A1 [A484]                  	dw	CHCP_VALUES			;AN000;
 38670 000084A3 00                      	db	0				;AN000;  no keywords
 38671                                  
 38672                                  CHCP_VALUES:
 38673 000084A4 01                      	db	1				;AN000;
 38674 000084A5 01                      	db	1				;AN000;  1 range
 38675 000084A6 01                      	db	1				;AN000;  returned if result
 38676 000084A7 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38677 000084AF 00                      	db	0				;AN000;  no numeric values
 38678 000084B0 00                      	db	0				;AN000;  no string values
 38679                                  
 38680                                  ; PARSE BLOCK FOR DATE
 38681                                  
 38682                                  ; The following parse control block can be used for any command which
 38683                                  ; needs only an optional date string as an operand. Returns unverified
 38684                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38685                                  
 38686                                  PARSE_DATE:
 38687 000084B1 [B484]                  	dw	DATE_PARMS			;AN000;
 38688 000084B3 00                      	db	0				;AN000;  no extra delimiter
 38689                                  DATE_PARMS:
 38690 000084B4 0001                    	db	0,1				;AN000;  1 positional parm
 38691 000084B6 [BA84]                  	dw	DATE_CONTROL1			;AN000;
 38692 000084B8 00                      	db	0				;AN000;  no switches
 38693 000084B9 00                      	db	0				;AN000;  no keywords
 38694                                  
 38695                                  DATE_CONTROL1:
 38696 000084BA 0110                    	dw	1001h				;AN000;  date - optional
 38697 000084BC 0000                    	dw	0				;AN000;  no function flags
 38698 000084BE [5795]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38699 000084C0 [4584]                  	dw	NO_VALUES			;AN000;
 38700 000084C2 00                      	db	0				;AN000;  no keywords
 38701                                  
 38702                                  ; PARSE BLOCK FOR TIME
 38703                                  
 38704                                  ; The following parse control block can be used for any command which
 38705                                  ; needs only an optional time string as an operand. Returns unverified
 38706                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38707                                  
 38708                                  PARSE_TIME:
 38709 000084C3 [C684]                  	dw	TIME_PARMS			;AN000;
 38710 000084C5 00                      	db	0				;AN000;  no extra delimiter
 38711                                  TIME_PARMS:
 38712 000084C6 0001                    	db	0,1				;AN000;  1 positional parm
 38713 000084C8 [CC84]                  	dw	TIME_CONTROL1			;AN000;
 38714 000084CA 00                      	db	0				;AN000;  no switches
 38715 000084CB 00                      	db	0				;AN000;  no keywords
 38716                                  
 38717                                  TIME_CONTROL1:
 38718 000084CC 0108                    	dw	0801h				;AN000;  TIME - optional
 38719 000084CE 0000                    	dw	0				;AN000;  no function flags
 38720 000084D0 [5F95]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38721 000084D2 [4584]                  	dw	NO_VALUES			;AN000;
 38722 000084D4 00                      	db	0				;AN000;  no keywords
 38723                                  
 38724                                  ; PARSE BLOCK FOR VOL
 38725                                  
 38726                                  ; The following parse control block can be used for any command which
 38727                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38728                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38729                                  ; internal command.
 38730                                  
 38731                                  PARSE_VOL:
 38732 000084D5 [D884]                  	dw	VOL_PARMS			;AN000;
 38733 000084D7 00                      	db	0				;AN000;  no extra delimiter
 38734                                  VOL_PARMS:
 38735 000084D8 0001                    	db	0,1				;AN000;  1 positional parm
 38736 000084DA [DE84]                  	dw	DRIVE_CONTROL1			;AN000;
 38737 000084DC 00                      	db	0				;AN000;  no switches
 38738 000084DD 00                      	db	0				;AN000;  no keywords
 38739                                  
 38740                                  DRIVE_CONTROL1:
 38741 000084DE 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38742 000084E0 0100                    	dw	1				;AN000;  capitalize - file table
 38743 000084E2 [6795]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38744 000084E4 [4584]                  	dw	NO_VALUES			;AN000;
 38745 000084E6 00                      	db	0				;AN000;  no keywords
 38746                                  
 38747                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38748                                  
 38749                                  ; The following parse control block can be used for any command which
 38750                                  ; needs only one required file specification as an operand. Returns a
 38751                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38752                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38753                                  
 38754                                  PARSE_MRDIR:
 38755 000084E7 [EA84]                  	dw	MRDIR_PARMS			;AN000;
 38756 000084E9 00                      	db	0				;AN000;  no extra delimiter
 38757                                  MRDIR_PARMS:
 38758 000084EA 0101                    	db	1,1				;AN000;  1 positional parm
 38759 000084EC [4884]                  	dw	FILE_REQUIRED			;AN000;
 38760 000084EE 00                      	db	0				;AN000;  no switches
 38761 000084EF 00                      	db	0				;AN000;  no keywords
 38762                                  
 38763                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38764                                  
 38765                                  ; The following parse control block can be used for any command which
 38766                                  ; needs only one optional file specification an operand. Returns a
 38767                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38768                                  ; for the CHDIR and TRUENAME internal commands.
 38769                                  
 38770                                  PARSE_CHDIR:
 38771 000084F0 [F384]                  	dw	CHDIR_PARMS			;AN000;
 38772 000084F2 00                      	db	0				;AN000;  no extra delimiter
 38773                                  CHDIR_PARMS:
 38774 000084F3 0001                    	db	0,1				;AN000;  1 positional parm
 38775 000084F5 [5184]                  	dw	FILE_OPTIONAL			;AN000;
 38776 000084F7 00                      	db	0				;AN000;  no switches
 38777 000084F8 00                      	db	0				;AN000;  no keywords
 38778                                  
 38779                                  ; PARSE BLOCK FOR ERASE
 38780                                  
 38781                                  ; The following parse control block is used for the DEL/ERASE internal
 38782                                  ; commands. This command has one required file specification and an
 38783                                  ; optional switch (/p) as operands. The verified switch or unverified
 38784                                  ; file specification is returned in PARSE1_OUTPUT.
 38785                                  
 38786                                  PARSE_ERASE:
 38787 000084F9 [FC84]                  	dw	ERASE_PARMS			;AN000;
 38788 000084FB 00                      	db	0				;AN000;  no extra delimiter
 38789                                  
 38790                                  ERASE_PARMS:
 38791 000084FC 0101                    	db	1,1				;AN000;  1 positional parm
 38792 000084FE [4884]                  	dw	FILE_REQUIRED			;AN000;
 38793 00008500 01                      	db	1				;AN000;  1 switch
 38794 00008501 [6384]                  	dw	SLASH_P_SWITCH			;AN000;
 38795 00008503 00                      	db	0				;AN000;  no keywords
 38796                                  
 38797                                  ; PARSE BLOCK FOR DIR
 38798                                  
 38799                                  ; The following parse control block is used for the DIR internal command.
 38800                                  ; This command has one optional file specification and several optional
 38801                                  ; switches. Switches, switch values, and the filespec are returned in 
 38802                                  ; PARSE1_OUTPUT.
 38803                                  ;
 38804                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38805                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38806                                  ; do not require colons, and are not checked against a value list.
 38807                                  ;
 38808                                  ; Switch /h has been removed from the DIR command	;M008
 38809                                  ; Switch /? is no longer handled internally		;M008
 38810                                  ;
 38811                                  ; A list of pointers to all the switch synonyms is provided here to
 38812                                  ; help identify which switch has been matched.
 38813                                  
 38814                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38815                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38816                                  
 38817                                  PARSE_DIR:
 38818 00008504 [0785]                  	dw	DIR_PARMS
 38819 00008506 00                      	db	0			; no extra delimiters
 38820                                  DIR_PARMS:
 38821 00008507 0001                    	db	0,1			; 1 optional positional param
 38822 00008509 [5A84]                  	dw	FILE_OPTIONAL2
 38823 0000850B 02                      	db	2			; 2 kinds of switches
 38824 0000850C [1185]                  	dw	DIR_SW_VALUED
 38825 0000850E [2085]                  	dw	DIR_SW_UNVALUED
 38826 00008510 00                      	db	0			; no keywords
 38827                                  
 38828                                  DIR_SW_VALUED:
 38829 00008511 0120                    	dw	2001h			; optional string value
 38830 00008513 2100                    	dw	21h			; optional colon; capitalize 
 38831 00008515 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 38832 00008517 [4784]                  	dw	NULL_VALUE_LIST		; don't validate value
 38833                                  
 38834 00008519 02                      	db	2
 38835                                  
 38836                                  ; MSDOS 6.0 COMMAND.COM
 38837                                  ;ifdef DBLSPACE_HOOKS
 38838                                  ;	db	3		; 3 'synonyms'
 38839                                  ;else
 38840                                  ;	db	2		; 2 'synonyms'
 38841                                  ;endif
 38842                                  
 38843                                  DIR_SW_A:
 38844 0000851A 2F4100                  	db	"/A",0
 38845                                  DIR_SW_O:
 38846 0000851D 2F4F00                  	db	"/O",0
 38847                                  
 38848                                  ; MSDOS 6.0 COMMAND.COM
 38849                                  ;ifdef DBLSPACE_HOOKS
 38850                                  ;DIR_SW_C	db	"/C",0
 38851                                  ;endif
 38852                                  
 38853                                  DIR_SW_UNVALUED:
 38854 00008520 0000                    	dw	0			; no value
 38855 00008522 0000                    	dw	0			; no format functions
 38856 00008524 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 38857 00008526 [4584]                  	dw	NO_VALUES
 38858                                  
 38859                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38860                                  	;db	12
 38861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38862 00008528 0E                      	db	14		; 14 'synonyms' !?
 38863                                  
 38864                                  ; MSDOS 6.0 COMMAND.COM
 38865                                  ;ifdef DBLSPACE_HOOKS
 38866                                  ;	db	13		; 13 'synonyms'
 38867                                  ;else
 38868                                  ;	db	12		; 12 'synonyms'
 38869                                  ;endif
 38870                                  
 38871                                  DIR_SW_NEG_A:
 38872 00008529 2F2D4100                	db	"/-A",0
 38873                                  DIR_SW_NEG_O:
 38874 0000852D 2F2D4F00                	db	"/-O",0
 38875                                  DIR_SW_S:
 38876 00008531 2F5300                  	db	"/S",0
 38877                                  DIR_SW_NEG_S:
 38878 00008534 2F2D5300                	db	"/-S",0
 38879                                  DIR_SW_B:
 38880 00008538 2F4200                  	db	"/B",0
 38881                                  DIR_SW_NEG_B:
 38882 0000853B 2F2D4200                	db	"/-B",0
 38883                                  DIR_SW_W:
 38884 0000853F 2F5700                  	db	"/W",0
 38885                                  DIR_SW_NEG_W:
 38886 00008542 2F2D5700                	db	"/-W",0
 38887                                  DIR_SW_P:
 38888 00008546 2F5000                  	db	"/P",0
 38889                                  DIR_SW_NEG_P:
 38890 00008549 2F2D5000                	db	"/-P",0
 38891                                  DIR_SW_L:
 38892 0000854D 2F4C00                  	db	"/L",0		;M010
 38893                                  DIR_SW_NEG_L:
 38894 00008550 2F2D4C00                	db	"/-L",0 	;M010
 38895                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38896                                  ;DIR_SW_NEG_C:
 38897                                  ;	db	"/-C",0
 38898                                  
 38899                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38900                                  ; identification. Order is critical - DIR routines rely on the
 38901                                  ; specific order in this list. Negated options appear at odd 
 38902                                  ; positions in the list, and simple on/off options appear first.
 38903                                  
 38904                                  Dir_Sw_Ptrs:
 38905                                  	; MSDOS 5.0 COMMAND.COM
 38906 00008554 [4285]                  	dw	DIR_SW_NEG_W 
 38907                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38908                                  	; MSDOS 6.0 COMMAND.COM
 38909                                  	;dw	DIR_SW_NEG_C
 38910                                  	;dw	DIR_SW_C
 38911                                  	;dw	DIR_SW_NEG_W
 38912                                  	
 38913 00008556 [3F85]                  	dw	DIR_SW_W
 38914 00008558 [4985]                  	dw	DIR_SW_NEG_P
 38915 0000855A [4685]                  	dw	DIR_SW_P
 38916 0000855C [3485]                  	dw	DIR_SW_NEG_S
 38917 0000855E [3185]                  	dw	DIR_SW_S
 38918 00008560 [3B85]                  	dw	DIR_SW_NEG_B
 38919 00008562 [3885]                  	dw	DIR_SW_B
 38920 00008564 [5085]                  	dw	DIR_SW_NEG_L	;M010
 38921 00008566 [4D85]                  	dw	DIR_SW_L	;M010
 38922 00008568 [2D85]                  	dw	DIR_SW_NEG_O
 38923 0000856A [1D85]                  	dw	DIR_SW_O
 38924 0000856C [2985]                  	dw	DIR_SW_NEG_A
 38925 0000856E [1A85]                  	dw	DIR_SW_A
 38926                                  
 38927                                  ; PARSE BLOCK FOR RENAME
 38928                                  
 38929                                  ; The following parse control block can be used for any command which
 38930                                  ; needs only two required file specifications as operands. Returns
 38931                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38932                                  ; Currently used for the RENAME internal command.
 38933                                  
 38934                                  PARSE_RENAME:
 38935 00008570 [7385]                  	dw	RENAME_PARMS		;AN000;
 38936 00008572 00                      	db	0			;AN000;  no extra delimiter
 38937                                  RENAME_PARMS:
 38938 00008573 0202                    	db	2,2			;AN000;  2 positional parms
 38939 00008575 [4884]                  	dw	FILE_REQUIRED		;AN000;
 38940 00008577 [4884]                  	dw	FILE_REQUIRED		;AN000;
 38941 00008579 00                      	db	0			;AN000;  no switches
 38942 0000857A 00                      	db	0			;AN000;  no keywords
 38943                                  
 38944                                  ; PARSE BLOCK FOR CTTY
 38945                                  
 38946                                  ; The following parse control block can be used for any command which
 38947                                  ; needs one required device name as an operand. Returns a pointer to
 38948                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38949                                  ; internal command.
 38950                                  
 38951                                  PARSE_CTTY:
 38952 0000857B [7E85]                  	dw	CTTY_PARMS		;AN000;
 38953 0000857D 00                      	db	0			;AN000;  no extra delimiter
 38954                                  CTTY_PARMS:
 38955 0000857E 0101                    	db	1,1			;AN000;  1 positional parm
 38956 00008580 [8485]                  	dw	CTTY_CONTROL1		;AN000;
 38957 00008582 00                      	db	0			;AN000;  no switches
 38958 00008583 00                      	db	0			;AN000;  no keywords
 38959                                  CTTY_CONTROL1:
 38960 00008584 0020                    	dw	2000h			;AN000;  string value - required
 38961 00008586 1100                    	dw	11h			;AN000;  capitalize - file table
 38962                                  					;AN000;  remove colon at end
 38963 00008588 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38964 0000858A [4584]                  	dw	NO_VALUES		;AN000;
 38965 0000858C 00                      	db	0			;AN000;  no keywords
 38966                                  
 38967                                  ; PARSE BLOCK FOR VER
 38968                                  
 38969                                  ; The following parse control block can be used for any command which
 38970                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38971                                  
 38972                                  PARSE_VER:
 38973 0000858D [9085]                  	dw	VER_PARMS
 38974 0000858F 00                      	db	0			; no extra delimiters
 38975                                  VER_PARMS:
 38976 00008590 0000                    	db	0,0			; no positional parameters
 38977                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 38978                                  %if 0	; PCDOS 7.1 (& MSDOS 5.0-6.22) COMMAND.COM 
 38979                                  	db	1			; one switch
 38980                                  	dw	SLASH_R
 38981                                  %else
 38982                                  	; 20/07/2024 - Retro DOS v4-v5 COMMAND.COM
 38983 00008592 02                      	db	2			; two switches
 38984 00008593 [9885]                  	dw	SLASH_R
 38985 00008595 [A485]                  	dw	SLASH_T ; Retro DOS v4-v5 COMMAND.COM switch
 38986                                  %endif
 38987 00008597 00                      	db	0			; no keywords
 38988                                  SLASH_R:
 38989 00008598 0000                    	dw	0			; no values
 38990 0000859A 0200                    	dw	2			; capitalize by filename table
 38991 0000859C [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 38992 0000859E [4584]                  	dw	NO_VALUES		; no values
 38993 000085A0 01                      	db	1			; one synonym
 38994                                  SLASH_R_SYN:
 38995 000085A1 2F5200                  	db	"/R",0
 38996                                  
 38997                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 38998                                  %if 1
 38999                                  SLASH_T:
 39000 000085A4 0000                    	dw	0			; no values
 39001 000085A6 0200                    	dw	2			; capitalize by filename table
 39002 000085A8 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 39003 000085AA [4584]                  	dw	NO_VALUES		; no values
 39004 000085AC 01                      	db	1			; one synonym
 39005                                  SLASH_T_SYN:
 39006 000085AD 2F5400                  	db	"/T",0
 39007                                  %endif
 39008                                  
 39009                                  ; M003 ; Start of changes for LoadHigh support
 39010                                  
 39011                                  ;Parse Control Block for LOADHIGH command
 39012                                  
 39013                                  Parse_LoadHi:
 39014 000085B0 [B385]                  	dw	LoadHi_Parms		;extended parm table
 39015 000085B2 00                      	db	0			;no extra delimiters
 39016                                  
 39017                                  LoadHi_Parms:
 39018 000085B3 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 39019 000085B5 [4884]                  	dw	FILE_REQUIRED		;control struc for filename
 39020 000085B7 00                      	db	0			;no switches
 39021 000085B8 00                      	db	0			;no keywords
 39022                                  
 39023                                  ; M003 ; End of changes for LoadHigh support
 39024                                  
 39025                                  TempVarName:
 39026 000085B9 54454D503D00            	db	"TEMP=",0
 39027                                  
 39028                                  ; ---------------------------------------------------------------------------
 39029                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 39030                                  %if 1
 39031 000085BF 0D0A                    RD4CMD_VER_MSG:	db 0Dh,0Ah
 39032 000085C1 526574726F20444F53-     		db 'Retro DOS v4 COMMAND.COM'
 39032 000085CA 20763420434F4D4D41-
 39032 000085D3 4E442E434F4D       
 39033 000085D9 0D0A                    		db 0Dh,0Ah 
 39034 000085DB 32303234202D204572-     		db '2024 - Erdogan Tan'
 39034 000085E4 646F67616E2054616E 
 39035 000085ED 0D0A                    		db 0Dh,0Ah
 39036 000085EF 24                      		db '$'
 39037                                  %endif
 39038                                  ; ---------------------------------------------------------------------------
 39039                                  
 39040                                  	; 16/04/2023
 39041                                  TRANDATAEND:		; TRANGROUP:88C2h
 39042                                  
 39043                                  ;============================================================================
 39044                                  ; PSDATA.INC, MSDOS 6.0, 1991
 39045                                  ;============================================================================
 39046                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39047                                  
 39048                                  ; 18/04/2023
 39049                                  TRANSPACESTART:
 39050                                  
 39051                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 39052                                  
 39053                                  ;********************** Local Data *************************************
 39054                                  
 39055                                  $P_ORDINAL:
 39056 000085F0 0000                    	dw	0		;AN000; Operand ordinal save area
 39057                                  $P_RC:
 39058 000085F2 0000                    	dw	0		;AN000; Return code from parser
 39059                                  $P_SI_Save:
 39060 000085F4 0000                    	dw	0		;AN000; Pointer of command buffer
 39061                                  $P_DX:
 39062 000085F6 0000                    	dw	0		;AN000; Return result buffer address
 39063                                  $P_Terminator:
 39064 000085F8 00                      	db	0		;AN000; Terminator code (ASCII)
 39065                                  $P_DBCSEV_OFF:
 39066 000085F9 0000                    	dw	0		;AN000; Offset of DBCS EV
 39067                                  $P_DBCSEV_SEG:
 39068 000085FB 0000                    	dw	0		;AN000; Segment of DBCS EV
 39069                                  $P_Flags:			;AN000; Parser internal flags
 39070                                  $P_Flags1:
 39071 000085FD 00                      	db	0		;AN038; to reference first byte flags
 39072                                  $P_Flags2:
 39073 000085FE 00                      	db	0		;AN038; to reference second byte flags only
 39074                                  $P_SaveSI_Cmpx:
 39075 000085FF 0000                    	dw	0		;AN000; save si for later use by complex
 39076                                  $P_KEYorSW_Ptr:
 39077 00008601 0000                    	dw	0		;AN000; points next to "=" or ":" code
 39078                                  $P_Save_EOB:
 39079 00008603 0000                    	dw	0		;AN000; save pointer to EOB
 39080                                  $P_Found_SYNONYM:
 39081 00008605 0000                    	dw	0		;AN000; es:@ points to found synonym
 39082                                  $P_STRING_BUF:
 39083 00008607 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 39084                                  $P_ORIG_ORD:
 39085 00008687 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 39086                                  $P_ORIG_STACK:
 39087 00008689 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 39088                                  $P_ORIG_SI:
 39089 0000868B 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 39090                                  $P_Got_Time:
 39091 0000868D 00                      	db	0		;AN023; if 1, use Time delimiters
 39092                                  $P_Country_Info:
 39093 0000868E FFFF                    	dw	-1 ; 0FFFFh
 39094 00008690 00<rep 20h>             	times	32 db 0	
 39095                                  $P_1st_Val:
 39096 000086B0 0000                    	dw	0		;AN000; used when process date or time
 39097                                  $P_2nd_Val:
 39098 000086B2 0000                    	dw	0		;AN000; used when process date or time
 39099                                  $P_3rd_Val:
 39100 000086B4 0000                    	dw	0		;AN000; used when process date or time
 39101                                  $P_4th_Val:
 39102 000086B6 0000                    	dw	0		;AN000; used when process date or time
 39103                                  $P_Char_CAP_Ptr:
 39104 000086B8 FF                      	db	0FFh		;AN000; info id
 39105 000086B9 0000                    	dw	0		;AN000; offset	of char case map table
 39106 000086BB 0000                    	dw	0		;AN000; segment of char case map table
 39107                                  $P_File_CAP_Ptr:
 39108 000086BD FF                      	db	0FFh		;AN000; info id
 39109 000086BE 0000                    	dw	0		;AN000; offset	of file case map table
 39110 000086C0 0000                    	dw	0		;AN000; segment of file case map table
 39111                                  
 39112                                  	; 18/04/2023
 39113                                  ;M029
 39114                                  ;!!!WARNING!!!
 39115                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 39116                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 39117                                  ;changes need to be made in SYSPARSE
 39118                                  
 39119                                  $P_FileSp_Char:
 39120 000086C2 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 39121                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 39122                                  
 39123                                  ;filespec error flag
 39124                                  $P_err_flag:
 39125 000086CB 00                      	db	0		;AN033; flag set if filespec parsing error
 39126                                  				;AN033;  was detected.
 39127                                  
 39128                                  ;============================================================================
 39129                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 39130                                  ;============================================================================
 39131                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39132                                  
 39133                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 39134                                  
 39135                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39136                                  ;;
 39137                                  ;; STRUCTURE: $M_RES_ADDRS
 39138                                  ;;
 39139                                  ;; Resident data area definition of variables
 39140                                  ;;
 39141                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39142                                  
 39143                                  $M_RT:
 39144 000086CC 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 39145                                  
 39146                                  ;============================================================================
 39147                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 39148                                  ;============================================================================
 39149                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39150                                  
 39151                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 39152                                  ; ---------------------------------------------------------------------------
 39153                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 39154                                  ;;M031 - changed copyright to 1991
 39155                                  ;;9/16 - changed version to 6.0 and copyright to 1992
 39156                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 39157                                  ;;B49,50 - changed version to 6 and copyright to 1993
 39158                                  ; ---------------------------------------------------------------------------
 39159                                  
 39160                                  ;;ifdef USA
 39161                                  ;MsDosVer6_CCopy:
 39162                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 39163                                  ;	db	"Licensed Material - Property of Microsoft "
 39164                                  ;	db	"All rights reserved "
 39165                                  ;endif
 39166                                  
 39167                                  ; 15/04/2023
 39168                                  MsDosVer5_CCopy:
 39169 00008759 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 39169 00008762 7273696F6E20352E30-
 39169 0000876B 3020284329436F7079-
 39169 00008774 726967687420313938-
 39169 0000877D 312D31393931204D69-
 39169 00008786 63726F736F66742043-
 39169 0000878F 6F727020           
 39170 00008793 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 39170 0000879C 4D6174657269616C20-
 39170 000087A5 2D2050726F70657274-
 39170 000087AE 79206F66204D696372-
 39170 000087B7 6F736F667420       
 39171 000087BD 416C6C207269676874-     	db	"All rights reserved "
 39171 000087C6 732072657365727665-
 39171 000087CF 6420               
 39172                                  ; ---------------------------------------------------------------------------
 39173                                  ; 15/04/2023
 39174                                  	; 16/04/2023 - 21/04/2023
 39175                                  	;db 	0
 39176                                  	;db	0Dh,0Ah
 39177                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 39178                                  	;db	0
 39179                                  	;db	'by Erdogan Tan - 05/05/2023'
 39180                                  	;db	0
 39181                                  
 39182                                  ;============================================================================
 39183                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 39184                                  ;============================================================================
 39185                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39186                                  
 39187                                  PRINTF_HANDLE:
 39188 000087D1 0000                    	dw	0		;AC000;
 39189                                  
 39190                                  ; 15/047/2023
 39191                                  %if 0
 39192                                  
 39193                                  ;============================================================================
 39194                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39195                                  ;============================================================================
 39196                                  ; 29/09/2018 - Retro DOS v3.0
 39197                                  
 39198                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39199                                  
 39200                                  ;The TRANSPACE segment contains variable data that is considered
 39201                                  ;volatile between command cycles, and therefore is not included in the
 39202                                  ;transient checksum area. Contents of these variables MUST be
 39203                                  ;initialized before use, and must not be relied upon from command
 39204                                  ;cycle to command cycle.
 39205                                  ;
 39206                                  ;No constant data values should be stored here.
 39207                                  
 39208                                  ; ---------------------------------------------------------------------------
 39209                                  ; START OF UNITIALIZED DATA
 39210                                  ; ---------------------------------------------------------------------------
 39211                                  
 39212                                  ;	times 12 db 0
 39213                                  
 39214                                  align 16
 39215                                  
 39216                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 39217                                  
 39218                                  PRINTF_LEFT:	db 0
 39219                                  PRINTF_LONG:	db 0
 39220                                  PRINTF_HEX:	db 0
 39221                                  TABLE_INDEX:	db 0
 39222                                  PRINTF_WIDTH:	dw 0
 39223                                  PRINTF_BASE:	dw 0
 39224                                  PAD_CHAR:	db 0
 39225                                  PRINTF_HANDLE:	dw 0
 39226                                  PRINTF_BUF: times 100 db 0
 39227                                  PRINTF_BUF_END: ; 30/09/2018
 39228                                  
 39229                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 39230                                  
 39231                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39232                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39233                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39234                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39235                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39236                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39237                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39238                                  
 39239                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39240                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 39241                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 39242                                  TPA:		dw 0			; LTPA	    (dw 0)	
 39243                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 39244                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 39245                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 39246                                  					; MYSEG1    (dw 0)	
 39247                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 39248                                  					; MYSEG2    (dw 0)	
 39249                                  		dw 0			; RESTEST   (dw 0)	
 39250                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 39251                                  
 39252                                  CHKDRV:		db 0
 39253                                  IFNOTFLAG:
 39254                                  FILTYP:
 39255                                  RDEOF:		db 0			; Misc flags
 39256                                  CURDRV:		db 0
 39257                                  PARM1:
 39258                                  Concat:		db 0
 39259                                  PARM2:
 39260                                  ArgC:		db 0
 39261                                  COMSW:		dw 0			; Switches between command and 1st arg
 39262                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 39263                                  ARG2S:					; Switches after 2nd arg		
 39264                                  DestSwitch:	dw 0
 39265                                  ARGTS:
 39266                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 39267                                  CFLAG:		db 0
 39268                                  DestClosed:
 39269                                  SPECDRV:	db 0
 39270                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 39271                                  NXTADD:		dw 0
 39272                                  FRSTSRCH:	db 0
 39273                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 39274                                  ;PerLine:	db 0			; entries/line u.b. DIR
 39275                                  LINCNT:		db 0
 39276                                  LINLEN:		db 0
 39277                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 39278                                  FILECNT:	dw 0			; file count u.b. DIR
 39279                                  ;FileSiz:	dd 0			; file size u.b. DIR
 39280                                  
 39281                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 39282                                  ;
 39283                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 39284                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 39285                                  
 39286                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 39287                                  
 39288                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 39289                                  DESTFCB2:
 39290                                  IDLEN:		db 0
 39291                                  ID:	  times	8  db 0
 39292                                  COM:	  times	3  db 0 
 39293                                  DEST:	  times 37 db 0
 39294                                  DESTNAME: times 11 db 0
 39295                                  DESTDIR:
 39296                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 39297                                  GOTOLEN:	; word
 39298                                  BWDBUF: 	; byte
 39299                                  EXEFCB: 	; word
 39300                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39301                                  
 39302                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39303                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39304                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39305                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39306                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39307                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39308                                  
 39309                                  SDIRBUF:  times 12 db 0	
 39310                                  _BITS:		dw 0
 39311                                  PATHCNT:	dw 0
 39312                                  PATHPOS:	dw 0
 39313                                  PATHSW:		dw 0
 39314                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 39315                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 39316                                  LINPERPAG:	db 0
 39317                                  		db 0
 39318                                  COMMA:		db 0			; flag set if +,, occurs
 39319                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 39320                                  
 39321                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 39322                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 39323                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 39324                                  
 39325                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 39326                                  STRING_PTR_1:	dw 0	   ; _4468h	
 39327                                  FILESIZE_L:	dw 0	   ; _446Ah		
 39328                                  FILESIZE_H:	dw 0	   ; _446Ch	
 39329                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 39330                                  
 39331                                  COPY_NUM:	dw 0
 39332                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 39333                                  CPYFLAG:	db 0
 39334                                  DIR_NUM:	dw 0
 39335                                  BYTES_FREE:	dw 0
 39336                                  		dw 0
 39337                                  MAJOR_VER_NUM:	dw 0
 39338                                  MINOR_VER_NUM:	dw 0
 39339                                  ONE_CHAR_VAL:	db 0
 39340                                  		;db 0
 39341                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 39342                                  VOL_DRV:	db 0
 39343                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 39344                                  
 39345                                  ROM_CALL:	db 0			; flag for rom function
 39346                                  ROM_IP:		dw 0
 39347                                  ROM_CS:		dw 0
 39348                                  
 39349                                  DestVars:
 39350                                  DestIsDir:	db 0
 39351                                  DestSiz:	db 0
 39352                                  DestTail:	dw 0
 39353                                  DestInfo:	db 0
 39354                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 39355                                  ENDDESTBUF:
 39356                                  
 39357                                  DESTHAND:	dw 0
 39358                                  DESTISDEV:	db 0
 39359                                  FIRSTDEST:	db 0
 39360                                  MELCOPY:	db 0
 39361                                  MELSTART:	dw 0
 39362                                  
 39363                                  SrcVars:
 39364                                  SrcIsDir:	db 0
 39365                                  SrcSiz:		db 0
 39366                                  SrcTail:	dw 0
 39367                                  SrcInfo:	db 0
 39368                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 39369                                  
 39370                                  SRCHAND:	dw 0
 39371                                  SRCISDEV:	db 0
 39372                                  
 39373                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 39374                                  
 39375                                  SRCPT:		dw 0
 39376                                  INEXACT:	db 0
 39377                                  		db 0 ; MSDOS 3.3 
 39378                                  NOWRITE:	db 0
 39379                                  BINARY:		db 0
 39380                                  WRITTEN:	dw 0
 39381                                  TERMREAD:	db 0
 39382                                  ASCII:		db 0
 39383                                  PLUS:		db 0
 39384                                  OBJCNT:		db 0			; Used in copy
 39385                                  CPDATE:		dw 0
 39386                                  CPTIME:		dw 0
 39387                                  
 39388                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 39389                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 39390                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39391                                  
 39392                                  BATHAND:	dw 0			; Batch handle
 39393                                  STARTEL:	dw 0
 39394                                  ELCNT:		db 0
 39395                                  ELPOS:		db 0
 39396                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39397                                  MSDOS 5.0
 39398                                  SKPDEL:
 39399                                  SOURCE:   times	11 db 0
 39400                                  
 39401                                  ext_entered:	db 0			;AN005;
 39402                                  
 39403                                  ;display_ioctl	db 0			;AN000; info level
 39404                                  ;		db 0			;AN000; reserved
 39405                                  ;		dw crt_ioctl_ln		;AN000; length of data
 39406                                  ;		dw 0			;AN000; control flags
 39407                                  ;display_mode:	db 0			;AN000; display mode, colors
 39408                                  ;		db 0			;AN000; reserved
 39409                                  ;		dw 0			;AN023; colors
 39410                                  ;		dw 0			;AN000; display width (PELS)
 39411                                  ;		dw 0			;AN000; display length (PELS)
 39412                                  ;display_width:	dw 0			;AN000; display width
 39413                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 39414                                  ;
 39415                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 39416                                  ;		dw 0			;AN000; info level
 39417                                  ;vol_serial:	dd 0			;AN000; volume serial number
 39418                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39419                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 39420                                  
 39421                                  EXPAND_STAR:	db 0
 39422                                  
 39423                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 39424                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 39425                                  ;append_exec:	db 0			;AN041; set if internal append executed
 39426                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 39427                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 39428                                  
 39429                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 39430                                  
 39431                                  ; Data declarations taken out of parse.asm
 39432                                  
 39433                                  ; MSDOS 6.0
 39434                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39435                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39436                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 39437                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39438                                  ;comptr		dw	?		; ptr into combuf
 39439                                  
 39440                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 39441                                  ARG:
 39442                                  ARG_ARGV:
 39443                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 39444                                  ARGV0_ARG_FLAGS:  db 0
 39445                                  ARGV0_ARGSTARTEL: dw 0
 39446                                  ARGV0_ARGLEN:	  dw 0
 39447                                  ARGV0_ARGSW_WORD: dw 0
 39448                                  ARGV0_OCOMPTR:	  dw 0
 39449                                  
 39450                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 39451                                  	  times 5 db 0
 39452                                  ARGV1_ARGSW_WORD: dw 0
 39453                                  		  dw 0
 39454                                  
 39455                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 39456                                  	  times 5 db 0
 39457                                  ARGV2_ARGSW_WORD: dw 0
 39458                                  		  dw 0
 39459                                  
 39460                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 39461                                  	
 39462                                  ARG_ARGVCNT:	dw 0
 39463                                  ARG_ARGSWINFO:	dw 0
 39464                                  
 39465                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 39466                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 39467                                  
 39468                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 39469                                  
 39470                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 39471                                  TPBUF:	times 128 db 0			; temporary buffer
 39472                                  LASTARG:	dw 0			; point at which to accumulate switch info
 39473                                  COMPTR:		dw 0			; ptr into combuf
 39474                                  
 39475                                  ; Data declarations taken out of path.asm
 39476                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 39477                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 39478                                  ;psep_char	DB	?			; '/' or '\'
 39479                                  ;search_best	DB	(?)			; best code, best filename so far
 39480                                  ;fname_max_len	equ	13
 39481                                  ;search_best_buf DB	fname_max_len DUP (?)
 39482                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 39483                                  ;search_error	DW	(?)			; address of error message to be printed
 39484                                  
 39485                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39486                                  
 39487                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 39488                                  
 39489                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 39490                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 39491                                  PATHINFO:
 39492                                  PATHINFO_0:	dw 0
 39493                                  PATHINFO_2:	dw 0
 39494                                  PATHINFO_4:	dw 0
 39495                                  PSEP_CHAR:	db 0
 39496                                  SEARCH_BEST:	db 0
 39497                                  ;FNAME_MAX_LEN equ 13
 39498                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 39499                                  SEARCH_CURDIR_BUF: times 64 db 0
 39500                                  SEARCH_ERROR:	dw 0
 39501                                  
 39502                                  ; Data declarations taken out of tbatch.asm
 39503                                  
 39504                                  ;if_not_count	DW	?
 39505                                  ;
 39506                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39507                                  ;
 39508                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39509                                  
 39510                                  ; 31/03/2023
 39511                                  STACK:		;LABEL	WORD
 39512                                  
 39513                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 39514                                  
 39515                                  IF_NOT_COUNT:	dw 0
 39516                                  ZFLAG:		db 0
 39517                                  	  times 256 db 0 	
 39518                                  STACK:
 39519                                  
 39520                                  ;INTERNATVARS	internat_block <>
 39521                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39522                                  ;
 39523                                  ;;		Buffer for DOS function 64h (Get extended country information)
 39524                                  ;;		subfunctions 2, 4, 6, or 7:
 39525                                  ;
 39526                                  ;CountryPtrInfo	label	byte
 39527                                  ;CountryPtrId	db	?
 39528                                  ;CountryPtr	dd	?
 39529                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39530                                  
 39531                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 39532                                  
 39533                                  INTERNATVARS:	
 39534                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 39535                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39536                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 39537                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 39538                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 39539                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 39540                                  BIT_FIELD:	db 0			; Bit values
 39541                                  					;   Bit 0 = 0 if currency symbol first
 39542                                  					;	  = 1 if currency symbol last
 39543                                  					;   Bit 1 = 0 if No space after currency symbol
 39544                                  					;	  = 1 if space after currency symbol
 39545                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 39546                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39547                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39548                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39549                                  					;  in pieces.
 39550                                  DATA_SEP:	db 0,0			; Data list separator character		
 39551                                  
 39552                                  		times 8 db 0
 39553                                  ;
 39554                                  ; Max size of the block returned by the INTERNATIONAL call
 39555                                  ;
 39556                                  INTERNAT_BLOCK_SIZE EQU	32
 39557                                  
 39558                                  BATLEN equ 32
 39559                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 39560                                  
 39561                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 39562                                  
 39563                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 39564                                  
 39565                                  BATBUFEND:	dw 0
 39566                                  
 39567                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 39568                                  
 39569                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 39570                                  
 39571                                  ; 18/04/2023
 39572                                  ; ----------------------------------------------------------------------------
 39573                                  ; 09/01/2023
 39574                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 39575                                  
 39576                                  %endif
 39577                                  
 39578                                  ;============================================================================
 39579                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39580                                  ;============================================================================
 39581                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39582                                  
 39583                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39584                                  
 39585                                  ;The TRANSPACE segment contains variable data that is considered
 39586                                  ;volatile between command cycles, and therefore is not included in the
 39587                                  ;transient checksum area. Contents of these variables MUST be
 39588                                  ;initialized before use, and must not be relied upon from command
 39589                                  ;cycle to command cycle.
 39590                                  ;
 39591                                  ;No constant data values should be stored here.
 39592                                  
 39593                                  ; ---------------------------------------------------------------------------
 39594                                  ; START OF UNITIALIZED DATA
 39595                                  ; ---------------------------------------------------------------------------
 39596                                  
 39597                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 39598                                  
 39599 000087D3 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39600 0000882A 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39601 00008881 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39602 00008904 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39603 00008987 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39604 000089CD 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39605 00008A50 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39606                                  
 39607                                  ; Variables passed up from resident	; in the Resident portion: (initial values)
 39608                                  HEADCALL:
 39609 00008AA3 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 39610 00008AA5 0000                    RESSEG:	dw 0			; MYSEG     (dw 0)
 39611 00008AA7 0000                    TPA:	dw 0			; LTPA	    (dw 0)
 39612                                  SWITCHAR:
 39613 00008AA9 00                      	db 0			; RSWITCHAR (db '-')
 39614                                  DIRCHAR:
 39615 00008AAA 00                      	db 0			; RDIRCHAR  (db '/')
 39616                                  EXEC_ADDR:
 39617 00008AAB 00000000                	dd 0			; 	    (dw EXT_EXEC)
 39618                                  				; MYSEG1    (dw 0)
 39619                                  RCH_ADDR:
 39620 00008AAF 00000000                	dd 0			;	    (dw TREMCHECK)
 39621                                  				; MYSEG2    (dw 0)
 39622                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
 39623                                  %if 0
 39624                                  	dw 0			; RESTEST   (dw 0)
 39625                                  %endif
 39626                                  
 39627                                  TRAN_TPA:
 39628 00008AB3 0000                    	dw 0			; RES_TPA   (dw 0)
 39629                                  
 39630 00008AB5 00                      CHKDRV:	db 0
 39631                                  IFNOTFLAG:
 39632                                  FILTYP:
 39633 00008AB6 00                      RDEOF:	db 0			; Misc flags
 39634 00008AB7 00                      CURDRV:	db 0
 39635                                  PARM1:
 39636 00008AB8 00                      Concat:	db 0
 39637                                  PARM2:
 39638 00008AB9 00                      ArgC:	db 0
 39639 00008ABA 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39640 00008ABC 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39641                                  ARG2S:				; Switches after 2nd arg
 39642                                  DestSwitch:
 39643 00008ABE 0000                    	dw 0
 39644                                  ARGTS:
 39645                                  AllSwitch:
 39646 00008AC0 0000                    	dw 0			; ALL switches except for COMSW
 39647 00008AC2 00                      CFLAG:	db 0
 39648                                  DestClosed:
 39649                                  SPECDRV:
 39650 00008AC3 00                      	db 0
 39651 00008AC4 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39652 00008AC6 0000                    NXTADD:	dw 0
 39653                                  FRSTSRCH:
 39654 00008AC8 00                      	db 0
 39655                                  ; 15/04/2023
 39656                                  LeftOnLine:
 39657 00008AC9 00                      	db 0			; entries left on line u.b. DIR
 39658                                  PerLine:
 39659 00008ACA 00                      	db 0			; entries/line u.b. DIR
 39660                                  
 39661                                  ; 14/08/2024
 39662                                  %if 0
 39663                                  LINCNT:	db 0
 39664                                  LINLEN:	db 0
 39665                                  %endif
 39666                                  
 39667                                  LeftOnPage:
 39668 00008ACB 0000                    	dw 0			; lines left on page u.b. DIR
 39669                                  FileCnt:
 39670 00008ACD 0000                    	dw 0			; file count u.b. DIR
 39671                                  FileSiz:
 39672 00008ACF 00000000                	dd 0			; file size u.b. DIR
 39673                                  
 39674                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39675                                  
 39676                                  FileCntTotal:
 39677 00008AD3 00000000                	dd 0			; total file count u.b. DIR
 39678                                  FileSizTotal:
 39679 00008AD7 00000000                	dd 0			; total file size u.b. DIR
 39680                                  
 39681                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39682                                  CHARBUF:
 39683 00008ADB 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39684                                  DESTFCB2:
 39685 00008B2B 00                      IDLEN:	db 0
 39686 00008B2C 00<rep 8h>              ID:	times	8  db 0
 39687 00008B34 00<rep 3h>              COM:	times	3  db 0
 39688 00008B37 00<rep 25h>             DEST:	times	37 db 0
 39689                                  DESTNAME:
 39690 00008B5C 00<rep Bh>              	times	11 db 0
 39691                                  DESTDIR:
 39692                                  DestFcb:
 39693 00008B67 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39694                                  GOTOLEN: ; word
 39695                                  BWDBUF:  ; byte
 39696                                  EXEFCB:  ; word
 39697 00008BAA 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39698                                  
 39699                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39700                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39701                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39702                                  DIRBUF_FDATE   equ DIRBUF+32  ; word
 39703                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39704                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39705                                  
 39706                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39707                                  SDIRBUF:
 39708 00008BF0 00<rep Ch>              	times 12 db 0	
 39709                                  _Bits:
 39710 00008BFC 0000                    	dw 0
 39711                                  PathCnt:
 39712 00008BFE 0000                    	dw 0
 39713                                  PathPos:
 39714 00008C00 0000                    	dw 0
 39715 00008C02 0000                    PathSw:	dw 0
 39716                                  AttrSpecified:
 39717 00008C04 00                      	db 0			; attribute bits u.b. DIR
 39718                                  AttrSelect:
 39719 00008C05 00                      	db 0			; attribute bits u.b. DIR
 39720 00008C06 00                      comma:	db 0			; flag set if +,, occurs
 39721                                  plus_comma:
 39722 00008C07 00                      	db 0			; flag set if +,, occurs
 39723                                  DirFlag:
 39724 00008C08 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39725                                  parse_last:
 39726 00008C09 0000                    	dw 0			;AN018; used to hold parsing position
 39727                                  system_cpage:
 39728 00008C0B 0000                    	dw 0			;AC001; used for CHCP variable
 39729                                  ; 03/08/2024
 39730                                  ;Arg_Buf:
 39731                                  ;	times 128 db 0
 39732                                  File_Size_Low:
 39733 00008C0D 0000                    	dw 0
 39734                                  File_Size_High:
 39735 00008C0F 0000                    	dw 0
 39736                                  string_ptr_2:
 39737 00008C11 0000                    	dw 0
 39738                                  Copy_num:
 39739 00008C13 0000                    	dw 0
 39740                                  cpyflag:
 39741 00008C15 00                      	db 0
 39742                                  Dir_Num:
 39743 00008C16 0000                    	dw 0
 39744                                  Bytes_Free:
 39745 00008C18 00000000                	dd 0
 39746                                  
 39747                                  Major_Ver_Num:
 39748 00008C1C 0000                    	dw 0
 39749                                  Minor_Ver_Num:
 39750 00008C1E 0000                    	dw 0
 39751                                  
 39752                                  One_Char_Val:
 39753 00008C20 00                      	db 0
 39754 00008C21 00                      	db 0
 39755                                  vol_drv:
 39756 00008C22 00                      	db 0
 39757                                  ROM_CALL:
 39758 00008C23 00                      	db 0			; flag for rom function
 39759 00008C24 0000                    ROM_IP:	dw 0
 39760 00008C26 0000                    ROM_CS:	dw 0
 39761                                  
 39762                                  DestVars:
 39763                                  DestIsDir:
 39764 00008C28 00                      	db 0
 39765                                  DestSiz:
 39766 00008C29 00                      	db 0
 39767                                  DestTail:
 39768 00008C2A 0000                    	dw 0
 39769                                  DestInfo:
 39770 00008C2C 00                      	db 0
 39771                                  DestBuf:
 39772 00008C2D 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39773                                  EndDestBuf:
 39774                                  DESTHAND:
 39775 00008C84 0000                    	dw 0
 39776                                  DESTISDEV:
 39777 00008C86 00                      	db 0
 39778                                  FIRSTDEST:
 39779 00008C87 00                      	db 0
 39780                                  MELCOPY:
 39781 00008C88 00                      	db 0
 39782                                  MELSTART:
 39783 00008C89 0000                    	dw 0
 39784                                  SrcVars:
 39785                                  SrcIsDir:
 39786 00008C8B 00                      	db 0
 39787 00008C8C 00                      SrcSiz:	db 0
 39788                                  SrcTail:
 39789 00008C8D 0000                    	dw 0
 39790                                  SrcInfo:
 39791 00008C8F 00                      	db 0
 39792                                  SrcBuf:
 39793 00008C90 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39794                                  SRCHAND:
 39795 00008CE7 0000                    	dw 0
 39796                                  SRCISDEV:
 39797 00008CE9 00                      	db 0
 39798                                  ScanBuf:
 39799 00008CEA 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39800                                  
 39801 00008D41 0000                    SRCPT:	dw 0
 39802                                  INEXACT:
 39803 00008D43 00                      	db 0
 39804                                  NOWRITE:
 39805 00008D44 00                      	db 0
 39806                                  BINARY:
 39807 00008D45 00                      	db 0
 39808                                  WRITTEN:
 39809 00008D46 0000                    	dw 0
 39810                                  TERMREAD:
 39811 00008D48 00                      	db 0
 39812 00008D49 00                      ASCII:	db 0
 39813 00008D4A 00                      PLUS:	db 0
 39814 00008D4B 00                      objcnt:	db 0			; Used in copy
 39815 00008D4C 0000                    CPDATE:	dw 0
 39816 00008D4E 0000                    CPTIME:	dw 0
 39817                                  
 39818                                  OFilePtr_Lo:
 39819 00008D50 0000                    	dw 0			; original file ptr for COPY when
 39820                                  OFilePtr_Hi:
 39821 00008D52 0000                    	dw 0			; 1st source is also destination
 39822                                  zflag:	; 10/08/2024 - PCDOS 7.1 COMMAND.COM
 39823 00008D54 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39824                                  BATHAND:
 39825 00008D55 0000                    	dw 0			; Batch handle
 39826                                  STARTEL:
 39827 00008D57 0000                    	dw 0
 39828 00008D59 00                      ELCNT:	db 0
 39829 00008D5A 00                      ELPOS:	db 0
 39830                                  
 39831                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39832                                  ; MSDOS 5.0
 39833                                  SKPDEL:
 39834 00008D5B 00<rep Bh>              SOURCE:	times 11 db 0
 39835                                  
 39836                                  ext_entered:
 39837 00008D66 00                      	db 0			;AN005;
 39838                                  
 39839                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39840                                  
 39841                                  Display_Ioctl:
 39842 00008D67 00                      	db 0			;AN000; info level
 39843 00008D68 00                      	db 0			;AN000; reserved
 39844 00008D69 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39845 00008D6B 0000                    	dw 0			;AN000; control flags
 39846                                  display_mode:
 39847 00008D6D 00                      	db 0			;AN000; display mode, colors
 39848 00008D6E 00                      	db 0			;AN000; reserved
 39849 00008D6F 0000                    	dw 0			;AN023; colors
 39850 00008D71 0000                    	dw 0			;AN000; display width (PELS)
 39851 00008D73 0000                    	dw 0			;AN000; display length (PELS)
 39852                                  display_width:
 39853 00008D75 0000                    	dw 0			;AN000; display width
 39854                                  LinPerPag:
 39855 00008D77 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39856                                  
 39857                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39858 00008D79 0000                    	dw 0			;AN000; info level
 39859                                  vol_serial:
 39860 00008D7B 00000000                	dd 0			;AN000; volume serial number
 39861                                  vol_label:
 39862 00008D7F 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39863 00008D8A 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39864                                  
 39865                                  expand_star:
 39866 00008D92 00                      	db 0
 39867                                  
 39868                                  msg_flag:
 39869 00008D93 00                      	db 0			;AN022; flag set if non-utility message issued
 39870                                  Msg_Numb:
 39871 00008D94 0000                    	dw 0			;AN022; set with extended error message issued
 39872                                  append_exec:
 39873 00008D96 00                      	db 0			;AN041; set if internal append executed
 39874                                  print_err_flag:
 39875 00008D97 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39876                                  subst_buffer:
 39877 00008D99 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39878                                  				;AN061;
 39879                                  ; 15/04/2023
 39880 00008DAF 00                      KPARSE:	db 0	; 3/3/KK	
 39881                                  
 39882                                  ; Data declarations taken out of parse.asm
 39883                                  
 39884                                  ; MSDOS 6.0
 39885                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39886                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39887                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39888                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39889                                  ;comptr		dw	?		; ptr into combuf
 39890                                  
 39891                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39892                                  ARG:
 39893                                  ARG_ARGV:
 39894                                  ARGV0_ARGPOINTER:
 39895 00008DB0 0000                    	dw 0	; ARGV[0]
 39896                                  ARGV0_ARG_FLAGS:
 39897 00008DB2 00                      	db 0
 39898                                  ARGV0_ARGSTARTEL:
 39899 00008DB3 0000                    	dw 0
 39900                                  ARGV0_ARGLEN:
 39901 00008DB5 0000                    	dw 0
 39902                                  ARGV0_ARGSW_WORD:
 39903 00008DB7 0000                    	dw 0
 39904                                  ARGV0_OCOMPTR:
 39905 00008DB9 0000                    	dw 0
 39906                                  ARGV1_ARGPOINTER:
 39907 00008DBB 0000                    	dw 0	; ARGV[1]	
 39908 00008DBD 00<rep 5h>              	times 5 db 0
 39909                                  ARGV1_ARGSW_WORD:
 39910 00008DC2 0000                    	dw 0
 39911 00008DC4 0000                    	dw 0
 39912                                  ARGV2_ARGPOINTER:
 39913 00008DC6 0000                    	dw 0	; ARGV[2]
 39914 00008DC8 00<rep 5h>              	times 5 db 0
 39915                                  ARGV2_ARGSW_WORD:
 39916 00008DCD 0000                    	dw 0
 39917 00008DCF 0000                    	dw 0
 39918 00008DD1 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39919                                  ARG_ARGVCNT:
 39920 00009070 0000                    	dw 0
 39921                                  ARG_ARGSWINFO:
 39922 00009072 0000                    	dw 0
 39923                                  ARG_ARGBUF:
 39924 00009074 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39925                                  ARG_ARGFORCOMBUF:
 39926 00009274 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39927                                  
 39928                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39929                                  ARGBUF_PTR:
 39930 000092F4 0000                    	dw 0			; index for argv[].argpointer
 39931                                  TPBUF:	;times 128 db 0		; temporary buffer
 39932                                  Arg_Buf:
 39933 000092F6 00<rep 80h>             	times 128 db 0	; 03/08/2024 (PCDOS 7.1 COMMAND.COM)
 39934                                  LASTARG:
 39935 00009376 0000                    	dw 0			; point at which to accumulate switch info
 39936 00009378 0000                    COMPTR:	dw 0			; ptr into combuf
 39937                                  
 39938                                  ; Data declarations taken out of path.asm
 39939                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39940                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39941                                  ;psep_char	DB	?		; '/' or '\'
 39942                                  ;search_best	DB	(?)		; best code, best filename so far
 39943                                  ;fname_max_len	equ	13
 39944                                  ;search_best_buf DB	fname_max_len DUP (?)
 39945                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39946                                  ;search_error	DW	(?)		; address of error message to be printed
 39947                                  
 39948                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39949                                  
 39950                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39951                                  
 39952 0000937A 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39953                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39954                                  pathinfo:
 39955                                  ;pathinfo_0:
 39956 000093A5 0000                    	dw 0
 39957                                  ;pathinfo_2:
 39958 000093A7 0000                    	dw 0
 39959                                  ;pathinfo_4:
 39960 000093A9 0000                    	dw 0
 39961                                  psep_char:
 39962 000093AB 00                      	db 0
 39963                                  search_best:
 39964 000093AC 00                      	db 0
 39965                                  FNAME_MAX_LEN equ 13
 39966                                  search_best_buf:
 39967 000093AD 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39968                                  search_curdir_buf:
 39969 000093BA 00<rep 40h>             	times 64 db 0
 39970                                  search_error:
 39971 000093FA 0000                    	dw 0
 39972                                  
 39973                                  ; Data declarations taken out of tbatch.asm
 39974                                  
 39975                                  ;if_not_count	DW	?
 39976                                  ;
 39977                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39978                                  ;
 39979                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39980                                  
 39981                                  ; 31/03/2023
 39982                                  ;STACK:	;LABEL	WORD
 39983                                  
 39984                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 39985                                  
 39986                                  IF_NOT_COUNT:
 39987 000093FC 0000                    	dw 0
 39988                                  ; 10/08/2024
 39989                                  ;zflag:	db 0
 39990                                  align 2
 39991 000093FE 00<rep 100h>            	times 256 db 0 
 39992                                  	; 16/04/2023
 39993                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 39994                                  STACK:
 39995                                  
 39996                                  ;INTERNATVARS	internat_block <>
 39997                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39998                                  
 39999                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 40000                                  INTERNATVARS:
 40001                                  		; (24+8 = 32 bytes)
 40002                                  DATE_TIME_FORMAT:
 40003 000094FE 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 40004                                  CURRENCY_SYM:
 40005 00009500 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 40006                                  THOUS_SEP:
 40007 00009505 0000                    	db 0,0			; Thousands separator 2 bytes
 40008                                  DECIMAL_SEP:
 40009 00009507 0000                    	db 0,0			; Decimal separator 2 bytes
 40010                                  DATE_SEP:
 40011 00009509 0000                    	db 0,0			; Date separator 2 bytes
 40012                                  TIME_SEP:
 40013 0000950B 0000                    	db 0,0			; Time separator 2 bytes
 40014                                  BIT_FIELD:
 40015 0000950D 00                      	db 0			; Bit values
 40016                                  				;   Bit 0 = 0 if currency symbol first
 40017                                  				;	  = 1 if currency symbol last
 40018                                  				;   Bit 1 = 0 if No space after currency symbol
 40019                                  				;	  = 1 if space after currency symbol
 40020                                  CURRENCY_CENTS:
 40021 0000950E 00                      	db 0			; Number of places after currency dec point
 40022                                  TIME_24:
 40023 0000950F 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 40024                                  MAP_CALL:
 40025 00009510 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 40026                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 40027                                  				;  in pieces.
 40028                                  DATA_SEP:
 40029 00009514 0000                    	db 0,0			; Data list separator character
 40030                                  
 40031 00009516 00<rep 8h>              	times 8 db 0
 40032                                  
 40033                                  ; Max size of the block returned by the INTERNATIONAL call
 40034                                  
 40035                                  INTERNAT_BLOCK_SIZE EQU	32
 40036                                  
 40037                                  ;;	Buffer for DOS function 64h (Get extended country information)
 40038                                  ;;	subfunctions 2, 4, 6, or 7:
 40039                                  ;
 40040                                  ;CountryPtrInfo	label	byte
 40041                                  ;CountryPtrId	db	?
 40042                                  ;CountryPtr	dd	?
 40043                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 40044                                  	
 40045                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 40046                                  CountryPtrInfo:
 40047                                  CountryPtrId:	
 40048 0000951E 00                      	db 0
 40049                                  CountryPtr:
 40050 0000951F 00000000                	dd 0
 40051                                  
 40052                                  OldCtrlCHandler:
 40053 00009523 00000000                	dd 0			; previous int 23 vector
 40054                                  
 40055                                  BATLEN equ 32
 40056                                  
 40057                                  BATBUFPOS:
 40058 00009527 0000                    	dw 0			; integer position in buffer of next byte
 40059                                  
 40060 00009529 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 40061                                  BATBUFEND:
 40062 00009549 0000                    	dw 0
 40063                                  TypeFilSiz:
 40064 0000954B 00000000                	dd 0			; stores size of file to be typed
 40065                                  
 40066                                  ; *****************************************************
 40067                                  ; EMG 4.00
 40068                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 40069                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 40070                                  ; *****************************************************
 40071                                  ;
 40072                                  ; COMMON PARSE OUTPUT BLOCKS
 40073                                  
 40074                                  ; Common output blocks for PARSE number, complex, or string values.
 40075                                  
 40076                                  PARSE1_OUTPUT:
 40077                                  PARSE1_TYPE:
 40078 0000954F 00                      	db 0			;AN000;  type
 40079                                  PARSE1_CODE:
 40080 00009550 00                      	db 0			;AN000;  return value
 40081                                  PARSE1_SYN:
 40082 00009551 0000                    	dw 0			;AN000;  es offset of synonym
 40083                                  PARSE1_ADDR:
 40084 00009553 00000000                	dd 0			;AN000;  numeric value / address
 40085                                  				;	 of string value
 40086                                  
 40087                                  ;  Common output block for PARSE date strings.
 40088                                  
 40089                                  DATE_OUTPUT:
 40090                                  DATE_TYPE:
 40091 00009557 00                      	db 0			;AN000;  type
 40092 00009558 00                      	db 0			;AN000;  return value
 40093 00009559 0000                    	dw 0			;AN000;  es offset of synonym
 40094                                  DATE_YEAR:
 40095 0000955B 0000                    	dw 0			;AN000;  year
 40096                                  DATE_MONTH:
 40097 0000955D 00                      	db 0			;AN000;  month
 40098                                  DATE_DAY:
 40099 0000955E 00                      	db 0			;AN000;  day
 40100                                  
 40101                                  ;  Common output block for PARSE time strings.
 40102                                  
 40103                                  TIME_OUTPUT:
 40104                                  TIME_TYPE:
 40105 0000955F 00                      	db 0			;AN000;  type
 40106 00009560 00                      	db 0			;AN000;  return value
 40107 00009561 0000                    	dw 0			;AN000;  es offset of synonym
 40108                                  TIME_HOUR:
 40109 00009563 00                      	db 0			;AN000;  hour
 40110                                  TIME_MINUTES:
 40111 00009564 00                      	db 0			;AN000;  minutes
 40112                                  TIME_SECONDS:
 40113 00009565 00                      	db 0			;AN000;  seconds
 40114                                  TIME_FRACTION:
 40115 00009566 00                      	db 0			;AN000;  hundredths
 40116                                  
 40117                                  ;  Common output block for PARSE drive specifier (one based drive number).
 40118                                  
 40119                                  DRIVE_OUTPUT:
 40120                                  DRIVE_TYPE:
 40121 00009567 00                      	db 0			;AN000;  type
 40122                                  DRIVE_VALUE:
 40123 00009568 00                      	db 0			;AN000;  return value
 40124 00009569 0000                    	dw 0			;AN000;  es offset of synonym
 40125                                  DRIVE_NUMBER:
 40126 0000956B 00                      	db 0			;AN000;  drive number
 40127 0000956C 000000                  	db 0,0,0		;AN000;  reserved
 40128                                  
 40129                                  	; 18/04/2023
 40130                                  	; 16/04/2023
 40131                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 40132                                  
 40133                                  ; ----------------------------------------------------------------------------
 40134                                  ; 20/04/2023
 40135                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
