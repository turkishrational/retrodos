     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update:  14/08/2024 (v5.0 - 2024 optimization)
     5                                  ;		15/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.15 (2.11)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  ; ----------------------------------------------------------------------------
    44                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    45                                  
    46                                  ;============================================================================
    47                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    48                                  ;============================================================================
    49                                  ; 21/09/2018 - Retro DOS v3.0
    50                                  
    51                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    52                                  ;BREAK <system call definitions>
    53                                  
    54                                  ;
    55                                  ;	Microsoft Confidential
    56                                  ;	Copyright (C) Microsoft Corporation 1991
    57                                  ;	All Rights Reserved.
    58                                  ;
    59                                  
    60                                  ;SUBTTL	system call definitions
    61                                  ;PAGE
    62                                  
    63                                  Abort				EQU 0	;  0	  0
    64                                  STD_CON_INPUT			EQU 1	;  1	  1
    65                                  Std_Con_Output			EQU 2	;  2	  2
    66                                  Std_Aux_Input			EQU 3	;  3	  3
    67                                  Std_Aux_Output			EQU 4	;  4	  4
    68                                  Std_Printer_Output		EQU 5	;  5	  5
    69                                  Raw_Con_IO			EQU 6	;  6	  6
    70                                  RAW_CON_INPUT			EQU 7	;  7	  7
    71                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    72                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    73                                  Std_Con_String_Input		EQU 10	; 10	  A
    74                                  Std_Con_Input_Status		EQU 11	; 11	  B
    75                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    76                                  DISK_RESET			EQU 13	; 13	  D
    77                                  Set_Default_Drive		EQU 14	; 14	  E
    78                                  FCB_Open			EQU 15	; 15	  F
    79                                  FCB_Close			EQU 16	; 16	 10
    80                                  Dir_Search_First		EQU 17	; 17	 11
    81                                  Dir_Search_Next 		EQU 18	; 18	 12
    82                                  FCB_Delete			EQU 19	; 19	 13
    83                                  FCB_Seq_Read			EQU 20	; 20	 14
    84                                  FCB_Seq_Write			EQU 21	; 21	 15
    85                                  FCB_Create			EQU 22	; 22	 16
    86                                  FCB_Rename			EQU 23	; 23	 17
    87                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    88                                  Set_DMA 			EQU 26	; 26	 1A
    89                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    90                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    91                                  ;									   ;
    92                                  Get_Default_DPB 		EQU 31	; 31	 1F
    93                                  ;									   ;
    94                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    95                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    96                                  FCB_Random_Read 		EQU 33	; 33	 21
    97                                  FCB_Random_Write		EQU 34	; 34	 22
    98                                  Get_FCB_File_Length		EQU 35	; 35	 23
    99                                  Get_FCB_Position		EQU 36	; 36	 24
   100                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   101                                  Create_Process_Data_Block	EQU 38	; 38	 26
   102                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   103                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   104                                  Parse_File_Descriptor		EQU 41	; 41	 29
   105                                  Get_Date			EQU 42	; 42	 2A
   106                                  Set_Date			EQU 43	; 43	 2B
   107                                  Get_Time			EQU 44	; 44	 2C
   108                                  Set_Time			EQU 45	; 45	 2D
   109                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   110                                  ; Extended functionality group
   111                                  Get_DMA 			EQU 47	; 47	 2F
   112                                  GET_VERSION			EQU 48	; 48	 30
   113                                  Keep_Process			EQU 49	; 49	 31
   114                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   115                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   116                                  ;									   ;
   117                                  Get_DPB 			EQU 50	; 50	 32
   118                                  ;									   ;
   119                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   120                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   121                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   122                                  Get_InDOS_Flag			EQU 52	; 52	 34
   123                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   124                                  Get_Drive_Freespace		EQU 54	; 54	 36
   125                                  CHAR_OPER			EQU 55	; 55	 37
   126                                  International			EQU 56	; 56	 38
   127                                  ;   Directory Group
   128                                  MKDir				EQU 57	; 57	 39
   129                                  RMDir				EQU 58	; 58	 3A
   130                                  CHDir				EQU 59	; 59	 3B
   131                                  ;   File Group
   132                                  Creat				EQU 60	; 60	 3C
   133                                  OPEN				EQU 61	; 61	 3D
   134                                  CLOSE				EQU 62	; 62	 3E
   135                                  READ				EQU 63	; 63	 3F
   136                                  Write				EQU 64	; 64	 40
   137                                  Unlink				EQU 65	; 65	 41
   138                                  LSEEK				EQU 66	; 66	 42
   139                                  CHMod				EQU 67	; 67	 43
   140                                  IOCTL				EQU 68	; 68	 44
   141                                  XDUP				EQU 69	; 69	 45
   142                                  XDup2				EQU 70	; 70	 46
   143                                  Current_Dir			EQU 71	; 71	 47
   144                                  ;    Memory Group
   145                                  ALLOC				EQU 72	; 72	 48
   146                                  DEALLOC				EQU 73	; 73	 49
   147                                  SETBLOCK			EQU 74	; 74	 4A
   148                                  ;    Process Group
   149                                  Exec				EQU 75	; 75	 4B
   150                                  EXIT				EQU 76	; 76	 4C
   151                                  WAITPROCESS			EQU 77	; 77	 4D
   152                                  Find_First			EQU 78	; 78	 4E
   153                                  ;   Special Group
   154                                  Find_Next			EQU 79	; 79	 4F
   155                                  ; SPECIAL SYSTEM GROUP
   156                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   157                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   158                                  ;									   ;
   159                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   160                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   161                                  Get_In_Vars			EQU 82	; 82	 52
   162                                  SetDPB				EQU 83	; 83	 53
   163                                  ;									   ;
   164                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   165                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   166                                  Get_Verify_On_Write		EQU 84	; 84	 54
   167                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   168                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   169                                  ;									   ;
   170                                  Dup_PDB 			EQU 85	; 85	 55
   171                                  ;									   ;
   172                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   173                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   174                                  Rename				EQU 86	; 86	 56
   175                                  File_Times			EQU 87	; 87	 57
   176                                  AllocOper			EQU 88	; 88	 58
   177                                  ; Network extention system calls
   178                                  GetExtendedError		EQU 89	; 89	 59
   179                                  CreateTempFile			EQU 90	; 90	 5A
   180                                  CreateNewFile			EQU 91	; 91	 5B
   181                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   182                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   183                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   184                                  ;									   ;
   185                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   186                                  					;	    CloseByName, CloseUser,
   187                                  					;	    CloseUserProcess,
   188                                  					;	    GetOpenFileList
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  UserOper			EQU 94	; 94	 5E Get and Set
   193                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   194                                  xNameTrans			EQU 96	; 96	 60
   195                                  PathParse			EQU 97	; 97	 61
   196                                  GetCurrentPSP			EQU 98	; 98	 62
   197                                  Hongeul 			EQU 99	; 99	 63
   198                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   199                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   200                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   201                                  ;									   ;
   202                                  Set_Printer_Flag		EQU 100 ; 100	 64
   203                                  ;									   ;
   204                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   205                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   206                                  GetExtCntry			EQU 101 ; 101	 65
   207                                  GetSetCdPg			EQU 102 ; 102	 66
   208                                  ExtHandle			EQU 103 ; 103	 67
   209                                  Commit				EQU 104 ; 104	 68
   210                                  GetSetMediaID			EQU 105 ; 105	 69
   211                                  IFS_IOCTL			EQU 107 ; 107	 6B
   212                                  ExtOpen 			EQU 108 ; 108	 6C
   213                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   214                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   215                                  ;                                                                          ;
   216                                  ;ifdef ROMEXEC
   217                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   218                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   219                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   220                                  ;endif
   221                                  ;                                                                          ;
   222                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  ;
   225                                  ;
   226                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   227                                  OEM_C1				EQU 249 ; 249	 F9
   228                                  OEM_C2				EQU 250 ; 250	 FA
   229                                  OEM_C3				EQU 251 ; 251	 FB
   230                                  OEM_C4				EQU 252 ; 252	 FC
   231                                  OEM_C5				EQU 253 ; 253	 FD
   232                                  OEM_C6				EQU 254 ; 254	 FE
   233                                  OEM_C7				EQU 255 ; 255	 FF
   234                                  
   235                                  ;============================================================================
   236                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   237                                  ;============================================================================
   238                                  ; 21/09/2018 - Retro DOS v3.0
   239                                  
   240                                  ;BREAK <Control character definitions>
   241                                  
   242                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   243                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   244                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   245                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   246                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   247                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   248                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   249                                  c_HT	    EQU     09h 	; ^I ASCII tab
   250                                  
   251                                  ;============================================================================
   252                                  ; DIRENT.INC, MSDOS 6.0, 1991
   253                                  ;============================================================================
   254                                  ; 21/09/2018 - Retro DOS v3.0
   255                                  
   256                                  ;Break <Directory entry>
   257                                  
   258                                  ;	NOTE:  These offsets are also used in the DTA for
   259                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   260                                  ;	with the FCB filename field, and the rest of the
   261                                  ;	DIR_ENTRY fields follow. -DavidOls
   262                                  
   263                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   264                                  ;
   265                                  ;	+---------------------------+
   266                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   267                                  ;	+---------------------------+
   268                                  ;	|     (BYTE) attributes     |	    11	    B
   269                                  ;	+---------------------------+
   270                                  ;	|    (10 BYTE) reserved     |	    12	    C
   271                                  ;	+---------------------------+
   272                                  ;	| (WORD) time of last write |	    22	    16
   273                                  ;	+---------------------------+
   274                                  ;	| (WORD) date of last write |	    24	    18
   275                                  ;	+---------------------------+
   276                                  ;	|   (WORD) First cluster    |	    26	    1A
   277                                  ;	+---------------------------+
   278                                  ;	|     (DWORD) file size     |	    28	    1C
   279                                  ;	+---------------------------+
   280                                  ;
   281                                  ;   First byte of filename  = E5 -> free directory entry
   282                                  ;			    = 00 -> end of allocated directory
   283                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   284                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   285                                  ;
   286                                  
   287                                  STRUC DIR_ENTRY
   288 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   289 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   290 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   291 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   292 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   293 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   294 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   295 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   296 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   297 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   298 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   299                                  .size:
   300                                  
   301                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   302                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   303                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   304                                  ;	    this field is zero for subdirectory files.
   305                                  
   306                                  ENDSTRUC
   307                                  
   308                                  ATTR_READ_ONLY	equ	 1h
   309                                  ATTR_HIDDEN	equ	 2h
   310                                  ATTR_SYSTEM	equ	 4h
   311                                  ATTR_VOLUME_ID	equ	 8h
   312                                  ATTR_DIRECTORY	equ	10h
   313                                  ATTR_ARCHIVE	equ	20h
   314                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   315                                  				;   NO directory entry on a disk EVER
   316                                  				;   has this bit set. It is set non-zero
   317                                  				;   when a device is found by GETPATH
   318                                  
   319                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   320                                  				; OR of hard attributes for FINDENTRY
   321                                  
   322                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   323                                  				; ignore this(ese) attribute(s) during
   324                                  				; search first/next
   325                                  
   326                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   327                                  				; changeable via CHMOD
   328                                  
   329                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   330                                  
   331                                  ;============================================================================
   332                                  ; ERROR.INC, MSDOS 6.0, 1991
   333                                  ;============================================================================
   334                                  ; 21/09/2018 - Retro DOS v3.0
   335                                  
   336                                  ;**	ERROR.INC - DOS Error Codes
   337                                  ;
   338                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   339                                  ;    return error codes through AX.	If an error occurred then
   340                                  ;    the carry bit will be set and the error code is in AX.	If no error
   341                                  ;    occurred then the carry bit is reset and AX contains returned info.
   342                                  ;
   343                                  ;    Since the set of error codes is being extended as we extend the operating
   344                                  ;    system, we have provided a means for applications to ask the system for a
   345                                  ;    recommended course of action when they receive an error.
   346                                  ;
   347                                  ;    The GetExtendedError system call returns a universal error, an error
   348                                  ;    location and a recommended course of action.	The universal error code is
   349                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   350                                  ;    is issued.
   351                                  
   352                                  
   353                                  ;	2.0 error codes
   354                                  
   355                                  error_invalid_function		EQU	1
   356                                  ERROR_FILE_NOT_FOUND		EQU	2
   357                                  ERROR_PATH_NOT_FOUND		EQU	3
   358                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   359                                  ERROR_ACCESS_DENIED		EQU	5
   360                                  error_invalid_handle		EQU	6
   361                                  error_arena_trashed		EQU	7
   362                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   363                                  error_invalid_block		EQU	9
   364                                  error_bad_environment		EQU	10
   365                                  ERROR_BAD_FORMAT		EQU	11
   366                                  error_invalid_access		EQU	12
   367                                  ERROR_INVALID_DATA		EQU	13
   368                                  ;**** reserved			EQU	14	; *****
   369                                  error_invalid_drive		EQU	15
   370                                  error_current_directory 	EQU	16
   371                                  error_not_same_device		EQU	17
   372                                  ERROR_NO_MORE_FILES		EQU	18
   373                                  
   374                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   375                                  
   376                                  ERROR_WRITE_PROTECT		EQU	19
   377                                  error_bad_unit			EQU	20
   378                                  error_not_ready 		EQU	21
   379                                  error_bad_command		EQU	22
   380                                  error_CRC			EQU	23
   381                                  error_bad_length		EQU	24
   382                                  error_Seek			EQU	25
   383                                  error_not_DOS_disk		EQU	26
   384                                  error_sector_not_found		EQU	27
   385                                  error_out_of_paper		EQU	28
   386                                  error_write_fault		EQU	29
   387                                  error_read_fault		EQU	30
   388                                  ERROR_GEN_FAILURE		EQU	31
   389                                  
   390                                  ;	the new 3.0 error codes reported through INT 24
   391                                  
   392                                  error_sharing_violation 	EQU	32
   393                                  error_lock_violation		EQU	33
   394                                  error_wrong_disk		EQU	34
   395                                  ERROR_FCB_UNAVAILABLE		EQU	35
   396                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   397                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   398                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   399                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   400                                  
   401                                  ;	New OEM network-related errors are 50-79
   402                                  
   403                                  error_not_supported		EQU	50
   404                                  
   405                                  error_net_access_denied		EQU	65	;M028
   406                                  
   407                                  ;	End of INT 24 reportable errors
   408                                  
   409                                  error_file_exists		EQU	80
   410                                  error_DUP_FCB			EQU	81	; *****
   411                                  error_cannot_make		EQU	82
   412                                  error_FAIL_I24			EQU	83
   413                                  
   414                                  ;	New 3.0 network related error codes
   415                                  
   416                                  error_out_of_structures 	EQU	84
   417                                  error_Already_assigned		EQU	85
   418                                  error_invalid_password		EQU	86
   419                                  error_invalid_parameter 	EQU	87
   420                                  error_NET_write_fault		EQU	88
   421                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   422                                  
   423                                  ;============================================================================
   424                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   425                                  ;============================================================================
   426                                  ; 22/09/2018 - Retro DOS v3.0
   427                                  
   428                                  ;**	DevSym.inc - Device Symbols
   429                                  
   430                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   431                                  
   432                                  STRUC SYSDEV
   433 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   434 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   435 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   436 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   437 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   438                                  .size:
   439                                  ENDSTRUC
   440                                  
   441                                  ; 24/09/2018
   442                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   443                                  
   444                                  ;============================================================================
   445                                  ; CURDIR.INC, MSDOS 6.0, 1991
   446                                  ;============================================================================
   447                                  ; 21/09/2018 - Retro DOS v3.0
   448                                  
   449                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   450                                  
   451                                  ;============================================================================
   452                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   453                                  ;============================================================================
   454                                  ; 21/09/2018 - Retro DOS v3.0
   455                                  
   456                                  ;/*
   457                                  ; *                      Microsoft Confidential
   458                                  ; *                      Copyright (C) Microsoft Corporation 1991
   459                                  ; *                      All Rights Reserved.
   460                                  ; */
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   463                                  ;*************************************
   464                                  ; COMMAND EQUs which are not switch dependant
   465                                  
   466                                  ;		include	curdir.inc	; to get DIRSTRLEN
   467                                  ;		Note dossym.inc must already have been included!
   468                                  
   469                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   470                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   471                                  
   472                                  SYM		EQU	">"
   473                                  
   474                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   475                                  
   476                                  NORMPERLIN	EQU	1
   477                                  WIDEPERLIN	EQU	5
   478                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   479                                  BatLen		EQU	32		; buffer for batch files
   480                                  YES_ECHO	EQU	1		; echo line
   481                                  NO_ECHO 	EQU	0		; don't echo line
   482                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   483                                  call_in_progress EQU	1		; indicate we're in the CALL command
   484                                  length_call	EQU	4		; length of CALL
   485                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   486                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   487                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   488                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   489                                  nullcommand	EQU     1		; no command on command line
   490                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   491                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   492                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   493                                  result_number	EQU	1		;AN000; number returned from parser
   494                                  result_string	EQU	3		;AN000; string returned from parser
   495                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   496                                  result_drive	EQU	6		;AN000; drive returned from parser
   497                                  result_date	EQU	7		;AN000; date returned from parser
   498                                  result_time	EQU	8		;AN000; time returned from parser
   499                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   500                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   501                                  util_msg_class	EQU	-1		;AN000; message class for utility
   502                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   503                                  parse_msg_class EQU	2		;AN000; message class for parse error
   504                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   505                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   506                                  colon_char	EQU	":"             ;AN000; colon character
   507                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   508                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   509                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   510                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   511                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   512                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   513                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   514                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   515                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   516                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   517                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   518                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   519                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   520                                  parm_block_size equ	11		;AN000; size of message subst block
   521                                  blank		equ	" "             ;AN000; blank character
   522                                  no_subst	equ	0		;AN000; no substitutions for messages
   523                                  one_subst	equ	1		;AN000; one substitution for messages
   524                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   525                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   526                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   527                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   528                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   529                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   530                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   531                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   532                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   533                                  capital_A	equ	'A'             ;AC000;
   534                                  vbar		equ	'|'             ;AC000;
   535                                  labracket	equ	'<'             ;AC000;
   536                                  rabracket	equ	'>'             ;AC000;
   537                                  dollar		equ	'$'             ;AC000;
   538                                  lparen		equ	'('             ;AC000;
   539                                  rparen		equ	')'             ;AC000;
   540                                  nullrparen	equ	29h		;AC000;
   541                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   542                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   543                                  star		equ	'*'             ;AC000;
   544                                  plus_chr	equ	'+'             ;AC000;
   545                                  small_a 	equ	'a'             ;AC000;
   546                                  small_z 	equ	'z'             ;AC000;
   547                                  dot_chr 	equ	'.'             ;AC000;
   548                                  tab_chr 	equ	9		;AN032;
   549                                  equal_chr	equ	'='             ;AN032;
   550                                  semicolon	equ	';'             ;AN049;
   551                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   552                                  dot_colon	equ	2e3ah		;AC000; '.:'
   553                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   554                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   555                                  AppendInstall	equ	0B700H		;AN020; append install check
   556                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   557                                  AppendGetState	equ	0B706H		;AN020; append get current state
   558                                  AppendSetState	equ	0B707H		;AN020; append set current state
   559                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   560                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   561                                  
   562                                  ;*************************************
   563                                  ;* PARSE ERROR MESSAGES
   564                                  ;*************************************
   565                                  
   566                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   567                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   568                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   569                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   570                                  
   571                                  ;*************************************
   572                                  ;* EQUATES FOR MESSAGE RETRIEVER
   573                                  ;*************************************
   574                                  
   575                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   576                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   577                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   578                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   579                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   580                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   581                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   582                                  
   583                                  ;*********************************
   584                                  ;* EQUATES FOR INT 10H
   585                                  ;*********************************
   586                                  
   587                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   588                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   589                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   590                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   591                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   592                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   593                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   594                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   595                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   596                                  
   597                                  AltPipeChr	equ	"|"             ; alternate pipe character
   598                                  
   599                                  FCB		equ	5Ch
   600                                  
   601                                  STRUC VARSTRUC
   602 00000000 ??                      .ISDIR:		RESB	1
   603 00000001 ??                      .SIZ:		RESB	1
   604 00000002 ????                    .TTAIL:		RESW	1
   605 00000004 ??                      .INFO:		RESB	1
   606 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   607                                  .size:
   608                                  ENDSTRUC
   609                                  ;
   610                                  ; Flags for internal command parsing
   611                                  ;
   612                                  fCheckDrive	equ	00000001b	; validate drive letter
   613                                  fSwitchAllowed	equ	00000010b	; switches allowed
   614                                  fLimitHelp	equ	00000100b	; /? must appear alone
   615                                  
   616                                  ;
   617                                  ; Test switches
   618                                  ;
   619                                  fParse		EQU	0001h		; display results of parseline
   620                                  
   621                                  ;
   622                                  ; Batch segment structure
   623                                  ;
   624                                  ;   BYTE    type of segment
   625                                  ;   BYTE    echo state of parent on entry to batch file
   626                                  ;   WORD    segment of last batch file
   627                                  ;   WORD    segment for FOR command
   628                                  ;   BYTE    FOR flag state on entry to batch file
   629                                  ;   DWORD   offset for next line
   630                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   631                                  ;   ASCIZ   file name (with . and ..)
   632                                  ;   BYTES   CR-terminated parameters
   633                                  ;   BYTE    0 flag to indicate end of parameters
   634                                  ;
   635                                  
   636                                  BATCHTYPE   equ 0
   637                                  
   638                                  STRUC BATCHSEGMENT
   639 00000000 ??                      .BatType:	RESB	1		; signature
   640 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   641                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   642 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   643 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   644 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   645 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   646 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   647 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   648 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   649                                  .SIZE:
   650                                  ENDSTRUC
   651                                  
   652                                  ANULL		equ	0		; terminates an argv string
   653                                  ARGMAX		equ	64		; max args on a command line
   654                                  ;ARGBLEN 	equ	2*128		; 1char each plus term NUL
   655                                  ; 27/07/2024 - PCDOS 7.1 COMMAND.COM ;*
   656                                  ARGBLEN 	equ	2*64
   657                                  tplen		equ	64		; max size of one argument
   658                                  arg_cnt_error	equ	1		; number of args > MAXARG
   659                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   660                                  
   661                                  STRUC ARGV_ELE				; elements in the argv array
   662 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   663 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   664 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   665 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   666 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   667 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   668                                  .SIZE:	; 11 ; 27/07/2024
   669                                  ENDSTRUC
   670                                  
   671                                  STRUC ARG_UNIT
   672 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   673 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   674 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   675 000002C4 <res 100h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   676 000003C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   677                                  .SIZE:	; 1092 ; 27/07/2024 ; (it was 1348 in MSDOS 5.0-6.22 COMMAND.COM) ;*
   678                                  ENDSTRUC
   679                                  
   680                                  ; Equates for initialization
   681                                  ;
   682                                  INITINIT	equ	01h		; initialization in progress
   683                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   684                                  INITCTRLC	equ	04h		; already in ^C handler
   685                                  
   686                                  ;============================================================================
   687                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   688                                  ;============================================================================
   689                                  ; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   690                                  
   691                                  ; Current structure of the data returned by the international call
   692                                  
   693                                  struc INTERNAT_BLOCK
   694 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   695 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   696 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   697 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   698 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   699 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   700 0000000F ??                      .bit_field:	resb 1			; Bit values
   701                                  					;   Bit 0 = 0 if currency symbol first
   702                                  					;	  = 1 if currency symbol last
   703                                  					;   Bit 1 = 0 if No space after currency symbol
   704                                  					;	  = 1 if space after currency symbol
   705                                  .currency_cents:
   706 00000010 ??                      		resb 1			; Number of places after currency dec point
   707 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   708 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   709                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   710                                  					;  in pieces.
   711 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   712 00000017 ??                      		resb 1
   713                                  endstruc
   714                                  
   715                                  ; Max size of the block returned by the INTERNATIONAL call
   716                                  
   717                                  internat_block_max equ 32
   718                                  
   719                                  ;============================================================================
   720                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   721                                  ;============================================================================
   722                                  ; 13/10/2018 - Retro DOS v3.0
   723                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   724                                  
   725                                  ;Break	<find first/next buffer>
   726                                  
   727                                  	; MSDOS 3.3 & MSDOS 6.0
   728                                  
   729                                  struc FIND_BUF
   730 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   731 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   732 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   733 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   734 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   735 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   736 00000015 ??                      .ATTR:	    resb 1	; attribute found
   737 00000016 ????                    .TIMR:	    resw 1	; time
   738 00000018 ????                    .DATE:	    resw 1	; date
   739 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   740 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   741 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   742                                  .size:
   743                                  endstruc
   744                                  
   745                                  ;=============================================================================
   746                                  ; PDB.INC, MSDOS 6.0, 1991
   747                                  ;=============================================================================
   748                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   749                                  
   750                                  ;**	Process data block (otherwise known as program header)
   751                                  
   752                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   753                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   754                                  ;	for use.
   755                                  
   756                                  FILPERPROC	EQU     20
   757                                  
   758                                  struc PDB	; Process_data_block
   759 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   760 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   761 00000004 ??                                      resb 1
   762 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   763 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   764 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   765 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   766 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   767 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   768 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   769 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   770 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   771 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   772 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   773 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   774 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   775 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   776 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   777 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   778 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   779 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   780                                  				;  an extended FCB
   781                                  ;endstruc 	; MSDOS 3.3
   782                                  	  	; MSDOS 6.0
   783 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   784 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   785 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   786 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   787                                  endstruc
   788                                  
   789                                  ;=============================================================================
   790                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   791                                  ;=============================================================================
   792                                  ; 24/09/2018 - Retro DOS v3.0
   793                                  
   794                                  ;major_version	equ 6		; Major DOS version
   795                                  ;minor_version	equ 0		; Minor DOS Version
   796                                  
   797                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   798                                  
   799                                  ; MSDOS 3.3 COMMAND.COM
   800                                  ;MAJOR_VERSION	EQU 3
   801                                  ;MINOR_VERSION	EQU 30
   802                                  
   803                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   804                                  MAJOR_VERSION	EQU 5		; Major DOS version
   805                                  MINOR_VERSION	EQU 0		; Minor DOS version
   806                                  
   807                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   808                                  
   809                                  ;-----------------------------------------------------------------------------
   810                                  ; 21/09/2018
   811                                  ;-----------------------------------------------------------------------------
   812                                  ; Retro DOS v3.0 NOTE:  
   813                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   814                                  ;	with minor modifications which are done by me (Erdogan Tan).
   815                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   816                                  ;	source code files (written by using MASM syntax).
   817                                  ;-----------------------------------------------------------------------------
   818                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   819                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   820                                  ;----------------------------------------------------------------------------- 	
   821                                  
   822                                  ;=============================================================================
   823                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   824                                  ;=============================================================================
   825                                  ; 21/09/2018 - Retro DOS v3.0
   826                                  
   827                                  ;	page ,132
   828                                  ;	title	COMMAND - resident code for COMMAND.COM
   829                                  ;	name	COMMAND
   830                                  
   831                                  ;/*
   832                                  ; *                      Microsoft Confidential
   833                                  ; *                      Copyright (C) Microsoft Corporation 1991
   834                                  ; *                      All Rights Reserved.
   835                                  ; */
   836                                  
   837                                  ;*****************************************************************************
   838                                  ;
   839                                  ; MODULE:	       COMMAND.COM
   840                                  ;
   841                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   842                                  ;
   843                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   844                                  ;		       parts.  First is the resident portion, which includes
   845                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   846                                  ;		       error), and 2EH (command line execute); it also has
   847                                  ;		       code to test and, if necessary, reload the transient
   848                                  ;		       portion. Following the resident is the init code, which
   849                                  ;		       is overwritten after use.  Then comes the transient
   850                                  ;		       portion, which includes all command processing (whether
   851                                  ;		       internal or external).  The transient portion loads at
   852                                  ;		       the end of physical memory, and it may be overlayed by
   853                                  ;		       programs that need as much memory as possible. When the
   854                                  ;		       resident portion of command regains control from a user
   855                                  ;		       program, a check sum is performed on the transient
   856                                  ;		       portion to see if it must be reloaded.  Thus programs
   857                                  ;		       which do not need maximum memory will save the time
   858                                  ;		       required to reload COMMAND when they terminate.
   859                                  ;
   860                                  ; ENTRY POINT:	       PROGSTART
   861                                  ;
   862                                  ; INPUT:	       command line at offset 81H
   863                                  ;
   864                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   865                                  ;		       from a secondary command processor via the EXIT
   866                                  ;		       internal command.
   867                                  ;
   868                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   869                                  ;		       hang the system.
   870                                  ;
   871                                  ; INTERNAL REFERENCES:
   872                                  ;
   873                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   877                                  ;		       (COMMAND.DOC)
   878                                  ;
   879                                  ; EXTERNAL REFERENCES:
   880                                  ;
   881                                  ;      ROUTINES:       none
   882                                  ;
   883                                  ;      DATA AREAS:     none
   884                                  ;
   885                                  ;*****************************************************************************
   886                                  ;
   887                                  ;			      REVISION HISTORY
   888                                  ;			      ----------------
   889                                  ;
   890                                  ; DOS 1.00 to DOS 3.30
   891                                  ; --------------------------
   892                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   893                                  ;
   894                                  ; REV 1.17
   895                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   896                                  ;	       resident since the EXELOAD may have overwritten the transient.
   897                                  ;
   898                                  ; REV 1.18
   899                                  ;    05/21/82  IBM version always looks on drive A
   900                                  ;	       MSVER always looks on default drive
   901                                  ;
   902                                  ; REV 1.19
   903                                  ;    06/03/82  Drive spec now entered in command line
   904                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   905                                  ;	       (print volume label)
   906                                  ;
   907                                  ; REV 1.20
   908                                  ;    06/09/82  Prints "directory" after directories
   909                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   910                                  ;
   911                                  ; REV 1.50
   912                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   913                                  ;	       do it right.
   914                                  ;
   915                                  ; REV 1.70
   916                                  ;	       EXEC used to fork off new processes
   917                                  ;
   918                                  ; REV 1.80
   919                                  ;	       C switch for single command execution
   920                                  ;
   921                                  ; REV 1.90
   922                                  ;	       Batch uses XENIX
   923                                  ;
   924                                  ; Rev 2.00
   925                                  ;	       Lots of neato stuff
   926                                  ;	       IBM 2.00 level
   927                                  ;
   928                                  ; Rev 2.01
   929                                  ;	       'D' switch for date time suppression
   930                                  ;
   931                                  ; Rev 2.02
   932                                  ;	       Default userpath is NUL rather than BIN
   933                                  ;		       same as IBM
   934                                  ;	       COMMAND split into pieces
   935                                  ;
   936                                  ; Rev 2.10
   937                                  ;	       INTERNATIONAL SUPPORT
   938                                  ;
   939                                  ; Rev 2.50
   940                                  ;	       all the 2.x new stuff -MU
   941                                  ;
   942                                  ; Rev 3.30     (Ellen G)
   943                                  ;	       CALL internal command (TBATCH2.ASM)
   944                                  ;	       CHCP internal command (TCMD2B.ASM)
   945                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   946                                  ;	       @ sign suppression of batch file line
   947                                  ;	       Replaceable environment value support in batch files
   948                                  ;	       INT 2FH calls for APPEND
   949                                  ;	       Lots of PTR fixes!
   950                                  ;
   951                                  ; Beyond 3.30 to forever  (Ellen G)
   952                                  ; ----------------------
   953                                  ;
   954                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   955                                  ;			Use Message Retriever services
   956                                  ;			/MSG switch for resident extended error msg
   957                                  ;			Convert to new capitalization support
   958                                  ;			Better error recovery on CHCP command
   959                                  ;			Code page file tag support
   960                                  ;			TRUENAME internal command
   961                                  ;			Extended screen line support
   962                                  ;			/P switch on DEL/ERASE command
   963                                  ;			Improved file redirection error recovery
   964                                  ;	(removed)	Improved batch file performance
   965                                  ;			Unconditional DBCS support
   966                                  ;			Volume serial number support
   967                                  ;	(removed)	COMMENT=?? support
   968                                  ;
   969                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   970                                  ;
   971                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   972                                  ;			require delimiters.
   973                                  ;
   974                                  ; A003	PTM P5,P9,P111	Included in A000 development
   975                                  ;
   976                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   977                                  ;			executing
   978                                  ;
   979                                  ; A005	DCR D17 	If user specifies an extension on the command
   980                                  ;			line search for that extension only.
   981                                  ;
   982                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   983                                  ;			exists"
   984                                  ;
   985                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   986                                  ;
   987                                  ; A008	PTM P182	Change COPY to set default if invalid function
   988                                  ;			returned from code page call.
   989                                  ;
   990                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   991                                  ;
   992                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   993                                  ;			transient COMMAND.
   994                                  ;
   995                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   996                                  ;			before appending to a file.
   997                                  ;
   998                                  ; A012	PTM P189	Fix redirection error recovery.
   999                                  ;
  1000                                  ; A013	PTM P330	Change date format
  1001                                  ;
  1002                                  ; A014	PTM P455	Fix echo parsing
  1003                                  ;
  1004                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1005                                  ;
  1006                                  ; A016	PTM P354	Fix extended error message addressing
  1007                                  ;
  1008                                  ; A017	PTM P448	Fix appending to 0 length files
  1009                                  ;
  1010                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1011                                  ;			the parser fails on. Fail on duplicate switches.
  1012                                  ;
  1013                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1014                                  ;			critical error
  1015                                  ;
  1016                                  ; A020	DCR D43 	Set append state off while in DIR
  1017                                  ;
  1018                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1019                                  ;
  1020                                  ; A022	DCR D209	Enhanced error recovery
  1021                                  ;
  1022                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1023                                  ;
  1024                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1025                                  ;
  1026                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1027                                  ;
  1028                                  ; A026	DCR D191	Change redirection error recovery support.
  1029                                  ;
  1030                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1031                                  ;			with a carriage return.
  1032                                  ;
  1033                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1034                                  ;			date and invalid time messages.
  1035                                  ;
  1036                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1037                                  ;			and TIME.
  1038                                  ;
  1039                                  ; A030	DCR D201	New extended attribute format.
  1040                                  ;
  1041                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1042                                  ;
  1043                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1044                                  ;
  1045                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1046                                  ;
  1047                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1048                                  ;
  1049                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1050                                  ;			do a read to determine eof.
  1051                                  ;
  1052                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1053                                  ;			so that ASSIGN works correctly.
  1054                                  ;
  1055                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1056                                  ;
  1057                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1058                                  ;
  1059                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1060                                  ;
  1061                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1062                                  ;			specified.
  1063                                  ;
  1064                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1065                                  ;			executes.
  1066                                  ;
  1067                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1068                                  ;			files causing loss of batch file.
  1069                                  ;
  1070                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1071                                  ;			CALL'ed batch files.
  1072                                  ;
  1073                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1074                                  ;			as an end of line character
  1075                                  ;
  1076                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1077                                  ;			and extended message pointers when we EXIT if
  1078                                  ;			COMMAND /P is the top level process.
  1079                                  ;
  1080                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1081                                  ;			"File not found - fn"
  1082                                  ;
  1083                                  ; A047	PTM P2819	Fix transient reload prompt message
  1084                                  ;
  1085                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1086                                  ;			when DBCS code was added.
  1087                                  ;
  1088                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1089                                  ;			on line.
  1090                                  ;
  1091                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1092                                  ;
  1093                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1094                                  ;
  1095                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1096                                  ;
  1097                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1098                                  ;
  1099                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1100                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1101                                  ;
  1102                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1103                                  ;			problems with breaking out of INT 24h
  1104                                  ;
  1105                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1106                                  ;
  1107                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1108                                  ;			before the "string".  EX: COMMAND /CDIR
  1109                                  ;
  1110                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1111                                  ;			DBCS switch.
  1112                                  ;
  1113                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1114                                  ;			the time.
  1115                                  ;
  1116                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1117                                  ;			messages to be disk based.  Only keep them if /MSG
  1118                                  ;			is used.
  1119                                  ;
  1120                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1121                                  ;			out of internal commands, due to substitution blocks
  1122                                  ;			not being reset.
  1123                                  ;
  1124                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1125                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1126                                  ;			secondary copy of environment.	Change default slash in
  1127                                  ;			default comspec string to backslash.
  1128                                  ;
  1129                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1130                                  ;			text for critical error messages.
  1131                                  ;
  1132                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1133                                  ;	5/20/88 	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1136                                  ;	 5/20/88	with Microsoft product already shipped.
  1137                                  ;
  1138                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1139                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1140                                  ;			header and space remaining.
  1141                                  ;
  1142                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1143                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1144                                  ;			environment was putting a "Z block" marker in the old
  1145                                  ;			environment.  The fix is to move to the old environment
  1146                                  ;			to the new environment before doing the SETBLOCK.
  1147                                  ;
  1148                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1149                                  ;        09/19/88       because the check for APPEND needed to be performed
  1150                                  ;                       before the DIR's findfirst.
  1151                                  ;
  1152                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1153                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1154                                  ;                       loading trans w/new comspec with no user change comspec.
  1155                                  ;
  1156                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1157                                  ;        11/05/88       Expansion of environment variables into batch line of
  1158                                  ;                       128 chars was not being counted and "%" which should be
  1159                                  ;                       ignored were being counted.
  1160                                  ;
  1161                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1162                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1163                                  ;                       ing included in checksum and was being overwritten by
  1164                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1165                                  ;                       Also removed fix A069 (because flag now protected).
  1166                                  ;
  1167                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1168                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1169                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1170                                  ;
  1171                                  ;***********************************************************************************
  1172                                  
  1173                                  ;
  1174                                  ;	Revision History
  1175                                  ;	================
  1176                                  ;
  1177                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1178                                  ;					at init time (date/time prompt)
  1179                                  ;
  1180                                  
  1181                                  ;
  1182                                  ;.xcref
  1183                                  ;.xlist
  1184                                  ;	include dossym.inc		; basic DOS symbol set
  1185                                  ;	include syscall.inc		; DOS function names
  1186                                  ;	include comsw.asm		; build version info
  1187                                  ;	include comequ.asm		; common command.com symbols
  1188                                  ;	include resmsg.equ		; resident message names
  1189                                  ;
  1190                                  ;	include comseg.asm		;segment ordering
  1191                                  ;.list
  1192                                  ;.cref
  1193                                  
  1194                                  ;CODERES segment public byte
  1195                                  ;CODERES ends
  1196                                  ;
  1197                                  ;DATARES 	segment public byte
  1198                                  ;		extrn	AccDen:byte
  1199                                  ;		extrn	Batch:word
  1200                                  ;		extrn	EchoFlag:byte
  1201                                  ;		extrn	ExeBad:byte
  1202                                  ;		extrn	ExecEMes:byte
  1203                                  ;		extrn	ExecErrSubst:byte
  1204                                  ;		extrn	ExtCom:byte
  1205                                  ;		extrn	ForFlag:byte
  1206                                  ;		extrn	IfFlag:byte
  1207                                  ;		extrn	InitFlag:BYTE
  1208                                  ;		extrn	Nest:word
  1209                                  ;		extrn	PipeFlag:byte
  1210                                  ;		extrn	RBadNam:byte
  1211                                  ;		extrn	RetCode:word
  1212                                  ;		extrn	SingleCom:word
  1213                                  ;		extrn	TooBig:byte
  1214                                  ;
  1215                                  ;		extrn	OldDS:word
  1216                                  ;
  1217                                  ;DATARES 	ends
  1218                                  ;
  1219                                  ;
  1220                                  ;INIT		segment public para
  1221                                  ;		extrn	ConProc:near
  1222                                  ;		extrn	Init_Contc_SpecialCase:near
  1223                                  ;INIT		ends
  1224                                  
  1225                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1226                                  ; --------------------------------------
  1227                                  ; 'command5.s' source code reference(s):
  1228                                  
  1229                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1230                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1231                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1232                                  ; ----------------------------------------------------------------------				 	 	
  1233                                  
  1234                                  ; ----------------------------------------------------------------------------
  1235                                  ; START OF RESIDENT PORTION
  1236                                  ; ----------------------------------------------------------------------------
  1237                                  ; SEGMENT - DATARES
  1238                                  ; ----------------------------------------------------------------------------
  1239                                  
  1240                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1241                                  
  1242                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1243                                  
  1244                                  ; ----------------------------------------------------------------------------
  1245                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1246                                  ; ----------------------------------------------------------------------------
  1247                                  
  1248                                  ;This file contains the low memory stub for command.com which hooks all the
  1249                                  ;entry points into the resident command.com and directs the calls to the
  1250                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1251                                  ;
  1252                                  ;The stub has been made part of the resident data and will always
  1253                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1254                                  ;that actually hook the interrupt vectors belong to either the first 
  1255                                  ;command.com or to any other command.com executed with the /p switch. 
  1256                                  ;
  1257                                  ;The stub also keeps track of the current active data segment. The 
  1258                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1259                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1260                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1261                                  ;the exit code picks up the previous data segment pointer from the current
  1262                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1263                                  ;
  1264                                  ;Right now the stub does not bother about A20 switching. We assume
  1265                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1266                                  ;value of the current data segment in one of the registers. A20 toggle 
  1267                                  ;support maybe added as a future enhancement, if the need is felt.
  1268                                  
  1269                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1270                                  
  1271                                  	[ORG 100H]
  1272                                  
  1273                                  	; 21/09/2018 - Retro DOS v3.0
  1274                                  StartCode:
  1275 00000000 E9FD13                  	jmp	ConProc	; 10/01/2023 
  1276                                  
  1277                                  	; 09/01/2023
  1278                                  
  1279                                  ; Make following table word-aligned, and at the same time, provide a
  1280                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1281                                  
  1282                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1283 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1284                                  
  1285                                  ;All the entry points declared below are patched in at INIT time with the
  1286                                  ;proper segment and offset values after the resident code segment has been
  1287                                  ;moved to its final location
  1288                                  
  1289                                  ;!!!WARNING!!!
  1290                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1291                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1292                                  ;in the correct segments and offsets
  1293                                  
  1294                                  Int2f_Entry:
  1295 00000004 [1713]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1296 00000006 0000                    	dw	0
  1297                                  Int2e_Entry:
  1298 00000008 [730D]                  	dw	Int_2e			; Address of int 2eh handler
  1299 0000000A 0000                    	dw	0
  1300                                  Ctrlc_Entry:
  1301 0000000C [330C]                  	dw	ContC			; Address of Ctrl-C handler
  1302 0000000E 0000                    	dw	0
  1303                                  CritErr_Entry:
  1304 00000010 [3410]                  	dw	DSKERR			; Address of critical error handler
  1305 00000012 0000                    	dw	0
  1306                                  
  1307                                  Exec_Entry:
  1308 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1309                                  RemCheck_Entry:
  1310 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1311                                  TrnLodCom1_Entry:
  1312 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1313                                  LodCom_Entry:
  1314 00000020 00000000                	dd	0			; Entry after exit from command.com
  1315                                  MsgRetrv_Entry:
  1316 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1317                                  HeadFix_Entry:
  1318 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1319                                  UMBOff_Entry:
  1320 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1321                                  XMMCallAddr:
  1322 00000030 00000000                	dd	0			; Call address for XMM functions
  1323                                  ComInHMA:
  1324 00000034 00                      	db	0			; Flags if command.com in HMA
  1325                                  
  1326                                  Int2f_Trap:
  1327                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1328 00000035 E86400                  	call	CheckA20
  1329 00000038 1E                      	push	ds			; push current ds value
  1330 00000039 0E                      	push	cs			; push resident data segment value
  1331                                  	;jmp	cs:Int2f_Entry
  1332 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1333                                  
  1334                                  Int2e_Trap:
  1335 0000003F FB                      	sti
  1336 00000040 E85900                  	call	CheckA20
  1337 00000043 1E                      	push	ds			; push current ds value
  1338 00000044 0E                      	push	cs			; push resident data segment value
  1339                                  	;jmp	cs:Int2e_Entry
  1340 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1341                                  
  1342                                  Ctrlc_Trap:
  1343 0000004A FB                      	sti
  1344 0000004B E84E00                  	call	CheckA20
  1345 0000004E 1E                      	push	ds			; push current ds value
  1346 0000004F 0E                      	push	cs			; push resident data segment value
  1347                                  	;jmp	cs:Ctrlc_Entry
  1348 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1349                                  
  1350                                  CritErr_Trap:
  1351 00000055 FB                      	sti
  1352 00000056 E84300                  	call	CheckA20
  1353 00000059 1E                      	push	ds			; push current ds value
  1354 0000005A 0E                      	push	cs			; push resident data segment value
  1355                                  	;jmp	cs:CritErr_Entry
  1356 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1357                                  
  1358                                  Exec_Trap:
  1359 00000060 E83900                  	call	CheckA20
  1360 00000063 1E                      	push	ds			; push current ds value
  1361 00000064 0E                      	push	cs			; push resident data segment value
  1362                                  	;jmp	cs:Exec_Entry
  1363 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1364                                  
  1365                                  RemCheck_Trap:
  1366 0000006A E82F00                  	call	CheckA20
  1367 0000006D 1E                      	push	ds			; push current ds value
  1368 0000006E 0E                      	push	cs			; push resident data segment value
  1369                                  	;jmp	cs:RemCheck_Entry
  1370 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1371                                  
  1372                                  TrnLodCom1_Trap:
  1373 00000074 E82500                  	call	CheckA20
  1374 00000077 1E                      	push	ds			; push current ds value
  1375 00000078 0E                      	push	cs			; push resident data segment value
  1376                                  	;jmp	cs:TrnLodCom1_Entry
  1377 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1378                                  
  1379                                  LodCom_Trap:
  1380 0000007E E81B00                  	call	CheckA20
  1381 00000081 1E                      	push	ds			; push current ds value
  1382 00000082 0E                      	push	cs			; push resident data segment value
  1383                                  	;jmp	cs:LodCom_Entry
  1384 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1385                                  
  1386                                  MsgRetrv_Trap:
  1387 00000088 E81100                  	call	CheckA20
  1388 0000008B 1E                      	push	ds			; push current ds value
  1389 0000008C 0E                      	push	cs			; push resident data segment value
  1390                                  	;jmp	cs:MsgRetrv_Entry
  1391 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1392                                  
  1393                                  HeadFix_Trap:
  1394 00000092 E80700                  	call	CheckA20
  1395 00000095 1E                      	push	ds			; push current ds value
  1396 00000096 0E                      	push	cs			; push resident data segment value
  1397                                  	;jmp	cs:HeadFix_Entry
  1398 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1399                                  
  1400                                  ; ----------------------------------------------------------------------------
  1401                                  
  1402                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1403                                  %if 0
  1404                                  	; 09/01/2023
  1405                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1406                                  
  1407                                  	; 05/06/2023
  1408                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1409                                  CheckA20:
  1410                                  	pushf				; save current flags
  1411                                  	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1412                                  	jz	short A20_on		; no, jump to resident
  1413                                  
  1414                                  	call	QueryA20
  1415                                  	jnc	short A20_on		; A20 is on, jump to resident
  1416                                  
  1417                                  	call	EnableA20		; turn A20 on
  1418                                  A20_on:
  1419                                  	popf				; flags have to be unchanged
  1420                                  	retn
  1421                                  %else
  1422                                  	; 18/07/2024
  1423                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1424                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1425                                  	; PCDOS 7.1 COMMAND.COM - RESGROUP:01FFh
  1426                                  CheckA20:
  1427 0000009C 9C                      	pushf				; save current flags
  1428 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1429 000000A3 741A                    	jz	short A20_on		; no, jump to resident
  1430                                  	; 18/07/2024
  1431 000000A5 50                      	push	ax
  1432 000000A6 53                      	push	bx
  1433                                  QueryA20:
  1434                                  	;mov	ah,7
  1435 000000A7 B407                    	mov	ah,XMM_QUERY_A20
  1436                                  	;call	cs:XMMCallAddr
  1437 000000A9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1438 000000AE 09C0                    	or	ax,ax
  1439                                  	; 16/04/2023
  1440 000000B0 750B                    	jnz	short QA20_ON		; A20 is on, jump to resident
  1441                                  	; 18/07/2024
  1442                                  EnableA20:
  1443                                  	;mov	ah,5
  1444 000000B2 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20	; turn A20 on
  1445                                  	;call	cs:XMMCallAddr
  1446 000000B4 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1447 000000B9 09C0                    	or	ax,ax
  1448 000000BB 7404                    	jz	short XMMerror		; AX = 0 fatal error
  1449                                  QA20_ON:
  1450 000000BD 5B                      	pop	bx
  1451 000000BE 58                      	pop	ax
  1452                                  A20_on:
  1453 000000BF 9D                      	popf				; flags have to be unchanged
  1454 000000C0 C3                      	retn
  1455                                  ;If we get an error, we just loop forever
  1456                                  XMMerror:
  1457 000000C1 EBFE                    	jmp	short XMMerror
  1458                                  %endif
  1459                                  
  1460                                  ; ----------------------------------------------------------------------------
  1461                                  
  1462                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1463                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1464                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1465                                  ; M005; pointers because our cs is going to be different. The segment to
  1466                                  ; M005; jump to is patched in at init time. (in init.asm)
  1467                                  
  1468                                  Carousel_i2f_Hook:			; M005
  1469 000000C3 EA                      	db	0EAh			; far jump opcode; M005
  1470 000000C4 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1471 000000C6 0000                    	dw	0			; int 2fh segment; M005
  1472                                  
  1473                                  ; ----------------------------------------------------------------------------
  1474                                  
  1475                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1476                                  %if 0
  1477                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1478                                  QueryA20:
  1479                                  	push	bx
  1480                                  	push	ax
  1481                                  	;mov	ah,7
  1482                                  	mov	ah,XMM_QUERY_A20
  1483                                  	;call	cs:XMMCallAddr
  1484                                  	call	far [cs:XMMCallAddr]
  1485                                  	or	ax,ax
  1486                                  	pop	ax
  1487                                  	pop	bx
  1488                                  	; 16/04/2023
  1489                                  	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1490                                  	stc					; OFF
  1491                                  	;retn
  1492                                  QA20_ON:
  1493                                  	;clc					; ON
  1494                                  	retn
  1495                                  %endif
  1496                                  
  1497                                  ; ----------------------------------------------------------------------------
  1498                                  
  1499                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1500                                  %if 0
  1501                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1502                                  EnableA20:
  1503                                  	push	bx
  1504                                  	push	ax
  1505                                  	;mov	ah,5
  1506                                  	mov	ah,XMM_LOCAL_ENABLE_A20
  1507                                  	;call	cs:XMMCallAddr
  1508                                  	call	far [cs:XMMCallAddr]
  1509                                  	or	ax,ax
  1510                                  	jz	short XMMerror			; AX = 0 fatal error
  1511                                  	pop	ax
  1512                                  	pop	bx
  1513                                  	retn
  1514                                  ;If we get an error, we just loop forever
  1515                                  XMMerror:
  1516                                  	jmp	short XMMerror
  1517                                  %endif
  1518                                  
  1519                                  ; -----------------------------------------------------------------------------
  1520                                  
  1521                                  HV_Extern   equ	1
  1522                                  HV_LoadHigh equ	1
  1523                                  HV_Stub	    equ	1
  1524                                  
  1525                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1526                                  
  1527                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1528                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1529                                  ;returns with all registers preserved and so all our segment registers are
  1530                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1531                                  ;comes back here. In this case the segment registers and the stack are
  1532                                  ;not set up and random things can happen. The only way to setup all the 
  1533                                  ;registers is to use the cs value and this can only be done when we are in
  1534                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1535                                  ;the code segment to the data segment.
  1536                                  
  1537                                  Issue_Exec_Call:
  1538 000000C8 CD21                    	int 	21h
  1539                                  
  1540                                  ;We disable interrupts while changing the stack because there is a bug in 
  1541                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1542                                  ;are being changed.
  1543                                  
  1544 000000CA FA                      	cli
  1545 000000CB 0E                      	push	cs
  1546 000000CC 17                      	pop	ss
  1547                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1548                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1549 000000CD BC[1E04]                	mov	sp,RStack		; stack is set up
  1550                                  	
  1551                                  	; 20/04/2023
  1552                                  	;sti
  1553                                  	;push	cs
  1554                                  	;pop	ds			; ds = DATARES
  1555                                  
  1556                                  ; M009; Restore UMB state to that before Exec
  1557                                  
  1558                                  	;pushf				;    This call frees HIDDEN umb's,
  1559                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1560                                  	;popf				;    strategy and link state, as app.
  1561                                  
  1562                                  	; 09/01/2023 - Retro DOS v4.0
  1563                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1564                                  	; ----------------------
  1565 000000D0 FB                      	sti
  1566                                  	
  1567 000000D1 0E                      	push    cs
  1568 000000D2 1F                      	pop     ds
  1569 000000D3 9C                      	pushf
  1570                                  	;mov	al,[cs:fInHigh]
  1571                                  	; 18/04/2023
  1572 000000D4 A0[2004]                	mov	al,[fInHigh]
  1573 000000D7 A880                    	test	al,80h
  1574 000000D9 7406                    	jz      short uhu10
  1575 000000DB 247F                    	and     al,7Fh
  1576                                  	;;call	cs:UMBOff_Entry
  1577                                  	;call	far [cs:UMBOff_Entry]
  1578 000000DD FF1E[2C00]              	call	far [UMBOff_Entry]
  1579                                  uhu10:
  1580                                  	;and	byte [cs:fInHigh],7Fh
  1581                                  	; 18/04/2023
  1582 000000E1 8026[2004]7F            	and	byte [fInHigh],7Fh
  1583 000000E6 9D                      	popf
  1584                                  	; ----------------------
  1585                                  
  1586                                  ;We now jump to the stub trap which returns us to the resident code. All
  1587                                  ;flags are preserved by the stub code.
  1588                                  
  1589 000000E7 E976FF                  	jmp	Exec_Trap
  1590                                  
  1591                                  ; ----------------------------------------------------------------------------
  1592                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1593                                  ; ----------------------------------------------------------------------------
  1594                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1595                                  
  1596                                  ;***	Message substitution blocks
  1597                                  
  1598                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1599                                  
  1600                                  ;BlkDevErrSubst	label	byte
  1601                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1602                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1603                                  
  1604 000000EA 02                      BlkDevErrSubst: db	2
  1605 000000EB 0000                    BlkDevErrRw:	dw	0
  1606 000000ED 01                      		db	1
  1607 000000EE [F000]                  		dw	DrvLet
  1608                                  
  1609 000000F0 41                      DrvLet:		db	'A'			; drive letter
  1610                                  
  1611                                  
  1612                                  ;CharDevErrSubst label	byte
  1613                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1614                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1615                                  
  1616 000000F1 02                      CharDevErrSubst: db	2
  1617 000000F2 0000                    CharDevErrRw:	dw	0
  1618 000000F4 02                      		db	2
  1619 000000F5 [0301]                  		dw	DevName
  1620                                  
  1621                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0318h
  1622                                  ;DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1623                                  ;		db	0
  1624                                  
  1625                                  ;NeedVolSubst	label	byte
  1626                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1627                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1628                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1629                                  
  1630 000000F7 02                      NeedVolSubst:	db	2
  1631 000000F8 [0001]                  		dw	VolName
  1632 000000FA 03                      		db	3
  1633 000000FB [0E01]                  		dw	VolSer+2
  1634 000000FD 03                      		db	3
  1635 000000FE [0C01]                  		dw	VolSer
  1636                                  
  1637                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0321h
  1638                                  	; NOTE:	VolName and VolSer must be adjacent
  1639                                  ;VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1640                                  		; 18/07/2024
  1641 00000100 000000                  VolName:	db	3 dup(0)
  1642 00000103 0000000000000000        DevName:	db	8 dup(0)
  1643                                  	
  1644 0000010B 00                      		db	0
  1645 0000010C 00000000                VolSer:		dd	0			; volume serial #
  1646                                  
  1647 00000110 00                      CDevAt:		db	0
  1648                                  
  1649                                  ;BadFatSubst	label	byte
  1650                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1651                                  
  1652 00000111 01                      BadFatSubst:	db	1
  1653 00000112 [F000]                  		dw	DrvLet
  1654                                  
  1655                                  ;PutBackSubst	label	byte
  1656                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1657                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1658                                  
  1659 00000114 02                      PutBackSubst:	db	2
  1660 00000115 0000                    PutBackComSpec:	dw	0
  1661 00000117 01                      		db	1
  1662 00000118 [1A01]                  		dw	PutBackDrv
  1663                                  
  1664 0000011A 20                      PutBackDrv:	db	' '			; drive letter
  1665                                  
  1666                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1667                                  
  1668 0000011B 02                      ExecErrSubst:	db	2
  1669 0000011C [4903]                  		dw	SafePathBuffer
  1670                                  
  1671 0000011E 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1672 00000122 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1673                                  
  1674 00000123 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1675 00000127 0000                    Save_Pdb:	dw	0
  1676 00000129 0000                    Parent:		dw	0
  1677 0000012B 00000000                OldTerm:	dd	0
  1678 0000012F 0000                    ErrCd_24:	dw	0
  1679 00000131 0000                    Handle01:	dw	0
  1680 00000133 00                      Loading:	db	0
  1681 00000134 0000                    Batch:		dw	0	; assume no batch mode initially
  1682                                  
  1683                                  ;;;;SR;
  1684                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1685                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1686                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1687                                  ;;;;
  1688                                  ;;;BatchEOF:	db	0
  1689                                  
  1690                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1691                                  	; What's this comspec_end about?
  1692 00000136 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1693 00000176 0000                    ComSpec_End:	dw	0
  1694                                  
  1695                                  ;Trans		label	dword
  1696                                  ;		dw	TRANGROUP:Command
  1697                                  
  1698                                  Trans:		;dw	12Ch
  1699                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1700 00000178 [2C01]                  		dw	COMMAND ; 16/04/2023
  1701 0000017A 0000                    TrnSeg:		dw	0
  1702                                  
  1703 0000017C 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1704                                  
  1705 0000017D 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1706 0000017E 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1707                                  
  1708 0000017F 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1709 00000180 0000                    MemSiz:		dw	0
  1710 00000182 0000                    Sum:		dw	0
  1711 00000184 01                      ExtCom:		db	1	; for init, pretend just did an external
  1712 00000185 0000                    RetCode: 	dw	0
  1713 00000187 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1714                                  
  1715                                  
  1716                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1717                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1718                                  
  1719 00000188 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1720 00000189 01                      Suppress:	db	1	; used for echo, 1=echo line
  1721 0000018A 0000                    Io_Save: 	dw	0
  1722 0000018C 00                      RestDir: 	db	0
  1723 0000018D 00                      PermCom: 	db	0	; true => permanent command
  1724                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1725                                  				; true => semi-permanent command (/K)
  1726 0000018E 0000                    SingleCom:	dw	0	; true => single command version
  1727 00000190 FFFF                    VerVal:		dw	-1
  1728 00000192 00                      fFail:		db	0	; true => fail all int 24s
  1729 00000193 00                      IfFlag:		db	0	; true => IF statement in progress
  1730                                  
  1731 00000194 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1732 00000195 0000                    ForPtr:		dw	0
  1733                                  
  1734 00000197 0000                    Nest:		dw	0	; nested batch file counter
  1735 00000199 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1736 0000019A 00                      Call_Batch_Flag: db	0
  1737 0000019B 0000                    Next_Batch:	dw	0	; address of next batch segment
  1738 0000019D 00                      NullFlag:	db	0	; flag if no command on command line
  1739 0000019E 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1740                                  				; buffer for file ucase address
  1741                                  ; Bugbug: don't need crit_msg_ anymore?
  1742                                  
  1743 000001A3 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1744 000001A5 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1745 000001A7 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1746 000001A9 0000                    		 dw	0	; DBCS vector segment
  1747 000001AB 0000                    Append_State:	dw	0	; current state of append
  1748                                  				;  (if Append_Flag is set)
  1749 000001AD 00                      Append_Flag:	db	0	; set if append state is valid
  1750 000001AE 00                      Re_Out_App:	db	0
  1751 000001AF 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1752                                  
  1753                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1754                                  ; various times. Here is the breakdown:
  1755                                  ;
  1756                                  ;   INITINIT	We are in the init code.
  1757                                  ;   INITSPECIAL We are in the date/time prompt
  1758                                  ;   INITCTRLC	We are handling a ^C already.
  1759                                  ;
  1760                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1761                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1762                                  ;
  1763                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1764                                  ; input buffer with a CR to pretend an empty response.
  1765                                  ;
  1766                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1767                                  ; (ourselves). We can then detect the carry set and properly retry the
  1768                                  ; operation.
  1769                                  
  1770                                  InitFlag:	;db	1
  1771 000001FF 01                      		db	INITINIT
  1772                                  
  1773                                  ; Note: these two bytes are referenced as a word
  1774 00000200 00                      PipeFlag:	db	0
  1775 00000201 00                      PipeFiles:	db	0
  1776                                  
  1777                                  ; (rdata.asm, msdos 6.0, 1992)
  1778                                  ; ----------------------------------------------------------------------------
  1779                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1780                                  
  1781                                  
  1782                                  ;;SR
  1783                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1784                                  ;;
  1785                                  ;
  1786                                  ;; Bugbug: can we find any way around maintaining these
  1787                                  ;; large buffers?
  1788                                  ;
  1789                                  ;Pipe1		db	67+12 dup (?)
  1790                                  ;Pipe2		db	67+12 dup (?)
  1791                                  ;
  1792                                  ;PipePtr 	dw	?
  1793                                  ;
  1794                                  ;PipeStr 	db	129 dup (?)
  1795                                  ;
  1796                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1797                                  ;
  1798                                  ;;SR;
  1799                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1800                                  ;;automatically be discarded after init.
  1801                                  ;;
  1802                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1803                                  ;; M004; the origin.
  1804                                  ;;
  1805                                  ;	ORG	Pipe1	; M004
  1806                                  ;
  1807                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1808                                  ;; what it expects, what it does.
  1809                                  ;
  1810                                  
  1811                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1812                                  
  1813                                  Pipe1	equ	EndInit
  1814                                  Pipe2	equ	Pipe1+67+12
  1815                                  PipePtr	equ	Pipe2+67+12
  1816                                  PipeStr	equ	PipePtr+2
  1817                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1818                                  
  1819                                  ; Bugbug: really need a procedure header for EndInit, describing
  1820                                  ; what it expects, what it does.
  1821                                  
  1822                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1823                                  
  1824                                  EndInit:
  1825 00000202 1E                      	push	ds
  1826 00000203 06                      	push	es		; save segments
  1827 00000204 0E                      	push	cs
  1828 00000205 1F                      	pop	ds		
  1829                                  	;assume	ds:RESGROUP
  1830                                  
  1831                                  ; M004; Save size of transient here before INIT segment is deallocated
  1832                                  
  1833 00000206 8B16[7E1C]              	mov	dx,[TrnSize]		; M004
  1834                                  ;M027
  1835                                  ; These variables are also defined in the INIT segment and need to be saved
  1836                                  ;before we resize
  1837                                  ;
  1838 0000020A A1[721C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1839 0000020D 8B1E[6E1C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1840 00000211 8B0E[741C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1841 00000215 50                      	push	ax		; Save all these values ;M027
  1842 00000216 53                      	push	bx		; M027
  1843 00000217 51                      	push	cx		; M027
  1844                                  
  1845                                  
  1846                                  ; Bugbug: push ds, pop es here.
  1847                                  	;mov	bx,ds
  1848                                  	;mov	es,bx		; es = RESGROUP
  1849                                  	; 09/01/2023
  1850 00000218 1E                      	push	ds
  1851 00000219 07                      	pop	es
  1852                                  
  1853                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1854                                  ; code + data for low COMMAND
  1855                                  
  1856 0000021A 8B1E[9F03]              	mov	bx,[ResSize]	; Total size of resident
  1857 0000021E B44A                    	mov	ah,4Ah
  1858                                  	;mov	ah,SETBLOCK
  1859 00000220 CD21                    	int	21h		; Set block to resident size
  1860                                  
  1861                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1862                                  		; ES = segment address of block to change
  1863                                  		; BX = new size in paragraphs
  1864                                  
  1865                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1866                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1867                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1868                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1869                                  ;
  1870                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1871                                  	
  1872 00000222 803E[8D01]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1873 00000227 7530                    	jne	short adjust_env ; no, do not free batchseg
  1874                                  
  1875 00000229 833E[3401]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1876 0000022E 7429                    	je	short adjust_env ; no, dont juggle
  1877                                  
  1878                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  1879                                  	; 21/01/2023
  1880 00000230 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1881                                  	;mov	bx,4	; 09/01/2023
  1882                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1883 00000233 B448                    	mov	ah,48h
  1884                                  	;mov	ah,ALLOC
  1885 00000235 CD21                    	int	21h
  1886                                  
  1887                                  		; DOS - 2+ - ALLOCATE MEMORY
  1888                                  		; BX = number of 16-byte paragraphs desired
  1889                                  
  1890                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1891                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1892                                  ; could be making it worse! We're second-guessing where memory
  1893                                  ; allocations go, which might not be such a great idea. Is there
  1894                                  ; a strategy, short of doing something even worse like diddling
  1895                                  ; arena headers, where we can minimize the possibility of fragmentation
  1896                                  ; under all cases? Hmm..
  1897                                  	
  1898 00000237 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1899                                  
  1900 00000239 8EC0                    	mov	es,ax		 ; es = New batch segment
  1901 0000023B 31FF                    	xor	di,di
  1902 0000023D 31F6                    	xor	si,si
  1903                                  
  1904 0000023F 1E                      	push	ds
  1905 00000240 8E1E[3401]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1906                                  	;assume	ds:nothing
  1907                                  	;mov	cx,SIZE BatchSegment
  1908                                  	; 23/01/2023
  1909                                  	;mov	cx,BATCHSEGMENT.SIZE
  1910                                  	;;mov	cx,33	; 09/01/2023
  1911                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1912                                  	;
  1913                                  	;add	cx,16		 ; for the filename
  1914                                  	; 20/04/2023
  1915 00000244 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16
  1916                                  
  1917                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1918                                  	; It's sure be bad if we copied more bytes than the batch segment
  1919                                  	; holds!
  1920                                  	
  1921 00000247 FC                      	cld
  1922 00000248 F3A4                    	rep	movsb
  1923 0000024A 1F                      	pop	ds
  1924                                  	;assume	ds:RESGROUP
  1925                                  
  1926 0000024B 8CC1                    	mov	cx,es		; save new batch segment 
  1927 0000024D 8E06[3401]              	mov	es,[Batch]
  1928 00000251 B449                    	mov	ah,49h
  1929                                  	;mov	ah,DEALLOC
  1930 00000253 CD21                    	int	21h		; free the old batch segment
  1931                                  
  1932                                  	; Bugbug: should we check for error?
  1933                                  
  1934 00000255 890E[3401]              	mov	[Batch],cx	; store new batch segment address
  1935                                  
  1936                                  adjust_env:
  1937 00000259 59                      	pop	cx		; cx = size of old env ;M027
  1938 0000025A 5B                      	pop	bx		; bx = size of new env needed ;M027
  1939 0000025B 5D                      	pop	bp		; bp = old env seg ;M027
  1940                                  
  1941                                  ;Allocate the correct size for the environment
  1942                                  
  1943 0000025C B448                    	mov	ah,48h
  1944                                  	;mov	ah,ALLOC
  1945 0000025E CD21                    	int	21h		; get memory
  1946 00000260 7264                    	jc	short nomem_err	; out of memory,signal error
  1947                                  	
  1948                                  	; Bugbug: why not continue, leaving environment where it is?
  1949                                  
  1950 00000262 A3[2703]                	mov	[EnvirSeg],ax	; Store new environment segment
  1951                                  	;;mov	[ds:2Ch],ax
  1952                                  	;mov	[2Ch],ax
  1953                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1954 00000265 A32C00                  	mov	[PDB.ENVIRON],ax
  1955 00000268 8EC0                    	mov	es,ax		; es = address of allocated memory
  1956                                  	;assume	es:nothing
  1957                                  
  1958                                  ;Copy the environment to the newly allocated segment
  1959                                  
  1960 0000026A 1E                      	push	ds
  1961 0000026B 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1962                                  	;assume	ds:nothing
  1963                                  
  1964 0000026D 31F6                    	xor	si,si
  1965 0000026F 89F7                    	mov	di,si		; Start transfer from 0
  1966                                  
  1967 00000271 FC                      	cld
  1968 00000272 F3A4                    	rep	movsb		; Do the copy
  1969                                  
  1970 00000274 1F                      	pop	ds		; ds = RESGROUP
  1971                                  	;assume	ds:RESGROUP
  1972                                  
  1973                                  ; We have to free the old environment block if it was allocated by INIT
  1974                                  
  1975                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1976                                  ; or does it also apply to passed environments?
  1977                                  
  1978                                  ;M036
  1979                                  ; Free up old env segment always because this is a copy passed by Exec and
  1980                                  ; takes up memory that is never used
  1981                                  
  1982                                  ;M044
  1983                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1984                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1985                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1986                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1987                                  ; in
  1988                                  
  1989                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1990                                          ;je	short no_free	    ; no, do not free it
  1991                                  	; 21/01/2023
  1992                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1993 00000275 803E[521C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment
  1994 0000027A 7506                    	jne	short no_free 
  1995                                  
  1996 0000027C 8EC5                    	mov	es,bp
  1997 0000027E B449                    	mov	ah,49h
  1998                                  	;mov	ah,DEALLOC
  1999 00000280 CD21                    	int	21h		    ; Free it
  2000                                  no_free:
  2001                                  
  2002                                  ; M004; Start of changes
  2003                                  
  2004                                  ; Move the transient now. We will allocate the biggest block available
  2005                                  ; now and move the transient to the top of the block. We will then
  2006                                  ; deallocate this block. When the resident starts executing, it will
  2007                                  ; hopefully allocate this block again and find the transient intact.
  2008                                  
  2009 00000282 C606[7C01]01            	mov	byte [TrnMvFlg],1 ; Indicate that transient has been moved
  2010 00000287 06                      	push	es
  2011                                  	;;mov	si,offset ResGroup:TranStart
  2012                                  	; 09/01/2023
  2013                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2014 00000288 BE0022                  	mov	si,TRANSTART	; (End of the resident portion)
  2015                                  	;mov	di,0
  2016 0000028B 31FF                    	xor	di,di ; 0
  2017                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2018                                  	;mov	cx,98C5h
  2019 0000028D B96F95                  	mov	cx,TRANSPACEEND
  2020                                  	
  2021                                  ; Find the largest block available
  2022                                  
  2023 00000290 BBFFFF                  	mov	bx,0FFFFh
  2024 00000293 B448                    	mov	ah,48h
  2025                                  	;mov	ah,ALLOC
  2026 00000295 CD21                    	int	21h
  2027                                  
  2028                                  ; dx = size of transient saved previously 
  2029                                  
  2030 00000297 39D3                    	cmp	bx,dx		; enough memory?
  2031 00000299 722B                    	jb	short nomem_err	; not enough memory for transient
  2032                                  
  2033 0000029B B448                    	mov	ah,48h
  2034                                  	;mov	ah,ALLOC
  2035 0000029D CD21                    	int	21h		; get the largest block
  2036 0000029F 7225                    	jc	short nomem_err	; something is really screwed up
  2037                                  
  2038 000002A1 50                      	push	ax		; save memory address
  2039 000002A2 01D8                    	add	ax,bx		; ax = top of my memory block
  2040 000002A4 29D0                    	sub	ax,dx		; less size of transient
  2041 000002A6 A3[7A01]                	mov	[TrnSeg],ax	; save transient segment
  2042 000002A9 8EC0                    	mov	es,ax		;
  2043 000002AB 58                      	pop	ax		; restore our seg addr
  2044                                  
  2045                                  ; Everything is set for a move. We need to move in the reverse direction to
  2046                                  ; make sure we dont overwrite ourselves while copying
  2047                                  
  2048 000002AC 01CE                    	add	si,cx
  2049 000002AE 4E                      	dec	si
  2050 000002AF 01CF                    	add	di,cx
  2051 000002B1 4F                      	dec	di
  2052 000002B2 FD                      	std
  2053 000002B3 F3A4                    	rep	movsb
  2054 000002B5 FC                      	cld
  2055                                  
  2056                                  ; Now we have to free up this block so that resident can get hold of it
  2057                                  
  2058 000002B6 8EC0                    	mov	es,ax
  2059 000002B8 B449                    	mov	ah,49h
  2060                                  	;mov	ah,DEALLOC
  2061 000002BA CD21                    	int	21h		; release the memory block
  2062                                  
  2063                                  ; M004; End of changes
  2064                                  
  2065                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2066                                  	; 09/01/2023
  2067 000002BC C606[FF01]00            	mov	byte [InitFlag],0	
  2068                                  
  2069 000002C1 07                      	pop	es
  2070 000002C2 1F                      	pop	ds
  2071                                  	;assume	ds:nothing
  2072                                  	
  2073                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2074                                  	
  2075 000002C3 E9B8FD                  	jmp	LodCom_Trap	; allocate transient
  2076                                  
  2077                                  nomem_err:
  2078                                  
  2079                                  ;We call the error routine which will never return. It will either exit
  2080                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2081                                  ;message ( if first COMMAND )
  2082                                  
  2083 000002C6 E9F518                  	jmp	Alloc_error
  2084                                  
  2085                                  ;EndCodeInit:	; label	byte		; M004
  2086                                  
  2087                                  	; 16/04/2023
  2088                                  	EndCodeInit equ $
  2089                                  
  2090                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2091                                  ;; M004; If not, we signal an assembly error
  2092                                  ;
  2093                                  ;IF2
  2094                                  ;	IF ($ GT EndPipe)
  2095                                  ;		.err
  2096                                  ;		%out	"ENDINIT CODE TOO BIG"
  2097                                  ;	ENDIF
  2098                                  ;ENDIF
  2099                                  
  2100                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2101                                  ;;
  2102                                  ;		ORG	EndPipe		; M004
  2103                                  
  2104                                  ; 09/01/2023
  2105                                  
  2106                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2107                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2108                                  
  2109                                  ; 16/04/2023
  2110                                  	FillBytes equ EndPipe - EndCodeInit
  2111                                  
  2112                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2113                                  ; 16/04/2023
  2114                                  %if FillBytes>0
  2115                                  	;times EndPipe - EndCodeInit db 0
  2116 000002C9 00<rep 5Ah>             	times FillBytes db 0
  2117                                  %endif
  2118                                  
  2119                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2120                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289
  2121                                  
  2122                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h
  2123                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2124                                  
  2125 00000323 [0202]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2126 00000325 [5102]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2127                                  
  2128                                  Exec_Block:	; label	byte	; the data block for exec calls
  2129 00000327 0000                    EnvirSeg:	dw	0
  2130                                  Com_Ptr:	; label	dword
  2131 00000329 8000                    		dw	80h	; point at unformatted parameters
  2132 0000032B 0000                    		dw	0
  2133                                  Com_Fcb1:	; label	dword
  2134 0000032D 5C00                    		dw	5Ch
  2135 0000032F 0000                    		dw	0
  2136                                  Com_Fcb2:	; label	dword
  2137 00000331 6C00                    		dw	6Ch
  2138 00000333 0000                    		dw	0
  2139                                  
  2140                                  ; variables passed to transient
  2141                                  TranVars:	; label	byte
  2142                                  		;dw	offset DATARES:HeadFix_Trap
  2143 00000335 [9200]                  		dw	HeadFix_Trap
  2144 00000337 0000                    MySeg:		dw	0	; put our own segment here
  2145 00000339 0000                    LTpa:		dw	0	; will store tpa segment here
  2146 0000033B 2F                      RSwitChar:	db	"/"
  2147 0000033C 5C                      RDirChar:	db	"\"
  2148                                  		;dw	offset DATARES:Issue_Exec_Call
  2149 0000033D [C800]                  		dw	Issue_Exec_Call
  2150 0000033F 0000                    MySeg1:		dw	0
  2151                                  		;dw	offset DATARES:RemCheck_Trap
  2152 00000341 [6A00]                  		dw	RemCheck_Trap
  2153 00000343 0000                    MySeg2:		dw	0
  2154                                  
  2155                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
  2156                                  %if 0
  2157                                  ResTest: 	dw	0
  2158                                  %endif
  2159                                  
  2160 00000345 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2161                                  
  2162                                  TranVarEnd:	; label	byte
  2163                                  
  2164 00000347 0000                    OldErrNo:	dw	0
  2165                                  
  2166                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2167                                  ;  MsgBuffer is only used while a command is being executed.
  2168                                  ;  SafePathBuffer is no longer needed, since it is used for
  2169                                  ;  unsuccessful program launches.
  2170                                  
  2171                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2172                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2173                                  	;Bugbug: Why so big a buffer?
  2174                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2175 00000349 00<rep 50h>             		times	64+3+13 db 0		
  2176                                  
  2177                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2178                                  
  2179 00000399 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2180 0000039D 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2181                                  
  2182                                  ;SR;
  2183                                  ; The three vars below have been added for a pure COMMAND.COM
  2184                                  
  2185 0000039F 0000                    ResSize:	dw	0
  2186                                  
  2187                                  ;SR;
  2188                                  ; Moved the stack here from the code segment
  2189                                  ;
  2190                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2191                                  	
  2192                                  		;db	(80h - 3) dup (?)
  2193 000003A1 90                      align 2
  2194 000003A2 00<rep 7Ch>             		times	124 db 0		
  2195                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2196                                  RStack:		; label	word
  2197 0000041E 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2198                                  				; resident code segments
  2199                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2200                                  
  2201                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2202                                  ; -------------------------------
  2203                                  
  2204                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2205                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2206                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2207                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2208                                  ;            given a command-line like "/L:3,500;4"
  2209                                  ; UmbUsed  - An array of characters, each of which is 1 if the UMB
  2210                                  ;            matching its index number was specified on the command-line;
  2211                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2212                                  ;            will be set to 1. All others will be set to 0.
  2213                                  ; UmbSize  - An array of words, each of which is interpreted as a size
  2214                                  ;            specified by the user for a UMB (in the above example, all
  2215                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2216                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2217                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2218                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2219                                  ;            for details).
  2220                                  
  2221                                  ; - MSDOS 6.0 COMMAND.COM -
  2222                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2223                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2224                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2225                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2226                                  ;; space problem (it's just such a nice round number, eh?).
  2227                                  
  2228                                  ;MAXUMB	equ	16
  2229                                  
  2230                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2231                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2232                                  
  2233 00000420 00                      fInHigh:	db	0
  2234                                  
  2235                                  ; MSDOS 6.0 COMMAND.COM
  2236                                  ;fUmbTiny:	db	0
  2237                                  ;SegLoad:	dw	0
  2238                                  ;UmbLoad:	db	0
  2239                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2240                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2241                                  ;fm_umb:	db	0
  2242                                  ;fm_strat:	db	0
  2243                                  ;fm_argc:	db	0
  2244                                  
  2245                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2246                                  ; UmbLoad is set to the UMB number given.
  2247                                  
  2248                                  ;*** MESSAGES
  2249                                  ;    and other translatable text
  2250                                  
  2251                                  ; include comrmsg.inc	; M00
  2252                                  ; ------------------------------
  2253                                  
  2254                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2255                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2256                                  
  2257 00000421 41                      ABORT_CHAR:	db 'A'
  2258 00000422 52                      RETRY_CHAR:	db 'R'
  2259 00000423 49                      IGNORE_CHAR:	db 'I'
  2260 00000424 46                      FAIL_CHAR:	db 'F'
  2261 00000425 59                      YES_CHAR:	db 'Y'
  2262 00000426 4E                      NO_CHAR:	db 'N'
  2263 00000427 05                      REQ_ABORT:	db 5
  2264 00000428 41626F7274              		db 'Abort'
  2265 0000042D 07                      REQ_RETRY:	db 7
  2266 0000042E 2C205265747279          		db ', Retry'
  2267 00000435 08                      REQ_IGNORE:	db 8
  2268 00000436 2C2049676E6F7265        		db ', Ignore'
  2269 0000043E 06                      REQ_FAIL:	db 6
  2270 0000043F 2C204661696C            		db ', Fail'
  2271 00000445 01                      REQ_END:	db 1
  2272 00000446 3F                      		db '?'
  2273 00000447 08                      MREAD:		db 8
  2274 00000448 72656164696E6700        		db 'reading', 0
  2275 00000450 08                      MWRITE:		db 8
  2276 00000451 77726974696E6700        		db 'writing', 0
  2277 00000459 0E                      MDRIVE:		db 14
  2278 0000045A 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2278 00000463 2025320D0A         
  2279 00000468 0F                      MDEVICE:	db 15
  2280 00000469 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2280 00000472 652025320D0A       
  2281 00000478 26                      MVOLSERIAL:	db 38
  2282 00000479 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2282 00000482 7365727420766F6C75-
  2282 0000048B 6D6520253120736572-
  2282 00000494 69616C2025322D2533-
  2282 0000049D 0D0A               
  2283 0000049F 25                      BADFATMSG:	db 37
  2284 000004A0 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2284 000004A9 636174696F6E207461-
  2284 000004B2 626C65206261642C20-
  2284 000004BB 64726976652025310D-
  2284 000004C4 0A                 
  2285 000004C5 15                      COMBAD:		db 21
  2286 000004C6 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2286 000004CF 4F4D4D414E442E434F-
  2286 000004D8 4D0D0A             
  2287 000004DB 21                      PUTBACKMSG:	db 33
  2288 000004DC 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2288 000004E5 736B20776974682025-
  2288 000004EE 3120696E2064726976-
  2288 000004F7 652025320D0A       
  2289 000004FD 21                      PROMPT:		db 33
  2290 000004FE 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2290 00000507 206B657920746F2063-
  2290 00000510 6F6E74696E7565202E-
  2290 00000519 202E202E0D0A       
  2291 0000051F 1C                      ENDBATMES:	db 28
  2292 00000520 0D0A                    		db 0Dh,0Ah
  2293 00000522 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2293 0000052B 206261746368206A6F-
  2293 00000534 622028592F4E293F   
  2294 0000053C 13                      EXECEMES:	db 19
  2295 0000053D 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2295 00000546 65637574652025310D-
  2295 0000054F 0A                 
  2296 00000550 13                      EXEBAD:		db 19
  2297 00000551 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2297 0000055A 4558452066696C650D-
  2297 00000563 0A                 
  2298 00000564 22                      TOOBIG:		db 34
  2299 00000565 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2299 0000056E 6F6F2062696720746F-
  2299 00000577 2066697420696E206D-
  2299 00000580 656D6F72790D0A     
  2300 00000587 16                      NOHANDMES:	db 22
  2301 00000588 0D0A                    		db 0Dh,0Ah
  2302 0000058A 4E6F20667265652066-     		db 'No free file handles'
  2302 00000593 696C652068616E646C-
  2302 0000059C 6573               
  2303 0000059E 1A                      RBADNAM:	db 26
  2304 0000059F 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2304 000005A8 6E64206F722066696C-
  2304 000005B1 65206E616D650D0A   
  2305                                  ACCDENIED:	; 14/01/2023
  2306                                  		; 10/01/2023
  2307                                  ACCDEN:		;db 14
  2308                                  		;db 'Access denied '
  2309                                  		; 19/07/2024 - PCDOS 7.1
  2310 000005B9 0D                      		db 13
  2311 000005BA 416363657373206465-     		db 'Access denied'
  2311 000005C3 6E696564           
  2312 000005C7 19                      BMEMMES:	db 25
  2313 000005C8 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2313 000005D1 616C6C6F636174696F-
  2313 000005DA 6E206572726F72     
  2314 000005E1 26                      HALTMES:	db 38
  2315 000005E2 0D0A                    		db 0Dh,0Ah
  2316 000005E4 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2316 000005ED 616420434F4D4D414E-
  2316 000005F6 442C2073797374656D-
  2316 000005FF 2068616C7465640D0A 
  2317 00000608 21                      FRETMES:	db 33
  2318 00000609 0D0A                    		db 0Dh,0Ah,
  2319 0000060B 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2319 00000614 61727420434F4D4D41-
  2319 0000061D 4E442C206578697469-
  2319 00000626 6E670D0A           
  2320 0000062A 2E                      PATRICIDE:	db 46
  2321 0000062B 0D0A                    		db 0Dh,0Ah
  2322 0000062D 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2322 00000636 2070726F6365737320-
  2322 0000063F 61626F727465642C20-
  2322 00000648 63616E6E6F7420636F-
  2322 00000651 6E74696E7565       
  2323 00000657 0D0A                    		db 0Dh,0Ah
  2324 00000659 02                      NEWLINE:	db 2
  2325 0000065A 0D0A                    		db 0Dh, 0Ah
  2326                                  
  2327                                  ; 10/01/2023
  2328                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2329                                  
  2330 0000065C [400B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2331 0000065E 0100                    		dw 1
  2332 00000660 [FB08]                  		dw PARSMSGPTRS		; parse	error messages
  2333 00000662 0100                    		dw 1
  2334 00000664 [400B]                  		dw EXTMSGPTRS		; critical error messages
  2335 00000666 0100                    		dw 1
  2336 00000668 0000                    		dw 0			; File system error messages
  2337 0000066A 0000                    		dw 0			; are not supported.
  2338 0000066C [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2339 0000066E 0000                    MySeg3:		dw 0			; segment of retriever routine
  2340                                  
  2341                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2342                                  
  2343 00000670 13                      CRMSG0:		db 19
  2344 00000671 57726974652070726F-     		db 'Write protect error'
  2344 0000067A 74656374206572726F-
  2344 00000683 72                 
  2345 00000684 0C                      CRMSG1:		db 12
  2346 00000685 496E76616C69642075-     		db 'Invalid unit'
  2346 0000068E 6E6974             
  2347 00000691 09                      CRMSG2:		db 9
  2348 00000692 4E6F74207265616479      		db 'Not ready'
  2349 0000069B 16                      CRMSG3:		db 22
  2350 0000069C 496E76616C69642064-     		db 'Invalid device request'
  2350 000006A5 657669636520726571-
  2350 000006AE 75657374           
  2351 000006B2 0A                      CRMSG4:		db 10
  2352 000006B3 44617461206572726F-     		db 'Data error'
  2352 000006BC 72                 
  2353 000006BD 21                      CRMSG5:		db 33
  2354 000006BE 496E76616C69642064-     		db 'Invalid device request parameters'
  2354 000006C7 657669636520726571-
  2354 000006D0 756573742070617261-
  2354 000006D9 6D6574657273       
  2355 000006DF 0A                      CRMSG6:		db 10
  2356 000006E0 5365656B206572726F-     		db 'Seek error'
  2356 000006E9 72                 
  2357 000006EA 12                      CRMSG7:		db 18
  2358 000006EB 496E76616C6964206D-     		db 'Invalid media type'
  2358 000006F4 656469612074797065 
  2359 000006FD 10                      CRMSG8:		db 16
  2360 000006FE 536563746F72206E6F-     		db 'Sector not found'
  2360 00000707 7420666F756E64     
  2361 0000070E 1A                      CRMSG9:		db 26
  2362 0000070F 5072696E746572206F-     		db 'Printer out of paper error'
  2362 00000718 7574206F6620706170-
  2362 00000721 6572206572726F72   
  2363 00000729 11                      CRMSG10:	db 17
  2364 0000072A 577269746520666175-     		db 'Write fault error'
  2364 00000733 6C74206572726F72   
  2365 0000073B 10                      CRMSG11:	db 16
  2366 0000073C 52656164206661756C-     		db 'Read fault error'
  2366 00000745 74206572726F72     
  2367 0000074C 0F                      CRMSG12:	db 15
  2368 0000074D 47656E6572616C2066-     		db 'General failure'
  2368 00000756 61696C757265       
  2369 0000075C 11                      CRMSG13:	db 17
  2370 0000075D 53686172696E672076-     		db 'Sharing violation'
  2370 00000766 696F6C6174696F6E   
  2371 0000076E 0E                      CRMSG14:	db 14
  2372 0000076F 4C6F636B2076696F6C-     		db 'Lock violation'
  2372 00000778 6174696F6E         
  2373 0000077D 13                      CRMSG15:	db 19
  2374 0000077E 496E76616C69642064-     		db 'Invalid disk change'
  2374 00000787 69736B206368616E67-
  2374 00000790 65                 
  2375 00000791 0F                      CRMSG16:	db 15
  2376 00000792 46434220756E617661-     		db 'FCB unavailable'
  2376 0000079B 696C61626C65       
  2377 000007A1 19                      CRMSG17:	db 25
  2378 000007A2 53797374656D207265-     		db 'System resource exhausted'
  2378 000007AB 736F75726365206578-
  2378 000007B4 68617573746564     
  2379 000007BB 12                      CRMSG18:	db 18
  2380 000007BC 436F64652070616765-     		db 'Code page mismatch'
  2380 000007C5 206D69736D61746368 
  2381 000007CE 0C                      CRMSG19:	db 12
  2382 000007CF 4F7574206F6620696E-     		db 'Out of input'
  2382 000007D8 707574             
  2383 000007DB 17                      CRMSG20:	db 23
  2384 000007DC 496E73756666696369-     		db 'Insufficient disk space'
  2384 000007E5 656E74206469736B20-
  2384 000007EE 7370616365         
  2385                                  
  2386                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2387                                  
  2388 000007F3 [7006]                  CRITMSGPTRS:	dw CRMSG0
  2389 000007F5 [8406]                  		dw CRMSG1
  2390 000007F7 [9106]                  		dw CRMSG2
  2391 000007F9 [9B06]                  		dw CRMSG3
  2392 000007FB [B206]                  		dw CRMSG4
  2393 000007FD [BD06]                  		dw CRMSG5
  2394 000007FF [DF06]                  		dw CRMSG6
  2395 00000801 [EA06]                  		dw CRMSG7
  2396 00000803 [FD06]                  		dw CRMSG8
  2397 00000805 [0E07]                  		dw CRMSG9
  2398 00000807 [2907]                  		dw CRMSG10
  2399 00000809 [3B07]                  		dw CRMSG11
  2400 0000080B [4C07]                  		dw CRMSG12
  2401 0000080D [5C07]                  		dw CRMSG13
  2402 0000080F [6E07]                  		dw CRMSG14
  2403 00000811 [7D07]                  		dw CRMSG15
  2404 00000813 [9107]                  		dw CRMSG16
  2405 00000815 [A107]                  		dw CRMSG17
  2406 00000817 [BB07]                  		dw CRMSG18
  2407 00000819 [CE07]                  		dw CRMSG19
  2408 0000081B [DB07]                  		dw CRMSG20
  2409                                  
  2410                                  		; 14/01/2023
  2411                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2412                                  
  2413 0000081D 13                      PAERRMSG0:	db 19
  2414 0000081E 546F6F206D616E7920-     		db 'Too many parameters'
  2414 00000827 706172616D65746572-
  2414 00000830 73                 
  2415 00000831 1A                      PAERRMSG1:	db 26
  2416 00000832 526571756972656420-     		db 'Required parameter missing'
  2416 0000083B 706172616D65746572-
  2416 00000844 206D697373696E67   
  2417 0000084C 0E                      PAERRMSG2:	db 14
  2418 0000084D 496E76616C69642073-     		db 'Invalid switch'
  2418 00000856 7769746368         
  2419 0000085B 0F                      PAERRMSG3:	db 15
  2420 0000085C 496E76616C6964206B-     		db 'Invalid keyword'
  2420 00000865 6579776F7264       
  2421 0000086B 01                      PAERRMSG4:	db 1
  2422 0000086C 20                      		db 20h
  2423 0000086D 24                      PAERRMSG5:	db 36
  2424 0000086E 506172616D65746572-     		db 'Parameter value not in allowed range'
  2424 00000877 2076616C7565206E6F-
  2424 00000880 7420696E20616C6C6F-
  2424 00000889 7765642072616E6765 
  2425                                  PAERRMSG6:	; 10/01/2023
  2426 00000892 1B                      PAERRMSG7:	db 27
  2427 00000893 506172616D65746572-     		db 'Parameter value not allowed'
  2427 0000089C 2076616C7565206E6F-
  2427 000008A5 7420616C6C6F776564 
  2428                                  ;PAERRMSG7:	db 27
  2429                                  ;		db 'Parameter value not allowed'
  2430 000008AE 1C                      PAERRMSG8:	db 28
  2431 000008AF 506172616D65746572-     		db 'Parameter format not correct'
  2431 000008B8 20666F726D6174206E-
  2431 000008C1 6F7420636F72726563-
  2431 000008CA 74                 
  2432 000008CB 11                      PAERRMSG9:	db 17
  2433 000008CC 496E76616C69642070-     		db 'Invalid parameter'
  2433 000008D5 6172616D65746572   
  2434 000008DD 1D                      PAERRMSG10:	db 29
  2435 000008DE 496E76616C69642070-     		db 'Invalid parameter combination'
  2435 000008E7 6172616D6574657220-
  2435 000008F0 636F6D62696E617469-
  2435 000008F9 6F6E               
  2436                                  
  2437                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2438                                  
  2439 000008FB [1D08]                  PARSMSGPTRS:	dw PAERRMSG0
  2440 000008FD [3108]                  		dw PAERRMSG1
  2441 000008FF [4C08]                  		dw PAERRMSG2
  2442 00000901 [5B08]                  		dw PAERRMSG3
  2443 00000903 [6B08]                  		dw PAERRMSG4
  2444 00000905 [6D08]                  		dw PAERRMSG5
  2445 00000907 [9208]                  		dw PAERRMSG6
  2446 00000909 [9208]                  		dw PAERRMSG7
  2447 0000090B [AE08]                  		dw PAERRMSG8
  2448 0000090D [CB08]                  		dw PAERRMSG9
  2449 0000090F [DD08]                  		dw PAERRMSG10
  2450                                  ; 21/04/2023
  2451                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2452                                  
  2453 00000911 10                      INVLFUNCT:	db 16
  2454 00000912 496E76616C69642066-     		db 'Invalid function'
  2454 0000091B 756E6374696F6E     
  2455 00000922 0E                      FNOTFOUND:	db 14
  2456 00000923 46696C65206E6F7420-     		db 'File not found'
  2456 0000092C 666F756E64         
  2457 00000931 0E                      PNOTFOUND:	db 14
  2458 00000932 50617468206E6F7420-     		db 'Path not found'
  2458 0000093B 666F756E64         
  2459 00000940 13                      TOOMANYOF:	db 19
  2460 00000941 546F6F206D616E7920-     		db 'Too many open files'
  2460 0000094A 6F70656E2066696C65-
  2460 00000953 73                 
  2461                                  ; 14/01/2023
  2462                                  ;ACCDEN:	; 10/01/2023
  2463                                  ;ACCDENIED:	db 14
  2464                                  ;		db 'Access denied '
  2465 00000954 0E                      INVHANDLE:	db 14
  2466 00000955 496E76616C69642068-     		db 'Invalid handle'
  2466 0000095E 616E646C65         
  2467 00000963 1F                      MEMCBDEST:	db 31
  2468 00000964 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2468 0000096D 6E74726F6C20626C6F-
  2468 00000976 636B73206465737472-
  2468 0000097F 6F796564           
  2469 00000983 13                      INSUFFMEM:	db 19
  2470 00000984 496E73756666696369-     		db 'Insufficient memory'
  2470 0000098D 656E74206D656D6F72-
  2470 00000996 79                 
  2471 00000997 1C                      INVMEMBLA:	db 28
  2472 00000998 496E76616C6964206D-     		db 'Invalid memory block address'
  2472 000009A1 656D6F727920626C6F-
  2472 000009AA 636B20616464726573-
  2472 000009B3 73                 
  2473 000009B4 13                      INVENVIRO:	db 19
  2474 000009B5 496E76616C69642045-     		db 'Invalid Environment'
  2474 000009BE 6E7669726F6E6D656E-
  2474 000009C7 74                 
  2475 000009C8 0E                      INVFORMAT:	db 14
  2476 000009C9 496E76616C69642066-     		db 'Invalid format'
  2476 000009D2 6F726D6174         
  2477 000009D7 1A                      INVFNPARM:	db 26
  2478 000009D8 496E76616C69642066-     		db 'Invalid function parameter'
  2478 000009E1 756E6374696F6E2070-
  2478 000009EA 6172616D65746572   
  2479 000009F2 0C                      INVLDDATA:	db 12
  2480 000009F3 496E76616C69642064-     		db 'Invalid data'
  2480 000009FC 617461             
  2481 000009FF 1B                      INVDRVSPC:	db 27
  2482 00000A00 496E76616C69642064-     		db 'Invalid drive specification'
  2482 00000A09 726976652073706563-
  2482 00000A12 696669636174696F6E 
  2483 00000A1B 23                      ATRCURDIR:	db 35
  2484 00000A1C 417474656D70742074-     		db 'Attempt to remove current directory'
  2484 00000A25 6F2072656D6F766520-
  2484 00000A2E 63757272656E742064-
  2484 00000A37 69726563746F7279   
  2485 00000A3F 0F                      NOTSAMDEV:	db 15
  2486 00000A40 4E6F742073616D6520-     		db 'Not same device'
  2486 00000A49 646576696365       
  2487 00000A4F 0D                      NOMOREFIL:	db 13
  2488 00000A50 4E6F206D6F72652066-     		db 'No more files'
  2488 00000A59 696C6573           
  2489 00000A5D 0B                      FILEXISTS:	db 11
  2490 00000A5E 46696C652065786973-     		db 'File exists'
  2490 00000A67 7473               
  2491 00000A69 1B                      CANTMKDIR:	db 27
  2492 00000A6A 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2492 00000A73 6B6520646972656374-
  2492 00000A7C 6F727920656E747279 
  2493 00000A85 0E                      FAILINT24:	db 14
  2494 00000A86 4661696C206F6E2049-     		db 'Fail on INT 24'
  2494 00000A8F 4E54203234         
  2495 00000A94 15                      TOOMANYRD:	db 21
  2496 00000A95 546F6F206D616E7920-     		db 'Too many redirections'
  2496 00000A9E 726564697265637469-
  2496 00000AA7 6F6E73             
  2497 00000AAA 15                      DUPLREDIR:	db 21
  2498 00000AAB 4475706C6963617465-     		db 'Duplicate redirection'
  2498 00000AB4 207265646972656374-
  2498 00000ABD 696F6E             
  2499 00000AC0 10                      INVPASSWD:	db 16
  2500 00000AC1 496E76616C69642070-     		db 'Invalid password'
  2500 00000ACA 617373776F7264     
  2501 00000AD1 11                      INVLDPARM:	db 17
  2502 00000AD2 496E76616C69642070-     		db 'Invalid parameter'
  2502 00000ADB 6172616D65746572   
  2503 00000AE3 12                      NETDATFAU:	db 18
  2504 00000AE4 4E6574776F726B2064-     		db 'Network data fault'
  2504 00000AED 617461206661756C74 
  2505 00000AF6 21                      FNOSUPNET:	db 33
  2506 00000AF7 46756E6374696F6E20-     		db 'Function not supported by network'
  2506 00000B00 6E6F7420737570706F-
  2506 00000B09 72746564206279206E-
  2506 00000B12 6574776F726B       
  2507 00000B18 27                      RSCNOTINS:	db 39
  2508 00000B19 526571756972656420-     		db 'Required system component not installed'
  2508 00000B22 73797374656D20636F-
  2508 00000B2B 6D706F6E656E74206E-
  2508 00000B34 6F7420696E7374616C-
  2508 00000B3D 6C6564             
  2509                                  
  2510                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2511                                  
  2512 00000B40 [1109]                  EXTMSGPTRS:	dw INVLFUNCT
  2513 00000B42 [2209]                  		dw FNOTFOUND
  2514 00000B44 [3109]                  		dw PNOTFOUND
  2515 00000B46 [4009]                  		dw TOOMANYOF
  2516 00000B48 [B905]                  		dw ACCDENIED
  2517 00000B4A [5409]                  		dw INVHANDLE
  2518 00000B4C [6309]                  		dw MEMCBDEST
  2519 00000B4E [8309]                  		dw INSUFFMEM
  2520 00000B50 [9709]                  		dw INVMEMBLA
  2521 00000B52 [B409]                  		dw INVENVIRO
  2522 00000B54 [C809]                  		dw INVFORMAT
  2523 00000B56 [D709]                  		dw INVFNPARM
  2524 00000B58 [F209]                  		dw INVLDDATA
  2525 00000B5A 0000                    		dw 0
  2526 00000B5C [FF09]                  		dw INVDRVSPC
  2527 00000B5E [1B0A]                  		dw ATRCURDIR
  2528 00000B60 [3F0A]                  		dw NOTSAMDEV
  2529 00000B62 [4F0A]                  		dw NOMOREFIL
  2530 00000B64 [7006]                  		dw CRMSG0
  2531 00000B66 [8406]                  		dw CRMSG1
  2532 00000B68 [9106]                  		dw CRMSG2
  2533 00000B6A [9B06]                  		dw CRMSG3
  2534 00000B6C [B206]                  		dw CRMSG4
  2535 00000B6E [BD06]                  		dw CRMSG5
  2536 00000B70 [DF06]                  		dw CRMSG6
  2537 00000B72 [EA06]                  		dw CRMSG7
  2538 00000B74 [FD06]                  		dw CRMSG8
  2539 00000B76 [0E07]                  		dw CRMSG9
  2540 00000B78 [2907]                  		dw CRMSG10
  2541 00000B7A [3B07]                  		dw CRMSG11
  2542 00000B7C [4C07]                  		dw CRMSG12
  2543 00000B7E [5C07]                  		dw CRMSG13
  2544 00000B80 [6E07]                  		dw CRMSG14
  2545 00000B82 [7D07]                  		dw CRMSG15
  2546 00000B84 [9107]                  		dw CRMSG16
  2547 00000B86 [A107]                  		dw CRMSG17
  2548 00000B88 [BB07]                  		dw CRMSG18
  2549 00000B8A [CE07]                  		dw CRMSG19
  2550 00000B8C [DB07]                  		dw CRMSG20
  2551 00000B8E 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2552 00000BDE [5D0A]                  		dw FILEXISTS
  2553 00000BE0 0000                    		dw 0
  2554 00000BE2 [690A]                  		dw CANTMKDIR
  2555 00000BE4 [850A]                  		dw FAILINT24
  2556 00000BE6 [940A]                  		dw TOOMANYRD
  2557 00000BE8 [AA0A]                  		dw DUPLREDIR
  2558 00000BEA [C00A]                  		dw INVPASSWD
  2559 00000BEC [D10A]                  		dw INVLDPARM
  2560 00000BEE [E30A]                  		dw NETDATFAU
  2561 00000BF0 [F60A]                  		dw FNOSUPNET
  2562 00000BF2 [180B]                  		dw RSCNOTINS
  2563                                  ; ----------------------------------------------------------------------------
  2564                                  	; 17/04/2023
  2565                                  ExtMsgEnd:
  2566                                  
  2567                                  ; 21/04/2023
  2568                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2569                                  
  2570                                  ; ----------------------------------------------------------------------------
  2571                                  
  2572                                  ; 20/04/2023
  2573                                  
  2574 00000BF4 90<rep Ch>              align 16
  2575                                  
  2576                                  ; ----------------------------------------------------------------------------
  2577                                  
  2578                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2579                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2580                                  
  2581                                  ; ----------------------------------------------------------------------------
  2582                                  ; SEGMENT - CODERES
  2583                                  ; ----------------------------------------------------------------------------
  2584                                  
  2585                                  ; 11/01/2023
  2586                                  RCODE_START:	
  2587                                  
  2588                                  ; ----------------------------------------------------------------------------
  2589                                  ;***	EXEC error handling
  2590                                  ;
  2591                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2592                                  ;	We examine the error code and select an appropriate message.
  2593                                  ; --------------------------
  2594                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2595                                  ;	Condense the error scan?
  2596                                  ;	RBADNAM is checked by transient, no need here?
  2597                                  ;	Move below Ext_Exec.
  2598                                  ; ----------------------------------------------------------------------------
  2599                                  
  2600                                  Exec_Err:
  2601                                  ;SR;
  2602                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2603                                  ; in order here
  2604                                  
  2605                                  ;	Bugbug:	can we use byte compares here?
  2606                                  ;	Might be able to use byte msg#s, too.
  2607                                  
  2608                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2609                                  ;	Speed not high priority here.
  2610                                  
  2611                                  ;	Move this to transient.
  2612                                  
  2613                                  	; 10/01/2023
  2614                                  
  2615                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2616 00000C00 BA[9E05]                	mov	dx,RBADNAM
  2617 00000C03 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2618 00000C05 741B                    	je	short GotExecEMes		; bad command
  2619                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2620 00000C07 BA[6405]                	mov	dx,TOOBIG
  2621 00000C0A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2622 00000C0C 7414                    	je	short GotExecEMes		; file not found
  2623                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2624 00000C0E BA[5005]                	mov	dx,EXEBAD
  2625 00000C11 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2626 00000C13 740D                    	je	short GotExecEMes		; bad exe file
  2627                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2628 00000C15 BA[B905]                	mov	dx,ACCDEN
  2629 00000C18 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2630 00000C1A 7406                    	je	short GotExecEMes		; access denied
  2631                                  
  2632                                  Default_Message:
  2633                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2634 00000C1C BA[3C05]                	mov	dx,EXECEMES
  2635                                  						; default message
  2636 00000C1F BE[1B01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2637                                  						; get address of subst block
  2638                                  GotExecEMes:
  2639                                  	;mov	dx,bx				; DX = ptr to msg
  2640 00000C22 E85006                  	call	RPrint ; invoke	RPrint
  2641 00000C25 EB09                    	jmp	short NoExec
  2642                                  
  2643                                  ; ----------------------------------------------------------------------------
  2644                                  ;***	EXEC call
  2645                                  ;
  2646                                  ;	The transient has set up everything for an EXEC system call.
  2647                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2648                                  ;	so that we may be able to recover cleanly upon success.
  2649                                  ;
  2650                                  ;	CS,DS,ES,SS = DATARES seg addr
  2651                                  ; ----------------------------------------------------------------------------
  2652                                  
  2653                                  Ext_Exec:
  2654                                  ;SR;
  2655                                  ; The words put on the stack by the stub will be popped off when we finally
  2656                                  ;jump to LodCom (by LodCom).
  2657                                  
  2658                                  	; 10/01/2023
  2659                                  	;int	21h			; do the exec
  2660                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2661                                  Exec_Ret:
  2662 00000C27 72D7                    	jc	short Exec_Err		; exec failed
  2663                                  
  2664                                  ;	The exec has completed. Retrieve the exit code.
  2665                                  
  2666                                  Exec_Wait:
  2667 00000C29 B44D                    	mov	ah,4Dh
  2668                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2669 00000C2B CD21                    	int	21h			; get the return code
  2670                                  	;mov	[cs:RetCode],ax
  2671                                  	; 11/01/2023
  2672 00000C2D A3[8501]                	mov	[RetCode],ax
  2673                                  
  2674                                  ;	See if we can reload the transient. The external command
  2675                                  ;	may have overwritten part of the transient.
  2676                                  
  2677                                  NoExec:
  2678                                  ;SR;
  2679                                  ; ds = es = ss = DATARES when we jump to LodCom
  2680                                  ;
  2681 00000C30 E97701                  	jmp	LodCom
  2682                                  
  2683                                  ; ----------------------------------------------------------------------------
  2684                                  ;***	Int 23 (ctrl-c) handler
  2685                                  ;
  2686                                  ;	This is the default system INT 23 handler. All processes
  2687                                  ;	(including COMMAND) get it by default. There are some
  2688                                  ;	games that are played: We ignore ^C during most of the
  2689                                  ;	INIT code. This is because we may perform an ALLOC and
  2690                                  ;	diddle the header! Also, if we are prompting for date/time
  2691                                  ;	in the init code, we are to treat ^C as empty responses.
  2692                                  ; ---------------------------
  2693                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2694                                  ; ----------------------------------------------------------------------------
  2695                                  
  2696                                  ;SR;
  2697                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2698                                  ;both these values off the stack now
  2699                                  ;
  2700                                  ;ContC	proc	far
  2701                                  
  2702                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2703                                  
  2704                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2705                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2706                                  ContC:
  2707 00000C33 1F                      	pop	ds			; ds = DATARES
  2708                                  ;	assume	ds:DATARES
  2709                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2710                                  
  2711 00000C34 F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1
  2712                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2713 00000C39 740D                    	jz	short NotAtInit		; no
  2714 00000C3B F606[FF01]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2715                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2716 00000C40 7404                    	jz	short CmdIret		; no, ignore ^C
  2717 00000C42 1F                      	pop	ds			; restore before jumping; M021
  2718                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2719 00000C43 E9E80D                  	jmp	init_contc_specialcase
  2720                                  CmdIret:
  2721                                  ;SR;
  2722                                  ; Restore ds to its previous value
  2723                                  ;
  2724                                  
  2725                                  ;;	mov	ds,[OLdDS]		;
  2726 00000C46 1F                      	pop	ds
  2727 00000C47 CF                      	iret				; yes, ignore the ^C
  2728                                  
  2729                                  NotAtInit:
  2730 00000C48 F606[FF01]04            	test	byte [InitFlag],INITCTRLC ; 4
  2731                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2732 00000C4D 7411                    	jz	short NotInit 		; nope too.
  2733                                  
  2734                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2735                                  ;	to set carry and return to the user sans flags only if the
  2736                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2737                                  
  2738                                  	;cmp	ah,1
  2739                                  	;jb	short CmdIret
  2740                                  	; 19/07/2024
  2741 00000C4F 84E4                    	test	ah,ah
  2742 00000C51 74F3                    	jz	short CmdIret
  2743                                  
  2744 00000C53 80FC0C                  	cmp	ah,12
  2745 00000C56 77EE                    	ja	short CmdIret
  2746                                  
  2747 00000C58 1F                      	pop	ds			;restore ds to old value
  2748 00000C59 83C406                  	add	sp,6			; remove int frame
  2749 00000C5C F9                      	stc
  2750                                  
  2751                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2752 00000C5D CA0200                  	retf	2			; remove those flags...
  2753                                  
  2754                                  NotInit:
  2755                                  
  2756                                  ;*	We have now received a ^C for some process (maybe ourselves
  2757                                  ;	but not at INIT).
  2758                                  ;	
  2759                                  ;	Note that we are running on the user's stack!!! Bad news if
  2760                                  ;	any of the system calls below go and issue another INT
  2761                                  ;	24... Massive stack overflow! Another bad point is that
  2762                                  ;	SavHand will save an already saved handle, thus losing a
  2763                                  ;	possible redirection...
  2764                                  ;	
  2765                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2766                                  ;	The above code will correctly flag the ^C diring the
  2767                                  ;	message output and prompting while ignoring the ^C the rest
  2768                                  ;	of the time.
  2769                                  ;	
  2770                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2771                                  ;	file, we ask if he wants to terminate it. If he does, then
  2772                                  ;	we turn off all internal flags and let the DOS abort.
  2773                                  
  2774 00000C60 800E[FF01]04            	or	byte [InitFlag],INITCTRLC ; 4
  2775                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2776 00000C65 FB                      	sti
  2777                                  
  2778                                  ;	push	cs			; el yucko! change the user's ds!!
  2779                                  ;	pop	ds
  2780                                  
  2781                                  ;	assume	ds:RESGROUP
  2782                                  
  2783 00000C66 58                      	pop	ax			; discard the old ds value
  2784                                  
  2785 00000C67 A1[8E01]                	mov	ax,[SingleCom]
  2786 00000C6A 09C0                    	or	ax,ax
  2787 00000C6C 7506                    	jnz	short NoReset
  2788 00000C6E 50                      	push	ax
  2789 00000C6F B40D                    	mov	ah,DISK_RESET ; 0Dh
  2790 00000C71 CD21                    	int	21h			; reset disks in case files were open
  2791 00000C73 58                      	pop	ax
  2792                                  
  2793                                  NoReset:
  2794                                  
  2795                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2796                                  ;	walk the entire active list and free each segment. Here,
  2797                                  ;	we just free the single batch segment.
  2798                                  
  2799 00000C74 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2800 00000C7A 7451                    	jz	short ContCTerm
  2801 00000C7C 09C0                    	or	ax,ax
  2802 00000C7E 754D                    	jnz	short ContCTerm
  2803 00000C80 E88402                  	call	SavHand
  2804 00000C83 E89203                  	call	AskEnd			; ask if user wants to end batch
  2805                                  
  2806                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2807                                  
  2808 00000C86 733F                    	jnc	short ContBatch
  2809 00000C88 8A0E[8801]              	mov	cl,[EchoFlag]		; get current echo flag
  2810 00000C8C 53                      	push	bx
  2811                                  
  2812                                  ClearBatch:
  2813 00000C8D 8E06[3401]              	mov	es,[Batch]		; get batch segment
  2814                                  	;mov	di,20h
  2815                                  	; 06/06/2023 (BugFix)
  2816 00000C91 BF2000                  	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
  2817                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2818                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2819 00000C94 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2820                                  	; MSDOS 3.3 ([ES:4])
  2821                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2822                                  	;
  2823                                  	; 19/07/2024
  2824                                  	;cmp	bx,0			; is a FOR in progress
  2825                                  	;je	short No_Bat_For	; no - don't deallocate
  2826 00000C99 85DB                    	test	bx,bx
  2827 00000C9B 7408                    	jz	short No_Bat_For
  2828                                  
  2829 00000C9D 06                      	push	es			;
  2830 00000C9E 8EC3                    	mov	es,bx			; yes - free it up...
  2831 00000CA0 B449                    	mov	ah,49h
  2832                                  	;mov	ah,DEALLOC ; 49h	;
  2833 00000CA2 CD21                    	int	21h			;
  2834 00000CA4 07                      	pop	es			; restore to batch segment
  2835                                  
  2836                                  No_Bat_For:
  2837                                  	;mov	cl,[es:1]
  2838 00000CA5 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2839                                  	;mov	bx,[es:3]
  2840 00000CAA 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2841 00000CAF B449                    	mov	ah,49h
  2842                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2843 00000CB1 CD21                    	int	21h
  2844 00000CB3 891E[3401]              	mov	[Batch],bx		; get ready to deallocate next batch
  2845 00000CB7 FF0E[9701]              	dec	word [Nest]		; is there another batch file?
  2846 00000CBB 75D0                    	jnz	short ClearBatch	; keep going until no batch file
  2847                                  
  2848                                  ;	We are terminating a batch file; restore the echo status
  2849                                  
  2850                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2851 00000CBD 5B                      	pop	bx
  2852 00000CBE 880E[8801]              	mov	[EchoFlag],cl		; reset echo status
  2853                                  	; 29/05/2018
  2854 00000CC2 C606[0002]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2855                                  
  2856                                  ContBatch:
  2857 00000CC7 E8A805                  	call	crlf			; print out crlf before returning
  2858 00000CCA E86302                  	call	RestHand
  2859                                  
  2860                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2861                                  
  2862                                  ContCTerm:
  2863 00000CCD 31C0                    	xor	ax,ax			; indicate no read
  2864 00000CCF 89C5                    	mov	bp,ax
  2865                                  
  2866                                  ;	The following resetting of the state flags is good for the
  2867                                  ;	generalized batch processing.
  2868                                  
  2869 00000CD1 A2[9301]                	mov	[IfFlag],al		; turn off iffing
  2870 00000CD4 A2[9401]                	mov	[ForFlag],al		; turn off for processing
  2871 00000CD7 E81C00                  	call	ResPipeOff
  2872 00000CDA 3906[8E01]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2873 00000CDE 7406                    	jz	short NoSetSing
  2874 00000CE0 C706[8E01]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2875                                  					;  pipe, batch, for
  2876                                  NoSetSing:
  2877                                  
  2878                                  ;	If we are doing an internal command, go through the reload process.
  2879                                  ;	If we are doing an external, let DOS abort the process.
  2880                                  ;	In both cases, we are now done with the ^C processing.
  2881                                  
  2882 00000CE6 8026[FF01]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2883 00000CEB 3806[8401]              	cmp	[ExtCom],al
  2884 00000CEF 7503                    	jnz	short DoDAb		; internal ^c
  2885 00000CF1 E94501                  	jmp	LodCom1
  2886                                  DoDAb:
  2887 00000CF4 F9                      	stc				; tell dos to abort
  2888                                  
  2889                                  ;SR;
  2890                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2891                                  ;by setting carry and leaving flags on the stack
  2892                                  
  2893 00000CF5 CB                      	retf				; Leave flags on stack
  2894                                  
  2895                                  ;ContC	endp
  2896                                  
  2897                                  ;SR;
  2898                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2899                                  ;both have ds = DATARES
  2900                                  
  2901                                  	; 11/01/2023
  2902                                  ResPipeOff:
  2903 00000CF6 50                      	push	ax
  2904 00000CF7 31C0                    	xor	ax,ax
  2905                                  	;xchg	al,[cs:PIPEFLAG]
  2906 00000CF9 8606[0002]              	xchg	al,[PipeFlag]
  2907 00000CFD 08C0                    	or	al,al
  2908 00000CFF 7404                    	jz	short NoPipePop
  2909                                  	;shr	byte [cs:ECHOFLAG],1
  2910 00000D01 D02E[8801]              	shr	byte [EchoFlag],1
  2911                                  NoPipePop:
  2912 00000D05 58                      	pop	ax
  2913 00000D06 C3                      	retn
  2914                                  
  2915                                  ;CODERES ends
  2916                                  
  2917                                  ;=============================================================================
  2918                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2919                                  ;=============================================================================
  2920                                  ; 21/09/2018 - Retro DOS v3.0
  2921                                  
  2922                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2923                                  ;	name	COMMAND2
  2924                                  
  2925                                  ;/*
  2926                                  ; *                      Microsoft Confidential
  2927                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2928                                  ; *                      All Rights Reserved.
  2929                                  ; */
  2930                                  
  2931                                  ;
  2932                                  ;	Revision History
  2933                                  ;	================
  2934                                  ;
  2935                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2936                                  ;			reserve memory by changing int 12h and then give it
  2937                                  ;			back to DOS by changing arenas in autoexec.bat.
  2938                                  ;			This makes command.com reload transient and this
  2939                                  ;			cannot be done at this stage.
  2940                                  ;
  2941                                  
  2942                                  ;CODERES segment public byte
  2943                                  
  2944                                  ;*	If we cannot allocate enough memory for the transient or there
  2945                                  ;	was some other allocation error, we display a message and
  2946                                  ;	then die.
  2947                                  
  2948                                  ;SR;
  2949                                  ; We will have to make sure that at this entry point and at FatalC, 
  2950                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2951                                  ;and so we should be able to do this
  2952                                  
  2953                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2954                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2955                                  
  2956                                  	;assume	ds:DATARES
  2957                                  BadMemErr:
  2958 00000D07 BA[C705]                	mov	dx,BMEMMES			; DX = ptr to msg
  2959                                  FatalC:
  2960                                  	; 12/01/2023
  2961                                  ;;	push	cs
  2962                                  ;;	pop	ds
  2963                                  ;;	assume	ds:ResGroup
  2964                                  ;	invoke	RPrint
  2965                                  
  2966                                  	; 12/01/2023
  2967                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2968 00000D0A E86805                  	call	RPrint
  2969                                  
  2970                                  	; MSDOS 3.3
  2971                                  	;call	RDISPMSG
  2972                                  
  2973                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2974                                  ;	we can't do anything else!
  2975                                  
  2976 00000D0D 803E[8D01]00            	cmp	byte [PermCom],0
  2977 00000D12 7410                    	je	short FatalRet
  2978                                  
  2979                                  ;	We are a permanent command. If we are in the process of the
  2980                                  ;	magic interrupt (Singlecom) then exit too.
  2981                                  
  2982 00000D14 833E[8E01]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2983 00000D19 7509                    	jne	short FatalRet			; must take int_2e exit
  2984                                  
  2985                                  ;	Permanent command. We can't do ANYthing except halt.
  2986                                  
  2987 00000D1B BA[E105]                	mov	dx,HALTMES			; DX = ptr to msg
  2988                                  	;invoke	RPrint
  2989                                  	; 12/01/2023	
  2990                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2991 00000D1E E85405                  	call	RPrint	
  2992                                  	; MSDOS 3.3
  2993                                  	;call	RDISPMSG
  2994 00000D21 FB                      	sti
  2995                                  Stall:
  2996 00000D22 EBFE                    	jmp	short Stall			; crash the system nicely
  2997                                  
  2998                                  FatalRet:
  2999 00000D24 BA[0806]                	mov	dx,FRETMES			; DX = ptr to msg
  3000                                  	;call	RDISPMSG
  3001                                  	; 12/01/2023	
  3002 00000D27 E84B05                  	call	RPrint	
  3003                                  FatalRet2:
  3004 00000D2A 803E[8D01]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  3005 00000D2F 7517                    	jne	short Ret_2e			; must be int_2e
  3006                                  
  3007                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3008                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3009                                  ;	case we decide to do that.)
  3010                                  
  3011 00000D31 A1[2901]                	mov	ax,[Parent]
  3012                                  	;mov	[16h],ax
  3013 00000D34 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3014 00000D37 A1[2B01]                	mov	ax,[OldTerm]
  3015                                  	;mov	[0Ah],ax
  3016 00000D3A A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3017 00000D3D A1[2D01]                	mov	ax,[OldTerm+2]
  3018                                  	;mov	[0Ch],ax
  3019 00000D40 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3020 00000D43 B8004C                  	mov	ax,4C00h
  3021                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3022 00000D46 CD21                    	int	21h
  3023                                  Ret_2e:
  3024                                  ;SR;
  3025                                  ; We will ensure that ds = DATARES for all entries to this place
  3026                                  ;
  3027                                  
  3028                                  ;;	push	cs
  3029                                  ;;	pop	ds
  3030                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3031                                    	
  3032                                  ;	assume	ds:DATARES
  3033                                  
  3034                                  	;PUSH	CS
  3035                                  	;POP	DS
  3036                                  
  3037 00000D48 C706[8E01]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3038 00000D4E 8E06[4503]              	mov	es,[Res_Tpa]
  3039                                  	;mov	ah,49h	; 12/01/2023
  3040 00000D52 B449                    	mov	ah,DEALLOC
  3041 00000D54 CD21                    	int	21h			; free up space used by transient
  3042 00000D56 8B1E[2701]              	mov	bx,[Save_Pdb]
  3043 00000D5A B450                    	mov	ah,50h
  3044                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3045 00000D5C CD21                    	int	21h			; current process is user
  3046 00000D5E A1[8501]                	mov	ax,[RetCode]
  3047 00000D61 803E[8401]00            	cmp	byte [ExtCom],0
  3048 00000D66 7502                    	jne	short GotECode
  3049 00000D68 31C0                    	xor	ax,ax			; internals always return 0
  3050                                  GotECode:
  3051 00000D6A C606[8401]01            	mov	byte [ExtCom],1		; force external
  3052                                  
  3053                                  ;SR; This is actually returning to the caller. However, the old code had
  3054                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3055                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3056                                  
  3057                                  	; 12/01/2023
  3058 00000D6F FF2E[2301]              	jmp	far [Int_2e_Ret]	; "iret"
  3059                                  
  3060                                  ;***	Int_2e, magic command executer
  3061                                  
  3062                                  Int_2e:
  3063                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3064                                  ;SR;
  3065                                  ;We are going to come here from the stub with the old ds and DATARES value
  3066                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3067                                  
  3068                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3069                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3070                                  
  3071 00000D73 1F                      	pop	ds			; ds = DATARES
  3072                                  	;assume	ds:DATARES
  3073 00000D74 58                      	pop	ax
  3074                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3075                                  
  3076                                  	;pop	word [cs:Int_2e_Ret]
  3077                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3078                                  	;pop	ax			; chuck flags
  3079 00000D75 8F06[2301]              	pop	word [Int_2e_Ret]
  3080 00000D79 8F06[2501]              	pop	word [Int_2e_Ret+2]
  3081                                  	
  3082 00000D7D 83C402                  	add	sp,2
  3083                                  
  3084                                  ;;	push	cs
  3085                                  ;;	pop	es
  3086                                  
  3087 00000D80 1E                      	push	ds
  3088 00000D81 07                      	pop	es			; es = DATARES
  3089                                  ;	;mov	ds,OldDS
  3090 00000D82 8ED8                    	mov	ds,ax
  3091                                  	;assume	ds:nothing		; ds = old value
  3092                                  
  3093 00000D84 BF8000                  	mov	di,80h
  3094 00000D87 B94000                  	mov	cx,64
  3095                                  ;	Bugbug:	cld
  3096 00000D8A F3A5                    	rep	movsw
  3097 00000D8C B451                    	mov	ah,51h
  3098                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3099 00000D8E CD21                    	int	21h			; get user's header
  3100                                  	; 12/01/2023
  3101 00000D90 26891E[2701]            	mov	[es:Save_Pdb],bx
  3102                                  	;mov	[cs:Save_Pdb],bx
  3103 00000D95 B450                    	mov	ah,50h
  3104                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3105                                  
  3106                                  ;;	mov	bx,cs
  3107                                  ;SR;
  3108                                  ;Set ds = DATARES because BadMemErr expects this
  3109                                  
  3110                                  	; 12/01/2023
  3111 00000D97 06                      	push	es
  3112 00000D98 1F                      	pop	ds
  3113                                  	;assume	ds:DATARES
  3114                                  
  3115 00000D99 8CDB                    	mov	bx,ds			; es = our PSP now
  3116                                  	;mov	bx,cs
  3117                                  
  3118 00000D9B CD21                    	int	21h			; current process is me
  3119                                  	;mov	word [cs:SingleCom],81h
  3120                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3121                                  	; 12/01/2023
  3122 00000D9D C706[8E01]8100          	mov	word [SingleCom],81h
  3123 00000DA3 C606[8401]01            	mov	byte [ExtCom],1		; make sure this case forced
  3124                                  
  3125                                  ;SR;
  3126                                  ;We can enter LodCom directly after a command shell is terminated or we
  3127                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3128                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3129                                  ;be properly set. To fake this, we push dummy values here.
  3130                                  
  3131                                  	; 12/01/2023
  3132 00000DA8 1E                      	push	ds			; old value of ds
  3133 00000DA9 1E                      	push	ds			; data seg value, ds = DATARES
  3134                                  LodCom: 				; termination handler
  3135 00000DAA 1F                      	pop	ds			; ds = DATARES
  3136                                  	;assume	ds:DATARES
  3137 00000DAB 83C402                  	add	sp,2
  3138                                  ;	;pop	OldDS			; store old ds
  3139                                  	;cmp	ExtCom,0
  3140 00000DAE 803E[8401]00            	cmp	byte [ExtCom],0
  3141                                  	;cmp	byte [cs:ExtCom],0
  3142                                  	;jne	short @f	 	; internal cmd - memory allocated
  3143                                  	; 16/04/2023
  3144 00000DB3 7503                    	jne	short LodCom0 ; 24/09/2018
  3145 00000DB5 E98100                  	jmp	LodCom1
  3146                                  	;je	short LodCom1 ; 25/09/2018	
  3147                                  ;@@:
  3148                                  LodCom0: ; 24/09/2018
  3149 00000DB8 BBFFFF                  	mov	bx,0FFFFh
  3150 00000DBB B448                    	mov	ah,48h	; 12/01/2023
  3151                                  	;mov	ah,ALLOC ; 48h	
  3152 00000DBD CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3153                                  				; BX = number of 16-byte paragraphs desired
  3154 00000DBF E80A00                  	call	SetSize
  3155 00000DC2 83C020                  	add	ax,20h
  3156 00000DC5 39C3                    	cmp	bx,ax
  3157 00000DC7 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3158                                  BadMemErrJ:
  3159 00000DC9 E93BFF                  	jmp	BadMemErr		; not enough memory
  3160                                  
  3161                                  ;***	SetSize - get transient size in paragraphs
  3162                                  
  3163                                  SetSize:
  3164                                  	; 12/01/2023
  3165                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3166                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3167 00000DCC B87E95                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3168 00000DCF B104                    	mov	cl,4
  3169 00000DD1 D3E8                    	shr	ax,cl
  3170 00000DD3 C3                      	retn
  3171                                  
  3172                                  MemOk:
  3173                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3174                                  
  3175 00000DD4 B448                    	mov	ah,48h
  3176                                  	;mov	ah,ALLOC  ; 48h
  3177 00000DD6 CD21                    	int	21h
  3178 00000DD8 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3179                                  	;mov	byte [cs:ExtCom],0
  3180                                  	;mov	[cs:Res_Tpa],ax
  3181                                  	; 12/01/2023
  3182 00000DDA C606[8401]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3183 00000DDF A3[4503]                	mov	[Res_Tpa],ax		; save current tpa segment
  3184                                  
  3185 00000DE2 2500F0                  	and	ax,0F000h
  3186 00000DE5 050010                  	add	ax,1000h		; round up to next 64k boundary
  3187 00000DE8 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3188                                  
  3189                                  ;	Make sure that new boundary is within allocated range
  3190                                  
  3191                                  	;mov	dx,[cs:Res_Tpa]
  3192                                  	; 12/01/2023
  3193 00000DEA 8B16[4503]              	mov	dx,[Res_Tpa]
  3194 00000DEE 01DA                    	add	dx,bx			; compute maximum address
  3195 00000DF0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3196 00000DF2 7608                    	jbe	short Bad_Tpa
  3197                                  
  3198                                  ;	Must have 64K of usable space.
  3199                                  
  3200 00000DF4 29C2                    	sub	dx,ax			; compute the usable space
  3201 00000DF6 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3202 00000DFA 7303                    	jae	short LTpaSet
  3203                                  Bad_Tpa:
  3204                                  	;mov	ax,[cs:Res_Tpa]
  3205                                  	; 12/01/2023
  3206 00000DFC A1[4503]                	mov	ax,[Res_Tpa]
  3207                                  LTpaSet:
  3208                                  	;mov	[cs:LTPA],ax
  3209                                  	;mov	ax,[cs:Res_Tpa]
  3210                                  	; 12/01/2023
  3211 00000DFF A3[3903]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3212 00000E02 A1[4503]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3213 00000E05 01C3                    	add	bx,ax
  3214                                  	;mov	[cs:MemSiz],bx
  3215 00000E07 891E[8001]              	mov	[MemSiz],bx
  3216 00000E0B E8BEFF                  	call	SetSize
  3217 00000E0E 29C3                    	sub	bx,ax
  3218                                  
  3219                                  	; MSDOS 6.0
  3220                                  
  3221                                  ;M038; Start of changes
  3222                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3223                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3224                                  ;running a program that changes arenas. This changes the largest block that
  3225                                  ;command.com gets and so changes the transient segment. So, command.com does
  3226                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3227                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3228                                  ;reload fails, hanging the system. To get around this we just copy the
  3229                                  ;transient from the previous address to the new address(if changed) and
  3230                                  ;then let command.com do the checksum. So, if the transient area is not
  3231                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3232                                  ;is not really corrupted and so this should work.
  3233                                  
  3234                                  	; 12/01/2023
  3235                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3236                                  
  3237 00000E10 3B1E[7A01]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3238 00000E14 7423                    	je	short LodCom1		; yes, dont copy
  3239                                  
  3240                                  ;Check if the new segment is above or below the current move. If the new
  3241                                  ;segment is above (i.e new block is larger than previous block), then we
  3242                                  ;have to move in the reverse direction
  3243                                  
  3244                                  	;mov	cx,98C5h
  3245 00000E16 B96F95                  	mov	cx,TRANSPACEEND		; cx = length to move
  3246 00000E19 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3247 00000E1B 31F6                    	xor	si,si			; normal move
  3248 00000E1D 89F7                    	mov	di,si
  3249 00000E1F FC                      	cld
  3250 00000E20 EB06                    	jmp	short copy_trans
  3251                                  mov_down:
  3252 00000E22 89CE                    	mov	si,cx			; reverse move, start from end
  3253 00000E24 4E                      	dec	si
  3254 00000E25 89F7                    	mov	di,si
  3255 00000E27 FD                      	std
  3256                                  copy_trans:
  3257 00000E28 1E                      	push	ds
  3258 00000E29 06                      	push	es
  3259 00000E2A 8EC3                    	mov	es,bx			; dest segment
  3260 00000E2C 8E1E[7A01]              	mov	ds,[TrnSeg]		; source segment
  3261                                  	;assume	ds:nothing
  3262                                  
  3263 00000E30 F3A4                    	rep	movsb			; copy transient
  3264 00000E32 FC                      	cld
  3265 00000E33 07                      	pop	es
  3266 00000E34 1F                      	pop	ds
  3267                                  	;assume	ds:DATARES
  3268                                  
  3269                                  ;M038; End of changes
  3270                                  
  3271                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3272                                  	; 12/01/2023
  3273 00000E35 891E[7A01]              	mov	[TrnSeg],bx
  3274                                  
  3275                                  LodCom1:
  3276                                  ;;	mov	ax,cs
  3277                                  ;;	mov	ss,ax
  3278                                  ;SR; At this point ds = DATARES which is where the stack is located
  3279                                  
  3280                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3281                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3282 00000E39 8CD8                    	mov	ax,ds
  3283 00000E3B 8ED0                    	mov	ss,ax
  3284                                  	;assume	ss:DATARES
  3285                                  	;;mov	sp,offset DATARES:RStack
  3286                                  	;mov	sp,53Eh
  3287 00000E3D BC[1E04]                	mov	sp,RStack
  3288                                  
  3289                                  ;;	mov	ds,ax
  3290                                  
  3291                                  	;assume	ds:DATARES
  3292                                  	
  3293                                  	; MSDOS 3.3
  3294                                  	;mov	ax,cs
  3295                                  	;mov	ss,ax
  3296                                  	;mov	sp,RSTACK
  3297                                  	;mov	ds,ax
  3298                                  
  3299 00000E40 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3300 00000E43 31ED                    	xor	bp,bp			; flag command ok
  3301 00000E45 B8FFFF                  	mov	ax,-1
  3302 00000E48 8706[9001]              	xchg	ax,[VerVal]
  3303 00000E4C 83F8FF                  	cmp	ax,-1
  3304 00000E4F 7404                    	je	short NoSetVer
  3305 00000E51 B42E                    	mov	ah,2Eh
  3306                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3307 00000E53 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3308                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3309                                  NoSetVer:
  3310 00000E55 833E[8E01]FF            	cmp	word [SingleCom],-1
  3311 00000E5A 7503                    	jne	short NoSng
  3312 00000E5C E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3313                                  NoSng:
  3314 00000E5F E87201                  	call	ChkSum			; check the transient
  3315                                  	;cmp	dx,[Sum]
  3316                                  	;je	short HavCom		; transient ok
  3317                                  	; 12/01/2023
  3318 00000E62 7412                    	jz	short HavCom
  3319                                  Bogus_Com:
  3320 00000E64 C606[3301]01            	mov	byte [Loading],1	; flag DskErr routine
  3321 00000E69 E81E01                  	call	LoadCom
  3322                                  ChkSame:
  3323 00000E6C E86501                  	call	ChkSum
  3324                                  	;cmp	dx,[Sum]
  3325                                  	;je	short HavCom		; same command
  3326                                  	; 12/01/2023
  3327 00000E6F 7405                    	jz	short HavCom
  3328                                  Also_Bogus:
  3329 00000E71 E85801                  	call	WrongCom
  3330 00000E74 EBF6                    	jmp	short ChkSame
  3331                                  
  3332                                  	; 12/01/2023
  3333                                  ;HavCom:
  3334                                  ;	; 25/09/2018
  3335                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3336                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3337                                  ;			; Return: AL = FFh unsupported subfunction
  3338                                  ;			; DL = current switch character
  3339                                  ;	mov     [RSWITCHAR],dl
  3340                                  ;	cmp     dl,'/'
  3341                                  ;	jnz     short USESLASH
  3342                                  ;	;mov	cl,'\'
  3343                                  ;	;mov	[RDIRCHAR],cl
  3344                                  ;	mov	byte [RDIRCHAR],'\'
  3345                                  ;USESLASH:
  3346                                  
  3347                                  HavCom:
  3348                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3349 00000E76 C606[3301]00            	mov	byte [Loading],0		; flag to DskErr
  3350                                  	;;mov	si,offset DATARES:TranVars
  3351                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3352 00000E7B BE[3503]                	mov	si,TranVars
  3353                                  	;;mov	di,offset TRANGROUP:HeadCall
  3354                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3355 00000E7E BF[A38A]                	mov	di,HEADCALL
  3356 00000E81 8E06[7A01]              	mov	es,[TrnSeg]
  3357 00000E85 FC                      	cld
  3358                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3359 00000E86 B9[4703]                	mov	cx,TranVarEnd
  3360 00000E89 29F1                    	sub	cx,si
  3361 00000E8B F3A4                    	rep	movsb			; transfer info to transient
  3362 00000E8D A1[8001]                	mov	ax,[MemSiz]
  3363 00000E90 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3364                                  
  3365                                  ;***	TJmp - jump-off to transient
  3366                                  ;
  3367                                  ;	Public label so debugger can find this spot.
  3368                                  
  3369                                  TJmp:	; 12/01/2023
  3370 00000E93 FF2E[7801]              	jmp	far [Trans]		; jmp dword ptr Trans
  3371                                  
  3372                                  ;***	TRemCheck - far version of RemCheck for transient
  3373                                  
  3374                                  TRemCheck:
  3375                                  	; 12/01/2023
  3376 00000E97 1F                      	pop	ds			; ds = DATARES
  3377 00000E98 83C402                  	add	sp,2			; discard old value of ds
  3378                                  
  3379 00000E9B E80100                  	call	RemCheck
  3380 00000E9E CB                      	retf
  3381                                  
  3382                                  ;***	RemCheck
  3383                                  ;
  3384                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3385                                  ;
  3386                                  ;	EXIT	ZR set if removeable media
  3387                                  ;		ZR clear if fixed media
  3388                                  ;
  3389                                  ;	USED	none
  3390                                  
  3391                                  	; 12/01/2023
  3392                                  RemCheck:
  3393 00000E9F 50                      	push	ax
  3394 00000EA0 53                      	push	bx
  3395 00000EA1 89C3                    	mov	bx,ax
  3396 00000EA3 B80844                  	mov	ax,4408h
  3397                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3398 00000EA6 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3399 00000EA8 7304                    	jnc	short rcCont		
  3400                                  
  3401                                  ;	If an error occurred, assume the media is non-removable.
  3402                                  ;	AX contains the non-zero error code from the int 21, so
  3403                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3404                                  ;	appear to be non-removable.				
  3405                                  					
  3406 00000EAA 09C0                    	or	ax,ax			
  3407 00000EAC EB05                    	jmp	short ResRegs
  3408                                  rcCont:
  3409 00000EAE 83E001                  	and	ax,1
  3410 00000EB1 F7D0                    	not	ax
  3411                                  ResRegs:
  3412 00000EB3 5B                      	pop	bx
  3413 00000EB4 58                      	pop	ax
  3414 00000EB5 C3                      	retn
  3415                                  
  3416                                  ;***	THeadFix
  3417                                  ;
  3418                                  ;	Far version of HeadFix, called from transient.
  3419                                  
  3420                                  THeadFix:
  3421                                  	; 12/01/2023
  3422 00000EB6 1F                      	pop	ds			; ds = DATARES
  3423 00000EB7 83C402                  	add	sp,2			; discard old ds value on stack
  3424                                  
  3425 00000EBA E80100                  	call	HeadFix
  3426 00000EBD CB                      	retf
  3427                                  
  3428                                  ;***	HeadFix
  3429                                  
  3430                                  	; 12/01/2023
  3431                                  HeadFix:
  3432 00000EBE E83101                  	call	SetVect			; set vectors to our values
  3433                                  
  3434                                  ;	Clean up header
  3435                                  
  3436                                  ;	Bugbug:	optimize:
  3437                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3438                                  
  3439 00000EC1 31DB                    	xor	bx,bx			; BX = handle = 0
  3440 00000EC3 8B0E[8A01]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3441                                  	;mov	dx,[18h] 
  3442 00000EC7 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3443 00000ECB 38D1                    	cmp	cl,dl
  3444 00000ECD 7408                    	je	short Chk1		; stdin matches
  3445 00000ECF B43E                    	mov	ah,3Eh
  3446                                  	;mov	ah,CLOSE  ; 3Eh
  3447 00000ED1 CD21                    	int	21h			; close stdin
  3448                                  	;mov	[18h],cl
  3449 00000ED3 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3450                                  Chk1:
  3451 00000ED7 43                      	inc	bx			; BX = handle = 1
  3452 00000ED8 38F5                    	cmp	ch,dh			
  3453 00000EDA 7408                    	je	short ChkOtherHand	; stdout matches
  3454 00000EDC B43E                    	mov	ah,3Eh
  3455                                  	;mov	ah,CLOSE
  3456 00000EDE CD21                    	int	21h			; close stdout
  3457                                  	;mov	[19h],ch
  3458 00000EE0 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3459                                  ChkOtherHand:
  3460 00000EE4 83C304                  	add	bx,4			; skip handles 2,3,4
  3461 00000EE7 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3462                                  					; (handles 0-4 already done)
  3463                                  CloseLoop:
  3464 00000EEA B43E                    	mov	ah,3Eh
  3465                                  	;mov	ah,CLOSE ; 3Eh
  3466 00000EEC CD21                    	int	21h			; close each handle
  3467 00000EEE 43                      	inc	bx			; BX = next handle
  3468 00000EEF E2F9                    	loop	CloseLoop
  3469                                  
  3470                                  	; MSDOS 6.0
  3471                                  ;	Bugbug:	since this is for transient code, move it there
  3472                                  	
  3473                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3474                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3475                                  
  3476                                  ;	M012: remove this CS -> DS. Must've been missed during
  3477                                  ;	purification.
  3478                                  ;;	push	ds			; save data segment
  3479                                  ;;	push	cs			; get local segment into DS
  3480                                  ;;	pop	ds			;
  3481 00000EF1 803E[AD01]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3482 00000EF6 750E                    	jne	short Append_Fix_End	; no - just exit
  3483 00000EF8 B807B7                  	mov	ax,0B707h
  3484                                  	;mov	ax,AppendSetState	; set the state of Append
  3485 00000EFB 8B1E[AB01]              	mov	bx,[Append_State] 	; back to the original state
  3486 00000EFF CD2F                    	int	2Fh			;
  3487 00000F01 C606[AD01]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3488                                  Append_Fix_End: 			;
  3489                                  ;;	pop	ds			; get data segment back
  3490 00000F06 C3                      	retn
  3491                                  
  3492                                  	; MSDOS 3.3
  3493                                  	;retn
  3494                                  
  3495                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3496                                  ;
  3497                                  ;	ENTRY	nothing
  3498                                  ;
  3499                                  ;	EXIT	nothing
  3500                                  ;
  3501                                  ;	USED	flags
  3502                                  ;
  3503                                  ;	EFFECTS
  3504                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3505                                  ;	  current program's stdin,stdout set to our stderr
  3506                                  ;
  3507                                  
  3508                                  ;SR;
  3509                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3510                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3511                                  
  3512                                  SavHand:
  3513                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3514                                  
  3515                                  	; 12/01/2023
  3516                                  	;push	ds ; MSDOS 3.3
  3517                                  
  3518 00000F07 53                      	push	bx			;preserve registers
  3519 00000F08 50                      	push	ax
  3520                                  	; 12/01/2023
  3521 00000F09 06                      	push	es
  3522 00000F0A 1E                      	push	ds			; save DATARES value
  3523                                  
  3524 00000F0B B451                    	mov	ah,51h
  3525                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3526 00000F0D CD21                    	int	21h			; BX = user's header seg addr
  3527 00000F0F 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3528                                  	;lds	bx,[34h]	
  3529 00000F11 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3530 00000F15 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3531                                  	; 12/01/2023
  3532 00000F17 07                      	pop	es			; es = DATARES
  3533 00000F18 06                      	push	es			; save it back on stack
  3534 00000F19 26A3[3101]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3535                                  	;mov	[cs:HANDLE01],ax
  3536                                  
  3537                                  ;SR;
  3538                                  ; Use es to address Handle01 & our JFN_Table
  3539                                  
  3540                                  	; 12/01/2023
  3541                                  	;mov	al,[es:1Ah]
  3542 00000F1D 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3543                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3544 00000F21 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3545 00000F23 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3546                                  	; 12/01/2023
  3547 00000F25 1F                      	pop	ds			; restore registers
  3548 00000F26 07                      	pop	es
  3549 00000F27 58                      	pop	ax
  3550 00000F28 5B                      	pop	bx
  3551                                  	;pop	ds ; MSDOS 3.3
  3552 00000F29 C3                      	retn
  3553                                  
  3554                                  	;assume	ds:DATARES
  3555                                  GetComDsk2:
  3556 00000F2A E81F00                  	call	GetComDsk
  3557 00000F2D E909FF                  	jmp	LodCom1			; memory already allocated
  3558                                  
  3559                                  RestHand:
  3560 00000F30 1E                      	push	ds
  3561 00000F31 53                      	push	bx			; restore stdin, stdout to user
  3562 00000F32 50                      	push	ax
  3563                                  	; 12/01/2023
  3564 00000F33 B451                    	mov	ah,51h
  3565                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3566 00000F35 CD21                    	int	21h			; point to user's header
  3567 00000F37 A1[3101]                	mov	ax,[Handle01]
  3568 00000F3A 8EDB                    	mov	ds,bx
  3569                                  	;assume ds:NOTHING
  3570                                  	;lds	bx,[34h] 
  3571 00000F3C C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3572 00000F40 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3573 00000F42 58                      	pop	ax
  3574 00000F43 5B                      	pop	bx
  3575 00000F44 1F                      	pop	ds
  3576 00000F45 C3                      	retn
  3577                                  
  3578                                  	;assume ds:DATARES,ss:DATARES
  3579                                  Hopeless:
  3580 00000F46 BA[C504]                	mov	dx,COMBAD
  3581 00000F49 E9BEFD                  	jmp	FatalC
  3582                                  
  3583                                  GetComDsk:
  3584 00000F4C A0[7F01]                	mov	al,[ComDrv]
  3585 00000F4F E84DFF                  	call	RemCheck
  3586 00000F52 75F2                    	jnz	short Hopeless		; non-removable media
  3587                                  GetComDsk3:
  3588 00000F54 81FA[C504]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3589 00000F58 7503                    	jne	short GetComDsk4
  3590                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3591                                  	; 12/01/2023
  3592                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3593                                  	;invoke	RPrint			; say COMMAND is invalid
  3594 00000F5A E81803                  	call	RPrint
  3595                                  	;call	RDISPMSG
  3596                                  
  3597                                  GetComDsk4:
  3598                                  
  3599                                  ;	Bugbug:	there's always a drive here? No need to check?
  3600                                  
  3601 00000F5D 803E[1A01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3602 00000F62 7509                    	jne	short Users_Drive	; yes - use it
  3603 00000F64 B419                    	mov	ah,19h
  3604                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3605 00000F66 CD21                    	int	21h
  3606 00000F68 0441                    	add	al,"A"                  ; convert to ascii
  3607 00000F6A A2[1A01]                	mov	[PutBackDrv],al		; put in message to print out
  3608                                  
  3609                                  Users_Drive:
  3610                                  	; 12/01/2023
  3611                                  	; MSDOS 6.0
  3612 00000F6D BA[DB04]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3613                                  	;mov	si,offset DATARES:PutBackSubst
  3614                                  	;invoke	RPrint
  3615 00000F70 BE[1401]                	mov	si,PutBackSubst		; containing COMMAND
  3616 00000F73 E8FF02                  	call	RPrint
  3617                                  	;mov	dx,offset DATARES:Prompt
  3618                                  	;invoke	RPrint
  3619 00000F76 BA[FD04]                	mov	dx,PROMPT		; "Press any key"
  3620 00000F79 E8F902                  	call	RPrint
  3621                                  
  3622                                  	; MSDOS 3.3
  3623                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3624                                  	;call	RDISPMSG
  3625                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3626                                  	;mov	si,[COMSPEC_END]
  3627                                  	;mov	byte [si+1],'$'
  3628                                  	;call	RDISPMSG
  3629                                  	;mov	byte [si+1],0
  3630                                  	;mov	dx,PROMPT
  3631                                  	;call	RDISPMSG
  3632                                  
  3633                                  	;call	GetRawFlushedByte
  3634                                  	;retn
  3635                                  	; 12/01/2023
  3636                                  	;jmp	short GetRawFlushedByte
  3637                                  
  3638                                  ;***	GetRawFlushedByte - flush world and get raw input
  3639                                  
  3640                                  GetRawFlushedByte:
  3641                                  	; 12/01/2023
  3642 00000F7C B8070C                  	mov	ax,0C07h
  3643                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3644 00000F7F CD21                    	int	21h			; get char without testing or echo
  3645 00000F81 B8000C                  	mov	ax,0C00h
  3646                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3647 00000F84 CD21                    	int	21h
  3648                                  
  3649                                  ;	Bugbug:	get rid of this return and the following retz.
  3650                                  
  3651                                  LoadCom_retn:
  3652 00000F86 C3                      	retn
  3653                                  
  3654                                  	; 21/04/2023
  3655                                  TryDoOpen:
  3656 00000F87 E8C2FF                  	call	GetComDsk
  3657                                  	;jmp	short LoadCom
  3658                                  
  3659                                  ;***	LoadCom - load in transient
  3660                                  
  3661                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3662                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3663                                  
  3664                                  LoadCom:
  3665                                  	;assume	ds:DATARES
  3666                                  	
  3667 00000F8A 45                      	inc	bp				; flag command read
  3668                                  
  3669 00000F8B BA[3601]                	mov	dx,ComSpec
  3670 00000F8E B8003D                  	mov	ax,3D00h
  3671                                  	;mov	ax,OPEN<<8	; 3D00h
  3672 00000F91 CD21                    	int	21h				; open command.com
  3673 00000F93 730B                    	jnc	short ReadCom
  3674                                  	;cmp	ax,4
  3675 00000F95 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3676 00000F98 75ED                    	jnz	short TryDoOpen
  3677 00000F9A BA[8705]                	mov	dx,NOHANDMES
  3678 00000F9D E96AFD                  	jmp	FatalC				; will never find a handle
  3679                                  
  3680                                  	; 21/04/2023
  3681                                  ;TryDoOpen:
  3682                                  	;call	GetComDsk
  3683                                  	;jmp	short LoadCom
  3684                                  
  3685                                  ReadCom:
  3686 00000FA0 89C3                    	mov	bx,ax				; BX = handle
  3687                                  	;mov	dx,offset RESGROUP:TranStart
  3688 00000FA2 BA0022                  	mov	dx,TRANSTART
  3689 00000FA5 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3690 00000FA7 B80042                  	mov	ax,4200h
  3691                                  	;mov	ax,LSEEK<<8	; 4200h
  3692 00000FAA CD21                    	int	21h
  3693 00000FAC 7210                    	jc	short WrongCom1
  3694                                  	; 12/01/2023
  3695                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3696                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3697 00000FAE B96F94                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3698 00000FB1 1E                      	push	ds
  3699 00000FB2 8E1E[7A01]              	mov	ds,[TrnSeg]
  3700                                  	;assume	ds:NOTHING
  3701 00000FB6 BA0001                  	mov	dx,100h
  3702 00000FB9 B43F                    	mov	ah,3Fh
  3703                                  	;mov	ah,READ	; 3Fh	
  3704 00000FBB CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3705                                  			; BX = file handle, CX = number of bytes to read
  3706                                  			; DS:DX -> buffer
  3707 00000FBD 1F                      	pop	ds
  3708                                  	;assume	ds:DATARES
  3709                                  WrongCom1:
  3710 00000FBE 9C                      	pushf
  3711 00000FBF 50                      	push	ax
  3712 00000FC0 B43E                    	mov	ah,3Eh
  3713                                  	;mov	ah,CLOSE ; 3Eh
  3714 00000FC2 CD21                    	int	21h			; close command.com
  3715 00000FC4 58                      	pop	ax
  3716 00000FC5 9D                      	popf
  3717 00000FC6 7204                    	jc	short WrongCom		; error on read
  3718 00000FC8 39C8                    	cmp	ax,cx
  3719                                  	;retz				; size matched
  3720 00000FCA 74BA                    	jz	short LoadCom_retn
  3721                                  WrongCom:
  3722 00000FCC BA[C504]                	mov	dx,COMBAD
  3723 00000FCF E87AFF                  	call	GetComDsk
  3724 00000FD2 EBB6                    	jmp	short LoadCom		; try again
  3725                                  
  3726                                  ;***	ChkSum - compute transient checksum
  3727                                  
  3728                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3729                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3730                                  ChkSum:
  3731 00000FD4 1E                      	push	ds
  3732 00000FD5 8E1E[7A01]              	mov	ds,[TrnSeg]
  3733 00000FD9 BE0001                  	mov	si,100h
  3734                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3735                                  	;mov	cx,87C2h
  3736 00000FDC B9[F084]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3737                                  Check_Sum:
  3738 00000FDF FC                      	cld
  3739 00000FE0 D1E9                    	shr	cx,1
  3740 00000FE2 31D2                    	xor	dx,dx
  3741                                  Chk:
  3742 00000FE4 AD                      	lodsw
  3743 00000FE5 01C2                    	add	dx,ax
  3744 00000FE7 83D200                  	adc	dx,0
  3745 00000FEA E2F8                    	loop	Chk
  3746                                  
  3747                                  	; 04/05/2023
  3748 00000FEC 1F                      	pop	ds
  3749                                  
  3750                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3751 00000FED 3B16[8201]              	cmp	dx,[Sum]
  3752                                  
  3753                                  	;pop	ds ; 04/05/2023
  3754 00000FF1 C3                      	retn
  3755                                  
  3756                                  ;***	SetVect - set interrupt vectors
  3757                                  
  3758                                  SetVect:
  3759                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3760                                  	; 12/01/2023
  3761 00000FF2 BA[7E00]                	mov	dx,LodCom_Trap
  3762                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3763 00000FF5 B82225                  	mov	ax,2522h
  3764                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3765 00000FF8 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3766 00000FFC 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3767 00001000 CD21                    	int	21h
  3768                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3769 00001002 BA[4A00]                	mov	dx,Ctrlc_Trap
  3770                                  	;mov	dx,CONTC ; MSDOS 3.3
  3771 00001005 FEC0                    	inc	al	; 23h
  3772 00001007 CD21                    	int	21h
  3773                                  	;mov	dx,offset DATARES:CritErr_Trap
  3774 00001009 BA[5500]                	mov	dx,CritErr_Trap
  3775                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3776 0000100C FEC0                    	inc	al	; 24h
  3777 0000100E CD21                    	int	21h
  3778 00001010 C3                      	retn
  3779                                  
  3780                                  	; MSDOS 6.0
  3781                                  ;;SR;
  3782                                  ;We have this to take care of the extra values pushed on the stack by
  3783                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3784                                  ;Lodcom1
  3785                                  
  3786                                  ;public	TrnLodCom1
  3787                                  	; 12/01/2023
  3788                                  TrnLodCom1:
  3789 00001011 1F                      	pop	ds			; ds = DATARES
  3790 00001012 83C402                  	add	sp,2
  3791                                  ;	pop	ds:OldDS
  3792 00001015 E921FE                  	jmp	LodCom1
  3793                                  
  3794                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3795                                  
  3796                                  %if 0
  3797                                  
  3798                                  ;***	EndInit - end up initialization sequence
  3799                                  ;
  3800                                  ;	Move the environment to a newly allocated segment.
  3801                                  
  3802                                  	; MSDOS 3.3
  3803                                  ENDINIT:
  3804                                  	push	ds			; save segments
  3805                                  	push	es			;
  3806                                  	push	cs			; get resident segment to DS
  3807                                  	pop	ds			;
  3808                                  	;assume	ds:RESGROUP
  3809                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3810                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3811                                  	;assume	es:NOTHING
  3812                                  
  3813                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3814                                  	jne	short NO_RESET 		; no - we already did it
  3815                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3816                                  	push	es			; save environment - just to be sure
  3817                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3818                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3819                                  				; ES = segment address of block to change
  3820                                  				; BX = new size in paragraphs
  3821                                  	pop	es
  3822                                  
  3823                                  NO_RESET:
  3824                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3825                                  	mov	ds,[OLDENV]		; source environment segment
  3826                                  	;assume	ds:NOTHING
  3827                                  	xor	si,si			; set up offsets to start of segments
  3828                                  	xor	di,di
  3829                                  	cld
  3830                                  	rep	movsb			; move it
  3831                                  	xor	ax,ax
  3832                                  	stosb				; make sure it ends with double-null
  3833                                  
  3834                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3835                                  	pop	es
  3836                                  	pop	ds
  3837                                  	jmp	LODCOM			; allocate transient
  3838                                  
  3839                                  	; MSDOS 6.0
  3840                                  
  3841                                  ;The init code has been changed to take care of the new way in which the
  3842                                  ;environment segment is allocated.
  3843                                  ;NB: We can use all the init variables at this point because they are all in
  3844                                  ;RESGROUP
  3845                                  ;Bugbug: The above approach will not work for ROMDOS
  3846                                  
  3847                                  ;IF 0
  3848                                  ;
  3849                                  ;EndInit:
  3850                                  ;	push	ds
  3851                                  ;	push	es			;save segments
  3852                                  ;	push	cs
  3853                                  ;	pop	ds		
  3854                                  ;	assume	ds:RESGROUP
  3855                                  ;;
  3856                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3857                                  ;;
  3858                                  ;	mov	bx,ds
  3859                                  ;	mov	es,bx			;es = RESGROUP
  3860                                  ;;
  3861                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3862                                  ;; code + data for low COMMAND
  3863                                  ;;
  3864                                  ;	mov	bx,ResSize		;Total size of resident
  3865                                  ;	mov	ah,SETBLOCK
  3866                                  ;	int	21h			;Set block to resident size
  3867                                  ;;
  3868                                  ;;Allocate the correct size for the environment
  3869                                  ;;
  3870                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3871                                  ;	mov	ah,ALLOC
  3872                                  ;	int	21h			;get memory
  3873                                  ;	jc	nomem_err		;out of memory,signal error
  3874                                  ;
  3875                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3876                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3877                                  ;	mov	es,ax			;es = address of allocated memory
  3878                                  ;	assume	es:nothing
  3879                                  ;
  3880                                  ;;
  3881                                  ;;Copy the environment to the newly allocated segment
  3882                                  ;;
  3883                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3884                                  ;
  3885                                  ;	push	ds
  3886                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3887                                  ;	assume	ds:nothing
  3888                                  ;
  3889                                  ;	xor	si,si
  3890                                  ;	mov	di,si			;Start transfer from 0
  3891                                  ;
  3892                                  ;	cld
  3893                                  ;	rep	movsb			;Do the copy
  3894                                  ;
  3895                                  ;	xor	ax,ax			
  3896                                  ;	stosb				;Make it end with double-null
  3897                                  ;
  3898                                  ;	pop	ds			;ds = RESGROUP
  3899                                  ;	assume	ds:RESGROUP
  3900                                  ;;
  3901                                  ;;We have to free the old environment block if it was allocated by INIT
  3902                                  ;;
  3903                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3904                                  ;	je      no_free                 ;no, do not free it
  3905                                  ;
  3906                                  ;	mov	ax,OldEnv		;Get old environment
  3907                                  ;	mov	es,ax
  3908                                  ;	mov	ah,DEALLOC	
  3909                                  ;	int	21h			;Free it
  3910                                  ;no_free:
  3911                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3912                                  ;	
  3913                                  ;	pop	es
  3914                                  ;	pop	ds
  3915                                  ;	assume	ds:nothing
  3916                                  ;	
  3917                                  ;	jmp	LodCom			;allocate transient
  3918                                  ;
  3919                                  ;nomem_err:
  3920                                  ;;
  3921                                  ;;We call the error routine which will never return. It will either exit
  3922                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3923                                  ;;message ( if first COMMAND )
  3924                                  ;;
  3925                                  ;
  3926                                  ;	call	Alloc_error
  3927                                  ;ENDIF
  3928                                  ;
  3929                                  ;CODERES ends
  3930                                  
  3931                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3932                                  ;	the resident group which is the location where the transient
  3933                                  ;	segments will be loaded initial.
  3934                                  
  3935                                  ;TAIL		segment public para
  3936                                  ;
  3937                                  ;		org	0
  3938                                  ;TranStart	label	word
  3939                                  ;		public	TranStart
  3940                                  ;
  3941                                  ;TAIL		ends
  3942                                  ;
  3943                                  
  3944                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3945                                  ;	the transient group which is the location where the exec
  3946                                  ;	segments will be loaded initial.
  3947                                  ;
  3948                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3949                                  
  3950                                  ;TRANTAIL	segment public para
  3951                                  ;
  3952                                  ;		org	0
  3953                                  ;ExecStart   	label   word
  3954                                  ;
  3955                                  ;TRANTAIL    	ends
  3956                                  
  3957                                  %endif ; 12/01/2023
  3958                                  
  3959                                  ;=============================================================================
  3960                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3961                                  ;=============================================================================
  3962                                  ; 22/09/2018 - Retro DOS v3.0
  3963                                  
  3964                                  ;	title	Localizable code for resident COMMAND
  3965                                  
  3966                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3967                                  
  3968                                  ; ----------------------------------------------------------------------------
  3969                                  ;***	AskEnd - ask user to confirm batch file termination
  3970                                  ;
  3971                                  ;	Confirm with user before freeing batch ...
  3972                                  ;
  3973                                  ;	ENTRY	nothing
  3974                                  ;
  3975                                  ;	EXIT	CY = set if batch termination is confirmed
  3976                                  ;
  3977                                  ;		CY = clear if batch should continue
  3978                                  ;
  3979                                  ;	USED	AX,DX,...
  3980                                  ;
  3981                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3982                                  ;	Bugbug:	or move it to command1 1st.
  3983                                  ;
  3984                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3985                                  ; ----------------------------------------------------------------------------
  3986                                  
  3987                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3988                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3989                                  
  3990                                  AskEnd:
  3991                                  	;assume	ds:DATARES
  3992                                  
  3993 00001018 BA[1F05]                	mov	dx,ENDBATMES			; DX = message #
  3994 0000101B E85702                  	call	RPrint
  3995                                  	;call	RDISPMSG  ; MSDOS 3.3
  3996 0000101E B8010C                  	mov	ax,0C01h
  3997                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3998 00001021 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3999                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  4000 00001023 E8E802                  	call	CharToUpper			; change to upper case
  4001 00001026 3A06[2604]              	cmp	al,[NO_CHAR]
  4002 0000102A 7407                    	je	short aeRet			; answer is no (CY is clear)
  4003 0000102C 3A06[2504]              	cmp	al,[YES_CHAR]
  4004 00001030 75E6                    	jne	short AskEnd			; invalid response, try again
  4005 00001032 F9                      	stc					; answer is yes
  4006                                  aeRet:	
  4007 00001033 C3                      	retn
  4008                                  
  4009                                  ; ----------------------------------------------------------------------------
  4010                                  ;***	DskErr - critical error handler
  4011                                  ;
  4012                                  ;	Default critical error handler unless user intercepts int 24h.
  4013                                  ;
  4014                                  ;	ENTRY	int 24h
  4015                                  ;
  4016                                  ;	EXIT
  4017                                  ;
  4018                                  ;	USED
  4019                                  ;
  4020                                  ;	EFFECTS
  4021                                  ; ----------------------------------------------------------------------------
  4022                                  
  4023                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4024                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4025                                  
  4026                                  ;SR; 
  4027                                  ;The stub is going to push the old ds value and the resident data segment
  4028                                  ;onto the stack in that order. Get it off the stack
  4029                                  
  4030                                  ;DskErr	proc	far
  4031                                  DSKERR:
  4032                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4033                                  	; 12/01/2023
  4034 00001034 1F                      	pop	ds			; ds = DATARES
  4035                                  	;assume ds:DATARES
  4036 00001035 8F06[1E04]              	pop	word [OldDS]		; save old ds value
  4037                                  
  4038                                  ;CRITERR: ; MSDOS 3.3
  4039 00001039 FB                      	sti
  4040                                  	; 12/01/2023
  4041                                  	;push	ds ; 25/09/2018
  4042 0000103A 06                      	push	es
  4043 0000103B 56                      	push	si
  4044 0000103C 51                      	push	cx
  4045 0000103D 57                      	push	di
  4046 0000103E 51                      	push	cx
  4047 0000103F 50                      	push	ax
  4048                                  
  4049 00001040 1E                      	push	ds			;save our data segment
  4050                                  	;push	cs ; 25/09/2018
  4051 00001041 07                      	pop	es			;es = DATARES
  4052                                  
  4053 00001042 8EDD                    	mov	ds,bp
  4054                                  	;assume	ds:nothing
  4055                                  
  4056                                  	;mov	ax,[si].SDEVATT
  4057 00001044 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4058 00001047 268826[1001]            	mov	[es:CDevAt],ah
  4059                                  
  4060                                  	;push	cs
  4061                                  	;pop	es
  4062                                  
  4063 0000104C BF[0301]                	mov	di,DevName
  4064 0000104F B90800                  	mov	cx,8
  4065                                  	;add	si,SDEVNAME  ; add si,10
  4066 00001052 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4067                                  				
  4068 00001055 FC                      	cld
  4069 00001056 F3A4                    	rep	movsb
  4070 00001058 58                      	pop	ax
  4071 00001059 59                      	pop	cx
  4072 0000105A 5F                      	pop	di
  4073                                  
  4074                                  ;	Stack still contains DS and ES.
  4075                                  
  4076                                  ;SR;
  4077                                  ;We need ds = DATARES for SavHand
  4078                                  
  4079                                  	 ;12/01/2023
  4080 0000105B 06                      	push	es
  4081 0000105C 1F                      	pop	ds
  4082                                  	;assume	ds:DATARES
  4083                                  
  4084                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4085 0000105D E8A7FE                  	call	SavHand
  4086                                  
  4087                                  	; 12/01/2023
  4088                                  	; 25/09/2018
  4089                                  	;;push	cs
  4090                                  	;push	es
  4091                                  	;pop	ds		; set up local data segment
  4092                                  	;assume	ds:resgroup
  4093                                  
  4094 00001060 52                      	push	dx
  4095 00001061 E80E02                  	call	crlf
  4096 00001064 5A                      	pop	dx
  4097                                  
  4098                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4099                                  
  4100 00001065 8826[8701]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4101                                  
  4102                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4103                                  
  4104 00001069 0441                    	add	al,'A'
  4105 0000106B A2[F000]                	mov	[DrvLet],al
  4106                                  
  4107                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4108                                  
  4109 0000106E F6C480                  	test	ah,80h
  4110 00001071 740A                    	jz	short NoHardE		; it's a disk-device error
  4111 00001073 F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4112 00001078 7503                    	jnz	short NoHardE		; it's a character device
  4113 0000107A E9E801                  	jmp	FatErr			; it's a FAT error
  4114                                  
  4115                                  NoHardE:
  4116 0000107D BE[4704]                	mov	si,MREAD		; SI = "read" msg #
  4117 00001080 F6C401                  	test	ah,1
  4118 00001083 7403                    	jz	short SavMes		; it's a read error
  4119 00001085 BE[5004]                	mov	si,MWRITE		; SI = "write" msg #
  4120                                  SavMes:
  4121 00001088 893E[4703]              	mov	[OldErrNo],di		; save critical error code
  4122                                  
  4123                                  ;	Bugbug:	don't need to save/restore all here?
  4124                                  
  4125 0000108C 06                      	push	es
  4126                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4127                                  	;push	ds			; GetExtendedError likes to STOMP
  4128                                  	; 12/01/2023
  4129                                  	; (all registers are changed -in dos service- except bp) *
  4130                                  	;push	bp
  4131                                  	; 19/07/2024
  4132                                  	;push	si
  4133                                  	;push	dx
  4134 0000108D 51                      	push	cx
  4135 0000108E 53                      	push	bx
  4136                                  	; 05/06/2023
  4137 0000108F B459                    	mov	ah,59h ; *
  4138                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4139 00001091 CD21                    	int	21h
  4140 00001093 5B                      	pop	bx
  4141 00001094 59                      	pop	cx
  4142                                  	; 19/07/2024
  4143                                  	;pop	dx
  4144                                  	;pop	si
  4145                                  	; 12/01/2023
  4146                                  	;pop	bp
  4147                                  	; 19/07/2024
  4148                                  	;pop	ds
  4149 00001095 893E[1E01]              	mov	[NeedVol],di		; save possible ptr to volume label
  4150 00001099 8C06[2001]              	mov	[NeedVol+2],es
  4151 0000109D 07                      	pop	es
  4152                                  
  4153                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4154                                  
  4155                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4156                                  	;xor	ah,ah
  4157 0000109E 89C7                    	mov	di,ax			; DI = error code
  4158                                  
  4159                                  ; Bugbug: somewhat obsolete documentation?
  4160                                  ;
  4161                                  ; DI is now the correct error code. Classify things to see what we are
  4162                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4163                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4164                                  ; the like) are contiguous.
  4165                                  
  4166                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4167                                  ;	Check use of ErrCd_24, though.
  4168                                  
  4169 000010A0 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4170 000010A3 7303                    	jae	short HavCod
  4171                                  
  4172                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4173                                  ;	even though it's not a critical error?
  4174                                  
  4175 000010A5 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4176                                  
  4177                                  ; DI now has the mapped error code. Old style errors are:
  4178                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4179                                  ; New style errors are:
  4180                                  ;   FOOBAR
  4181                                  ; We need to figure out which the particular error belongs to.
  4182                                  
  4183                                  HavCod:
  4184 000010A8 C606[2201]00            	mov	byte [ErrType],0	; assume old style
  4185 000010AD 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4186 000010B0 7405                    	je	short SetStyle
  4187 000010B2 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4188 000010B5 7504                    	jne	short GotStyle
  4189                                  
  4190                                  SetStyle:
  4191                                  ;	Bugbug:	use INC
  4192                                  	;mov	byte [ErrType],1		; must be new type
  4193 000010B7 FE06[2201]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4194                                  
  4195                                  GotStyle:
  4196 000010BB 893E[2F01]              	mov	[ErrCd_24],di
  4197                                  	; 12/01/2023
  4198                                  	; 25/09/2018
  4199                                  	; MSDOS 6.0
  4200 000010BF 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4201                                  	; MSDOS 3.3
  4202                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4203                                  
  4204                                  						; If the error message is unknown
  4205 000010C2 7641                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4206                                  
  4207                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4208                                  ; how to handle things
  4209                                  
  4210                                  ;input to IFSFUNC:    AL=1
  4211                                  ;		      BX=extended error number
  4212                                  ;
  4213                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4214                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4215                                  ;			   Abort, Retry, Ignore
  4216                                  ;			 1=<message>
  4217                                  ;			   Abort, Retry, Ignore
  4218                                  ;		      ES:DI=pointer to message text
  4219                                  ;		      carry set=>no message
  4220                                  
  4221 000010C4 89C7                    	mov	di,ax			; retrieve correct extended error...
  4222 000010C6 B80005                  	mov	ax,0500h		; is the redir there?
  4223 000010C9 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4224                                  			; Return: AL = 00h not installed, OK to install
  4225                                  			; 01h not installed, can't install
  4226                                  			; FFh installed
  4227 000010CB 3CFF                    	cmp	al,0FFh
  4228 000010CD 7529                    	jne	short NoHandler		; no, go to NoHandler
  4229                                  
  4230                                  	; 12/01/2023
  4231                                  	; MSDOS 6.0
  4232 000010CF 53                      	push	bx
  4233 000010D0 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4234 000010D2 B80105                  	mov	ax,0501h
  4235 000010D5 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4236 000010D7 5B                      	pop	bx 
  4237 000010D8 721E                    	jc	short NoHandler
  4238                                  	
  4239                                  	; MSDOS 3.3
  4240                                  	;mov     ax,di
  4241                                  	;mov     ah,5
  4242                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4243                                  	;jc      short NOHANDLER
  4244                                  
  4245                                  ;	Bugbug:	need to record error type?
  4246                                  
  4247 000010DA A2[2201]                	mov	[ErrType],al
  4248                                  
  4249 000010DD 1E                      	push	ds
  4250 000010DE 06                      	push	es
  4251 000010DF 1F                      	pop	ds
  4252 000010E0 89FA                    	mov	dx,di
  4253 000010E2 B9FFFF                  	mov	cx,-1			; find end of msg
  4254 000010E5 30C0                    	xor	al,al
  4255                                  
  4256 000010E7 FC                      	cld
  4257 000010E8 F2AE                    	repnz	scasb
  4258                                  
  4259                                  ;	Bugbug:	we can do better than this.
  4260                                  
  4261                                  	;mov	byte [di-1],'$'
  4262                                  	; 19/07/2024
  4263 000010EA 4F                      	dec	di
  4264 000010EB C60524                  	mov	byte [di],'$'
  4265                                  	
  4266                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4267                                  	
  4268 000010EE B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4269 000010F0 CD21                    	int	21h
  4270                                  
  4271                                  	;mov	byte [di-1],0			; restore terminal byte
  4272                                  	; 19/07/2024
  4273 000010F2 C60500                  	mov	byte [di],0
  4274                                  
  4275 000010F5 1F                      	pop	ds				; clean up and continue
  4276 000010F6 EB15                    	jmp	short CheckErrType
  4277                                  
  4278                                  ;*	Redir isn't available or doesn't recognize the error.
  4279                                  ;	Restore regs to unextended error.
  4280                                  
  4281                                  NoHandler:
  4282 000010F8 C606[2201]00            	mov	byte [ErrType],0
  4283                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4284 000010FD 8B3E[4703]              	mov	di,[OldErrNo]
  4285 00001101 893E[2F01]              	mov	[ErrCd_24],di
  4286                                  
  4287                                  NormalError:
  4288                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4289                                  	; MSDOS 6.0
  4290 00001105 83C713                  	add	di,ERROR_WRITE_PROTECT
  4291 00001108 87FA                    	xchg	di,dx			; may need dx later
  4292 0000110A E88101                  	call	RPrintCrit		; print error type
  4293                                  
  4294                                  	; MSDOS 3.3
  4295                                  	;shl     di,1
  4296                                  	;mov     di,[CRMSGTBL+di]
  4297                                  	;xchg    di,dx
  4298                                  	;call    RDISPMSG
  4299                                  
  4300                                  CheckErrType:
  4301 0000110D 803E[2201]00            	cmp	byte [ErrType],0	; Check error style...
  4302 00001112 7405                    	je	short ContOld
  4303 00001114 E85B01                  	call	crlf			; if new style then done printing
  4304 00001117 EB31                    	jmp	short Ask
  4305                                  
  4306                                  ContOld:
  4307                                  	; 12/01/2023
  4308                                  	; MSDOS 6.0
  4309 00001119 46                      	inc	si			; DS:SI = ptr to asciiz string
  4310                                  
  4311                                  ;	Bugbug:	combine some of the following two sections?
  4312                                  
  4313                                  	; 12/01/2023
  4314 0000111A F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4315                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4316 0000111F 740F                    	jz	short BlkErr
  4317                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4318                                  	;mov	dx,ChardevErr
  4319 00001121 BA[6804]                	mov	dx,MDEVICE
  4320                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4321 00001124 8936[F200]              	mov	[CharDevErrRw],si
  4322                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4323 00001128 BE[F100]                	mov	si,CharDevErrSubst
  4324                                  
  4325 0000112B E84701                  	call	RPrint				; print the message
  4326 0000112E EB1A                    	jmp	short Ask			; don't ralph on command
  4327                                  
  4328                                  	; 12/01/2023
  4329                                  	; MSDOS 3.3
  4330                                  	;mov	dx,ERRMES
  4331                                  	;call	RDISPMSG
  4332                                  	;mov	dx,si
  4333                                  	;call	RDISPMSG
  4334                                  	;
  4335                                  	;test	byte [CDevAt],80h
  4336                                  	;jz	short BLKERR
  4337                                  	;mov	dx,CHARDEVERR	; " device "
  4338                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4339                                  	;int	21h		; DOS - PRINT STRING
  4340                                  	;			; DS:DX -> string terminated by "$"
  4341                                  	;jmp	short ASK
  4342                                  
  4343                                  BlkErr:
  4344                                  	; 12/01/2023
  4345                                  	; MSDOS 6.0
  4346                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4347                                  	;mov	dx,BlkDevErr
  4348 00001130 BA[5904]                	mov	dx,MDRIVE
  4349                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4350 00001133 8936[EB00]              	mov	[BlkDevErrRw],si
  4351                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4352 00001137 BE[EA00]                	mov	si,BlkDevErrSubst
  4353 0000113A E83801                  	call	RPrint
  4354                                  
  4355                                  	; MSDOS 3.3
  4356                                  	;mov	dx,BLKDEVERR
  4357                                  	;call	RDISPMSG
  4358                                  
  4359 0000113D 803E[3301]00            	cmp	byte [Loading],0
  4360 00001142 7406                    	jz	short Ask
  4361 00001144 E8E9FD                  	call	RestHand
  4362 00001147 E9E0FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4363                                  Ask:
  4364 0000114A 833E[2F01]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4365 0000114F 751E                    	jne	short Not15		; not error 15
  4366                                  
  4367                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4368                                  
  4369 00001151 51                      	push	cx
  4370                                  
  4371                                  ;	Bugbug:	does this push/pop need to be done?
  4372                                  
  4373 00001152 1E                      	push	ds
  4374 00001153 07                      	pop	es
  4375 00001154 C536[1E01]              	lds	si,[NeedVol]
  4376                                  	;assume	ds:NOTHING
  4377 00001158 57                      	push	di
  4378 00001159 BF[0001]                	mov	di,VolName
  4379                                  	; 12/01/2023
  4380                                  	; MSDOS 6.0
  4381 0000115C B91000                  	mov	cx,16			; copy volume name & serial #
  4382                                  	; MSDOS 3.3
  4383                                  	;mov	cx,11			; copy volume name
  4384 0000115F FC                      	cld
  4385 00001160 F3A4                    	rep	movsb
  4386 00001162 5F                      	pop	di
  4387 00001163 06                      	push	es
  4388 00001164 1F                      	pop	ds
  4389 00001165 59                      	pop	cx
  4390                                  	;assume	ds:DATARES
  4391                                  	; 12/01/2023
  4392                                  	; MSDOS 6.0
  4393                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4394                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4395                                  	;mov	dx,NeedVolMsg
  4396 00001166 BA[7804]                	mov	dx,MVOLSERIAL
  4397 00001169 BE[F700]                	mov	si,NeedVolSubst
  4398 0000116C E80601                  	call	RPrint
  4399                                  
  4400                                  	; MSDOS 3.3
  4401                                  	;mov	dx,NEEDVOLMSG
  4402                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4403                                  	;int	21h		; DOS - PRINT STRING
  4404                                  	;			; DS:DX -> string terminated by "$"
  4405                                  Not15:
  4406                                  ;*	Print abort, retry, ignore, fail message.
  4407                                  ;	Print only options that are valid.
  4408                                  
  4409                                  ;	Bugbug:	sizzle this.
  4410                                  
  4411                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4412 0000116F BA[2704]                	mov	dx,REQ_ABORT
  4413 00001172 E80001                  	call	RPrint
  4414                                  	;call	RDISPMSG
  4415 00001175 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4416 0000117A 7406                    	jz	short Try_Ignore
  4417 0000117C BA[2D04]                	mov	dx,REQ_RETRY
  4418 0000117F E8F300                  	call	RPrint
  4419                                  	;call	RDISPMSG
  4420                                  Try_Ignore:
  4421 00001182 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4422 00001187 7406                    	jz	short Try_Fail
  4423 00001189 BA[3504]                	mov	dx,REQ_IGNORE
  4424 0000118C E8E600                  	call	RPrint
  4425                                  	;call	RDISPMSG
  4426                                  Try_Fail:
  4427 0000118F F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4428 00001194 7406                    	jz	short Term_Question
  4429 00001196 BA[3E04]                	mov	dx,REQ_FAIL
  4430 00001199 E8D900                  	call	RPrint
  4431                                  	;call	RDISPMSG
  4432                                  Term_Question:
  4433 0000119C BA[4504]                	mov	dx,REQ_END
  4434 0000119F E8D300                  	call	RPrint
  4435                                  	;call	RDISPMSG
  4436                                  
  4437                                  ;	If the /f switch was given, we fail all requests.
  4438                                  
  4439 000011A2 F606[9201]FF            	test	byte [fFail],-1
  4440 000011A7 741B                    	jz	short DoPrompt
  4441 000011A9 B403                    	mov	ah,3				; signal fail
  4442 000011AB E9A800                  	jmp	EExit
  4443                                  
  4444                                  	; 16/04/2023
  4445                                  Abort_Process:
  4446 000011AE F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4447 000011B3 745D                    	jz	short AbortCont			; no, handle it normally
  4448 000011B5 803E[8D01]00            	cmp	byte [PermCom],0		; are we top level process?
  4449 000011BA 744B                    	jz	short JustExit			; yes, just exit
  4450                                  
  4451 000011BC BA[2A06]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4452                                  	; 12/01/2023
  4453 000011BF E8B300                  	call	RPrint				; print it
  4454                                  	;call	RDISPMSG
  4455                                  DeadInTheWater:
  4456 000011C2 EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4457                                  
  4458                                  DoPrompt:
  4459                                  	; 12/01/2023
  4460 000011C4 B8010C                  	mov	ax,0C01h
  4461                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4462 000011C7 CD21                    	int	21h				; get response
  4463                                  
  4464 000011C9 E8A600                  	call	crlf
  4465 000011CC E83F01                  	call	CharToUpper			; convert to upper case
  4466 000011CF B400                    	mov	ah,0				; return code for ignore
  4467 000011D1 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4468 000011D6 7406                    	jz	short User_Retry
  4469 000011D8 3A06[2304]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4470                                  	;jz	short EExitJ
  4471                                  	; 16/04/2023
  4472 000011DC 7478                    	jz	short EExit
  4473                                  
  4474                                  ;	Bugbug:	optimize following code.
  4475                                  
  4476                                  User_Retry:
  4477 000011DE FEC4                    	inc	ah				; return code for retry
  4478 000011E0 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4479 000011E5 7406                    	jz	short User_Abort
  4480 000011E7 3A06[2204]              	cmp	al,[RETRY_CHAR]			; retry?
  4481                                  	;jz	short EExitJ
  4482                                  	; 16/04/2023
  4483 000011EB 7469                    	jz	short EExit
  4484                                  User_Abort:
  4485 000011ED FEC4                    	inc	ah				; return code for abort
  4486                                  						;  (abort always allowed)
  4487 000011EF 3A06[2104]              	cmp	al,[ABORT_CHAR]			; abort?
  4488 000011F3 74B9                    	jz	short Abort_Process		; exit user program
  4489 000011F5 FEC4                    	inc	ah				; return code for fail
  4490 000011F7 F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4491 000011FC 7406                    	jz	short AskJ
  4492 000011FE 3A06[2404]              	cmp	al,[FAIL_CHAR]			; fail?
  4493                                  	;jz	short EExitJ
  4494                                  	; 16/04/2023
  4495 00001202 7452                    	jz	short EExit
  4496                                  AskJ:
  4497 00001204 E943FF                  	jmp	Ask
  4498                                  
  4499                                  	; 12/01/2023
  4500                                  ;EExitJ:
  4501                                  	;jmp	short EExit
  4502                                  
  4503                                  JustExit:
  4504                                  	;assume	ds:DATARES
  4505                                  	; 12/01/2023
  4506 00001207 A1[2901]                	mov	ax,[Parent]			; load real parent pid
  4507                                  	;mov	[16h],ax
  4508 0000120A A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4509 0000120D B8FF4C                  	mov	ax,4CFFh
  4510                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4511 00001210 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4512                                  				; AL = exit code
  4513                                  AbortCont:
  4514 00001212 F606[7D01]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4515 00001217 7405                    	jz	short Not_Batch_Abort
  4516 00001219 C606[7E01]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4517                                  
  4518                                  Not_Batch_Abort:
  4519 0000121E 8A16[0002]              	mov	dl,[PipeFlag]
  4520 00001222 E8D1FA                  	call	ResPipeOff
  4521 00001225 08D2                    	or	dl,dl
  4522 00001227 740D                    	je	short CheckForA
  4523 00001229 833E[8E01]00            	cmp	word [SingleCom],0
  4524 0000122E 7406                    	je	short CheckForA
  4525 00001230 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4526                                  
  4527                                  CheckForA:
  4528 00001236 833E[2F01]00            	cmp	word [ErrCd_24],0		; write protect?
  4529 0000123B 7407                    	je	short abortfor
  4530 0000123D 833E[2F01]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4531 00001242 7512                    	jne	short EExit			; don't abort the FOR
  4532                                  
  4533                                  abortfor:
  4534 00001244 C606[9401]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4535 00001249 833E[8E01]00            	cmp	word [SingleCom],0
  4536 0000124E 7406                    	je	short EExit
  4537 00001250 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4538                                  
  4539                                  EExit:
  4540 00001256 88E0                    	mov	al,ah
  4541 00001258 89FA                    	mov	dx,di
  4542                                  RestHd:
  4543 0000125A E8D3FC                  	call    RestHand
  4544 0000125D 59                      	pop	cx
  4545 0000125E 5E                      	pop	si				; restore registers
  4546 0000125F 07                      	pop	es
  4547                                  
  4548                                  	; 12/01/2023	
  4549                                  	; MSDOS 6.0
  4550                                  ;;	pop	ds
  4551                                  ;SR;
  4552                                  ;ds has to be got from the variable we saved it in
  4553                                  
  4554 00001260 8E1E[1E04]               	mov	ds,[OldDS]			; restore old value of ds
  4555                                  
  4556                                  ;	pop	ds
  4557                                  ;	assume	ds:nothing
  4558                                  
  4559                                  	; MSDOS 3.3
  4560                                  	;pop	ds
  4561                                  
  4562 00001264 CF                      	iret
  4563                                  
  4564                                  FatErr:
  4565                                  	; 12/01/2023
  4566                                  	; MSDOS 6.0
  4567                                  	;mov	dx,offset DATARES:BadFatMsg
  4568                                  	;mov	si,offset DATARES:BadFatSubst
  4569 00001265 BA[9F04]                	mov	dx,BADFATMSG
  4570 00001268 BE[1101]                	mov	si,BadFatSubst
  4571 0000126B E80700                  	call	RPrint
  4572                                  
  4573                                  	; MSDOS 3.3
  4574                                  	;mov	dx,BADFATMSG
  4575                                  	;call	RDISPMSG
  4576                                  	;mov	dx,BLKDEVERR
  4577                                  	;call	RDISPMSG
  4578                                  
  4579 0000126E B002                    	mov	al,2				; abort
  4580 00001270 EBE8                    	jmp	short RestHd
  4581                                  
  4582                                  ;DskErr	endp
  4583                                  
  4584                                  	; MSDOS 6.0
  4585                                  ; ----------------------------------------------------------------------------
  4586                                  ;***	RPrint - print message
  4587                                  ;***	Crlf - display cr/lf
  4588                                  ;
  4589                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4590                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4591                                  ;		variable fields related to substitution blocks are set
  4592                                  ;
  4593                                  ;	EXIT	nothing
  4594                                  ;
  4595                                  ;	USED	flags
  4596                                  ;
  4597                                  ;	EFFECTS
  4598                                  ;	  Message is displayed on stdout.
  4599                                  ;
  4600                                  ;	NOTE
  4601                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4602                                  ;	  be greater than number of substition blocks present.
  4603                                  ; ----------------------------------------------------------------------------
  4604                                  
  4605                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4606                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4607                                  
  4608                                  crlf: 
  4609                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4610                                  	; 14/01/2023
  4611 00001272 BA[5906]                	mov	dx,NEWLINE
  4612                                  
  4613                                  ;RPrint	proc
  4614                                  ;
  4615                                  ;	assume	ds:DATARES,ss:DATARES
  4616                                  ;
  4617                                  	; 14/01/2023
  4618                                  RPrint:
  4619                                  
  4620                                  ;	Bugbug:	do we need to save all reg's?
  4621                                  
  4622 00001275 56                      	push	si			; preserve registers
  4623 00001276 50                      	push	ax
  4624 00001277 53                      	push	bx
  4625 00001278 51                      	push	cx
  4626 00001279 52                      	push	dx
  4627                                  
  4628 0000127A 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4629 0000127C 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4630 0000127E AC                      	lodsb				; AL = message length
  4631                                  					; DS:SI = ptr to message text
  4632 0000127F 31C9                    	xor	cx,cx
  4633 00001281 88C1                    	mov	cl,al			; CX = message length
  4634 00001283 E303                    	jcxz	rpRet
  4635                                  
  4636 00001285 E81900                  	call	RDispMsg
  4637                                  
  4638 00001288 5A                      rpRet:	pop	dx
  4639 00001289 59                      	pop	cx
  4640 0000128A 5B                      	pop	bx
  4641 0000128B 58                      	pop	ax
  4642 0000128C 5E                      	pop	si
  4643 0000128D C3                      	retn
  4644                                  
  4645                                  ;RPrint	endp
  4646                                  
  4647                                  	; 14/01/2023
  4648                                  ;	; MSDOS 3.3
  4649                                  ;CRLF:
  4650                                  ;	mov     dx,NEWLIN
  4651                                  ;
  4652                                  ;RDISPMSG: ; Display message/text
  4653                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4654                                  ;	push    ax
  4655                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4656                                  ;	clc
  4657                                  ;	int     21h             ; DOS - PRINT STRING
  4658                                  ;				; DS:DX -> string terminated by "$"
  4659                                  ;	pop     ax
  4660                                  ;	retn
  4661                                  
  4662                                  
  4663                                  	; MSDOS 6.0
  4664                                  ; ----------------------------------------------------------------------------
  4665                                  ;***	RPrintCrit - print critical error message
  4666                                  ;
  4667                                  ;	ENTRY	DX = extended error # (19-39)
  4668                                  ;
  4669                                  ;	EXIT	nothing
  4670                                  ;
  4671                                  ;	USED	flags
  4672                                  ;
  4673                                  ;	EFFECTS
  4674                                  ;	  Message is displayed on stdout
  4675                                  ; ----------------------------------------------------------------------------
  4676                                  
  4677                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4678                                  
  4679                                  ;RPrintCrit	proc
  4680                                  ;	assume	ds:DATARES,ss:DATARES
  4681                                  
  4682                                  	; 14/01/2023
  4683                                  RPrintCrit:
  4684 0000128E 52                      	push	dx			; preserve DX
  4685 0000128F 87DA                    	xchg	bx,dx			; BX = extended error #
  4686                                  					; DX = saved BX
  4687 00001291 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4688 00001294 D1E3                    	shl	bx,1			; BX = offset in word table
  4689 00001296 8B9F[F307]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4690 0000129A 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4691                                  					; BX = restored
  4692 0000129C E8D6FF                  	call	RPrint			; print the message
  4693 0000129F 5A                      	pop	dx			; restore DX
  4694 000012A0 C3                      	retn
  4695                                  
  4696                                  ;RPrintCrit	endp
  4697                                  
  4698                                  ; ----------------------------------------------------------------------------
  4699                                  ;***	RDispMsg - display message
  4700                                  ;
  4701                                  ;	Display message, with substitutions, for RPrint.
  4702                                  ;
  4703                                  ;	ENTRY	DS:SI = ptr to message text
  4704                                  ;		CX = message length
  4705                                  ;		DS:BX = ptr to substitution block, if any
  4706                                  ;
  4707                                  ;	EXIT	nothing
  4708                                  ;
  4709                                  ;	USED	AX,CX,DX,SI
  4710                                  ; ----------------------------------------------------------------------------
  4711                                  
  4712                                  ;RDispMsg	proc
  4713                                  ;	assume	ds:DATARES,ss:DATARES
  4714                                  
  4715                                  RDispMsg:
  4716                                  	; 14/01/2023
  4717                                  rdNextChar:
  4718 000012A1 AC                      	lodsb				; AL = next char
  4719 000012A2 3C25                    	cmp	al,'%'
  4720 000012A4 7511                    	jne	short rdOutChar		; not a substitution
  4721 000012A6 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4722 000012A8 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4723 000012AB 80FA09                  	cmp	dl,9
  4724 000012AE 7307                    	jae	short rdOutChar		; not a substitution
  4725                                  
  4726                                  ;*	A substitution code %1 - %9 has been encountered.
  4727                                  ;	DL = 0-8, indicating %1-%9
  4728                                  ;	DS:BX = ptr to substitution block
  4729                                  
  4730 000012B0 E80D00                  	call	SubstMsg		; display the substitution
  4731 000012B3 46                      	inc	si			; SI = ptr past %n
  4732 000012B4 49                      	dec	cx			; count extra character in %n
  4733 000012B5 EB06                    	jmp	short rdCharDone
  4734                                  
  4735                                  ;*	Normal character output.
  4736                                  
  4737                                  rdOutChar:
  4738 000012B7 88C2                    	mov	dl,al			; DL = char
  4739 000012B9 B402                    	mov	ah,2			; AH = DOS Character Output code
  4740 000012BB CD21                    	int	21h			; call DOS
  4741                                  rdCharDone:
  4742 000012BD E2E2                    	loop	rdNextChar
  4743 000012BF C3                      	retn
  4744                                  
  4745                                  ;RDispMsg	endp
  4746                                  
  4747                                  ; ----------------------------------------------------------------------------
  4748                                  ;***	SubstMsg - display message substitution
  4749                                  ;
  4750                                  ;	Display a substitution string within a message.
  4751                                  ;	Substitution can be a char, an ASCIIZ string, or
  4752                                  ;	a word to be displayed as hex digits.
  4753                                  ;
  4754                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4755                                  ;		DS:BX = ptr to substitution block
  4756                                  ;
  4757                                  ;	EXIT	nothing
  4758                                  ;
  4759                                  ;	USED	AX,DX
  4760                                  ; ----------------------------------------------------------------------------
  4761                                  
  4762                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4763                                  
  4764                                  ;SubstMsg	proc
  4765                                  ;	assume	ds:DATARES,ss:DATARES
  4766                                  	
  4767                                  	; 14/01/2023
  4768                                  SubstMsg:
  4769 000012C0 53                      	push	bx			; preserve BX
  4770 000012C1 51                      	push	cx			; preserve CX
  4771                                  
  4772                                  	;mov	al,size SUBST		; AL = size of substitution block
  4773 000012C2 B003                    	mov	al,3
  4774 000012C4 F6E2                    	mul	dl			; AX = offset of desired subst block
  4775 000012C6 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4776                                  
  4777                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4778 000012C8 8A07                    	mov	al,[bx]
  4779                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4780 000012CA 8B5F01                  	mov	bx,[bx+1]
  4781                                  
  4782                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4783                                  
  4784 000012CD FEC8                    	dec	al
  4785 000012CF 7428                    	jz	short smChar
  4786 000012D1 FEC8                    	dec	al
  4787 000012D3 742C                    	jz	short smStr
  4788                                  
  4789                                  ;*	Hex number substitution.
  4790                                  
  4791                                  	;mov	ax,ds:[bx]		; AX = word value
  4792 000012D5 8B07                    	mov	ax,[bx]
  4793 000012D7 B90400                  	mov	cx,4			; CX = # digits to display
  4794                                  smDigit:
  4795 000012DA D1C0                    	rol	ax,1
  4796 000012DC D1C0                    	rol	ax,1
  4797 000012DE D1C0                    	rol	ax,1
  4798 000012E0 D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4799                                  
  4800 000012E2 50                      	push	ax			; save other digits
  4801 000012E3 240F                    	and	al,0Fh			; AL = binary digit
  4802 000012E5 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4803 000012E7 3C39                    	cmp	al,'9'
  4804 000012E9 7602                    	jbe	short smDigit09		; it's 0-9
  4805                                  	;add	al,7
  4806 000012EB 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4807                                  smDigit09:
  4808 000012ED 88C2                    	mov	dl,al			; DL = ascii digit
  4809 000012EF B402                    	mov	ah,2
  4810 000012F1 CD21                    	int	21h			; output the ascii digit
  4811 000012F3 58                      	pop	ax			; restore all digits
  4812                                  
  4813 000012F4 E2E4                    	loop	smDigit
  4814                                  	;jmp	short smRet
  4815                                  	; 14/01/2023
  4816                                  smRet:	
  4817 000012F6 59                      	pop	cx
  4818 000012F7 5B                      	pop	bx
  4819 000012F8 C3                      	retn
  4820                                  
  4821                                  ;*	Char substitution.
  4822                                  
  4823                                  smChar:
  4824                                  	;mov	dl,ds:[bx]		; DL = char to output
  4825 000012F9 8A17                    	mov	dl,[bx]
  4826 000012FB B402                    	mov	ah,2
  4827 000012FD CD21                    	int	21h
  4828 000012FF EBF5                    	jmp	short smRet
  4829                                  
  4830                                  ;*	String substitution.
  4831                                  
  4832                                  smStr:
  4833                                  	;mov	dl,ds:[bx]		; DL = next char
  4834 00001301 8A17                    	mov	dl,[bx]
  4835 00001303 08D2                    	or	dl,dl
  4836 00001305 74EF                    	jz	short smRet		; null char - we're done
  4837 00001307 B402                    	mov	ah,2
  4838 00001309 CD21                    	int	21h			; display char
  4839 0000130B 43                      	inc	bx			; DS:BX = ptr to next char
  4840 0000130C EBF3                    	jmp	short smStr
  4841                                  
  4842                                  ;smRet:	pop	cx
  4843                                  ;	pop	bx
  4844                                  ;	retn
  4845                                  
  4846                                  ;SubstMsg	endp
  4847                                  
  4848                                  	; MSDOS 6.0
  4849                                  ; ----------------------------------------------------------------------------
  4850                                  ;***	CharToUpper - convert character to uppercase
  4851                                  ;
  4852                                  ;	ENTRY	AL = char
  4853                                  ;
  4854                                  ;	EXIT	AL = uppercase char
  4855                                  ;
  4856                                  ;	USED	AX
  4857                                  ; ----------------------------------------------------------------------------
  4858                                  
  4859                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4860                                  
  4861                                  ;CharToUpper	proc
  4862                                  ;	assume	ds:DATARES
  4863                                  CharToUpper:
  4864 0000130E 50                      	push	ax		; put char on stack as arg to int 2F
  4865 0000130F B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4866 00001312 CD2F                    	int	2Fh
  4867 00001314 44                      	inc	sp		; throw away old char on stack
  4868 00001315 44                      	inc	sp
  4869 00001316 C3                      	retn
  4870                                  
  4871                                  ;CharToUpper	endp
  4872                                  
  4873                                  	; 14/01/2023
  4874                                  ;	; MSDOS 3.3
  4875                                  ;CHARTOUPPER:
  4876                                  ;	cmp	al,80h
  4877                                  ;	jb	short CHARTOUPPER1
  4878                                  ;	sub	al,80h
  4879                                  ;	push	ds
  4880                                  ;	push	bx
  4881                                  ;	lds	bx,[UPPERCASETBL]
  4882                                  ;	add	bx,2
  4883                                  ;	xlat
  4884                                  ;	pop	bx
  4885                                  ;	pop	ds
  4886                                  ;	jmp	short CHARTOUPPER_RETN
  4887                                  ;CHARTOUPPER1:
  4888                                  ;	cmp	al,'a'
  4889                                  ;	jb	short CHARTOUPPER_RETN
  4890                                  ;	cmp	al,'z'
  4891                                  ;	ja	short CHARTOUPPER_RETN
  4892                                  ;	sub	al,20h
  4893                                  ;CHARTOUPPER_RETN:
  4894                                  ;	retn
  4895                                  
  4896                                  ;public	EndCode
  4897                                  ;EndCode label byte
  4898                                  
  4899                                  	; MSDOS 6.0
  4900                                  ; ----------------------------------------------------------------------------
  4901                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4902                                  ;
  4903                                  ;	ENTRY	If we handle it -
  4904                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4905                                  ;		  DL = operation =
  4906                                  ;		     0 = get extended error messages
  4907                                  ;		     1 = set extended error messages
  4908                                  ;		     2 = get parse error messages
  4909                                  ;		     3 = set parse error messages
  4910                                  ;		     4 = get critical error messages
  4911                                  ;		     5 = set critical error messages
  4912                                  ;		     6 = get file system error messages
  4913                                  ;		     7 = set file system error messages
  4914                                  ;		     8 = get disk retriever routine
  4915                                  ;		     9 = set disk retriever routine
  4916                                  ;		  ES:DI = address for 'set' operations
  4917                                  ;
  4918                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4919                                  ;
  4920                                  ;	NOTE
  4921                                  ;	  This handler replaces the one that used to reside in DOS.
  4922                                  ;	  'Set' operations are ignored.
  4923                                  ;	  'File system error messages' are not supported.
  4924                                  ; ----------------------------------------------------------------------------
  4925                                  
  4926                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4927                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4928                                  ;SR;
  4929                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4930                                  ;segment address. Get them off the stack
  4931                                  
  4932                                  ;MsgInt2fHandler proc	far
  4933                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4934                                  
  4935                                  	; 14/01/2023
  4936                                  MsgInt2fHandler:
  4937 00001317 1F                      	pop	ds			; ds = DATARES
  4938                                  	;assume	ds:DATARES
  4939                                  ;	pop	word [OldDS]		; save old value of ds
  4940                                  
  4941 00001318 3D2E12                  	cmp	ax,122Eh
  4942                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4943                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4944 0000131B 742A                    	je	short miOurs		; it's ours
  4945                                  
  4946                                  ;ifndef ROMDOS
  4947                                  	;cmp	ax,5500h
  4948 0000131D 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4949                                  ;else
  4950                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4951                                  ;endif	;ROMDOS
  4952 00001320 741C                    	je	short fcOurs
  4953                                  
  4954                                  ;SR;
  4955                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4956                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4957                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4958                                  ;current value of ds as it points at the data segment. So we do some kinky
  4959                                  ;stack manipulations.
  4960                                  
  4961 00001322 50                      	push	ax
  4962 00001323 50                      	push	ax			; create 2 words on stack for retf
  4963                                  
  4964 00001324 55                      	push	bp
  4965 00001325 50                      	push	ax
  4966                                  
  4967 00001326 89E5                    	mov	bp,sp			; bp can be used to address stack
  4968                                  
  4969                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4970                                  ;do a 'pop ds' at the end to restore our ds
  4971                                  
  4972 00001328 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4973 0000132B 894604                  	mov	[bp+4],ax
  4974                                  	
  4975                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4976 0000132E A1[9B03]                	mov	ax,[Int2fHandler+2]
  4977 00001331 894608                  	mov	[bp+8],ax		; put segment address
  4978                                  	;mov	ax,word ptr ds:Int2fHandler
  4979 00001334 A1[9903]                	mov	ax,[Int2fHandler]
  4980 00001337 894606                  	mov	[bp+6],ax		; put offset address
  4981                                  
  4982 0000133A 58                      	pop	ax
  4983 0000133B 5D                      	pop	bp
  4984 0000133C 1F                      	pop	ds
  4985                                  
  4986 0000133D CB                      	retf				; chain on to next handler
  4987                                  
  4988                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4989                                  
  4990                                  fcOurs:
  4991                                  
  4992                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4993                                  
  4994 0000133E 58                      	pop	ax			; discard ds currently on stack
  4995 0000133F 1E                      	push	ds			; store our data segment
  4996                                  
  4997                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4998 00001340 BE[0400]                	mov	si,Int2f_Entry
  4999                                  
  5000 00001343 31C0                    	xor	ax,ax			; indicate COMMAND present
  5001 00001345 EB11                    	jmp	short miRet		; return to caller
  5002                                  
  5003                                  miOurs:
  5004 00001347 F6C201                  	test	dl,1
  5005 0000134A 750C                    	jnz	short miRet		; ignore 'set' operations
  5006                                  
  5007 0000134C 53                      	push	bx			; preserve BX
  5008 0000134D 89D3                    	mov	bx,dx
  5009 0000134F 30FF                    	xor	bh,bh			; BX = index in word table
  5010 00001351 D1E3                    	shl	bx,1			; BX = index in dword table
  5011                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5012 00001353 C4BF[5C06]              	les	di,[bx+MsgPtrLists]
  5013 00001357 5B                      	pop	bx			; restore BX
  5014                                  miRet:
  5015                                  ;	mov	ds,[OldDS]		; restore ds
  5016 00001358 1F                      	pop	ds
  5017                                  	;assume	ds:nothing
  5018                                  
  5019 00001359 CF                      	iret
  5020                                  
  5021                                  ;MsgInt2fHandler endp
  5022                                  
  5023                                  	; MSDOS 6.0
  5024                                  ; ----------------------------------------------------------------------------
  5025                                  ;***	MsgRetriever - message retrieval routine for utilities
  5026                                  ;
  5027                                  ;	Address of this routine is passed to utility programs via 
  5028                                  ;	message services int 2f. We try to find the desired message
  5029                                  ;	in memory or in our disk image.
  5030                                  ;
  5031                                  ;	ENTRY	AX = message #
  5032                                  ;		DI = offset in RESGROUP of msg ptr list
  5033                                  ;		ComSpec = asciiz pathname to our disk image
  5034                                  ;
  5035                                  ;	EXIT	CY clear for success
  5036                                  ;		ES:DI = ptr to count byte, followed by message text
  5037                                  ;
  5038                                  ;		CY set for failure
  5039                                  ;		ES,DI undefined
  5040                                  ;
  5041                                  ;	USED	flags
  5042                                  ;
  5043                                  ;	NOTE
  5044                                  ;	  The message # in AX is used to compute an offset into
  5045                                  ;	  the message ptr list pointed to by DI. The lists must
  5046                                  ;	  start with message # 1 and proceed through consecutive
  5047                                  ;	  message #'s.  
  5048                                  ;
  5049                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5050                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5051                                  ;	  valid message #.  ;M033
  5052                                  ;
  5053                                  ;	  List positions with no corresponding message text are
  5054                                  ;	  indicated by null pointers, which this routine detects.
  5055                                  ; ----------------------------------------------------------------------------
  5056                                  
  5057                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5058                                  
  5059                                  ;SR; This routine will be called directly by the utilities. So, we have
  5060                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5061                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5062                                  
  5063                                  ;MsgRetriever	proc	far
  5064                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5065                                  
  5066                                  	; 14/01/2023
  5067                                  MsgRetriever:
  5068 0000135A 1F                      	pop	ds			; ds = DATARES
  5069                                  	;assume	ds:DATARES
  5070                                  ;	pop	word [OldDS]		; save old ds
  5071                                  
  5072 0000135B 50                      	push	ax			; preserve registers
  5073 0000135C 53                      	push	bx
  5074 0000135D 51                      	push	cx
  5075 0000135E 52                      	push	dx
  5076 0000135F 56                      	push	si
  5077                                  
  5078                                  ;;	push	ds
  5079                                  ;;	push	cs
  5080                                  ;;	pop	ds			; DS = DATARES seg addr
  5081                                  ;;	assume	ds:RESGROUP
  5082                                  ;;	push	cs
  5083                                  
  5084 00001360 1E                      	push	ds			; get es from ds
  5085 00001361 07                      	pop	es			; ES = DATARES seg addr
  5086                                  
  5087                                  ;	Begin modification M033.
  5088                                  
  5089                                  ;	Make sure msg # is valid.
  5090                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5091                                  
  5092                                  	;mov	bx,11
  5093 00001362 BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5094                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5095 00001365 81FF[FB08]              	cmp	di,PARSMSGPTRS
  5096 00001369 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5097                                  	;mov	bx,90
  5098 0000136B BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5099                                  chkmsgnum:
  5100 0000136E 39C3                    	cmp	bx,ax
  5101 00001370 725A                    	jc	short mrRet		; msg # too high, return carry
  5102                                  
  5103                                  ;	Msg # is valid.
  5104                                  
  5105                                  ;	End modification M033.
  5106                                  
  5107 00001372 48                      	dec	ax
  5108 00001373 D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5109 00001375 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5110                                  
  5111 00001377 81FF[9D03]              	cmp	di,ResMsgEnd
  5112 0000137B 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5113                                  
  5114                                  ;*	Retrieve message from disk (or ROM) image.
  5115                                  ;	Read once to get the ptr to the message, then again for the message.
  5116                                  
  5117                                  ;ifndef	ROMDOS
  5118                                  	; 14/01/2023
  5119                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5120 0000137D BE[3601]                	mov	si,ComSpec
  5121 00001380 BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5122 00001383 BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5123 00001386 B8006C                  	mov	ax,6C00h
  5124                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5125 00001389 CD21                    	int	21h				; call DOS
  5126 0000138B 723F                    	jc	short mrRet			; return failure
  5127                                  
  5128 0000138D 89C3                    	mov	bx,ax				; BX = file handle
  5129 0000138F 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5130 00001391 31F6                    	xor	si,si				; SI = read count
  5131                                  mrRead:
  5132 00001393 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5133 00001397 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5134 00001399 B80042                  	mov	ax,4200h
  5135                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5136 0000139C CD21                    	int	21h				; call DOS
  5137 0000139E 721A                    	jc	short mrCloseFile		; handle error
  5138                                  
  5139                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5140 000013A0 BA[4903]                	mov	dx,MsgBuffer
  5141 000013A3 B94000                  	mov	cx,64				; CX = # bytes to read
  5142 000013A6 B43F                    	mov	ah,3Fh
  5143                                  	;mov	ah,READ				; AH = 'Read File'
  5144 000013A8 CD21                    	int	21h				; call DOS
  5145 000013AA 720E                    	jc	short mrCloseFile		; handle error
  5146                                  
  5147 000013AC 09F6                    	or	si,si				; (CY cleared)
  5148 000013AE 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5149 000013B0 46                      	inc	si				; mark one read done
  5150 000013B1 8B16[4903]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5151 000013B5 09D2                    	or	dx,dx
  5152 000013B7 75DA                    	jnz	short mrRead			; go read the message
  5153 000013B9 F9                      	stc					; null ptr found- no msg
  5154                                  
  5155                                  mrCloseFile:
  5156 000013BA 9C                      	pushf				; save success/failure (CY)
  5157 000013BB B43E                    	mov	ah,3Eh
  5158                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5159 000013BD CD21                    	int	21h			; call DOS
  5160                                  ;	Bugbug: should we avoid this popf?
  5161 000013BF 9D                      	popf				; CY = success/failure
  5162 000013C0 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5163 000013C2 EB08                    	jmp	short mrRet		; we're done
  5164                                  
  5165                                  ;else	;ROMDOS
  5166                                  ;
  5167                                  ;;	DI = ptr to msg ptr
  5168                                  ;
  5169                                  ;	mov	si,di			; SI = ptr to msg ptr
  5170                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5171                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5172                                  ;
  5173                                  ;;	ASSUME ES:NOTHING is still in effect.
  5174                                  ;
  5175                                  ;	push	ds
  5176                                  ;	pop	es				; ES = DATARES seg addr
  5177                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5178                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5179                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5180                                  ;	or	si,si
  5181                                  ;	jz	mrNoMsg			; null ptr- no message text
  5182                                  ;
  5183                                  ;	sub	si,100h			; SI = offset into image of msg
  5184                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5185                                  ;	mov	di,offset DATARES:MsgBuffer
  5186                                  ;	invoke	LoadFromROM
  5187                                  ;	clc					; success
  5188                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5189                                  ;	jmp	short mrRet
  5190                                  ;
  5191                                  ;mrNoMsg:
  5192                                  ;	stc
  5193                                  ;	jmp	short mrRet
  5194                                  ;
  5195                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5196                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5197                                  ;	assume	es:NOTHING
  5198                                  ;
  5199                                  ;endif	;ROMDOS
  5200                                  
  5201                                  ;*	Message ptr is in memory.
  5202                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5203                                  
  5204                                  mrInMem:
  5205                                  	; 14/01/2023
  5206 000013C4 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5207 000013C7 09FF                    	or	di,di			; (CY cleared)
  5208 000013C9 7501                    	jnz	short mrRet		; found message
  5209 000013CB F9                      	stc				; null ptr found - no message
  5210                                  mrRet:	
  5211 000013CC 5E                      	pop	si			; restore all registers
  5212 000013CD 5A                      	pop	dx
  5213 000013CE 59                      	pop	cx
  5214 000013CF 5B                      	pop	bx
  5215 000013D0 58                      	pop	ax
  5216                                  
  5217                                  ;	mov	ds,[OldDS]		; restore ds
  5218 000013D1 1F                      	pop	ds
  5219                                  	;assume	ds:nothing
  5220                                  
  5221 000013D2 CB                      	retf	; 21/04/2023
  5222                                  
  5223                                  ;MsgRetriever endp
  5224                                  
  5225                                  ; M003; Start of changes for UMB support
  5226                                  
  5227                                  ; ----------------------------------------------------------------------------
  5228                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5229                                  ;
  5230                                  ;	ENTRY	al = Saved alloc strat and link state
  5231                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5232                                  ;			b1 = 1 if link state to restore is Linked
  5233                                  ;
  5234                                  ;	EXIT	None
  5235                                  ;
  5236                                  ;	USED	ax, bx, cx
  5237                                  ; ----------------------------------------------------------------------------
  5238                                  
  5239                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5240                                  
  5241                                  ;public	Lh_OffUnlink
  5242                                  Lh_OffUnlink:	; proc	far
  5243                                  	; 14/01/2023
  5244 000013D3 88C5                    	mov	ch,al
  5245 000013D5 88C1                    	mov	cl,al
  5246                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5247                                  	;mov	ax,(ALLOCOPER<<8)
  5248 000013D7 B80058                  	mov	ax,5800h
  5249 000013DA CD21                    	int	21h
  5250 000013DC 89C3                    	mov	bx,ax
  5251 000013DE D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5252 000013E0 80E180                  	and	cl,80h				; mask off b6-b0
  5253 000013E3 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5254 000013E6 08CB                    	or	bl,cl				; set HighFirst bit state
  5255                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5256                                  	;mov	ax,(ALLOCOPER<<8)|1
  5257 000013E8 B80158                  	mov	ax,5801h
  5258 000013EB CD21                    	int	21h				; set alloc strat
  5259                                  
  5260 000013ED 88EB                    	mov	bl,ch
  5261 000013EF D0EB                    	shr	bl,1
  5262 000013F1 30FF                    	xor	bh,bh				; bx = linkstate
  5263                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5264                                  	;mov	ax,(ALLOCOPER<<8)|3
  5265 000013F3 B80358                  	mov	ax,5803h
  5266 000013F6 CD21                    	int	21h				; set linkstate
  5267                                  
  5268 000013F8 CB                      	retf
  5269                                  
  5270                                  ;Lh_OffUnlink endp
  5271                                  
  5272                                  ; M003; End of changes for UMB support
  5273                                  
  5274                                  ;public	EndCode
  5275                                  ; 14/01/2023
  5276                                  ;EndCode: ; label byte
  5277                                  ; 06/06/2023
  5278                                  ; 16/04/2023
  5279                                  ; 14/08/2024
  5280                                  ;EndCode equ ($-StartCode)+100h
  5281                                  
  5282                                  ; 06/06/2023
  5283                                  ;EndCode equ $-StartCode
  5284                                  
  5285                                  ; 14/08/2024
  5286                                  EndCode:
  5287                                  ENDCODE equ ($-StartCode)+100h	
  5288                                  
  5289                                  ;CODERES ends
  5290                                  ;	end
  5291                                  
  5292                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5293                                  
  5294                                  	;times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5295                                  	; 14/08/2024
  5296 000013F9 00<rep 7h>              	times	(((ENDCODE+15)>>4)<<4)-ENDCODE db 0
  5297                                  
  5298                                  ;align 16
  5299                                  
  5300                                  ;=============================================================================
  5301                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5302                                  ;=============================================================================
  5303                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5304                                  
  5305                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5306                                  
  5307                                  ;TITLE   COMMAND Initialization
  5308                                  
  5309                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5310                                  ;ENVIRONSIZ2 EQU 092H
  5311                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5312                                  
  5313                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5314                                  ; 23/09/2018
  5315                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5316                                  ; 14/01/2023
  5317                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5318                                  
  5319                                  ; ----------------------------------------------------------------------------
  5320                                  
  5321                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5322                                  
  5323                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5324                                  ENVIRONSIZ equ 160
  5325                                  ENVSML	equ 256	; minimum environment size
  5326                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5327                                  MAX_COMSPEC equ 146
  5328                                  ECOMSPEC equ 14
  5329                                  
  5330                                  ; 14/01/2023
  5331                                  TAB_CHAR equ 09h
  5332                                  SPACE_CHAR equ 20h	
  5333                                  
  5334                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5335                                  ;ENVIRONSIZ equ 180	; SIZE Environment 
  5336                                  
  5337                                  ;----------------------------------------------------
  5338                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5339                                  ;----------------------------------------------------
  5340                                  ;Environment Struc	; Default COMMAND environment
  5341                                  ;
  5342                                  ;Env_PathString  db	"path="
  5343                                  ;Env_PathSpec	 db	"c:\msdos"
  5344                                  ;                db	0
  5345                                  ;Env_PrmptString db	"prompt="
  5346                                  ;Env_PrmptSpec   db	"$p$g"
  5347                                  ;                db	0
  5348                                  ;Env_ComString   db	"comspec="
  5349                                  ;Env_ComSpec     db	"\command.com"
  5350                                  ;		 db	134 dup (0)
  5351                                  ;
  5352                                  ;Environment ends
  5353                                  ;----------------------------------------------------
  5354                                  
  5355                                  ;-----------------------------------------------------------------------------
  5356                                  
  5357                                  ;-----------------------------------------------------------------------------
  5358                                  ; START OF INIT PORTION
  5359                                  ; This code is deallocated after initialization.
  5360                                  ;-----------------------------------------------------------------------------
  5361                                  
  5362                                  ;INIT	SEGMENT PUBLIC PARA
  5363                                  
  5364                                  ; 	EXTRN   HEADER:BYTE
  5365                                  ;	EXTRN   BADCOMLKMES:BYTE
  5366                                  
  5367                                  ;	PUBLIC  CONPROC
  5368                                  
  5369                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5370                                  
  5371                                          ;ORG 0
  5372                                  ;ZERO = $
  5373                                  	; 23/09/2018
  5374                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5375                                  
  5376                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5377                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5378                                  ConProc:
  5379                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5380 00001400 BC[1E04]                	mov	sp,RStack
  5381                                  
  5382                                  ; We need to set the PSP to us right at start because Carousel needs
  5383                                  ; to be lied to and it does not set PSP when it transfers control to
  5384                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5385                                  ; command.com is also not lied to.
  5386                                  
  5387                                  	; 14/01/2023
  5388                                  	; MSDOS 6.0
  5389 00001403 B450                            mov	ah,50h
  5390                                  	;mov	ah,SET_CURRENT_PDB
  5391 00001405 8CC3                            mov	bx,es
  5392 00001407 CD21                            int	21h
  5393                                  
  5394                                  	; 14/01/2023
  5395 00001409 B430                    	mov	ah,30h 
  5396                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5397                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5398                                  	;mov	ax,3000h
  5399 0000140B CD21                    	int	21h
  5400                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5401                                  	;cmp	ax,5
  5402 0000140D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5403 00001410 7411                    	je	short okdos			; DOS version is ok
  5404                                  
  5405 00001412 BA[181D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5406 00001415 E85DFE                  	call	RPrint
  5407                                  
  5408                                  	; MSDOS 3.3
  5409                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5410                                  	;int	21h             ; DOS - PRINT STRING
  5411                                  				; DS:DX -> string terminated by "$"
  5412 00001418 8CC0                    	mov	ax,es
  5413 0000141A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5414                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5415                                  Here:	
  5416 0000141F 74FE                    	jz	short Here			;  loop forever
  5417                                  	
  5418 00001421 CD20                    	int	20h				; otherwise, exit
  5419                                  okdos:
  5420                                  	; 23/09/2018
  5421                                  
  5422                                  ;  Calculate and save the end of the INIT segment (which is also
  5423                                  ;  the beginning of TRANGROUP).
  5424                                  
  5425                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5426                                  	; MSDOS 3.3
  5427                                  	;mov	ah,65h
  5428                                  	;mov	al,2
  5429                                  	;mov	dx,-1
  5430                                  	;mov	bx,-1
  5431                                  	;mov	cx,5
  5432                                  	;mov	di,UCASE_ADDR
  5433                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5434                                  	;		; AL = 02h : Get pointer to character translation table
  5435                                  	;		; BX = code page (-1 = current global code page)
  5436                                  	;		; DX = country ID (-1 = current country)
  5437                                  	;		; CX = amount of data to return
  5438                                  	;; ES:DI = pointer to output buffer
  5439                                  	;; Buffer offset :
  5440                                  	;;	00h -  byte,  country Id
  5441                                  	;;  	01h -  dword, pointer to uppercase table	
  5442                                  
  5443                                  	; 14/01/2023
  5444                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5445                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5446 00001423 BA0F22                  	mov	dx,TRANSTART+15			; get end of init code
  5447                                  	; 27/09/2018
  5448                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5449 00001426 B104                    	mov	cl,4				; change to paragraphs
  5450 00001428 D3EA                            shr	dx,cl				;
  5451 0000142A 8CC8                            mov     ax,cs                           ; get current segment
  5452 0000142C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5453 0000142E A3[7C1C]                        mov     [initend],ax			; save this
  5454                                  
  5455                                  	; 14/01/2023
  5456                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5457                                  
  5458                                  ;  Check for /? on the command line. If found, display help text and exit.
  5459                                  ;  NOTE: this routine may terminate the program, never returning.
  5460                                  
  5461 00001431 E86A06                  	call	CheckHelp
  5462                                  
  5463                                  ; We have to patch the segment values for the various interrupt entry points.
  5464                                  ; This is because we need to have the default addresses of the handlers in our
  5465                                  ; stub before the relocation is done. These values will then be changed once
  5466                                  ; the resident is relocated
  5467                                  
  5468 00001434 E8A507                  	call	patch_segs
  5469                                  
  5470                                  ;  Turn APPEND off during initialization processing
  5471                                  
  5472                                  	; 14/01/2023
  5473 00001437 B800B7                  	mov     ax,0B700h
  5474                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5475 0000143A CD2F                    	int	2Fh				;
  5476                                  	;cmp	al,0				; append installed?
  5477 0000143C 08C0                    	or	al,al
  5478 0000143E 7418                    	jz	short set_msg_addr		; no - continue
  5479                                  	
  5480 00001440 B802B7                  	mov	ax,0B702h
  5481                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5482 00001443 CD2F                    	int	2Fh				;
  5483                                  	;cmp	ax,-1				; append version correct?
  5484                                  	;jne	short set_msg_addr		; no - continue
  5485 00001445 40                      	inc	ax ; -1 -> 0
  5486 00001446 7510                    	jnz	short set_msg_addr        
  5487                                  	
  5488 00001448 B806B7                  	mov     ax,0B706h
  5489                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5490 0000144B CD2F                    	int	2Fh				;
  5491 0000144D 891E[AB01]                      mov     [Append_State],bx		; save append state
  5492                                         
  5493 00001451 31DB                    	xor	bx,bx                           ; clear out state
  5494 00001453 B807B7                  	mov	ax,0B707h
  5495                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5496 00001456 CD2F                    	int	2Fh				; set everything off
  5497                                  
  5498                                  set_msg_addr:
  5499                                  	; 14/01/2023
  5500                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5501                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5502                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5503 00001458 BF[1D08]                	mov	di,DataresEnd
  5504 0000145B 893E[9D03]              	mov	[ResMsgEnd],di			; save it
  5505                                  
  5506 0000145F E88C07                          call    get_XMMAddr                     ; get XMM call address
  5507                                  
  5508                                  ; Check if this is the first instance of command.com. If not, we just exit
  5509                                  ; this routine without moving any code.
  5510                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5511                                  ; stub. We just have to copy this over
  5512                                  	
  5513                                  ;ifndef ROMDOS
  5514 00001462 B80055                  	mov	ax,5500h
  5515                                  	;mov	ax,GET_COMMAND_STATE	
  5516                                  ;else
  5517                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5518                                  ;endif ; ROMDOS
  5519                                  
  5520 00001465 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5521                                  	;assume	ds:nothing
  5522                                  
  5523                                  	; 03/05/2023
  5524                                  	; Return:
  5525                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5526                                  	;   DS:SI -> entry point table
  5527                                  
  5528                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5529                                  
  5530 00001467 09C0                    	or	ax,ax
  5531 00001469 750C                    	jnz	short first_com			; this is the first instance
  5532                                  
  5533                                  	; 14/01/2023
  5534 0000146B 268936[BC20]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5535 00001470 268C1E[BE20]            	mov	[es:ResJmpTable+2],ds
  5536 00001475 EB06                    	jmp	short init_cntry
  5537                                  
  5538                                  first_com:
  5539 00001477 26C606[C020]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5540                                  
  5541                                  init_cntry:
  5542                                  	; 14/01/2023
  5543 0000147D 06                      	push	es
  5544 0000147E 1F                      	pop	ds
  5545                                  	;assume	ds:RESGROUP
  5546                                  
  5547 0000147F B465                    	mov	ah,65h
  5548                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5549 00001481 B004                    	mov	al,4				; get file ucase table
  5550 00001483 BAFFFF                  	mov	dx,-1				;
  5551                                  	;mov	bx,-1				;
  5552 00001486 89D3                    	mov	bx,dx
  5553 00001488 B90500                  	mov	cx,5				; number of bytes we want
  5554                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5555 0000148B BF[9E01]                	mov	di,FUCase_Addr
  5556 0000148E CD21                    	int	21h
  5557                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5558                                  		; AL = function -
  5559                                  
  5560                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5561                                  
  5562 00001490 1E                      	push	ds				;
  5563 00001491 B80063                  	mov	ax,6300h
  5564                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5565 00001494 CD21                    	int	21h				;
  5566                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5567                                  			
  5568 00001496 8CDB                    	mov	bx,ds				; get segment to bx
  5569 00001498 1F                      	pop	ds				;
  5570 00001499 8936[A701]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5571 0000149D 891E[A901]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5572                                  
  5573                                  	;mov	ax,[16h]
  5574 000014A1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5575                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5576 000014A4 A3[2901]                	mov	[Parent],ax			;  correctly.
  5577 000014A7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5578 000014AA A3[2B01]                	mov	[OldTerm],ax
  5579 000014AD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5580 000014B0 A3[2D01]                	mov	[OldTerm+2],ax
  5581                                  
  5582                                  	; 14/01/2023
  5583                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5584                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5585                                  	;mov	ax,EndCode+15
  5586                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5587                                  	; 14/01/2023
  5588                                  	;mov	cl,4				; ax = size of resident part of
  5589                                  	;shr	ax,cl				;  command in paragraphs. Add
  5590                                  	;mov	cx,cs				;  this to CS and you get the
  5591                                  	;add	ax,cx				;  segment of the TPA.
  5592                                  
  5593 000014B3 8CC8                    	mov	ax,cs
  5594                                  	; 14/08/2024
  5595                                  	EndCodeParag equ (ENDCODE+15)>>4 
  5596                                  	;add	ax,(EndCode+15)>>4
  5597 000014B5 055001                  	add	ax,EndCodeParag
  5598                                  	
  5599 000014B8 A3[4503]                	mov	[Res_Tpa],ax			; Temporarily save the TPA segment
  5600 000014BB 2500F0                  	and	ax,0F000h
  5601 000014BE 050010                  	add	ax,1000h			; Round up to next 64K boundary
  5602 000014C1 7303                    	jnc	short TpaSet			; Memory wrap if carry set
  5603 000014C3 A1[4503]                	mov	ax,[Res_Tpa]
  5604                                  TpaSet:
  5605 000014C6 A3[3903]                	mov	[LTpa],ax			; Good enough for the moment
  5606                                  	;mov	ax,[2]
  5607 000014C9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5608                                  
  5609 000014CC 8C1E[3F03]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5610 000014D0 8C1E[4303]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5611 000014D4 8C1E[3703]              	mov	[MySeg],ds			;  use to call resident routines.
  5612                                  	; 19/04/2023
  5613                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5614 000014D8 8C1E[6E06]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5615                                  
  5616 000014DC A3[8001]                	mov	[MemSiz],ax			; Needed for execing other programs
  5617                                  
  5618                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5619                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5620                                  
  5621                                  ; First reallocate the COMMAND size to its memory image
  5622                                  	
  5623 000014DF 50                      	push	ax    
  5624                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5625                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5626                                  	;mov	bx,TRANSTART
  5627                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5628                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5629                                  	;add	bx,15 ; *			; round up the size
  5630                                  
  5631                                  	; 03/05/2023
  5632                                  	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5633                                  	;;add	bx,TRANSPACEEND
  5634                                  	; 06/06/2023
  5635                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5636                                          ;mov	cl,4				;
  5637                                          ;shr	bx,cl				; size of command.com
  5638 000014E0 BB770B                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
  5639                                  	
  5640 000014E3 B44A                    	mov	ah,4Ah
  5641                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5642 000014E5 CD21                            int     21h				;
  5643 000014E7 58                              pop     ax				;
  5644                                  	
  5645                                  ; Compute maximum size of environment
  5646                                  
  5647                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5648                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5649                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5650                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5651                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5652 000014E8 C706[701C]4C00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5653                                  ;
  5654                                  ; Compute minimum size of environment
  5655                                  ;
  5656                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5657                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5658 000014EE C706[6E1C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5659                                  
  5660                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5661                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5662                                  	; 06/06/2023
  5663                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5664                                  	;mov	cl,4				;  in paragraphs.
  5665                                  	;shr	dx,cl
  5666 000014F4 BA5709                  	mov	dx,(TRANSPACEEND+15)>>4
  5667 000014F7 8916[7E1C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5668                                  
  5669 000014FB 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5670 000014FD A3[7A01]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5671                                  	;mov	ax,[2Ch]
  5672 00001500 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5673                                  
  5674                                  	; 14/01/2023
  5675                                          ; MSDOS 6.0
  5676                                  	;mov	[EnvirSeg],ax
  5677                                          
  5678                                  	; 21/01/2023
  5679 00001503 09C0                    	or	ax,ax				; if there is no environment segment,
  5680 00001505 7406                    	jz	short buildenv			; make one
  5681                                    
  5682                                  	; 21/01/2023
  5683                                  	; MSDOS 3.3 & MSDOS 5.0
  5684                                  	;inc	byte [CHUCKENV]
  5685 00001507 FE06[521C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5686                                  	
  5687                                  	; MSDOS 3.3 & MSDOS 5.0
  5688 0000150B EB03                    	jmp	short environpassed
  5689                                  	; MSDOS 6.0
  5690                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5691                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5692                                  
  5693                                  	; MSDOS 6.0
  5694                                  
  5695                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5696                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5697                                  ; size and free this buffer. We need this buffer because we no longer have an
  5698                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5699                                  ; given on the command line before we know the environment size. This routine
  5700                                  ; will not return in case of an allocation error. It will either exit or hang
  5701                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5702                                  
  5703                                  	; 14/01/2023
  5704                                  buildenv:
  5705 0000150D E87206                  	call	alloc_env                       ; try to allocate buffer
  5706                                  environpassed:
  5707                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5708 00001510 A3[2703]                	mov	[EnvirSeg],ax
  5709                                  	;
  5710 00001513 8EC0                    	mov	es,ax                           ; and it load into es.
  5711                                  	;assume	es:nothing
  5712                                  
  5713                                  gottheenvir:
  5714                                  
  5715                                  ; Initialize the command drive
  5716                                  
  5717                                  ; 14/01/2023
  5718                                  %if 0
  5719                                  	; MSDOS 3.3
  5720                                  BUILDENV:
  5721                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5722                                  	mov	ax,PATHSTRING ; "PATH="
  5723                                  	mov	cl,4
  5724                                  	shr	ax,cl
  5725                                  	mov	dx,ds
  5726                                  	add	ax,dx
  5727                                  ENVIRONPASSED:
  5728                                          mov	[ENVIRSEG],ax
  5729                                          MOV     es,ax
  5730                                  
  5731                                          ;mov	ax,CHAR_OPER<<8
  5732                                          mov	ax,CHAR_OPER*256 ; 3700h
  5733                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5734                                  			; Return: AL = FFh unsupported subfunction
  5735                                  			; DL = current switch character
  5736                                          mov	[RSWITCHAR],dl
  5737                                  
  5738                                          ;CMP	dl,'/'
  5739                                  	cmp	dl,[slash_chr]
  5740                                          jnz	short IUSESLASH
  5741                                  
  5742                                  	;mov	al,'\'
  5743                                   	mov	al,[bslash_chr]
  5744                                  	mov	[COMSPECT],al
  5745                                  
  5746                                  	cmp	byte [CHUCKENV],0
  5747                                  	jnz	short IUSESLASH
  5748                                  
  5749                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5750                                  	; 30/04/2018
  5751                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5752                                  	; 23/09/2018
  5753                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5754                                  gottheenvir:
  5755                                  IUSESLASH:
  5756                                  
  5757                                  ; Initialize the command drive
  5758                                  
  5759                                  %endif
  5760                                  	; 14/01/2023
  5761                                  	; MSDOS 3.3 & MSDOS 6.0
  5762 00001515 B419                    	mov	ah,19h
  5763                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5764 00001517 CD21                    	int	21h
  5765 00001519 FEC0                    	inc	al
  5766 0000151B A2[7F01]                	mov	[ComDrv],al
  5767                                  
  5768                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5769 0000151E A05C00                          mov	al,[FCB]
  5770 00001521 08C0                    	or	al,al
  5771 00001523 7426                    	jz	short nocomdrv		; no drive specified
  5772                                  
  5773 00001525 B43A                    	mov	ah,':'
  5774 00001527 A2[7F01]                	mov	[ComDrv],al
  5775 0000152A 0440                    	add	al,40h			; convert number to uppercase character
  5776                                  
  5777 0000152C FD                      	std
  5778                                  
  5779                                  	; MSDOS 6.0
  5780                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5781                                  	;je	short notwidenv		;  move the default comspec string in it
  5782                                  	; 14/01/2023
  5783                                  	; MSDOS 5.0 COMMAND.COM
  5784                                  	;mov	di,[ComspOffset]
  5785                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5786                                          ;je	short notwidenv		; yes, must have been inherited that way
  5787                                  
  5788                                  	; MSDOS 3.3
  5789                                  	;cmp	byte [CHUCKENV],0
  5790                                  	;jne	short NOTWIDENV
  5791                                  	; 21/01/2021
  5792                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5793 0000152D 803E[521C]00             	cmp	byte [AllocedEnv],0
  5794 00001532 7713                    	ja	short notwidenv
  5795                                  
  5796 00001534 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5797 00001535 06                      	push	es			;  the drivespec is in ax and is copied
  5798 00001536 1F                      	pop	ds			;  on to the front of the string.
  5799                                  
  5800                                  	; MSDOS 6.0
  5801                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5802                                          ;lea	di,[di+MAX_COMSPEC-1]
  5803                                  
  5804                                  	; 21/01/2023
  5805                                  	; 14/01/2023
  5806                                  	; MSDOS 5.0 COMMAND.COM
  5807                                  	; MSDOS 3.3
  5808                                  	; 23/09/2018
  5809                                  	; 30/04/2018
  5810                                  	;mov	di,159
  5811                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5812                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5813 00001537 BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5814                                  	;mov	si,157
  5815                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5816                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5817 0000153A BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5818                                  	;mov	cx,144
  5819                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5820 0000153D B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5821                                  
  5822 00001540 F3A4                    	rep	movsb
  5823 00001542 1F                      	pop	ds
  5824                                  
  5825                                  	; MSDOS 6.0
  5826                                  	;mov	word ptr es:[di-1],ax
  5827                                  
  5828                                  	; MSDOS 3.3
  5829                                  	;mov	[es:0Eh],ax
  5830                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5831                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5832                                  	; 14/01/2023
  5833 00001543 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5834                                  
  5835                                  	; MSDOS 3.3 & MSDOS 6.0
  5836                                  notwidenv:
  5837 00001547 FC                      	cld
  5838 00001548 A3[341C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5839                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5840                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5841                                  	;mov	[KAUTOBAT],ax
  5842                                  nocomdrv:
  5843 0000154B E8A4FA                  	call	SetVect        ; Set the vectors
  5844                                  
  5845                                  ; parsing starts here
  5846                                  
  5847                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5848                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5849                                  	; MSDOS 6.0
  5850 0000154E 0E                      	push	cs
  5851 0000154F 0E                      	push	cs
  5852 00001550 1F                      	pop	ds
  5853 00001551 07                      	pop	es
  5854                                  	;assume ds:ResGroup,es:ResGroup
  5855                                  
  5856                                  ; 14/01/2023
  5857                                  %if 0	
  5858                                  	; MSDOS 3.3
  5859                                  	mov	si,80h		; get command line
  5860                                  	lodsb			; get length of line
  5861                                  	mov	cl,al
  5862                                  	xor	ch,ch		; cx = length of command line
  5863                                  
  5864                                  ; insure that the command line correctly ends with a cr
  5865                                  
  5866                                  	add	si,cx		; go to end of command line	
  5867                                  	mov	byte [si], 0Dh	; insert a carriage return
  5868                                  
  5869                                  	mov	si,81h		; Start of parms
  5870                                  CHKARG:
  5871                                          jcxz	COMRETURNSJ     ; No parameters
  5872                                          dec	cx
  5873                                  	lodsb
  5874                                  CHECKSWITCHCHR:
  5875                                  	;cmp	al,' '
  5876                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5877                                  	jz	short CHKARG
  5878                                  	cmp	al,9		; Skip TAB characters
  5879                                  	jz	short CHKARG
  5880                                  	cmp	al,[RSWITCHAR]	; Switch?
  5881                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5882                                  	jmp	CHKOTHERARGS	; No
  5883                                  
  5884                                  %endif
  5885                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5886                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5887                                  	; MSDOS 6.0
  5888                                  
  5889 00001552 BE8000                  	mov	si,80h				; get command line
  5890 00001555 AC                      	lodsb					; get length of line
  5891 00001556 89F7                    	mov	di,si				; get line position in di
  5892 00001558 30E4                    	xor	ah,ah				; ax = length of command line
  5893                                  
  5894                                  ; insure that the command line correctly ends with a cr
  5895                                  
  5896 0000155A 01C7                    	add	di,ax				; go to end of command line
  5897 0000155C C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5898 0000155F 31C9                    	xor	cx,cx				; clear cx
  5899 00001561 890E[141D]                      mov	[num_positionals],cx		; initialize positionals
  5900                                  
  5901                                  ; Scan the command line looking for the parameters
  5902                                  
  5903                                  Parse_command_line:
  5904                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5905 00001565 BF[861C]                	mov	di,PARSE_COMMAND
  5906 00001568 8B0E[141D]              	mov	cx,[num_positionals]		; Get number of positionals
  5907 0000156C 31D2                    	xor	dx,dx				; clear dx
  5908 0000156E 8936[161D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5909                                  	;call	dword ptr Init_Parse
  5910 00001572 FF1E[7A1C]              	call	far [Init_Parse]		; call parser
  5911 00001576 890E[141D]                      mov     [num_positionals],cx		; Save number of positionals
  5912                                  	; 29/01/2023
  5913                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5914                                          ;cmp	ax,-1
  5915                                  	;jne	short t1
  5916                                  	; 10/06/2023
  5917 0000157A 40                      	inc	ax	 ; cmp ax,-1
  5918 0000157B 7503                    	jnz	short t1 ; 0FFFFh -> 0
  5919                                  	; ax = 0
  5920 0000157D E9FB01                  	jmp     ArgsDone                        ; yes - exit
  5921                                  t1:	
  5922                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5923                                  	;;cmp	ax,0
  5924                                  	;and	ax,ax
  5925                                  	; 10/06/2023
  5926 00001580 48                      	dec	ax  ; cmp ax,0
  5927 00001581 7447                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  5928                                  
  5929                                  ; Before issuing error message - make sure switch is not /C
  5930                                  
  5931                                  parse_line_error:
  5932                                  	; 14/01/2023
  5933                                  	;push	si				; save line position
  5934                                  	;push	ax				; save error number
  5935                                  	;cmp	ax,3
  5936 00001583 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5937                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5938 00001586 752A                    	jne	short parse_line_error_disp2
  5939 00001588 56                      	push	si ; **				; save line position
  5940 00001589 50                      	push	ax ; *				; save error number
  5941 0000158A 89F7                    	mov	di,si				; Get terminating pointer in DI
  5942 0000158C 8B36[161D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5943                                  
  5944                                  init_chk_delim:
  5945 00001590 39FE                    	cmp	si,di				; at end of parsed parameter?
  5946 00001592 741C                            je	short parse_line_error_disp	; Yes - just display message
  5947 00001594 AC                      	lodsb					;
  5948 00001595 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5949                                  	;cmp	al,space_chr ; 14/01/2023
  5950                                  	;;cmp	al,[space]			; Skip blank spaces
  5951 00001597 74F7                    	je	short init_chk_delim		;
  5952                                  	;cmp	al,9
  5953 00001599 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5954 0000159B 74F3                    	je	short init_chk_delim		;
  5955                                  
  5956 0000159D 3A06[3B03]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5957 000015A1 750D                            jne	short parse_line_error_disp	; No - just issue message
  5958 000015A3 AC                      	lodsb					; Get the char after the switch
  5959                                  
  5960 000015A4 E86804                  	call	iupconv 			; upper case it
  5961                                  
  5962                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5963                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5964                                  	;16/04/2023
  5965 000015A7 3C43                    	cmp	al,'C' ; scswitch
  5966 000015A9 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5967 000015AB 5A                      	pop	dx ; *				; even up stack
  5968 000015AC 5A                      	pop	dx ; **				; even up stack
  5969 000015AD E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5970                                  
  5971                                  	; MSDOS 6.0
  5972                                  ;check_k_too:
  5973                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  5974                                          ;jne	short parse_line_error_disp	;
  5975                                  	;pop	dx ; *				; even up stack
  5976                                  	;pop	dx ; **				; even up stack
  5977                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5978                                  
  5979                                  parse_line_error_disp:
  5980                                  	; 14/01/2023
  5981 000015B0 58                      	pop	ax ; *				; restore error number
  5982 000015B1 5E                      	pop	si ; **				; restore line position
  5983                                  parse_line_error_disp2:
  5984 000015B2 89C2                    	mov	dx,ax				; get message number
  5985 000015B4 E8FC03                  	call	RPrintParse
  5986 000015B7 E8B8FC                  	call	crlf
  5987 000015BA EBA9                            jmp     short Parse_command_line        ; continue parsing
  5988                                  
  5989                                  ; 16/04/2023
  5990                                  %if 1
  5991                                  SetMSwitch:
  5992                                          ;cmp	byte [ext_msg],1
  5993 000015BC 803E[811C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5994                                  	; 16/04/2023
  5995                                  	;jnz	short setMswitchok		; no - set it
  5996                                  	;;mov	ax,1
  5997                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5998                                  	;jmp	parse_line_error                ; go issue error message
  5999                                  	; 16/04/2023
  6000 000015C1 744F                    	je	short parse_line_error_j
  6001                                  setMswitchok:
  6002                                          ;mov	byte [ext_msg],1
  6003 000015C3 C606[811C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6004                                  	; 06/06/2023
  6005 000015C8 EB9B                    	jmp	short Parse_command_line	; keep parsing
  6006                                  %endif
  6007                                  
  6008                                  parse_cont:
  6009                                  
  6010                                  ; 15/01/2023
  6011                                  %if 0
  6012                                  	; MSDOS 3.3
  6013                                  
  6014                                  ; See if a switch was entered
  6015                                  
  6016                                  	jcxz	COMRETURNSJ
  6017                                  	dec	cx
  6018                                  	lodsb
  6019                                  	or	al,20h		; Lower case
  6020                                  	cmp	al,'f'		; FAIL switch
  6021                                  	jnz     short CHECKPSWITCH
  6022                                  %endif
  6023                                  
  6024                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6025                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6026                                  	; MSDOS 6.0
  6027                                  
  6028                                  ; See if a switch was entered
  6029                                  ;
  6030                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6031                                  
  6032 000015CA 813E[0D1D][BD1C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6033 000015D0 742A                    	je	short SetFSwitch		; yes go set fail switch
  6034 000015D2 813E[0D1D][B11C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6035 000015D8 7431                    	je	short SetPSwitch		; yes go set up PERMCOM
  6036 000015DA 813E[0D1D][C91C]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6037 000015E0 7453                    	je	short SetDSwitch		; yes go set date switch
  6038 000015E2 813E[0D1D][EE1C]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6039 000015E8 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6040                                  	; MSDOS 6.0 only!
  6041                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6042                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  6043 000015EA 813E[0D1D][D51C]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6044 000015F0 7467                    	je	short SetESwitch		; yes go set up environment
  6045 000015F2 813E[0D1D][FA1C]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6046                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6047                                  	; 15/01/2023
  6048 000015F8 74C2                    	je	short SetMSwitch 
  6049 000015FA EB7B                    	jmp	ChkOtherArgs		; Must be something else
  6050                                  
  6051                                  	; MSDOS 6.0
  6052                                  ;SetMSwitchjmp:
  6053                                  	;jmp	SetMSwitch
  6054                                  	
  6055                                  	; MSDOS 6.0
  6056                                  SetFSwitch:
  6057 000015FC 803E[9201]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6058                                  	; 16/04/2023
  6059                                  	;jne	short failok		; no - set it
  6060                                  	;;mov	ax,1
  6061                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6062                                          ;jmp	parse_line_error        ; go issue error 
  6063                                  	; 16/04/2023
  6064 00001601 740F                    	je	short parse_line_error_j
  6065                                  
  6066                                  	; MSDOS 3.3 & MSDOS 6.0
  6067                                  failok:
  6068 00001603 C606[9201]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6069                                  	; MSDOS 3.3
  6070                                  	;jmp	short CHKARG
  6071                                  	; MSDOS 6.0
  6072 00001608 E95AFF                  	jmp	Parse_command_line
  6073                                  
  6074                                  ;CHECKPSWITCH:
  6075                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6076                                  	;cmp	al,[letter_p]
  6077                                          ;jnz	short CHECKDSWITCH
  6078                                  
  6079                                  SetPSwitch:
  6080                                  
  6081                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6082                                  ; termination address.
  6083                                  
  6084                                  	; MSDOS 6.0
  6085 0000160B 803E[8D01]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6086 00001610 7406                    	jz	short permcomok		; no - set it
  6087                                  	; 16/04/2023
  6088                                  parse_line_error_j:
  6089                                          ;mov	ax,1
  6090 00001612 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6091 00001615 E96BFF                          jmp	parse_line_error	; go issue error 
  6092                                  
  6093                                  permcomok:
  6094                                  	; MSDOS 3.3 & MSDOS 6.0
  6095 00001618 FE06[8D01]              	inc	byte [PermCom]
  6096                                  	;mov	word [OLDTERM],LODCOM
  6097 0000161C C706[2B01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6098                                  	;mov	[OLDTERM+2],ds
  6099 00001622 8C1E[2D01]              	mov	[OldTerm+2],ds
  6100                                  
  6101                                  ; make sure that we display the date and time. if the flag was not
  6102                                  ; initialized, set it to indicate yes, do prompt.
  6103                                  
  6104                                  	; MSDOS 3.3
  6105                                  	;cmp	byte [PRDATTM],-1
  6106                                  	;jnz	short CHKARG
  6107                                  	;mov	byte [PRDATTM],0
  6108                                  	;jmp	short CHKARG
  6109                                  
  6110                                  	; MSDOS 6.0
  6111 00001626 803E[451C]FF            	cmp	byte [PRDATTM],-1
  6112 0000162B 7505                    	jne	short Parse_command_line_jmp
  6113 0000162D C606[451C]00            	mov	byte [PRDATTM],0
  6114                                  Parse_command_line_jmp:
  6115 00001632 E930FF                  	jmp     Parse_command_line	; keep parsing
  6116                                  
  6117                                  ;COMRETURNSJ:
  6118                                  ;	; MSDOS 3.3
  6119                                  ;	JMP	ARGSDONE
  6120                                  
  6121                                  ;CHECKDSWITCH:
  6122                                  	;;cmp	al,'d'
  6123                                          ;cmp	al,[letter_d]
  6124                                  	;jnz	short CHECKCSWITCH
  6125                                  
  6126                                  SetDSwitch:
  6127                                  
  6128                                  ; Flag no date/time prompting.
  6129                                  
  6130                                  	; MSDOS 6.0
  6131 00001635 803E[831C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6132                                  	; 16/04/2023
  6133                                  	;jz	short setdateok		; no - set it
  6134                                          ;;mov	ax,1
  6135                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6136                                          ;jmp	parse_line_error	; go issue error message
  6137                                  	; 16/04/2023
  6138 0000163A 75D6                    	jnz	short parse_line_error_j
  6139                                  setdateok:
  6140 0000163C FE06[831C]              	inc	byte  [dswitch]		; indicate /D entered
  6141                                  
  6142                                  	; MSDOS 3.3 & MSDOS 6.0
  6143 00001640 C606[451C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6144                                  	; MSDOS 3.3
  6145                                  	;jmp	short CHKARG
  6146                                  	; MSDOS 6.0
  6147 00001645 E91DFF                  	jmp     Parse_command_line	; continue parsing
  6148                                  
  6149                                  	; 15/01/2023
  6150                                  	; MSDOS 6.0 
  6151                                  ;SetKSwitch:
  6152                                  	;mov	byte [SemiPermCom],0
  6153                                  	;jmp	short SetSorKSwitch
  6154                                  
  6155                                  ;CHECKCSWITCH:
  6156                                  	;;cmp	al,'c'
  6157                                  	;cmp	al,[letter_c]
  6158                                          ;jnz	short CHECKESWITCH
  6159                                  
  6160                                  SetSSwitch:
  6161                                  ;SETCSWITCH:
  6162                                  
  6163                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6164                                  
  6165 00001648 C606[8D01]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6166                                  ;SetSorKSwitch:
  6167 0000164D 8936[8E01]              	mov	[SingleCom],si		; Point to the rest of the command line
  6168 00001651 C606[451C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6169                                  ;COMRETURNSJ: ; 24/09/2018
  6170 00001656 E92201                  	jmp     ArgsDone
  6171                                  
  6172                                  ;CHECKESWITCH:
  6173                                  	;cmp	al,'e'
  6174                                  	;jnz	short CHKARG
  6175                                  
  6176                                  ; Look for environment-size setting switch
  6177                                  
  6178                                  ; The environment size is represented in decimal bytes and is
  6179                                  ; converted into paragraphs (rounded up to the next paragraph).
  6180                                  
  6181                                  SetESwitch:
  6182                                  	; MSDOS 6.0
  6183 00001659 803E[821C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6184                                  	; 16/04/2023
  6185                                  	;jz	short eswitchok		; no - set it
  6186                                  	;;mov	ax,1
  6187                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6188                                          ;jmp	parse_line_error	; go issue error message
  6189                                  	; 16/04/2023
  6190 0000165E 75B2                    	jnz	short parse_line_error_j
  6191                                  eswitchok:
  6192 00001660 FE06[821C]              	inc	byte [eswitch]		; indicate /E entered
  6193                                  
  6194                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6195                                  %if 0
  6196                                  	; 23/09/2018 - Retro DOS v3.0
  6197                                  
  6198                                  	; MSDOS 3.3
  6199                                  	; (COMMAND.COM offset 0FC5h)
  6200                                  ESWITCHOK:
  6201                                  	jcxz    CHKARG
  6202                                  	dec     cx
  6203                                  	lodsb
  6204                                  	cmp     al,':'
  6205                                  	jnz     short CHECKSWITCHCHR
  6206                                  	xor     bx,bx
  6207                                  	mov     ax,bx
  6208                                  GETENVSIZE:
  6209                                  	jcxz    SETENVSIZE
  6210                                  	dec     cx
  6211                                  	lodsb
  6212                                  	cmp     al,'0'
  6213                                  	jb      short NOTDECIMALCHR
  6214                                  	cmp     al,'9'
  6215                                  	ja      short NOTDECIMALCHR
  6216                                  	sub     al,'0'
  6217                                  	mov     dx,bx
  6218                                  	shl     dx,1
  6219                                  	shl     dx,1   ; dx = 4*bx
  6220                                  	add     bx,dx  ; bx = 5*bx
  6221                                  	shl     bx,1   ; bx = 10*bx
  6222                                  	add     bx,ax
  6223                                  	jmp     short GETENVSIZE
  6224                                  
  6225                                  NOTDECIMALCHR:
  6226                                  	;cmp	al,' '
  6227                                  	cmp	al,[SPACE_CHAR]
  6228                                  	jz      short CHECKENVSIZE
  6229                                  	;cmp	al,'/'
  6230                                  	cmp     al,[RSWITCHAR]
  6231                                  	jz      short CHECKENVSIZE
  6232                                  
  6233                                  CHECKNEXTECHR:
  6234                                  	jcxz    INVENVSIZE
  6235                                  	dec     cx
  6236                                  	lodsb
  6237                                  	;cmp	al,' '
  6238                                  	cmp     al,[SPACE_CHR]
  6239                                  	jz      short ENVSIZESPC
  6240                                  	;cmp	al,'/'
  6241                                  	cmp     al,[RSWITCHAR]
  6242                                  	jnz     short CHECKNEXTECHR
  6243                                  
  6244                                  ENVSIZESPC:
  6245                                  	dec     si
  6246                                  	inc     cx
  6247                                  	jmp     short INVENVSIZE
  6248                                  	
  6249                                  	;nop
  6250                                  
  6251                                  CHECKENVSIZE: 
  6252                                  	dec     si
  6253                                  	inc     cx
  6254                                  
  6255                                  SETENVSIZE:
  6256                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6257                                  	mov	word [ENVSIZ],ENVBIG/16
  6258                                  	cmp     bx,32768
  6259                                  	ja      short INVENVSIZE
  6260                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6261                                  	mov	word [ENVSIZ],ENVSML/16
  6262                                  	cmp     bx,160
  6263                                  	jb      short INVENVSIZE
  6264                                  	add     bx,15
  6265                                  	shr     bx,1
  6266                                  	shr     bx,1
  6267                                  	shr     bx,1
  6268                                  	shr     bx,1
  6269                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6270                                  	jmp     short NEXTCH2
  6271                                  
  6272                                  	;nop
  6273                                  
  6274                                  INVENVSIZE:
  6275                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6276                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6277                                  	int     21h             ; DOS - PRINT STRING
  6278                                  				; DS:DX -> string terminated by "$"
  6279                                  NEXTCH2:
  6280                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6281                                  	jmp     CHKARG
  6282                                  
  6283                                  	;jmp	ARGSDONE
  6284                                  
  6285                                  %endif
  6286                                  	; 15/01/2023
  6287                                  	; MSDOS 6.0
  6288                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6289 00001664 BF[0F1D]                        mov	di,COMND1_ADDR
  6290 00001667 8B1D                    	mov     bx,[di]				; into bx
  6291                                  
  6292 00001669 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6293 0000166C B104                    	mov	cl,4				; convert to pargraphs
  6294 0000166E D3EB                    	shr	bx,cl				; by right 4
  6295                                  
  6296 00001670 891E[6E1C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6297 00001674 E9EEFE                  	jmp	Parse_command_line		; continue parsing command line
  6298                                  
  6299                                  ; 16/04/2023
  6300                                  %if 0
  6301                                  SetMSwitch:
  6302                                          ;cmp	byte [ext_msg],1
  6303                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6304                                  	jnz	short setMswitchok		; no - set it
  6305                                  	;mov	ax,1
  6306                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6307                                  	jmp	parse_line_error                ; go issue error message
  6308                                  setMswitchok:
  6309                                          ;mov	byte [ext_msg],1
  6310                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6311                                  	jmp	Parse_command_line              ; keep parsing
  6312                                  %endif
  6313                                  
  6314                                  ;ArgsDoneJ:
  6315                                  	;jmp	ArgsDone
  6316                                  
  6317                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6318                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6319                                  	
  6320                                  ChkOtherArgs:
  6321                                  
  6322                                  ; We have a non-switch character here.
  6323                                  
  6324                                  	; MSDOS 6.0
  6325 00001677 1E                      	push	ds ; ****			;
  6326 00001678 56                      	push	si ; *** 			; save place in command line
  6327 00001679 C536[0F1D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6328                                  	;assume	ds:nothing			;
  6329                                  
  6330 0000167D 89F2                    	mov	dx,si				; put in dx also
  6331 0000167F B8023D                  	mov	ax,3D02h
  6332                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6333 00001682 CD21                    	int	21h
  6334 00001684 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6335 00001686 89C3                    	mov	bx,ax
  6336 00001688 B80044                  	mov	ax,4400h
  6337                                  	;mov	ax,IOCTL shl 8
  6338 0000168B CD21                    	int	21h
  6339 0000168D F6C280                  	test	dl,80h
  6340 00001690 7506                    	jnz	short IsaDevice
  6341                                  BadSetCon:
  6342 00001692 B43E                    	mov	ah,3Eh
  6343                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6344 00001694 CD21                    	int	21h
  6345 00001696 EB4E                    	jmp	short ChkSrchSpec
  6346                                  
  6347                                  ; 15/01/2023
  6348                                  %if 0
  6349                                  	; MSDOS 3.3
  6350                                  	; (COMMAND.COM offset 1047h)
  6351                                          dec	si
  6352                                  	inc	cx
  6353                                  	mov	dx,si
  6354                                  	push	cx ; **
  6355                                  	push	si ; *
  6356                                  CONTRLOOP:
  6357                                  	lodsb
  6358                                  	dec	cx
  6359                                  	;cmp	al,' '
  6360                                  	cmp	al,[SPACE_CHR]
  6361                                  	jz	short SETCDEV
  6362                                  	cmp	al,9
  6363                                  	jz	short SETCDEV
  6364                                  	jcxz	SETCDEVA
  6365                                  	jmp	short CONTRLOOP
  6366                                  
  6367                                  SETCDEVA:
  6368                                          inc	si
  6369                                  SETCDEV:
  6370                                  	mov	byte [SI-1],0
  6371                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6372                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6373                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6374                                  			; DS:DX -> ASCIZ filename
  6375                                  			; AL = access mode
  6376                                  			; 2 - read & write
  6377                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6378                                          mov	bx,ax
  6379                                          ;mov	ax,IOCTL shl 8
  6380                                          mov     ax,IOCTL*256 ; 4400h
  6381                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6382                                  			; BX = file or device handle
  6383                                          test	dl,80H
  6384                                  	jnz	short ISADEVICE
  6385                                  BADSETCON: ; MSDOS 6.0
  6386                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6387                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6388                                  			; BX = file handle
  6389                                          JMP     short CHKSRCHSPEC
  6390                                  %endif
  6391                                  	;nop
  6392                                  
  6393                                  	; 15/01/2023
  6394                                  IsaDevice:
  6395                                  	; MSDOS 3.3 & MSDOS 6.0
  6396 00001698 30F6                    	xor	dh,dh
  6397 0000169A 80CA03                  	or	dl,3				; Make sure has CON attributes
  6398                                  	;mov	ax,(IOCTL shl 8) or 1
  6399 0000169D B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6400 000016A0 CD21                    	int	21h
  6401                                  	;
  6402                                  	; 15/01/2023
  6403 000016A2 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6404                                  	; 25/09/2018
  6405                                  	;pop	dx ; *
  6406                                  	;pop	dx ; **
  6407                                  	;
  6408                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6409                                  	
  6410 000016A4 89DA                    	mov	dx,bx				; Save new handle
  6411                                  
  6412                                  	; MSDOS 6.0
  6413 000016A6 26803E[C120]01          	cmp	byte [es:DevFlag],1
  6414 000016AC 742A                    	jz	short DevErr
  6415                                  
  6416                                  	; MSDOS 3.3
  6417                                          ;pop	bx ; *				; Throw away saved SI
  6418                                          ;pop	bx ; **				; Throw away saved CX
  6419                                  
  6420                                  	; MSDOS 3.3 & MSDOS 6.0
  6421 000016AE 51                      	push	cx ; **
  6422 000016AF B90300                  	mov	cx,3
  6423 000016B2 31DB                    	xor	bx,bx
  6424                                  
  6425                                  	; 15/01/2023
  6426                                  rcclloop:
  6427 000016B4 B43E                    	mov	ah,3Eh
  6428                                  	;mov	ah,CLOSE ; 3Eh
  6429 000016B6 CD21                    	int	21h
  6430 000016B8 43                      	inc	bx
  6431 000016B9 E2F9                    	loop	rcclloop
  6432                                  
  6433 000016BB 89D3                    	mov	bx,dx				; New device handle
  6434 000016BD B445                    	mov	ah,45h
  6435                                  	;mov	ah,XDUP ; 45h
  6436 000016BF CD21                    	int	21h				; Dup to 0
  6437 000016C1 B445                    	mov	ah,45h
  6438                                  	;mov	ah,XDUP
  6439 000016C3 CD21                    	int	21h				; Dup to 1
  6440 000016C5 B445                    	mov	ah,45h
  6441                                  	;mov	ah,XDUP
  6442 000016C7 CD21                    	int	21h				; Dup to 2
  6443 000016C9 B43E                    	mov	ah,3Eh
  6444                                  	;mov	ah,CLOSE
  6445 000016CB CD21                    	int	21h				; Close initial handle
  6446                                  	
  6447 000016CD 59                      	pop	cx ; **
  6448                                  	
  6449                                  	; MSDOS 6.0
  6450 000016CE 5E                      	pop	si ; ***			; restore position of command line
  6451 000016CF 1F                      	pop	ds ; ****			;
  6452                                  
  6453                                  ; Register the fact that we already have redirected the output
  6454                                  ; and can not do it again
  6455                                  
  6456 000016D0 26FE06[C120]            	inc	byte [es:DevFlag]		
  6457 000016D5 E98DFE                  	jmp	Parse_command_line		; continue parsing
  6458                                  
  6459                                  	; MSDOS 3.3
  6460                                  	;jcxz	ARGSDONEJ2
  6461                                  	;jmp	CHKARG
  6462                                  
  6463                                  	; MSDOS 6.0
  6464                                  DevErr:
  6465 000016D8 5E                      	pop	si ; ***
  6466 000016D9 1F                      	pop	ds ; ****
  6467 000016DA BA0100                  	mov	dx,1
  6468 000016DD E8D302                          call	RPrintParse                     ; "Too many parameters"
  6469 000016E0 E88FFB                          call	crlf
  6470 000016E3 E97FFE                  	jmp	Parse_command_line
  6471                                  
  6472                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6473                                  	; MSDOS 6.0
  6474 000016E6 26803E[C220]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6475 000016EC 74EA                            jz	short DevErr			; yes, error
  6476                                  	
  6477 000016EE 26FE06[C220]                    inc	byte [es:PathFlag]		; mark that we have a path
  6478                                  
  6479                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6480                                  ; This buffer will later be replaced by a proper environment
  6481                                  
  6482                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6483                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6484 000016F3 36A1[2703]              	mov	ax,[ss:EnvirSeg]
  6485                                  	
  6486                                  	; MSDOS 6.0
  6487                                  	;call	alloc_env                       ; environment buffer
  6488                                  
  6489                                  	; 15/01/2023
  6490                                  	; MSDOS 5.0
  6491 000016F7 36803E[521C]01          	cmp	byte [ss:AllocedEnv],1
  6492 000016FD 36C606[521C]00          	mov	byte [ss:AllocedEnv],0
  6493 00001703 7507                    	jne     short env_alloced
  6494 00001705 E87A04                  	call	alloc_env
  6495 00001708 36A3[2703]              	mov	[ss:EnvirSeg],ax
  6496                                  
  6497                                  env_alloced:
  6498                                  	; MSDOS 5.0 & MSDOS 6.0
  6499 0000170C 8EC0                    	mov	es,ax
  6500                                  	;assume	es:nothing
  6501 0000170E 56                      	push	si ; **				; remember location of file
  6502 0000170F 31C9                    	xor	cx,cx				; clear cx for counting
  6503                                  	
  6504                                  	; 15/01/2023
  6505                                  countloop:
  6506 00001711 AC                      	lodsb					; get a character
  6507 00001712 41                      	inc	cx				; increment counter
  6508                                          ;;cmp	al,0
  6509                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6510                                  	;jne	short countloop			; no - keep counting
  6511 00001713 08C0                    	or	al,al	
  6512 00001715 75FA                    	jnz	short countloop
  6513                                  
  6514                                  	;;;;mov	al,[Space]
  6515                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6516                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6517                                  	; 16/04/2023
  6518                                  	;mov	al,20h ; ' ' 
  6519 00001717 4E                      	dec	si				; move back one
  6520                                          ;mov	[si],al				; put a space at end of line
  6521 00001718 C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6522                                  
  6523                                  ; We now know how long the new pathspec for command.com is. Time to
  6524                                  ; figure out how long the current COMSPEC setting is, and then to move
  6525                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6526                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6527                                  ; where the filespec exists in the environment) is updated as well.
  6528                                  
  6529                                  	; MSDOS 6.0 COMMAND.COM
  6530                                  	;push	cx                              ;
  6531                                          ;mov	cx,ENVBIG                       ;
  6532                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6533                                          ;mov	al,0                            ;
  6534                                          ;repne	scasb                           ; find the end of COMSPEC
  6535                                          ;mov	si,di                           ;
  6536                                  ;comp_endenv:                                   ;
  6537                                          ;scasb                                  ; end of env?
  6538                                          ;je	got_endenv                      ; yes
  6539                                          ;repne	scasb                           ;
  6540                                          ;jmp	comp_endenv                     ;
  6541                                  ;got_endenv:                                    ;
  6542                                          ;mov    cx,di                           ;
  6543                                          ;sub    cx,si                           ;
  6544                                          ;mov    di,ComspOffset                  ;
  6545                                          ;sub    di,ComspStrLen                  ;
  6546                                          ;push   ds                              ;
  6547                                          ;push   es                              ;
  6548                                          ;pop    ds                              ;
  6549                                          ;rep    movsb                           ;
  6550                                          ;dec    di                              ; copy in new COMSPEC=
  6551                                          ;push   cs                              ;
  6552                                          ;pop    ds                              ;
  6553                                          ;assume ds:ResGroup                     ;
  6554                                          ;mov    si,offset RESGROUP:ComspString  ;
  6555                                          ;mov    cx,ComspStrLen                  ;
  6556                                          ;rep    movsb                           ;
  6557                                          ;mov    ComspOffset,di                  ;
  6558                                          ;pop    ds                              ;
  6559                                          ;assume ds:nothing                      ;
  6560                                          ;pop    cx                              ;
  6561                                  	;
  6562                                          ;pop    si                              ; get new comspec location back
  6563                                  
  6564                                  	; MSDOS 3.3 COMMAND.COM
  6565                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6566                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6567                                  	;mov	cl,4
  6568                                  	;shr	ax,cl
  6569                                  	;mov	dx,ds
  6570                                  	;add	ax,dx
  6571                                  	;mov	[ENVIRSEG],ax
  6572                                  	;mov	es,ax
  6573                                  	;;mov	al,' '
  6574                                  	;mov	al,[SPACE_CHR]
  6575                                  	;mov	[si-1],al
  6576                                  	;pop	si ; **				; Remember location
  6577                                  	;pop	cx ; *				; and count
  6578                                  	;;mov	di,[ECOMLOC]
  6579                                  	;mov	di,[COMSPOFFSET]
  6580                                  
  6581                                  	; 15/01/2023
  6582                                  	; MSDOS 5.0 COMMAND.COM
  6583 0000171B 5E                      	pop	si ; **
  6584                                  	;mov	di,14
  6585 0000171C BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6586                                  
  6587                                  ComtrLoop:
  6588                                  	; MSDOS 3.3 & MSDOS 6.0
  6589 0000171F AC                      	lodsb
  6590 00001720 49                      	dec	cx
  6591                                  	;;;;cmp	al,' '
  6592                                  	;;;cmp	al,[space_chr]
  6593                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6594                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6595                                  	; 16/04/2023
  6596 00001721 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6597 00001723 7405                    	je	short SetComsr
  6598                                  	; MSDOS 3.3
  6599                                  	;cmp	al,9
  6600                                  	;je	short SetComsr
  6601                                  	; MSDOS 3.3 & MSDOS 6.0
  6602 00001725 AA                      	stosb
  6603 00001726 E302                    	jcxz	SetComsr
  6604 00001728 EBF5                    	jmp	short ComtrLoop
  6605                                  
  6606                                  SetComsr:
  6607                                  	; 15/01/2023
  6608                                  	; MSDOS 6.0
  6609 0000172A 51                      	push	cx ; **
  6610 0000172B 0E                      	push	cs				; Get local segment
  6611 0000172C 1F                      	pop	ds				;
  6612                                  	;assume	ds:ResGroup			;
  6613 0000172D 1E                      	push	ds ; *
  6614                                  	;mov	si,offset ResGroup:ComSpect
  6615 0000172E BE[261C]                	mov	si,COMSPECT
  6616 00001731 B90E00                  	mov	cx,14
  6617 00001734 268A45FF                	mov	al,[es:di-1]
  6618 00001738 3A06[3C03]              	cmp	al,[RDirChar]
  6619 0000173C 7502                    	jne	short iNotRoot
  6620 0000173E 46                      	inc	si				; Don't make a double /
  6621 0000173F 49                      	dec	cx
  6622                                  	
  6623                                  	; MSDOS 3.3
  6624                                  	;push	si
  6625                                  	;push	cx
  6626                                  	;push	ds
  6627                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6628                                  	;mov	cx,14
  6629                                  	;mov	al,[es:di-1]
  6630                                  	;call	PATHCHRCMPR
  6631                                  	;jnz	short INOTROOT			
  6632                                  	;inc	si				; Don't make a double /
  6633                                  	;dec	cx
  6634                                  
  6635                                  iNotRoot:
  6636                                  	; MSDOS 3.3 & MSDOS 6.0
  6637 00001740 F3A4                    	rep	movsb
  6638                                  
  6639                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6640                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6641                                  	; 15/01/2023
  6642                                  	;mov	dx,14
  6643 00001742 BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6644                                  
  6645 00001745 06                      	push	es
  6646 00001746 1F                      	pop	ds
  6647                                  	;;mov	ax,OPEN shl 8
  6648                                  	;mov	ax,OPEN*256 ; 3D00h
  6649 00001747 B8003D                  	mov	ax,3D00h ; 15/01/2023
  6650 0000174A CD21                    	int	21h				; Open COMMAND.COM
  6651 0000174C 1F                      	pop	ds ; *
  6652 0000174D 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6653 0000174F 89C3                    	mov	bx,ax				; Handle
  6654 00001751 B43E                    	mov	ah,3Eh ; 15/01/2023
  6655                                  	;mov	ah,CLOSE ; 3Eh
  6656 00001753 CD21                    	int	21h				; Close COMMAND.COM
  6657                                  SetComsrRet:
  6658                                  	; 15/01/2023
  6659 00001755 59                      	pop	cx ; **
  6660 00001756 5E                      	pop	si ; ***
  6661                                  
  6662                                  	; MSDOS 6.0
  6663 00001757 1F                      	pop	ds ; ****			;
  6664                                  	;assume	ds:ResGroup			;
  6665                                  	;
  6666 00001758 0E                      	push	cs				; Make sure local ES is
  6667 00001759 07                      	pop	es				;  restored
  6668 0000175A E908FE                  	jmp	Parse_command_line		; continue parsing command line
  6669                                  
  6670                                  	; MSDOS 3.3
  6671                                  ;ARGSDONEJ2:
  6672                                  	;jcxz	ARGSDONE
  6673                                  	;jmp	CHKARG
  6674                                  
  6675                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6676                                  SetComsrBad:
  6677                                  	; MSDOS 3.3 & MSDOS 6.0
  6678                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6679 0000175D BA[AA1D]                	mov	dx,BADCOMLKMES
  6680                                  
  6681                                  ;	Note: we're about to make a near call to TriageError, which
  6682                                  ;	lives in a different segment and group. Some linkers will
  6683                                  ;	generate a warning like "Possible fix-up overflow". We're
  6684                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6685                                  ;	we're still all together.
  6686                                  
  6687                                  	; 16/01/2023
  6688                                  	TRIAGEERROR equ TRANSTART+TriageError
  6689                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6690                                  
  6691                                  	;call	50B2h
  6692 00001760 E8(784E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6693                                  				; in original MSDOS 3.3 COMMAND.COM
  6694                                  
  6695                                  			; TriageError procedure is at offset 50B2h
  6696                                  			; in original MSDOS 5.0 COMMAND.COM	
  6697 00001763 83F841                  	cmp	ax,65
  6698 00001766 7503                    	jne	short doprt
  6699                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6700 00001768 BA[D31D]                	mov	dx,BADCOMACCMSG
  6701                                  doprt:
  6702 0000176B E807FB                  	call	RPrint
  6703                                  	;mov	si,offset ResGroup:ComSpect
  6704 0000176E BE[261C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6705                                  	;;mov	di,[ECOMLOC]
  6706                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6707                                  	; 16/01/2023
  6708 00001771 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6709 00001774 B90E00                  	mov	cx,14
  6710 00001777 F3A4                    	rep	movsb				; get my default back
  6711                                  
  6712 00001779 EBDA                    	jmp	short SetComsrRet
  6713                                  
  6714                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6715                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6716                                  ArgsDone:
  6717                                  	; MSDOS 6.0
  6718 0000177B 8E06[2703]              	mov	es,[EnvirSeg]			; get environment back
  6719                                  	;assume	es:nothing			;
  6720                                  
  6721                                  	; MSDOS 3.3 & MSDOS 6.0
  6722 0000177F 803E[8D01]00                    cmp	byte [PermCom],0
  6723 00001784 742E                            jz	short ComReturns
  6724                                  
  6725 00001786 06                      	push	es				; Save environment pointer
  6726 00001787 B450                    	mov	ah,50h
  6727                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6728 00001789 8CDB                    	mov	bx,ds
  6729 0000178B 8EC3                    	mov	es,bx
  6730 0000178D CD21                    	int	21h				; current process is me
  6731 0000178F BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6732                                  	;;mov	ax,offset RESGROUP:LODCOM
  6733                                  	;mov	ax,LODCOM
  6734                                  	; 16/01/2023
  6735 00001792 B8[7E00]                	mov	ax,LodCom_Trap
  6736 00001795 AB                              stosw
  6737 00001796 8CD8                            mov	ax,ds
  6738 00001798 AB                              stosw
  6739                                  	;;mov	ax,offset RESGROUP:CONTC
  6740                                  	;mov	ax,CONTC
  6741                                  	; 16/01/2023
  6742 00001799 B8[4A00]                	mov	ax,Ctrlc_Trap
  6743 0000179C AB                              stosw
  6744 0000179D 8CD8                            mov	ax,ds
  6745 0000179F AB                              stosw
  6746                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6747                                  	;mov	ax,CRITERR
  6748                                  	; 16/01/2023
  6749 000017A0 B8[5500]                	mov	ax,CritErr_Trap
  6750 000017A3 AB                      	stosw
  6751 000017A4 8CD8                    	mov     ax,ds
  6752 000017A6 AB                      	stosw
  6753                                  	;;mov	word ptr ds:16h,ds
  6754                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6755 000017A7 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6756                                          ;;mov	dx,offset RESGROUP:Int_2e
  6757                                  	;mov	dx,Int_2e
  6758                                          ; 16/01/2023
  6759 000017AB BA[3F00]                	mov	dx,Int2e_Trap
  6760 000017AE B82E25                  	mov	ax,252Eh
  6761                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6762                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6763 000017B1 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6764                                  			; AL = interrupt number
  6765                                  			; DS:DX = new vector to be used for specified interrupt
  6766 000017B3 07                              pop	es				; Remember environment
  6767                                  	
  6768                                  ComReturns:
  6769                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6770 000017B4 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6771                                  	; 16/01/2023
  6772 000017B7 A3[2901]                	mov	[Parent],ax			; Save parent
  6773                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6774 000017BA 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6775                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6776 000017BE A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6777 000017C1 A3[8A01]                        mov	[Io_Save],ax		; Get the default stdin and out
  6778 000017C4 8C1E[2B03]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6779 000017C8 8C1E[2F03]                      mov	[Com_Fcb1+2],ds
  6780 000017CC 8C1E[3303]              	mov	[Com_Fcb2+2],ds
  6781                                          ;mov	di,offset ResGroup:ComSpec
  6782 000017D0 BF[3601]                        mov	di,ComSpec
  6783                                  
  6784                                  	;;mov	si,[ECOMLOC]
  6785                                  	; 16/01/2023
  6786                                  	;mov	si,[ComspOffset]
  6787 000017D3 BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6788 000017D6 803E[521C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6789                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6790                                  	
  6791 000017DB 8CD8                    	mov	ax,ds				; Xchg es,ds
  6792 000017DD 06                      	push	es
  6793 000017DE 1F                      	pop	ds
  6794 000017DF 8EC0                    	mov	es,ax
  6795                                  
  6796                                  	;jne	short CopyComsp ; MSDOS 6.0
  6797                                  	; 16/01/2023	
  6798 000017E1 7417                    	je	short CopyComsp ; MSDOS 5.0
  6799                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6800                                  
  6801 000017E3 0E                              push	cs
  6802 000017E4 1F                              pop	ds
  6803                                  
  6804                                          ;mov	si,offset ResGroup:ComspString
  6805 000017E5 BE[591C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6806 000017E8 06                      	push	es
  6807 000017E9 57                      	push	di
  6808 000017EA E8D701                  	call	IfindE
  6809 000017ED 89FE                    	mov	si,di
  6810 000017EF 06                      	push	es
  6811 000017F0 1F                      	pop	ds
  6812 000017F1 5F                      	pop	di
  6813 000017F2 07                      	pop	es
  6814 000017F3 7305                            jnc	short CopyComsp
  6815                                  
  6816                                  	; MSDOS 6.0
  6817                                  ComSpecNofnd:
  6818                                  	;mov	si,offset ResGroup:ComspString
  6819                                  	;add	si,ComspStrLen
  6820                                  	;push	cs
  6821                                  	;pop	ds
  6822                                  
  6823                                  	; 21/01/2023
  6824                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6825                                  	;mov	si,0Eh
  6826 000017F5 BE0E00                  	mov	si,ECOMSPEC
  6827 000017F8 0E                      	push	cs
  6828 000017F9 1F                      	pop	ds	
  6829                                  
  6830                                  	; 21/01/2023
  6831                                  ;COMSPECNOFND:
  6832                                  	; MSDOS 3.3
  6833                                          ;;mov	si,[es:ECOMLOC]
  6834                                          ;mov	si,[es:COMSPOFFSET]
  6835                                  	;;add	si,offset RESGROUP:PATHSTRING
  6836                                          ;add	si,PATHSTRING ; "PATH="
  6837                                  	;push	cs
  6838                                  	;pop	ds
  6839                                  
  6840                                  CopyComsp:
  6841                                  	; 21/01/2023
  6842                                  ;COPYCOMSP:
  6843                                  	; MSDOS 3.3 & MSDOS 6.0
  6844                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6845                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6846 000017FA 26893E[1501]            	mov	[es:PutBackComSpec],di
  6847 000017FF 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6848 00001803 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6849                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6850                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6851 00001805 268306[1501]02          	add	word [es:PutBackComSpec],2
  6852                                  CopyComspLoop:
  6853 0000180B AC                      	lodsb
  6854 0000180C AA                      	stosb
  6855 0000180D 08C0                    	or	al,al
  6856 0000180F 75FA                    	jnz	short CopyComspLoop
  6857                                  
  6858 00001811 26893E[7601]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6859 00001816 26FF0E[7601]            	dec	word [es:ComSpec_End]
  6860 0000181B 268A26[7F01]            	mov	ah,[es:ComDrv]
  6861 00001820 80C440                  	add	ah,'A'-1 ; 40h
  6862 00001823 268826[1A01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6863                                  
  6864                                  	; -------------------------------
  6865                                  
  6866                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6867                                  %if 0
  6868                                  
  6869                                  	; MSDOS 3.3
  6870                                  	push	cs
  6871                                          pop	ds
  6872                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6873                                  	mov	bx,DATARESEND+15
  6874                                          mov	cl,4
  6875                                          shr	bx,cl
  6876                                          MOV     AH,SETBLOCK ; 4Ah
  6877                                          int	21h			; Shrink me to the resident only
  6878                                  
  6879                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6880                                  
  6881                                  	mov	byte [TRNMVFLG], 1
  6882                                  	push	es ; *
  6883                                  	mov	si,TRANSTART
  6884                                  	mov	di,0
  6885                                  	mov	es,[TrnSeg]
  6886                                  	;mov	cx,4D5Ch
  6887                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6888                                  	push	cx
  6889                                  	mov	ax,cx
  6890                                  	add	ax,si
  6891                                  	mov	cl,4
  6892                                  	shr	ax,cl
  6893                                  	inc	ax
  6894                                  	mov	cx,ds
  6895                                  	add	ax,cx
  6896                                  	cmp	ax,[TrnSeg]
  6897                                  	pop	cx
  6898                                  	jb	short MOV_DOWN
  6899                                  
  6900                                  	call	LOADCOM
  6901                                  	jmp	short ICHKSUM
  6902                                  
  6903                                  MOV_DOWN:
  6904                                  	add     si,cx
  6905                                  	dec     si
  6906                                  	add     di,cx
  6907                                  	dec     di
  6908                                  	std
  6909                                  	rep	movsb
  6910                                  	cld
  6911                                  
  6912                                  ICHKSUM:
  6913                                  	; 24/09/2018
  6914                                  ;
  6915                                  ; Compute checksum right now before we can get corrupted and save it
  6916                                  ;
  6917                                  	; MSDOS 6.0
  6918                                  	;mov	si,offset RESGROUP:TranStart
  6919                                  	;add	si,100h
  6920                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6921                                  	;
  6922                                  	;cld
  6923                                  	;shr	cx,1
  6924                                  	;xor	dx,dx
  6925                                  ;Ichksum:
  6926                                  	;lodsw
  6927                                  	;add	dx,ax
  6928                                  	;adc	dx,0
  6929                                  	;loop	Ichksum
  6930                                  	;
  6931                                          ;mov	Sum,dx			; store checksum
  6932                                  
  6933                                  	; MSDOS 3.3
  6934                                  	pop     es ; *
  6935                                  	call    CHKSUM
  6936                                  	mov     [SUM],dx
  6937                                  
  6938                                  	; MSDOS 3.3 & MSDOS 6.0
  6939                                          cmp     byte [PRDATTM],0	;
  6940                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6941                                  ;
  6942                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6943                                  ;
  6944                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6945                                  	;mov	bx,3
  6946                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6947                                          mov     ah,ALLOC ; 48h		;
  6948                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6949                                  			; BX = number of 16-byte paragraphs desired
  6950                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6951                                          mov     [BATCH],ax		; save batch segment
  6952                                  
  6953                                  NOBATCHSEG:
  6954                                  
  6955                                  %endif
  6956                                  	; -------------------------------
  6957                                  
  6958                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6959                                  	
  6960                                  	; MSDOS 6.0
  6961 00001828 E81002                  	call	setup_for_messages		; set up parse and extended error messages
  6962                                  
  6963                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6964                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6965                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6966                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6967                                  ; the data otherwise it is just the data.
  6968                                   
  6969 0000182B E8A702                  	call	Setup_res_end			; put resident size in ResSize
  6970                                  
  6971 0000182E 0E                      	push	cs
  6972 0000182F 1F                      	pop	ds
  6973                                  	;assume	ds:RESGROUP
  6974                                  
  6975                                  ;Public EnvMaximum
  6976                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6977                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6978                                  
  6979                                  	; 21/01/2023
  6980                                  	; MSDOS 6.0
  6981                                  	;;mov	si,offset RESGROUP:TranStart
  6982                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6983                                  	;mov	si,TRANSTART
  6984                                  	;add	si,100h
  6985                                  	; 23/04/2023
  6986 00001830 BE0023                  	mov	si,TRANSTART+100h
  6987                                  
  6988                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6989                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6990 00001833 B9[F084]                	mov	cx,TRANDATAEND-100h
  6991                                  
  6992 00001836 FC                      	cld
  6993 00001837 D1E9                    	shr	cx,1
  6994 00001839 31D2                    	xor	dx,dx
  6995                                  Ichksum:
  6996 0000183B AD                      	lodsw
  6997 0000183C 01C2                    	add	dx,ax
  6998 0000183E 83D200                  	adc	dx,0
  6999 00001841 E2F8                    	loop	Ichksum
  7000                                  
  7001 00001843 8916[8201]                      mov	[Sum],dx			; store checksum
  7002                                  
  7003 00001847 803E[451C]00                    cmp     byte [PRDATTM],0
  7004 0000184C 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  7005                                  	
  7006                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  7007                                  
  7008                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  7009                                  	; 21/01/2023
  7010                                  	;mov	bx,4
  7011 0000184E BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  7012 00001851 B448                    	mov	ah,48h
  7013                                  	;mov	ah,ALLOC                        ;
  7014 00001853 CD21                            int	21h                             ;
  7015 00001855 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  7016 00001857 A3[3401]                        mov	[Batch],ax			; save batch segment
  7017                                  
  7018                                  NoBatchSeg:
  7019                                  
  7020                                  ; 21/01/2023
  7021                                  %if 0
  7022                                  	; MSDOS 3.3
  7023                                  	mov     bx,0FFFFh ; 65535
  7024                                  	mov     ah,ALLOC ; 48h
  7025                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7026                                  			; BX = number of 16-byte paragraphs desired
  7027                                  	sub     bx,[TRNSIZE]
  7028                                  	sub     bx,128
  7029                                  	mov     [ENVMAX],bx
  7030                                  
  7031                                  	cmp     bx,4096
  7032                                  	jb      short ALLOCENVIRSEG
  7033                                  	mov     bx,4096-1		; max. allowed environment size
  7034                                  	mov     [ENVMAX],bx
  7035                                  
  7036                                  ALLOCENVIRSEG:
  7037                                  	mov     ah,ALLOC ; 48h
  7038                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7039                                  			; BX = number of 16-byte paragraphs desired
  7040                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  7041                                  	mov     [OLDENV],bx		; save it	
  7042                                  	mov     word [USEDENV],0	; initialize environment size counter
  7043                                  	mov     ds,bx
  7044                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  7045                                  	mov     es,ax
  7046                                  	xor     si,si
  7047                                  	mov     di,si
  7048                                  	mov     bx,[ss:ENVMAX]
  7049                                  	shl     bx,1
  7050                                  	shl     bx,1
  7051                                  	shl     bx,1
  7052                                  	shl     bx,1
  7053                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  7054                                  	dec     bx			; dec by one to leave room for double 0
  7055                                  	xor     dx,dx			; use dx to indicate that there was
  7056                                  					; no environment size error.
  7057                                  
  7058                                  NXSTR:
  7059                                  	call    GETSTRLEN		; get the size of the current env string
  7060                                  
  7061                                  	push    ds
  7062                                  	push    cs
  7063                                  	pop     ds
  7064                                  	add     [USEDENV],cx		; add the string length to env size
  7065                                  	pop     ds
  7066                                  	cmp     cx,1			; end of environment was encountered.
  7067                                  	je      short ENVEXIT
  7068                                  	sub     bx,cx
  7069                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  7070                                  	inc     dx			; out of env space msg must be displayed
  7071                                  	jmp     short ENVEXIT
  7072                                  
  7073                                  	;nop
  7074                                  
  7075                                  OKCPYSTR:
  7076                                  	jmp     short NXSTR
  7077                                  
  7078                                  ENVEXIT: 
  7079                                  	push    cs
  7080                                  	pop     ds
  7081                                  	or      dx, dx			; dx will be non-zero if error
  7082                                  	jz      short ENVNOERR
  7083                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  7084                                  	call    RPRINT
  7085                                  
  7086                                  %endif
  7087                                  
  7088                                  	; 21/01/2023
  7089                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7090 0000185A 8B1E[2703]              	mov	bx,[EnvirSeg]			; get old environment segment
  7091 0000185E 891E[721C]              	mov	[OldEnv],bx			; save it
  7092 00001862 C706[741C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7093 00001868 8EDB                    	mov	ds,bx
  7094                                  	;assume	ds:nothing
  7095                                  	
  7096 0000186A 31F6                    	xor	si,si
  7097 0000186C 89F7                    	mov	di,si
  7098                                  
  7099                                  ; This is the maximum allowed size for the environment
  7100                                  
  7101                                  	; 21/01/2023
  7102                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7103                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7104                                  	;;mov	[ss:EnvMax],bx
  7105                                  	;shl	bx,1
  7106                                  	;shl	bx,1
  7107                                  	;shl	bx,1
  7108                                  	;shl	bx,1
  7109 0000186E BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7110 00001871 36891E[701C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7111 00001876 4B                      	dec	bx				; dec by one to leave room for double 0
  7112 00001877 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7113                                  						; no environment size error.
  7114                                  ;public NxtStr
  7115                                  NxtStr:
  7116 00001879 E81E01                  	call	GetStrLen			; get the size of the current env string
  7117                                  
  7118                                  ;Bugbug: Can use ss here to address UsedEnv
  7119                                  
  7120 0000187C 1E                      	push	ds                              ; get addressability to environment
  7121 0000187D 0E                              push	cs                              ;                       counter
  7122 0000187E 1F                              pop	ds                              ;
  7123                                  	;assume	ds:ResGroup
  7124 0000187F 010E[741C]                      add	[UsedEnv],cx			; add the string length to env size
  7125 00001883 1F                      	pop	ds                              ;
  7126                                  	;assume	ds:nothing
  7127                                  	
  7128 00001884 83F901                  	cmp	cx,1				; end of environment was encountered.
  7129 00001887 7405                    	je	short EnvExit
  7130 00001889 29CB                    	sub	bx,cx
  7131                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7132                                  	; 21/01/2023
  7133 0000188B 73EC                    	jae	short NxtStr
  7134 0000188D 42                      	inc	dx				; out of env space msg must be displayed
  7135                                  	;jmp	short EnvExit
  7136                                  
  7137                                  ;OkCpyStr:
  7138                                  	;jmp	short NxtStr
  7139                                  
  7140                                  EnvExit:
  7141 0000188E 0E                      	push	cs
  7142 0000188F 1F                      	pop	ds
  7143                                  	;assume	ds:ResGroup
  7144 00001890 09D2                    	or	dx,dx				; dx will be non-zero if error
  7145 00001892 7406                    	jz	short EnvNoErr
  7146                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7147 00001894 BA[301D]                	mov	dx,OUTENVMSG
  7148 00001897 E8DBF9                  	call 	RPrint
  7149                                  EnvNoErr:
  7150 0000189A A1[6E1C]                	mov	ax,[EnvSiz]			; env size previously set
  7151 0000189D B104                    	mov	cl,4
  7152 0000189F D3E0                    	shl	ax,cl				; get size in bytes
  7153 000018A1 3B06[741C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7154 000018A5 7706                    	ja	short st_envsize		; yes, store the size
  7155 000018A7 A1[741C]                	mov	ax,[UsedEnv]
  7156 000018AA 83C00F                  	add	ax,15				; round up
  7157                                  st_envsize:	
  7158 000018AD D3E8                    	shr	ax,cl
  7159 000018AF A3[6E1C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7160                                  
  7161                                  ;if MSVER
  7162                                  	;cmp	SingleCom,0
  7163                                  	;jnz	nophead 			; don't print header if SingleCom
  7164                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7165                                  	;call	RPrint
  7166                                  ;nophead:
  7167                                  ;endif
  7168                                  
  7169                                  ; 21/01/2023
  7170                                  %if 0
  7171                                  	; MSDOS 3.3
  7172                                  ENVNOERR:
  7173                                  	mov     cx,[ENVMAX]
  7174                                  	sub     cx,bx			; current environment size in bytes
  7175                                  	add     cx,16			; add memory arena to the size
  7176                                  	shr     cx,1
  7177                                  	shr     cx,1
  7178                                  	shr     cx,1
  7179                                  	shr     cx,1			; convert current env size to paragraphs
  7180                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7181                                  	;jb	short SET_ENVSIZE
  7182                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7183                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7184                                  
  7185                                  SET_ENVSIZE:
  7186                                  	mov     bx,[ENVSIZ]
  7187                                  	mov     ax,es
  7188                                  	add     ax,bx			; get end segment of environemnt
  7189                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7190                                  	ja      short NOPHEAD
  7191                                  					; free unused paragraghs		
  7192                                  	mov     ax,es
  7193                                  	mov     bx,[INITEND]
  7194                                  	sub     bx,ax
  7195                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7196                                  	mov	word [RESETENV],1	; environment segment reset sign
  7197                                  
  7198                                  NOPHEAD:
  7199                                  	; MSDOS 3.3
  7200                                  	mov     ah,SETBLOCK ; 4Ah
  7201                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7202                                  			; ES = segment address of block to change
  7203                                  			; BX = new size in paragraphs
  7204                                  %endif
  7205                                  	; 21/01/2023
  7206                                  
  7207                                  	; MSDOS 3.3 & 6.0
  7208 000018B2 833E[3401]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7209 000018B7 7503                    	jnz     short DoDate		; yes - go initialize it
  7210 000018B9 E99300                  	jmp     NoDttm			; don't do autoexec or date time
  7211                                  
  7212                                  DoDate:
  7213                                  
  7214                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7215                                  
  7216 000018BC A1[3401]                	mov	ax,[Batch]		; get batch segment
  7217 000018BF C606[8801]03            	mov	byte [EchoFlag],3	; set batch echo
  7218 000018C4 C706[9701]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7219 000018CA 8EC0                    	mov	es,ax
  7220                                  
  7221                                  ; initialize the segment
  7222                                  
  7223 000018CC 31FF                    	xor	di,di
  7224                                  	;;mov	al,0
  7225                                  	;mov	al,BATCHTYPE ; 0
  7226                                  	; 06/06/2023
  7227 000018CE 31C0                    	xor	ax,ax
  7228 000018D0 AA                      	stosb
  7229                                  	;mov	al,1			; initialize echo for batch exit
  7230                                  	;inc	al
  7231                                  	; 22/07/2024
  7232 000018D1 40                      	inc	ax
  7233 000018D2 AA                      	stosb
  7234                                  
  7235                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7236                                  
  7237                                  	;xor	ax,ax			; initialize to zero
  7238                                  	; 06/06/2023
  7239                                  	;dec	al ; ax = 0
  7240                                  	; 22/07/2024
  7241 000018D3 48                      	dec	ax
  7242                                  
  7243                                  	; 21/01/2023
  7244 000018D4 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7245                                  
  7246 000018D5 AB                      	stosw				; batch segment of last job - batlast
  7247 000018D6 AB                      	stosw				; segment for FOR
  7248 000018D7 AA                      	stosb				; FOR flag
  7249 000018D8 AB                      	stosw				; position in file - batseek
  7250 000018D9 AB                      	stosw
  7251                                  
  7252                                  ; clean out the parameters
  7253                                  
  7254                                  	;mov	ax,-1			; initialize to no parameters
  7255                                  	; 06/06/2023
  7256 000018DA 48                      	dec	ax ; ax = -1
  7257                                  
  7258 000018DB B90A00                  	mov	cx,10
  7259 000018DE F3AB                    	rep	stosw
  7260                                  
  7261                                  ; decide whether we should grab the default drive
  7262                                  
  7263 000018E0 803E[341C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7264 000018E5 7509                    	jne	short NoAutSet
  7265 000018E7 B419                    	mov	ah,19h	; 21/01/2023
  7266                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7267 000018E9 CD21                    	int	21h
  7268                                  	;;add	al,'A'
  7269                                  	;add	al,[letter_A] ; Ucasea
  7270                                  	;add	al,[ucasea] ; 21/01/2023
  7271                                  	; 21/01/2023
  7272 000018EB 0441                    	add	al,'A'
  7273 000018ED A2[341C]                	mov	[AUTOBAT],al
  7274                                  	; 21/01/2023
  7275                                  	;mov	[KAUTOBAT],al
  7276                                  NoAutSet:
  7277                                  
  7278                                  ; copy in the batch file name (including nul)
  7279                                  
  7280                                  	;mov	si,offset ResGroup:AutoBat
  7281 000018F0 BE[341C]                	mov	si,AUTOBAT
  7282 000018F3 B90800                  	mov	cx,8
  7283 000018F6 F3A5                    	rep	movsw
  7284                                  	; 23/04/2023
  7285 000018F8 A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7286                                  
  7287                                  	;mov	dx,offset ResGroup:AutoBat
  7288 000018F9 BA[341C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7289                                  
  7290                                  	;;mov	ax,OPEN shl 8
  7291 000018FC B8003D                  	mov	ax,3D00h ; 21/01/2023
  7292                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7293 000018FF CD21                    	int	21h			; see if autoexec.bat exists
  7294 00001901 7208                    	jc	short noabat
  7295 00001903 89C3                    	mov	bx,ax
  7296 00001905 B43E                    	mov	ah,3Eh ; 21/01/2023
  7297                                  	;mov	ah,CLOSE  ; 3Eh
  7298 00001907 CD21                    	int	21h
  7299 00001909 EB51                    	jmp	short Drv0		; go process autoexec
  7300                                  
  7301                                  noabat:
  7302 0000190B 50                      	push	ax
  7303 0000190C E89400                  	call	Setup_Seg
  7304 0000190F A3[501C]                	mov	[triage_add+2],ax
  7305 00001912 58                      	pop	ax
  7306 00001913 FF1E[4E1C]              	call	far [triage_add]	; get extended error
  7307 00001917 83F841                  	cmp	ax,65			; network access denied?
  7308                                  	;jne	short OPENERR		; no - go deallocate batch
  7309                                  	; 21/01/2023
  7310                                  	;je	short AccDenErr
  7311 0000191A 7506                    	jne	short OpenErr
  7312                                  
  7313                                  	; 21/01/2023
  7314                                  ;_ACCDENERROR:					; yes - put out message
  7315                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7316                                  ;	mov	dx,ACCDENERR
  7317                                  ;	call	RPRINT
  7318                                  
  7319                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7320                                  
  7321                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7322                                  
  7323                                  ; 21/01/2023
  7324                                  %if 0
  7325                                  
  7326                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7327                                  ; by Ellen to check only when in Korea. The country information
  7328                                  ; returned will overlay the old parse data area, but we don't care
  7329                                  ; since we won't need the parse information or country information.
  7330                                  ; We only care about the country code returned in BX.
  7331                                  
  7332                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7333                                  
  7334                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7335                                  	mov	dx,INTERNAT_INFO
  7336                                  	mov	ax,3800h
  7337                                  	;mov	ax,INTERNATIONAL<<8
  7338                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7339                                  	int	21h				;
  7340                                  	jc	short NoKabat 			; error - don't bother with it
  7341                                  	cmp	bx,52h
  7342                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7343                                  	jne	short OpenErr 			; no, don't check for kautoexe
  7344                                  
  7345                                  	;mov	di,BatFile			; 3/3/kk
  7346                                  	mov	di,20h
  7347                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7348                                  	mov	si,KAUTOBAT
  7349                                  	mov	cx,8				; auto execution for the 3/3/kk
  7350                                  	rep	movsw				; non-english country	3/3/kk
  7351                                  	movsb					; move in carraige return to terminate string
  7352                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7353                                  	mov	dx,KAUTOBAT
  7354                                  	mov	ax,3D00h
  7355                                  	;mov	ax,OPEN<<8
  7356                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7357                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7358                                  	jc	short NoKabat 			; 3/3/kk
  7359                                  	mov	bx,ax				; 3/3/kk
  7360                                  	mov	ah,3Eh
  7361                                  	;mov	ah,CLOSE			; 3/3/kk
  7362                                  	int	21h				; 3/3/kk
  7363                                  	jmp	short Drv0			; 3/3/kk
  7364                                  
  7365                                  NoKabat:					; 3/3/kk
  7366                                  	call	far [triage_add]		; get extended error
  7367                                  	cmp	ax,65				; network access denied?
  7368                                  	jnz	short OpenErr 			; no - go deallocate batch
  7369                                  
  7370                                  %endif
  7371                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7372                                  
  7373                                  AccDenErr:					; yes - put out message
  7374                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7375 0000191C BA[B905]                	mov	dx,ACCDEN
  7376 0000191F E853F9                  	call	RPrint
  7377                                  OpenErr:
  7378                                  ;OPENERR:
  7379 00001922 8E06[3401]              	mov	es,[Batch]		; not found--turn off batch job
  7380 00001926 B449                    	mov	ah,49h
  7381                                  	;mov	ah,DEALLOC ; 49h
  7382 00001928 CD21                    	int	21h
  7383 0000192A C706[3401]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7384 00001930 C606[8801]01            	mov	byte [EchoFlag],1
  7385 00001935 C706[9701]0000          	mov	word [Nest],0		; indicate no batch in progress
  7386                                  
  7387                                  ;DoDttm:
  7388                                  	;mov	ax,offset TranGroup:Datinit
  7389 0000193B B8[5F2E]                	mov	ax,DATINIT
  7390 0000193E A3[461C]                	mov	[INITADD],ax
  7391                                  
  7392                                  	; MSDOS 6.0
  7393                                  ;;M004;;mov	ax,TrnSeg	
  7394                                  ;
  7395                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7396                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7397                                  ; M004; We use TranStart to get the start of the transient segment.
  7398                                  
  7399                                  	; 21/01/2023
  7400                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7401                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7402                                  	; 06/06/2023
  7403                                  	;mov	ax,TRANSTART
  7404                                  	;mov	cl,4				; M004
  7405                                  	;shr	ax,cl				; get relative seg ; M004
  7406                                  	; 06/06/2023
  7407 00001941 B82002                  	mov	ax,TRANSTART>>4	
  7408                                  
  7409 00001944 8CC9                    	mov	cx,cs
  7410 00001946 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7411                                  
  7412                                  	; 21/01/2023
  7413                                  	; MSDOS 3.3
  7414                                  	; 25/09/2018
  7415                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7416                                  
  7417                                  	; MSDOS 3.3 & MSDOS 6.0
  7418 00001948 A3[481C]                	mov	[INITADD+2],ax
  7419                                  	;call	dword ptr InitAdd
  7420 0000194B FF1E[461C]              	call	far [INITADD]
  7421                                  
  7422                                  NoDttm:
  7423                                  	; MSDOS 6.0
  7424                                  	; 21/01/2023
  7425                                  ;Copyright:
  7426                                  	;public	Copyright
  7427                                  ;	Bugbug:	remove Copyright label.
  7428                                  
  7429                                  ;if IBMVER
  7430 0000194F 833E[8E01]00            	cmp	word [SingleCom],0
  7431 00001954 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7432                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7433 00001956 BA[4B1D]                	mov	dx,COPYRIGHTMSG
  7434 00001959 E819F9                  	call	RPrint
  7435                                  ;endif
  7436                                  	; 21/01/2023
  7437                                  	; MSDOS 3.3
  7438                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7439                                  	;jnz	short DRV0
  7440                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7441                                  	;call	RPRINT
  7442                                  ;DRV0:
  7443                                  	; MSDOS 3.3
  7444                                  	;mov	byte [INITFLAG],0
  7445                                  	;jmp	ENDINIT
  7446                                  
  7447                                  	; 21/01/2023
  7448                                  	; MSDOS 6.0
  7449                                  Drv0:						; Reset APPEND state
  7450 0000195C 1E                      	push	ds				; save data segment
  7451 0000195D 0E                      	push	cs				; Get local segment into DS
  7452 0000195E 1F                      	pop	ds				;
  7453 0000195F B807B7                  	mov	ax,0B707h ; 21/01/2023
  7454                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7455 00001962 8B1E[AB01]              	mov	bx,[Append_State] 		;  back to the original state
  7456 00001966 CD2F                    	int	2Fh				;
  7457 00001968 1F                      	pop	ds				; get data segment back
  7458                                  
  7459                                  ;Check FirstCom set previously to see if this is the first instance of
  7460                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7461                                  ;jump table from the previous stub to the current stub.
  7462                                  
  7463 00001969 803E[C020]01            	cmp	byte [FirstCom],1		; first command.com?
  7464 0000196E 7424                    	jz	short move_code			; yes, move it
  7465                                  
  7466 00001970 06                      	push	es
  7467 00001971 1E                      	push	ds
  7468                                  
  7469 00001972 1E                      	push	ds
  7470 00001973 07                      	pop	es
  7471                                  	;mov	di,offset DATARES:Int2f_Entry
  7472 00001974 BF[0400]                	mov	di,Int2f_Entry	
  7473                                  
  7474                                  	;mov	ds,[es:ResJmpTable+2]		; get segment address
  7475                                  	;mov	si,[es:ResJmpTable]		; get offset address
  7476                                  	; 22/07/2024 - PCDOS 7.1 COMMAND.COM
  7477 00001977 26C536[BC20]            	lds	si,[es:ResJmpTable]
  7478                                  
  7479                                  	;mov	cx,11
  7480                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7481                                  	;shl	cx,1
  7482                                  	;shl	cx,1				; size of table in bytes
  7483                                  	; 21/01/2023
  7484 0000197C B92C00                  	mov	cx,44				; size of table in bytes
  7485                                  
  7486 0000197F FC                      	cld
  7487 00001980 F3A4                    	rep	movsb				; copy the jump table
  7488                                  
  7489                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7490                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7491                                  
  7492 00001982 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7493 00001988 7206                    	jb	short res_low			; no, dont set flag
  7494                                  
  7495 0000198A 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7496                                  res_low:
  7497 00001990 1F                      	pop	ds
  7498 00001991 07                      	pop	es
  7499 00001992 EB03                    	jmp	short finish_init
  7500                                  
  7501                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7502                                  ;or to overlay the messages in the data segment if the user has not used the
  7503                                  ;/msg switch.
  7504                                  
  7505                                  move_code:
  7506 00001994 E88501                  	call	Move_res_code			; move the code
  7507                                  
  7508                                  finish_init:
  7509                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7510 00001997 E968E8                  	jmp	EndInit
  7511                                  
  7512                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7513                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7514                                  
  7515                                  GetStrLen:
  7516                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7517                                  ;	Length is returned in CX
  7518                                  
  7519                                  	; MSDOS 3.3 & MSDOS 6.0
  7520 0000199A 31C9                    	xor	cx,cx
  7521                                  NxtChar:
  7522 0000199C AC                      	lodsb
  7523 0000199D 41                      	inc	cx
  7524 0000199E 08C0                    	or	al,al
  7525 000019A0 75FA                    	jnz	short NxtChar
  7526 000019A2 C3                      	retn
  7527                                  
  7528                                  	; 29/01/2023
  7529                                  Setup_Seg:
  7530                                  
  7531                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7532                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7533                                  ; code segment is used
  7534                                  ; Segment returned in AX.
  7535                                  
  7536                                  	; MSDOS 3.3 & MSDOS 6.0
  7537 000019A3 A1[7A01]                	mov	ax,[TrnSeg]
  7538 000019A6 803E[7C01]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7539 000019AB 7405                    	je	short setup_end
  7540                                  
  7541                                  ;06/06/2023
  7542                                  %if 0
  7543                                  	push	bx
  7544                                  	mov	bx,cs
  7545                                  	;mov	ax,offset ResGroup:TranStart
  7546                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7547                                  	; 06/06/2023
  7548                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7549                                  	;mov	ax,TRANSTART
  7550                                  	;shr	ax,1
  7551                                  	;shr	ax,1
  7552                                  	;shr	ax,1
  7553                                  	;shr	ax,1
  7554                                  	; 29/01/2023
  7555                                  	mov	ax,TRANSTART>>4
  7556                                  	add	ax,bx
  7557                                  	pop	bx
  7558                                  %endif
  7559                                  	; 06/06/2023
  7560 000019AD 8CC8                    	mov	ax,cs
  7561 000019AF 052002                  	add	ax,TRANSTART>>4
  7562                                  
  7563                                  setup_end:
  7564 000019B2 C3                      	retn
  7565                                  
  7566                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7567                                  ;RPRINT:
  7568                                  	; MSDOS 3.3
  7569                                  	;push    ax
  7570                                  	;call    SETUP_SEG
  7571                                  	;mov     [PRINTADD+2], ax
  7572                                  	;;call	dword ptr PRINTADD
  7573                                  	;call	far [PRINTADD]
  7574                                  	;pop     ax
  7575                                  	;retn
  7576                                  
  7577                                  	; 29/01/2023
  7578                                  	; MSDOS 6.0
  7579                                  ;***	RPrintParse - display parse error message
  7580                                  ;
  7581                                  ;	ENTRY	DX = parse error #
  7582                                  ;
  7583                                  ;	EXIT	nothing
  7584                                  ;
  7585                                  ;	USED	flags
  7586                                  ;
  7587                                  ;	EFFECTS
  7588                                  ;	  Message is displayed on stdout.
  7589                                  
  7590                                  RPrintParse:	;proc
  7591                                  	;assume	ds:ResGroup,ss:ResGroup
  7592                                  
  7593 000019B3 52                      	push	dx				; preserve DX
  7594 000019B4 87DA                    	xchg	bx,dx				; bx = parse error #
  7595                                  						; dx = saved BX
  7596 000019B6 4B                      	dec	bx				; bx = parse error index, from 0
  7597 000019B7 D1E3                    	shl	bx,1				; bx = offset in word table
  7598                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7599 000019B9 8B9F[FB08]              	mov	bx,[bx+PARSMSGPTRS]
  7600 000019BD 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7601                                  						; bx = restored
  7602 000019BF E8B3F8                  	call	RPrint				; print the message
  7603 000019C2 5A                      	pop	dx				; restore DX
  7604 000019C3 C3                      	retn
  7605                                  
  7606                                  ;RPrintParse	endp
  7607                                  
  7608                                  	; 29/01/2023
  7609                                  ;PATHCHRCMPR:
  7610                                  	; MSDOS 3.3
  7611                                  	;push	dx
  7612                                  	;mov	dl,[slash_chr]
  7613                                  	;;cmp	byte [RSWITCHAR],'/'
  7614                                          ;cmp	[RSWITCHAR],dl
  7615                                  	;je	short RNOSLASHT
  7616                                  	;;cmp	al,'/'
  7617                                  	;cmp	al,dl
  7618                                  	;je	short RET41 ; zf = 1 
  7619                                  ;RNOSLASHT:
  7620                                          ;;cmp	al,'\'
  7621                                  	;cmp	al,[bslash_chr]
  7622                                  ;RET41:
  7623                                  	;pop	dx
  7624                                  	;retn
  7625                                  
  7626                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7627                                  IfindE:
  7628                                  	; MSDOS 3.3 & MSDOS 6.0
  7629 000019C4 E80300                  	call	ifind				; find the name
  7630                                  	;jc	short ifind2			; carry means not found
  7631                                  	;jmp	short Iscasb1 			; scan for = sign
  7632                                  	; 29/01/2023
  7633 000019C7 733A                    	jnc	short Iscasb1
  7634                                  ifind2:
  7635 000019C9 C3                      	retn
  7636                                  
  7637                                  	; 29/01/2023
  7638                                  
  7639                                  ; on return of find1, es:di points to beginning of name
  7640                                  
  7641                                  ifind:
  7642 000019CA FC                      	cld
  7643 000019CB E82700                  	call	Icount0				; cx = length of name
  7644 000019CE 8E06[2703]              	mov	es,[EnvirSeg]
  7645 000019D2 31FF                    	xor	di,di
  7646                                  ifind1:
  7647 000019D4 51                      	push	cx
  7648 000019D5 56                      	push	si
  7649 000019D6 57                      	push	di
  7650                                  ifind11:
  7651 000019D7 AC                      	lodsb
  7652 000019D8 E83400                  	call	iupconv
  7653 000019DB 47                      	inc	di
  7654 000019DC 263A45FF                	cmp	al,[es:di-1]
  7655 000019E0 7502                    	jnz	short ifind12
  7656 000019E2 E2F3                    	loop	ifind11
  7657                                  ifind12:
  7658 000019E4 5F                      	pop	di
  7659 000019E5 5E                      	pop	si
  7660 000019E6 59                      	pop	cx
  7661 000019E7 74E0                    	jz	short ifind2
  7662 000019E9 51                      	push	cx
  7663 000019EA E81A00                  	call	Iscasb2 			; scan for a nul
  7664 000019ED 59                      	pop	cx
  7665                                  	;cmp	byte [es:di],0
  7666                                  	;jnz	short ifind1
  7667                                  	;stc					; indicate not found
  7668 000019EE 26803D01                	cmp	byte [es:di],1
  7669 000019F2 73E0                    	jnb	short ifind1
  7670                                  	; cf=1					; indicate not found
  7671                                  ;ifind2:
  7672 000019F4 C3                      	retn
  7673                                  
  7674                                  	; 29/01/2023
  7675                                  Icount0:
  7676 000019F5 1E                      	push	ds
  7677 000019F6 07                      	pop	es
  7678 000019F7 89F7                    	mov	di,si
  7679                                  
  7680 000019F9 57                      	push	di				; count number of chars until "="
  7681 000019FA E80600                  	call	Iscasb1
  7682                                  	; 25/09/2018
  7683                                  	;jmp	short Icountx
  7684                                  	;push	di				; count number of chars until nul
  7685                                  	;call	Iscasb2
  7686                                  ;Icountx:
  7687 000019FD 59                      	pop	cx
  7688 000019FE 29CF                    	sub	di,cx
  7689 00001A00 87F9                    	xchg	di,cx
  7690 00001A02 C3                      	retn
  7691                                  
  7692                                  Iscasb1:
  7693                                  	; 29/01/2023
  7694 00001A03 B03D                    	mov	al,"="
  7695                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7696 00001A05 EB02                    	jmp	short Iscasbx
  7697                                  Iscasb2:
  7698 00001A07 30C0                    	xor	al,al				; scan for a nul
  7699                                  Iscasbx:
  7700 00001A09 B90001                  	mov	cx,256 ; 100h
  7701 00001A0C F2AE                    	repnz	scasb
  7702 00001A0E C3                      	retn
  7703                                  
  7704                                  	; 29/01/2023
  7705                                  ;IUPCONV:
  7706                                  	; MSDOS 3.3
  7707                                          ;;cmp	al,"a"
  7708                                  	;cmp	al,[letter_a]
  7709                                          ;jb	short IRET22
  7710                                          ;;cmp	al,"z"
  7711                                          ;cmp	al,[letter_z]
  7712                                  	;ja	short IRET22
  7713                                          ;sub	al,20h			; Lower-case changed to upper-case
  7714                                  ;IRET22:
  7715                                  	;retn
  7716                                  
  7717                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7718                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7719                                  
  7720                                  	; MSDOS 6.0
  7721                                  ; *****************************************************************
  7722                                  ; *
  7723                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7724                                  ; *
  7725                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7726                                  ; *		 the character in AL from the file upper case table
  7727                                  ; *		 in DOS if character if above ascii 128, else
  7728                                  ; *		 subtracts 20H if between "a" and "z".
  7729                                  ; *
  7730                                  ; * INPUT:	 DS	      set to resident
  7731                                  ; *		 AL	      char to be upper cased
  7732                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7733                                  ; *
  7734                                  ; * OUTPUT:	 AL	      upper cased character
  7735                                  ; *
  7736                                  ; *****************************************************************
  7737                                  
  7738                                  iupconv:	;proc	near				
  7739                                  	;assume	ds:ResGroup			;
  7740                                  
  7741 00001A0F 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7742 00001A11 7210                    	jb	short other_fucase		; no - upper case math
  7743 00001A13 2C80                    	sub	al,80h				; only upper 128 chars in table
  7744 00001A15 1E                      	push	ds				;
  7745 00001A16 53                      	push	bx				;
  7746                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7747 00001A17 C51E[9F01]              	lds     bx,[FUCase_Addr+1]
  7748 00001A1B 83C302                  	add	bx,2				; skip over first word
  7749                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7750 00001A1E D7                      	xlat
  7751 00001A1F 5B                      	pop	bx				;
  7752 00001A20 1F                      	pop	ds				;
  7753 00001A21 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7754                                  
  7755                                  other_fucase:					;
  7756                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7757 00001A23 3C61                    	cmp	al,'a'
  7758 00001A25 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7759                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7760 00001A27 3C7A                    	cmp	al,'z'
  7761 00001A29 7702                    	ja	short iupconv_end		;
  7762 00001A2B 2C20                    	sub	al,20h				; Change lower-case to upper
  7763                                  iupconv_end:					;
  7764 00001A2D C3                      	retn
  7765                                  
  7766                                  ;iupConv endp
  7767                                  
  7768                                  	; 29/01/2023
  7769                                  init_contc_specialcase:
  7770                                  	; MSDOS 3.3 & MSDOS 6.0
  7771                                  						; This routine is called if control-C
  7772 00001A2E 83C406                  	add	sp,6				;  is type during the date/time prompt
  7773 00001A31 56                      	push	si				;  at initialization time.  The desired
  7774 00001A32 89D6                    	mov	si,dx				;  response is to make it look like the
  7775 00001A34 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7776 00001A39 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7777 00001A3A CF                      	iret					;  a <CR> in the user's buffer, and
  7778                                  						;  returning directly to the user.
  7779                                  						; In this case the user is TCODE.
  7780                                  
  7781                                  ; ----------------------------------------------------------------------------
  7782                                  
  7783                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7784                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7785                                  
  7786                                  	; MSDOS 6.0
  7787                                  ; ****************************************************************
  7788                                  ; *
  7789                                  ; * ROUTINE:	 Setup_for_messages
  7790                                  ; *
  7791                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7792                                  ; *		 messages as follows:
  7793                                  ; *
  7794                                  ; *		 IF /P and /MSG are entered
  7795                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7796                                  ; *		 ELSE IF /P is entered
  7797                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7798                                  ; *		    remove PARSE ERRORS from memory
  7799                                  ; *		 ELSE
  7800                                  ; *		    remove PARSE ERRORS from memory
  7801                                  ; *		 ENDIF
  7802                                  ; *
  7803                                  ; * INPUT:	 PERMCOM	Set up with user input
  7804                                  ; *		 EXT_MSG	Set up with user input
  7805                                  ; *		 System set up to retain PARSE ERRORS
  7806                                  ; *
  7807                                  ; * OUTPUT:	 registers unchanged
  7808                                  ; *
  7809                                  ; ****************************************************************
  7810                                  
  7811                                  setup_for_messages: ;proc near		
  7812                                  
  7813 00001A3B 53                      	push	bx
  7814 00001A3C 1E                      	push	ds				; save data segment
  7815 00001A3D 06                      	push	es				; save environment segment
  7816 00001A3E 50                      	push	ax				;
  7817 00001A3F 52                      	push	dx				;
  7818 00001A40 57                      	push	di				;
  7819 00001A41 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7820 00001A43 8ED8                    	mov	ds,ax				;
  7821 00001A45 8EC0                    	mov	es,ax				;
  7822                                  
  7823 00001A47 803E[8D01]00            	cmp	byte [PermCom],0		; was permcom set?
  7824 00001A4C 743C                    	jz	short no_permcom		; No - don't worry about messages
  7825                                  
  7826                                  ;*	We're permanent. Install our message services int 2f handler.
  7827                                  
  7828 00001A4E 06                      	push	es
  7829                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7830 00001A4F B82F35                  	mov	ax,352Fh
  7831 00001A52 CD21                    	int	21h
  7832                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7833                                  			; AL = interrupt number
  7834                                  			; Return: ES:BX = value of interrupt vector
  7835 00001A54 891E[9903]              	mov	[Int2fHandler],bx
  7836 00001A58 8C06[9B03]              	mov	[Int2fHandler+2],es
  7837 00001A5C 07                      	pop	es
  7838                                  
  7839                                  ;	DS = RESGROUP seg addr
  7840                                  
  7841                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7842                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7843                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7844                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7845                                  ; M005; call) goes off into space.
  7846                                  
  7847 00001A5D 803E[C020]00            	cmp	byte [FirstCom],0		; M005
  7848 00001A62 7416                    	je	short no_msg_hook		; M005
  7849                                  ;
  7850                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7851                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7852                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7853                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7854                                  ; M005; segment matches the command.com PSP and then updates these segments
  7855                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7856                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7857                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7858                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7859                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7860                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7861                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7862                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7863                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7864                                  ; M005; jump to the actual int 2fh entry point.
  7865                                  ;
  7866 00001A64 1E                      	push	ds				; M005
  7867                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7868 00001A65 BA[C300]                	mov     dx,Carousel_i2f_Hook
  7869 00001A68 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7870 00001A6B 8CD8                    	mov	ax,ds				; M005
  7871 00001A6D 40                      	inc	ax				; Relocated cs ; M005
  7872 00001A6E 8ED8                    	mov	ds,ax				; M005
  7873                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7874 00001A70 B82F25                  	mov	ax,252Fh
  7875 00001A73 CD21                    	int	21h
  7876                                  			; DOS - SET INTERRUPT VECTOR
  7877                                  			; AL = interrupt number
  7878                                  			; DS:DX = new vector to be used for specified interrupt
  7879 00001A75 1F                      	pop	ds				; M005
  7880                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7881 00001A76 8C1E[C600]              	mov	[Carousel_i2f_Hook+3],ds
  7882                                  						; patch in the cs for jump
  7883                                  no_msg_hook:					; M005
  7884 00001A7A 803E[811C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7885 00001A7F 7516                    	jne	short permcom_end		; no /msg - exit
  7886                                  
  7887                                  permcom_slash_msg:				; Keep messages in memory
  7888                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7889 00001A81 BF[F40B]                	mov     di,ExtMsgEnd
  7890 00001A84 893E[9D03]              	mov	[ResMsgEnd],di			; save it
  7891 00001A88 EB0D                    	jmp	short permcom_end		; exit
  7892                                  
  7893                                  no_permcom:					
  7894                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7895 00001A8A 803E[811C]01            	cmp	byte [ext_msg],1
  7896 00001A8F 7506                    	jne	short permcom_end		; no - no error
  7897                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7898 00001A91 BA0200                  	mov	dx,2
  7899 00001A94 E81CFF                  	call	RPrintParse
  7900                                  
  7901                                  permcom_end:
  7902 00001A97 5F                      	pop	di				;
  7903 00001A98 5A                      	pop	dx				;
  7904 00001A99 58                      	pop	ax				;
  7905 00001A9A 07                      	pop	es				; get environment back
  7906 00001A9B 1F                      	pop	ds				;
  7907 00001A9C 5B                      	pop	bx
  7908                                  
  7909 00001A9D C3                      	retn					;
  7910                                  
  7911                                  ;setup_for_messages	endp
  7912                                  
  7913                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7914                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7915                                  
  7916                                  	; MSDOS 6.0
  7917                                  
  7918                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7919                                  ;
  7920                                  ;	ENTRY	command-line tail at 81h
  7921                                  ;
  7922                                  ;	EXIT	return if /? not found
  7923                                  ;		terminate if /? found
  7924                                  ;
  7925                                  ;	USED	AX,BX,CX,DX,SI,DI
  7926                                  ;
  7927                                  ;	EFFECTS	Help text displayed if /? found on command line
  7928                                  
  7929                                  CheckHelp:	; proc
  7930                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7931                                  
  7932 00001A9E BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7933                                  	;mov	di,offset RESGROUP:Parse_Command
  7934 00001AA1 BF[861C]                	mov	di,PARSE_COMMAND
  7935                                  					; ES:DI = ptr to primary parse block
  7936 00001AA4 31C9                    	xor	cx,cx			; CX = # positional param's found
  7937 00001AA6 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7938                                  chParse:
  7939                                  	;call	dword ptr Init_Parse
  7940 00001AA8 FF1E[7A1C]              	call	far [Init_Parse]	; call system parser
  7941                                  
  7942                                  	;;cmp	ax,END_OF_LINE
  7943                                  	;cmp	ax,-1 ; 0FFFFh	
  7944                                  	;je	short chRet		; end of command line, no /? found
  7945                                  	;;cmp	ax,RESULT_NO_ERROR
  7946                                  	;;cmp	ax,0
  7947                                  	;;je	short chWhich		; valid syntax element found
  7948                                  	;;jmp	short chParse		; go parse more
  7949                                  	;and	ax,ax ; cmp ax,0
  7950                                  	;jnz	short chParse ; jne
  7951                                  	; 10/06/2023
  7952 00001AAC 40                      	inc	ax	; cmp ax,-1
  7953 00001AAD 7413                    	jz	short chRet   ; 0FFFFh -> 0
  7954 00001AAF 48                      	dec	ax	; cmp ax,0
  7955 00001AB0 75F6                    	jnz	short chParse ; 1 -> 0
  7956                                  	; ax = 0
  7957                                  chWhich:
  7958                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7959 00001AB2 813E[0D1D][081D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7960 00001AB8 7409                    	je	short chHelp		; /? found - display help & exit
  7961                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7962 00001ABA 813E[0D1D][EE1C]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7963                                  	;je	short chRet		; /c found - ignore rest of line
  7964                                  	; 29/01/2023
  7965 00001AC0 75E6                    	jne	short chParse
  7966                                  	; MSDOS 6.0
  7967                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7968                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7969                                  	;je	short chRet		; /k found - ignore rest of line
  7970                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7971                                  chRet:
  7972 00001AC2 C3                      	retn
  7973                                  chHelp:
  7974                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7975 00001AC3 BE[9220]                	mov	si,HelpMsgs
  7976                                  chHelpNext:
  7977 00001AC6 AD                      	lodsw					; AX = ptr to msg
  7978 00001AC7 09C0                    	or	ax,ax
  7979 00001AC9 7407                    	jz	short chHelpDone		; end of list - all done
  7980 00001ACB 89C2                    	mov	dx,ax				; DX = ptr to msg
  7981 00001ACD E8A5F7                  	call	RPrint				; display msg
  7982 00001AD0 EBF4                    	jmp	short chHelpNext		; go do next msg
  7983                                  
  7984                                  chHelpDone:
  7985 00001AD2 CD20                    	int	20h				; terminate program
  7986                                  ;chRet:
  7987 00001AD4 C3                      	retn
  7988                                  
  7989                                  ;CheckHelp	endp
  7990                                  
  7991                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7992                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7993                                  
  7994                                  	; MSDOS 6.0
  7995                                  
  7996                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7997                                  ;
  7998                                  ; It determines based on 2 factors:
  7999                                  ;	1. Is this is the first COMMAND?
  8000                                  ;	2. Is COMMAND to be loaded into HIMEM?
  8001                                  ;   The strategy works as follows:
  8002                                  ;
  8003                                  ;	if (First COMMAND)
  8004                                  ;	then if (COMMAND in HIMEM)
  8005                                  ;		ResSize = resident_data;
  8006                                  ;	     else
  8007                                  ;		ResSize = resident_data + resident_code;
  8008                                  ;	else
  8009                                  ;	   ResSize = resident_data;
  8010                                  ;
  8011                                  ; Int 2fh calls have been added to determine whether or not we are the first
  8012                                  ; COMMAND and whether DOS is in HIMEM.
  8013                                  ;
  8014                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  8015                                  ;
  8016                                  ;	EXIT:  ResSize = resident size in low memory
  8017                                  ;
  8018                                  ;	REGISTERS AFFECTED: ax,cx,dx
  8019                                  ;
  8020                                  
  8021                                  GET_HMA_ADDR	equ	4A02h
  8022                                  
  8023                                  Setup_res_end:	;proc near
  8024                                  	
  8025 00001AD5 1E                      	push	ds
  8026 00001AD6 8CC8                    	mov	ax,cs
  8027 00001AD8 8ED8                    	mov	ds,ax				;ds = RESGROUP
  8028                                  	;assume	ds:RESGROUP
  8029                                  
  8030 00001ADA 8B0E[9D03]              	mov	cx,[ResMsgEnd]			;set resident size = data
  8031                                  
  8032                                  ;ifndef	ROMDOS
  8033                                  
  8034                                  ;M042 -- Begin changes
  8035                                  ;If messages are to be kept behind, we need to round up the messages to
  8036                                  ;the next para boundary. This is because we have a dummy segment between the
  8037                                  ;data and the resident code segment so that the code segment starts on a
  8038                                  ;para boundary
  8039                                  
  8040                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  8041 00001ADE 81F9[F40B]              	cmp	cx,ExtMsgEnd
  8042 00001AE2 7506                    	jne	short calc_res			;no, continue
  8043 00001AE4 83C10F                  	add	cx,15				;round up
  8044 00001AE7 83E1F0                  	and	cx,0FFF0h
  8045                                  calc_res:
  8046                                  
  8047                                  ;M042 -- End changes
  8048                                  
  8049                                  	; 18/07/2024
  8050                                  	;xor	ax,ax
  8051                                         	
  8052 00001AEA 803E[C020]01            	cmp	byte [FirstCom],1		;is it first command.com?
  8053                                  	;jne	short not_first			;no, do not keep code
  8054                                  	; 06/06/2023
  8055 00001AEF 751A                    	jne	short not_first2
  8056                                  
  8057                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  8058                                  ;bit 4 of dh is set
  8059                                  
  8060 00001AF1 53                      	push	bx
  8061 00001AF2 51                      	push	cx
  8062                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  8063 00001AF3 B80633                  	mov	ax,3306h
  8064 00001AF6 CD21                    	int	21h
  8065                                  		; DOS - 5+ Get TRUE Version Number
  8066                                  		; (BL major, BH minor, DL revision, DH flags)
  8067 00001AF8 59                      	pop	cx
  8068                                  
  8069                                  ;bugbug: remove version check after testing
  8070                                  
  8071 00001AF9 80FB05                  	cmp	bl,5				;bl has true version ; M013
  8072 00001AFC 7207                    	jb	short oldver
  8073                                  
  8074 00001AFE 31C0                    	xor	ax,ax
  8075 00001B00 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  8076                                  	;pop	bx
  8077                                  	;jnz	short not_first			;DOS in HIMEM, code not
  8078                                  						;	resident
  8079                                  	; 29/01/2023
  8080 00001B03 7503                    	jnz	short not_first_pop
  8081                                  oldver:
  8082                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8083                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8084                                  	; 06/06/2023
  8085                                  	; 29/01/2023
  8086                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  8087                                  	; 03/05/2023
  8088 00001B05 B8F907                  	mov	ax,EndCode-RCODE_START	; 06/06/2023
  8089                                  
  8090                                  not_first_pop:
  8091                                  	; 29/01/2023
  8092 00001B08 5B                      	pop	bx
  8093                                  
  8094                                  not_first:
  8095                                  
  8096                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  8097                                  
  8098 00001B09 01C1                    	add	cx,ax
  8099                                  
  8100                                  not_first2:	; 06/06/2023
  8101                                  
  8102                                  ;endif	;not ROMDOS
  8103                                  
  8104 00001B0B 83C10F                  	add	cx,15				;round up to next para
  8105 00001B0E D1E9                    	shr	cx,1
  8106 00001B10 D1E9                    	shr	cx,1
  8107 00001B12 D1E9                    	shr	cx,1
  8108 00001B14 D1E9                    	shr	cx,1				;ax = para size of res code
  8109 00001B16 890E[9F03]              	mov	[ResSize],cx			;store resident size
  8110                                  
  8111 00001B1A 1F                      	pop	ds
  8112                                  	;assume	ds:nothing
  8113 00001B1B C3                      	retn
  8114                                  
  8115                                  ;ifndef	ROMDOS
  8116                                  
  8117                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8118                                  
  8119                                  	; 29/01/2023
  8120                                  ;oldver:
  8121                                  ;	pop	bx
  8122                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8123                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8124                                  ;	; 29/01/2023
  8125                                  ;	mov	ax,EndCode-RCODE_START
  8126                                  ;	jmp	short not_first
  8127                                  
  8128                                  ;endif	;not ROMDOS
  8129                                  
  8130                                  ;setup_res_end	endp
  8131                                  
  8132                                  ;ifndef	ROMDOS
  8133                                  
  8134                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8135                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8136                                  
  8137                                  	; MSDOS 6.0
  8138                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8139                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8140                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8141                                  ; the correct resident size. When remaining low, we have to check if we 
  8142                                  ; need to overlay the messages part of the data segment which is determined
  8143                                  ; by the /msg switch.
  8144                                  ;
  8145                                  ;	ENTRY: ResMsgEnd = end of resident data
  8146                                  ;
  8147                                  ;	EXIT:  The resident code is either up high or in its final location
  8148                                  ;		down low.
  8149                                  ;
  8150                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8151                                  	
  8152                                  Move_res_code:	;proc near
  8153                                  
  8154 00001B1C 1E                      	push	ds
  8155 00001B1D 06                      	push	es
  8156                                  
  8157 00001B1E 8CC8                    	mov	ax,cs
  8158 00001B20 8ED8                    	mov	ds,ax
  8159                                  	;assume	ds:RESGROUP
  8160                                  
  8161                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8162 00001B22 B80633                  	mov	ax,3306h
  8163 00001B25 CD21                    	int	21h				;DOS in HIMEM?
  8164                                  		; DOS - 5+ Get TRUE Version Number
  8165                                  		; (BL major, BH minor, DL revision, DH flags)
  8166                                  
  8167 00001B27 80E610                  	and	dh,10h				; M013
  8168 00001B2A 750E                    	jnz	short move_high			;yes, move code high
  8169                                  
  8170                                  ;Check if messages have been discarded or not
  8171                                  
  8172                                  load_low:
  8173 00001B2C 1E                      	push	ds
  8174 00001B2D 07                      	pop	es				;es = RESGROUP
  8175 00001B2E 8B3E[9D03]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8176                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8177                                  	;mov	bx,ExtMsgEnd
  8178                                  	; 29/01/2023
  8179 00001B32 81FF[F40B]              	cmp	di,ExtMsgEnd
  8180                                  	;cmp	di,bx				;are messages to be kept?
  8181 00001B36 7431                    	je	short no_move			;yes, dont move code
  8182                                  
  8183 00001B38 EB37                    	jmp	short setup_move		;es:di points at dest.
  8184                                  
  8185                                  move_high:
  8186                                  
  8187                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8188                                  ;We pass in bx the number of bytes we need
  8189                                  
  8190                                  	;mov	bx,offset CODERES:EndCode
  8191                                  	; 29/01/2023
  8192                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8193                                  	; 06/06/2023
  8194                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8195                                  	; 03/05/2023
  8196 00001B3A BBF907                  	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8197                                  
  8198                                  ;M030;
  8199                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8200                                  
  8201 00001B3D BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8202                                  						;this ; M030
  8203 00001B40 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8204 00001B43 CD2F                    	int	2Fh
  8205                                  
  8206                                  ;If the offset = 0xffff, then no HMA available
  8207                                  
  8208 00001B45 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8209 00001B48 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8210 00001B4D 7522                    	jne	short setup_move		;no error, es:di = memory
  8211                                  
  8212                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8213                                  	; 29/01/2023	
  8214 00001B4F FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8215                                  
  8216                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8217                                  ;ResSize to reflect this
  8218                                  
  8219 00001B53 8B0E[9D03]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8220                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8221                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8222                                  	;mov	ax,EndCode-RCODE_START
  8223                                  	;add	cx,ax
  8224                                  	; 06/06/2023
  8225                                  	; 29/01/2023
  8226                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8227                                  	;add	cx,15				;round up to next para
  8228                                  	; 03/05/2023
  8229 00001B57 81C10808                	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8230 00001B5B D1E9                    	shr	cx,1
  8231 00001B5D D1E9                    	shr	cx,1
  8232 00001B5F D1E9                    	shr	cx,1
  8233 00001B61 D1E9                    	shr	cx,1				;ax = para size of res code
  8234 00001B63 890E[9F03]              	mov	[ResSize],cx			;store resident size
  8235 00001B67 EBC3                    	jmp	short load_low			;let code remain low
  8236                                  
  8237                                  no_move:
  8238                                  	; 05/05/2023
  8239                                  	;mov	cl,4
  8240 00001B69 83C70F                  	add	di,0Fh
  8241 00001B6C 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8242 00001B6F EB0B                    	jmp	short patch_up
  8243                                  
  8244                                  setup_move:
  8245                                  	;mov	si,offset RESGROUP:StartCode
  8246                                  	; 03/05/2023
  8247 00001B71 BE[000C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8248                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8249                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8250                                  	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8251                                  	; 06/06/2023
  8252                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8253                                  	; 03/05/2023
  8254 00001B74 B9F907                  	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8255                                  
  8256 00001B77 FC                      	cld
  8257 00001B78 57                      	push	di				;need di for patching offset
  8258 00001B79 F3A4                    	rep	movsb
  8259 00001B7B 5F                      	pop	di
  8260                                  
  8261                                  patch_up:
  8262 00001B7C E84200                  	call	patch_stub
  8263 00001B7F 07                      	pop	es
  8264 00001B80 1F                      	pop	ds
  8265                                  	;assume	ds:nothing
  8266 00001B81 C3                      	retn
  8267                                  
  8268                                  ;Move_res_code endp
  8269                                  
  8270                                  ;else	;ROMDOS
  8271                                  ;
  8272                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8273                                  ;
  8274                                  ;Move_res_code	proc
  8275                                  ;
  8276                                  ;	push	es
  8277                                  ;
  8278                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8279                                  ;	call	patch_stub
  8280                                  ;
  8281                                  ;	pop	es
  8282                                  ;	ret
  8283                                  ;
  8284                                  ;Move_res_code	endp
  8285                                  ;
  8286                                  ;	assume	ds:NOTHING		; to match ending assume above
  8287                                  ;
  8288                                  ;endif	;ROMDOS
  8289                                  
  8290                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8291                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8292                                  
  8293                                  	; MSDOS 6.0
  8294                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8295                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8296                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8297                                  ; the contents of this temporary environment are copied to it. This routine
  8298                                  ; will not be called in case a valid environment is passed to command.com
  8299                                  ;
  8300                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8301                                  ;
  8302                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8303                                  ;
  8304                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8305                                  
  8306                                  alloc_env:	;proc near
  8307                                  	;assume ds:nothing
  8308                                  	
  8309 00001B82 1E                              push    ds
  8310 00001B83 06                      	push	es
  8311 00001B84 56                      	push	si
  8312 00001B85 57                      	push	di
  8313                                  
  8314                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8315                                  %if 0
  8316                                          push    ss
  8317                                          pop     ds
  8318                                  	;assume ds:RESGROUP
  8319                                  
  8320                                          mov     ax,[EnvirSeg]
  8321                                  
  8322                                          cmp	byte [AllocedEnv],0
  8323                                          je	short alloc_cont
  8324                                          jmp     alloc_done
  8325                                  
  8326                                  alloc_cont:
  8327                                          sub     di,di                           ; default start
  8328                                          ;mov	bx,SIZE Environment             ; default size needed
  8329                                  	; 29/01/2023
  8330                                  	mov	bx,ENVIRONSIZ
  8331                                  
  8332                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8333                                          je	short alloc_seg			; no
  8334                                  
  8335                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8336                                  ;   Record their respective locations and do not add the default vars.
  8337                                  
  8338                                  	or      ax,ax
  8339                                  	jz	short alloc_new			; no previous environment
  8340                                  
  8341                                          mov     es,ax
  8342                                  	;assume es:nothing
  8343                                  
  8344                                  _find_path:
  8345                                          mov     al,0
  8346                                          sub     di,di
  8347                                  comp_path:
  8348                                          scasb                                   ; end of env?
  8349                                  	je	short _find_prompt		; yes
  8350                                          dec     di
  8351                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8352                                          ;mov	si,offset RESGROUP:PathString
  8353                                  	mov	si,PathString	
  8354                                          repe    cmpsb
  8355                                          je	short got_path
  8356                                          mov	cx,256
  8357                                          repne   scasb                           ; find next NULL
  8358                                          jmp     short comp_path
  8359                                  
  8360                                  got_path:
  8361                                          mov	byte [PathString],0		; don't add it
  8362                                  
  8363                                  _find_prompt:
  8364                                          sub     di,di
  8365                                  comp_prompt:
  8366                                  	scasb                                   ; end of env?
  8367                                  	je	short find_comspec		; yes
  8368                                  	dec     di
  8369                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8370                                  	;mov	si,offset RESGROUP:PrmptString
  8371                                  	mov	si,PrmptString
  8372                                          repe    cmpsb
  8373                                          je	short got_prompt
  8374                                          mov     cx,256
  8375                                          repne   scasb                           ; find next NULL
  8376                                          jmp	short comp_prompt
  8377                                  
  8378                                  got_prompt:
  8379                                  	mov	byte [PrmptString],0		; don't add it
  8380                                  
  8381                                  find_comspec:
  8382                                          sub     di,di
  8383                                  comp_comspec:
  8384                                          scasb                                   ; end of env?
  8385                                          je	short got_envend		; yes
  8386                                          dec     di
  8387                                          mov	cx,ComspStrLen ; mov cx,8
  8388                                  	;mov	si,offset RESGROUP:ComspString
  8389                                  	mov	si,ComspString
  8390                                          repe    cmpsb
  8391                                          je	short got_comspec
  8392                                          mov     cx,256
  8393                                          repne   scasb                           ; find next NULL
  8394                                          jmp	short comp_comspec
  8395                                  
  8396                                  got_comspec:
  8397                                          mov     [ComspOffset],di
  8398                                  
  8399                                  find_envend:
  8400                                          sub     di,di
  8401                                          mov     cx,ENVBIG                       ; max env size
  8402                                  comp_envend:
  8403                                          dec     cx                              ;
  8404                                          scasb                                   ; end of env?
  8405                                          je	short got_envend		; yes
  8406                                          repne   scasb
  8407                                          jmp	short comp_envend
  8408                                  
  8409                                  got_envend:
  8410                                          dec     di
  8411                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8412                                  
  8413                                  ;   We want to fall through to alloc_new and set up default
  8414                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8415                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8416                                  
  8417                                          push    ds
  8418                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8419                                          mov	ds,[PDB.PARENT_PID]
  8420                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8421                                  	cmp	word [PDB.PARENT_PID],0
  8422                                  	pop     ds
  8423                                          jne	short alloc_seg			; no, we're not the first process
  8424                                                                                  ; so don't muck with the env.
  8425                                  alloc_new:
  8426                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8427                                  
  8428                                  alloc_seg:
  8429                                  
  8430                                  ; Allocate default environment size
  8431                                  
  8432                                          mov     cx,bx                           ; save byte-granular size in CX
  8433                                          add     bx,15
  8434                                          shr     bx,1
  8435                                          shr     bx,1
  8436                                          shr     bx,1
  8437                                          shr     bx,1                            ; BX = # paras
  8438                                  	mov	ah,ALLOC
  8439                                  	int	21h
  8440                                          jnc	short init_ok
  8441                                          jmp     init_nomem                      ; insufficient memory, error
  8442                                  
  8443                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8444                                  ; the new buffer
  8445                                  
  8446                                  init_ok:
  8447                                  	mov	es,ax
  8448                                  	;assume	es:nothing                      ; es = temp env segment
  8449                                  
  8450                                  	or      di,di
  8451                                          jz	short copy_path
  8452                                  
  8453                                          push    cx
  8454                                          push    ds
  8455                                          mov     ds,[EnvirSeg]
  8456                                          ;assume ds:nothing
  8457                                          sub     si,si
  8458                                          mov     cx,di
  8459                                          sub     di,di
  8460                                          rep     movsb
  8461                                          pop     ds
  8462                                          ;assume ds:RESGROUP
  8463                                          pop     cx
  8464                                          sub     cx,di
  8465                                  
  8466                                  copy_path:
  8467                                  
  8468                                  ; First clear out (the rest of) the buffer
  8469                                  
  8470                                          push    di
  8471                                          sub     ax,ax
  8472                                          rep     stosb
  8473                                          pop     di
  8474                                  
  8475                                  ; Initialize the path string (PATH=) first
  8476                                  
  8477                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8478                                  	mov	si,PathString
  8479                                          cmp     byte [si],al			; add it?
  8480                                          je	short init_prompt		; no
  8481                                  	;;mov	cx,PathStrLen+1                 ;
  8482                                  	;mov	cx,6 ; db "PATH=",0
  8483                                          ; 14/08/2024
  8484                                  	mov	cl,6
  8485                                          rep     movsb                           ;
  8486                                          cmp     [AllocedEnv],al			; virgin env?
  8487                                          je	short init_prompt		; no
  8488                                  
  8489                                  ; Establish a more reasonable default for the PATH
  8490                                  
  8491                                  	;mov	ah,GET_DEFAULT_DRIVE
  8492                                  	mov	ah,19h
  8493                                  	int	21h
  8494                                          add     al,'A'                          ; convert to letter
  8495                                          mov     [DefPathString],al              ;
  8496                                          mov     [DefPath2String],al             ; now our default paths are complete
  8497                                  
  8498                                          mov     dl,0                            ; get dir for default drive
  8499                                          push    ds                              ;
  8500                                          push    es                              ;
  8501                                          pop     ds                              ;
  8502                                          mov     byte [di],'\'			;
  8503                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8504                                  	;mov	ah,Current_Dir                  ;
  8505                                          mov	ah,47h
  8506                                  	int     21h                             ;
  8507                                          pop     ds                              ;
  8508                                  
  8509                                  	;;mov	cx,DefPathStrLen+1              ;
  8510                                  	;mov	cx,9 ; db "C:\MSDOS",0
  8511                                  	; 14/08/2024 ; ch = 0
  8512                                  	mov	cl,9
  8513                                  
  8514                                  	;mov	dx,offset RESGROUP:DefPathString
  8515                                  	mov	dx,DefPathString 
  8516                                  	mov	si,dx                           ;
  8517                                          ;mov	ah,CHDir                        ;
  8518                                          mov	ah,3Bh
  8519                                  	int     21h                             ;
  8520                                          jnc	short init_setpath		; DefPathString exists!
  8521                                  
  8522                                  	;;mov	cx,DefPath2StrLen+1		;
  8523                                  	;mov	cx,7 ; db "C:\DOS",0
  8524                                  	; 14/08/2024 ; ch = 0
  8525                                  	mov	cl,7
  8526                                  
  8527                                  	;mov	dx,offset RESGROUP:DefPath2String
  8528                                  	mov	dx,DefPath2String
  8529                                          mov     si,dx                           ;
  8530                                          ;mov	ah,CHDir                        ;
  8531                                          mov	ah,3Bh
  8532                                          int     21h                             ;
  8533                                          jc	short init_prompt		; DefPath2String doesn't exist
  8534                                  
  8535                                  init_setpath:
  8536                                          mov     dx,di                           ; success
  8537                                          push    ds                              ; so restore prev dir
  8538                                          push    es                              ;
  8539                                          pop     ds                              ; DS:DX -> prev dir
  8540                                          ;mov	ah,CHDir                        ;
  8541                                          mov	ah,3Bh
  8542                                          int     21h                             ;
  8543                                          pop     ds                              ;
  8544                                  
  8545                                          dec     di                              ; then copy in DefPathString
  8546                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8547                                  
  8548                                  ; Initialize the default prompt
  8549                                  
  8550                                  init_prompt:
  8551                                          push    di                              ;
  8552                                          sub     ax,ax                           ;
  8553                                  	;mov	cx,64				; insure any data read in
  8554                                  	; 14/08/2024
  8555                                  	mov	cl,64  ; ch = 0
  8556                                          rep     stosb                           ; from Current_Dir is zapped
  8557                                          pop     di                              ;
  8558                                  
  8559                                  	cmp	[AllocedEnv],al			; virgin env?
  8560                                          je	short init_comspec		; no
  8561                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8562                                          mov	si,PrmptString
  8563                                  	cmp     [si],al				; add it?
  8564                                          je      short init_comspec		; no
  8565                                  	;mov	cx,PrmptStrLen+1                ;
  8566                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8567                                  	rep     movsb                           ;
  8568                                  
  8569                                  ; Initialize the Comspec string
  8570                                  
  8571                                  init_comspec:
  8572                                          cmp	[ComspOffset],ax		; add it?
  8573                                          jne	short init_done			; no
  8574                                          lea     ax,[di+ComspStrLen]             ;
  8575                                          mov	[ComspOffset],ax		;
  8576                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8577                                          mov	si,ComspString
  8578                                  	;mov	cx,ComspStrLen2+1               ;
  8579                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8580                                  	rep     movsb                           ;
  8581                                  
  8582                                  init_done:
  8583                                          mov     ax,es                           ; return env seg in ax
  8584                                          mov     [EnvirSeg],ax			; save env seg
  8585                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8586                                  %endif
  8587                                  
  8588                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8589                                  %if 1
  8590                                  	;mov	bx,10
  8591 00001B86 BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8592 00001B89 B448                    	mov	ah,48h
  8593 00001B8B CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8594                                  			; BX = number of 16-byte paragraphs desired
  8595 00001B8D 722C                    	jc	short init_nomem
  8596                                  
  8597                                  init_ok:
  8598 00001B8F 8EC0                    	mov	es,ax
  8599                                  	;assume	es:nothing                      ; es = temp env segment
  8600                                  
  8601 00001B91 31FF                    	xor	di,di
  8602 00001B93 89F8                    	mov	ax,di
  8603                                  	;mov	cx,160
  8604 00001B95 B9A000                  	mov	cx,ENVIRONSIZ
  8605 00001B98 F3AA                            rep	stosb
  8606                                  
  8607                                  init_pathstr:
  8608                                  
  8609                                  ; Initialize the path string (PATH=) first
  8610                                  
  8611 00001B9A 16                      	push	ss
  8612 00001B9B 1F                      	pop	ds
  8613                                  
  8614                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8615 00001B9C BE[531C]                	mov	si,PathString
  8616 00001B9F BF0000                  	mov	di,0
  8617                                  init_cp_pathstr:
  8618 00001BA2 AC                      	lodsb
  8619 00001BA3 AA                      	stosb
  8620 00001BA4 08C0                    	or	al,al
  8621 00001BA6 75FA                    	jnz	short init_cp_pathstr
  8622                                  
  8623                                  ; Initialize the Comspec string
  8624                                  
  8625                                  init_comspec:
  8626                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8627 00001BA8 BE[591C]                        mov	si,ComspString
  8628                                  	; 05/05/2023
  8629 00001BAB BF0600                  	mov	di,6
  8630                                  init_cp_compstr:
  8631 00001BAE AC                      	lodsb
  8632 00001BAF AA                      	stosb
  8633 00001BB0 08C0                    	or	al,al
  8634 00001BB2 75FA                    	jnz	short init_cp_compstr
  8635                                  
  8636                                  init_done:
  8637 00001BB4 8CC0                            mov     ax,es                           ; return env seg in ax
  8638                                          ;mov	[EnvirSeg],ax			; save env seg
  8639                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8640                                  %endif	
  8641                                  
  8642                                  	; 29/01/2023
  8643                                  alloc_done:
  8644 00001BB6 5F                      	pop	di
  8645 00001BB7 5E                      	pop	si
  8646 00001BB8 07                      	pop	es
  8647 00001BB9 1F                              pop     ds
  8648                                  	;assume	ds:nothing
  8649 00001BBA C3                      	retn
  8650                                  
  8651                                  	; 29/01/2023
  8652                                  init_nomem:
  8653                                  
  8654                                  ;We call the error routine from here. This routine never returns. It either
  8655                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8656                                  ;the system ( if it is the first COMMAND.COM ).
  8657                                  
  8658 00001BBB E80000                  	call	Alloc_error
  8659                                  
  8660                                  ;Alloc_env	endp
  8661                                  
  8662                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8663                                  ; check if this is a permanent or secondary command.com and take the 
  8664                                  ; appropriate action.
  8665                                  ;
  8666                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8667                                  ;
  8668                                  ;	EXIT:	None - does not return
  8669                                  ;
  8670                                  ;	REGISTERS AFFECTED: Does not matter
  8671                                  ;
  8672                                  
  8673                                  ;public Alloc_error
  8674                                  Alloc_error:	;proc	near
  8675                                  
  8676                                  	;jmp	RESGROUP:BadMemErr
  8677                                  	; 29/01/2023
  8678 00001BBE E946F1                  	jmp	BadMemErr	
  8679                                  	
  8680                                  ;Alloc_error	endp
  8681                                  
  8682                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8683                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8684                                  
  8685                                  	; MSDOS 6.0
  8686                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8687                                  ; the stub table of the various entry points in the resident code segment.
  8688                                  ; Some of them are interrupt entry points and some of them are entries from
  8689                                  ; the transient to the resident code segment.
  8690                                  ;
  8691                                  ;	ENTRY:	ds = RESGROUP
  8692                                  ;		es:di = segment:offset of final location of resident code
  8693                                  ;
  8694                                  ;	EXIT:	All segments and offsets patched into the stub table
  8695                                  ;
  8696                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8697                                  
  8698                                  patch_stub:	;proc near
  8699                                  	;assume	ds:RESGROUP
  8700                                  	
  8701 00001BC1 06                      	push	es
  8702                                  
  8703 00001BC2 8CC3                    	mov	bx,es			;bx = resident code segment
  8704 00001BC4 89FA                    	mov	dx,di
  8705                                  	;mov	di,offset DATARES:Int2f_Entry
  8706 00001BC6 BF[0400]                	mov	di,Int2f_Entry
  8707                                  	;mov	si,offset RESGROUP:Reloc_Table
  8708 00001BC9 BE[A620]                	mov	si,Reloc_Table
  8709 00001BCC 1E                      	push	ds
  8710 00001BCD 07                      	pop	es			;es = RESGROUP = DATARES
  8711                                  
  8712                                  ;bx:dx = segment:offset of resident code segment
  8713                                  ;es:di = entry point table in stub
  8714                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8715                                  
  8716                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8717 00001BCE B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8718                                  patchlp:
  8719 00001BD1 AD                      	lodsw				;get current offset
  8720 00001BD2 01D0                    	add	ax,dx			;offset it by code seg location 
  8721 00001BD4 AB                      	stosw				;store offset
  8722 00001BD5 89D8                    	mov	ax,bx			
  8723 00001BD7 AB                      	stosw				;store segment 
  8724 00001BD8 E2F7                    	loop	patchlp
  8725                                  
  8726 00001BDA 07                      	pop	es
  8727 00001BDB C3                      	retn
  8728                                  
  8729                                  ;Patch_stub	endp
  8730                                  
  8731                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8732                                  
  8733                                  	; MSDOS 6.0
  8734                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8735                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8736                                  ; are temporarily needed to handle these interrupts if they occur before
  8737                                  ; the resident is relocated to its final position and all the addresses of
  8738                                  ; the handlers have been updated.
  8739                                  ;
  8740                                  ;	ENTRY:	es = PSP segment = code segment
  8741                                  ;
  8742                                  ;	EXIT:	Current segment values patched into the jump table in the
  8743                                  ;		stub.
  8744                                  ;
  8745                                  ;	REGISTERS AFFECTED: ax, cx, di
  8746                                  
  8747                                  patch_segs:	;proc near
  8748                                  
  8749                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8750 00001BDC BF[0400]                	mov	di,Int2f_Entry 
  8751 00001BDF B90400                  	mov	cx,4			;we have to patch 4 handlers
  8752 00001BE2 83C702                  	add	di,2
  8753 00001BE5 8CC0                    	mov	ax,es
  8754                                  pseglp:
  8755 00001BE7 AB                      	stosw				;store the segment value
  8756 00001BE8 83C702                  	add	di,2			;skip the next offset value
  8757 00001BEB E2FA                    	loop	pseglp
  8758                                  
  8759 00001BED C3                      	retn
  8760                                  
  8761                                  ;Patch_segs	endp
  8762                                  
  8763                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8764                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8765                                  
  8766                                  	; MSDOS 6.0
  8767                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8768                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8769                                  ; and is used by the stub when we have to jump to the resident in HMA
  8770                                  ;
  8771                                  ;	ENTRY:	ds = RESGROUP
  8772                                  ;
  8773                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8774                                  ;
  8775                                  ;	REGISTERS AFFECTED:
  8776                                  ;
  8777                                  
  8778                                  get_XMMAddr:	;proc near
  8779                                  	;assume	ds:RESGROUP
  8780                                  
  8781 00001BEE 06                      	push	es
  8782                                  
  8783                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8784 00001BEF B80043                  	mov	ax,4300h
  8785 00001BF2 CD2F                    	int	2Fh
  8786                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8787                                  		; Return: AL = 80h XMS driver installed
  8788                                  		; AL <> 80h no driver
  8789 00001BF4 3C80                    	cmp	al,80h			; Q: installed
  8790 00001BF6 750D                    	jne	short cXMMexit		; N: set error, quit
  8791                                  ;
  8792                                  ; get the XMM control functions entry point, save it, we
  8793                                  ; need to call it later.
  8794                                  ;
  8795                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8796 00001BF8 B81043                  	mov	ax,4310h
  8797 00001BFB CD2F                    	int	2Fh
  8798                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8799                                  		; Return: ES:BX -> driver entry point
  8800                                  
  8801 00001BFD 891E[3000]              	mov	[XMMCallAddr], bx
  8802 00001C01 8C06[3200]              	mov	[XMMCallAddr+2],es
  8803                                  cXMMexit:
  8804 00001C05 07                      	pop	es
  8805 00001C06 C3                      	retn				; done
  8806                                  
  8807                                  ;get_XMMAddr	endp
  8808                                  
  8809                                  ;=============================================================================
  8810                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8811                                  ;=============================================================================
  8812                                  ; 24/09/2018 - Retro DOS v3.0
  8813                                  
  8814                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8815                                  
  8816                                  ; TITLE	COMMAND Initialization messages
  8817                                  
  8818                                  ;INIT	SEGMENT PUBLIC PARA
  8819                                  
  8820                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8821                                  
  8822                                  	; 25/09/2018
  8823                                  	; (15 bytes filler)
  8824 00001C07 00                      	db 0
  8825                                  	;db "25/9/2018 ETAN"
  8826                                  	; 15/06/2023
  8827                                  	;db "15/6/2023 ETAN"
  8828                                  	; 31/07/2024
  8829 00001C08 31342F382F32303234-     	db "14/8/2024 ETAN" ; 14/08/2024
  8829 00001C11 204554414E         
  8830 00001C16 00                      	db 0
  8831                                  
  8832                                  ; 30/01/2023
  8833                                  %if 0
  8834                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8835                                  	;dw 0
  8836                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8837                                  	db 0Dh,0Ah
  8838                                  	db 0Dh,0Ah
  8839                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8840                                  	db 0Dh,0Ah
  8841                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8842                                  	db ' ',0Dh,0Ah
  8843                                  	db '                                                   ',
  8844                                  	db 0Dh,0Ah,0
  8845                                  
  8846                                  	times 43 db 20h
  8847                                  
  8848                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8849                                  BADCOMLKMES:
  8850                                  	dw _152Fh
  8851                                  
  8852                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8853                                  BADCOMACCMSG:
  8854                                  	dw _155Ah
  8855                                  
  8856                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8857                                  ACCDENERR:
  8858                                  	dw _1593h
  8859                                  
  8860                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8861                                  OUTENVMSG:
  8862                                  	dw _15A5h
  8863                                  
  8864                                  BADVERMSG:
  8865                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8866                                  
  8867                                  BADENVSIZMSG:
  8868                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8869                                  
  8870                                  HEADERPTR:
  8871                                  	dw COPYRIGHTMSG
  8872                                  %endif
  8873                                  
  8874                                  ; 30/01/2023
  8875                                  ;align 16
  8876                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8877                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8878                                  ICONDEV:
  8879 00001C17 2F4445562F                      db '/DEV/'
  8880 00001C1C 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8881                                  BADCSPFL:
  8882 00001C25 00                      	db 0
  8883                                  COMSPECT:
  8884 00001C26 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8884 00001C2F 434F4D00           
  8885 00001C33 00                      	db 0
  8886                                  AUTOBAT:
  8887 00001C34 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8887 00001C3D 45432E424154000D   
  8888                                  ;KAUTOBAT:
  8889                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8890                                  PRDATTM:
  8891 00001C45 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8892                                  INITADD:
  8893 00001C46 00000000                	dd 0
  8894                                  print_add:
  8895 00001C4A [BF4D]                  	dw Printf_Init
  8896 00001C4C 0000                    	dw 0
  8897                                  triage_add:
  8898 00001C4E [9F2C]                  	dw Triage_Init
  8899 00001C50 0000                    	dw 0
  8900                                  ;CHUCKENV:
  8901                                  AllocedEnv:
  8902 00001C52 00                      	db 0
  8903                                  
  8904                                  ; 30/01/2023 - MSDOS 3.3
  8905                                  ;COMSPOFFSET:
  8906                                  ;ECOMLOC:
  8907                                  ;	;dw 0Eh
  8908                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8909                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8910                                  ;COMSPSTRING:
  8911                                  ;	db 'COMSPEC='
  8912                                  
  8913                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8914                                  PathString:
  8915 00001C53 504154483D00            	db 'PATH=',0
  8916                                  PathStrLen equ $-PathString-1
  8917                                  ; MSDOS 6.0
  8918                                  ;DefPathString:
  8919                                  ;	db 'C:\MSDOS',0
  8920                                  ;DefPathStrLen equ  $-DefPathString-1
  8921                                  ;DefPath2String:
  8922                                  ;	db 'C:\DOS',0
  8923                                  ;DefPath2StrLen equ $-DefPath2String-1
  8924                                  ;
  8925                                  ;PrmptString:
  8926                                  ;	db 'PROMPT=$P$G',0
  8927                                  ;PrmptStrLen equ $-PrmptString-1
  8928                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8929                                  ;ComspOffset:
  8930                                  ;	dw 0
  8931                                  ComspString:
  8932 00001C59 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8932 00001C62 434F4D4D414E442E43-
  8932 00001C6B 4F4D00             
  8933                                  ComspStrLen equ 8		; length of COMSPEC=
  8934                                  ComspStrLen2 equ $-ComspString-1
  8935                                  				; length of full COMSPEC
  8936                                  	; 29/01/2023
  8937                                  ;equal_sign:
  8938                                  ;equalsign:
  8939                                  ;	db '='
  8940                                  ;letter_a:
  8941                                  ;lcasea:
  8942                                  ;	db 'a'
  8943                                  ;letter_z:
  8944                                  ;lcasez:
  8945                                  ;	db 'z'
  8946                                  	; 30/01/2023
  8947                                  ;;slash_chr:
  8948                                  ;;	db '/'
  8949                                  ;;bslash_chr:
  8950                                  ;;	db '\'
  8951                                  ;space_chr:
  8952                                  ;;space:
  8953                                  ;	db 20h
  8954                                  ;;letter_p:
  8955                                  ;;	db 'p'
  8956                                  ;;letter_d:
  8957                                  ;;	db 'd'
  8958                                  ;;letter_c:
  8959                                  ;;	db 'c'
  8960                                  	; 16/04/2023
  8961                                  ; MSDOS 5.0 & MSDOS 6.0
  8962                                  ;scswitch:
  8963                                  ;	db 'C'		; Single command
  8964                                  ;;skswitch:
  8965                                  ;	db 'K' ; MSDOS 6.0
  8966                                  ;;letter_A:
  8967                                  ;ucasea: ; 21/01/2023 
  8968                                  ;	db 'A'
  8969                                  
  8970                                  	; 30/01/2023
  8971                                  EnvSiz:
  8972 00001C6E 0000                    	dw 0		; size user wants to allocate
  8973                                  EnvMax:
  8974 00001C70 0000                    	dw 0		; maximum size allowed
  8975                                  OldEnv:
  8976 00001C72 0000                    	dw 0		; envirseg at initialization
  8977                                  UsedEnv:
  8978 00001C74 0000                    	dw 0		; amount of envirseg used
  8979                                  	; MSDOS 5.0 & MSDOS 6.0
  8980                                  PARS_MSG_OFF:
  8981 00001C76 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8982                                  PARS_MSG_SEG:
  8983 00001C78 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8984                                  
  8985                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8986                                  
  8987                                  Init_Parse:
  8988                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8989                                  init_p:
  8990 00001C7A [BB4D]                  	dw append_parse
  8991                                  initend:
  8992 00001C7C 0000                    	dw 0		; segment address of end of init
  8993                                  TrnSize:
  8994 00001C7E 0000                    	dw 0		; size of transient in paragraphs
  8995                                  
  8996                                  ; 23/07/2024 - Retro DOS v4.1 (& 4.0) COMMAND.COM
  8997                                  ;%if 0
  8998                                  resetenv:
  8999                                  	;dw 0		; set if we need to setblck env at endinit
  9000                                  	; 23/07/2024
  9001 00001C80 00                      	db 0
  9002                                  ;%endif
  9003                                  
  9004                                  ext_msg:
  9005 00001C81 00                      	db 0		; set if /MSG switch entered
  9006                                  eswitch:
  9007 00001C82 00                      	db 0		; set if /e was entered
  9008                                  dswitch:
  9009 00001C83 00                      	db 0		; set if /d was entered
  9010                                  parsemes_ptr:
  9011 00001C84 0000                    	dw 0		; word to store parse error number
  9012                                  
  9013                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9014                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  9015                                  
  9016                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  9017                                  ;  The following parse control block is used for COMMAND. This block is
  9018                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  9019                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  9020                                  ;
  9021                                  ;  Anything on the command line after the /C switch will be passed to the
  9022                                  ;  executable command, so if /C is used, it must be specified last. The
  9023                                  ;  /MSG switch can only be specified if the /P switch is specified.
  9024                                  ;
  9025                                  ;  The /? switch causes help text to be displayed. Any other options
  9026                                  ;  on the command line are ignored. Command.com will not load if /?
  9027                                  ;  is specified.
  9028                                  
  9029                                  INTERNAT_INFO:		; used for country info after parsing is completed
  9030                                  PARSE_COMMAND:
  9031 00001C86 [891C]                  	dw COMMAND_PARMS
  9032 00001C88 00                      	db 0			; no extra delimiter
  9033                                  COMMAND_PARMS:
  9034 00001C89 0002                    	db 0,2			; 1 positional parm
  9035 00001C8B [9F1C]                  	dw COMMAND_FILE
  9036 00001C8D [9F1C]                  	dw COMMAND_FILE
  9037                                          ; MSDOS 5.0
  9038 00001C8F 07                      	db 7			; 7 switches
  9039                                  	; MSDOS 6.0
  9040                                  	;db 8 			; 8 switches
  9041 00001C90 [A81C]                  	dw COMMAND_SWITCH1
  9042 00001C92 [B41C]                  	dw COMMAND_SWITCH2
  9043 00001C94 [C01C]                  	dw COMMAND_SWITCH3
  9044 00001C96 [CC1C]                  	dw COMMAND_SWITCH4
  9045 00001C98 [E51C]                  	dw COMMAND_SWITCH5
  9046 00001C9A [F11C]                  	dw COMMAND_SWITCH6
  9047 00001C9C [FF1C]                  	dw COMMAND_SWITCH7
  9048                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  9049 00001C9E 00                      	db 0			; no keywords
  9050                                  
  9051                                  COMMAND_FILE:
  9052 00001C9F 0102                    	dw 0201h		; filespec - optional
  9053 00001CA1 0100                    	dw 1			; capitalize - file table
  9054 00001CA3 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9055 00001CA5 [131D]                  	dw NO_VAL 		;
  9056 00001CA7 00                      	db 0			; no keywords
  9057                                  
  9058                                  COMMAND_SWITCH1:
  9059 00001CA8 0000                    	dw 0			; no match flags
  9060 00001CAA 0200                    	dw 2			; capitalize by char table
  9061 00001CAC [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9062 00001CAE [131D]                  	dw NO_VAL 		;
  9063 00001CB0 01                      	db 1			; 1 keyword
  9064                                  COMMAND_P_SYN:
  9065 00001CB1 2F5000                  	db '/P',0		; /P switch
  9066                                  
  9067                                  COMMAND_SWITCH2:
  9068 00001CB4 0000                    	dw 0			; no match flags
  9069 00001CB6 0200                    	dw 2			; capitalize by char table
  9070 00001CB8 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9071 00001CBA [131D]                  	dw NO_VAL 		;
  9072 00001CBC 01                      	db 1			; 1 keyword
  9073                                  COMMAND_F_SYN:
  9074 00001CBD 2F4600                  	db '/F',0		; /F switch
  9075                                  
  9076                                  COMMAND_SWITCH3:
  9077 00001CC0 0000                    	dw 0			; no match flags
  9078 00001CC2 0200                    	dw 2			; capitalize by char table
  9079 00001CC4 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9080 00001CC6 [131D]                  	dw NO_VAL 		;
  9081 00001CC8 01                      	db 1			; 1 keyword
  9082                                  COMMAND_D_SYN:
  9083 00001CC9 2F4400                  	db '/D',0		; /D switch
  9084                                  
  9085                                  COMMAND_SWITCH4:
  9086 00001CCC 0080                    	dw 8000h		; numeric value - required
  9087 00001CCE 0000                    	dw 0			; no function flags
  9088 00001CD0 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9089 00001CD2 [D81C]                  	dw COMMAND_E_VAL	; pointer to value list
  9090 00001CD4 01                      	db 1			; 1 keyword
  9091                                  COMMAND_E_SYN:
  9092 00001CD5 2F4500                  	db '/E',0		; /E switch
  9093                                  
  9094                                  COMMAND_E_VAL:
  9095 00001CD8 01                      	db 1			;
  9096 00001CD9 01                      	db 1			; 1 range
  9097 00001CDA 01                      	db 1			; returned if result
  9098                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  9099                                  	; MSDOS 5.0 COMMAND.COM
  9100                                  	; (RESGROUP:1F2Bh)
  9101 00001CDB A0000000                	dd 160	 ; ENVSML
  9102 00001CDF 00800000                	dd 32768 ; ENVBIG
  9103 00001CE3 00                      	db 0			; no numeric values
  9104 00001CE4 00                      	db 0			; no string values
  9105                                  
  9106                                  COMMAND_SWITCH5:
  9107 00001CE5 0000                    	dw 0			; no match flags
  9108 00001CE7 0200                    	dw 2			; capitalize by char table
  9109 00001CE9 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9110 00001CEB [131D]                  	dw NO_VAL 		;
  9111 00001CED 01                      	db 1			; 1 keyword
  9112                                  COMMAND_C_SYN:
  9113 00001CEE 2F4300                  	db '/C',0		; /C switch
  9114                                  
  9115                                  COMMAND_SWITCH6:
  9116 00001CF1 0000                    	dw 0			; no match flags
  9117 00001CF3 0200                    	dw 2			; capitalize by char table
  9118 00001CF5 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9119 00001CF7 [131D]                  	dw NO_VAL 		;
  9120 00001CF9 01                      	db 1			; 1 keyword
  9121                                  COMMAND_M_SYN:
  9122 00001CFA 2F4D534700              	db '/MSG',0		; /MSG switch
  9123                                  
  9124                                  COMMAND_SWITCH7:
  9125 00001CFF 0000                    	dw 0			; no match flags
  9126 00001D01 0200                    	dw 2			; capitalize by char table
  9127 00001D03 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9128 00001D05 [131D]                  	dw NO_VAL 		;
  9129 00001D07 01                      	db 1			; 1 keyword
  9130                                  COMMAND_?_SYN:
  9131 00001D08 2F3F00                  	db '/?',0 		; /? switch
  9132                                  
  9133                                  	; MSDOS 6.0
  9134                                  ;COMMAND_SWITCH8:
  9135                                  ;	dw 0			; no match flags
  9136                                  ;	dw 2			; capitalize by char table
  9137                                  ;	dw COMND1_OUTPUT	; result buffer
  9138                                  ;	dw NO_VAL 		;
  9139                                  ;	db 1			; 1 keyword
  9140                                  ;COMMAND_K_SYN:
  9141                                  ;	db '/K',0		; /K switch
  9142                                  
  9143                                  COMND1_OUTPUT:
  9144                                  COMND1_TYPE:
  9145 00001D0B 00                      	db 0			; type
  9146                                  COMND1_CODE:
  9147 00001D0C 00                      	db 0			; return value
  9148                                  COMND1_SYN:
  9149 00001D0D 0000                    	dw 0			; synonym pointer
  9150                                  COMND1_ADDR:
  9151 00001D0F 00000000                	dd 0			; numeric value / address
  9152                                  				; of string value
  9153                                  NO_VAL:
  9154 00001D13 00                      	db 0			; no values
  9155                                  num_positionals:
  9156 00001D14 0000                    	dw 0			; counter for positionals
  9157                                  old_parse_ptr:
  9158 00001D16 0000                    	dw 0			; SI position before calling parser
  9159                                  
  9160                                  	; 30/01/2023
  9161                                  ;***	INITIALIZATION MESSAGES
  9162                                  ;	-------------------------
  9163                                  ;	include	comimsg.inc	;M00
  9164                                  ;-----------------------------------------------------------------------------	
  9165                                  
  9166                                  BADVERMSG:
  9167 00001D18 17                      	db 23
  9168 00001D19 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9168 00001D22 20444F532076657273-
  9168 00001D2B 696F6E0D0A         
  9169                                  OUTENVMSG:
  9170 00001D30 1A                      	db 26
  9171 00001D31 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9171 00001D3A 7669726F6E6D656E74-
  9171 00001D43 2073706163650D0A   
  9172                                  COPYRIGHTMSG:
  9173 00001D4B 5E                      	db 94
  9174 00001D4C 0D0A                    	db 0Dh,0Ah
  9175 00001D4E 0D0A                    	db 0Dh,0Ah
  9176 00001D50 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9176 00001D59 285229204D532D444F-
  9176 00001D62 532852292056657273-
  9176 00001D6B 696F6E20352E30300D-
  9176 00001D74 0A                 
  9177 00001D75 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9177 00001D7E 20202020284329436F-
  9177 00001D87 70797269676874204D-
  9177 00001D90 6963726F736F667420-
  9177 00001D99 436F72702031393831-
  9177 00001DA2 2D313939312E0D0A   
  9178                                  BADCOMLKMES:
  9179 00001DAA 28                      	db 40
  9180 00001DAB 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9180 00001DB4 20434F4D4D414E4420-
  9180 00001DBD 736561726368206469-
  9180 00001DC6 726563746F72792062-
  9180 00001DCF 61640D0A           
  9181                                  BADCOMACCMSG:
  9182 00001DD3 36                      	db 54
  9183 00001DD4 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9183 00001DDD 20434F4D4D414E4420-
  9183 00001DE6 736561726368206469-
  9183 00001DEF 726563746F72792062-
  9183 00001DF8 616420             
  9184 00001DFB 616363657373206465-     	db 'access denied',0Dh,0Ah
  9184 00001E04 6E6965640D0A       
  9185                                  HELPMSG1:
  9186 00001E0A 3C                      	db 60
  9187 00001E0B 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9187 00001E14 6E657720696E737461-
  9187 00001E1D 6E6365206F66207468-
  9187 00001E26 65204D532D444F5320-
  9187 00001E2F 636F6D6D616E642069-
  9187 00001E38 6E7465727072657465-
  9187 00001E41 722E0D0A           
  9188 00001E45 0D0A                    	db 0Dh,0Ah
  9189                                  HELPMSG2:
  9190 00001E47 46                      	db 70
  9191 00001E48 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9191 00001E51 5B64726976653A5D70-
  9191 00001E5A 6174685D205B646576-
  9191 00001E63 6963655D205B2F453A-
  9191 00001E6C 6E6E6E6E6E5D205B2F-
  9191 00001E75 505D205B2F43207374-
  9191 00001E7E 72696E675D205B2F4D-
  9191 00001E87 53475D             
  9192 00001E8A 0D0A                    	db 0Dh,0Ah
  9193 00001E8C 0D0A                    	db 0Dh,0Ah
  9194                                  HELPMSG3:
  9195 00001E8E 48                              db 72
  9196 00001E8F 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9196 00001E98 5D7061746820202020-
  9196 00001EA1 537065636966696573-
  9196 00001EAA 207468652064697265-
  9196 00001EB3 63746F727920636F6E-
  9196 00001EBC 7461696E696E672043-
  9196 00001EC5 4F4D4D414E442E434F-
  9196 00001ECE 4D20               
  9197 00001ED0 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9198                                  HELPMSG4:
  9199 00001ED7 4D                      	db 77
  9200 00001ED8 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9200 00001EE1 202020202020202020-
  9200 00001EEA 537065636966696573-
  9200 00001EF3 207468652064657669-
  9200 00001EFC 636520746F20757365-
  9200 00001F05 20666F7220636F6D6D-
  9200 00001F0E 616E6420696E707574-
  9200 00001F17 20616E6420         
  9201 00001F1C 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9202                                  HELPMSG5:
  9203 00001F25 45                      	db 69
  9204 00001F26 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9204 00001F2F 6E2020202020202020-
  9204 00001F38 536574732074686520-
  9204 00001F41 696E697469616C2065-
  9204 00001F4A 6E7669726F6E6D656E-
  9204 00001F53 742073697A6520746F-
  9204 00001F5C 206E6E6E6E6E206279-
  9204 00001F65 7465732E           
  9205 00001F69 0D0A                    	db 0Dh,0Ah
  9206                                  HELPMSG6:
  9207 00001F6B 4D                      	db 77
  9208 00001F6C 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9208 00001F75 202020202020202020-
  9208 00001F7E 4D616B657320746865-
  9208 00001F87 206E657720636F6D6D-
  9208 00001F90 616E6420696E746572-
  9208 00001F99 707265746572207065-
  9208 00001FA2 726D616E656E7420   
  9209 00001FAA 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9209 00001FB3 6974292E0D0A       
  9210                                  HELPMSG7:
  9211 00001FB9 50                      	db 80
  9212 00001FBA 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9212 00001FC3 6E6720202020202020-
  9212 00001FCC 43617272696573206F-
  9212 00001FD5 75742074686520636F-
  9212 00001FDE 6D6D616E6420737065-
  9212 00001FE7 636966696564206279-
  9212 00001FF0 20737472696E672C20-
  9212 00001FF9 616E6420           
  9213 00001FFD 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9213 00002006 732E0D0A           
  9214                                  HELPMSG8:
  9215 0000200A 4E                      	db 78
  9216 0000200B 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9216 00002014 202020202020202020-
  9216 0000201D 537065636966696573-
  9216 00002026 207468617420616C6C-
  9216 0000202F 206572726F72206D65-
  9216 00002038 737361676573206265-
  9216 00002041 2073746F7265642069-
  9216 0000204A 6E20               
  9217 0000204C 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9217 00002055 6F750D0A           
  9218                                  HELPMSG9:
  9219 00002059 38                      	db 56
  9220 0000205A 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9220 00002063 202020202020202020-
  9220 0000206C 6E65656420746F2073-
  9220 00002075 706563696679202F50-
  9220 0000207E 207769746820746869-
  9220 00002087 73207377697463682E-
  9220 00002090 0D0A               
  9221                                  HelpMsgs:
  9222 00002092 [0A1E]                          dw HELPMSG1
  9223 00002094 [471E]                  	dw HELPMSG2
  9224 00002096 [8E1E]                  	dw HELPMSG3
  9225 00002098 [D71E]                  	dw HELPMSG4
  9226 0000209A [251F]                  	dw HELPMSG5
  9227 0000209C [6B1F]                  	dw HELPMSG6
  9228 0000209E [B91F]                  	dw HELPMSG7
  9229 000020A0 [0A20]                  	dw HELPMSG8
  9230 000020A2 [5920]                  	dw HELPMSG9
  9231                                  
  9232                                  	; 23/04/2023
  9233 000020A4 0000                    	dw 0
  9234                                  
  9235                                  ;-----------------------------------------------------------------------------
  9236                                  
  9237                                  ;SR;
  9238                                  ; This table of offsets is used by the init code to calculate the new offsets
  9239                                  ;for these labels after the resident code has been relocated
  9240                                  
  9241                                  ;Reloc_Table:
  9242                                  	;dw offset CODERES:MsgInt2fHandler
  9243                                  	;dw offset CODERES:Int_2e
  9244                                  	;dw offset CODERES:ContC
  9245                                  	;dw offset CODERES:DskErr
  9246                                  	;dw offset CODERES:Exec_Ret
  9247                                  	;dw offset CODERES:TRemCheck
  9248                                  	;dw offset CODERES:TrnLodCom1
  9249                                  	;dw offset CODERES:LodCom
  9250                                  	;dw offset CODERES:MsgRetriever
  9251                                  	;dw offset CODERES:THeadFix
  9252                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9253                                  
  9254                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9255                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9256                                  
  9257                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9258 000020A6 1707                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9259 000020A8 7301                    	dw Int_2e - RCODE_START		  ; 177h	
  9260 000020AA 3300                    	dw ContC - RCODE_START		  ; 035h
  9261 000020AC 3404                    	dw DSKERR - RCODE_START		  ; 445h
  9262 000020AE 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9263 000020B0 9702                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9264 000020B2 1104                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9265 000020B4 AA01                    	dw LodCom - RCODE_START		  ; 1AEh
  9266 000020B6 5A07                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9267 000020B8 B602                    	dw THeadFix - RCODE_START	  ; 2C2h
  9268 000020BA D307                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9269                                  
  9270                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9271                                  
  9272                                  ResJmpTable:
  9273 000020BC 00000000                	dd 0			; stores prev stub jump table addr
  9274                                  FirstCom:
  9275 000020C0 00                      	db 0			; flag set if first command.com
  9276                                  DevFlag:
  9277 000020C1 00                      	db 0
  9278                                  PathFlag:
  9279 000020C2 00                      	db 0
  9280                                  
  9281                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9282                                  	;times 13 db 0
  9283                                  
  9284                                  ; 30/01/2023
  9285                                  coderes_end equ $
  9286                                  
  9287                                  ;INIT	ENDS
  9288                                  
  9289                                  ;	END
  9290                                  
  9291                                  ;-----------------------------------------------------------------------------
  9292                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9293                                  ;-----------------------------------------------------------------------------
  9294                                  
  9295                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9296                                  	; 30/01/2023
  9297 000020C3 00                      db	0
  9298                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"
  9299 000020C4 526574726F20444F53-     db	"Retro DOS v4 COMMAND.COM by Erdogan Tan [2024]" ; 21/07/2024	
  9299 000020CD 20763420434F4D4D41-
  9299 000020D6 4E442E434F4D206279-
  9299 000020DF 204572646F67616E20-
  9299 000020E8 54616E205B32303234-
  9299 000020F1 5D                 
  9300 000020F2 00                      db	0
  9301                                  
  9302                                  ;-----------------------------------------------------------------------------
  9303                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9304                                  ;-----------------------------------------------------------------------------
  9305                                  
  9306                                  ;TAIL    SEGMENT PUBLIC PARA
  9307                                  ;        ORG     0
  9308                                  ;TRANSTART LABEL WORD
  9309                                  ;TAIL    ENDS
  9310                                  
  9311                                  ;ALIGN 16  ; 25/09/2018
  9312                                  
  9313                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9314                                  
  9315                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9316                                  numbertomod equ (numbertodiv % 16)
  9317                                  
  9318                                  %if numbertomod>0 & numbertomod<16
  9319 000020F3 00<rep Dh>              	times (16-numbertomod) db 0
  9320                                  %endif
  9321                                  
  9322                                  ; 30/01/2023
  9323                                  ;TRANSTART:
  9324                                  
  9325                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9326                                  ;	times	128 db 0	
  9327                                  
  9328                                  ;-----------------------------------------------------------------------------
  9329                                  ; SEGMENT - TRANSCODE
  9330                                  ;-----------------------------------------------------------------------------
  9331                                  
  9332                                  ;TRANGROUP: ; 21/04/2018
  9333                                  
  9334                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9335                                  ;-----------------------------------------------------------------------------
  9336                                  
  9337                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9338                                  
  9339                                  ; 21/04/2018 - Retro DOS v2.0
  9340                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9341                                  ; (these values must be changed when transcom.s source code is changed
  9342                                  ; and data offsets are changed)
  9343                                  ;
  9344                                  ; 30/04/2018
  9345                                  ; 29/04/2018
  9346                                  
  9347                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9348                                  ;COMMAND      EQU  012CH
  9349                                  ;DATINIT      EQU  2091H
  9350                                  ;HEADCALL     EQU  428FH
  9351                                  ;TRANSPACEEND EQU  4D5CH
  9352                                  ;TRANDATAEND  EQU  3F44H
  9353                                  
  9354                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9355                                  ;TRIAGE_INIT  EQU  1F15H
  9356                                  ;PRINTF_INIT  EQU  34E0H 
  9357                                  
  9358                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9359                                  
  9360                                  ;TPA	EQU  4293H
  9361                                  ;TRNLEN	EQU  04D6H
  9362                                  
  9363                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9364                                  ;COMMAND      EQU  012CH
  9365                                  ;DATINIT      EQU  206FH
  9366                                  ;HEADCALL     EQU  426FH
  9367                                  ; 09/01/2023
  9368                                  ;TRANSPACEEND EQU  4D3CH
  9369                                  ;TRANDATAEND  EQU  3F24H
  9370                                  ;TRIAGE_INIT  EQU  1EF3H
  9371                                  ;PRINTF_INIT  EQU  34BFH 
  9372                                  ;
  9373                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9374                                  
  9375                                  ;-----------------------------------------------------------------------------
  9376                                  ; ARENA.INC, MSDOS 6.0, 1991
  9377                                  ;-----------------------------------------------------------------------------
  9378                                  ; 13/10/2018 - Retro DOS 3.0
  9379                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9380                                  
  9381                                  ;BREAK <Memory arena structure>
  9382                                  
  9383                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9384                                  
  9385                                  ; arena item
  9386                                  
  9387                                  struc ARENA
  9388 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9389 00000001 ????                      .owner:	resw 1		; owner of arena item
  9390 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9391                                  endstruc
  9392                                  
  9393                                  ;-----------------------------------------------------------------------------
  9394                                  ;START OF TRANSIENT PORTION
  9395                                  ;This code is loaded at the end of memory and may be overwritten by
  9396                                  ;memory-intensive user programs.
  9397                                  ;-----------------------------------------------------------------------------
  9398                                  
  9399                                  ; 16/04/2023
  9400                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9401                                  ; 29/09/2018
  9402                                  ; 31/01/2023 
  9403                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9404                                  			; 09/01/2023
  9405                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9406                                  
  9407                                  ; 25/09/2018
  9408                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9409                                  ;
  9410                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9411                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9412                                  ;
  9413                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9414                                  ;
  9415                                  ;
  9416                                  ;COMTRANS:
  9417                                  ;
  9418                                  ; 20/10/2018 - Retro DOS v3.0	
  9419                                  ;INCBIN	"TRANCOM3.BIN"
  9420                                  ;
  9421                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9422                                  ;
  9423                                  ; 29/04/2018
  9424                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9425                                  ;
  9426                                  ;TIMES BSS_SIZE db 0
  9427                                  ;
  9428                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9429                                  
  9430                                  ;COMMANDCOMSIZE equ $ - 100h
  9431                                  
  9432                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9433                                  ; ============================================================================
  9434                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9435                                  ; ============================================================================
  9436                                  
  9437                                  ; ----------------------------------------------------------------------------
  9438                                  ; START OF TRANSIENT PORTION
  9439                                  ; ----------------------------------------------------------------------------
  9440                                  ; SEGMENT - TRANSCODE
  9441                                  ; ----------------------------------------------------------------------------
  9442                                  
  9443                                  ; 18/04/2023
  9444                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9445                                  
  9446                                  ; 18/04/2023
  9447                                  ;-----------------------------------------------------------------------------
  9448                                  ; TRANSCODE segment offset 0
  9449                                  TRANSIENTSTART:
  9450                                  
  9451                                  	; 31/01/2023
  9452 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9453                                  
  9454                                  ;============================================================================
  9455                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9456                                  ;============================================================================
  9457                                  ; 12/10/2018 - Retro DOS v3.0
  9458                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9459                                  
  9460                                  ;[ORG 100h]
  9461                                  
  9462                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9463                                  
  9464                                  ; ---------------------------------------------------------------------------
  9465                                  		
  9466                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9467                                  		; (TRANGROUP:0100h)
  9468                                  SETDRV:
  9469 00000100 B40E                    	mov	ah,0Eh
  9470                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9471 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9472                                  			; DL = new default drive number
  9473                                  			;		(0 = A, 1 = B, ..)
  9474                                  			; Return: AL = number of logical drives
  9475                                  
  9476                                  ; ---------------------------------------------------------------------------
  9477                                  
  9478                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9479                                  ; No registers (CS:IP) no flags, nothing.
  9480                                  
  9481                                  TCOMMAND:
  9482 00000104 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
  9483 00000109 B8FFFF                  	mov	ax,-1
  9484 0000010C 8706[9001]              	xchg	ax,[VerVal]
  9485 00000110 83F8FF                  	cmp	ax,-1
  9486 00000113 7404                    	je	short NOSETVER2
  9487 00000115 B42E                    	mov	ah,2Eh
  9488                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9489 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9490                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9491                                  NOSETVER2:
  9492 00000119 2EFF1E[A38A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9493 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9494 00000120 833E[8E01]FF            	cmp	word [SingleCom],-1
  9495 00000125 7505                    	jne	short COMMAND
  9496                                  _$EXITPREP:
  9497 00000127 0E                      	push	cs
  9498 00000128 1F                      	pop	ds
  9499 00000129 E91E20                  	jmp	_$EXIT		; Have finished the single command
  9500                                  
  9501                                  ; ---------------------------------------------------------------------------
  9502                                  ;
  9503                                  ; Main entry point from resident portion.
  9504                                  ;
  9505                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9506                                  ;   just beginning the processing of another command.
  9507                                  ;
  9508                                  ; ---------------------------------------------------------------------------
  9509                                  
  9510                                  ; We are not always sure of the state of the world at this time. We presume
  9511                                  ; worst case and initialize the relevant registers: segments and stack.
  9512                                  
  9513                                  COMMAND:
  9514 0000012C FC                      	cld
  9515 0000012D 8CC8                    	mov	ax,cs
  9516 0000012F FA                      	cli
  9517 00000130 8ED0                    	mov	ss,ax
  9518                                  	;mov	sp,offset TRANGROUP:STACK
  9519                                  				; 07/06/2023
  9520 00000132 BC[FE94]                	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
  9521                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9522 00000135 FB                      	sti
  9523                                  		
  9524 00000136 8EC0                    	mov	es,ax
  9525                                  		
  9526                                  	; MSDOS 6.0
  9527 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9528                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9529                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9530                                  	; 31/01/2023
  9531 0000013A E8714D                  	call	TSYSLOADMSG
  9532 0000013D C606[968D]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9533                                  
  9534                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9535                                  	;mov	ds,[ss:RESSEG]
  9536                                  	; 31/01/2023
  9537 00000142 8E1E[A58A]              	mov	ds,[RESSEG]
  9538 00000146 36C606[8188]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9539 0000014C 36C606[0489]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9540                                  
  9541                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9542                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9543                                  ; I guess not: the only circumstances in which we reload the command processor
  9544                                  ; is after a transient program execution. In this case, we let the current
  9545                                  ; directory lie where it may.
  9546                                  
  9547 00000152 09ED                    	or	bp,bp		; See if just read
  9548 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9549 00000156 36C706[8288]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9550 0000015D EB17                    	jmp	short NOSETBUF
  9551                                  TESTRDIR:
  9552 0000015F 803E[8C01]00            	cmp	byte [RestDir],0
  9553 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9554 00000166 1E                      	push	ds
  9555                                  
  9556                                  ; We have an unusual situation to handle. The user *may* have changed his
  9557                                  ; directory as a result of an internal command that got aborted. Restoring it
  9558                                  ; twice may not help us: the problem may never go away. We just attempt it
  9559                                  ; once and give up.
  9560                                  
  9561 00000167 C606[8C01]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9562                                  
  9563                                  	; Restore users directory
  9564 0000016C 0E                      	push	cs
  9565 0000016D 1F                      	pop	ds
  9566 0000016E BA[8789]                	mov	dx,USERDIR1
  9567 00000171 B43B                    	mov	ah,3Bh
  9568                                  	;mov	ah,CHDir ; 3Bh
  9569 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9570                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9571 00000175 1F                      	pop	ds
  9572                                  NOSETBUF:
  9573 00000176 803E[0102]00            	cmp	byte [PipeFiles],0
  9574 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9575 0000017D 803E[0002]00            	cmp	byte [PipeFlag],0
  9576 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9577 00000184 E8642B                  	call	PIPEDEL
  9578                                  NOPCLOSE:
  9579                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9580                                  	; 31/01/2023
  9581 00000187 C606[8401]00            	mov	byte [ExtCom],0 ; Flag internal command
  9582 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9583 0000018E 8ED8                    	mov	ds,ax
  9584 00000190 50                      	push	ax
  9585                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9586 00000191 BA[FE94]                	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
  9587                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9588 00000194 B80038                  	mov	ax,3800h
  9589                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9590 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9591                                  			; get current-country info
  9592                                  			; DS:DX	-> buffer for returned info
  9593 00000199 58                      	pop	ax
  9594 0000019A 2B06[A78A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9595 0000019E 53                      	push	bx
  9596 0000019F BB1000                  	mov	bx,16
  9597 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9598 000001A4 5B                      	pop	bx
  9599 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9600 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9601 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9602                                  SAVSIZ:
  9603                                  
  9604                                  ; AX is the number of bytes free in the buffer between the resident and the
  9605                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9606                                  
  9607 000001AC 3D0002                  	cmp	ax,512
  9608 000001AF 7603                    	jbe	short GOTSIZE
  9609                                  	;and	ax,~1FFh
  9610 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9611                                  GOTSIZE:
  9612 000001B4 A3[C48A]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9613 000001B7 8E1E[A58A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9614                                  
  9615 000001BB F606[8801]01            	test	byte [EchoFlag],1 
  9616 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9617 000001C2 E8052B                  	call	SINGLETEST
  9618 000001C5 7219                    	jb	short GETCOM
  9619 000001C7 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1
  9620 000001CC 7512                    	jnz	short GETCOM
  9621                                  				; G  Don't print prompt in FOR
  9622 000001CE F606[9401]FF            	test	byte [ForFlag],0FFh ; -1
  9623 000001D3 750B                    	jnz	short GETCOM
  9624                                  				; G  Don't print prompt if in batch
  9625 000001D5 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
  9626 000001DB 7503                    	jnz	short GETCOM
  9627 000001DD E8EF23                  	call	CRLF2
  9628                                  GETCOM:
  9629 000001E0 C606[9901]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9630 000001E5 C606[9A01]00            	mov	byte [Call_Batch_Flag],0
  9631 000001EA B419                    	mov	ah,19h
  9632                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9633 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9634 000001EE 36A2[B78A]              	mov	[ss:CURDRV],al
  9635 000001F2 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9636 000001F7 7403                    	jz	short NOPIPE
  9637 000001F9 E9BA2B                  	jmp	PIPEPROC	; Continue the pipeline
  9638                                  NOPIPE:
  9639 000001FC F606[8801]01            	test	byte [EchoFlag],1
  9640 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9641 00000203 E8C42A                  	call	SINGLETEST
  9642 00000206 7212                    	jb	short NOPDRV
  9643 00000208 F606[9401]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9644 0000020D 750B                    	jnz	short NOPDRV
  9645 0000020F F706[3401]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9646 00000215 750D                    	jnz	short TESTFORBAT
  9647 00000217 E8771B                  	call	PRINT_PROMPT	; Prompt the user
  9648                                  NOPDRV:
  9649 0000021A F606[9401]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9650 0000021F 7403                    	jz	short TESTFORBAT
  9651 00000221 E9B70B                  	jmp	FORPROC		; Continue the FOR
  9652                                  
  9653                                  TESTFORBAT:
  9654 00000224 36C606[508A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9655 0000022A C606[AF01]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9656 0000022F C606[AE01]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9657 00000234 C606[9301]00            	mov	byte [IfFlag],0	; no more ifs...
  9658 00000239 F706[3401]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9659 0000023F 7441                    	jz	short ISNOBAT
  9660                                  
  9661                                  	; 31/01/2023
  9662                                  
  9663                                  	; MSDOS 6.0
  9664                                  
  9665                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9666                                  
  9667 00000241 06                      	push	es			;AN000; save ES
  9668 00000242 1E                      	push	ds			;AN000; save DS
  9669                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9670                                  	; 05/02/2023
  9671 00000243 B80219                  	mov	ax,1902h
  9672 00000246 8E06[3401]              	mov	es,[Batch]		;AN000; get batch segment
  9673                                  	;mov	di,20h
  9674 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9675 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9676 0000024E 1F                      	pop	ds			;AN000;
  9677                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9678 0000024F BA[0489]                	mov	dx,COMBUF
  9679 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9680                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9681                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9682                                  		; final filename element uppercased
  9683                                  		; DS:DX -> buffer for results
  9684                                  	;cmp	al,0FFh
  9685 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9686 00000256 1F                      	pop	ds			;AN000; restore DS
  9687 00000257 07                      	pop	es			;AN000; restore ES
  9688 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9689                                  
  9690                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9691 0000025A 1E                      	push	ds
  9692 0000025B E81603                  	call	READBAT			; Continue BATCH
  9693 0000025E 1F                      	pop	ds
  9694 0000025F C606[9D01]00            	mov	byte [NullFlag],0	;G reset no command flag
  9695 00000264 F706[3401]FFFF          	test	word [Batch],0FFFFh
  9696 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9697 0000026C 8B1E[9B01]              	mov	bx,[Next_Batch]
  9698                                  	; 31/01/2023
  9699 00000270 09DB                    	or	bx,bx
  9700                                  	;cmp	bx,0			;G see if there is a new batch file
  9701 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9702 00000274 891E[3401]              	mov	[Batch],bx		;G get segment of next batch file
  9703 00000278 C706[9B01]0000          	mov	word [Next_Batch],0	;G reset next batch
  9704                                  JDOCOM1:
  9705 0000027E 0E                      	push	cs
  9706 0000027F 1F                      	pop	ds
  9707 00000280 EB55                    	jmp	short DOCOM1
  9708                                  ISNOBAT:
  9709 00000282 833E[8E01]00            	cmp	word [SingleCom],0
  9710 00000287 741C                    	jz	short REGCOM
  9711                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9712 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9713 0000028C 8736[8E01]              	xchg	si,[SingleCom]
  9714 00000290 BF[0689]                	mov	di,COMBUF+2
  9715 00000293 31C9                    	xor	cx,cx
  9716                                  SINGLELOOP:
  9717 00000295 AC                      	lodsb
  9718 00000296 AA                      	stosb
  9719 00000297 41                      	inc	cx
  9720 00000298 3C0D                    	cmp	al,0Dh
  9721 0000029A 75F9                    	jnz	short SINGLELOOP
  9722 0000029C 49                      	dec	cx
  9723 0000029D 0E                      	push	cs
  9724 0000029E 1F                      	pop	ds
  9725 0000029F 880E[0589]              	mov	[COMBUF+1],cl
  9726                                  
  9727                                  ; do NOT issue a trailing CRLF...
  9728                                  
  9729 000002A3 EB32                    	jmp	short DOCOM1
  9730                                  
  9731                                  	;nop
  9732                                  
  9733                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9734                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9735                                  
  9736                                  ; We have a normal command.  
  9737                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9738                                  ; sometimes they aren't. At this point, we automatically close all spool
  9739                                  ; files and turn on truncation mode.
  9740                                  
  9741                                  REGCOM:
  9742                                  	;mov	ax,(ServerCall shl 8) + 9
  9743                                  	; 31/01/2023
  9744 000002A5 B8095D                  	mov	ax,5D09h
  9745                                  	;mov	ax,(SERVERCALL<<8)+9
  9746 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9747                                  	;mov	ax,(ServerCall shl 8) + 8
  9748 000002AA B8085D                  	mov	ax,5D08h
  9749                                  	;mov	ax,(SERVERCALL<<8)+8
  9750 000002AD B201                    	mov	dl,1
  9751 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9752                                  			; DL = 00h redirected output is	combined
  9753                                  			;      01h redirected output placed in separate	jobs
  9754                                  			; start	new print job now
  9755 000002B1 0E                      	push	cs
  9756 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9757 000002B3 BA[8188]                	mov	dx,UCOMBUF
  9758                                  
  9759                                  	; MSDOS 6.0
  9760                                  ;	Try to read interactive command line via DOSKey.
  9761                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9762                                  
  9763                                  	; 31/01/2023
  9764 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9765 000002B9 CD2F                    	int	2Fh
  9766 000002BB 09C0                    	or	ax,ax
  9767 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9768                                  
  9769 000002BF B40A                    	mov	ah,0Ah
  9770                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9771 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9772                                  			; DS:DX	-> buffer
  9773                                  GOTCOM:
  9774 000002C3 8A0E[8188]              	mov	cl,[UCOMBUF]
  9775 000002C7 30ED                    	xor	ch,ch
  9776 000002C9 83C103                  	add	cx,3
  9777 000002CC BE[8188]                	mov	si,UCOMBUF
  9778 000002CF BF[0489]                	mov	di,COMBUF
  9779 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9780                                  DOCOM:
  9781 000002D4 E8F822                  	call	CRLF2
  9782                                  DOCOM1:
  9783 000002D7 E87C26                  	call	PRESCAN		; Cook the input buffer
  9784 000002DA 7406                    	jz	short NOPIPEPROC
  9785 000002DC E9562A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9786                                  
  9787                                  NULLCOMJ:
  9788 000002DF E9FA00                  	jmp	NULLCOM
  9789                                  
  9790                                  NOPIPEPROC:
  9791 000002E2 E84E2D                  	call	PARSELINE
  9792 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9793                                  BADPARSE:
  9794 000002E7 0E                      	push	cs
  9795 000002E8 1F                      	pop	ds
  9796 000002E9 BA[1F7F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9797 000002EC E8DA4A                  	call	std_eprintf
  9798 000002EF E912FE                  	jmp	TCOMMAND
  9799                                  
  9800                                  OKPARSE:
  9801                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9802                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9803                                  	; 01/02/2023
  9804 000002F2 F606[B28D]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9805 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9806                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9807 000002F9 833E[7090]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9808 000002FE 74DF                    	jz	short NULLCOMJ
  9809                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9810 00000300 833E[B58D]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9811 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9812                                  
  9813 00000307 BE[0689]                	mov	si,COMBUF+2
  9814 0000030A BF[2B8B]                	mov	di,IDLEN
  9815                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9816                                  				; Make FCB with blank scan-off
  9817                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9818 0000030D B80129                  	mov	ax,2901h
  9819 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9820                                  			; DS:SI	-> string to parse
  9821                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9822                                  			; AL = bit mask	to control parsing
  9823                                  	;mov	bx,[ARG_ARGV]
  9824 00000312 8B1E[B08D]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9825 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9826 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9827 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9828                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9829                                  	;and	dl,~20h
  9830 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9831                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9832                                  	; 31/01/2023
  9833 00000321 80EA41                  	sub	dl,'A'
  9834 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9835 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9836                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9837 00000328 8B3E[B38D]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9838 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9839 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9840 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9841                                  DRVBADJ:
  9842 00000334 E92125                  	jmp	DRVBAD
  9843                                  DRVGD:
  9844 00000337 8A05                    	mov	al,[di]
  9845 00000339 A2[C38A]                	mov	[SPECDRV],al
  9846 0000033C B020                    	mov	al,' '
  9847 0000033E B90900                  	mov	cx,9
  9848 00000341 47                      	inc	di
  9849 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9850 00000344 B008                    	mov	al,8
  9851 00000346 28C8                    	sub	al,cl
  9852 00000348 A2[2B8B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9853 0000034B BF8100                  	mov	di,81h
  9854 0000034E 56                      	push	si
  9855 0000034F BE[0689]                	mov	si,COMBUF+2	; Skip over all leading delims
  9856 00000352 E88722                  	call	scanoff
  9857                                  
  9858                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9859                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9860                                  
  9861                                  	; MSDOS 6.0
  9862                                  ;SR;
  9863                                  ; We are going to skip over the first char always. The logic is that the
  9864                                  ;command tail can never start from the first character. The code below is 
  9865                                  ;trying to figure out the command tail and copy it to the command line 
  9866                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9867                                  ;character and the user given command line is a full 128 bytes, we try to
  9868                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9869                                  ;char overwrites the code and leads to a crash on future commands.
  9870                                  
  9871 00000355 46                      	inc	si ;  MSDOS 6.0
  9872                                  DO_SKIPCOM:
  9873 00000356 AC                      	lodsb			; move command line pointer over
  9874 00000357 E88A22                  	call	DELIM		; pathname -- have to do it ourselves
  9875 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9876 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9877 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9878 00000360 3A06[A98A]              	cmp	al,[SWITCHAR]	; specified command string
  9879 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9880                                  DO_SKIPPED:
  9881 00000366 4E                      	dec	si
  9882 00000367 31C9                    	xor	cx,cx
  9883                                  COMTAIL:
  9884 00000369 AC                      	lodsb
  9885 0000036A AA                      	stosb			; Move command tail to 80h
  9886 0000036B 3C0D                    	cmp	al,0Dh
  9887 0000036D E0FA                    	loopne	COMTAIL
  9888 0000036F 4F                      	dec	di
  9889 00000370 89FD                    	mov	bp,di
  9890 00000372 F6D1                    	not	cl
  9891 00000374 880E8000                	mov	[80h],cl
  9892 00000378 5E                      	pop	si
  9893                                  ;-----
  9894                                  ; Some of these comments are sadly at odds with this brave new code.
  9895                                  ;-----
  9896                                  ; If the command has 0 parameters must check here for
  9897                                  ; any switches that might be present.
  9898                                  ; SI -> first character after the command.
  9899                                  
  9900                                  	;mov	di,arg.argv[0].argsw_word
  9901                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9902 00000379 8B3E[B78D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9903 0000037D 893E[BA8A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9904                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9905                                  				; s = argv[1];
  9906                                  	;mov	si,[ARGV1_ARGPOINTER]
  9907 00000381 8B36[BB8D]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9908 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9909 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9910 00000389 89EE                    	mov	si,bp
  9911                                  DOPARSE:
  9912 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9913                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9914                                  	; 01/02/2023
  9915 0000038E B80129                  	mov	ax,2901h
  9916                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9917 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9918                                  			; DS:SI	-> string to parse
  9919                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9920                                  			; AL = bit mask	to control parsing
  9921 00000393 A2[B88A]                	mov	[PARM1],al	; Save result of parse
  9922                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9923                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9924 00000396 8B3E[C28D]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9925 0000039A 893E[BC8A]              	mov	[ARG1S],di
  9926                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9927                                  				; s = argv[2];
  9928                                  	;mov	si,[ARGV2_ARGPOINTER]
  9929 0000039E 8B36[C68D]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9930 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9931 000003A4 7502                    	jnz	short DOPARSE2
  9932 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9933                                  DOPARSE2:			
  9934 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9935                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9936 000003AB B80129                  	mov	ax,2901h
  9937                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9938 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9939                                  			; DS:SI	-> string to parse
  9940                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9941                                  			; AL = bit mask	to control parsing
  9942 000003B0 A2[B98A]                	mov	[PARM2],al	; Save result
  9943                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9944                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9945 000003B3 8B3E[CD8D]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9946 000003B7 893E[BE8A]              	mov	[ARG2S],di
  9947                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9948                                  	;mov	di,arg.argv[0].argsw_word
  9949 000003BB 8B3E[B78D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9950 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9951                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9952                                  	;and	di,arg.argswinfo	
  9953 000003C1 233E[7290]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9954 000003C5 893E[C08A]              	mov	[ARGTS],di
  9955                                  
  9956 000003C9 A0[2B8B]                	mov	al,[IDLEN]
  9957 000003CC 8A16[C38A]              	mov	dl,[SPECDRV]
  9958 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9959 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9960 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9961 000003D6 E9D223                  	jmp	FNDCOM		; otherwise, check internal com table
  9962                                  EXTERNALJ1:
  9963 000003D9 E9D424                  	jmp	EXTERNAL
  9964                                  NULLCOM:
  9965 000003DC 8E1E[A58A]              	mov	ds,[RESSEG]
  9966 000003E0 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9967 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9968 000003E8 C606[9D01]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9969                                  	;mov	byte [NullFlag],nullcommand ; 1
  9970                                  NOSETFLAG:
  9971 000003ED 833E[8E01]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9972 000003F2 7403                    	je	short EXITJ
  9973 000003F4 E9E9FD                  	jmp	GETCOM
  9974                                  EXITJ:
  9975 000003F7 E92DFD                  	jmp	_$EXITPREP
  9976                                  
  9977                                  ;============================================================================
  9978                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9979                                  ;============================================================================
  9980                                  ; 12/10/2018 - Retro DOS v3.0
  9981                                  
  9982                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9983                                  
  9984                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9985                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9986                                  ;   there is a header that describes a block of rom program.  This header
  9987                                  ;   contains information needed to initialize a module and to provide PCDOS
  9988                                  ;   with a set of reserved names for execution.
  9989                                  ;
  9990                                  ;   This header has the following format:
  9991                                  ;
  9992                                  ;   rom_header	STRUC
  9993                                  ;	Signature1  DB	55h
  9994                                  ;	Signature2  DB	AAh
  9995                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9996                                  ;	init_jmp    DB	3 dup (?)
  9997                                  ;	name_list   name_struc <>
  9998                                  ;   rom_header	ENDS
  9999                                  ;
 10000                                  ;   name_struc	STRUC
 10001                                  ;	name_len    DB	?
 10002                                  ;	name_text   DB	? DUP (?)
 10003                                  ;	name_jmp    DB	3 DUP (?)
 10004                                  ;   name_struc	ENDS
 10005                                  ;
 10006                                  ;   The name list is a list of names that are reserved by a particular section
 10007                                  ;   of a module.  This list of names is terminated by a null name (length
 10008                                  ;   is zero).
 10009                                  ;
 10010                                  ;   Consider now, the PCDOS action when a user enters a command:
 10011                                  ;
 10012                                  ;	COMMAND.COM has control.
 10013                                  ;	o   If location FFFFEh has FDh then
 10014                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
 10015                                  ;		    by AAh, stop scan if we get above or = F0000H
 10016                                  ;	o	When we've found one, compare the name entered by the user
 10017                                  ;		    with the one found in the rom.  If we have a match, then
 10018                                  ;		    set up the environment for execution and do a long jump
 10019                                  ;		    to the near jump after the found name.
 10020                                  ;	o	If no more names in the list, then continue scanning the module
 10021                                  ;		    for more 55h followed by AAh.
 10022                                  ;	o   We get to this point only if there is no matching name in the
 10023                                  ;		rom.  We now look on disk for the command.
 10024                                  ;
 10025                                  ;   This gives us the flexibility to execute any rom cartridge without having
 10026                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10027                                  ;   want to be invisible to the DOS should not have any names in their lists
 10028                                  ;   (i.e. they have a single null name).
 10029                                  ;
 10030                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10031                                  ;   Clearly this version will be available on disk.  How does a user actually
 10032                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10033                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10034                                  ;   solution:
 10035                                  ;
 10036                                  ;   o	Keep things consistent and force the user to have his software named
 10037                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10038                                  
 10039                                  struc ROM_HEADER
 10040 00000000 ??                          .signature1: resb 1
 10041 00000001 ??                          .signature2: resb 1
 10042 00000002 ??                          .rom_length: resb 1
 10043 00000003 ??????                      .init_jmp:	 resb 3
 10044 00000006 ??                          .name_list:	 resb 1
 10045                                      .size:
 10046                                  endstruc
 10047                                  
 10048                                  struc NAME_STRUC
 10049 00000000 ??                          .name_len:	resb 1
 10050 00000001 ??                          .name_text:	resb 1
 10051 00000002 ??????                      .name_jmp:	resb 3
 10052                                      .size:	
 10053                                  endstruc
 10054                                  
 10055                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10056                                  
 10057                                  ; =============== S U B	R O U T	I N E =======================================
 10058                                  
 10059                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10060                                  
 10061                                  ; 05/02/2023
 10062                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10063                                  
 10064                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10065                                  
 10066                                  ROM_SCAN:
 10067 000003FA 06                      	push	es
 10068 000003FB 56                      	push	si
 10069 000003FC 57                      	push	di
 10070 000003FD 51                      	push	cx
 10071 000003FE 50                      	push	ax
 10072 000003FF 53                      	push	bx
 10073                                  
 10074                                  	; check for PC Jr signature in rom
 10075                                  
 10076 00000400 B800F0                  	mov	ax,0F000h
 10077 00000403 8EC0                    	mov	es,ax
 10078 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10079 0000040B 7408                    	je	short SCAN_IT
 10080                                  NO_ROM:
 10081 0000040D F8                      	clc
 10082                                  ROM_RET:
 10083 0000040E 5B                      	pop	bx
 10084 0000040F 58                      	pop	ax
 10085 00000410 59                      	pop	cx
 10086 00000411 5F                      	pop	di
 10087 00000412 5E                      	pop	si
 10088 00000413 07                      	pop	es
 10089 00000414 C3                      	retn
 10090                                  
 10091                                  	; start scanning at C000h
 10092                                  SCAN_IT:
 10093 00000415 B800C0                  	mov	ax,0C000h
 10094                                  SCAN_ONE:
 10095 00000418 8EC0                    	mov	es,ax
 10096 0000041A 31FF                    	xor	di,di
 10097                                  
 10098                                  	; check for a valid header
 10099                                  SCAN_MODULE:
 10100 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
 10101 00000421 740A                    	je	short SCAN_LIST
 10102 00000423 058000                  	add	ax,80h
 10103                                  SCAN_END:
 10104 00000426 3D00F0                  	cmp	ax,0F000h
 10105 00000429 72ED                    	jb	short SCAN_ONE
 10106 0000042B EBE0                    	jmp	short NO_ROM
 10107                                  
 10108                                  	; trundle down list of names
 10109                                  SCAN_LIST:
 10110                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10111 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10112 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
 10113 00000433 D1E3                    	shl	bx,1
 10114 00000435 D1E3                    	shl	bx,1		; number of paragraphs
 10115 00000437 83C37F                  	add	bx,7Fh
 10116 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
 10117                                  	;mov	di,6
 10118                                  	; 05/05/2023
 10119 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
 10120                                  	;nop
 10121                                  SCAN_NAME:
 10122 00000440 268A0D                  	mov	cl,[es:di]	; length of name
 10123 00000443 47                      	inc	di		; point to name
 10124 00000444 30ED                    	xor	ch,ch
 10125 00000446 09C9                    	or	cx,cx		; zero length name
 10126 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
 10127 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
 10128 0000044C EBD8                    	jmp	short SCAN_END
 10129                                  
 10130                                  	; compare a single name
 10131                                  SCAN_TEST:
 10132 0000044E 89D6                    	mov	si,dx
 10133 00000450 46                      	inc	si
 10134 00000451 F3A6                    	repe cmpsb		 ; compare name
 10135 00000453 7407                    	jz	short SCAN_FOUND ; success!
 10136                                  SCAN_NEXT:
 10137 00000455 01CF                    	add	di,cx		; failure, next name piece
 10138 00000457 83C703                  	add	di,3
 10139 0000045A EBE4                    	jmp	short SCAN_NAME
 10140                                  
 10141                                  	; found a name. save entry location
 10142                                  SCAN_FOUND:	
 10143 0000045C 803C3F                  	cmp	byte [si],'?'
 10144 0000045F 7405                    	je	short SCAN_SAVE
 10145 00000461 803C20                  	cmp	byte [si],' '
 10146 00000464 75EF                    	jne	short SCAN_NEXT
 10147                                  SCAN_SAVE:
 10148 00000466 2E8C06[268C]            	mov	[cs:ROM_CS],es
 10149 0000046B 2E893E[248C]            	mov	[cs:ROM_IP],di
 10150 00000470 F9                      	stc
 10151 00000471 EB9B                    	jmp	short ROM_RET
 10152                                  
 10153                                  ; ---------------------------------------------------------------------------
 10154                                  
 10155                                  ; execute a rom-placed body of code. allocate largest block
 10156                                  
 10157                                  ROM_EXEC:
 10158 00000473 BBFFFF                  	mov	bx,0FFFFh
 10159                                  	; 05/02/2023
 10160 00000476 B448                    	mov	ah,48h
 10161                                  	;mov	ah,ALLOC ; 48h
 10162 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10163                                  			; BX = number of 16-byte paragraphs desired
 10164 0000047A B448                    	mov	ah,48h
 10165                                  	;mov	ah,ALLOC ; 48h
 10166 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10167                                  			; BX = number of 16-byte paragraphs desired
 10168 0000047E 53                      	push	bx
 10169 0000047F 50                      	push	ax
 10170                                  
 10171                                  	; set terminate addresses
 10172                                  
 10173 00000480 B82225                  	mov	ax,2522h
 10174                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10175                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10176 00000483 1E                      	push	ds
 10177 00000484 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 10178                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10179                                  	;mov	dx,131h ; MSDOS 3.3
 10180                                  	; 05/02/2023
 10181                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10182 00000489 BA[290C]                	mov	dx,Exec_Wait
 10183 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10184                                  			; AL = interrupt number
 10185                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10186 0000048E 8CDA                    	mov	dx,ds
 10187 00000490 8EC2                    	mov	es,dx
 10188 00000492 1F                      	pop	ds
 10189                                  		
 10190                                  	; and create program header and dup all jfn's
 10191                                  
 10192 00000493 5A                      	pop	dx
 10193 00000494 B455                    	mov	ah,55h
 10194                                  	;mov	ah,DUP_PDB ; 55h
 10195 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10196                                  			; DX = segment number at which to set up PSP
 10197                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10198                                  		
 10199                                  	; set up dma address
 10200                                  
 10201 00000498 8EDA                    	mov	ds,dx
 10202 0000049A BA8000                  	mov	dx,80h
 10203 0000049D B41A                    	mov	ah,1Ah
 10204                                  	;mov	ah,Set_DMA ; 1Ah
 10205 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10206                                  			; DS:DX	-> disk	transfer buffer
 10207                                  
 10208                                  	; copy in environment info
 10209                                  
 10210 000004A1 26A1[2703]              	mov	ax,[es:EnvirSeg]
 10211                                  	;mov	[2Ch],ax
 10212 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10213                                  
 10214                                  	; set up correct size of block
 10215                                  
 10216 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10217 000004A9 8CDA                    	mov	dx,ds
 10218 000004AB 01DA                    	add	dx,bx
 10219                                  	;mov	[2],dx
 10220 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10221                                  
 10222                                  	; change ownership of block
 10223                                  
 10224 000004B1 8CDA                    	mov	dx,ds
 10225 000004B3 4A                      	dec	dx
 10226 000004B4 8EDA                    	mov	ds,dx
 10227 000004B6 42                      	inc	dx	
 10228                                  	;mov	[1],dx
 10229 000004B7 89160100                	mov	[ARENA.owner],dx
 10230 000004BB 8EDA                    	mov	ds,dx
 10231                                  
 10232                                  	; set up correct stack
 10233                                  
 10234 000004BD 81FB0010                	cmp	bx,1000h
 10235 000004C1 7202                    	jb	short GOT_STACK
 10236 000004C3 31DB                    	xor	bx,bx
 10237                                  GOT_STACK:
 10238 000004C5 B104                    	mov	cl,4
 10239 000004C7 D3E3                    	shl	bx,cl
 10240 000004C9 8CDA                    	mov	dx,ds
 10241 000004CB 8ED2                    	mov	ss,dx
 10242 000004CD 89DC                    	mov	sp,bx
 10243 000004CF 31C0                    	xor	ax,ax
 10244 000004D1 50                      	push	ax
 10245                                  
 10246                                  	; set up initial registers and go to the guy
 10247                                  
 10248 000004D2 F7D0                    	not	ax
 10249 000004D4 2EFF36[268C]            	push	word [cs:ROM_CS]
 10250 000004D9 2EFF36[248C]            	push	word [cs:ROM_IP]
 10251 000004DE 8EC2                    	mov	es,dx
 10252 000004E0 CB                      	retf	; far return
 10253                                  
 10254                                  ;============================================================================
 10255                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10256                                  ;============================================================================
 10257                                  ; 12/10/2018 - Retro DOS v3.0
 10258                                  
 10259                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10260                                  
 10261                                  ; =============== S U B	R O U T	I N E =======================================
 10262                                  
 10263                                  ;Break	<PromptBat - Open or wait for batch file>
 10264                                  
 10265                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10266                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10267                                  
 10268                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10269                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10270                                  ; file. Leave segment registers alone.
 10271                                  
 10272                                  PROMPTBAT:
 10273 000004E1 E84808                  	call	BATOPEN
 10274 000004E4 7201                    	jc	short PROMPTBAT1
 10275 000004E6 C3                      	retn
 10276                                  PROMPTBAT1:
 10277                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10278                                  	; MSDOS 6.0 COMMAND.COM
 10279 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10280 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10281 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10282 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10283                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10284 000004F1 E83500                  	call	output_batch_name
 10285 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10286                                  
 10287                                  	; 05/02/2023
 10288                                  	; MSDOS 3.3 COMMAND.COM
 10289                                  	;cmp	dx,ACCDENPTR
 10290                                  	;jz	short BATDIE
 10291                                  
 10292                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10293                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10294 000004F6 2EFF1E[AF8A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10295 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10296                                  
 10297                                  ; The media is not changeable. Turn everything off.
 10298                                  
 10299 000004FD E83D0B                  	call	FOROFF
 10300 00000500 E8632A                  	call	PipeOff
 10301 00000503 A2[9301]                	mov	[IfFlag],al	; No If in progress.	
 10302 00000506 BA[197F]                	mov	dx,BADBAT_PTR
 10303                                  BATDIE:
 10304 00000509 E8F003                  	call	BATCHOFF
 10305 0000050C 0E                      	push	cs
 10306 0000050D 1F                      	pop	ds
 10307                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10308                                  	; 05/02/2023
 10309 0000050E E8B848                  	call	std_eprintf	; MSDOS 6.0
 10310                                  	;call	STD_PRINTF	; MSDOS 3.3
 10311                                  
 10312                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10313                                  
 10314 00000511 E9F0FB                  	jmp	TCOMMAND
 10315                                  
 10316                                  ; Ask the user to reinsert the batch file
 10317                                  
 10318                                  ASKFORBAT:
 10319 00000514 1E                      	push	ds
 10320 00000515 0E                      	push	cs
 10321 00000516 1F                      	pop	ds
 10322                                  
 10323                                  	; MSDOS 6.0
 10324                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10325 00000517 BA[1C7F]                	mov	dx,NEEDBAT_PTR
 10326                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10327                                  	; 05/02/2023
 10328 0000051A E8AC48                  	call	std_eprintf
 10329                                  	;mov	dx,offset trangroup:pausemes_ptr
 10330 0000051D BA[8E7F]                	mov	dx,PAUSEMES_PTR
 10331                                  	;invoke std_eprintf		;AN000; get second part of message
 10332 00000520 E8A648                  	call	std_eprintf
 10333                                  					;AN000; print it to stderr
 10334                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10335                                  	;call	STD_EPRINTF
 10336 00000523 E82E00                  	call	GETKEYSTROKE
 10337 00000526 1F                      	pop	ds
 10338 00000527 EBB8                    	jmp	short PROMPTBAT
 10339                                  
 10340                                  
 10341                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10342                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10343                                  
 10344                                  	; MSDOS 6.0
 10345                                  ;****************************************************************
 10346                                  ;*
 10347                                  ;* ROUTINE:	Output_batch_name
 10348                                  ;*
 10349                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10350                                  ;*
 10351                                  ;* INPUT:	DX - extended error number
 10352                                  ;*
 10353                                  ;* OUTPUT:	Ready to call print routine
 10354                                  ;*
 10355                                  ;****************************************************************
 10356                                  ;
 10357                                  ;public	output_batch_name		;AN022;
 10358                                  
 10359                                  output_batch_name:	;proc near	;AN022;
 10360                                  
 10361 00000529 1E                      	push	ds			;AN022; save resident segment
 10362 0000052A 8E1E[3401]              	mov	ds,[Batch]		;AN022; get batch file segment
 10363                                  	;assume	DS:nothing		;AN022;
 10364                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10365                                  	; 05/02/2023
 10366                                  	;mov	si,20h
 10367                                  	; 24/04/2023
 10368 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10369                                  	;invoke	dstrlen 		;AN022; get length of string
 10370 00000531 E83627                  	call	dstrlen
 10371                                  	;mov	di,offset Trangroup:bwdbuf
 10372                                  					;AN022; target for batch name
 10373 00000534 BF[AA8B]                	mov	di,BWDBUF
 10374 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10375                                  
 10376 00000539 0E                      	push	cs			;AN022; get local segment
 10377 0000053A 1F                      	pop	ds			;AN022;
 10378                                  	;assume	DS:trangroup		;AN022;
 10379                                  	; 05/02/2023
 10380 0000053B 8916[FC7E]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10381                                  	;mov	byte [msg_disp_class],1
 10382 0000053F C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 10383                                  					;AN022; set up extended error msg class
 10384                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10385 00000544 BA[FC7E]                	mov	dx,extend_buf_ptr	
 10386                                  					;AN022; get extended message pointer
 10387                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10388 00000547 C706[118C][AA8B]        	mov	word [string_ptr_2],BWDBUF	
 10389                                  					;AN022; point to substitution
 10390                                  	;mov	byte [extend_buf_sub],1
 10391 0000054D C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 10392                                  					;AN022; set up for one subst
 10393 00000552 1F                      	pop	ds			;AN022; restore data segment
 10394 00000553 C3                      	retn				;AN022; return
 10395                                  
 10396                                  ;output_batch_name    endp		;AN022;
 10397                                  
 10398                                  
 10399                                  ; =============== S U B	R O U T	I N E =======================================
 10400                                  
 10401                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10402                                  
 10403                                  ; Read the next keystroke. Since there may be several characters in the queue
 10404                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10405                                  ; AFTER waiting.
 10406                                  
 10407                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10408                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10409                                  
 10410                                  GETKEYSTROKE:
 10411                                  	; 05/02/2023
 10412                                  	; MSDOS 3.3
 10413                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10414                                  	;;mov	ax,0C08h
 10415                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10416                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10417                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10418                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10419                                  	;;mov	ax,0C00h
 10420                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10421                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10422                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10423                                  	;retn
 10424                                  
 10425                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10426                                  	; MSDOS 6.0
 10427 00000554 52                      	push	dx			;AN000;  3/3/KK
 10428                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10429                                  					;AN000;  3/3/KK
 10430 00000555 B80263                  	mov	ax,6302h
 10431 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10432                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10433                                  	
 10434 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10435                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10436                                  					;AN000;  3/3/KK
 10437 0000055B B80163                  	mov	ax,6301h
 10438 0000055E B201                    	mov	dl,1
 10439                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10440 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10441                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10442                                  		; DL = new mode
 10443                                  		; 00h return only full characters on DOS keyboard input functions
 10444                                  		; 01h return partially-formed characters also
 10445                                  	
 10446                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10447 00000562 B8080C                  	mov	ax,0C08h
 10448 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10449                                  		; DOS - CLEAR KEYBOARD BUFFER
 10450                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10451                                  
 10452                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10453 00000567 B8000C                  	mov	ax,0C00h
 10454 0000056A CD21                    	int	21h
 10455                                  		; DOS - CLEAR KEYBOARD BUFFER
 10456                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10457                                  
 10458                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10459                                  					;AN000;  3/3/KK
 10460 0000056C B80163                  	mov	ax,6301h
 10461 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10462 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10463 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10464                                  	
 10465 00000573 C3                      	retn
 10466                                  
 10467                                  ; =============== S U B	R O U T	I N E =======================================
 10468                                  
 10469                                  ; Break	<ReadBat - read 1 line from batch file>
 10470                                  
 10471                                  ; ReadBat - read a single line from the batch file. 
 10472                                  ; Perform all substitutions as appropriate.
 10473                                  
 10474                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10475                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10476                                  
 10477                                  READBAT:
 10478                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10479                                  		
 10480                                  	;mov	byte [Suppress],1
 10481                                  				; initialize line suppress status
 10482 00000574 C606[8901]01            	mov	byte [Suppress],YES_ECHO
 10483 00000579 F606[7E01]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10484 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10485 00000580 C606[7D01]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10486                                  
 10487                                  	; MSDOS 6.0
 10488                                  
 10489                                  ;M037; Start of changes
 10490                                  ; We check here if we have set the flag indicating that the batchfile is at
 10491                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10492                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10493                                  ;batch file gets closed etc. and then return as if everything is done.
 10494                                  
 10495                                  	; 05/02/2023
 10496 00000585 1E                      	push	ds
 10497 00000586 8E1E[3401]              	mov	ds,[Batch]
 10498                                  	;cmp	byte [2],0
 10499 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10500                                  				; are we at EOF in batchfile
 10501 0000058F 1F                      	pop	ds
 10502 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10503                                  	;invoke	GetBatByt	; frees up batchseg
 10504 00000592 E8D303                  	call	GETBATBYT
 10505 00000595 26A2[0689]              	mov	[es:COMBUF+2],al
 10506                                  				; stuff CR into command buffer
 10507                                  				; as a dummy command
 10508                                  	;;invoke CrLf2		; print a CR-LF
 10509                                  	;call	CRLF2
 10510                                  	;;return		; done batch processing
 10511                                  	;retn
 10512                                  	; 24/04/2023
 10513 00000599 E93320                  	jmp	CRLF2
 10514                                  
 10515                                  ;M037; End of changes
 10516                                  		
 10517                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10518                                  CONTBAT:
 10519 0000059C E842FF                  	call	PROMPTBAT
 10520                                  
 10521                                  TRYING_TO_ABORT:
 10522 0000059F BF[0689]                	mov	di,COMBUF+2
 10523                                  
 10524                                  ; Save position and try to scan for first non delimiter.
 10525                                  
 10526                                  TESTNOP:
 10527 000005A2 8CD8                    	mov	ax,ds
 10528 000005A4 8E1E[3401]              	mov	ds,[Batch]
 10529 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10530 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10531                                  				; save current location.
 10532 000005B0 8ED8                    	mov	ds,ax
 10533 000005B2 E84B06                  	call	SKIPDELIM	; skip to first non-delim
 10534                                  
 10535                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10536                                  ; beginning and read the line.
 10537                                  
 10538 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10539 000005B7 59                      	pop	cx
 10540 000005B8 5A                      	pop	dx		; restore position in bat file
 10541 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10542 000005BB F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10543 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10544                                  
 10545                                  	;cmp	al,'@'
 10546 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10547 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10548                                  	;mov	byte [Suppress],0
 10549 000005C7 C606[8901]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10550 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10551                                  	;nop
 10552                                  SET_BAT_POS:
 10553 000005CE 1E                      	push	ds
 10554 000005CF 8E1E[3401]              	mov	ds,[Batch]
 10555                                  	;mov	[8],dx
 10556 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10557                                  	;mov	[10],cx
 10558 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10559 000005DB 1F                      	pop	ds
 10560                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10561                                  	; 05/02/2023
 10562 000005DC B80042                  	mov	ax,4200h
 10563                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10564 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10565                                  			; AL = method: offset from beginning of	file
 10566                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10567                                  	; 24/04/2023
 10568                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10569 000005E1 26C706[2795]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10570                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10571 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10572 000005EA EB0F                    	jmp	short RDBAT
 10573                                  
 10574                                  	;nop
 10575                                  
 10576                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10577                                  ; We eat characters until a CR is seen.
 10578                                  
 10579                                  NOPLINE:
 10580 000005EC E80501                  	call	SKIPTOEOL
 10581 000005EF E87603                  	call	GETBATBYT	; eat trailing LF
 10582                                  	;test	word [Batch],0FFFFh
 10583 000005F2 F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10584 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10585                                  READBAT_RETN:			; Hit EOF
 10586 000005FA C3                      	retn
 10587                                  
 10588                                  ; ---------------------------------------------------------------------------
 10589                                  
 10590                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10591                                  ; input, we are to consider two special cases:
 10592                                  ;
 10593                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10594                                  ;   %sym%	This is a symbol from the environment
 10595                                  
 10596                                  RDBAT:
 10597 000005FB E86A03                  	call	GETBATBYT
 10598 000005FE 41                      	inc	cx		; Inc the line length
 10599                                  
 10600                                  	; 05/02/2023
 10601                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10602 000005FF E8BB1D                  	call	testkanj
 10603 00000602 740C                    	jz	short RDBAT1
 10604                                  	;cmp	cx,127
 10605 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10606 00000607 7350                    	jnb	short TOOLONG
 10607 00000609 AA                      	stosb
 10608 0000060A E85B03                  	call    GETBATBYT
 10609 0000060D 41                      	inc	cx
 10610 0000060E EB0A                    	jmp	short SAVBATBYT
 10611                                  RDBAT1:
 10612 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10613 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10614                                  
 10615                                  ; See if we have a parameter character.
 10616                                  
 10617 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10618 00000618 7449                    	je	short NEEDPARM
 10619                                  
 10620                                  ; no parameter character. Store it as usual and see if we are done.
 10621                                  
 10622                                  SAVBATBYT:
 10623 0000061A AA                      	stosb			; End of line found?
 10624 0000061B 3C0D                    	cmp	al,0Dh
 10625 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10626                                  
 10627                                  ; We have read in an entire line. 
 10628                                  ; Decide whether we should echo the command line or not.
 10629                                  
 10630                                  FOUND_EOL:
 10631 0000061F 81EF[0789]              	sub	di,COMBUF+3
 10632 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10633 00000625 26A2[0589]              	mov	[es:COMBUF+1],al
 10634                                  				; Set length of line
 10635 00000629 E83C03                  	call	GETBATBYT	; Eat linefeed
 10636 0000062C E8E906                  	call	BATCLOSE
 10637 0000062F 803E[8901]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10638 00000634 7407                    	jz	short RESET
 10639 00000636 F606[8801]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10640 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10641                                  RESET:
 10642 0000063D 0E                      	push	cs
 10643 0000063E 1F                      	pop	ds		; Go back to local segment
 10644 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10645                                  TRY_NEXTFLAG:
 10646 00000641 803E[9D01]01            	cmp	byte [NullFlag],nullcommand ; 1
 10647                                  				;G was there a command last time?
 10648 00000646 7403                    	jz	short NO_CRLF_PRINT
 10649                                  				;G no - don't print crlf
 10650 00000648 E8841F                  	call	CRLF2		;G Print out prompt
 10651                                  NO_CRLF_PRINT:
 10652 0000064B E84317                  	call	PRINT_PROMPT
 10653 0000064E 0E                      	push	cs		;G change data segment
 10654 0000064F 1F                      	pop	ds
 10655 00000650 BA[0689]                	mov	dx,COMBUF+2	; get command line for echoing
 10656 00000653 E8D21F                  	call	CRPRINT
 10657                                  	;call	CRLF2
 10658                                  	;retn
 10659                                  	; 06/02/2023
 10660 00000656 E9761F                  	jmp	CRLF2
 10661                                  
 10662                                  ; The line was too long. Eat remainder of input text up until the CR
 10663                                  
 10664                                  TOOLONG:
 10665 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10666 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10667 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10668                                  LTLCONT:
 10669 00000660 AA                      	stosb			; Terminate the command
 10670 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10671                                  
 10672                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10673                                  
 10674                                  NEEDPARM:
 10675 00000663 E80203                  	call	GETBATBYT	; get next character
 10676 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10677 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10678 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10679 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10680                                  
 10681                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10682                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10683                                  ; see if the <something> has a terminating % and then look up the contents
 10684                                  ; in the environment.
 10685                                  
 10686                                  PAROK:
 10687 0000066E 2C30                    	sub	al,'0'
 10688 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10689 00000672 3C09                    	cmp	al,9
 10690 00000674 7735                    	ja	short NEEDENV
 10691                                  
 10692                                  ; We have found %<number>. This is taken from the parameters in the
 10693                                  ; allocated batch area.
 10694                                  
 10695 00000676 98                      	cbw
 10696 00000677 89C3                    	mov	bx,ax		; move index into AX
 10697 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10698 0000067B 06                      	push	es
 10699 0000067C 8E06[3401]              	mov	es,[Batch]
 10700                                  
 10701                                  ; The structure of the batch area is:
 10702                                  ;
 10703                                  ;   BYTE    type of segment
 10704                                  ;   DWORD   offset for next line
 10705                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10706                                  ;   ASCIZ   file name (with . and ..)
 10707                                  ;   BYTES   CR-terminated parameters
 10708                                  ;   BYTE    0 flag to indicate end of parameters
 10709                                  ;
 10710                                  ; Get pointer to BX'th argument
 10711                                  
 10712                                  	;;mov	si,[es:bx+0Bh]
 10713                                  	; 05/02/2023
 10714                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10715 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10716 00000684 07                      	pop	es
 10717                                  
 10718                                  ; Is there a parameter here?
 10719                                  
 10720 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10721 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10722 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10723                                  
 10724                                  ; Copy in the found parameter from batch segment
 10725                                  
 10726                                  YES_THERE_IS:
 10727 0000068D 1E                      	push	ds
 10728 0000068E 8E1E[3401]              	mov	ds,[Batch]
 10729 00000692 49                      	dec	cx		; Don't count '%' in line length
 10730                                  COPYPARM:
 10731 00000693 AC                      	lodsb			; From resident segment
 10732 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10733 00000696 740F                    	je	short ENDPARAM
 10734 00000698 41                      	inc	cx		; Inc the line length
 10735 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10736 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10737 0000069F AA                      	stosb
 10738 000006A0 EBF1                    	jmp	short COPYPARM
 10739                                  
 10740                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10741                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10742                                  ; believing that we are at EOL. Clobber AL too.
 10743                                  
 10744                                  LINETOOL:
 10745 000006A2 30C0                    	xor	al,al
 10746 000006A4 1F                      	pop	ds
 10747 000006A5 EBB2                    	jmp	short TOOLONG
 10748                                  
 10749                                  ; We have copied in an entire parameter. Go back for more
 10750                                  
 10751                                  ENDPARAM:
 10752 000006A7 1F                      	pop	ds
 10753 000006A8 E950FF                  	jmp	RDBAT
 10754                                  
 10755                                  ; We have found % followed by something other than 0-9. We presume that there
 10756                                  ; will be a following % character. In between is an environment variable that
 10757                                  ; we will fetch and replace in the batch line with its value.
 10758                                  
 10759                                  NEEDENV:
 10760                                  	; MSDOS 6.0 COMMAND.COM
 10761                                  	; 05/02/2023 
 10762 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10763                                  
 10764                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10765 000006AC 1E                      	push	ds
 10766 000006AD 57                      	push	di
 10767                                  				; temp spot for name
 10768 000006AE BF[2C8B]                	mov	di,ID
 10769 000006B1 0430                    	add	al,'0'		; reconvert character
 10770 000006B3 AA                      	stosb			; store it in appropriate place
 10771                                  
 10772                                  ; loop getting characters until the next % is found or until EOL
 10773                                  
 10774                                  GETENV1:
 10775 000006B4 E8B102                  	call	GETBATBYT	; get the byte
 10776 000006B7 AA                      	stosb			; store it
 10777 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10778 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10779                                  
 10780                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10781                                  
 10782 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10783 000006C1 BE[2C8B]                	mov	si,ID 		; point to buffer
 10784 000006C4 5F                      	pop	di		; point to line buffer
 10785 000006C5 0E                      	push	cs
 10786 000006C6 1F                      	pop	ds
 10787 000006C7 E88B02                  	call	STRCPY
 10788                                  	; 05/02/2023
 10789 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10790                                  	; 24/04/2023
 10791                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10792 000006CC 1F                      	pop	ds
 10793 000006CD E94AFF                  	jmp	SAVBATBYT
 10794                                  GETENV15:
 10795 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10796 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10797                                  
 10798                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10799                                  ; This was the source of bug #1.
 10800                                  ;	dec	cx		;AN070; Don't count "%"
 10801                                  
 10802 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10803 000006D6 268845FF                	mov	[es:di-1],al
 10804                                  
 10805                                  ; ID now either has a =-terminated string which we are to find in the
 10806                                  ; environment or a non =-terminated string which will not be found in the
 10807                                  ; environment.
 10808                                  
 10809                                  GETENV2:
 10810 000006DA BE[2C8B]                	mov	si,ID
 10811 000006DD 0E                      	push	cs
 10812 000006DE 1F                      	pop	ds		; DS:SI points to name
 10813 000006DF 51                      	push	cx
 10814 000006E0 E8301C                  	call	find_name_in_environment
 10815 000006E3 59                      	pop	cx
 10816 000006E4 06                      	push	es
 10817 000006E5 1F                      	pop	ds
 10818 000006E6 0E                      	push	cs
 10819 000006E7 07                      	pop	es
 10820 000006E8 89FE                    	mov	si,di
 10821 000006EA 5F                      	pop	di		; get back pointer to command line
 10822                                  
 10823                                  ; If the parameter was not found, there is no need to perform any replacement.
 10824                                  ; We merely pretend that we've copied the parameter.
 10825                                  
 10826 000006EB 7203                    	jc	short GETENV6
 10827                                  
 10828                                  ; ES:DI points to command line being built
 10829                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10830                                  
 10831 000006ED E86502                  	call	STRCPY		; (let RdBat handle overflow)
 10832                                  	; 24/04/2022
 10833                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10834                                  GETENV6:
 10835 000006F0 1F                      	pop	ds
 10836 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10837                                  
 10838                                  ; =============== S U B	R O U T	I N E =======================================
 10839                                  
 10840                                  ;   SkipToEOL - read from batch file until end of line
 10841                                  
 10842                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10843                                  SKIPTOEOL:
 10844 000006F4 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10845                                  	;jnz	short SKIPTOEOL1  	
 10846                                  	;retn			; no batch file in effect
 10847                                  	
 10848 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10849                                  SKIPTOEOL1:
 10850 000006FC E86902                  	call	GETBATBYT
 10851 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10852 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10853                                  SKIPTOEOL2:
 10854 00000703 C3                      	retn
 10855                                  
 10856                                  ; =============== S U B	R O U T	I N E =======================================
 10857                                  
 10858                                  ;Break	<Allocate and deallocate the transient portion>
 10859                                  
 10860                                  ; Free Transient. Modify ES,AX,flags
 10861                                  
 10862                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10863                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10864                                  FREE_TPA:
 10865 00000704 06                      	push	es
 10866 00000705 8E06[A58A]              	mov	es,[RESSEG]
 10867 00000709 268E06[4503]            	mov	es,[es:Res_Tpa]
 10868 0000070E B449                    	mov	ah,49h
 10869                                  	;mov	ah,DEALLOC ; 49h
 10870 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10871                                  			; ES = segment address of area to be freed
 10872 00000712 07                      	pop	es
 10873 00000713 C3                      	retn
 10874                                  
 10875                                  ; =============== S U B	R O U T	I N E =======================================
 10876                                  
 10877                                  ; Allocate transient. Modify AX,BX,DX,flags
 10878                                  
 10879                                  	; 06/02/2023
 10880                                  ALLOC_TPA:
 10881 00000714 06                      	push	es
 10882 00000715 8E06[A58A]              	mov	es,[RESSEG]
 10883 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10884 0000071C B448                    	mov	ah,48h
 10885                                  	;mov	ah,ALLOC ; 48h
 10886 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10887                                  			; BX = number of 16-byte paragraphs desired
 10888 00000720 53                      	push	bx	  	; Save size of block
 10889 00000721 B448                    	mov	ah,48h
 10890                                  	;mov	ah,ALLOC ; 48h
 10891 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10892                                  			; BX = number of 16-byte paragraphs desired
 10893                                  
 10894                                  ; Attempt to align TPA on 64K boundary
 10895                                  
 10896 00000725 5B                      	pop	bx		; Restore size of block
 10897 00000726 26A3[4503]              	mov	[es:Res_Tpa],ax
 10898                                  				; Save segment to beginning of block
 10899 0000072A A3[B38A]                	mov	[TRAN_TPA],ax
 10900                                  
 10901                                  ; Is the segment already aligned on a 64K boundary
 10902                                  
 10903 0000072D 89C2                    	mov	dx,ax		; Save segment
 10904 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10905 00000732 7507                    	jnz	short CALC_TPA
 10906 00000734 89D0                    	mov	ax,dx
 10907 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10908 00000739 7523                    	jnz	short NOROUND
 10909                                  CALC_TPA:
 10910 0000073B 89D0                    	mov	ax,dx
 10911 0000073D 2500F0                  	and	ax,0F000h
 10912 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10913 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10914                                  
 10915                                  ; Make sure that new boundary is within allocated range
 10916                                  
 10917 00000745 268B16[4503]            	mov	dx,[es:Res_Tpa]
 10918 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10919 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10920 0000074E 720E                    	jb	short NOROUND
 10921                                  
 10922                                  ; Make sure that we won't overwrite the transient
 10923                                  
 10924 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10925 00000752 39C3                    	cmp	bx,ax
 10926 00000754 7208                    	jb	short NOROUND
 10927                                  
 10928                                  ; The area from the 64K boundary to the beginning of the transient must
 10929                                  ; be at least 64K.
 10930                                  
 10931 00000756 29C3                    	sub	bx,ax
 10932                                  	;cmp	bx,4096
 10933 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10934 0000075C 7304                    	jnb	short ROUNDDONE
 10935                                  NOROUND:
 10936 0000075E 26A1[4503]              	mov	ax,[es:Res_Tpa]
 10937                                  ROUNDDONE:
 10938 00000762 26A3[3903]              	mov	[es:LTpa],ax	; Re-compute everything
 10939 00000766 A3[A78A]                	mov	[TPA],ax
 10940 00000769 89C3                    	mov	bx,ax
 10941 0000076B 8CC8                    	mov	ax,cs
 10942 0000076D 29D8                    	sub	ax,bx
 10943 0000076F 53                      	push	bx
 10944 00000770 BB1000                  	mov	bx,16
 10945 00000773 F7E3                    	mul	bx
 10946 00000775 5B                      	pop	bx
 10947 00000776 09D2                    	or	dx,dx
 10948 00000778 7403                    	jz	short SAVSIZ2
 10949 0000077A B8FFFF                  	mov	ax,-1
 10950                                  SAVSIZ2:
 10951                                  
 10952                                  ; AX is the number of bytes free in the buffer between the resident and the
 10953                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10954                                  
 10955 0000077D 3D0002                  	cmp	ax,512
 10956 00000780 7603                    	jbe	short GOTSIZE2
 10957                                  	;and	ax,~1FFh
 10958 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10959                                  GOTSIZE2:
 10960 00000785 A3[C48A]                	mov	[BYTCNT],ax
 10961 00000788 07                      	pop	es
 10962 00000789 C3                      	retn
 10963                                  
 10964                                  ; =============== S U B	R O U T	I N E =======================================
 10965                                  
 10966                                  ;Break	<BatCom - enter a batch file>
 10967                                  
 10968                                  ; The exec search has determined that the user has requested a batch file for
 10969                                  ; execution. We parse the arguments, create the batch segment, and signal
 10970                                  ; batch processing.
 10971                                  
 10972                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10973                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10974                                  BATCOM:	
 10975                                  
 10976                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10977                                  
 10978                                  ; Batch parameters are read with ES set to segment of resident part
 10979                                  
 10980                                  	; MSDOS 6.0
 10981 0000078A 8E06[A58A]              	mov	es,[RESSEG]
 10982                                  	;ASSUME	ES:RESGROUP
 10983                                  	;cmp	byte [es:Call_Batch_Flag],1
 10984 0000078E 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10985                                  					;AN043; If in CALL,
 10986 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10987                                  	;invoke	IOSET			; Set up any redirection
 10988 00000796 E8E223                  	call	IOSET
 10989                                  skip_ioset:				;AN043;
 10990 00000799 E868FF                  	call	FREE_TPA		; G
 10991                                  	;cmp	byte [es:Call_Batch_Flag],1
 10992 0000079C 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10993 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10994                                  
 10995                                  	; 12/02/2023
 10996                                  	; MSDOS 3.3
 10997                                  	;call	IOSET
 10998                                  	;mov	es,[RESSEG]
 10999                                  	;call	FREE_TPA
 11000                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 11001                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 11002                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 11003                                  
 11004                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11005                                  
 11006                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 11007                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 11008                                  ; Don't execute if in call
 11009                                  
 11010 000007A4 E89608                  	call	FOROFF
 11011                                  GETECHO:
 11012 000007A7 E8BC27                  	call	PipeOff
 11013 000007AA 26A0[8801]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 11014 000007AE 2401                    	and	al,1			; Save current echo state
 11015                                  
 11016 000007B0 50                      	push	ax
 11017 000007B1 31C0                    	xor	ax,ax
 11018 000007B3 26F706[3401]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 11019 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 11020 000007BC 26A1[3401]              	mov	ax,[es:Batch] 		; Get current batch segment
 11021                                  	;cmp	byte [es:Call_Batch_Flag],1
 11022 000007C0 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11023 000007C6 7408                    	jz	short LEAVEBAT
 11024                                  
 11025                                  ;  We are in a chained batch file, save batlast from previous batch segment
 11026                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11027                                  
 11028 000007C8 06                      	push	es
 11029 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 11030                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11031                                  				; Get previous batch segment
 11032                                  	; 12/02/2023
 11033                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11034 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11035 000007CF 07                      	pop	es
 11036                                  LEAVEBAT:
 11037 000007D0 50                      	push	ax		; Keep segment until new one created
 11038                                  	;cmp	byte [es:Call_Batch_Flag],1
 11039 000007D1 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11040 000007D7 7403                    	jz	short STARTBAT
 11041 000007D9 E82001                  	call	BATCHOFF
 11042                                  
 11043                                  ; Find length of batch file
 11044                                  
 11045                                  STARTBAT:
 11046 000007DC 26C606[9A01]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11047 000007E2 BE[CD89]                	mov	si,EXECPATH
 11048                                  
 11049                                  	; 12/02/2023
 11050                                  	; MSDOS 6.0
 11051 000007E5 B811B7                  	mov	ax,0B711h
 11052                                  	;mov	ax,AppendTruename
 11053                                  				;AN042; Get the real path where the batch file
 11054 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11055 000007EA B44E                    	mov	ah,4Eh
 11056                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11057 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 11058 000007EE B91300                  	mov	cx,13h
 11059                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11060 000007F1 CD21                    	int	21h		;AN042;
 11061                                  
 11062                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11063 000007F3 E87424                  	call	dstrlen
 11064                                  ;
 11065                                  ; Allocate batch area:
 11066                                  ;   BYTE    type of segment
 11067                                  ;   WORD    segment of last batch file
 11068                                  ;   WORD    segment for FOR command
 11069                                  ;   BYTE    FOR flag state on entry to batch file
 11070                                  ;   DWORD   offset for next line
 11071                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11072                                  ;   ASCIZ   file name (with . and ..)
 11073                                  ;   BYTES   CR-terminated parameters
 11074                                  ;   BYTE    0 flag to indicate end of parameters
 11075                                  ;
 11076                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11077                                  ; later when we've squeezed out the extra
 11078                                  ;
 11079 000007F6 89CB                    	mov	bx,cx		; length of file name.
 11080                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11081                                  	; 12/02/2023
 11082                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11083                                  	; 25/04/2023
 11084 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11085                                  					; structure + max len + round up
 11086 000007FC 51                      	push	cx
 11087 000007FD B104                    	mov	cl,4
 11088 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 11089 00000801 53                      	push	bx		; Save size of batch segment
 11090 00000802 B448                    	mov	ah,48h
 11091                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11092 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11093                                  				; BX = number of 16-byte paragraphs desired
 11094 00000806 5B                      	pop	bx		; Get size of batch segment
 11095                                  
 11096                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11097                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11098                                  ; G This error will occur with nesting of batch files. We also need to
 11099                                  ; G make sure that we don't overlay the transient.
 11100                                  
 11101 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11102                                  
 11103 00000809 50                      	push	ax		;G save batch segment
 11104 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 11105 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 11106 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 11107                                  
 11108                                  	; MSDOS 6.0
 11109                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11110                                  ; M006; batchseg is always above the transient. We need to change this code
 11111                                  ; M006; to only check for an overlap
 11112                                  
 11113                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11114                                  	; 12/02/2023
 11115                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11116                                  	;mov	dx,TRANSPACEEND		
 11117                                  	;add	dx,15		;round up para; M006
 11118 00000811 BA7E95                  	mov	dx,TRANSPACEEND+15
 11119                                  
 11120 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 11121 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 11122                                  
 11123 00000818 39D8                    	cmp	ax,bx		; M006
 11124 0000081A 7211                    	jb	short ENOUGH_MEM
 11125                                  				; Batchseg below transient
 11126                                  				; enough memory ; M006
 11127 0000081C 39D0                    	cmp	ax,dx		; M006
 11128 0000081E 770D                    	ja	short ENOUGH_MEM	
 11129                                  				; Batchseg above transient
 11130                                  				; enough memory ; M006
 11131                                  
 11132                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11133                                  
 11134 00000820 58                      	pop	ax		; restore ax; M006
 11135                                  
 11136                                  	; 12/02/2023
 11137                                  	; MSDOS 3.3
 11138                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11139                                  ; M006;	pop	ax		;G get batch segment back
 11140                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11141                                  
 11142                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11143 00000821 06                      	push	es		;G no we're hitting the transient
 11144 00000822 8EC0                    	mov	es,ax
 11145 00000824 B80049                  	mov	ax,4900h
 11146                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11147 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11148                                  			; ES = segment address of area to be freed
 11149 00000829 07                      	pop	es
 11150                                  MEM_ERROR:
 11151 0000082A E9B800                  	jmp	NO_MEMORY	;G Set up for message and exit
 11152                                  
 11153                                  ENOUGH_MEM:
 11154                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11155                                  	; MSDOS 6.0
 11156 0000082D 58                      	pop	ax		; restore ax; M006
 11157                                  
 11158                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11159 0000082E 26A3[3401]              	mov	[es:Batch],ax
 11160 00000832 E8DFFE                  	call	ALLOC_TPA
 11161                                  
 11162                                  ; Initialize batch segment
 11163                                  
 11164 00000835 5A                      	pop	dx		; length of name
 11165 00000836 58                      	pop	ax		;G get saved batch segment back
 11166 00000837 26FF06[9701]            	inc	word [es:Nest]	;G increment # batch files in progress
 11167 0000083C 06                      	push	es
 11168 0000083D 268E06[3401]            	mov	es,[es:Batch]
 11169                                  	;mov	byte [ES:0],0
 11170                                  				; signal batch file type
 11171 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11172                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11173                                  				;G save segment of last batch file
 11174                                  	;mov	[es:3],ax	; MSDOS 6.0
 11175 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11176 0000084C 1E                      	push	ds
 11177 0000084D 8E1E[A58A]              	mov	ds,[RESSEG]	;G set to resident data
 11178                                  
 11179 00000851 31C0                    	xor	ax,ax
 11180 00000853 8A1E[9401]              	mov	bl,[ForFlag]	;G get the current FOR state
 11181                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11182                                  				;G save it in the batch segment
 11183                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11184 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11185 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11186 0000085F 7406                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11187                                  	;mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11188                                  	;mov	byte [ForFlag],0 ;G reset forflag
 11189                                  	; 26/07/2024
 11190 00000861 A2[9401]                	mov	[ForFlag],al ; 0
 11191 00000864 A1[9501]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11192                                  FOR_NOT_ON:
 11193                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11194                                  				;G save FOR segment in batch segment
 11195                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11196 00000867 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11197 0000086B 31C0                    	xor	ax,ax
 11198 0000086D A3[9501]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11199 00000870 8A1E[8801]              	mov	bl,[EchoFlag]
 11200 00000874 1F                      	pop	ds
 11201                                  	;mov	[es:1],bl 
 11202                                  				 ;G save echo state of parent
 11203 00000875 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11204                                  ;SR;
 11205                                  ; Initialize the new BatchEOF flag we have added to 0
 11206                                  
 11207                                  	; MSDOS 6.0
 11208                                  	;mov	byte [es:2],0
 11209 0000087A 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11210                                  
 11211                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11212 00000880 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11213                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11214 00000884 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11215                                  
 11216                                  ; Initialize pointers
 11217                                  
 11218 00000888 48                      	dec	ax		; put -1 into AX
 11219                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11220                                  				; point to parm area
 11221                                  	;mov	di,0Ch	; MSDOS 6.0
 11222 00000889 BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11223 0000088C 89FB                    	mov	bx,di
 11224 0000088E B90A00                  	mov	cx,10
 11225 00000891 F3AB                    	rep stosw		; Init to no parms
 11226                                  
 11227                                  ; Move in batch file name
 11228                                  
 11229 00000893 89D1                    	mov	cx,dx
 11230 00000895 F3A4                    	rep	movsb
 11231                                  
 11232                                  ; Now copy the command line into batch segment, parsing the arguments along
 11233                                  ; the way. Segment will look like this:
 11234                                  ;
 11235                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11236                                  ;
 11237                                  ; or, in the case of fewer arguments:
 11238                                  ;
 11239                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11240                                  
 11241 00000897 BE[0689]                	mov	si,COMBUF+2
 11242                                  	;mov	cx,10		; at most 10 arguments
 11243                                  	; 07/06/2023
 11244 0000089A B10A                    	mov	cl,10
 11245                                  EACHPARM:
 11246 0000089C E83D1D                  	call	scanoff		; skip to argument
 11247                                  
 11248                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11249                                  
 11250 0000089F 3C0D                    	cmp	al,0Dh		; end of road?
 11251 000008A1 741D                    	jz	short HAVPARM	; yes, no more arguments
 11252                                  
 11253                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11254                                  
 11255 000008A3 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11256                                  
 11257                                  ; Go into allocated piece and stick in new argument pointer.
 11258                                  
 11259 000008A5 26893F                  	mov	[es:bx],di	; store batch pointer
 11260 000008A8 83C302                  	add	bx,2		; advance arg counter
 11261                                  
 11262                                  ; Move the parameter into batch segment
 11263                                  
 11264                                  MOVPARM:
 11265 000008AB AC                      	lodsb			; get byte
 11266 000008AC E8351D                  	call	DELIM		; if delimiter
 11267 000008AF 7407                    	jz	short ENDPARM	; then done with parm
 11268 000008B1 AA                      	stosb			; store byte
 11269 000008B2 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11270 000008B4 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11271 000008B6 EBF3                    	jmp	short MOVPARM
 11272                                  
 11273                                  ; We have copied a parameter up until the first separator.
 11274                                  ; Terminate it with CR.
 11275                                  
 11276                                  ENDPARM:
 11277 000008B8 B00D                    	mov	al,0Dh
 11278 000008BA AA                      	stosb
 11279 000008BB E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11280 000008BD 49                      	dec	cx		; remember that we've seen one.	
 11281 000008BE EBDC                    	jmp	short EACHPARM
 11282                                  
 11283                                  ; We have parsed the entire line. Terminate the arg list
 11284                                  
 11285                                  HAVPARM:
 11286 000008C0 30C0                    	xor	al,al		; Nul terminate the parms
 11287 000008C2 AA                      	stosb
 11288                                  
 11289                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11290                                  ; into paragraphs and setblock to the appropriate size
 11291                                  
 11292 000008C3 8D5D0F                  	lea	bx,[di+15]
 11293 000008C6 B104                    	mov	cl,4
 11294 000008C8 D3EB                    	shr	bx,cl
 11295 000008CA B44A                    	mov	ah,4Ah
 11296                                  	;mov	ah,SETBLOCK ; 4Ah
 11297 000008CC CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11298                                  			; ES = segment address of block	to change
 11299                                  			; BX = new size	in paragraphs
 11300 000008CE 07                      	pop	es
 11301 000008CF 06                      	push	es
 11302 000008D0 1F                      	pop	ds		; Simply batch FCB setup
 11303 000008D1 833E[8E01]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11304 000008D6 7506                    	jne	short NOBATSING
 11305 000008D8 C706[8E01]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11306                                  
 11307                                  NOBATSING:
 11308                                  
 11309                                  ; Enter the batch file with the current echo state
 11310                                  
 11311 000008DE 58                      	pop	ax		; Get original echo state
 11312 000008DF A2[8801]                	mov	[EchoFlag],al	; restore it
 11313 000008E2 E91FF8                  	jmp	TCOMMAND
 11314                                  
 11315                                  ; The following is executed if there isn't enough memory for batch segment
 11316                                  
 11317                                  NO_MEMORY:
 11318 000008E5 5A                      	pop	dx		; even up our stack 
 11319 000008E6 58                      	pop	ax
 11320 000008E7 58                      	pop	ax
 11321 000008E8 E829FE                  	call	ALLOC_TPA	; reallocate memory
 11322                                  
 11323                                  	; 12/02/2023
 11324                                  	; MSDOS 3.3
 11325                                  	;mov	dx,INSFMEMMESPTR
 11326                                  	;jmp	CERROR
 11327                                  
 11328                                  	; MSDOS 6.0
 11329                                  	;mov	byte [msg_disp_class],1
 11330 000008EB C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 11331                                  				;AN000; set up extended error msg class
 11332                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11333 000008F0 BA[FC7E]                	mov	dx,extend_buf_ptr
 11334                                  	;			;AC000; get extended message pointer
 11335                                  	;mov	word [extend_buf_ptr],8
 11336 000008F3 C706[FC7E]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11337                                  				;AN000; get message number in control block
 11338 000008F9 E95420                  	jmp	cerror		;g print error message and go...
 11339                                  
 11340                                  ; =============== S U B	R O U T	I N E =======================================
 11341                                  
 11342                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11343                                  BATCHOFF:
 11344 000008FC 50                      	push	ax
 11345 000008FD 06                      	push	es
 11346 000008FE 1E                      	push	ds
 11347 000008FF 53                      	push	bx
 11348                                  
 11349 00000900 2E8E06[A58A]            	mov	es,[cs:RESSEG]
 11350                                  	;mov	ds,[cs:RESSEG]
 11351                                  	; 26/07/2024
 11352 00000905 06                      	push	es
 11353 00000906 1F                      	pop	ds
 11354                                  
 11355 00000907 A1[3401]                	mov	ax,[Batch]	; Free the batch segment
 11356 0000090A 09C0                    	or	ax,ax
 11357 0000090C 7442                    	jz	short NOTFREE
 11358                                  
 11359 0000090E 06                      	push	es
 11360 0000090F 8EC0                    	mov	es,ax
 11361 00000911 F606[8801]01            	test	byte [EchoFlag],1
 11362                                  				;G Is echo on?
 11363 00000916 7505                    	jnz	short ECHO_LAST_LINE
 11364                                  				;G Yes - echo last line in file
 11365                                  	;mov	byte [SUPPRESS],0
 11366 00000918 C606[8901]00            	mov	byte [Suppress],NO_ECHO
 11367                                  				;G no - don't echo last line in file	
 11368                                  ECHO_LAST_LINE:
 11369                                  	;mov	bl,[es:1]
 11370 0000091D 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11371                                  				; G get echo state
 11372 00000922 881E[8801]              	mov	[EchoFlag],bl
 11373                                  				; G  and restore it
 11374                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11375                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11376 00000926 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11377                                  				;G Get FOR segment
 11378 0000092B 891E[9501]              	mov	[ForPtr],bx	;G  and restore it
 11379                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11380                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11381 0000092F 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11382                                  				;G Get FOR flag
 11383 00000934 881E[9401]              	mov	[ForFlag],bl
 11384                                  				;G  and restore it
 11385                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11386                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11387 00000938 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11388                                  				;G  Get old batch segment
 11389                                  
 11390 0000093D B449                    	mov	ah,49h
 11391                                  	;mov	ah,DEALLOC ; 49h
 11392 0000093F CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11393                                  			; ES = segment address of area to be freed
 11394 00000941 07                      	pop	es
 11395 00000942 891E[9B01]              	mov	[Next_Batch],bx	;G reset batch segment	
 11396 00000946 26FF0E[9701]            	dec	word [es:Nest]
 11397 0000094B 31C0                    	xor	ax,ax
 11398 0000094D A3[3401]                	mov	[Batch],ax	; No batch in progress
 11399                                  NOTFREE:
 11400 00000950 5B                      	pop	bx
 11401 00000951 1F                      	pop	ds
 11402 00000952 07                      	pop	es
 11403 00000953 58                      	pop	ax
 11404 00000954 C3                      	retn
 11405                                  
 11406                                  ; =============== S U B	R O U T	I N E =======================================
 11407                                  
 11408                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11409                                  
 11410                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11411                                  ;	Entry : DS:SI ==> source string
 11412                                  ;		ES:DI ==> destination string
 11413                                  ;		CX = current length of destination string
 11414                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11415                                  
 11416                                  	; 12/02/2023	
 11417                                  	; MSDOS 3.3
 11418                                  ;STRCPY:
 11419                                  	;push	ax
 11420                                  ;CCYCLE:
 11421                                  	;lodsb
 11422                                  	;stosb
 11423                                  	;or	al,al
 11424                                  	;jnz	short CCYCLE
 11425                                  	;pop	ax
 11426                                  	;retn
 11427                                  
 11428                                  ;Procedure StrCpy,NEAR
 11429                                  
 11430                                  	; 12/02/2023
 11431                                  	; MSDOS 6.0
 11432                                  STRCPY:
 11433 00000955 50                      	push	ax
 11434                                  ccycle:
 11435 00000956 AC                      	lodsb
 11436 00000957 41                      	inc	cx
 11437                                  	;cmp	cx,128
 11438 00000958 81F98000                	cmp	cx,COMBUFLEN
 11439                                  	;jb	short ccopy
 11440                                  	;stc			; set carry to signal error
 11441                                  	;jmp	short ccend
 11442                                  	; 12/02/2023
 11443 0000095C F5                      	cmc
 11444 0000095D 7205                    	jc	short ccend
 11445                                  ccopy:
 11446 0000095F AA                      	stosb
 11447 00000960 08C0                    	or	al,al
 11448 00000962 75F2                    	jnz	short ccycle
 11449                                  ccend:
 11450 00000964 49                      	dec	cx		; discount extra byte
 11451 00000965 4F                      	dec	di		; back up pointer
 11452 00000966 58                      	pop	ax
 11453 00000967 C3                      	retn			; return carry clear
 11454                                  
 11455                                  ;EndProc StrCpy
 11456                                  
 11457                                  ;============================================================================
 11458                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11459                                  ;============================================================================
 11460                                  ; 12/10/2018 - Retro DOS v3.0
 11461                                  
 11462                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11463                                  
 11464                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11465                                  
 11466                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11467                                  
 11468                                  ; =============== S U B	R O U T	I N E =======================================
 11469                                  
 11470                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11471                                  
 11472                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11473                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11474                                  ; AH, DX destroyed.
 11475                                  
 11476                                  GETBATBYT:
 11477 00000968 53                      	push	bx
 11478 00000969 51                      	push	cx
 11479 0000096A 1E                      	push	ds
 11480 0000096B F606[7E01]FF            	test	byte [Batch_Abort],-1
 11481                                  	;jnz	short BATEOF
 11482                                  	; 14/02/2023
 11483 00000970 7403                    	jz	short getbatbyt1
 11484 00000972 E9D100                  	jmp	BATEOF
 11485                                  getbatbyt1:
 11486 00000975 F706[3401]FFFF          	test	word [Batch],-1
 11487                                  	;jz	short BATEOF
 11488                                  	; 14/02/2023
 11489 0000097B 7503                    	jnz	short getbatbyt2
 11490 0000097D E9C600                  	jmp	BATEOF
 11491                                  getbatbyt2:
 11492 00000980 06                      	push	es
 11493 00000981 8E06[3401]              	mov	es,[Batch]
 11494                                  
 11495                                  	; MSDOS 6.0
 11496                                  ;M020;
 11497                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11498                                  ;try to read from the batchfile again.
 11499                                  
 11500                                  	;cmp	byte [es:2],0
 11501 00000985 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11502                                  				;already reached EOF?	;M020
 11503 0000098B 7403                    	jz	short not_eof	;no, read batch file	;M020
 11504 0000098D E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11505                                  not_eof:						;M020
 11506                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11507                                  	;add	word [es:8],1	; MSDOS 6.0
 11508 00000990 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11509                                  	;adc	word [es:10],0	; MSDOS 6.0
 11510 00000996 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11511 0000099C 07                      	pop	es
 11512                                  
 11513                                  ; See if we have bytes buffered...
 11514                                  
 11515 0000099D 8CC8                    	mov	ax,cs
 11516 0000099F 8ED8                    	mov	ds,ax
 11517 000009A1 8B1E[2795]              	mov	bx,[BATBUFPOS]
 11518 000009A5 83FBFF                  	cmp	bx,-1
 11519 000009A8 7540                    	jnz	short UNBUF
 11520                                  
 11521                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11522                                  
 11523 000009AA BA[2995]                	mov	dx,BATBUF
 11524 000009AD 8B0E[4384]              	mov	cx,[BATBUFLEN] ; max to read.
 11525 000009B1 8B1E[558D]              	mov	bx,[BATHAND]
 11526                                  	; 14/02/2023
 11527 000009B5 B43F                    	mov	ah,3Fh
 11528                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11529 000009B7 CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11530                                  			; BX = file handle,CX = number	of bytes to read
 11531                                  			; DS:DX	-> buffer
 11532                                  	; MSDOS 6.0
 11533 000009B9 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11534                                  	;invoke	get_ext_error_number	;AN022; get the error
 11535 000009BB E83213                  	call	get_ext_error_number
 11536 000009BE 1E                      	push	ds			;AN022; save local segment
 11537 000009BF 8E1E[A58A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11538                                  	;assume ds:resgroup		;AN022;
 11539 000009C3 89C2                    	mov	dx,ax			;AN022; put error in DX
 11540                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11541 000009C5 E861FB                  	call	output_batch_name
 11542 000009C8 1F                      	pop	ds			;AN022;
 11543                                  	;assume	ds:trangroup		;AN022;
 11544                                  	;invoke	std_eprintf		;AN022; print out the error
 11545 000009C9 E8FD43                  	call	std_eprintf
 11546                                  	;mov	byte ptr combuf+2,end_of_line_in
 11547 000009CC C606[0689]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11548                                  	;				;AN022; terminate the batch line for parsing
 11549                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11550 000009D1 C606[0789]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11551                                  	;				;AN022; terminate the batch line for output
 11552                                  ;M020;
 11553                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11554                                  ;error is never hit (and it shouldn't be)
 11555                                  
 11556 000009D6 8E1E[A58A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11557 000009DA EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11558                                  bat_read_ok:				;AN022;
 11559                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11560 000009DC 89C1                    	mov	cx,ax
 11561                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11562                                  	; 14/02/2023
 11563 000009DE E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11564 000009E0 890E[4995]              	mov	[BATBUFEND],cx
 11565 000009E4 31DB                    	xor	bx,bx
 11566 000009E6 891E[2795]              	mov	[BATBUFPOS],bx
 11567                                  
 11568                                  	; Buffered bytes!
 11569                                  UNBUF:
 11570 000009EA 8A87[2995]              	mov	al,[BATBUF+bx]		; get next byte
 11571 000009EE 43                      	inc	bx
 11572 000009EF 3B1E[4995]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11573 000009F3 7203                    	jb	short SETBUFPOS
 11574 000009F5 BBFFFF                  	mov	bx,-1
 11575                                  SETBUFPOS:
 11576 000009F8 891E[2795]              	mov	[BATBUFPOS],bx
 11577 000009FC 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11578 000009FE 7575                    	jne	short GETBYTEDONE
 11579                                  
 11580                                  ;We get here only when we hit an EOF
 11581                                  	
 11582                                  	; MSDOS 6.0
 11583                                  BATEOFDS:
 11584                                  ;SR;
 11585                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11586                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11587                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11588                                  ;batch processing is turned off before the last line is processed and so 
 11589                                  ;this line would never be executed. 
 11590                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11591                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11592                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11593                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11594                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11595                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11596                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11597                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11598                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11599                                  ;another redundant CR-LF. There is no work-around I can think of.
 11600                                  ; 	I would love to restructure this entire routine and its caller to
 11601                                  ;make the flow really easy to understand but I guess this will have to wait.
 11602                                  ;
 11603 00000A00 06                      	push	es
 11604 00000A01 8E06[A58A]              	mov	es,[RESSEG]
 11605                                  ;SR;
 11606                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11607                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11608                                  ;
 11609 00000A05 268E06[3401]            	mov	es,[es:Batch]
 11610                                  	;cmp	byte [es:2],0
 11611 00000A0A 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11612 00000A10 7516                    	jnz	short crpresent
 11613                                  
 11614                                  	;inc	byte [es:2]
 11615 00000A12 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11616                                  					;match the dec following
 11617 00000A17 8B1E[4995]              	mov	bx,[BATBUFEND]
 11618 00000A1B 80BF[2895]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11619 00000A20 7406                    	je	short crpresent		;yes, no need to fake it
 11620                                  
 11621                                  	;add	byte [es:2],3
 11622 00000A22 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11623                                  					;BatchEOF == 4 to fake CR-LF
 11624                                  crpresent:
 11625                                  ;;	;pop	es
 11626                                  
 11627                                  	;ASSUME	DS:TranGroup
 11628                                  	; 14/02/2023
 11629 00000A28 8E1E[A58A]              	mov	ds,[RESSEG]
 11630                                  	;ASSUME	DS:ResGroup
 11631                                  ;SR;
 11632                                  ; The shift operation is done here to replace the decrement. This is because
 11633                                  ;we can jump to this label directly from above when bogus calls are made to
 11634                                  ;this routine even after batch processing is turned off. The shift ensures
 11635                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11636                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11637                                  ;calls.
 11638                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11639                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11640                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11641                                  ;turning batch processing off.
 11642                                  
 11643                                  At_EOF:					;new label added ;M020
 11644                                  	;shr	byte [es:2],1
 11645 00000A2C 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11646                                  					;decrement the flag
 11647 00000A31 7412                    	jz	short turn_off		;zero,turn batch off
 11648                                  	;cmp	byte [es:2],1
 11649 00000A33 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11650 00000A39 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11651                                  ;
 11652                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11653                                  ;
 11654 00000A3B B00D                    	mov	al,0Dh			;return fake CR.
 11655 00000A3D 07                      	pop	es
 11656 00000A3E EB35                    	jmp	short GETBYTEDONE
 11657                                  ret_lf:
 11658 00000A40 B00A                    	mov	al,0Ah			;return fake LF
 11659 00000A42 07                      	pop	es
 11660 00000A43 EB30                    	jmp	short GETBYTEDONE		
 11661                                  turn_off:
 11662 00000A45 07                      	pop	es
 11663                                  ;BATEOF:
 11664                                  	; MSDOS 3.3
 11665                                  ;TURN_OFF:
 11666                                  	;mov	ds,[RESSEG]
 11667                                  
 11668                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11669                                  BATEOF:
 11670 00000A46 E8B3FE                  	call	BATCHOFF
 11671 00000A49 E8CC02                  	call	BATCLOSE
 11672                                  
 11673                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11674                                  
 11675                                  ;SR; BugBug
 11676                                  ; There is a good reason why this carriage return is being returned here. 
 11677                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11678                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11679                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11680                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11681                                  ;the batchfile already had a CR-LF. 
 11682                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11683                                  ;the end-of-line. This CR is to mark the end-of-file.
 11684                                  
 11685 00000A4C B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11686 00000A4E F606[7E01]FF            	test	byte [Batch_Abort],-1
 11687 00000A53 C606[7E01]00            	mov	byte [Batch_Abort],0
 11688 00000A58 7407                    	jz	short CONT_GET_BYT
 11689 00000A5A BF[0689]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11690 00000A5D 31C9                    	xor	cx,cx			; zero line length
 11691 00000A5F EB14                    	jmp	short GETBYTEDONE
 11692                                  CONT_GET_BYT:
 11693 00000A61 833E[8E01]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11694 00000A66 750D                    	jne	short GETBYTEDONE
 11695 00000A68 833E[9701]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11696 00000A6D 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11697 00000A6F C706[8E01]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11698                                  GETBYTEDONE:
 11699 00000A75 1F                      	pop	ds
 11700 00000A76 59                      	pop	cx
 11701 00000A77 5B                      	pop	bx
 11702 00000A78 C3                      	retn
 11703                                  
 11704                                  ; ---------------------------------------------------------------------------
 11705                                  
 11706                                  ;break	<$If - conditional execution>
 11707                                  
 11708                                  	; 17/04/2023
 11709                                  ;IFERRORP:
 11710                                  ;	pop	ax
 11711                                  ;IFERROR:
 11712                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11713                                  ;FORERROR:
 11714                                  ;	mov	dx,SYNTMES_PTR
 11715                                  ;	jmp	cerror
 11716                                  
 11717                                  ; ---------------------------------------------------------------------------
 11718                                  
 11719                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11720                                  _$IF:
 11721                                  	; MSDOS 6.0
 11722                                  ; Turn off any pipes in progress.
 11723 00000A79 1E                      	push	ds			;AN004; save local DS
 11724 00000A7A 8E1E[A58A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11725                                  	;assume	ds:resgroup		;AN004;
 11726 00000A7E 803E[0102]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11727 00000A83 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11728                                  	;invoke	PipeDel 		;AN004; turn off piping
 11729 00000A85 E86322                  	call	PIPEDEL	
 11730                                  IFNoPipe:				;AN004;
 11731 00000A88 1F                      	pop	ds			;AN004; get local DS back
 11732                                  	;assume	ds:trangroup		;AN004;
 11733                                  
 11734                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11735 00000A89 C606[B68A]00            	mov	byte [IFNOTFLAG],0
 11736 00000A8E C706[FC93]0000          	mov	word [IF_NOT_COUNT],0
 11737 00000A94 BE8100                  	mov	si,81h
 11738                                  IFREENT:
 11739 00000A97 E8421B                  	call	scanoff
 11740 00000A9A 3C0D                    	cmp	al,0Dh
 11741 00000A9C 743C                    	je	short IFERROR
 11742 00000A9E 89F5                    	mov	bp,si
 11743 00000AA0 BF[9482]                	mov	di,IFTAB		; Prepare to search if table	
 11744                                  	;mov	ch,0
 11745                                  	; 17/04/2023
 11746 00000AA3 30ED                    	xor	ch,ch
 11747                                  IFINDCOM:
 11748 00000AA5 89EE                    	mov	si,bp
 11749 00000AA7 8A0D                    	mov	cl,[di]
 11750 00000AA9 47                      	inc	di
 11751 00000AAA E33E                    	jcxz	IFSTRING
 11752 00000AAC EB02                    	jmp	short FIRSTCOMP
 11753                                  IFCOMP:
 11754 00000AAE 7510                    	jnz	short IF_DIF
 11755                                  FIRSTCOMP:
 11756 00000AB0 AC                      	lodsb
 11757 00000AB1 268A25                  	mov	ah,[es:di]
 11758 00000AB4 47                      	inc	di
 11759 00000AB5 38E0                    	cmp	al,ah
 11760 00000AB7 7405                    	je	short IFLP
 11761 00000AB9 80CC20                  	or	ah,20h			; Try lower case
 11762 00000ABC 38E0                    	cmp	al,ah
 11763                                  IFLP:
 11764 00000ABE E2EE                    	loop	IFCOMP
 11765                                  IF_DIF:
 11766 00000AC0 9F                      	lahf
 11767 00000AC1 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11768 00000AC3 8B1D                    	mov	bx,[di]			; Get handler address
 11769 00000AC5 47                      	inc	di
 11770 00000AC6 47                      	inc	di
 11771 00000AC7 9E                      	sahf
 11772 00000AC8 75DB                    	jnz	short IFINDCOM
 11773 00000ACA AC                      	lodsb
 11774 00000ACB 3C0D                    	cmp	al,0Dh
 11775                                  IFERRJ:
 11776 00000ACD 740B                    	jz	short IFERROR
 11777 00000ACF E8121B                  	call	DELIM
 11778 00000AD2 75D1                    	jnz	short IFINDCOM
 11779 00000AD4 E8051B                  	call	scanoff
 11780 00000AD7 FFE3                    	jmp	bx
 11781                                  
 11782                                  	; 17/04/2023
 11783                                  IFERRORP:
 11784 00000AD9 58                      	pop	ax
 11785                                  IFERROR:
 11786                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11787                                  FORERROR:
 11788 00000ADA BA[947F]                	mov	dx,SYNTMES_PTR
 11789 00000ADD E9701E                  	jmp	cerror
 11790                                  
 11791                                  IFNOT:
 11792 00000AE0 F616[B68A]              	not	byte [IFNOTFLAG]
 11793 00000AE4 FF06[FC93]              	inc	word [IF_NOT_COUNT]
 11794 00000AE8 EBAD                    	jmp	short IFREENT
 11795                                  
 11796                                  ; We are comparing two strings for equality. First, find the end of the
 11797                                  ; first string.
 11798                                  
 11799                                  IFSTRING:
 11800 00000AEA 56                      	push	si			; save away pointer for later compare
 11801 00000AEB 31C9                    	xor	cx,cx			; count of chars in first string
 11802                                  FIRST_STRING:
 11803 00000AED AC                      	lodsb				; get character
 11804 00000AEE 3C0D                    	cmp	al,0Dh			; end of line?
 11805 00000AF0 74E7                    	jz	short IFERRORP		; yes => error
 11806 00000AF2 E8EF1A                  	call	DELIM			; is it a delimiter?
 11807 00000AF5 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11808 00000AF7 41                      	inc	cx			; remember 1 byte for the length
 11809 00000AF8 EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11810                                  EQUAL_CHECK:
 11811 00000AFA 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11812 00000AFC 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11813 00000AFE 3C0D                    	cmp	al,0Dh			; end of line?
 11814 00000B00 74D7                    	je	short IFERRORP		; yes, syntax error
 11815 00000B02 AC                      	lodsb				; get next char
 11816 00000B03 EBF5                    	jmp	short EQUAL_CHECK
 11817                                  
 11818                                  ; The first = has been found. The next char had better be an = too.
 11819                                  
 11820                                  EQUAL_CHECK2:
 11821 00000B05 AC                      	lodsb				; get potential = char
 11822 00000B06 3C3D                    	cmp	al,'='			; is it good?	
 11823                                  	;jnz	short IFERRPJ		; no, error
 11824                                  	; 17/04/2023
 11825 00000B08 75CF                    	jne	short IFERRORP
 11826                                  
 11827                                  ; Find beginning of second string.
 11828                                  
 11829 00000B0A E8CF1A                  	call	scanoff
 11830 00000B0D 3C0D                    	cmp	al,0Dh
 11831                                  	;jz	short IFERRPJ
 11832                                  	; 17/04/2023
 11833 00000B0F 74C8                    	je	short IFERRORP
 11834 00000B11 5F                      	pop	di
 11835                                  
 11836                                  ; DS:SI points to second string
 11837                                  ; CX has number of chars in first string
 11838                                  ; ES:DI points to first string
 11839                                  
 11840 00000B12 F3A6                    	repe	cmpsb
 11841 00000B14 7414                    	jz	short MATCH		; match found!
 11842                                  
 11843                                  ; No match. Let's find out what was wrong. The character that did not match
 11844                                  ; has been advanced over. Let's back up to it.
 11845                                  
 11846 00000B16 4E                      	dec	si
 11847                                  
 11848                                  ; If it is EOL, then syntax error
 11849                                  
 11850 00000B17 803C0D                  	cmp	byte [si],0Dh
 11851                                  	;jz	short IFERRJ
 11852                                  	; 17/04/2023
 11853 00000B1A 74BE                    	je	short IFERROR
 11854                                  
 11855                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11856                                  
 11857                                  SKIPSTRINGEND:
 11858 00000B1C AC                      	lodsb
 11859                                  NOTMATCH:
 11860 00000B1D 3C0D                    	cmp	al,0Dh
 11861                                  IFERRORJ2:
 11862                                  	;jz	short IFERRJ
 11863                                  	; 17/04/2023
 11864 00000B1F 74B9                    	jz	short IFERROR
 11865 00000B21 E8C01A                  	call	DELIM
 11866 00000B24 75F6                    	jnz	short SKIPSTRINGEND
 11867                                  
 11868                                  ; Signal that we did NOT have a match
 11869                                  
 11870 00000B26 B0FF                    	mov	al,-1
 11871 00000B28 EB37                    	jmp	short IFRET
 11872                                  
 11873                                  	; 17/04/2023
 11874                                  ;IFERRPJ:
 11875                                  	;jmp	IFERRORP
 11876                                  
 11877                                  ; The compare succeeded. Was the second string longer than the first?
 11878                                  ; We do this by seeing if the next char is a delimiter.
 11879                                  
 11880                                  MATCH:
 11881 00000B2A AC                      	lodsb
 11882 00000B2B E8B61A                  	call	DELIM
 11883 00000B2E 75ED                    	jnz	short NOTMATCH ; not same.
 11884 00000B30 30C0                    	xor	al,al
 11885 00000B32 EB2D                    	jmp	short IFRET
 11886                                  
 11887                                  ; ---------------------------------------------------------------------------
 11888                                  
 11889                                  IFEXISTS:
 11890                                  
 11891                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11892                                  
 11893                                  ;MOREDELIM:
 11894 00000B34 AC                      	lodsb
 11895 00000B35 E8AC1A                  	call	DELIM
 11896 00000B38 75FA                    	jnz	short IFEXISTS
 11897                                  	;jnz	short MOREDELIM
 11898                                  
 11899 00000B3A BA[AA8B]                	mov	dx,DIRBUF
 11900 00000B3D B8001A                  	mov	ax,1A00h
 11901                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11902 00000B40 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11903                                  			; DS:DX	-> disk	transfer buffer
 11904 00000B42 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11905 00000B45 031E[FC93]              	add	bx,[IF_NOT_COUNT]
 11906                                  	;mov	ax,ARG_ARGV
 11907                                  	;mov	ax,ARG+ARG_UNIT.argv
 11908 00000B49 B8[B08D]                	mov	ax,ARG
 11909 00000B4C E8FD25                  	call	argv_calc		; convert arg index to pointer
 11910 00000B4F 8B17                    	mov	dx,[bx]
 11911                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11912                                  	;mov	cx,6
 11913 00000B51 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11914 00000B54 B8004E                  	mov	ax,4E00h
 11915                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11916 00000B57 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11917                                  			; CX = search attributes
 11918                                  			; DS:DX	-> ASCIZ filespec
 11919                                  			; (drive,path, and wildcards allowed)
 11920 00000B59 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11921 00000B5B 30C0                    	xor	al,al
 11922 00000B5D EB02                    	jmp	short IFRET
 11923                                  
 11924                                  	;nop
 11925                                  IF_EX_C:
 11926 00000B5F B0FF                    	mov	al,-1			; false 'n' fall through...
 11927                                  IFRET:
 11928 00000B61 F606[B68A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11929 00000B66 7402                    	jz	short REALTEST
 11930 00000B68 F6D0                    	not	al
 11931                                  REALTEST:
 11932 00000B6A 08C0                    	or	al,al
 11933 00000B6C 7403                    	jz	short IFTRUE
 11934 00000B6E E993F5                  	jmp	TCOMMAND
 11935                                  
 11936                                  IFTRUE:
 11937 00000B71 E8681A                  	call	scanoff
 11938 00000B74 89F1                    	mov	cx,si
 11939 00000B76 81E98100                	sub	cx,81h
 11940 00000B7A 280E8000                	sub	[80h],cl
 11941 00000B7E 8A0E8000                	mov	cl,[80h]
 11942 00000B82 880E[0589]              	mov	[COMBUF+1],cl
 11943 00000B86 BF[0689]                	mov	di,COMBUF+2
 11944 00000B89 FC                      	cld
 11945 00000B8A F3A4                    	rep	movsb
 11946 00000B8C B00D                    	mov	al,0Dh
 11947 00000B8E AA                      	stosb
 11948                                  
 11949                                  ; Signal that an IF was done. 
 11950                                  ; This prevents the redirections from getting lost.
 11951                                  
 11952 00000B8F 1E                      	push	ds
 11953 00000B90 8E1E[A58A]              	mov	ds,[RESSEG]
 11954 00000B94 C606[9301]FF            	mov	byte [IfFlag],-1
 11955 00000B99 1F                      	pop	ds
 11956                                  
 11957                                  ; Go do the command
 11958                                  
 11959 00000B9A E93AF7                  	jmp	DOCOM1
 11960                                  
 11961                                  ; ---------------------------------------------------------------------------
 11962                                  
 11963                                  IFERRORJ3:
 11964 00000B9D EB80                    	jmp	IFERRORJ2
 11965                                  
 11966                                  IFERLEV:
 11967 00000B9F B70A                    	mov	bh,10
 11968 00000BA1 30DB                    	xor	bl,bl
 11969                                  GETNUMLP:
 11970 00000BA3 AC                      	lodsb
 11971 00000BA4 3C0D                    	cmp	al,0Dh
 11972 00000BA6 74F5                    	je	short IFERRORJ3
 11973 00000BA8 E8391A                  	call	DELIM
 11974 00000BAB 740C                    	jz	short GOTNUM
 11975 00000BAD 2C30                    	sub	al,'0'
 11976 00000BAF 86C3                    	xchg	al,bl
 11977 00000BB1 F6E7                    	mul	bh
 11978 00000BB3 00D8                    	add	al,bl
 11979 00000BB5 86C3                    	xchg	al,bl
 11980 00000BB7 EBEA                    	jmp	short GETNUMLP
 11981                                  GOTNUM:
 11982 00000BB9 1E                      	push	ds
 11983 00000BBA 8E1E[A58A]              	mov	ds,[RESSEG]
 11984 00000BBE 8A26[8501]              	mov	ah,[RetCode]
 11985 00000BC2 1F                      	pop	ds
 11986 00000BC3 30C0                    	xor	al,al
 11987 00000BC5 38DC                    	cmp	ah,bl
 11988 00000BC7 7398                    	jnb	short IFRET
 11989 00000BC9 FEC8                    	dec	al
 11990 00000BCB EB94                    	jmp	short IFRET
 11991                                  
 11992                                  ; ---------------------------------------------------------------------------
 11993                                  
 11994                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11995                                  ; This is a NOP if no batch in progress.
 11996                                  
 11997                                  _SHIFT:
 11998 00000BCD 8E1E[A58A]              	mov	ds,[RESSEG]
 11999 00000BD1 A1[3401]                	mov	ax,[Batch]		; get batch pointer
 12000 00000BD4 09C0                    	or	ax,ax			; in batch mode?
 12001 00000BD6 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 12002                                  SHIFT_RETN:				; no, done.
 12003 00000BD8 C3                      	retn
 12004                                  SHIFT1:
 12005 00000BD9 8EC0                    	mov	es,ax
 12006 00000BDB 8ED8                    	mov	ds,ax
 12007                                  
 12008                                  ; Now move the batch args down by 1 word
 12009                                  
 12010                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 12011                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 12012 00000BDD BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 12013 00000BE0 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 12014 00000BE3 B90900                  	mov	cx,9			; move 9 parameters
 12015 00000BE6 F3A5                    	rep	movsw			; SHIFT down
 12016                                  
 12017                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 12018                                  ; We have copied it into the previous position.
 12019                                  
 12020 00000BE8 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 12021 00000BEB 74EB                    	je	short SHIFT_RETN ; No new parm
 12022                                  
 12023                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 12024                                  ; Assume, first, that there is no next argument.
 12025                                   
 12026 00000BED 8B35                    	mov	si,[di]
 12027 00000BEF C705FFFF                	mov	word [di],-1		; Assume no parm
 12028                                  
 12029                                  ; The parameters are CR separated. Scan for end of this parm.
 12030                                  
 12031                                  SKIPCRLP:
 12032 00000BF3 AC                      	lodsb
 12033 00000BF4 3C0D                    	cmp	al,0Dh
 12034 00000BF6 75FB                    	jne	short SKIPCRLP
 12035                                  
 12036                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12037                                  ; are finished. There are no more parms and the pointer has been previously
 12038                                  ; initialized to indicate it.
 12039                                  
 12040 00000BF8 803C00                  	cmp	byte [si],0
 12041 00000BFB 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12042 00000BFD 8935                    	mov	[di],si			; Pointer to next parm as %9
 12043 00000BFF C3                      	retn
 12044                                  
 12045                                  ; =============== S U B	R O U T	I N E =======================================
 12046                                  
 12047                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12048                                  ; returns char in AL, carry set -> eof
 12049                                  
 12050                                  SKIPDELIM:
 12051 00000C00 F706[3401]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12052 00000C06 740A                    	jz	short SKIPERR
 12053 00000C08 E85DFD                  	call	GETBATBYT		; get a char
 12054 00000C0B E8D619                  	call	DELIM			; check for ignoreable chars
 12055 00000C0E 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12056 00000C10 F8                      	clc
 12057 00000C11 C3                      	retn
 12058                                  SKIPERR:
 12059 00000C12 F9                      	stc
 12060                                  GOTO_RETN:
 12061 00000C13 C3                      	retn
 12062                                  
 12063                                  ; ---------------------------------------------------------------------------
 12064                                  
 12065                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12066                                  ;  .com file. This routine strips the CALL off the command line, sets
 12067                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12068                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12069                                  ;  being CALLed.
 12070                                  
 12071                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12072                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12073                                  _$CALL:
 12074                                  
 12075                                  ;  strip off CALL from command line
 12076                                  
 12077                                  	;ASSUME DS:trangroup,ES:trangroup
 12078                                  
 12079 00000C14 56                      	push	si
 12080 00000C15 57                      	push	di
 12081 00000C16 50                      	push	ax
 12082 00000C17 51                      	push	cx
 12083 00000C18 BE[0689]                	mov	si,COMBUF+2
 12084 00000C1B E8BE19                  	call	scanoff			;get to first non-delimeter
 12085                                  	;add	si,4
 12086 00000C1E 83C604                  	add	si,length_call		;point to char past CALL
 12087 00000C21 BF[0689]                	mov	di,COMBUF+2
 12088                                  	;mov	cx,124		
 12089 00000C24 B97C00                  	mov	cx,COMBUFLEN-length_call 
 12090                                  					;get length of buffer
 12091 00000C27 F3A4                    	rep	movsb			;move it
 12092 00000C29 59                      	pop	cx
 12093 00000C2A 58                      	pop	ax
 12094 00000C2B 5F                      	pop	di
 12095 00000C2C 5E                      	pop	si
 12096                                  
 12097                                  ;  set call flag to indicate call in progress
 12098                                  
 12099 00000C2D 1E                      	push	ds
 12100 00000C2E 8E1E[A58A]              	mov	ds,[RESSEG]
 12101 00000C32 C606[9901]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12102 00000C37 C606[9A01]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12103                                  
 12104                                  ; Turn off any pipes in progress.
 12105                                  
 12106 00000C3C 803E[0102]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12107 00000C41 7403                    	jz	short _NOPIPE
 12108 00000C43 E8A520                  	call	PIPEDEL
 12109                                  _NOPIPE:
 12110 00000C46 1F                      	pop	ds
 12111 00000C47 C3                      	retn
 12112                                  
 12113                                  ; ---------------------------------------------------------------------------
 12114                                  
 12115                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12116                                  _GOTO:
 12117 00000C48 8E1E[A58A]              	mov	ds,[RESSEG]
 12118 00000C4C F706[3401]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12119 00000C52 74BF                    	jz	short GOTO_RETN
 12120 00000C54 31D2                    	xor	dx,dx
 12121 00000C56 1E                      	push	ds
 12122 00000C57 8E1E[3401]              	mov	ds,[Batch]
 12123                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12124 00000C5B 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12125                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12126 00000C5F 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12127                                  
 12128                                  	; MSDOS 6.0
 12129                                  ;M037
 12130                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12131                                  ;
 12132 00000C63 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12133                                  					; clear eof indicator ;M037
 12134                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12135 00000C68 1F                      	pop	ds
 12136                                  GOTOOPEN:
 12137 00000C69 E875F8                  	call	PROMPTBAT
 12138                                  	;mov	di,5Dh
 12139 00000C6C BF5D00                  	mov	di,FCB+1		; Get the label
 12140 00000C6F B90B00                  	mov	cx,11
 12141 00000C72 B020                    	mov	al,' '
 12142 00000C74 F2AE                    	repne	scasb
 12143 00000C76 7501                    	jnz	short NOINC
 12144 00000C78 41                      	inc	cx
 12145                                  NOINC:
 12146 00000C79 83E90B                  	sub	cx,11
 12147 00000C7C F7D9                    	neg	cx
 12148                                  	;mov	[cs:GOTOLEN],cx
 12149                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12150 00000C7E 26890E[AA8B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12151                                  
 12152                                  ; At beginning of file. Skip to first non-delimiter char
 12153                                  
 12154 00000C83 E87AFF                  	call	SKIPDELIM
 12155 00000C86 721C                    	jb	short BADGOTO
 12156 00000C88 3C3A                    	cmp	al,':'
 12157 00000C8A 7426                    	jz	short CHKLABEL
 12158                                  LABLKLP:				; Look for the label
 12159 00000C8C E8D9FC                  	call	GETBATBYT
 12160 00000C8F 3C0A                    	cmp	al,0Ah
 12161 00000C91 7509                    	jne	short LABLKTST
 12162                                  
 12163                                  ; At beginning of line. Skip to first non-delimiter char
 12164                                  
 12165 00000C93 E86AFF                  	call	SKIPDELIM
 12166 00000C96 720C                    	jb	short BADGOTO
 12167 00000C98 3C3A                    	cmp	al,':'
 12168 00000C9A 7416                    	je	short CHKLABEL
 12169                                  LABLKTST:
 12170 00000C9C F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
 12171 00000CA2 75E8                    	jnz	short LABLKLP
 12172                                  BADGOTO:
 12173 00000CA4 E87100                  	call	BATCLOSE
 12174                                  
 12175                                  	; MSDOS 6.0
 12176                                  ;SR;
 12177                                  ; At this point we are terminating without freeing up any nested batch 
 12178                                  ;segments i.e if the error occurred within a called batch file. This routine
 12179                                  ;will traverse the linked list of batch segments and free all of them.
 12180                                  ;
 12181 00000CA7 E8BB00                  	call	free_batch		; free up nested batch segments
 12182                                  
 12183                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12184 00000CAA 0E                      	push	cs
 12185 00000CAB 1F                      	pop	ds
 12186 00000CAC BA[917F]                	mov	dx,BADLAB_PTR
 12187 00000CAF E99E1C                  	jmp	cerror
 12188                                  
 12189                                  ; Found the :.	Skip to first non-delimiter char
 12190                                  
 12191                                  CHKLABEL:
 12192 00000CB2 E84BFF                  	call	SKIPDELIM
 12193 00000CB5 72ED                    	jb	short BADGOTO
 12194 00000CB7 BF5D00                  	mov	di,FCB+1 ; 5Dh
 12195                                  	;mov	cx,[cs:GOTOLEN]
 12196                                  	; 14/02/2023
 12197 00000CBA 268B0E[AA8B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12198 00000CBF EB05                    	jmp	short GOTBYTE
 12199                                  
 12200                                  NEXTCHRLP:
 12201 00000CC1 51                      	push	cx
 12202 00000CC2 E8A3FC                  	call	GETBATBYT
 12203 00000CC5 59                      	pop	cx
 12204                                  GOTBYTE:
 12205                                  	; 18/03/2023
 12206                                  	; 14/02/2023
 12207                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12208 00000CC6 E8F416                  	call	testkanj
 12209 00000CC9 7413                    	jz	short NOTKANJ1
 12210 00000CCB 263A05                  	cmp	al,[es:di]
 12211 00000CCE 75CC                    	jne	short LABLKTST
 12212 00000CD0 47                      	inc	di
 12213 00000CD1 49                      	dec	cx
 12214 00000CD2 E3C8                    	jcxz	LABLKTST
 12215 00000CD4 51                      	push	cx
 12216 00000CD5 E890FC                  	call	GETBATBYT
 12217 00000CD8 59                      	pop	cx
 12218 00000CD9 263A05                  	cmp	al,[es:di]
 12219 00000CDC EB0C                    	jmp	short KNEXTLABCHR
 12220                                  NOTKANJ1:
 12221                                  	; 14/02/2023
 12222                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12223 00000CDE 0C20                    	or	al,20h
 12224 00000CE0 263A05                  	cmp	al,[es:di]
 12225                                  	;jne	short TRYUPPER
 12226                                  	;jmp	short NEXTLABCHR
 12227                                  	; 25/04/2023
 12228 00000CE3 7407                    	je	short NEXTLABCHR 
 12229                                  TRYUPPER:
 12230 00000CE5 2C20                    	sub	al,20h
 12231 00000CE7 263A05                  	cmp	al,[es:di]
 12232                                  KNEXTLABCHR:
 12233 00000CEA 75B0                    	jnz	short LABLKTST
 12234                                  NEXTLABCHR:
 12235 00000CEC 47                      	inc	di
 12236 00000CED E2D2                    	loop	NEXTCHRLP
 12237 00000CEF E876FC                  	call	GETBATBYT
 12238                                  	; 14/02/2023
 12239 00000CF2 26833E[AA8B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12240                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12241 00000CF8 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12242 00000CFA 3C20                    	cmp	al,' '
 12243 00000CFC 779E                    	ja	short LABLKTST
 12244                                  GOTOCONT:
 12245 00000CFE 3C0D                    	cmp	al,0Dh
 12246 00000D00 7407                    	je	short SKIPLFEED
 12247                                  TONEXTBATLIN:
 12248 00000D02 E863FC                  	call	GETBATBYT
 12249 00000D05 3C0D                    	cmp	al,0Dh
 12250 00000D07 75F9                    	jne	short TONEXTBATLIN
 12251                                  SKIPLFEED:
 12252 00000D09 E85CFC                  	call	GETBATBYT
 12253                                  
 12254                                  	; MSDOS 6.0
 12255                                  ;SR;
 12256                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12257                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12258                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12259                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12260                                  ;all other cases, EOF will be hit while trying to read the next line and
 12261                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12262                                  ;
 12263 00000D0C 06                      	push	es
 12264 00000D0D 8E06[3401]              	mov	es,[Batch]
 12265 00000D11 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12266                                  					;invalidate fake CR-LF flag
 12267 00000D17 07                      	pop	es
 12268                                  
 12269                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12270                                  	;call	BATCLOSE
 12271                                  	;retn
 12272                                  	; 14/02/2023
 12273                                  	;jmp	short BATCLOSE
 12274                                  
 12275                                  ; =============== S U B	R O U T	I N E =======================================
 12276                                  
 12277                                  BATCLOSE:
 12278 00000D18 2E8B1E[558D]            	mov	bx,[cs:BATHAND]
 12279 00000D1D 83FB05                  	cmp	bx,5
 12280 00000D20 7204                    	jb	short CLOSERETURN
 12281                                  	; 14/02/2023
 12282 00000D22 B43E                    	mov	ah,3Eh
 12283                                  	;mov	ah,CLOSE ; 3Eh
 12284 00000D24 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12285                                  			; BX = file handle
 12286                                  CLOSERETURN:
 12287 00000D26 C606[7D01]00            	mov	byte [In_Batch],0 ; reset flag	
 12288 00000D2B C3                      	retn
 12289                                  
 12290                                  ; =============== S U B	R O U T	I N E =======================================
 12291                                  
 12292                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12293                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12294                                  
 12295                                  	; 14/02/2023
 12296                                  BATOPEN:
 12297 00000D2C 1E                      	push	ds
 12298 00000D2D 8E1E[3401]              	mov	ds,[Batch]
 12299                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12300                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12301 00000D31 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12302 00000D34 B8003D                  	mov	ax,3D00h
 12303                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12304 00000D37 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12305                                  			; DS:DX	-> ASCIZ filename
 12306                                  			; AL = access mode
 12307                                  			; 0 - read
 12308 00000D39 721C                    	jc	short SETERRDL
 12309                                  	;mov	dx,[8]
 12310 00000D3B 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12311                                  	;mov	cx,[10]
 12312 00000D3F 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12313 00000D43 1F                      	pop	ds
 12314                                  	;mov	[cs:BATHAND],ax
 12315 00000D44 26A3[558D]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12316 00000D48 89C3                    	mov	bx,ax
 12317 00000D4A B80042                  	mov	ax,4200h
 12318                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12319 00000D4D CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12320                                  			; AL = method: offset from beginning of	file
 12321                                  
 12322                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12323                                  					; nuke batch buffer position
 12324 00000D4F 26C706[2795]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12325                                  BATOPEN_RETN:
 12326 00000D56 C3                      	retn
 12327                                  
 12328                                  SETERRDL:
 12329 00000D57 89D3                    	mov	bx,dx
 12330                                  	; MSDOS 6.0
 12331                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12332                                  	; 14/02/2023
 12333 00000D59 E8940F                  	call	get_ext_error_number
 12334 00000D5C 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12335                                  
 12336                                  	; MSDOS 3.3
 12337                                  	;mov	dx,INSERTDSKPTR
 12338                                  	;call	GET_EXT_ERR_NUMBER
 12339                                  
 12340                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12341 00000D5E 8A07                    	mov	al,[bx]			; Get drive spec
 12342 00000D60 2C40                    	sub	al,'@'			; A = 1
 12343 00000D62 1F                      	pop	ds
 12344 00000D63 F9                      	stc				; SUB mucked over carry
 12345 00000D64 C3                      	retn
 12346                                  
 12347                                  ; =============== S U B	R O U T	I N E =======================================
 12348                                  
 12349                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12350                                  ;the batch and FOR segments until all of them are freed. It also restores
 12351                                  ;the old state of the EchoFlag.
 12352                                  ;
 12353                                  ;	ENTRY:	ds = RESGROUP
 12354                                  ;
 12355                                  ;	EXIT: 	All batch & FOR segments freed.
 12356                                  ;		EchoFlag restored to old state before batch process.
 12357                                  ;
 12358                                  ;	REGISTERS AFFECTED: bx, cx
 12359                                  
 12360                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12361                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12362                                  
 12363                                  free_batch: ;proc near
 12364                                  	;assume	ds:RESGROUP,es:nothing
 12365                                  
 12366 00000D65 06                      	push	es
 12367 00000D66 8B1E[9B01]              	mov	bx,[Next_Batch]
 12368 00000D6A 09DB                    	or	bx,bx
 12369 00000D6C 7431                    	jz	short fb_ret
 12370                                  _ClearBatch:
 12371 00000D6E 8EC3                    	mov	es,bx			; get batch segment
 12372                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12373 00000D70 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12374                                  	;cmp	bx,0			; is a FOR in progress
 12375                                  	; 27/07/2024
 12376 00000D75 21DB                    	and	bx,bx
 12377 00000D77 7408                    	jz	short no_bat_for	; no - don't deallocate
 12378 00000D79 06                      	push	es			;
 12379 00000D7A 8EC3                    	mov	es,bx			; yes - free it up...
 12380 00000D7C B449                    	mov	ah,49h
 12381                                  	;mov	ah,DEALLOC		;
 12382 00000D7E CD21                    	int	21h			;
 12383 00000D80 07                      	pop	es			; restore to batch segment
 12384                                  no_bat_for:
 12385                                  	;mov	cl,[es:1]
 12386 00000D81 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12387                                  					; get old echo flag
 12388                                  	;mov	bx,[es:3]
 12389 00000D86 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12390                                  					; get old batch segment
 12391 00000D8B B449                    	mov	ah,49h
 12392                                  	;mov	ah,DEALLOC		; free it up...
 12393 00000D8D CD21                    	int	21h
 12394                                  	; 14/02/2023
 12395                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12396 00000D8F FF0E[9701]              	dec	word [Nest]		; is there another batch file?
 12397 00000D93 75D9                    	jnz	short _ClearBatch	; keep going until no batch file
 12398                                  	
 12399 00000D95 880E[8801]              	mov	[EchoFlag],cl		;restore echo status
 12400 00000D99 C706[3401]0000          	mov	word [Batch],0		;no batch process in progress
 12401                                  fb_ret:
 12402 00000D9F 07                      	pop	es
 12403 00000DA0 C3                      	ret
 12404                                  
 12405                                  ;free_batch endp
 12406                                  
 12407                                  ;============================================================================
 12408                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12409                                  ;============================================================================
 12410                                  ; 10/10/2018 - Retro DOS v3.0
 12411                                  
 12412                                  ; All batch proccessing has DS set to segment of resident portion
 12413                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12414                                  
 12415                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12416                                  
 12417                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12418                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12419                                  
 12420                                  ; ---------------------------------------------------------------------------
 12421                                  
 12422                                  	; 15/02/2023
 12423                                  FORTERM:
 12424                                  	; MSDOS 6.0
 12425 00000DA1 0E                      	push	cs			;AN037; Get local segment into
 12426 00000DA2 1F                      	pop	ds			;AN037;  DS, ES
 12427 00000DA3 0E                      	push	cs			;AN037;
 12428 00000DA4 07                      	pop	es			;AN037;
 12429                                  
 12430                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12431 00000DA5 E89502                  	call	FOROFF
 12432                                  	;mov	ds,[cs:RESSEG]
 12433 00000DA8 268E1E[A58A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12434 00000DAD 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 12435 00000DB3 750F                    	jne	short BAT_CRLF
 12436 00000DB5 833E[9701]00            	cmp	word [Nest],0		;See if we have nested batch files
 12437 00000DBA 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12438 00000DBC C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12439 00000DC2 EB12                    	jmp	short NOFORP2
 12440                                  BAT_CRLF:
 12441 00000DC4 F606[8801]01            	test	byte [EchoFlag],1 	; Is echo on?
 12442 00000DC9 740B                    	jz	short NOFORP2		; no - exit
 12443 00000DCB F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12444                                  					; print CRLF if in batch
 12445 00000DD1 7403                    	jz	short NOFORP2
 12446 00000DD3 E8F917                  	call	CRLF2
 12447                                  NOFORP2:
 12448 00000DD6 E92BF3                  	jmp	TCOMMAND
 12449                                  
 12450                                  ; ---------------------------------------------------------------------------
 12451                                  
 12452                                  ;------
 12453                                  ;   For-loop processing. For loops are of the form:
 12454                                  ;	    for %<loop-variable> in (<list>) do <command>
 12455                                  ; where <command> may contain references of the form %<variable>, which are
 12456                                  ; later substituted with the items in <list>. The for-loop structure is
 12457                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12458                                  ; <command> once for each item in <list>. All of the information needed for
 12459                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12460                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12461                                  ; a complete copy of the original command-line structure as parsed by
 12462                                  ; 'parseline', loop control variables, and a dma buffer for the
 12463                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12464                                  ; processing has completed, this chunk of memory is returned to the system.
 12465                                  ;
 12466                                  ;   All of the previously defined variables, in 'datares', used for loop
 12467                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12468                                  ;
 12469                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12470                                  ; containing all of the other error messages.
 12471                                  ;
 12472                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12473                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12474                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12475                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12476                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12477                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12478                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12479                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12480                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12481                                  ; instead of
 12482                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12483                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12484                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12485                                  ; doesn't matter whether we put brackets around the location or not -- the
 12486                                  ; assembler is "smart" enough to know that we want an address instead of the
 12487                                  ; contents of that location.
 12488                                  ;
 12489                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12490                                  ; One method would be to have a link field in each for-structure pointing to
 12491                                  ; its parent.  Variable references that couldn't be resolved in the local
 12492                                  ; frame would cause a search of prior frames. For-structures would still be
 12493                                  ; allocated and released in exactly the same fashion. The only limit on the
 12494                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12495                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12496                                  ; maintained in the resident data area. This structure would be an array of
 12497                                  ; control-variable names and pointers to for-structure blocks. This would
 12498                                  ; greatly speed up the resolution of non-local variable references. However,
 12499                                  ; since space in the resident is precious, we would have to compromise on a
 12500                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12501                                  ; allocation and de-allocation would have to be modified slightly to take this
 12502                                  ; new structure into account.
 12503                                  ;
 12504                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12505                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12506                                  ; it may be easier to allocate it as part of 'for_segment'.
 12507                                  ;------
 12508                                  		; include fordata.asm
 12509                                  
 12510                                  ; Data structure definitions included by tfor.asm
 12511                                  
 12512                                  struc FOR_INFO
 12513 00000000 <res 444h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12514 00000444 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12515 00000445 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12516 00000447 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12517 00000449 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12518 0000044B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12519 000004CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12520 0000054B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12521                                    .size:
 12522                                  endstruc
 12523                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12524                                  					; ARG_UNIT.SIZE = 1092 ; 27/07/2024
 12525                                  _$FOR_EXIT:
 12526 00000DD9 EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12527                                  
 12528                                  ; ---------------------------------------------------------------------------
 12529                                  
 12530                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12531                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12532                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 12533                                  FORPROC:
 12534 00000DDB A1[9501]                	mov	ax,[ForPtr]
 12535 00000DDE 8ED8                    	mov	ds,ax
 12536 00000DE0 8EC0                    	mov	es,ax			; operate in for-info area
 12537                                  	;;mov	dx,5CBh	; MSDOS 5.0 & 6.22
 12538                                  	;mov	dx,4CBh ; PCDOS 7.1 ; 27/07/2024
 12539 00000DE2 BACB04                  	mov	dx,FOR_INFO.FORDMA	; 1348+1+2+2+2+128 = 1483 = 5CBh
 12540                                  		; PCDOS 7.1 COMMAND.COM ; 1092+1+2+2+2+128 = 1227 = 4CBh
 12541 00000DE5 B8001A                  	mov	ax,1A00h
 12542                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12543 00000DE8 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12544                                  			; DS:DX	-> disk	transfer buffer
 12545                                  FOR_BEGIN:
 12546                                  	;;cmp	word [545h],0
 12547                                  	;cmp	word [445h] ; 27/07/2024
 12548 00000DEA 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12549 00000DEF 7404                    	jz	short FOR_BEGIN1
 12550                                  					; non-zero for_expand equals FALSE
 12551                                  	;;inc	word [547h]
 12552                                  	;inc	word [447h] ; 27/07/2024
 12553 00000DF1 FF064704                	inc	word [FOR_INFO.FOR_MINARG]
 12554                                  FOR_BEGIN1:
 12555                                  	;mov	bx,[447h] ; 27/07/2024
 12556 00000DF5 8B1E4704                	mov	bx,[FOR_INFO.FOR_MINARG] ; current item in <list> to examine
 12557                                  	;cmp	bx,[449h] ; 27/07/2024
 12558 00000DF9 3B1E4904                	cmp	bx,[FOR_INFO.FOR_MAXARG]
 12559 00000DFD 7FDA                     	jg	short _$FOR_EXIT	; exceeding maxarg means all done
 12560                                  	;mov	ax,0
 12561 00000DFF B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12562 00000E02 E84723                  	call	argv_calc		; compute argv[x] address
 12563                                  	;mov	cx,[bx+3]
 12564 00000E05 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12565 00000E08 8B17                    	mov	dx,[bx]
 12566                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12567                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12568 00000E0A F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12569 00000E0E 7512                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12570 00000E10 8B37                    	mov	si,[bx]
 12571                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12572                                  
 12573                                  	;mov	al,[cs:LPAREN]
 12574                                  	; 15/02/2023
 12575                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12576                                  	;mov	al,'('	; mov al,lparen
 12577                                  	;cmp	[si-1],	al		; If the current token is the first
 12578                                  	; 27/07/2024
 12579 00000E12 807CFF28                	cmp	byte [si-1],'('
 12580 00000E16 750A                    	jne	short FORSUB		;  one in the list and originally had
 12581 00000E18 41                      	inc	cx			;  the opening paren as its first char,
 12582                                  					;  the argstartel ptr needs to be
 12583                                  					;  advanced passed it before the prefix
 12584                                  					;  length is computed.
 12585                                  	;mov	al,':'
 12586                                  	;cmp	[si+1],	al		; If the token begins with "(d:",
 12587                                  	; 27/07/2024
 12588 00000E19 807C013A                	cmp	byte [si+1],':'
 12589 00000E1D 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12590 00000E1F 83C102                  	add	cx,2			;  rest of the prefix as well.
 12591                                  FORSUB:
 12592 00000E22 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12593                                  	;;cmp	word [545h],0
 12594                                  	;cmp	word [445h],0 ; 27/07/2024
 12595 00000E24 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12596                                  					; are we still expanding a name?
 12597 00000E29 7416                    	jz	short FOR_FIND_NEXT
 12598                                  					; if so, get next matching filename
 12599                                  	;test	byte [bx+2],2
 12600 00000E2B F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12601 00000E2F 7505                    	jnz	short FOR_FIND_FIRST
 12602                                  					; should we expand THIS (new) arg?
 12603                                  	;mov	cx,[bx+5]
 12604                                  					; else, just copy all of it directly
 12605 00000E31 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12606 00000E34 EB1D                    	jmp	short FOR_SMOOSH
 12607                                  
 12608                                  	;nop
 12609                                  	; 15/02/2023
 12610                                  FOR_FIND_FIRST:
 12611 00000E36 51                      	push	cx
 12612 00000E37 31C9                    	xor	cx,cx
 12613 00000E39 B8004E                  	mov	ax,4E00h
 12614                                  	;mov	ax,Find_First*256 ; 4E00h
 12615 00000E3C CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12616                                  			; CX = search attributes
 12617                                  			; DS:DX	-> ASCIZ filespec
 12618                                  			; (drive,path, and wildcards allowed)
 12619 00000E3E 59                      	pop	cx
 12620 00000E3F EB05                    	jmp	short FOR_RESULT
 12621                                  
 12622                                  	;nop
 12623                                  FOR_FIND_NEXT:
 12624 00000E41 B8004F                  	mov	ax,4F00h
 12625                                  	;mov	ax,Find_Next*256 ;4F00h
 12626 00000E44 CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12627                                  			; [DTA]	= data block from
 12628                                  			; last AH = 4Eh/4Fh call
 12629                                  FOR_RESULT:
 12630 00000E46 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12631 00000E49 7201                    	jc	short FOR_CHECK
 12632                                  	; 15/02/2023
 12633 00000E4B 40                      	inc	ax ; ax = 0
 12634                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12635                                  FOR_CHECK:				; record success of findfirst/next
 12636                                  	;;mov	[545h],ax
 12637                                  	;mov	[445h],ax ; 27/07/2024
 12638 00000E4C A34504                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12639 00000E4F 09C0                    	or	ax,ax			; anything out there?
 12640 00000E51 7597                    	jnz	short FOR_BEGIN		; if not, try next arg
 12641                                  FOR_SMOOSH:
 12642                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12643 00000E53 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12644                                  	;;mov	di,54Bh	; MSDOS 5.0 & 6.22 COMMAND.COM
 12645                                  	;mov	di,44Bh ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12646 00000E55 BF4B04                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12647 00000E58 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12648                                  					
 12649 00000E5A 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12650                                  					; if we're not expanding, we can
 12651 00000E5F 7509                    	jnz	short FOR_MAKE_COM 	; skip the following
 12652                                  	; 15/02/2023
 12653                                  	;;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.22 COMMAND.COM ; 27/07/2024
 12654                                  	; 27/07/2024
 12655                                  	;mov	si,04E9h ; PCDOS 7.1 COMMAND.COM
 12656 00000E61 BEE904                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12657                                  FOR_MORE:
 12658                                  	;cmp	byte [si],0		; tack on matching filename
 12659                                  	;jz	short FOR_MAKE_COM
 12660                                  	;movsb
 12661                                  	;jnz	short FOR_MORE
 12662                                  	; 25/04/2023
 12663 00000E64 AC                      	lodsb
 12664 00000E65 AA                      	stosb
 12665 00000E66 08C0                    	or	al,al
 12666 00000E68 75FA                    	jnz	short FOR_MORE
 12667                                  FOR_MAKE_COM:
 12668                                  	; 25/04/2023
 12669                                  	;xor	al,al			; tack a null byte onto the end
 12670                                  	;stosb				; of the substitute string
 12671 00000E6A 31C9                    	xor	cx,cx			; character count for command line
 12672 00000E6C F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12673 00000E6E 31DB                    	xor	bx,bx			; argpointer
 12674 00000E70 BF[0689]                	mov	di,COMBUF+2
 12675                                  	; 15/02/2023
 12676                                  	;;mov	bl,[544h] ; MSDOS 5.0-6.22 ; 27/07/2024
 12677                                  	; 27/07/2024
 12678                                  	;mov	bl,[444h] ; PCDOS 7.1 COMMAND.COM 
 12679 00000E73 8A1E4404                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12680                                  	;;mov	dh,[64Bh]
 12681                                  	;mov	dh,[54Bh] ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12682 00000E77 8A364B05                	mov	dh,[FOR_INFO.FOR_VAR]
 12683                                  					; %<for-var> is replaced by [forbuf]
 12684 00000E7B 0E                      	push	cs			; time to form the <command> string
 12685 00000E7C 07                      	pop	es
 12686                                  	;assume ES:trangroup
 12687                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12688 00000E7D B80000                  	mov	ax,0			; translate offset to pointer
 12689 00000E80 E8C922                  	call	argv_calc
 12690                                  	;mov	si,[bx+9]
 12691 00000E83 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr]
 12692                                  					; mov ptr passed beginning space
 12693 00000E86 46                      	inc	si
 12694                                  FOR_MAKE_LOOP:
 12695 00000E87 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12696 00000E89 46                      	inc	si
 12697 00000E8A 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12698 00000E8C 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12699 00000E8E 3834                    	cmp	[si],dh			; got the right <variable>?
 12700 00000E90 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12701 00000E92 46                      	inc	si			; skip over <for-variable>
 12702                                  
 12703 00000E93 56                      	push	si
 12704                                  	; 15/02/2023
 12705                                  	;;mov	si,54Bh	; MSDOS 5.0-6.22 ; 27/07/2024
 12706                                  	; 27/07/2024
 12707                                  	;mov	si,44Bh ; PCDOS 7.1 COMMAND.COM
 12708 00000E94 BE4B04                  	mov	si,FOR_INFO.FORBUF
 12709                                  					; substitute the <item> for <variable>
 12710                                  					; to make a final <command> to execute
 12711                                  SLOOP:					
 12712 00000E97 AC                      	lodsb				; grab all those <item> bytes, and
 12713 00000E98 AA                      	stosb				; add 'em to the <command> string,
 12714 00000E99 08C0                    	or	al,al			; until we run into a null
 12715 00000E9B E0FA                    	loopne	SLOOP
 12716 00000E9D 4F                      	dec	di			; adjust length and <command> pointer
 12717 00000E9E 41                      	inc	cx			; so we can overwrite the null
 12718 00000E9F 5E                      	pop	si
 12719 00000EA0 EBE5                    	jmp	short FOR_MAKE_LOOP
 12720                                  					; got back for more <command> bytes
 12721                                  FOR_STOSB:
 12722 00000EA2 AA                      	stosb				; take a byte from the <command> arg
 12723 00000EA3 49                      	dec	cx			; and put it into the <command> to be
 12724                                  					; executed (and note length, too)
 12725 00000EA4 3C0D                    	cmp	al,0Dh
 12726 00000EA6 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12727                                  FOR_MADE_COM:
 12728 00000EA8 F6D1                    	not	cl
 12729                                  	;mov	[cs:COMBUF+1],cl
 12730                                  	;mov	ds,[cs:RESSEG]
 12731                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12732                                  	; MSDOS 5.0 COMMAND.COM
 12733 00000EAA 26880E[0589]            	mov	[es:COMBUF+1],cl
 12734 00000EAF 268E1E[A58A]            	mov	ds,[es:RESSEG]
 12735                                  	;assume DS:resgroup
 12736 00000EB4 F606[8801]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12737 00000EB9 742F                    	jz	short NOECHO3
 12738                                  	;cmp	byte [NullFlag],nullcommand
 12739 00000EBB 803E[9D01]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12740 00000EC0 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf
 12741                                  
 12742 00000EC2 E80A17                  	call	CRLF2		  	;G Print out prompt
 12743                                  NO_CRLF_PR:
 12744 00000EC5 C606[9D01]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12745 00000ECA 0E                      	push	cs
 12746 00000ECB 1F                      	pop	ds
 12747 00000ECC 57                      	push	di
 12748 00000ECD E8C10E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12749 00000ED0 5F                      	pop	di
 12750                                  
 12751 00000ED1 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12752 00000ED6 C706[118C][0689]        	mov	word [string_ptr_2],COMBUF+2
 12753                                  	; 17/04/2023
 12754 00000EDC BA[C380]                	mov	dx,string_buf_ptr
 12755 00000EDF E8EF3E                  	call	std_printf
 12756 00000EE2 26C645FF0D              	mov	byte [es:di-1],0Dh
 12757 00000EE7 E9EAF3                  	jmp	DOCOM		  	; run silent, run deep...
 12758                                  NOECHO3:
 12759 00000EEA C606[9D01]00            	mov	byte [NullFlag],0
 12760 00000EEF 0E                      	push	cs
 12761 00000EF0 1F                      	pop	ds
 12762 00000EF1 E9E3F3                  	jmp	DOCOM1
 12763                                  
 12764                                  FORNESTERRJ:				; no multi-loop processing... yet!
 12765 00000EF4 E84601                  	call	FOROFF
 12766 00000EF7 E92901                  	jmp	FORNESTERR
 12767                                  
 12768                                  ; ---------------------------------------------------------------------------
 12769                                  
 12770                                  FORERRORJ:
 12771 00000EFA E9DDFB                  	jmp	FORERROR
 12772                                  
 12773                                  ; ---------------------------------------------------------------------------
 12774                                  
 12775                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F24h
 12776                                  
 12777                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12778                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 12779                                  
 12780                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12781                                  	; PCDOS 7.1 COMMAND.COM - TRANGROUP:1040h
 12782                                  _$FOR:
 12783 00000EFD 8E06[A58A]              	mov	es,[RESSEG]
 12784 00000F01 26803E[9401]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12785 00000F07 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12786                                  
 12787                                  ; Turn off any pipes in progress.
 12788                                  
 12789 00000F09 26803E[0102]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12790 00000F0F 7403                    	jz	short NO_PIPE
 12791 00000F11 E8D71D                  	call	PIPEDEL
 12792                                  NO_PIPE:
 12793 00000F14 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12794 00000F16 E8F400                  	call	NEXTARG			; move to next argv[n]
 12795 00000F19 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12796 00000F1B 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12797 00000F1D 75DB                    	jne	short FORERRORJ
 12798 00000F1F 89C5                    	mov	bp,ax			; save forloop variable
 12799 00000F21 AC                      	lodsb
 12800 00000F22 08C0                    	or	al,al			; and MUST end immediately...
 12801 00000F24 75D4                    	jnz	short FORERRORJ
 12802 00000F26 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12803 00000F29 72CF                    	jb	short FORERRORJ
 12804                                  	;and	ax,0DFDFh
 12805 00000F2B 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12806                                  	; 15/02/2023
 12807                                  	;cmp	ax,4E49h  	; MSDOS 5.0
 12808                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12809                                  	;cmp	ax,in_word	; MSDOS 5.0
 12810 00000F2E 3D494E                  	cmp	ax,'IN'
 12811 00000F31 75C7                    	jnz	short FORERRORJ
 12812 00000F33 AC                      	lodsb
 12813                                  
 12814                                  	; 15/02/2023
 12815                                  	; MSDOS 3.3
 12816                                  	;or	al,al			; it, too, must end right away
 12817                                  	;jz	short CHECKLPAREN
 12818                                  	;cmp	al,[LPAREN]
 12819                                  	;jnz	short FORERRORJ
 12820                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12821                                  	;add	word [bx],2
 12822                                  	;;add	word [bx+9],2
 12823                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12824                                  	;;sub	word [bx+5],2
 12825                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12826                                  	;mov	ax,[si-1]
 12827                                  	;jmp	short LPCHECK
 12828                                  
 12829                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12830                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12831                                  
 12832                                  	; MSDOS 6.0
 12833                                  ; Compaq bug fix -- exit from this loop on error
 12834                                  
 12835 00000F34 08C0                    	or	al,al
 12836 00000F36 75C2                    	jne	short FORERRORJ		; jump on error
 12837                                  
 12838                                  ;	je	short CHECKLPAREN
 12839                                  ;
 12840                                  ; Not null. Perhaps there are no spaces between this and the (:
 12841                                  ;   FOR %i in(foo bar...
 12842                                  ; Check for the Lparen here
 12843                                  ;
 12844                                  ;;	cmp	al,lparen
 12845                                  ;;	jnz	short FORERRORJ
 12846                                  ;
 12847                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12848                                  ; being there in the first place.
 12849                                  ;
 12850                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12851                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12852                                  ;;						; advance original string
 12853                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12854                                  ;
 12855                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12856                                  ; current value.
 12857                                  ;
 12858                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12859                                  ;;	jmp	short LPCHECK
 12860                                  ;
 12861                                  ; end of Compaq bug fix
 12862                                  
 12863                                  ; ---------------------------------------------------------------------------
 12864                                  
 12865                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12866                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12867                                  
 12868                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12869                                  CHECKLPAREN:
 12870 00000F38 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12871 00000F3B 72BD                    	jc	short FORERRORJ
 12872                                  LPCHECK:
 12873                                  	; 15/02/2023
 12874                                  	; MSDOS 5.0 (% MSDOS 6.0)
 12875                                  	;;cmp	al,[LPAREN]
 12876                                  	;cmp	al,lparen
 12877 00000F3D 3C28                    	cmp	al,'('
 12878 00000F3F 75B9                    	jne	short FORERRORJ
 12879 00000F41 80FC00                  	cmp	ah,0
 12880 00000F44 7410                    	je	short FOR_PAREN_TOKEN
 12881                                  	;;cmp	ah,[RPAREN]		; special case:  null list
 12882                                  	;cmp	ah,rparen
 12883 00000F46 80FC29                  	cmp	ah,')'
 12884 00000F49 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12885 00000F4B E953FE                  	jmp	FORTERM
 12886                                  FOR_LIST_NOT_EMPTY:
 12887                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12888 00000F4E FF07                    	inc	word [bx]		; Advance ptr past "("
 12889                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry
 12890 00000F50 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12891 00000F53 46                      	inc	si			; Inc si so check for ")" works
 12892 00000F54 EB0D                    	jmp	short FOR_LIST
 12893                                  
 12894                                  	;nop
 12895                                  FOR_PAREN_TOKEN:
 12896 00000F56 E8B400                  	call	NEXTARG			; what have we in our <list>?
 12897 00000F59 729F                    	jc	short FORERRORJ
 12898                                  	; 15/02/2023
 12899                                  	;;;cmp	ax,[RPAREN+1]
 12900                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12901                                  	;cmp	ax,nullrparen
 12902 00000F5B 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12903 00000F5E 7503                    	jne	short FOR_LIST
 12904 00000F60 E93EFE                  	jmp	FORTERM
 12905                                  
 12906                                  ;FORERORJJ:
 12907                                  	;jmp	FORERROR
 12908                                  
 12909                                  FOR_LIST:				; skip over rest of <list>
 12910 00000F63 89D1                    	mov	cx,dx			; first arg of <list>
 12911                                  
 12912                                  SKIP_LIST:
 12913                                  	;add	si,[bx+5]
 12914 00000F65 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12915 00000F68 83EE03                  	sub	si,3			; si = ptr to last char of token
 12916                                  	; 15/02/2023
 12917                                  	;;mov	al,[RPAREN]
 12918                                  	;mov	al,rparen
 12919 00000F6B B029                    	mov	al,')'
 12920 00000F6D 3804                    	cmp	[si],al			; Is this the last element in <list>
 12921 00000F6F 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12922 00000F71 E89900                  	call	NEXTARG			; No, get next arg <list>
 12923                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12924                                  	;jmp	short SKIP_LIST
 12925                                  	; 15/02/2023
 12926 00000F74 73EF                    	jnc	short SKIP_LIST
 12927                                  
 12928                                  	; 15/02/2023
 12929                                  FORERORJJ:
 12930 00000F76 E961FB                  	jmp	FORERROR
 12931                                  
 12932                                  FOR_END_LIST:
 12933 00000F79 89D7                    	mov	di,dx			; record position of last arg in <list>
 12934 00000F7B C60400                  	mov	byte [si],0		; Zap the rparen
 12935                                  	; 15/02/2023
 12936                                  	;;;cmp	ax,[RPAREN+1]
 12937                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12938                                  	;cmp	ax,nullparen
 12939 00000F7E 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12940 00000F81 7401                    	je	short FOR_DO		; Yes, continue
 12941 00000F83 47                      	inc	di			; No, inc position of last arg
 12942                                  FOR_DO:
 12943 00000F84 E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12944 00000F87 72ED                    	jc	short FORERORJJ
 12945                                  	;and	ax,0DFDFh
 12946 00000F89 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12947                                  	; 15/02/2023
 12948                                  	;;cmp	ax,[DO_WORD]
 12949                                  	;cmp	ax,do_word ; 4F44h
 12950 00000F8C 3D444F                  	cmp	ax,'DO'	 ; 4F44h
 12951 00000F8F 75E5                    	jne	short FORERORJJ
 12952 00000F91 AC                      	lodsb
 12953 00000F92 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12954 00000F94 75E0                    	jnz	short FORERORJJ
 12955                                  		
 12956 00000F96 E87400                  	call	NEXTARG			; on to the beginning of <command>
 12957 00000F99 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12958                                  
 12959 00000F9B 50                      	push	ax
 12960 00000F9C 53                      	push	bx
 12961 00000F9D 51                      	push	cx
 12962 00000F9E 52                      	push	dx			; preserve registers against disaster
 12963 00000F9F 57                      	push	di
 12964 00000FA0 56                      	push	si
 12965 00000FA1 55                      	push	bp
 12966 00000FA2 E85FF7                  	call	FREE_TPA		; need to make free memory, first
 12967 00000FA5 E89500                  	call	FOROFF
 12968                                  	;mov	bx,264
 12969 00000FA8 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12970 00000FAB E8C524                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12971 00000FAE 9C                      	pushf
 12972 00000FAF 26A3[9501]              	mov	[es:ForPtr],ax
 12973 00000FB3 E85EF7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12974 00000FB6 9D                      	popf
 12975 00000FB7 5D                      	pop	bp
 12976 00000FB8 5E                      	pop	si
 12977 00000FB9 5F                      	pop	di
 12978 00000FBA 5A                      	pop	dx
 12979 00000FBB 59                      	pop	cx
 12980 00000FBC 5B                      	pop	bx
 12981 00000FBD 58                      	pop	ax
 12982 00000FBE 723C                    	jc	short FOR_ALLOC_ERR
 12983                                  
 12984 00000FC0 06                      	push	es			; save resgroup seg...
 12985 00000FC1 26FF36[9501]            	push	word [es:ForPtr]
 12986 00000FC6 07                      	pop	es
 12987                                  	;assume es:for_segment
 12988 00000FC7 49                      	dec	cx			; forproc wants min pointing before
 12989 00000FC8 4F                      	dec	di			; first arg, max right at last one
 12990                                  	; 15/02/2023
 12991                                  	;;mov	[547h],cx
 12992                                  	; 27/07/2024
 12993                                  	;mov	[447h],cx ; PCDOS 7.1 COMMAND.COM
 12994 00000FC9 26890E4704              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12995                                  	;;mov	[549h],di
 12996                                  	;mov	[449h],di ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12997 00000FCE 26893E4904              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12998                                  	;;mov	[544h],dl
 12999                                  	;mov	[444h],dl ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13000 00000FD3 2688164404              	mov	[es:FOR_INFO.FOR_COM_START],dl
 13001                                  	;;mov	word [545h],0FFFFh ; -1
 13002                                  	;mov	[445h],0FFFFh ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13003 00000FD8 26C7064504FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 13004                                  					; non-zero means FALSE
 13005 00000FDF 89E8                    	mov	ax,bp
 13006                                  	;;mov	[64Bh],ah
 13007                                  	;mov	[54Bh],ah ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 13008 00000FE1 2688264B05              	mov	[es:FOR_INFO.FOR_VAR],ah
 13009 00000FE6 07                      	pop	es
 13010                                  	;assume es:resgroup
 13011 00000FE7 26FE06[9401]            	inc	byte [es:ForFlag]
 13012 00000FEC 26833E[8E01]FF          	cmp	word [es:SingleCom],-1
 13013 00000FF2 7507                    	jne	short FOR_RET
 13014 00000FF4 26C706[8E01]00FF        	mov	word [es:SingleCom],0FF00h
 13015                                  FOR_RET:
 13016 00000FFB C3                      	retn
 13017                                  
 13018                                  FOR_ALLOC_ERR:
 13019                                  	; 15/02/2023
 13020                                  	; MSDOS 3.3
 13021                                  	;mov	dx,INSFMEMMESPTR
 13022                                  	;jmp	CERROR
 13023                                  
 13024                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13025                                  	; MSDOS 6.0
 13026                                  	;mov	byte [msg_disp_class],1
 13027 00000FFC C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 13028                                  					;AN000; set up extended error msg class
 13029                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 13030 00001001 BA[FC7E]                	mov	dx,extend_buf_ptr
 13031                                  					;AC000; get extended message pointer
 13032                                  	;mov	word [extend_buf_ptr],8
 13033 00001004 C706[FC7E]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13034                                  					;AN000; get message number in control block
 13035 0000100A E94319                  	jmp	cerror
 13036                                  
 13037                                  
 13038                                  ; =============== S U B	R O U T	I N E =======================================
 13039                                  
 13040                                  NEXTARG:
 13041 0000100D 42                      	inc	dx			; next argv[n]
 13042                                  	;cmp	dx,[ARG_ARGVCNT]
 13043 0000100E 3B16[7090]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13044                                  					; make sure we don't run off end
 13045 00001012 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13046 00001014 89D3                    	mov	bx,dx
 13047                                  	;mov	ax,ARG_ARGV
 13048                                  	;mov	ax,ARG+ARG_UNIT.argv
 13049 00001016 B8[B08D]                	mov	ax,ARG
 13050 00001019 E83021                  	call	argv_calc		; convert array index to pointer
 13051 0000101C 8B37                    	mov	si,[bx]			; load pointer to argstring
 13052                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13053 0000101E AD                      	lodsw				; and load first two chars
 13054 0000101F F8                      	clc
 13055 00001020 C3                      	retn
 13056                                  NEXTARG_ERR:
 13057 00001021 F9                      	stc
 13058 00001022 C3                      	retn
 13059                                  
 13060                                  ; ---------------------------------------------------------------------------
 13061                                  
 13062                                  FORNESTERR:
 13063 00001023 1E                      	push	ds
 13064 00001024 8E1E[A58A]              	mov	ds,[RESSEG]
 13065                                  	;ASSUME DS:RESGROUP
 13066 00001028 BA[5A80]                	mov	dx,FORNESTMES_PTR
 13067 0000102B 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 13068 00001031 7506                    	jne	short NOFORP3
 13069 00001033 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13070                                  NOFORP3:
 13071 00001039 1F                      	pop	ds
 13072 0000103A E91319                  	jmp	cerror
 13073                                  
 13074                                  ; =============== S U B	R O U T	I N E =======================================
 13075                                  
 13076                                  ; General routine called to free the for segment. We also clear the forflag
 13077                                  ; too. Change no registers.
 13078                                  
 13079                                  FOROFF:
 13080 0000103D 50                      	push	ax
 13081 0000103E 06                      	push	es
 13082 0000103F 2E8E06[A58A]            	mov	es,[cs:RESSEG]
 13083 00001044 26A1[9501]              	mov	ax,[es:ForPtr]
 13084 00001048 09C0                    	or	ax,ax
 13085 0000104A 7408                    	jz	short FREEDONE
 13086 0000104C 06                      	push	es
 13087 0000104D 8EC0                    	mov	es,ax
 13088                                  	; 15/02/2023
 13089 0000104F B449                    	mov	ah,49h
 13090                                  	;mov	ah,DEALLOC ; 49h
 13091 00001051 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13092                                  			; ES = segment address of area to be freed
 13093 00001053 07                      	pop	es
 13094                                  FREEDONE:
 13095 00001054 26C706[9501]0000        	mov	word [es:ForPtr],0
 13096 0000105B 26C606[9401]00          	mov	byte [es:ForFlag],0
 13097 00001061 07                      	pop	es
 13098 00001062 58                      	pop	ax
 13099 00001063 C3                      	retn
 13100                                  
 13101                                  ;============================================================================
 13102                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13103                                  ;============================================================================
 13104                                  ; 09/10/2018 - Retro DOS v3.0
 13105                                  
 13106                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13107                                  
 13108                                  ; ---------------------------------------------------------------------------
 13109                                  
 13110                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13111                                  
 13112                                  %if 0
 13113                                  
 13114                                  ; The DIR command displays the contents of a directory.
 13115                                  ;
 13116                                  ; ****************************************************************
 13117                                  ; *
 13118                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13119                                  ; *
 13120                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13121                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13122                                  ; *		 If an error occurs issue and error message and
 13123                                  ; *		 transfer control to CERROR.
 13124                                  ; *
 13125                                  ; * INPUT:	 command line at offset 81H
 13126                                  ; *
 13127                                  ; * OUTPUT:	 none
 13128                                  ; *
 13129                                  ; ****************************************************************
 13130                                  
 13131                                  CATALOG:
 13132                                  	; MSDOS 3.3
 13133                                  
 13134                                  	;mov	ax,ARG_ARGV
 13135                                  	;mov	ax,ARG+ARG_UNIT.argv
 13136                                  	mov	ax,ARG
 13137                                  	mov	dx,0FFFFh
 13138                                  	xor	cx,cx
 13139                                  	xor	si,si
 13140                                  DIR1:
 13141                                  	;cmp	cx,[ARG_ARGVCNT]
 13142                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13143                                  	jnb	short DIR6 ; No more arguments
 13144                                  	mov	bx,cx
 13145                                  	call	ARGV_CALC
 13146                                  	;or	si,[bx+7]
 13147                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13148                                  	test	si,7FFCh  ; test si,~8003
 13149                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13150                                  	;test	byte [bx+2],1
 13151                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13152                                  	jz	short DIR3
 13153                                  	jmp	short DIR5
 13154                                  DIR2:
 13155                                  	mov	dx,BADPARMPTR
 13156                                  	jmp	CERROR
 13157                                  DIR3:
 13158                                  	or	cx,cx
 13159                                  	jnz	short DIR4	
 13160                                  	;cmp	word [bx+5],3
 13161                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13162                                  	jz	short DIR5
 13163                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13164                                  	add	word [bx],3
 13165                                  	;add	word [bx+9],3
 13166                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13167                                  	;add	word [bx+3],3
 13168                                  	add	word [bx+ARGV_ELE.argstartel],3
 13169                                  	;sub	word [bx+5],3
 13170                                  	sub	word [bx+ARGV_ELE.arglen],3
 13171                                  DIR4:
 13172                                  	cmp	dx,0FFFFh
 13173                                  	jnz	short DIR2
 13174                                  	mov	dx,bx
 13175                                  DIR5:
 13176                                  	inc	cx
 13177                                  	jmp	short DIR1
 13178                                  DIR6:
 13179                                  	mov	[COMSW],si
 13180                                  	push	dx
 13181                                  	xor	al,al
 13182                                  	cmp	dx,0FFFFh
 13183                                  	jz	short DIR7
 13184                                  	mov	bx,dx
 13185                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13186                                  	mov	di,[bx]
 13187                                  	cmp	byte [di+1],':'
 13188                                  	jnz	short DIR7
 13189                                  	mov	al,[di]
 13190                                  	or	al,20h		; Lowercase drive name	
 13191                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13192                                  DIR7:
 13193                                  	;mov	[5CH],al
 13194                                  	mov	[FCB],al
 13195                                  	call	OKVOLARG
 13196                                  	mov	al,'?'		; *.* is default file spec.
 13197                                  	;mov	di,5Dh
 13198                                  	mov	di,FCB+1
 13199                                  	mov	cx,11
 13200                                  	rep stosb
 13201                                  
 13202                                  ; Begin by processing any switches that may have been specified.
 13203                                  ; BITS will contain any information about switches that was
 13204                                  ; found when the command line was parsed.
 13205                                  
 13206                                  	mov	ax,[COMSW]	; Get switches from command
 13207                                  	mov	[_BITS],ax	; initialize switches
 13208                                  	mov	word [COMSW],0	; initialize flags
 13209                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13210                                  	;test	al,1
 13211                                  	test	al,SWITCHW	; /W ?
 13212                                  	;mov	al,1
 13213                                  	mov	al,NORMPERLIN
 13214                                  	jz	short DIR8
 13215                                  	;mov	al,5
 13216                                  	mov	al,WIDEPERLIN
 13217                                  DIR8:
 13218                                  	mov	[LINLEN],al	; Set number of entries per line
 13219                                  	mov	[LINCNT],al
 13220                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13221                                  	mov	dx,DIRBUF
 13222                                  	mov	ah,Set_DMA ; 1Ah
 13223                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13224                                  			; DS:DX	-> disk	transfer buffer
 13225                                  	;mov	dl,[5Ch]
 13226                                  	mov	dl,[FCB]
 13227                                  	call	SAVUDIR
 13228                                  	pop	bx
 13229                                  	cmp	bx,0FFFFh
 13230                                  	jz	short DIR9
 13231                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13232                                  	mov	dx,[bx]
 13233                                  
 13234                                  ; The user may have specified a device. Search for the path and see if the
 13235                                  ; attributes indicate a device.
 13236                                  
 13237                                  	mov	ah,Find_First ; 4Eh
 13238                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13239                                  			; CX = search attributes
 13240                                  			; DS:DX	-> ASCIZ filespec
 13241                                  			; (drive,path, and wildcards allowed)
 13242                                  	jc	short DIR10
 13243                                  			; Check device atrribute..
 13244                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13245                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13246                                  	; 14/10/2018
 13247                                  	;test	byte [DIRBUF+21],40h
 13248                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13249                                  	jz	short DIR10	; no, go do normal operation
 13250                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13251                                  DIR9:
 13252                                  	jmp	short DOHEADER
 13253                                  DIR10:
 13254                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13255                                  	mov	dx,[bx]
 13256                                  	mov	ah,CHDir ; 3Bh
 13257                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13258                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13259                                  	jnc	short DOHEADER
 13260                                  	;mov	si,[bx+3]
 13261                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13262                                  	cmp	dx,si
 13263                                  	jz	short DIR_NO_DRIVE
 13264                                  	xor	cl,cl
 13265                                  	xchg	cl,[si]
 13266                                  	mov	ah,CHDir ; 3Bh
 13267                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13268                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13269                                  	xchg	cl,[si]
 13270                                  	jnc	short DIR_NO_DRIVE
 13271                                  	mov	al,[si-1]
 13272                                  	call	PATHCHRCMP
 13273                                  	jnz	short DIR11
 13274                                  	mov	al,[si-2]
 13275                                  	call	PATHCHRCMP
 13276                                  	jz	short DIR12
 13277                                  	xchg	cl,[si-1]
 13278                                  	mov	ah,CHDir ; 3Bh
 13279                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13280                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13281                                  	xchg	cl,[si-1]
 13282                                  	jnc	short DIR_NO_DRIVE
 13283                                  DIR11:
 13284                                  	mov	ch,':'
 13285                                  	cmp	ch,[si-1]
 13286                                  	jnz	short DIR12
 13287                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13288                                  	mov	cx,[bx]
 13289                                  	xchg	cx,si
 13290                                  	sub	cx,si
 13291                                  	cmp	cx,2
 13292                                  	jz	short DIR_NO_DRIVE
 13293                                  DIR12:
 13294                                  	mov	dx,BADCDPTR
 13295                                  	;test	byte [bx+2],4
 13296                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13297                                  	jnz	short DIRERROR
 13298                                  DIRNF:
 13299                                  	mov	dx,FNOTFOUNDPTR
 13300                                  DIRERROR:
 13301                                  	jmp	CERROR
 13302                                  DIR_NO_DRIVE:
 13303                                  	cmp	word [si],'..'
 13304                                  	jnz	short DOREALPARSE
 13305                                  	cmp	byte [si+2],0
 13306                                  	jnz	short DOREALPARSE
 13307                                  	inc	word [COMSW]
 13308                                  	jmp	short DOHEADER
 13309                                  DOREALPARSE:
 13310                                  	mov	di,FCB ; 5Ch	
 13311                                  	;mov	ax,290Eh
 13312                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13313                                  	int	21h	; DOS -	PARSE FILENAME
 13314                                  			; DS:SI	-> string to parse
 13315                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13316                                  			; AL = bit mask	to control parsing
 13317                                  	cmp	byte [si],0
 13318                                  	jz	short DOHEADER
 13319                                  	dec	word [COMSW]
 13320                                  DOHEADER:
 13321                                  		
 13322                                  ; Display the header
 13323                                  
 13324                                  	push	bx
 13325                                  	call	BUILD_DIR_STRING
 13326                                  	mov	dx,DIRBUF
 13327                                  	mov	[VOL_DIR],dx
 13328                                  	mov	dx,DIRHEADPTR
 13329                                  	call	PRINTF_CRLF
 13330                                  	pop	bx
 13331                                  	cmp	bx,0FFFFh
 13332                                  	jz	short DOSEARCH
 13333                                  
 13334                                  ; If there were chars left after parse or device, then invalid file name
 13335                                  
 13336                                  	cmp	word [COMSW],0
 13337                                  	jz	short DOSEARCH	; nothing left; good parse
 13338                                  	jl	short DIRNFFIX	; not .. => error file not found
 13339                                  	call	RESTUDIR
 13340                                  	mov	dx,BADCDPTR
 13341                                  	jmp	CERROR		; was .. => error directory not found
 13342                                  DIRNFFIX:
 13343                                  	call	RESTUDIR
 13344                                  	jmp	short DIRNF
 13345                                  
 13346                                  ; We are assured that everything is correct. Let's go and search. Use
 13347                                  ; attributes that will include finding directories. Perform the first search
 13348                                  ; and reset our directory afterward.
 13349                                  
 13350                                  DOSEARCH:
 13351                                  	;mov	byte [55h],0FFh
 13352                                  	mov	byte [FCB-7],0FFh
 13353                                  	;mov	byte [5Bh],10h
 13354                                  	mov	byte [FCB-1],10h
 13355                                  
 13356                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13357                                  ; the directory information as an extended FCB. We must bias all fetches into
 13358                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13359                                  
 13360                                  	mov	ah,Dir_Search_First ; 11h
 13361                                  	mov	dx,FCB-7 ; 55h
 13362                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13363                                  			; DS:DX	-> FCB
 13364                                  
 13365                                  ; Restore the user's directory. We preserve, though, the return from the
 13366                                  ; previous system call for later checking.
 13367                                  
 13368                                  FOUND_FIRST_FILE:
 13369                                  	push	ax		; save return state
 13370                                  	call	RESTUDIR	; restore user's dir	
 13371                                  	pop	ax		; get return state back
 13372                                  
 13373                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13374                                  ; no more.
 13375                                  
 13376                                  DIRSTART:
 13377                                  	inc	al		; 0FFh = file not found
 13378                                  	jnz	short DISPLAY	; Either an error or we are finished
 13379                                  	jmp	CHKCNT
 13380                                  DISPLAY:
 13381                                  	inc	word [FILECNT]	; Keep track of how many we find
 13382                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13383                                  	;call	SHONAME
 13384                                  	call	DISPLAYNAME
 13385                                  	;test	byte [_BITS],1
 13386                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13387                                  	jz	short DIRTEST	; If so, no size, date, or time
 13388                                  	jmp	NEXENT
 13389                                  DIRTEST:
 13390                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13391                                  	; 14/10/2018
 13392                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13393                                  	;test	byte [DIRBUF+19],10h
 13394                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13395                                  	jz	short FILEENT
 13396                                  	mov	dx,DMESPTR
 13397                                  	call	STD_PRINTF
 13398                                  	jmp	short NOFSIZ
 13399                                  FILEENT:
 13400                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13401                                  	;mov	dx,[DIRBUF+36]
 13402                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13403                                  	mov	[FILESIZE_L],dx
 13404                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13405                                  	;mov	dx,[DIRBUF+38]
 13406                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13407                                  	mov	[FILESIZE_H],dx
 13408                                  	mov	dx,FSIZEMESPTR
 13409                                  	call	STD_PRINTF	; Print size of file
 13410                                  NOFSIZ:
 13411                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13412                                  	;mov	ax,[DIRBUF+32]
 13413                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13414                                  	or	ax,ax
 13415                                  	jz	short NEXENT	; Skip if no date
 13416                                  	mov	di,CHARBUF
 13417                                  	push	ax
 13418                                  	mov	ax,'  '
 13419                                  	stosw
 13420                                  	pop	ax
 13421                                  	mov	bx,ax
 13422                                  	and	ax,1Fh		; Get day
 13423                                  	mov	dl,al
 13424                                  	mov	ax,bx
 13425                                  	mov	cl,5
 13426                                  	shr	ax,cl		; Align month
 13427                                  	and	al,0Fh		; Get month
 13428                                  	mov	dh,al
 13429                                  	mov	cl,bh
 13430                                  	shr	cl,1		; Align year
 13431                                  	xor	ch,ch
 13432                                  	add	cx,80		; Relative 1980
 13433                                  	cmp	cl,100
 13434                                  	jb	short MILLENIUM
 13435                                  	sub	cl,100
 13436                                  MILLENIUM:
 13437                                  	call	DATE_CXDX
 13438                                  	;mov	cx,[DIRBUF_FTIME]
 13439                                  	;mov	cx,[DIRBUF+30]
 13440                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13441                                  	jcxz	PRBUF		; Time field present?
 13442                                  	mov	ax,2020h
 13443                                  	stosw
 13444                                  	shr	cx,1
 13445                                  	shr	cx,1
 13446                                  	shr	cx,1
 13447                                  	shr	cl,1
 13448                                  	shr	cl,1		; Hours in CH, minutes in CL
 13449                                  	mov	bl,[TIME_24]
 13450                                  	or	bl,80h		; Tell P_TIME called from DIR
 13451                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13452                                  PRBUF:
 13453                                  	xor	ax,ax
 13454                                  	stosb
 13455                                  	mov	dx,CHARBUF
 13456                                  	mov	[STRING_PTR_2],dx
 13457                                  	mov	dx,STRINGBUF2PTR
 13458                                  	call	STD_PRINTF
 13459                                  NEXENT:
 13460                                  	dec	byte [LINCNT]
 13461                                  	jnz	short SAMLIN
 13462                                  NEXLIN:
 13463                                  	mov	al,[LINLEN]
 13464                                  	mov	[LINCNT],al
 13465                                  	call	CRLF2
 13466                                  	dec	byte [LINPERPAG]
 13467                                  	jnz	short SCROLL
 13468                                  	;test	byte [_BITS],2
 13469                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13470                                  	jz	short SCROLL	; If not, just continue
 13471                                  	mov	byte [LINPERPAG],23
 13472                                  	call	PAUSE
 13473                                  	jmp	short SCROLL
 13474                                  SAMLIN:
 13475                                  	mov	dx,TABPTR	; Output a tab
 13476                                  	call	STD_PRINTF
 13477                                  SCROLL:
 13478                                  	mov	ah,Dir_Search_Next ; 12h
 13479                                  	;mov	dx,55h
 13480                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13481                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13482                                  			; DS:DX	-> FCB
 13483                                  			; Return: AL = status
 13484                                  	jmp	DIRSTART
 13485                                  CHKCNT:
 13486                                  	test	word [FILECNT],0FFFFh ; -1
 13487                                  	jnz	short TRAILER
 13488                                  	jmp	DIRNF
 13489                                  TRAILER:
 13490                                  	mov	al,[LINLEN]
 13491                                  	cmp	al,[LINCNT]
 13492                                  	jz	short MMESSAGE
 13493                                  	call	CRLF2
 13494                                  MMESSAGE:
 13495                                  	mov	dx,DIRMESPTR
 13496                                  	mov	si,[FILECNT]
 13497                                  	mov	[DIR_NUM],si
 13498                                  	call	STD_PRINTF
 13499                                  DTFREE:
 13500                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13501                                  	;mov	dl,[5Ch]
 13502                                  	mov	dl,[FCB]
 13503                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13504                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13505                                  	cmp	ax,-1
 13506                                  	jnz	short DTFREE1
 13507                                  DTRET:
 13508                                  	retn
 13509                                  DTFREE1:
 13510                                  	mul	cx
 13511                                  	mul	bx
 13512                                  	mov	[BYTES_FREE],ax
 13513                                  	mov	[BYTES_FREE+2],dx
 13514                                  	mov	dx,BYTEMESPTR
 13515                                  	jmp	STD_PRINTF
 13516                                  
 13517                                  ; =============== S U B	R O U T	I N E =======================================
 13518                                  
 13519                                  SHONAME:
 13520                                  DISPLAYNAME:
 13521                                  	; MSDOS 3.3
 13522                                  	mov	di,CHARBUF
 13523                                  	mov	cx,8
 13524                                  	rep	movsb
 13525                                  	mov	al,' '
 13526                                  	stosb
 13527                                  	mov	cx,3
 13528                                  	rep	movsb
 13529                                  	xor	ax,ax
 13530                                  	stosb
 13531                                  	push	dx
 13532                                  	mov	dx,CHARBUF
 13533                                  	mov	[STRING_PTR_2],dx
 13534                                  	mov	dx,STRINGBUF2PTR
 13535                                  	call	STD_PRINTF
 13536                                  	pop	dx
 13537                                  	retn
 13538                                  
 13539                                  %endif
 13540                                  
 13541                                  ;============================================================================
 13542                                  ; DIR.ASM, MSDOS 6.0, 1991
 13543                                  ;============================================================================
 13544                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13545                                  
 13546                                  	; MSDOS 6.0
 13547                                  %if 0
 13548                                  
 13549                                  ;***	DIR.ASM - DIR internal command
 13550                                  
 13551                                  comment	% =================================================================
 13552                                  
 13553                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13554                                  "PART4 COMMAND Transient routines".
 13555                                  
 13556                                  From residual documentation, I surmise that TCMD.ASM originally
 13557                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13558                                  VER.  The file seems to have been successively split:
 13559                                  
 13560                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13561                                  
 13562                                  TCMD1A.ASM contained only the DIR command.
 13563                                  
 13564                                  Usage:
 13565                                  ------
 13566                                  
 13567                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13568                                  
 13569                                  DIR /?
 13570                                  
 13571                                  
 13572                                  <filespec> may include any or none of:  drive; directory path;
 13573                                             wildcarded filename.  If drive or directory path are
 13574                                  	   omitted, the current defaults are used.  If the
 13575                                  	   file name or extension is omitted, wildcards are
 13576                                  	   assumed.
 13577                                  
 13578                                  /w	Wide listing format.  Files are displayed in compressed
 13579                                  	'name.ext' format.  Subdirectory files are enclosed in
 13580                                  	brackets, '[dirname]'.
 13581                                  
 13582                                  /p	Paged, or prompted listing.  A screenful is displayed
 13583                                  	at a time.  The name of the directory being listed appears
 13584                                  	at the top of each page.
 13585                                  
 13586                                  	Bugbug:  pages nead to be uniform length..?
 13587                                  
 13588                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13589                                  	listed in compressed 'name.ext' format, one per line,
 13590                                  	without additional information.  Good for making batch
 13591                                  	files or for piping.  When used with /s, complete
 13592                                  	pathnames are listed.
 13593                                  
 13594                                  /s	Descend subdirectory tree.  Performs command on current
 13595                                  	or specified directory, then for each subdirectory below
 13596                                  	that directory.  Directory header and footer is displayed
 13597                                  	for each directory where matching files are found, unless
 13598                                  	used with /b.  /b suppresses headers and footers.
 13599                                  
 13600                                  	Tree is explored depth first, alphabetically within the
 13601                                  	same level.
 13602                                  
 13603                                  	Bugbug:  hidden directories aren't searched.
 13604                                  
 13605                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13606                                  
 13607                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13608                                  	compressed volume.
 13609                                  
 13610                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13611                                  	extension).  A sort order may be specified after /o.  Any of
 13612                                  	the following characters may be used: nedsgc (name, extension,
 13613                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13614                                  	a '-' before any letter causes a downward sort on that field.
 13615                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13616                                  	then within each extension sort by date and time in reverse
 13617                                  	chronological order.
 13618                                  
 13619                                  /a	Attribute selection.  Without /a, hidden and system files
 13620                                  	are suppressed from the listing.  With /a alone, all files
 13621                                  	are listed.  An attribute list may follow /a, consisting of
 13622                                  	any of the following characters:  hsdar (hidden, system,
 13623                                  	directory, archive, read-only).  A '-' before any letter
 13624                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13625                                  	are marked read-only and are not directory files.  Note
 13626                                  	that hidden or system files may be included in the listing.
 13627                                  	They are suppressed without /a but are treated like any other
 13628                                  	attribute with /a.
 13629                                  
 13630                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13631                                  
 13632                                  /h has been removed.					;M008
 13633                                  
 13634                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13635                                  	DIR command line.  Any command line options may be specified
 13636                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13637                                  	A filespec may be specified in DIRCMD and will be used unless
 13638                                  	a filespec is specified on the command line.  Any switch
 13639                                  	specified in DIRCMD may be overridden on the command line.
 13640                                  	If the original DIR default action is desired for a particular
 13641                                  	switch, the switch letter may be preceded by a '-' on the
 13642                                  	command line.  E.g.,
 13643                                  
 13644                                  	  /-w	use long listing format
 13645                                  	  /-p	don't page the listing
 13646                                  	  /-b	don't use bare format
 13647                                  	  /-s	don't descend subdirectory tree
 13648                                  	  /-o	display files in disk order
 13649                                  	  /-a	suppress hidden and system files
 13650                                  
 13651                                  Notes:
 13652                                  ------
 13653                                  
 13654                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13655                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13656                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13657                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13658                                  a flag byte which is made zero when the entry is loaded, and made one
 13659                                  when the entry is used.
 13660                                  
 13661                                  Revision History
 13662                                  ================
 13663                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13664                                  				in the absence of ANSI.SYS
 13665                                  
 13666                                  M007	sa	8/1/90		Allow /p/b combination
 13667                                  
 13668                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13669                                  				to internally handle /? message.
 13670                                  
 13671                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13672                                  
 13673                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13674                                  				first FCB with the drive number when the drive
 13675                                  				letter in the command line is preceded by a
 13676                                  				switch.  Now dir manually loads the drive
 13677                                  				number after parsing.
 13678                                  
 13679                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13680                                  				from the ROM BIOS.
 13681                                  
 13682                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13683                                  				a subdirectory having len(pathname)>MAXPATH.
 13684                                  				Just skip over that subdirectory.
 13685                                  
 13686                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13687                                  				byte value, rather than collating table.
 13688                                  				This to match MS-DOS Shell's sort order.
 13689                                  
 13690                                  ========================================================================= %
 13691                                  
 13692                                  %endif
 13693                                  
 13694                                  ; 16/02/2023
 13695                                  
 13696                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13697                                  
 13698                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13699                                  ;
 13700                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13701                                  ;		(order is hard-coded; see OnOffSw)
 13702                                  ;		Inmem is set when entries are loaded in memory.
 13703                                  
 13704                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13705                                  mask.wide  equ 1
 13706                                  mask.pagd  equ 2
 13707                                  mask.subd  equ 4
 13708                                  mask.bare  equ 8
 13709                                  mask.lcase equ 16
 13710                                  mask.inmem equ 32
 13711                                  ;
 13712                                  mask.dev    equ 1
 13713                                  mask.baddir equ 2	
 13714                                  
 13715                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13716                                  
 13717                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13718                                  
 13719                                  ;ResultBuffer	struc		; structure of parse result buffer
 13720                                  ;ValueType	db	?
 13721                                  ;ValueTag	db	?
 13722                                  ;SynPtr		dw	?
 13723                                  ;ValuePtr	dd	?
 13724                                  ;ResultBuffer	ends
 13725                                  
 13726                                  ;ErrorRec	record	baddir:1,dev:1
 13727                                  ;
 13728                                  ;		Error bits are:
 13729                                  ;		  Invalid directory format
 13730                                  ;		  File is device
 13731                                  
 13732                                  ;EntryStruc	struc			; our private directory entry structure
 13733                                  ;used		db	?		; =0 until entry used, then =1
 13734                                  ;filename	db	8 dup (?)	; filename
 13735                                  ;fileext	db	3 dup (?)	; extension
 13736                                  ;fileattr	db	?		; file attributes
 13737                                  ;filetime	dw	?		; file time
 13738                                  ;filedate	dw	?		; file date
 13739                                  ;filesize	dd	?		; file size
 13740                                  ;EntryStruc	ends
 13741                                  
 13742                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13743                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13744                                  ;	push	ax
 13745                                  ;	endm
 13746                                  
 13747                                  ;	public	Catalog		; our entry point
 13748                                  ;
 13749                                  ;	break	<DIR (Catalog) principal routines>
 13750                                  ;
 13751                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13752                                  ; ---------------------------------------------------------------------------
 13753                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13754                                  
 13755                                  ;----------------------------------------------------------------------------
 13756                                  ;----------------------------------------------------------------------------
 13757                                  
 13758                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13759                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13760                                  
 13761                                  ;***	Catalog - DIR command main routine
 13762                                  ;
 13763                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13764                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13765                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13766                                  ;		Tpa = TPA buffer seg addr
 13767                                  ;		BytCnt = # bytes in TPA buffer
 13768                                  ;
 13769                                  ;	EXIT	nothing
 13770                                  ;
 13771                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13772                                  ;
 13773                                  ;	ERROR EXITS
 13774                                  ;
 13775                                  ;	  Errors are handled by setting up error message pointers
 13776                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13777                                  ;	   the environment variable, however, are handled by printing
 13778                                  ;	   an error message and continuing.
 13779                                  ;
 13780                                  ;	EFFECTS
 13781                                  ;
 13782                                  ;	  Directory listing is displayed (on standard output).
 13783                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13784                                  ;	   restore APPEND state.
 13785                                  ;	  Working directory may be changed. The user's default
 13786                                  ;	   directory is saved and flagged for restoration by RestUDir
 13787                                  ;	   during COMMAND cycle.
 13788                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13789                                  ;
 13790                                  ;	NOTES
 13791                                  ;
 13792                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13793                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13794                                  
 13795                                  	; 16/02/2023
 13796                                  CATALOG:
 13797 00001064 E8A400                  	call	SetDefaults
 13798 00001067 E8C800                  	call	ParseEnvironment
 13799 0000106A E8E000                  	call	ParseCmdLine
 13800 0000106D 7303                    	jnc	short catalog1	; no parse error
 13801 0000106F E99600                  	jmp	catErr		; error msg is set up
 13802                                  catalog1:
 13803 00001072 E80901                  	call	SetOptions
 13804 00001075 E8DF00                  	call	SetCollatingTable
 13805                                  
 13806                                  ;	Drive # to operate on has already been placed in FCB by
 13807                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13808                                  
 13809                                  	;;;test	Bits,mask bare
 13810                                  	;;test 	word [_Bits],8
 13811                                  	;test	byte [_Bits],8
 13812 00001078 F606[FC8B]08            	test	byte [_Bits],mask.bare
 13813 0000107D 750A                    	jnz	short catalog2	; don't display volume info for /b
 13814                                  	;invoke	OkVolArg	; find & display volume info
 13815 0000107F E8E00B                  	call	OkVolArg
 13816                                  	;sub	byte [LeftOnpage],2
 13817 00001082 832E[CB8A]02            	sub	word [LeftOnPage],2
 13818                                  				; record display lines used by volume info
 13819 00001087 EB14                    	jmp	short catCrunch
 13820                                  
 13821                                  ;	OkVolArg side effects:
 13822                                  ;	APPEND is disabled;
 13823                                  ;	DTA established at DirBuf;
 13824                                  ;	Filename fields in FCB are wildcarded.
 13825                                  
 13826                                  catalog2:
 13827                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13828                                  
 13829                                  	;invoke	DisAppend	; disable APPEND
 13830 00001089 E8A30B                  	call	DisAppend
 13831                                  
 13832                                  	;mov	dx,offset TRANGROUP:DirBuf
 13833 0000108C BA[AA8B]                	mov	dx,DIRBUF
 13834 0000108F B41A                    	mov	ah,1Ah
 13835                                  	;mov	ah,Set_DMA
 13836 00001091 CD21                    	int	21h		; set DTA
 13837                                  
 13838                                  
 13839                                  	;mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13840                                  	;inc	di		; ES:DI = ptr to filename field of FCB
 13841                                  	; 28/07/2024
 13842 00001093 BF5D00                  	mov	di,FCB+1 ; 5Dh
 13843 00001096 B03F                    	mov	al,'?'		; AL = wildcard character
 13844 00001098 B90B00                  	mov	cx,11
 13845 0000109B F3AA                    	rep	stosb		; wildcard filename field
 13846                                  
 13847                                  catCrunch:
 13848 0000109D E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13849 000010A0 7230                    	jc	short catRecErr	; handle recorded or extended error
 13850                                  
 13851                                  ;	User's directory has been saved, we've changed to specified directory.
 13852                                  ;	ComSw = error bits for later use
 13853                                  ;	FCB contains parsed filename
 13854                                  
 13855                                  	;cmp	byte [COMSW],0
 13856 000010A2 833E[BA8A]00            	cmp	word [COMSW],0
 13857 000010A7 7529                    	jne	short catRecErr	; handle recorded error
 13858                                  
 13859 000010A9 E88701                  	call	InstallCtrlC	; install control-C handler
 13860 000010AC E8CD08                  	call	ZeroTotals	; zero grand totals
 13861 000010AF E84304                  	call	ListDir		; list main directory
 13862 000010B2 7244                    	jc	short catExtErr
 13863                                  
 13864                                  	;;;test	Bits,mask subd
 13865                                  	;;test	word [_Bits],4
 13866                                  	;test	byte [_Bits],4
 13867 000010B4 F606[FC8B]04            	test	byte [_Bits],mask.subd
 13868 000010B9 7405                    	jz	short catalog3	; subdirectories option not set
 13869 000010BB E88D01                  	call	ListSubds	; list subdirectories
 13870 000010BE 7238                    	jc	short catExtErr
 13871                                  catalog3:
 13872                                  ;	Check if any files were found.
 13873                                  
 13874                                  	;;;test	Bits,mask bare
 13875                                  	;;test	word [_Bits],8
 13876                                  	;test	byte [_Bits],8
 13877 000010C0 F606[FC8B]08            	test	byte [_Bits],mask.bare
 13878 000010C5 750A                    	jnz	short catRet	; don't bother for bare format
 13879                                  
 13880 000010C7 A1[D38A]                	mov	ax,[FileCntTotal]
 13881 000010CA 09C0                    	or	ax,ax
 13882 000010CC 7417                    	jz	short catNoFiles ; no files found
 13883                                  
 13884 000010CE E8A702                  	call	DisplayTotals	; display trailing grand totals
 13885                                  	;jmp	short catRet	; all done
 13886                                  	; 25/04/2023
 13887                                  catRet:
 13888 000010D1 C3                      	retn
 13889                                  
 13890                                  catRecErr:
 13891                                  
 13892                                  ;	ComSw may have error bit set. If not, do extended error.
 13893                                  
 13894                                  	;;;test	ComSw,mask dev
 13895                                  	;;test	word [COMSW],1
 13896                                  	;test	byte [COMSW],1
 13897 000010D2 F606[BA8A]01            	test	byte [COMSW],mask.dev
 13898 000010D7 750C                    	jnz	short catNoFiles 
 13899                                  				; filename is device, respond 'file not found'
 13900                                  	;;test	ComSw,mask baddir
 13901                                  	;;test	word [COMSW],2
 13902                                  	;test	byte [COMSW],2
 13903 000010D9 F606[BA8A]02            	test	byte [COMSW],mask.baddir
 13904 000010DE 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13905                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13906                                  				; invalid directory
 13907 000010E0 BA[3780]                	mov	dx,badcd_ptr
 13908 000010E3 EB23                    	jmp	short catErr
 13909                                  
 13910                                  catNoFiles:
 13911                                  
 13912                                  ;	Display header and force 'file not found' message.
 13913                                  
 13914 000010E5 E81107                  	call	DisplayHeader
 13915 000010E8 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13916 000010EB C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13917 000010F0 BA[FC7E]                	mov	dx,extend_buf_ptr
 13918 000010F3 A3[FC7E]                	mov	[extend_buf_ptr],ax
 13919 000010F6 EB10                    	jmp	short catErr
 13920                                  
 13921                                  catExtErr:
 13922                                  
 13923                                  ;	DOS has returned an error status. Get the extended error#, and
 13924                                  ;	set up an error message, changing 'No more files' error 
 13925                                  ;	to 'File not found' error.
 13926                                  
 13927 000010F8 E8E50B                  	call	Set_Ext_Error_Msg
 13928 000010FB 833E[FC7E]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13929 00001100 7506                    	jne	short catalog4  ; catErr
 13930 00001102 C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13931                                  catalog4:
 13932                                  
 13933                                  ;	Error exit. Error message information has been set up
 13934                                  ;	for Std_EPrintf.
 13935                                  
 13936                                  catErr:
 13937 00001108 E94518                  	jmp	cerror		; go to COMMAND error recycle point
 13938                                  
 13939                                  	; 25/04/2023
 13940                                  ;catRet:
 13941                                  	;retn
 13942                                  
 13943                                  ; ---------------------------------------------------------------------------
 13944                                  
 13945                                  ;***	SetDefaults - set default pathname, options
 13946                                  ;
 13947                                  ;	ENTRY	DS = TRANGROUP seg addr
 13948                                  ;
 13949                                  ;	EXIT	nothing
 13950                                  ;
 13951                                  ;	USED	AX,DI
 13952                                  ;
 13953                                  ;	EFFECTS
 13954                                  ;	  SrcBuf = '*',EOL - default pathname
 13955                                  ;	  PathPos = ptr to pathname
 13956                                  ;	  PathCnt = length of pathname
 13957                                  
 13958                                  	; 16/02/2023
 13959                                  SetDefaults:
 13960 0000110B BF[908C]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13961 0000110E 893E[008C]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13962                                  	;mov	al,STAR
 13963 00001112 B02A                    	mov	al,'*'
 13964 00001114 AA                      	stosb
 13965                                  	;mov	al,END_OF_LINE_IN
 13966 00001115 B00D                    	mov	al,0Dh ; cr
 13967 00001117 AA                      	stosb				; SrcBuf = '*',0Dh
 13968 00001118 C706[FE8B]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13969                                  
 13970 0000111E 31C0                    	xor	ax,ax			; AX = 0
 13971 00001120 A3[BA8A]                	mov	[COMSW],ax		; = no error
 13972 00001123 A3[FC8B]                	mov	[_Bits],ax		; = options off
 13973 00001126 A2[2D8C]                	mov	[DestBuf],al		; = no sort
 13974 00001129 C606[048C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13975 0000112E A2[058C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13976                                  peRet:	; 25/04/2023
 13977 00001131 C3                      	retn
 13978                                  
 13979                                  ; ---------------------------------------------------------------------------
 13980                                  
 13981                                  ;***	ParseEnvironment - find and parse our environment variable
 13982                                  ;
 13983                                  ;	Find our environment variable and parse it. If a parse
 13984                                  ;	error occurs, issue an error message. The parse results
 13985                                  ;	up to the error will still have effect. Always leave
 13986                                  ;	the option variables in a useable state.
 13987                                  ;
 13988                                  ;	ENTRY	DS = TRANGROUP seg addr
 13989                                  ;
 13990                                  ;	EXIT	nothing
 13991                                  ;
 13992                                  ;	USED	AX,BX,CX,DX,SI,DI
 13993                                  ;
 13994                                  ;	EFFECTS
 13995                                  ;
 13996                                  ;	  Bits may contain new option settings.
 13997                                  ;	  DestBuf may contain new series of sort codes.
 13998                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13999                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14000                                  ;	  PathPos, PathCnt updated for new pathname.
 14001                                  ;
 14002                                  ;	  If a parse error occurred, an error message will be issued.
 14003                                  
 14004                                  	; 16/02/2023
 14005                                  ParseEnvironment:
 14006 00001132 E87603                  	call	GetEnvValue		; get environment variable value
 14007 00001135 72FA                    	jc	short peRet		; name not found in environment
 14008                                  
 14009                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 14010                                  
 14011 00001137 E8B904                  	call	Parse_Line		; parse environment value
 14012 0000113A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14013                                  	;cmp	ax,END_OF_LINE
 14014 0000113D 74F2                    	je	short peRet		; successful completion
 14015                                  
 14016                                  ;	Some kind of parse error occurred.
 14017                                  ;	We're set up for a Std_EPrintf call.
 14018                                  
 14019 0000113F E8873C                  	call	std_eprintf		; display the parse error
 14020                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 14021                                  					; restore default msg class
 14022 00001142 C606[FA7E]FF            	mov	byte [msg_disp_class],0FFh ; -1
 14023                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 14024 00001147 BA[3B81]                	mov	dx,errparsenv_ptr
 14025                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 14026                                  	;call	Printf_Crlf
 14027                                  	; 25/04/2023
 14028                                  	;retn
 14029 0000114A E9763C                  	jmp	Printf_Crlf
 14030                                  					;M008;Internal handling of /? removed
 14031                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14032                                  	; 25/04/2023
 14033                                  ;peRet:
 14034                                  	;retn
 14035                                  
 14036                                  ; ---------------------------------------------------------------------------
 14037                                  
 14038                                  ;***	ParseCmdLine - parse and record command line parameters
 14039                                  ;
 14040                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14041                                  ;		DS, ES, CS = TRANGROUP seg addr
 14042                                  ;
 14043                                  ;	EXIT	CY = set if parse error occurred
 14044                                  ;
 14045                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14046                                  ;		AX = system parser error code
 14047                                  ;		DX = ptr to message block
 14048                                  ;
 14049                                  ;	USED	AX,BX,CX,DX,SI,DI
 14050                                  ;
 14051                                  ;	EFFECTS
 14052                                  ;
 14053                                  ;	  Bits may contain new option settings.
 14054                                  ;	  DestBuf may contain new series of sort codes.
 14055                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14056                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14057                                  ;	  PathPos, PathCnt updated for new pathname.
 14058                                  ;
 14059                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14060                                  ;	  Msg_Disp_Class = parse error class
 14061                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14062                                  ;	  Message block (see DX) is set up for parse error message
 14063                                  
 14064                                  	; 16/02/2023
 14065                                  ParseCmdLine:
 14066 0000114D BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14067 00001150 E8A004                  	call	Parse_Line		; parse cmd line tail
 14068 00001153 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14069                                  	;;cmp	ax,END_OF_LINE
 14070                                  	; 25/04/2023
 14071                                  	;je	short pcOk		; parse completed successfully
 14072                                  
 14073                                  ;	A parse error occurred. We're all set up for message output.
 14074                                  
 14075                                  	; 25/04/2023
 14076                                  	; cf = 1 (ax < 0FFFFh)
 14077                                  	;stc		   		; return failure
 14078                                  	;jmp	short pcRet
 14079                                  	; 25/04/2023
 14080                                  	;retn
 14081                                  pcOk:
 14082                                  	; 25/04/2023
 14083                                  	;cf = 0 (ax = 0FFFFh)
 14084                                  	;clc				; return success
 14085                                  pcRet:
 14086 00001156 C3                      	retn
 14087                                  
 14088                                  ; ---------------------------------------------------------------------------
 14089                                  
 14090                                  ;***	SetCollatingTable - set up character collating table for sorting
 14091                                  ;
 14092                                  ;	If country is other than USA, try to get a collating table
 14093                                  ;	for character sorting. For USA, use straight byte values.
 14094                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14095                                  ;	by straight byte values in the USA for better performance.
 14096                                  ;
 14097                                  ;	ENTRY	ES = TRANGROUP seg addr
 14098                                  ;
 14099                                  ;	EXIT	nothing
 14100                                  ;
 14101                                  ;	USED	AX,BX,CX,DX,DI
 14102                                  ;
 14103                                  ;	EFFECTS
 14104                                  ;
 14105                                  ;	  If collating table is set -
 14106                                  ;	    CountryPtrId = 6.
 14107                                  ;	    CountryPtr points to collating table.
 14108                                  ;
 14109                                  ;	  Otherwise -
 14110                                  ;	    CountryPtrId = 0.
 14111                                  
 14112                                  SetCollatingTable:
 14113                                  
 14114                                  ;	Begin modification M028
 14115                                  
 14116                                  	;mov	dx,offset TRANGROUP:InternatVars
 14117                                  	;			; DS:DX = ptr to international info buffer
 14118 00001157 BA[FE94]                	mov	dx,INTERNATVARS
 14119 0000115A B80038                  	mov	ax,3800h
 14120                                  	;mov	ax,INTERNATIONAL << 8
 14121                                  	;;mov	ax,INTERNATIONAL shl 8
 14122                                  				; AX = 'Get current country info'
 14123 0000115D CD21                    	int	21h		; call DOS
 14124 0000115F 7217                    	jc	short scNoTable	; error - so don't collate
 14125                                  
 14126                                  ;	BX = country code
 14127                                  
 14128 00001161 83FB01                  	cmp	bx,1
 14129 00001164 7412                    	je	short scNoTable	; we're in USA, don't collate
 14130                                  
 14131                                  ;	End modification M028
 14132                                  
 14133                                  ;*	Country code is other than USA. Try to get a collating table.
 14134                                  
 14135 00001166 B80665                  	mov	ax,6506h
 14136                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14137                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14138                                  				; AH = 'Get Extended Country Info'
 14139                                  				; AL = 'Get Pointer to Collating Table'
 14140 00001169 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14141 0000116C B90500                  	mov	cx,5		; CX = length of info buffer
 14142 0000116F 89DA                    	mov	dx,bx		; DX = country ID = default
 14143                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14144 00001171 BF[1E95]                	mov	di,CountryPtrInfo
 14145                                  				; ES:DI = ptr to info buffer
 14146 00001174 CD21                    	int	21h		; call DOS
 14147 00001176 7305                    	jnc	short scRet	; success
 14148                                  
 14149                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14150                                  
 14151                                  scNoTable:			;M028
 14152 00001178 C606[1E95]00            	mov	byte [CountryPtrId],0
 14153                                  scRet:
 14154 0000117D C3                      	retn
 14155                                  
 14156                                  ; ---------------------------------------------------------------------------
 14157                                  
 14158                                  ;***	SetOptions - check and set options
 14159                                  ;
 14160                                  ;	ENTRY	nothing
 14161                                  ;
 14162                                  ;	EXIT	nothing
 14163                                  ;
 14164                                  ;	USED	AX,BX,CX,DX
 14165                                  ;
 14166                                  ;	EFFECTS
 14167                                  ;
 14168                                  ;	  Bits may contain modified option settings.
 14169                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14170                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14171                                  ;	  PerLine is set according to /w presence.
 14172                                  
 14173                                  	; 16/02/2023
 14174                                  SetOptions:
 14175                                  
 14176                                  ;	If bare listing requested, cancel wide listings.
 14177                                  
 14178                                  	;;;test	Bits,mask bare
 14179                                  	;;test	word [_Bits],8
 14180                                  	;test	byte [_Bits],8
 14181 0000117E F606[FC8B]08            	test	byte [_Bits],mask.bare
 14182 00001183 7405                    	jz	short setopts1
 14183                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14184                                  	;;and	word [_Bits],0FFFEh
 14185                                  	;;and	byte [_Bits],0FEh
 14186 00001185 8026[FC8B]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 14187                                  setopts1:
 14188                                  ;	Set # lines per display page.
 14189                                  
 14190                                  ;M01  Obtain screen height from ROM BIOS data area
 14191                                  ;
 14192                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14193                                  
 14194 0000118A 1E                      	push	ds
 14195                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14196 0000118B B84000                  	mov	ax,40h
 14197 0000118E 8ED8                    	mov	ds,ax			;
 14198                                  	;Assume	DS:ROMBIOS_DATA
 14199                                  
 14200                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14201 00001190 A08400                  	mov	al,[84h]
 14202 00001193 1F                      	pop	ds			;
 14203                                  	;Assume	DS:Trangroup
 14204                                  
 14205 00001194 08C0                    	or	al,al			; If zero specified
 14206 00001196 7502                    	jnz	short setopts2		;
 14207                                  
 14208                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14209 00001198 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14210                                  setopts2:
 14211 0000119A 30E4                    	xor	ah,ah
 14212                                  setopts3:
 14213 0000119C FEC0                    	inc	al			; height + 1 ;M018
 14214                                  
 14215 0000119E A3[778D]                	mov	[LinPerPag],ax		; set the rows now
 14216                                  
 14217                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14218                                  
 14219                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE
 14220                                  					; IOCTL for handles
 14221 000011A1 B80C44                  	mov	ax,440Ch
 14222                                  	;mov	bx,STDOUT		; handle #
 14223 000011A4 BB0100                  	mov	bx,1
 14224                                  	;mov	ch,IOC_SC		; screen
 14225 000011A7 B503                    	mov	ch,3
 14226                                  	;mov	cl,get_generic		; get display info
 14227 000011A9 B17F                    	mov	cl,7Fh
 14228 000011AB BA[678D]                	mov	dx,Display_Ioctl	; info block
 14229 000011AE CD21                    	int	21h			; call DOS
 14230                                  
 14231 000011B0 A1[778D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14232 000011B3 A3[CB8A]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14233                                  
 14234                                  ;	Set # entries per line.
 14235                                  
 14236                                  	;mov	byte [PerLine],NORMPERLIN
 14237                                  					; # entries per line without /w
 14238 000011B6 C606[CA8A]01            	mov	byte [PerLine],1
 14239                                  	;;;test	Bits,mask wide
 14240                                  	;;test	word [_Bits],1
 14241                                  	;test	byte [_Bits],1
 14242 000011BB F606[FC8B]01            	test	byte [_Bits],mask.wide
 14243 000011C0 7405                    	jz	short setopts4
 14244                                  	;mov	byte [PerLine],WIDEPERLIN
 14245                                  					; # entries per line with /w
 14246 000011C2 C606[CA8A]05            	mov	byte [PerLine],5
 14247                                  setopts4:
 14248                                  				;M011;start;The following code checks if a drive
 14249                                  				;letter has been parsed into SrcBuf, and if
 14250                                  				;so, the correct drive number is loaded into
 14251                                  				;the first FCB, at offset 5C.
 14252                                  
 14253                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14254 000011C7 803E[918C]3A            	cmp	byte [SrcBuf+1],':'
 14255 000011CC 750A                    	jne	short soRet
 14256                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14257 000011CE A0[908C]                	mov	al,[SrcBuf]
 14258                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14259 000011D1 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14260 000011D3 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14261 000011D5 A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14262                                  						;M011;end
 14263                                  soRet:
 14264 000011D8 C3                      	retn
 14265                                  
 14266                                  ; ---------------------------------------------------------------------------
 14267                                  
 14268                                  ;***	CrunchPath - analyze supplied or default pathname
 14269                                  ;
 14270                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14271                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14272                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14273                                  ;		 must have space for another char after the delimiter.
 14274                                  ;
 14275                                  ;	EXIT	CY = clear if no error
 14276                                  ;		We are changed to directory found in pathname
 14277                                  ;		Previous directory ready to be restored via RestUDir
 14278                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14279                                  ;
 14280                                  ;		If error occurred,
 14281                                  ;		CY = set
 14282                                  ;		ComSw = error bits (see ErrorRec)
 14283                                  ;		If ComSw not set,
 14284                                  ;		Ready for DOS Get Extended Error call
 14285                                  
 14286                                  	; 16/02/2023
 14287                                  CrunchPath:
 14288 000011D9 E8E101                  	call	FileIsDevice
 14289 000011DC 7507                    	jne	short crpath1	; not a device, skip ahead
 14290                                  	;;;or	ComSw,mask dev	; signal file is device
 14291                                  	;;or	word [COMSW],1
 14292                                  	;or	byte [COMSW],1
 14293 000011DE 800E[BA8A]01            	or	byte [COMSW],mask.dev
 14294 000011E3 EB2F                    	jmp	short cpErr	; return error
 14295                                  crpath1:
 14296 000011E5 FF36[008C]              	push	word [PathPos]	; save ptr to pathname
 14297 000011E9 C606[088C]FF            	mov	byte [DirFlag],-1
 14298                                  				; tell PathCrunch not to parse file into FCB
 14299 000011EE E88714                  	call	PathCrunch	; change to directory in pathname
 14300 000011F1 C606[088C]00            	mov	byte [DirFlag],0
 14301                                  				; reset our little flag
 14302 000011F6 5E                      	pop	si		; SI = ptr to pathname
 14303 000011F7 7208                    	jc	short cpNoDir	; didn't find directory path
 14304 000011F9 741A                    	jz	short cpRet	; found directory path w/ no filename
 14305                                  				;  - leave wildcard default in FCB and return
 14306                                  
 14307                                  ;*	We found a directory, and there was a filename attached.
 14308                                  ;	DestTail = ptr to ASCIIZ filename
 14309                                  
 14310 000011FB 8B36[2A8C]              	mov	si,[DestTail]	; SI = ptr to filename
 14311 000011FF EB28                    	jmp	short cpFile	; go parse the file into FCB
 14312                                  
 14313                                  ;*	PathCrunch failed to find a directory in the pathname.
 14314                                  ;
 14315                                  ;	Msg_Numb = error code
 14316                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14317                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14318                                  
 14319                                  cpNoDir:
 14320 00001201 A1[948D]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14321 00001204 09C0                    	or	ax,ax
 14322 00001206 750C                    	jnz	short cpErr	  ; error occurred - return it
 14323 00001208 803E[288C]00            	cmp	byte [DestIsDir],0
 14324 0000120D 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14325                                  crpath3:
 14326                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14327                                  	;;or	word [COMSW],2
 14328                                  	;or	byte [COMSW],2
 14329 0000120F 800E[BA8A]02            	or	byte [COMSW],mask.baddir
 14330                                  	;jmp	short cpErr	  ; return error
 14331                                  	; 16/02/2023
 14332                                  cpErr:
 14333 00001214 F9                      	stc			  ; return error
 14334                                  cpRet:
 14335 00001215 C3                      	retn
 14336                                  
 14337                                  cpMaybe:
 14338                                  ;	SI = ptr to pathname
 14339                                  
 14340                                  	;cmp	byte [si+1],COLON_CHAR
 14341 00001216 807C013A                	cmp	byte [si+1],':'
 14342 0000121A 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14343 0000121C AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14344                                  crpath2:
 14345 0000121D 813C2E2E                	cmp	word [si],".."
 14346 00001221 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14347 00001223 807C0200                	cmp	byte [si+2],0
 14348                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14349                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14350                                  	;;;or	word [COMSW],2
 14351                                  	;;or	byte [COMSW],2
 14352                                  	;or	byte [COMSW],mask.baddir
 14353                                  	;jmp	short cpErr	  ; return error
 14354                                  	; 16/02/2023
 14355 00001227 74E6                    	je	short crpath3
 14356                                  
 14357                                  ;	The preceding code was taken from the old DIR routine.
 14358                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14359                                  ;	occurring when we're at the root directory. Too bad it
 14360                                  ;	doesn't handle problems with "..\..", etc.
 14361                                  
 14362                                  ;	We're ready to parse a filename into the FCB.
 14363                                  ;	SI = ptr to ASCIIZ filename
 14364                                  
 14365                                  cpFile:	
 14366 00001229 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14367 0000122C B80E29                  	mov	ax,290Eh
 14368                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14369                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14370                                  				; wildcards already in FCB used as defaults
 14371 0000122F CD21                    	int	21h
 14372 00001231 F8                      	clc			; return success
 14373                                  	;jmp	short cpRet
 14374                                  	; 16/02/2023
 14375 00001232 C3                      	retn
 14376                                  
 14377                                  ;cpErr:
 14378                                  ;	stc			; return error
 14379                                  ;cpRet:
 14380                                  ;	retn
 14381                                  
 14382                                  ; ---------------------------------------------------------------------------
 14383                                  
 14384                                  ;***	InstallCtrlC - install our private control-C handler
 14385                                  ;
 14386                                  ;	Put our control-c handler in front of command.com's default
 14387                                  ;	handler, to make sure the user's default directory gets restored.
 14388                                  ;	This shouldn't be necessary, but, for now, there are situations
 14389                                  ;	where the TDATA segment is left in a modified state when a
 14390                                  ;	control-c occurs.  This means that the transient will be
 14391                                  ;	reloaded, and the user's directory cannot be restored.
 14392                                  ;
 14393                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14394                                  ;
 14395                                  ;	ENTRY	nothing
 14396                                  ;
 14397                                  ;	EXIT	nothing
 14398                                  ;
 14399                                  ;	USED	AX,BX,DX
 14400                                  ;
 14401                                  ;	EFFECTS
 14402                                  ;
 14403                                  ;	  CtrlCHandler address placed in int 23 vector.
 14404                                  ;
 14405                                  ;	NOTE
 14406                                  ;
 14407                                  ;	  Command.com's basic control-c handler will be restored
 14408                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14409                                  
 14410                                  	; 16/02/2023
 14411                                  InstallCtrlC:
 14412 00001233 06                      	push	es			; preserve ES
 14413 00001234 B82335                  	mov	ax,3523h
 14414                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14415                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14416 00001237 CD21                    	int	21h
 14417 00001239 891E[2395]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14418 0000123D 8C06[2595]              	mov	[OldCtrlCHandler+2],es	 
 14419 00001241 07                      	pop	es			; restore ES
 14420                                  
 14421 00001242 BA[8719]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14422 00001245 B82325                  	mov	ax,2523h
 14423                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14424                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14425 00001248 CD21                    	int	21h
 14426 0000124A C3                      	retn
 14427                                  
 14428                                  ; ---------------------------------------------------------------------------
 14429                                  
 14430                                  ;***	ListSubds - search and list files in subdirectories
 14431                                  ;
 14432                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14433                                  ;		FCB is still set up for file searches
 14434                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14435                                  ;
 14436                                  ;	EXIT	CY = clear if no error
 14437                                  ;		FileCnt = # files found & displayed
 14438                                  ;		FileSiz = total size of files found
 14439                                  ;
 14440                                  ;		If error,
 14441                                  ;		CY = set
 14442                                  ;		Ready for DOS Get Extended Error call
 14443                                  ;
 14444                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14445                                  ;
 14446                                  ;	EFFECTS
 14447                                  ;
 14448                                  ;	  FileCntTotal, FileSizTotal are updated.
 14449                                  ;	  Subdirectories may be listed on standard output device.
 14450                                  ;
 14451                                  ;	NOTES
 14452                                  ;
 14453                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14454                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14455                                  ;	   Each name is stored ASCIIZ.
 14456                                  
 14457                                  	; 16/02/2023
 14458                                  ListSubds:
 14459                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14460 0000124B E8911A                  	call	SetRest1
 14461                                  
 14462 0000124E BB[EA8C]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14463                                  lsNode:
 14464 00001251 C60700                  	mov	byte [bx],0		; start with null child name
 14465                                  lsLoop:
 14466 00001254 E8F001                  	call	FindNextChild		; search for next subdirectory
 14467 00001257 7235                    	jc	short lsErr		; search failed - examine error
 14468                                  
 14469 00001259 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14470 0000125B E84004                  	call	ChangeDir		; enter child directory
 14471                                  
 14472                                  					; M023;start
 14473 0000125E 7306                    	jnc	short lstsd1		; check for error
 14474                                  	;cmp	ax,3
 14475 00001260 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14476 00001263 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14477                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14478                                  	; 16/02/2023			; M023;end
 14479 00001265 C3                      	retn
 14480                                  lstsd1:	
 14481 00001266 53                      	push	bx
 14482 00001267 E88B02                  	call	ListDir			; list the directory
 14483 0000126A 5B                      	pop	bx
 14484                                  
 14485                                  ;	Note we're ignoring errors returned here.
 14486                                  
 14487 0000126B 89DF                    	mov	di,bx			; DI = ptr to child's name
 14488 0000126D B90D00                  	mov	cx,13			; CX = max name length w/ null
 14489 00001270 30C0                    	xor	al,al			; AL = zero byte to look for
 14490 00001272 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14491 00001274 53                      	push	bx			; save ptr to child's name
 14492 00001275 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14493 00001277 E8D7FF                  	call	lsNode			; recurse from new node
 14494 0000127A 5B                      	pop	bx			; BX = ptr to child's name
 14495 0000127B 9C                      	pushf				; save error condition
 14496                                  	
 14497                                  	;;shove	0
 14498                                  	;mov	ax,0
 14499 0000127C 29C0                    	sub	ax,ax ; 0
 14500 0000127E 50                      	push	ax
 14501                                  	;shove	".."
 14502 0000127F B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14503 00001282 50                      	push	ax
 14504 00001283 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14505 00001285 E81604                  	call	ChangeDir		; return to parent directory
 14506 00001288 58                      	pop	ax			; restore stack
 14507 00001289 58                      	pop	ax
 14508                                  
 14509 0000128A 9D                      	popf				; restore error condition from child
 14510                                  	;jc	short lsRet		; return error
 14511                                  	;jmp	short lsLoop		; look for more children
 14512                                  	; 16/02/2023
 14513 0000128B 73C7                    	jnc	short lsLoop
 14514 0000128D C3                      	retn
 14515                                  lsErr:
 14516 0000128E E85F0A                  	call	get_ext_error_number	; AX = extended error code
 14517                                  	;cmp	ax,2
 14518 00001291 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14519 00001294 7406                    	je	short lsRet		; file not found, we're ok
 14520                                  	;cmp	ax,18
 14521 00001296 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14522 00001299 7401                    	je	short lsRet		; no more files, we're ok
 14523 0000129B F9                      	stc				; return other errors
 14524                                  lsRet:	
 14525 0000129C C3                      	retn
 14526                                  
 14527                                  ; ---------------------------------------------------------------------------
 14528                                  
 14529                                  	;break	<DIR support routines>
 14530                                  
 14531                                  ;***	SUPPORT ROUTINES
 14532                                  
 14533                                  ; ----------------------
 14534                                  
 14535                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14536                                  ;
 14537                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14538                                  ;		BX = ptr to last child's name
 14539                                  ;		BP = ptr to temp child's name
 14540                                  ;
 14541                                  ;	EXIT	nothing
 14542                                  ;
 14543                                  ;	USED	AX,CX,SI,DI
 14544                                  ;
 14545                                  ;	EFFECTS
 14546                                  ;
 14547                                  ;	  Filename pointed to by BP may be changed.
 14548                                  ;
 14549                                  ;	NOTES
 14550                                  ;
 14551                                  ;	  Potential filename replaces temp filename if:
 14552                                  ;	   it's a subdirectory file;
 14553                                  ;	   it doesn't start with a '.';
 14554                                  ;	   it's alphanumerically greater than last child's name;
 14555                                  ;	   and it's alphanumerically less than temp name.
 14556                                  
 14557                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14558                                  	; 07/06/2023
 14559                                  CheckChild:
 14560                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14561 0000129D F606[BF8B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14562 000012A2 741D                    	jz	short ccRet	; not a subdirectory file- return
 14563                                  
 14564                                  	; 16/02/2023
 14565 000012A4 BE[C88B]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14566 000012A7 803C2E                  	cmp	byte [si],'.'
 14567                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14568                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14569 000012AA 7415                    	je	short ccRet	; starts with a dot- return
 14570                                  
 14571                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14572                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14573 000012AC 89DF                    	mov	di,bx
 14574 000012AE E80404                  	call	CmpAscz		; compare candidate to last child's name
 14575 000012B1 760E                    	jna	short ccRet	; it's not above it- return
 14576                                  
 14577                                  
 14578                                  	; 07/06/2023
 14579                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14580                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14581                                  	; si = DIRBUF+FIND_BUF.PNAME
 14582 000012B3 89EF                    	mov	di,bp
 14583 000012B5 E8FD03                  	call	CmpAscz		; compare candidate to temp name
 14584 000012B8 7307                    	jnb	short ccRet	; it's not below it- return
 14585                                  
 14586                                  ;	New kid is alright. Copy to temp.
 14587                                  
 14588                                  	; 07/06/2023
 14589                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14590                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14591                                  	; si = DIRBUF+FIND_BUF.PNAME
 14592 000012BA 89EF                    	mov	di,bp
 14593 000012BC B90D00                  	mov	cx,13
 14594 000012BF F3A4                    	rep	movsb
 14595                                  ccRet:
 14596 000012C1 C3                      	retn
 14597                                  
 14598                                  ; ---------------------------------------------------------------------------
 14599                                  
 14600                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14601                                  ;
 14602                                  ;	Compare one directory entry against another according to
 14603                                  ;	the sort codes in DestBuf. One or more comparisons
 14604                                  ;	may be made of file name, extension, time/date, and
 14605                                  ;	size.  Comparisons may be made for upward or downward
 14606                                  ;	sort order.
 14607                                  ;
 14608                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14609                                  ;		ES:BP = ptr to entry to be compared against
 14610                                  ;		DestBuf contains sort codes (see DestBuf)
 14611                                  ;		DS = TRANGROUP seg addr
 14612                                  ;
 14613                                  ;	EXIT	BX = unchanged
 14614                                  ;		BP = unchanged
 14615                                  ;		Condition flags set for same, above, or below
 14616                                  ;		 comparing BX entry against BP entry.
 14617                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14618                                  ;
 14619                                  ;	USED:	AX,CX,DX,SI,DI
 14620                                  
 14621                                  	; 16/02/2023
 14622                                  CmpEntry:
 14623 000012C2 BE[2D8C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14624                                  ceLoop:
 14625 000012C5 31C0                    	xor	ax,ax		; AX = 0
 14626 000012C7 8A04                    	mov	al,[si]		; AL = sort code
 14627 000012C9 08C0                    	or	al,al
 14628 000012CB 741C                    	jz	short ceDone	; sort code is zero, we're done
 14629 000012CD 46                      	inc	si		; DS:SI = ptr to next sort code
 14630 000012CE 56                      	push	si		; save ptr to next sort code
 14631 000012CF FEC8                    	dec	al
 14632 000012D1 D0E0                    	shl	al,1
 14633                                  	;sal	al,1		; AX = index into cmp call table
 14634                                  				; CY set for downward sort order
 14635 000012D3 89C6                    	mov	si,ax		; SI = index into cmp call table
 14636 000012D5 2E8B84[EA12]            	mov	ax,[cs:si+FieldCmps]
 14637                                  				; AX = addr of compare routine
 14638 000012DA 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14639 000012DC FFD0                    	call	ax 		; do upwards sort
 14640 000012DE EB06                    	jmp	short ceNs
 14641                                  ceDn:
 14642 000012E0 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14643 000012E2 FFD0                    	call	ax		; do sort
 14644 000012E4 87DD                    	xchg	bx,bp		; swap ptrs back
 14645                                  ceNs:
 14646 000012E6 5E                      	pop	si		; SI = ptr to next sort code
 14647 000012E7 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14648                                  ceDone:
 14649                                  
 14650                                  ;	Get here either from unequal compare or sort code = 0.
 14651                                  ;	In the latter case, condition codes indicate equality,
 14652                                  ;	which is correct.
 14653                                  
 14654 000012E9 C3                      	retn
 14655                                  
 14656                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14657                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14658                                  
 14659                                  FieldCmps:		; call table of entry comparisons
 14660 000012EA [F412]                  	dw	CmpName
 14661 000012EC [FF12]                  	dw	CmpExt
 14662 000012EE [3D13]                  	dw	CmpTime
 14663 000012F0 [5913]                  	dw	CmpSize
 14664 000012F2 [5E13]                  	dw	CmpType
 14665                                  
 14666                                  ; ---------------------------------------------------------------------------
 14667                                  
 14668                                  ;***	CmpName - compare file name of two entries
 14669                                  ;***	CmpExt - compare extension of two entries
 14670                                  ;
 14671                                  ;	ENTRY	ES:BX = ptr to one entry
 14672                                  ;		ES:BP = ptr to another entry
 14673                                  ;
 14674                                  ;	EXIT	BX = unchanged
 14675                                  ;		BP = unchanged
 14676                                  ;		Condition flags set for same, above, or below
 14677                                  ;		comparing BX entry to BP entry.
 14678                                  ;
 14679                                  ;	USED:	AX,CX,DX,SI,DI
 14680                                  
 14681                                  	; 16/02/2023
 14682                                  CmpName:
 14683 000012F4 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14684 000012F6 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14685                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14686                                  	;add	si,1
 14687                                  	; 25/04/2023
 14688 000012F8 46                      	inc	si
 14689                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14690                                  	;add	di,1
 14691                                  	; 25/04/2023
 14692 000012F9 47                      	inc	di
 14693                                  	;mov	cx,size filename
 14694                                  				; CX = length of name
 14695 000012FA B90800                  	mov	cx,8
 14696 000012FD EB0C                    	jmp	short CmpStr
 14697                                  
 14698                                  CmpExt:
 14699                                  	; 07/06/2023
 14700                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14701                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14702                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14703                                  	;add	si,9
 14704                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14705                                  	;add	di,9
 14706                                  	;
 14707 000012FF BE0900                  	mov	si,9
 14708 00001302 89F7                    	mov	di,si ; mov di,9
 14709 00001304 01DE                    	add	si,bx
 14710 00001306 01EF                    	add	di,bp
 14711                                  	;
 14712                                  	;mov	cx,size fileext	; CX = length of extension field
 14713 00001308 B90300                  	mov	cx,3
 14714                                  
 14715                                  ;	Bugbug:	use symbol for subfunction code.
 14716                                  
 14717                                  CmpStr:	
 14718 0000130B 803E[1E95]06            	cmp	byte [CountryPtrId],6
 14719 00001310 7527                    	jne	short cnNoCollTable
 14720                                  				; no collating table available
 14721                                  
 14722                                  ;*	Compare strings using collating table.
 14723                                  ;
 14724                                  ;	ES:SI = ptr to 1st string
 14725                                  ;	ES:DI = ptr to 2nd string
 14726                                  ;	CX = length
 14727                                  
 14728 00001312 55                      	push	bp		; preserve BP
 14729 00001313 53                      	push	bx		; preserve BX
 14730 00001314 1E                      	push	ds		; preserve DS
 14731 00001315 C51E[1F95]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14732                                  	;assume	ds:NOTHING
 14733 00001319 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14734 0000131B 43                      	inc	bx
 14735 0000131C 43                      	inc	bx		; DS:BX = ptr to collating values
 14736                                  				; DS:[BX]-2 = size of table
 14737 0000131D 31C0                    	xor	ax,ax		; AX = 0 for starters
 14738                                  
 14739                                  ;	Bugbug:	Investigate removing collating table length checks.
 14740                                  
 14741                                  cnNextChar:
 14742 0000131F 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14743 00001322 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14744 00001323 39E8                    	cmp	ax,bp		; compare to collating table length
 14745 00001325 7301                    	jae	short cn1 	; char not in table
 14746 00001327 D7                      	xlat				
 14747                                  cn1:				; AL = AX = collating value
 14748 00001328 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14749                                  	;lods	byte ptr es:[si]
 14750 0000132A 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14751                                  				; ES:SI = ptr to next char 1st string
 14752 0000132C 39E8                    	cmp	ax,bp		; compare to collating table length
 14753 0000132E 7301                    	jae	short cn2	; char not in table
 14754 00001330 D7                      	xlat				
 14755                                  cn2:				; AL = AX = collating value
 14756 00001331 39D0                    	cmp	ax,dx		; compare collating values
 14757 00001333 E1EA                    	loope	cnNextChar	; until unequal or no more left
 14758                                  
 14759 00001335 1F                      	pop	ds		; restore DS
 14760                                  	;assume	ds:TRANGROUP
 14761 00001336 5B                      	pop	bx		; restore BX
 14762 00001337 5D                      	pop	bp		; restore BP
 14763 00001338 C3                      	retn
 14764                                  
 14765                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14766                                  ;	Don't we wish we could just do this all the time? Sigh.
 14767                                  
 14768                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14769                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14770                                  cnNoCollTable:
 14771                                  	;repe	cmps byte ptr es:[si],[di]
 14772                                  				;db 0F3h,26h,0A6h,0C3h
 14773 00001339 F3                      	repe	; 0F3h
 14774 0000133A 26                      	es	; 26h
 14775 0000133B A6                      	cmpsb	; 0A6h
 14776 0000133C C3                      	retn	; 0C3h
 14777                                  
 14778                                  ; ---------------------------------------------------------------------------
 14779                                  
 14780                                  ;***	CmpTime - compare entries by date/time
 14781                                  ;
 14782                                  ;	ENTRY	ES:BX = ptr to one entry
 14783                                  ;		ES:BP = ptr to another entry
 14784                                  ;
 14785                                  ;	EXIT	BX = unchanged
 14786                                  ;		BP = unchanged
 14787                                  ;		Condition flags set for same, above, or below
 14788                                  ;		 comparing BX entry to BP entry.
 14789                                  ;
 14790                                  ;	USED:	CX,SI,DI
 14791                                  ;
 14792                                  ;	NOTE	Filetime and filedate fields in our private entry
 14793                                  ;		structure must be adjacent and in that order.
 14794                                  
 14795                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14796                                  	; 07/06/2023
 14797                                  CmpTime:
 14798 0000133D 89DE                    	mov	si,bx
 14799 0000133F 89EF                    	mov	di,bp
 14800                                  	;add	si,filedate + size filedate - 1
 14801 00001341 83C610                  	add	si,16 ; 15+2-1
 14802                                  	;add	di,filedate + size filedate - 1
 14803 00001344 83C710                  	add	di,16 ; 15+2-1
 14804                                  	; 07/06/2023
 14805 00001347 BE1000                  	mov	si,16
 14806                                  CmpST2:		; 07/06/2023
 14807 0000134A 89F7                    	mov	di,si	; mov di,16
 14808 0000134C 01DE                    	add	si,bx
 14809 0000134E 01EF                    	add	di,bp
 14810                                  
 14811                                  	;mov	cx,size filetime + size filedate
 14812 00001350 B90400                  	mov	cx,4 ; 2+2
 14813 00001353 FD                      	std
 14814                                  	;repe	cmps byte ptr es:[si],[di]
 14815                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 14816 00001354 F3                      	repe	; 0F3h
 14817 00001355 26                      	es	; 26h
 14818 00001356 A6                      	cmpsb	; 0A6h
 14819                                  	
 14820 00001357 FC                      	cld	; 0FCh
 14821 00001358 C3                      	retn	; 0C3h
 14822                                  
 14823                                  ; ---------------------------------------------------------------------------
 14824                                  
 14825                                  ;***	CmpSize - compare entries by size
 14826                                  ;
 14827                                  ;	ENTRY	ES:BX = ptr to one entry
 14828                                  ;		ES:BP = ptr to another entry
 14829                                  ;
 14830                                  ;	EXIT	BX = unchanged
 14831                                  ;		BP = unchanged
 14832                                  ;		Condition flags set for same, above, or below
 14833                                  ;		 comparing BX entry to BP entry.
 14834                                  ;
 14835                                  ;	USED:	CX,SI,DI
 14836                                  
 14837                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14838                                  	; 07/06/2023
 14839                                  CmpSize:
 14840                                  	;mov	si,bx
 14841                                  	;mov	di,bp
 14842                                  	;;add	si,filesize + size filesize - 1
 14843                                  	;add	si,20  ; 17+4-1
 14844                                  	;;add	di,filesize + size filesize - 1
 14845                                  	;add	di,20  ; 17+4-1
 14846                                  	; 07/06/2023
 14847 00001359 BE1400                  	mov	si,20
 14848                                  	;;;
 14849 0000135C EBEC                    	jmp	short CmpST2 ; 07/06/2023
 14850                                  	;;;
 14851                                  ;CmpST2:
 14852                                  ;	mov	di,si	; mov di,20
 14853                                  ;	add	si,bx
 14854                                  ;	add	di,bp
 14855                                  ;
 14856                                  ;	;mov	cx,size filesize
 14857                                  ;	mov	cx,4
 14858                                  ;	std
 14859                                  ;	;repe	cmps byte ptr es:[si],[di]
 14860                                  ;				;db 0F3h,26h,0A6h
 14861                                  ;	repe	; 0F3h
 14862                                  ;	es	; 26h
 14863                                  ;	cmpsb	; 0A6h
 14864                                  ;
 14865                                  ;	cld
 14866                                  ;	retn
 14867                                  
 14868                                  ; ---------------------------------------------------------------------------
 14869                                  
 14870                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14871                                  ;
 14872                                  ;	ENTRY	ES:BX = ptr to one entry
 14873                                  ;		ES:BP = ptr to another entry
 14874                                  ;
 14875                                  ;	EXIT	BX = unchanged
 14876                                  ;		BP = unchanged
 14877                                  ;		Condition flags set for same, above, or below
 14878                                  ;		 comparing BX entry to BP entry.
 14879                                  ;
 14880                                  ;	USED:	AX
 14881                                  
 14882                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14883                                  CmpType:
 14884                                  	;mov	al,es:[bx].fileattr
 14885 0000135E 268A470C                	mov	al,[es:bx+12]
 14886                                  	;mov	ah,es:[bp].fileattr
 14887 00001362 268A660C                	mov	ah,[es:bp+12]
 14888                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14889                                  	;and	ax,1010h
 14890 00001366 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14891 00001369 38C4                    	cmp	ah,al
 14892 0000136B C3                      	retn
 14893                                  
 14894                                  ; ---------------------------------------------------------------------------
 14895                                  
 14896                                  ;***	DefaultAttr - set default attribute conditions
 14897                                  ;
 14898                                  ;	ENTRY	nothing
 14899                                  ;
 14900                                  ;	EXIT	CY clear
 14901                                  ;
 14902                                  ;	USED
 14903                                  ;
 14904                                  ;	EFFECTS
 14905                                  ;
 14906                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14907                                  
 14908                                  	; 16/02/2023
 14909                                  DefaultAttr:
 14910                                  	;mov	byte [AttrSpecified],6
 14911 0000136C C606[048C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14912                                  					; specify H and S
 14913 00001371 C606[058C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14914 00001376 F8                      	clc				; return success
 14915                                  dtRet:	; 18/02/2023
 14916 00001377 C3                      	retn
 14917                                  
 14918                                  ; ---------------------------------------------------------------------------
 14919                                  
 14920                                  ;***	DisplayTotals - display grand total stats
 14921                                  ;
 14922                                  ;	If we searched subdirectories, display the total # files found
 14923                                  ;	 and total size of files found.
 14924                                  ;	Display disk space remaining.
 14925                                  ;
 14926                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14927                                  ;		Bits contains setting of /s
 14928                                  ;		FCB contains drive #
 14929                                  ;
 14930                                  ;	EXIT	nothing
 14931                                  ;
 14932                                  ;	USES	AX,DX
 14933                                  ;		FileSiz
 14934                                  
 14935                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14936                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14937                                  
 14938                                  DisplayTotals:
 14939                                  	;;;test	Bits,mask subd
 14940                                  	;;test	word [_Bits],4
 14941                                  	;test	byte [_Bits],4
 14942 00001378 F606[FC8B]04            	test	byte [_Bits],mask.subd
 14943 0000137D 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14944                                  
 14945 0000137F E84D12                  	call	CRLF2			; start on new line
 14946 00001382 E8C403                  	call	UseLine
 14947                                  
 14948 00001385 BA[3881]                	mov	dx,total_ptr
 14949 00001388 E8463A                  	call	std_printf		; "Total:",cr,lf
 14950 0000138B E8BB03                  	call	UseLine
 14951                                  
 14952 0000138E A1[D38A]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14953 00001391 BE[D78A]                	mov	si,FileSizTotal
 14954 00001394 BF[CF8A]                	mov	di,FileSiz
 14955 00001397 A5                      	movsw
 14956 00001398 A5                      	movsw				; move total size to size variable
 14957 00001399 E87605                  	call	DisplayCntSiz		; display file count & size &
 14958                                  dtFree: 				;   (maybe) compression ratio
 14959 0000139C B436                    	mov	ah,36h
 14960                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14961 0000139E 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14962 000013A2 CD21                    	int	21h			; call DOS
 14963 000013A4 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14964 000013A7 74CE                    	jz	short dtRet		; can't get drive space - return
 14965 000013A9 F7E1                    	mul	cx
 14966 000013AB F7E3                    	mul	bx
 14967 000013AD A3[188C]                	mov	[Bytes_Free],ax
 14968 000013B0 8916[1A8C]              	mov	[Bytes_Free+2],dx
 14969 000013B4 BA[4A7F]                	mov	dx,bytmes_ptr
 14970 000013B7 E8173A                  	call	std_printf		; "nnn bytes free",cr,lf
 14971                                  	;call	UseLine
 14972                                  ;dtRet:
 14973                                  	;retn
 14974                                  	; 18/02/2023
 14975 000013BA E98C03                  	jmp	UseLine
 14976                                  
 14977                                  ; ---------------------------------------------------------------------------
 14978                                  
 14979                                  ;***	FileIsDevice - see if file looks like a device
 14980                                  ;
 14981                                  ;	ENTRY	PathPos = ptr to pathname
 14982                                  ;		PathCnt = length of pathname w/o terminating char
 14983                                  ;		DirBuf is DOS DTA
 14984                                  ;
 14985                                  ;	EXIT	ZR = set if file looks like a device
 14986                                  ;
 14987                                  ;	USED	AX,BX,CX,DX,DI
 14988                                  ;
 14989                                  ;	EFFECTS
 14990                                  ;
 14991                                  ;	  DTA buffer holds results of Find First function
 14992                                  ;
 14993                                  ;	NOTES
 14994                                  ;
 14995                                  ;	  We try to flag devices in two ways. First, we try
 14996                                  ;	  the DOS Find First function. It returns attribute bit 6
 14997                                  ;	  set on a successful find if it identifies a device name.
 14998                                  ;	  Unfortunately, it returns 'path not found' for a device
 14999                                  ;	  name terminated with colon, such as "CON:". So, we look
 15000                                  ;	  for any colon in the pathname after the 2nd character,
 15001                                  ;	  and flag the pathname as a device if we find one.
 15002                                  
 15003                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15004                                  FileIsDevice:
 15005 000013BD 8B16[008C]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 15006                                  
 15007 000013C1 89D7                    	mov	di,dx
 15008 000013C3 033E[FE8B]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 15009 000013C7 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 15010 000013C9 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 15011                                  
 15012 000013CB 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 15013 000013CD B44E                    	mov	ah,4Eh
 15014                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 15015 000013CF CD21                    	int	21h	 	 ; call DOS
 15016 000013D1 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 15017 000013D3 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 15018                                  
 15019                                  ;	Found a dir entry, see if Find First thinks it's a device.
 15020                                  
 15021                                  	;test	byte [DIRBUF+21],40h
 15022 000013D5 F606[BF8B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 15023 000013DA 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 15024 000013DC 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 15025                                  	;jmp	short piRet
 15026                                  	; 25/04/2023
 15027                                  piRet:
 15028 000013DE C3                      	retn
 15029                                  
 15030                                  ;	Device attribute not returned by Find First function. But
 15031                                  ;	let's check for a colon anywhere in the pathname after the
 15032                                  ;	second byte.
 15033                                  ;
 15034                                  ;	DI = ptr to byte after pathname
 15035                                  
 15036                                  piCol:
 15037 000013DF 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15038 000013E0 B03A                    	mov	al,':'
 15039                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15040 000013E2 8B0E[FE8B]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15041 000013E6 49                      	dec	cx
 15042 000013E7 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15043 000013E8 09C9                    	or	cx,cx
 15044 000013EA 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15045 000013EC 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15046 000013EE FD                      	std			 ; scan downward
 15047 000013EF F2AE                    	repne	scasb
 15048 000013F1 FC                      	cld			 ; restore default upward direction
 15049                                  
 15050                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15051                                  ;piRet:
 15052 000013F2 C3                      	retn
 15053                                  
 15054                                  ;FileIsDevice endp
 15055                                  
 15056                                  ; ---------------------------------------------------------------------------
 15057                                  
 15058                                  ;***	FindFirst - find first directory entry to display
 15059                                  ;***	FindNext - find next directory entry to display
 15060                                  ;
 15061                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15062                                  ;		AttrSpecified, AttrSelect are set
 15063                                  ;
 15064                                  ;	EXIT	CY = clear if successful
 15065                                  ;		BX = offset in TPA buffer of directory entry found
 15066                                  ;
 15067                                  ;		If unsuccessful,
 15068                                  ;		CY = set
 15069                                  ;		AX = DOS error code
 15070                                  ;		DOS Get Extended Error call will get error code
 15071                                  ;
 15072                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15073                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15074                                  ;		but DOS Get Extended Error call WON'T return the correct
 15075                                  ;		error. That's ok, because we'll see the value in AX
 15076                                  ;		and recognize it as a non-error condition.
 15077                                  ;
 15078                                  ;	USED	AX,CX,DX,SI,DI
 15079                                  ;
 15080                                  ;	EFFECTS
 15081                                  ;
 15082                                  ;	  Entries in memory may be marked as output.
 15083                                  ;	  If not sorted, entry is loaded at TPA.
 15084                                  ;
 15085                                  ;	NOTES
 15086                                  ;
 15087                                  ;	  If we don't find a qualifying file, we return after the final
 15088                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15089                                  ;	   indicate an appropriate condition.
 15090                                  
 15091                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15092                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15093                                  	
 15094                                  FindFirst:
 15095                                  	;mov	ax,offset TRANGROUP:GetFirst
 15096 000013F3 B8[CA14]                	mov	ax,GetFirst
 15097 000013F6 EB03                    	jmp	short ffFindEntry
 15098                                  
 15099                                  	; 18/02/2023
 15100                                  FindNext:
 15101                                  	;mov	ax,offset TRANGROUP:GetNext
 15102 000013F8 B8[D814]                	mov	ax,GetNext
 15103                                  
 15104                                  ;	AX = address of correct disk get routine to use.
 15105                                  
 15106                                  ffFindEntry:
 15107 000013FB 06                      	push	es			; save TRANGROUP seg addr
 15108                                  	;;;test	Bits,mask inmem
 15109                                  	;;test	word [_Bits],20h
 15110                                  	;test	byte [_Bits],20h
 15111 000013FC F606[FC8B]20            	test	byte [_Bits],mask.inmem
 15112 00001401 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15113                                  
 15114                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15115                                  ;	There will always be one, or LoadEntries would've failed.
 15116                                  
 15117 00001403 E81A00                  	call	FindInMem		; find first entry in TPA
 15118 00001406 EB16                    	jmp	short ffRet		; return what TPA search returns
 15119                                  
 15120                                  ;	Get entry from disk.
 15121                                  
 15122                                  ffDisk:
 15123 00001408 FFD0                    	call	ax			; get entry from disk
 15124 0000140A 720E                    	jc	short ffGetErr		; get & return error
 15125 0000140C 8E06[A78A]              	mov	es,[TPA]		; ES = seg addr of TPA
 15126 00001410 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15127 00001412 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15128 00001414 E85601                  	call	LoadEntry		; load entry to TPA
 15129 00001417 F8                      	clc				; return success
 15130 00001418 EB04                    	jmp	short ffRet
 15131                                  
 15132                                  ffGetErr:
 15133 0000141A E8D308                  	call	 get_ext_error_number	; AX = DOS error code
 15134 0000141D F9                      	stc
 15135                                  ffRet:
 15136 0000141E 07                      	pop	es			; ES = TRANGROUP seg addr again
 15137 0000141F C3                      	retn
 15138                                  
 15139                                  ; ---------------------------------------------------------------------------
 15140                                  
 15141                                  ;***	FindInMem - find next directory entry in TPA buffer
 15142                                  ;
 15143                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15144                                  ;
 15145                                  ;	EXIT	BX = offset in TPA of entry found
 15146                                  ;
 15147                                  ;		If no more files,
 15148                                  ;		CY = set
 15149                                  ;		AX = DOS 'no more files' error code
 15150                                  ;
 15151                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15152                                  ;
 15153                                  ;	EFFECTS
 15154                                  ;
 15155                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15156                                  
 15157                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15158                                  FindInMem:
 15159 00001420 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15160 00001424 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15161 00001426 FC                      	cld				; make sure default string direction is up
 15162                                  	
 15163 00001427 E86D00                  	call	FindOneInMem		; locate an entry
 15164 0000142A 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15165                                  
 15166                                  ;	BX = ptr to entry in TPA
 15167                                  
 15168                                  fiBest:
 15169 0000142C 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15170                                  fiNext:
 15171 0000142E E87300                  	call	FindNextInMem		; locate next entry
 15172 00001431 720C                    	jc	short fiFound		; no more, best entry so far wins
 15173                                  
 15174                                  ;	BX = ptr to next entry
 15175                                  
 15176 00001433 E88CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15177 00001436 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15178 00001438 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15179                                  
 15180                                  fiNoMore:
 15181                                  
 15182                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15183                                  
 15184                                  	;mov	ax,18
 15185 0000143A B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15186 0000143D F9                      	stc				; return error
 15187                                  	;jmp	short fiRet
 15188                                  	; 18/02/2023
 15189 0000143E C3                      	retn
 15190                                  
 15191                                  fiFound:
 15192 0000143F 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15193 00001441 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15194 00001445 F8                      	clc				; return success
 15195                                  fiRet:
 15196 00001446 C3                      	retn
 15197                                  
 15198                                  ; ---------------------------------------------------------------------------
 15199                                  
 15200                                  ;***	FindNextChild - find next subdirectory in current directory
 15201                                  ;
 15202                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15203                                  ;		DirBuf is established DTA
 15204                                  ;
 15205                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15206                                  ;
 15207                                  ;		If failure,
 15208                                  ;		CY = set
 15209                                  ;		DOS Get Extended Error call will get error
 15210                                  ;
 15211                                  ;	USED	AX,CX,DX,SI,DI,BP
 15212                                  ;
 15213                                  ;	EFFECTS
 15214                                  ;
 15215                                  ;	  DirBuf is used for find first/next calls.
 15216                                  ;
 15217                                  ;	NOTES
 15218                                  ;
 15219                                  ;	  We keep on checking files until DOS returns an error. If
 15220                                  ;	  the error is 'no more files' and the temp filename is not
 15221                                  ;	  the initial high tag, copy the temp to the child's name spot
 15222                                  ;	  and return success. Otherwise, send the error back to caller.
 15223                                  ;
 15224                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15225                                  
 15226                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15227                                  FindNextChild:
 15228 00001447 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15229                                  	;shove	00FFh			; temp filename = high tag
 15230 0000144A B8FF00                  	mov	ax,0FFh
 15231 0000144D 50                      	push	ax
 15232 0000144E 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15233                                  	;shove	"*"	
 15234 00001450 B02A                    	mov	al,'*'  ; ax = 002Ah
 15235 00001452 50                      	push	ax
 15236                                  	;;shove	".*" 
 15237                                  	;mov	ax,"*."
 15238                                  	;mov	ax,2E2Ah
 15239 00001453 B42E                    	mov	ah,'.'
 15240 00001455 50                      	push	ax
 15241 00001456 E8F704                  	call	GetDriveLtr		; AX = "d:"
 15242 00001459 50                      	push	ax
 15243 0000145A 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15244                                  
 15245                                  ;	See that the stack is restored properly at the end of this proc.
 15246                                  
 15247                                  	;mov	cx,10h
 15248 0000145C B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15249 0000145F B44E                    	mov	ah,4Eh
 15250                                  	;mov	ah,Find_First
 15251 00001461 CD21                    	int	21h			; DOS- Find First matching file
 15252 00001463 722C                    	jc	short fcRet		; return error
 15253                                  
 15254 00001465 E835FE                  	call	CheckChild		; check child against last, temp
 15255                                  fcNext:	
 15256                                  	;mov	cx,10h
 15257 00001468 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15258 0000146B B44F                    	mov	ah,4Fh
 15259                                  	;mov	ah,Find_Next
 15260 0000146D CD21                    	int	21h			; DOS- Find Next matching file
 15261 0000146F 7205                    	jc	short fcErr		; examine error
 15262                                  
 15263 00001471 E829FE                  	call	CheckChild		; check child against last, temp
 15264 00001474 EBF2                    	jmp	short fcNext		; go find another child
 15265                                  
 15266                                  fcErr:
 15267 00001476 E87708                  	call	get_ext_error_number	; AX = extended error code
 15268                                  	;cmp	ax,18
 15269 00001479 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15270 0000147C 7512                    	jne	short fcNope		; some other error- return it
 15271                                  
 15272                                  ;	We ran out of files. See if we qualified at least one.
 15273                                  
 15274 0000147E 807E00FF                	cmp	byte [bp],0FFh
 15275 00001482 740C                    	je	short fcNope		; temp filename is unused- no child
 15276                                  
 15277                                  ;	Move temp filename to child name position.
 15278                                  
 15279 00001484 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15280 00001486 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15281                                  fcMove:
 15282 00001488 AC                      	lodsb				; AL = next byte of filename
 15283 00001489 AA                      	stosb				; store byte
 15284 0000148A 08C0                    	or	al,al
 15285 0000148C 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15286 0000148E EBF8                    	jmp	short fcMove		; go move another byte
 15287                                  fcNope:
 15288 00001490 F9                      	stc				; return error
 15289                                  fcRet:
 15290 00001491 9F                      	lahf
 15291 00001492 83C414                  	add	sp,20			; restore stack
 15292 00001495 9E                      	sahf
 15293 00001496 C3                      	retn
 15294                                  
 15295                                  ; ---------------------------------------------------------------------------
 15296                                  
 15297                                  ;***	FindOneInMem - find the first available entry in TPA
 15298                                  ;***	FindNextInMem - find the next available entry in TPA
 15299                                  ;
 15300                                  ;	ENTRY	ES = TPA seg addr
 15301                                  ;		BX = ptr to entry in TPA
 15302                                  ;
 15303                                  ;	EXIT	BX = ptr to entry found
 15304                                  ;		CY = set if no more entries available in TPA
 15305                                  ;
 15306                                  ;	USED	AL
 15307                                  
 15308                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15309                                  FindOneInMem:
 15310 00001497 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15311 0000149A 3C01                    	cmp	al,1
 15312 0000149C 7406                    	je	short FindNextInMem	; entry has already been used
 15313 0000149E 3CFF                    	cmp	al,0FFh
 15314 000014A0 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15315                                  
 15316                                  ;	BX = ptr to entry that hasn't been output yet.
 15317                                  
 15318 000014A2 F8                      	clc				; return success
 15319 000014A3 C3                      	retn
 15320                                  
 15321                                  FindNextInMem:
 15322 000014A4 83C315                  	add	bx,21
 15323                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15324 000014A7 EBEE                    	jmp	short FindOneInMem	; go look at it
 15325                                  foNoMore:
 15326 000014A9 F9                      	stc				; ran out of entries, return failure
 15327 000014AA C3                      	retn
 15328                                  
 15329                                  ; ---------------------------------------------------------------------------
 15330                                  
 15331                                  ;***	GetEnvValue - get value of our environment variable
 15332                                  ;
 15333                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15334                                  ;
 15335                                  ;	EXIT	CY = set if environment variable not in environment
 15336                                  ;
 15337                                  ;		Otherwise:
 15338                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15339                                  ;
 15340                                  ;	USED	AX,BX,CX,DX,DI
 15341                                  ;		(We assume the (almost) worst, since we don't know about
 15342                                  ;		Find_Name_In_Environment.)
 15343                                  ;
 15344                                  ;	EFFECTS
 15345                                  ;
 15346                                  ;	  ScanBuf is loaded with value text
 15347                                  
 15348                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15349                                  GetEnvValue:
 15350 000014AB 06                      	push	es				; save ES
 15351                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15352 000014AC BE[8081]                	mov	si,DirEnvVar
 15353                                  	;invoke	Find_Name_In_Environment
 15354 000014AF E8610E                  	call	find_name_in_environment
 15355 000014B2 7214                    	jc	short geRet			; name not found in environment
 15356                                  
 15357                                  ;	ES:DI = ptr to value of environment variable
 15358                                  ;	We're assuming DS, CS, and SS are unchanged.
 15359                                  
 15360 000014B4 1E                      	push	ds
 15361 000014B5 06                      	push	es
 15362 000014B6 1F                      	pop	ds
 15363 000014B7 07                      	pop	es
 15364                                  
 15365                                  	;assume	ds:nothing
 15366                                  
 15367                                  ;	DS = seg addr of environment variable value (in environment segment)
 15368                                  ;	ES = TRANGROUP seg addr
 15369                                  
 15370 000014B8 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15371                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15372 000014BA BF[EA8C]                	mov	di,ScanBuf
 15373                                  geLoop:
 15374                                  ;@@:	
 15375 000014BD AC                      	lodsb
 15376 000014BE 08C0                    	or	al,al
 15377 000014C0 AA                      	stosb
 15378                                  	;loopnz	@B		; move the string, including trailing null
 15379 000014C1 E0FA                    	loopnz	geLoop
 15380                                  
 15381 000014C3 06                      	push	es
 15382 000014C4 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15383                                  	;assume	ds:TRANGROUP
 15384                                  
 15385                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15386 000014C5 BE[EA8C]                	mov	si,ScanBuf
 15387                                  geRet:
 15388 000014C8 07                      	pop	es				; restore ES
 15389 000014C9 C3                      	retn
 15390                                  
 15391                                  ; ---------------------------------------------------------------------------
 15392                                  
 15393                                  ;***	GetFirst - get first directory entry from disk
 15394                                  ;
 15395                                  ;	ENTRY	DOS DTA established at DirBuf
 15396                                  ;		FCB contains drive # and filename
 15397                                  ;		Current directory (on selected drive) is the one to search
 15398                                  ;		AttrSpecified & AttrSelect masks set
 15399                                  ;
 15400                                  ;	EXIT	CY = clear if success
 15401                                  ;		DirBuf contains extended FCB for file found
 15402                                  ;
 15403                                  ;		If unsuccessful,
 15404                                  ;		CY = set
 15405                                  ;		Ready for DOS Get Extended Error call
 15406                                  ;
 15407                                  ;	USED	AX,DX
 15408                                  ;
 15409                                  ;	EFFECTS
 15410                                  ;
 15411                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15412                                  ;	  FCB-1 = attribute mask to find all files
 15413                                  ;	  These fields should remain unmodified for GetNext calls.
 15414                                  ;
 15415                                  ;***	GetNext - get next directory entry from disk
 15416                                  ;
 15417                                  ;	ENTRY	As for GetFirst, plus
 15418                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15419                                  ;
 15420                                  ;	EXIT	As for GetFirst
 15421                                  ;
 15422                                  ;	USED	AX,DX
 15423                                  
 15424                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15425                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15426                                  GetFirst:
 15427                                  	;mov	byte [55h],0FFh	; -1
 15428 000014CA C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15429                                  	;mov	byte [5Bh],16h
 15430 000014CF C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15431                                  					; find any file
 15432                                  	; 07/06/2023
 15433                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15434 000014D4 B411                    	mov	ah,11h
 15435                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15436                                  	; 07/06/2023
 15437                                  	;int	21h			; call DOS
 15438                                  	;shl	al,1			; CY = set if error
 15439                                  	;jc	short gfRet		; return error
 15440                                  	;jmp	short gfFound		; go look at attr's
 15441                                  	; 07/06/2023
 15442 000014D6 EB02                    	jmp	short GetFrstNxt
 15443                                  GetNext:
 15444                                  	; 07/06/2023
 15445                                  	;;mov	dx,55h
 15446                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15447 000014D8 B412                    	mov	ah,12h
 15448                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15449                                  GetFrstNxt:
 15450                                  	; 07/06/2023
 15451 000014DA BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15452                                  	;
 15453 000014DD CD21                    	int	21h			; call DOS
 15454 000014DF D0E0                    	shl	al,1			; CY = set if error
 15455 000014E1 7211                    	jc	short gfRet		; return error
 15456                                  
 15457                                  ;*	Found an entry. Check attributes.
 15458                                  gfFound:
 15459                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15460                                  	;mov	al,[DIRBUF+19]
 15461 000014E3 A0[BD8B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15462 000014E6 8A26[048C]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15463 000014EA 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15464 000014EC 2226[058C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15465 000014F0 38E0                    	cmp	al,ah
 15466 000014F2 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15467                                  gfRet:
 15468 000014F4 C3                      	retn
 15469                                  
 15470                                  ; ---------------------------------------------------------------------------
 15471                                  
 15472                                  ;***	ListDir - search for and list files in the current directory
 15473                                  ;
 15474                                  ;	List header, files, and trailer for current directory on selected
 15475                                  ;	drive. Header & trailer are listed if at least one file is found.
 15476                                  ;	If no qualifying files are found, no display output occurs.
 15477                                  ;
 15478                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15479                                  ;		FCB contains selected drive # and filename spec
 15480                                  ;		Option bits, attribute masks, and sort codes set up
 15481                                  ;
 15482                                  ;	EXIT	CY = clear if no error
 15483                                  ;		FileCnt = # files found & displayed
 15484                                  ;
 15485                                  ;		If error,
 15486                                  ;		CY = set
 15487                                  ;		Ready for DOS Get Extended Error call
 15488                                  ;
 15489                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15490                                  ;		FileSiz
 15491                                  ;
 15492                                  ;	EFFECTS
 15493                                  ;
 15494                                  ;	  FileCntTotal, FileSizTotal are updated.
 15495                                  ;	  Files found are listed. A directory header and trailer are
 15496                                  ;	   displayed only if files are found.
 15497                                  
 15498                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15499                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15500                                  
 15501                                  ListDir:
 15502 000014F5 31C0                    	xor	ax,ax ; 0
 15503 000014F7 A3[CD8A]                	mov	[FileCnt],ax		; zero file count
 15504 000014FA A3[CF8A]                	mov	[FileSiz],ax		; zero file size accumulator
 15505 000014FD A3[D18A]                	mov	[FileSiz+2],ax
 15506                                  	;cmp	byte [DestBuf],0	; check for sort code
 15507                                  	; 31/07/2024
 15508 00001500 3806[2D8C]              	cmp	[DestBuf],al ; 0
 15509 00001504 740A                    	je	short ld1		; no sort
 15510 00001506 E83000                  	call	LoadEntries		; load entries for sorted listing
 15511 00001509 7305                    	jnc	short ld1		; no error - continue
 15512 0000150B E8E207                  	call	get_ext_error_number	; AX = DOS error code
 15513                                  	; 19/02/2023
 15514                                  	;stc
 15515 0000150E EB12                    	jmp	short ldErr		; return error
 15516                                  ld1:
 15517 00001510 E8E0FE                  	call	FindFirst		; find first file
 15518 00001513 720D                    	jc	short ldErr		; not found, return error
 15519                                  
 15520                                  ;	BX = offset in TPA buffer of entry found
 15521                                  
 15522 00001515 E8E102                  	call	DisplayHeader		; if at least one file, display header
 15523                                  ldNext:
 15524 00001518 E8B902                  	call	DisplayFile		; display the file entry
 15525                                  ;ldNext:
 15526 0000151B E8DAFE                  	call	FindNext		; find another file
 15527 0000151E 7202                    	jc	short ldErr		; not found
 15528                                  	;call	DisplayFile		; display entry
 15529                                  	;jmp	short ldNext		; go find another one
 15530                                  	; 19/02/2023
 15531 00001520 EBF6                    	jmp	short ldNext
 15532                                  ldErr:
 15533                                  	;cmp	ax,2
 15534 00001522 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15535 00001525 7407                    	je	short ldDone		; file not found, we're done
 15536                                  	;cmp	ax,18
 15537 00001527 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15538 0000152A 7402                    	je	short ldDone		; no more files, we're done
 15539 0000152C F9                      	stc
 15540                                  	;jmp	short ldRet
 15541                                  	; 19/02/2023
 15542 0000152D C3                      	retn
 15543                                  ldDone:
 15544 0000152E 833E[CD8A]00            	cmp	word [FileCnt],0
 15545                                  	;je	short ld2		; no files found, just return
 15546                                  	; 25/04/2023
 15547 00001533 7403                    	jz	short ldRet
 15548 00001535 E8CA03                  	call	DisplayTrailer		; display trailing info
 15549                                  	; 08/06/2023
 15550                                  	; cf=0
 15551                                  ;ld2:	
 15552                                  	;clc				; return success
 15553                                  ldRet:
 15554 00001538 C3                      	retn
 15555                                  
 15556                                  ; ---------------------------------------------------------------------------
 15557                                  
 15558                                  ;***	LoadEntries - attempt to load entries from current directory
 15559                                  ;
 15560                                  ;	Load all qualifying directory entries from the current directory
 15561                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15562                                  ;	other than 'no more files', return to caller with carry flag set.
 15563                                  ;	If we run out of buffer space, display a message that we haven't
 15564                                  ;	enough memory to sort this directory, but return without error.
 15565                                  ;	Other routines know whether or not entries have been loaded by
 15566                                  ;	the 'inmem' flag bit, which we set here.
 15567                                  ;
 15568                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15569                                  ;	this allows sorting over 3000 entries in a directory.
 15570                                  ;
 15571                                  ;	ENTRY	Tpa = buffer seg addr
 15572                                  ;		BytCnt = buffer length, in bytes
 15573                                  ;		Current directory (on selected drive) is the one to load
 15574                                  ;		FCB contains drive # and filespec
 15575                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15576                                  ;
 15577                                  ;	EXIT	CY = set if error
 15578                                  ;		If error, DOS Get Extended Error will get error info
 15579                                  ;
 15580                                  ;	USED	AX,CX,DX,SI,DI
 15581                                  ;
 15582                                  ;	EFFECTS
 15583                                  ;
 15584                                  ;	  Inmem bit of Bits = set if load succeeded.
 15585                                  ;	  Tpa buffer contains directory entries.
 15586                                  ;	  Byte after last entry = 0FFh.
 15587                                  
 15588                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15589                                  LoadEntries:
 15590 00001539 06                      	push	es			; save TRANGROUP seg addr
 15591 0000153A 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15592 0000153E 31FF                    	xor	di,di			; ES:DI = destination ptr
 15593                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15594                                  	;;and	word [_Bits],0FFDFh
 15595                                  	;and	byte [_Bits],0DFh	; not 20h
 15596 00001540 8026[FC8B]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15597                                  
 15598 00001545 E882FF                  	call	GetFirst		; look for first file
 15599 00001548 7221                    	jc	short leRet		; return any error
 15600 0000154A E82000                  	call	LoadEntry		; load entry into TPA
 15601                                  leNext:
 15602 0000154D E888FF                  	call	GetNext			; get another file
 15603 00001550 720F                    	jc	short leLoaded		; assume any error is no more files
 15604 00001552 A1[C48A]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15605 00001555 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15606                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15607 00001557 83F817                  	cmp	ax,23 ; 21+2 
 15608 0000155A 720E                    	jb	short leOk		; not enough memory left, give up
 15609 0000155C E80E00                  	call	LoadEntry		; load entry into TPA
 15610 0000155F EBEC                    	jmp	short leNext		; go get another file
 15611                                  
 15612                                  leLoaded:
 15613 00001561 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15614                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15615                                  	;;or	word [_Bits],20h
 15616                                  	;or	byte [_Bits],20h
 15617 00001565 800E[FC8B]20            	or	byte [_Bits],mask.inmem
 15618                                  	; 25/04/2023
 15619                                  	; cf = 0
 15620                                  leOk:
 15621 0000156A F8                      	clc				; return no error
 15622                                  leRet:
 15623 0000156B 07                      	pop	es			; ES = TRANGROUP seg addr again
 15624 0000156C C3                      	retn
 15625                                  
 15626                                  
 15627                                  ; ---------------------------------------------------------------------------
 15628                                  
 15629                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15630                                  ;
 15631                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15632                                  ;		DirBuf contains extended FCB of entry to load
 15633                                  ;
 15634                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15635                                  ;
 15636                                  ;	USED	AX,CX,SI
 15637                                  ;
 15638                                  ;	NOTES
 15639                                  ;
 15640                                  ;	  I could've used symbolic offsets and sizes of fields from
 15641                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15642                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15643                                  ;	   as well as our private directory entry structure.
 15644                                  ;
 15645                                  ;	  We force a zero size for subdirectory files. A zero size is
 15646                                  ;	   ordinarily returned for subdirectories, but with Novell
 15647                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15648                                  
 15649                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15650                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15651                                  LoadEntry:
 15652                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15653 0000156D BE[B28B]                	mov	si,DIRBUF+8
 15654 00001570 30C0                    	xor	al,al				; AL = 0
 15655 00001572 AA                      	stosb					; 'used' byte = false
 15656 00001573 B90B00                  	mov	cx,11
 15657 00001576 F3A4                    	rep	movsb				; transfer filename & extension
 15658 00001578 AC                      	lodsb					; AL = attrib byte
 15659 00001579 AA                      	stosb					; store attrib byte
 15660                                  	;add	si,10 ; 22-11-1
 15661                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15662 0000157A 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15663 0000157D A5                      	movsw					; transfer time
 15664 0000157E A5                      	movsw					; transfer date
 15665 0000157F 46                      	inc	si				; skip alloc unit
 15666 00001580 46                      	inc	si
 15667                                  	;and	al,10h
 15668 00001581 2410                    	and	al,ATTR_DIRECTORY
 15669 00001583 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15670 00001585 A5                      	movsw
 15671 00001586 A5                      	movsw					; transfer size
 15672 00001587 C3                      	retn
 15673                                  leSetDirSize:
 15674 00001588 31C0                    	xor	ax,ax ; 0
 15675 0000158A AB                      	stosw
 15676 0000158B AB                      	stosw					; store zero size
 15677 0000158C C3                      	retn
 15678                                  
 15679                                  ; ---------------------------------------------------------------------------
 15680                                  
 15681                                  ;***	NoOrder - turn sorting off
 15682                                  ;
 15683                                  ;	ENTRY	nothing
 15684                                  ;
 15685                                  ;	EXIT	CY clear
 15686                                  ;
 15687                                  ;	USED	AX
 15688                                  ;
 15689                                  ;	EFFECTS
 15690                                  ;
 15691                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15692                                  
 15693                                  	; 19/02/2023
 15694                                  NoOrder:
 15695 0000158D C606[2D8C]00            	mov	byte [DestBuf],0
 15696                                  				; no sort
 15697 00001592 F8                      	clc			; no error
 15698 00001593 C3                      	retn
 15699                                  
 15700                                  ; ---------------------------------------------------------------------------
 15701                                  
 15702                                  ;***	OnOffSw - record occurence of on/off option switch
 15703                                  ;
 15704                                  ;	ENTRY	DI = index into word list of switches
 15705                                  ;
 15706                                  ;	EXIT	CY clear
 15707                                  ;
 15708                                  ;	USED	AX,CX
 15709                                  ;
 15710                                  ;	EFFECTS
 15711                                  ;
 15712                                  ;	  Bits modified to indicate option state.
 15713                                  
 15714                                  	; 19/02/2023
 15715                                  OnOffSw:
 15716 00001594 89F9                    	mov	cx,di		; CX = index into word list of options
 15717 00001596 D1E9                    	shr	cx,1
 15718 00001598 D1E9                    	shr	cx,1		; CX = bit position of option
 15719 0000159A B80100                  	mov	ax,1		
 15720 0000159D D3E0                    	shl	ax,cl		; AX = bit mask of option
 15721 0000159F F7C70200                	test	di,2		; check if it is a negated option
 15722 000015A3 7405                    	jz	short oo1	; it's negated
 15723                                  	;or	Bits,ax		; turn option on
 15724 000015A5 0906[FC8B]              	or	[_Bits],ax
 15725                                  	;jmp	short ooRet
 15726                                  	; 19/02/2023
 15727                                  	;cf=0
 15728 000015A9 C3                      	retn
 15729                                  oo1:	
 15730 000015AA F7D0                    	not	ax		; AX = complemented bit mask of option
 15731                                  	;and	Bits,ax		; turn option off
 15732 000015AC 2106[FC8B]              	and	[_Bits],ax
 15733                                  ooRet:
 15734                                  	; 19/02/2023
 15735                                  	;cf=0
 15736                                  	;clc			; always return success
 15737 000015B0 C3                      	retn
 15738                                  
 15739                                  ; ---------------------------------------------------------------------------
 15740                                  
 15741                                  ;***	ParseAttr - parse and record /A option
 15742                                  ;
 15743                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15744                                  ;
 15745                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15746                                  ;
 15747                                  ;		For parse error, we set up for Std_EPrintf call:
 15748                                  ;		AX = parse error code, like system parser
 15749                                  ;		DX = ptr to message block
 15750                                  ;
 15751                                  ;	USED	AX,CX,DX,DI
 15752                                  ;
 15753                                  ;	EFFECTS
 15754                                  ;
 15755                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15756                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15757                                  ;
 15758                                  ;	  For parse error, we set up for Std_EPrintf call:
 15759                                  ;	  Msg_Disp_Class = parse error message class
 15760                                  ;	  Message block (see DX) is set up for parse error message
 15761                                  
 15762                                  	; 19/02/2023
 15763                                  ParseAttr:
 15764 000015B1 56                      	push	si			; save SI
 15765 000015B2 C606[048C]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15766                                  
 15767                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15768                                  
 15769                                  	;;mov	si,word ptr [bx].ValuePtr
 15770                                  					; SI = ptr to string after /A
 15771                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15772 000015B7 8B7704                  	mov	si,[bx+4]
 15773                                  paLoop:	
 15774 000015BA BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15775 000015BD AC                      	lodsb				; AL = next char in string
 15776 000015BE 08C0                    	or	al,al
 15777                                  	;jz	short paOk		; it's terminating null, we're done
 15778                                  	; 19/02/2023
 15779 000015C0 742F                    	jz	short paRet ; cf=0
 15780 000015C2 3C2D                    	cmp	al,'-'
 15781 000015C4 7502                    	jne	short pa1		; not '-', go look for letter
 15782 000015C6 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15783 000015C7 AC                      	lodsb				; AL = next char
 15784                                  pa1:	
 15785                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15786                                  					; DI = ptr to attrib letter list
 15787 000015C8 BF[3784]                	mov	di,AttrLtrs ; "RHSvDA"
 15788                                  	;mov	cx,6
 15789 000015CB B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15790 000015CE F2AE                    	repne	scasb			; look for our letter in the list
 15791 000015D0 751B                    	jne	short paErr		; not found, return error
 15792                                  
 15793 000015D2 F7D1                    	not	cx
 15794                                  	;add	cx,6
 15795 000015D4 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15796                                  
 15797                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15798                                  ;	starting from bit 0.
 15799                                  
 15800                                  ;	Record this attribute bit in AttrSpecified.
 15801                                  
 15802 000015D7 B001                    	mov	al,1
 15803 000015D9 D2E0                    	shl	al,cl			; AL = mask for our bit
 15804 000015DB 0806[048C]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15805                                  
 15806                                  ;	Record the selected state for this attribute in AttrSelect.
 15807                                  ;	DX = 0 or 1, the selected state for this attribute.
 15808                                  
 15809 000015DF F6D0                    	not	al			; AL = mask for all other bits
 15810 000015E1 2006[058C]              	and	[AttrSelect],al		; clear our bit
 15811 000015E5 D2E2                    	shl	dl,cl			; DL = our bit state in position
 15812 000015E7 0816[058C]              	or	[AttrSelect],dl		; set selected attr state
 15813 000015EB EBCD                    	jmp	short paLoop		; go look at next char
 15814                                  
 15815                                  ;	The attribute letter string is invalid.
 15816                                  
 15817                                  paErr:	
 15818 000015ED E87103                  	call	SetupParamError		; set message up for Std_EPrintf
 15819 000015F0 F9                      	stc		   		; return error
 15820                                  	; 19/02/2023
 15821                                  	;jmp	short paRet
 15822                                  ;paOk:
 15823                                  	;clc				; return success		
 15824                                  paRet:	
 15825 000015F1 5E                      	pop	si			; restore SI
 15826 000015F2 C3                      	retn
 15827                                  
 15828                                  ; ---------------------------------------------------------------------------
 15829                                  
 15830                                  ;***	ParseLine - parse a line of text
 15831                                  ;
 15832                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15833                                  ;	error occurs.
 15834                                  ;
 15835                                  ;	ENTRY	DS:SI = ptr to text
 15836                                  ;		CS, DS, ES = TRANGROUP seg addr
 15837                                  ;
 15838                                  ;	EXIT	AX = last return code from system parser
 15839                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15840                                  ;
 15841                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15842                                  ;		DX = ptr to message block
 15843                                  ;
 15844                                  ;	USED	BX,CX,DX,SI,DI
 15845                                  ;
 15846                                  ;	EFFECTS
 15847                                  ;
 15848                                  ;	  Bits may contain new option settings.
 15849                                  ;	  DestBuf may contain new series of sort codes.
 15850                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15851                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15852                                  ;	  PathPos, PathCnt updated for new pathname.
 15853                                  ;
 15854                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15855                                  ;	  Msg_Disp_Class = parse error class
 15856                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15857                                  ;	  Message block (see DX) is set up for parse error message
 15858                                  
 15859                                  	; 19/02/2023
 15860                                  Parse_Line:
 15861                                  	; 04/05/2023
 15862 000015F3 BF[0485]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15863 000015F6 31C9                    	xor	cx,cx			; CX = # positionals found
 15864                                  plPars:
 15865 000015F8 E8BC0B                  	call	Parse_With_Msg		; call parser
 15866 000015FB 83F8FF                  	cmp	ax,-1
 15867                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15868 000015FE 7411                    	je	short plRet		; EOL encountered, return
 15869 00001600 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15870 00001603 750C                    	jne	short plRet		; parse error occurred, return
 15871                                  
 15872                                  ;	Parse call succeeded. We have a filespec or a switch.
 15873                                  ;	DX = ptr to result buffer
 15874                                  
 15875 00001605 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15876 00001607 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15877 0000160A 7406                    	je	short plFil		; we have a filespec
 15878                                  
 15879 0000160C E85900                  	call	ParseSwitch		; else we have a switch
 15880                                  	;jc	short plRet		; error parsing switch, return
 15881                                  	;jmp	short plPars		; parse more
 15882                                  	; 19/02/2023
 15883 0000160F 73E7                    	jnc	short plPars
 15884                                  plRet:
 15885 00001611 C3                      	retn	
 15886                                  plFil:	
 15887 00001612 E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15888 00001615 EBE1                    	jmp	short plPars		; parse more
 15889                                  ;plRet:
 15890                                  ;	retn
 15891                                  
 15892                                  ; ---------------------------------------------------------------------------
 15893                                  
 15894                                  ;***	ParseOrder - parse and record /O option
 15895                                  ;
 15896                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15897                                  ;
 15898                                  ;	EXIT	CY = set if error occurs parsing order
 15899                                  ;
 15900                                  ;		For parse error, we set up for Std_EPrintf call:
 15901                                  ;		AX = parse error code, like system parser
 15902                                  ;		DX = ptr to message block
 15903                                  ;
 15904                                  ;	USED	AX,CX,DX,DI
 15905                                  ;
 15906                                  ;	EFFECTS
 15907                                  ;
 15908                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15909                                  ;
 15910                                  ;	  For parse error, we set up for Std_EPrintf call:
 15911                                  ;	  Msg_Disp_Class = parse error message class
 15912                                  ;	  Message block (see DX) is set up for parse error message
 15913                                  
 15914                                  	; 19/02/2023
 15915                                  ParseOrder:
 15916 00001617 56                      	push	si			; save SI
 15917 00001618 53                      	push	bx			; save ptr to result buffer
 15918                                  
 15919                                  	;;mov	si,word ptr [bx].ValuePtr
 15920                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15921 00001619 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15922                                  	;mov	bx,offset TRANGROUP:DestBuf
 15923                                  	; 08/06/2023 (BugFix)
 15924 0000161C BB[2D8C]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 15925 0000161F 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15926 00001621 08C0                    	or	al,al
 15927 00001623 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15928                                  
 15929                                  ;	We have /O alone. Set standard sort order.
 15930                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15931                                  
 15932 00001625 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15933 00001628 43                      	inc	bx
 15934 00001629 C60701                  	mov	byte [bx],1		; then by name
 15935 0000162C 43                      	inc	bx
 15936 0000162D C60702                  	mov	byte [bx],2		; then by extension
 15937 00001630 43                      	inc	bx
 15938 00001631 EB2F                    	jmp	short poOk		; return success
 15939                                  
 15940                                  ;	We have /O<something>. Parse sort order letters.
 15941                                  
 15942                                  poLtr:	
 15943 00001633 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15944 00001635 AC                      	lodsb				; AL = next sort order letter
 15945 00001636 08C0                    	or	al,al
 15946 00001638 7428                    	jz	short poOk		; NUL found, return success
 15947                                  
 15948 0000163A 3C2D                    	cmp	al,'-'
 15949 0000163C 7503                    	jne	short po1		; not '-', go look for letter
 15950 0000163E B280                    	mov	dl,80h			; DL = downward sort mask
 15951 00001640 AC                      	lodsb				; AL = next char
 15952                                  po1:
 15953                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15954                                  	; 08/06/2023 (BugFix)
 15955 00001641 BF[3D84]                	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
 15956 00001644 B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15957 00001647 F2AE                    	repne	scasb			; look for our letter in the list
 15958 00001649 7510                    	jne	short poErr		; not found, return error
 15959                                  
 15960 0000164B F7D9                    	neg	cx
 15961 0000164D 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15962                                  
 15963 00001650 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15964 00001652 880F                    	mov	[bx],cl			; store sort order code in buffer
 15965 00001654 43                      	inc	bx			; BX = ptr to next spot in buffer
 15966                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15967 00001655 81FB[848C]              	cmp	bx,EndDestBuf
 15968                                  	;jae	short poErr		; too many letters
 15969                                  	;
 15970                                  	;jmp	short poLtr		; go look at next char
 15971                                  	; 19/02/2023
 15972 00001659 72D8                    	jb	short poLtr
 15973                                  
 15974                                  ;	The sort order string is invalid.  
 15975                                  
 15976                                  poErr:
 15977 0000165B 5B                      	pop	bx			; BX = ptr to result buffer
 15978 0000165C E80203                  	call	SetupParamError		; set message up for Std_EPrintf
 15979 0000165F F9                      	stc				; return failure
 15980 00001660 EB04                    	jmp	short poRet
 15981                                  poOk:	
 15982 00001662 C60700                  	mov	byte [bx],0		; mark end of sort code list
 15983 00001665 5B                      	pop	bx			; BX = ptr to result buffer
 15984                                  	; 19/02/2023
 15985                                  	;cf=0
 15986                                  	;clc				; return success
 15987                                  poRet:
 15988 00001666 5E                      	pop	si			; restore SI
 15989 00001667 C3                      	retn
 15990                                  
 15991                                  ; ---------------------------------------------------------------------------
 15992                                  
 15993                                  ;***	ParseSwitch - parse a switch
 15994                                  ;
 15995                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15996                                  ;		     a switch
 15997                                  ;
 15998                                  ;	EXIT	CY = set if parse error occurred
 15999                                  ;
 16000                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16001                                  ;		AX = parse error code, like system parser
 16002                                  ;		DX = ptr to message block
 16003                                  ;
 16004                                  ;	USED	AX,BX,DX
 16005                                  ;
 16006                                  ;	EFFECTS
 16007                                  ;
 16008                                  ;	  Bits may contain new option settings.
 16009                                  ;	  DestBuf may contain new series of sort codes.
 16010                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16011                                  ;
 16012                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16013                                  ;	  Msg_Disp_Class = parse error class
 16014                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16015                                  ;	  Message block (see DX) is set up for parse error message
 16016                                  
 16017                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16018                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 16019                                  ParseSwitch:
 16020 00001668 51                      	push	cx			; save CX
 16021 00001669 57                      	push	di			; save DI
 16022                                  
 16023                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 16024                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 16025 0000166A 8B4702                  	mov	ax,[bx+2]
 16026                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16027 0000166D BF[5485]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16028 00001670 B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16029 00001673 FC                      	cld				; scan direction = upward
 16030 00001674 F2AF                    	repne	scasw			; locate synonym ptr in list
 16031                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16032 00001676 81EF[5685]              	sub	di,Dir_Sw_Ptrs+2
 16033                                  
 16034                                  ;	DI = index into word list of synonym ptrs
 16035                                  
 16036 0000167A 2EFF95[8216]            	call	word [cs:di+SwHandler]	; use same index into call table
 16037                                  
 16038 0000167F 5F                      	pop	di			; restore DI
 16039 00001680 59                      	pop	cx			; restore CX
 16040                                  
 16041 00001681 C3                      	retn
 16042                                  
 16043                                  ; ---------------------------------------------------------------------------
 16044                                  
 16045                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16046                                  ;	Simple on/off switches must occur first in both lists, and must be
 16047                                  ;	  in order of option bits in Bits, starting with bit 0.
 16048                                  
 16049                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16050                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16051                                  
 16052                                  SwHandler:
 16053 00001682 [9415]                  	dw	OnOffSw		; /-W
 16054 00001684 [9415]                  	dw	OnOffSw		; /W
 16055 00001686 [9415]                  	dw	OnOffSw		; /-P
 16056 00001688 [9415]                  	dw	OnOffSw		; /P
 16057 0000168A [9415]                  	dw	OnOffSw		; /-S
 16058 0000168C [9415]                  	dw	OnOffSw		; /S
 16059 0000168E [9415]                  	dw	OnOffSw		; /-B
 16060 00001690 [9415]                  	dw	OnOffSw		; /B
 16061 00001692 [9415]                  	dw	OnOffSw		; /-L	;M010
 16062 00001694 [9415]                  	dw	OnOffSw		; /L	;M010
 16063 00001696 [8D15]                  	dw	NoOrder		; /-O
 16064 00001698 [1716]                  	dw	ParseOrder	; /O
 16065 0000169A [6C13]                  	dw	DefaultAttr	; /-A
 16066 0000169C [B115]                  	dw	ParseAttr	; /A
 16067                                  
 16068                                  ; ---------------------------------------------------------------------------
 16069                                  
 16070                                  	;break	<DIR utility routines>
 16071                                  
 16072                                  ;***	UTILITY ROUTINES
 16073                                  ; ---------------------- 
 16074                                  
 16075                                  ; ---------------------------------------------------------------------------
 16076                                  
 16077                                  ;***	ChangeDir - change directory on target drive
 16078                                  ;
 16079                                  ;	ENTRY	FCB contains drive #
 16080                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16081                                  ;
 16082                                  ;	EXIT	Changed current directory on drive
 16083                                  ;
 16084                                  ;		If error,
 16085                                  ;		CY = set
 16086                                  ;		DOS Get Extended Error call will get error
 16087                                  ;
 16088                                  ;	USED	AX,DX,SI,DI
 16089                                  ;
 16090                                  ;	EFFECTS
 16091                                  ;
 16092                                  ;	  DirBuf is used to build "d:string".
 16093                                  
 16094                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16095                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16096                                  
 16097                                  ChangeDir:
 16098                                  	;mov	di,offset TRANGROUP:DirBuf
 16099 0000169E BF[AA8B]                	mov	di,DIRBUF
 16100 000016A1 E8AC02                  	call	GetDriveLtr	; AX = "d:"
 16101 000016A4 AB                      	stosw			; put drive specifier in buffer
 16102 000016A5 89D6                    	mov	si,dx		; SI = ptr to argument string
 16103                                  cdLoop:
 16104 000016A7 AC                      	lodsb
 16105 000016A8 AA                      	stosb			; move byte to buffer
 16106 000016A9 08C0                    	or	al,al
 16107 000016AB 75FA                    	jne	short cdLoop	; continue until null transferred
 16108                                  
 16109                                  	;mov	dx,offset TRANGROUP:DirBuf
 16110 000016AD BA[AA8B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16111                                  	;mov	ah,CHDir
 16112 000016B0 B43B                    	mov	ah,3Bh
 16113 000016B2 CD21                    	int	21h		; change directory
 16114 000016B4 C3                      	retn			; return what CHDIR returns
 16115                                  
 16116                                  ; ---------------------------------------------------------------------------
 16117                                  
 16118                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16119                                  ;
 16120                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16121                                  ;		ES:DI = ptr to another ASCIIZ string
 16122                                  ;
 16123                                  ;	EXIT	flags set after REPE CMPSB
 16124                                  ;
 16125                                  ;	USED	AL,CX,SI,DI
 16126                                  ;
 16127                                  ;	NOTES
 16128                                  ;
 16129                                  ;	Maximum run of comparison is length of DS:SI string.
 16130                                  ;	This ensures that two identical strings followed by
 16131                                  ;	random characters will compare correctly.
 16132                                  
 16133                                  	; 19/02/2023
 16134                                  CmpAscz:
 16135                                  	; 07/06/2023
 16136 000016B5 56                      	push	si ; *
 16137                                  	;
 16138 000016B6 57                      	push	di
 16139                                  
 16140 000016B7 89F7                    	mov	di,si
 16141 000016B9 30C0                    	xor	al,al
 16142 000016BB B9FFFF                  	mov	cx,0FFFFh
 16143 000016BE F2AE                    	repne	scasb
 16144 000016C0 F7D1                    	not	cx
 16145                                  
 16146 000016C2 5F                      	pop	di
 16147 000016C3 F3A6                    	repe	cmpsb
 16148                                  
 16149                                  	; 07/06/2023
 16150 000016C5 5E                      	pop	si ; *
 16151                                  	;
 16152 000016C6 C3                      	retn
 16153                                  
 16154                                  ; ---------------------------------------------------------------------------
 16155                                  
 16156                                  ;***	CopyPathname - copy pathname to our buffer
 16157                                  ;
 16158                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16159                                  ;		     a filespec
 16160                                  ;
 16161                                  ;	EXIT	nothing
 16162                                  ;
 16163                                  ;	USED	AX
 16164                                  ;
 16165                                  ;	EFFECTS
 16166                                  ;
 16167                                  ;	  SrcBuf may contain a new pathname/filespec.
 16168                                  ;	  PathPos, PathCnt updated for new pathname.
 16169                                  
 16170                                  	; 19/02/2023
 16171                                  CopyPathname:
 16172 000016C7 56                      	push	si
 16173                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16174                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16175 000016C8 C57704                  	lds	si,[bx+4]
 16176                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16177 000016CB E8D515                  	call	Move_To_SrcBuf
 16178 000016CE 5E                      	pop	si
 16179 000016CF C3                      	retn
 16180                                  
 16181                                  ; ---------------------------------------------------------------------------
 16182                                  
 16183                                  ;***	CountFile - update counters with current file
 16184                                  ;
 16185                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16186                                  ;
 16187                                  ;	EXIT	nothing
 16188                                  ;
 16189                                  ;	USED	AX,DX
 16190                                  ;
 16191                                  ;	EFFECTS
 16192                                  ;
 16193                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16194                                  
 16195                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16196                                  CountFile:
 16197 000016D0 06                      	push	es			; save TRANGROUP seg addr
 16198 000016D1 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16199                                  
 16200 000016D5 FF06[CD8A]              	inc	word [FileCnt]		; # files this directory
 16201 000016D9 FF06[D38A]              	inc	word [FileCntTotal]	; # files total
 16202 000016DD 7504                    	jnz	short cntf1
 16203 000016DF FF06[D58A]              	inc	word [FileCntTotal+2]
 16204                                  cntf1:
 16205                                  	;mov	ax,word ptr es:[bx].filesize
 16206                                  					; AX = low word of file size
 16207                                  	;mov	dx,word ptr es:[bx].filesize+2
 16208                                  					; DX = high word of file size
 16209 000016E3 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16210 000016E7 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16211 000016EB 0106[CF8A]              	add	[FileSiz],ax
 16212 000016EF 1116[D18A]              	adc	[FileSiz+2],dx		; size of this directory
 16213 000016F3 0106[D78A]              	add	[FileSizTotal],ax
 16214 000016F7 1116[D98A]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16215                                  
 16216 000016FB 07                      	pop	es			; ES = TRANGROUP seg addr again
 16217                                  dbRet:	; 19/02/2023
 16218 000016FC C3                      	retn
 16219                                  
 16220                                  ; ---------------------------------------------------------------------------
 16221                                  
 16222                                  ;***	DisplayBare - display filename in bare format
 16223                                  ;
 16224                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16225                                  ;
 16226                                  ;	EXIT	DX = # char's displayed, including dot
 16227                                  ;
 16228                                  ;	USED	AX,CX,SI,DI
 16229                                  ;
 16230                                  ;	EFFECTS
 16231                                  ;
 16232                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16233                                  ;	  If /s is on, complete pathname is displayed.
 16234                                  ;
 16235                                  ;	NOTE
 16236                                  ;
 16237                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16238                                  
 16239                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16240                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16241                                  
 16242                                  DisplayBare:
 16243                                  ;	Suppress . and .. files from bare listing.
 16244                                  
 16245 000016FD 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16246 000016FF 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16247                                  	;assume	ds:NOTHING
 16248                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16249 00001703 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16250 00001707 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16251                                  	;assume	ds:TRANGROUP
 16252 00001709 74F1                    	je	short dbRet		; it's . or .. - don't display
 16253                                  
 16254                                  	;;;test	Bits,mask subd
 16255                                  	;;test	word [_Bits],4
 16256                                  	;test	byte [_Bits],4
 16257 0000170B F606[FC8B]04            	test	byte [_Bits],mask.subd
 16258 00001710 7431                    	jz	short dbNameExt		; not /s - display filename only
 16259                                  
 16260                                  	;invoke	Build_Dir_String
 16261 00001712 E83507                  	call	build_dir_string
 16262                                  	;mov	di,offset TRANGROUP:BwdBuf
 16263 00001715 BF[AA8B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16264                                     
 16265                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16266                                  	;;test	word [_Bits],10h
 16267                                  	;test	byte [_Bits],10h
 16268 00001718 F606[FC8B]10            	test	byte [_Bits],mask.lcase
 16269                                  	;jz	@F			;M010;lowercase not needed
 16270 0000171D 7405                    	jz	short dbare1
 16271 0000171F 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16272 00001721 E87E02                  	call	LowercaseString		;M010;path string is in BwdBuf
 16273                                  dbare1:
 16274                                  ;@@:	
 16275                                  	;xor	al,al			; AL = 0
 16276                                  	; 19/02/2023
 16277 00001724 31C0                    	xor	ax,ax
 16278 00001726 B9FFFF                  	mov	cx,0FFFFh
 16279 00001729 FC                      	cld
 16280 0000172A F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16281 0000172C 4F                      	dec	di			; ES:DI = ptr to null byte
 16282                                  
 16283 0000172D 26807DFF5C              	cmp	byte [es:di-1],'\'
 16284                                  	;je	@F
 16285 00001732 7403                    	je	short dbare2		; already terminated w/ '\'
 16286                                  
 16287                                  	;mov	ax,'\'			; AX = '\',0
 16288 00001734 B05C                    	mov	al,'\'
 16289 00001736 AB                      	stosw				; add to dir string
 16290                                  ;@@:
 16291                                  dbare2:
 16292                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16293 00001737 C706[118C][AA8B]        	mov	word [string_ptr_2],BWDBUF
 16294                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16295 0000173D BA[C380]                	mov	dx,string_buf_ptr
 16296                                  	;invoke	Std_Printf		; display device & directory path
 16297 00001740 E88E36                  	call	std_printf
 16298                                  dbNameExt:
 16299 00001743 E82D00                  	call	DisplayDotForm		; display name.ext
 16300                                  	;invoke	CrLf2			; display cr/lf
 16301 00001746 E8860E                  	call	CRLF2
 16302                                  	; 19/02/2023
 16303                                  	;call	UseLine			;M007;Allow /p with /b
 16304                                  ;dbRet:
 16305                                  	;retn
 16306                                  
 16307                                  	; 19/02/2023
 16308                                  	;jmp	short UseLine
 16309                                  
 16310                                  ; ---------------------------------------------------------------------------
 16311                                  
 16312                                  ;***	UseLine - use a display line, start a new page if none left
 16313                                  ;
 16314                                  ;	ENTRY	nothing
 16315                                  ;
 16316                                  ;	EXIT	nothing
 16317                                  ;
 16318                                  ;	USED	flags
 16319                                  
 16320                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16321                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16322                                  UseLine:
 16323 00001749 FF0E[CB8A]              	dec	word [LeftOnPage]
 16324 0000174D 833E[CB8A]02            	cmp	word [LeftOnPage],2
 16325 00001752 771E                    	ja	short ulRet
 16326                                  	; 19/02/2023
 16327                                  	;call	EndPage
 16328                                  ;ulRet:
 16329                                  	;retn
 16330                                  
 16331                                  	; 19/02/2023
 16332                                  	;jmp	short EndPage
 16333                                  
 16334                                  ; ---------------------------------------------------------------------------
 16335                                  
 16336                                  ;***	EndPage - end the current display page
 16337                                  ;
 16338                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16339                                  ;		Current directory (on selected drive) is the one being listed
 16340                                  ;		Bits contains /p setting
 16341                                  ;
 16342                                  ;	EXIT	LeftOnPage = # lines left for next page
 16343                                  ;
 16344                                  ;	USED	AX,DX
 16345                                  ;
 16346                                  ;	EFFECTS
 16347                                  ;
 16348                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16349                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16350                                  
 16351                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16352                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16353                                  
 16354                                  EndPage:
 16355                                  	;;;test	Bits,mask pagd
 16356                                  	;;test	word [_Bits],2
 16357                                  	;test	byte [_Bits],2
 16358 00001754 F606[FC8B]02            	test	byte [_Bits],mask.pagd
 16359 00001759 7410                    	jz	short epNew		; paged display isn't enabled
 16360                                  
 16361 0000175B 53                      	push	bx			; save BX
 16362 0000175C 51                      	push	cx			; save CX
 16363                                  
 16364                                  	;invoke	Pause			; "Press any key to continue..."
 16365 0000175D E85302                  	call	PAUSE
 16366                                  
 16367                                  	;invoke	Build_Dir_String
 16368 00001760 E8E706                  	call	build_dir_string
 16369                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16370 00001763 BA[3E81]                	mov	dx,dircont_ptr
 16371                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16372 00001766 E85A36                  	call	Printf_Crlf
 16373                                  
 16374 00001769 59                      	pop	cx			; restore CX
 16375 0000176A 5B                      	pop	bx			; restore BX
 16376                                  epNew:	
 16377 0000176B A1[778D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16378 0000176E 48                      	dec	ax			; AX = # lines till next EndPage
 16379 0000176F A3[CB8A]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16380                                  ulRet:	
 16381                                  	; 19/02/2023
 16382 00001772 C3                      	retn
 16383                                  
 16384                                  ; ---------------------------------------------------------------------------
 16385                                  
 16386                                  ;***	DisplayDotForm - display filename in compressed dot format
 16387                                  ;
 16388                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16389                                  ;	if the filename has a nonblank extension.
 16390                                  ;
 16391                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16392                                  ;
 16393                                  ;	EXIT	DX = # char's displayed, including dot
 16394                                  ;
 16395                                  ;	USED	AX,CX,SI,DI
 16396                                  ;
 16397                                  ;	EFFECTS
 16398                                  ;
 16399                                  ;	  Filename is displayed in name.ext format.
 16400                                  ;
 16401                                  ;	NOTE
 16402                                  ;
 16403                                  ;	  We allow for bogus filenames that have blanks embedded
 16404                                  ;	  in the name or extension.
 16405                                  
 16406                                  ;	Bugbug:	might be a good performance gain if we buffered
 16407                                  ;	up the output and used DOS function 9.
 16408                                  
 16409                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16410                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16411                                  
 16412                                  DisplayDotForm:
 16413 00001773 1E                      	push	ds			; save TRANGROUP seg addr
 16414 00001774 06                      	push	es			; save ES
 16415 00001775 2EA1[A78A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16416 00001779 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16417                                  	;assume	ds:nothing
 16418 0000177B 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16419                                  
 16420                                  	; 08/06/2023
 16421                                  	;mov	di,bx			; ES:DI = ptr to entry
 16422                                  	;;;add	di,filename + size filename - 1
 16423                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16424                                  	;;mov	cx,size filename	; CX = length of name field
 16425                                  	;mov	cx,8
 16426                                  	; 08/06/2023
 16427 0000177D B90800                  	mov	cx,8
 16428 00001780 89CF                    	mov	di,cx
 16429 00001782 01DF                    	add	di,bx
 16430                                  	
 16431 00001784 B020                    	mov	al,' '
 16432 00001786 FD                      	std				; scan down
 16433 00001787 F3AE                    	repe	scasb			; scan for nonblank
 16434                                  
 16435                                  ;	Assume file name has at least one character.
 16436                                  
 16437 00001789 41                      	inc	cx			; CX = # chars in name
 16438 0000178A 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16439                                  
 16440 0000178C 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16441                                  	;;add	si,filename		; DS:SI = ptr to name
 16442                                  	;add	si,1 
 16443                                  	;		; add si,EntryStruc.filename
 16444                                  	; 25/04/2023
 16445 0000178E 46                      	inc	si
 16446                                  NextNameChar:
 16447 0000178F FC                      	cld
 16448 00001790 AC                      	lodsb				; AL = next char
 16449                                  
 16450                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16451                                  	;;test	word [ss:_Bits],10h
 16452                                  	;test	byte [ss:_Bits],10h
 16453 00001791 36F606[FC8B]10          	test	byte [ss:_Bits],mask.lcase
 16454                                  	;jz	short @F		;M010;lowercase not required
 16455 00001797 7403                    	jz	short ddf1
 16456 00001799 E8FB01                  	call	LowerCase		;M010;filename char is in AL
 16457                                  ddf1:
 16458                                  ;@@:	
 16459                                  	;invoke	Print_Char		; display it
 16460 0000179C E85C06                  	call	PRINT_CHAR
 16461 0000179F E2EE                    	loop	NextNameChar
 16462                                  
 16463                                  ;	Now do extension.
 16464                                  
 16465 000017A1 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16466                                  	;add	di,fileext + size fileext - 1
 16467 000017A3 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16468                                  	;mov	cx,size fileext		; CX = length of ext field
 16469 000017A6 B90300                  	mov	cx,3
 16470 000017A9 B020                    	mov	al,' '
 16471 000017AB FD                      	std				; scan down
 16472 000017AC F3AE                    	repe	scasb			; scan for nonblank
 16473 000017AE 7420                    	je	short ddDone		; no nonblank chars in ext
 16474                                  
 16475 000017B0 41                      	inc	cx			; CX = # chars in ext
 16476 000017B1 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16477 000017B3 42                      	inc	dx			;      including dot
 16478                                  
 16479 000017B4 B02E                    	mov	al,'.'
 16480 000017B6 E84206                  	call	PRINT_CHAR
 16481 000017B9 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16482                                  	;add	si,fileext		; DS:SI = ptr to ext
 16483 000017BB 83C609                  	add	si,9
 16484                                  
 16485                                  NextExtChar:
 16486 000017BE FC                      	cld
 16487 000017BF AC                      	lodsb				; AL = next char
 16488                                  
 16489                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16490                                  	;;test	word [cs:_Bits],10h
 16491                                  	;test	byte [cs:_Bits],10h
 16492 000017C0 2EF606[FC8B]10          	test	byte [cs:_Bits],mask.lcase
 16493                                  	;jz	short @F		;M010;lowercase not required
 16494 000017C6 7403                    	jz	short ddf2
 16495 000017C8 E8CC01                  	call	LowerCase		;M010;fileext char is in AL
 16496                                  ;@@:	
 16497                                  ddf2:
 16498                                  	;invoke	Print_Char		; display it
 16499 000017CB E82D06                  	call	PRINT_CHAR
 16500 000017CE E2EE                    	loop	NextExtChar
 16501                                  ddDone:
 16502 000017D0 07                      	pop	es			; restore ES
 16503 000017D1 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16504                                  	;assume	ds:TRANGROUP
 16505 000017D2 FC                      	cld				; leave direction flag = up
 16506 000017D3 C3                      	retn
 16507                                  
 16508                                  ; ---------------------------------------------------------------------------
 16509                                  
 16510                                  ;***	DisplayFile - display file entry, update counters
 16511                                  ;
 16512                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16513                                  ;		Bits contains /w, /p settings
 16514                                  ;
 16515                                  ;	EXIT	nothing
 16516                                  ;
 16517                                  ;	USED	AX,CX,DX,SI,DI,BP
 16518                                  ;
 16519                                  ;	EFFECTS
 16520                                  ;
 16521                                  ;	  Entry is displayed.
 16522                                  ;	  If not /b,
 16523                                  ;	    Cursor is left at end of entry on screen.
 16524                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16525                                  ;	  If /b,
 16526                                  ;	    Cursor is left at beginning of next line.
 16527                                  ;	    Cnt's and Siz's aren't updated.
 16528                                  
 16529                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16530                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16531                                  
 16532                                  DisplayFile:
 16533                                  	;;;test	Bits,mask bare
 16534                                  	;;test	word [_Bits],8
 16535                                  	;test	byte [_Bits],8
 16536 000017D4 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16537 000017D9 7405                    	jz	short dfNorm		; not /b - do normal display
 16538                                  
 16539 000017DB E81FFF                  	call	DisplayBare		; display file in bare format
 16540 000017DE EB18                    	jmp	short dfRet
 16541                                  dfNorm:	
 16542 000017E0 E87800                  	call	DisplayNext		; pos'n cursor for next entry
 16543                                  	;;;test	Bits,mask wide
 16544                                  	;;test	word [_Bits],1
 16545                                  	;test	byte [_Bits],1
 16546 000017E3 F606[FC8B]01            	test	byte [_Bits],mask.wide
 16547 000017E8 7405                    	jz	short dfFull		; full format
 16548 000017EA E83701                  	call	DisplayWide		; wide format
 16549 000017ED EB06                    	jmp	short dfCnt
 16550                                  dfFull:	
 16551 000017EF E83400                  	call	DisplayName		; display filename & extension
 16552 000017F2 E88D00                  	call	DisplayTheRest		; display size, date, time
 16553                                  dfCnt:
 16554 000017F5 E8D8FE                  	call	CountFile		; update file counters
 16555                                  dfRet:
 16556                                  dhRet:	; 19/02/2023
 16557 000017F8 C3                      	retn
 16558                                  
 16559                                  ; ---------------------------------------------------------------------------
 16560                                  
 16561                                  ;***	DisplayHeader - display directory header of working directory
 16562                                  ;
 16563                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16564                                  ;		LeftOnPage = # lines left on display page
 16565                                  ;
 16566                                  ;	EXIT	nothing
 16567                                  ;
 16568                                  ;	ERROR EXIT
 16569                                  ;
 16570                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16571                                  ;	   specification" if there's a problem obtaining the current
 16572                                  ;	   directory pathname.
 16573                                  ;
 16574                                  ;	USED	AX,DX,SI,DI
 16575                                  ;
 16576                                  ;	EFFECTS
 16577                                  ;
 16578                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16579                                  ;	   we are using for the DTA) contains the directory string.
 16580                                  ;	  LeftOnPage is adjusted.
 16581                                  
 16582                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16583                                  
 16584                                  DisplayHeader:
 16585                                  	;;;test	Bits,mask bare
 16586                                  	;;test	word [_Bits],8
 16587                                  	;test	byte [_Bits],8
 16588 000017F9 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16589 000017FE 75F8                    	jnz	short dhRet		; /b - don't display header
 16590                                  
 16591                                  	;;;test	Bits,mask subd
 16592                                  	;;test	word [_Bits],4
 16593                                  	;test	byte [_Bits],4
 16594 00001800 F606[FC8B]04            	test	byte [_Bits],mask.subd
 16595 00001805 7408                    	jz	short dhNorm		; not /s
 16596                                  
 16597                                  ;	For subdirectory listings, put a blank line before the header.
 16598                                  
 16599                                  	;invoke	Crlf2			; start with a blank line
 16600 00001807 E8C50D                  	call	CRLF2
 16601 0000180A E83CFF                  	call	UseLine
 16602 0000180D EB05                    	jmp	short dhCom
 16603                                  dhNorm:
 16604 0000180F B020                    	mov	al,' ' ; 20h
 16605                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16606 00001811 E8E705                  	call	PRINT_CHAR		; print a leading blank
 16607                                  dhCom:
 16608 00001814 E83306                  	call	build_dir_string
 16609 00001817 BA[4380]                	mov	dx,dirhead_ptr
 16610 0000181A E8B435                  	call	std_printf		; print header & cr/lf
 16611 0000181D E829FF                  	call	UseLine
 16612 00001820 E8AC0D                  	call	CRLF2			; another cr/lf
 16613                                  	;call	UseLine
 16614                                  ;dhRet:
 16615                                  	;retn
 16616                                  
 16617                                  	; 19/02/2023
 16618 00001823 E923FF                  	jmp	UseLine
 16619                                  
 16620                                  ; ---------------------------------------------------------------------------
 16621                                  
 16622                                  ;***	DisplayName - display file name & extension
 16623                                  ;
 16624                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16625                                  ;
 16626                                  ;	EXIT	nothing
 16627                                  ;
 16628                                  ;	USED	AX,CX,DX,SI,DI
 16629                                  ;
 16630                                  ;	EFFECTS
 16631                                  ;
 16632                                  ;	  Filename & extension are displayed in spread format.
 16633                                  ;	  Cursor is left at end of extension.
 16634                                  
 16635                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16636                                  	; 08/06/2023
 16637                                  DisplayName:
 16638 00001826 1E                      	push	ds			; save TRANGROUP seg addr
 16639 00001827 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16640                                  	;assume	ds:nothing
 16641 0000182B 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16642                                  	;add	si,filename		; DS:SI = ptr to filename
 16643                                  	;add	si,1  ; EntryStruc.filename
 16644                                  	; 08/06/2023
 16645 0000182D 46                      	inc	si
 16646 0000182E BF[DB8A]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16647                                  
 16648 00001831 B90800                  	mov	cx,8
 16649 00001834 FC                      	cld
 16650 00001835 F3A4                    	rep	movsb			; move filename to CharBuf
 16651 00001837 B020                    	mov	al,' '
 16652 00001839 AA                      	stosb				; add a blank
 16653                                  	;mov	cx,3
 16654                                  	; 08/06/2023
 16655 0000183A B103                    	mov	cl,3
 16656 0000183C F3A4                    	rep	movsb			; add extension
 16657 0000183E 30C0                    	xor	al,al
 16658 00001840 AA                      	stosb				; add a NULL
 16659                                  
 16660 00001841 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16661                                  	;assume	ds:TRANGROUP
 16662                                  
 16663                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16664                                  	;;test	word [_Bits],10h
 16665                                  	;test	byte [_Bits],10h
 16666 00001842 F606[FC8B]10            	test	byte [_Bits],mask.lcase
 16667 00001847 7406                    	jz	short dn1		;M010;lowercase not required
 16668 00001849 BE[DB8A]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16669 0000184C E85301                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16670                                  dn1:	
 16671 0000184F C706[118C][DB8A]        	mov	word [string_ptr_2],CHARBUF
 16672 00001855 BA[C380]                	mov	dx,string_buf_ptr
 16673                                  	;call	std_printf		; print filename & extension
 16674                                  	;retn
 16675                                  	; 19/02/2023
 16676 00001858 E97635                  	jmp	std_printf
 16677                                  
 16678                                  ; ---------------------------------------------------------------------------
 16679                                  
 16680                                  ;***	DisplayNext - move display cursor to next entry position
 16681                                  ;
 16682                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16683                                  ;		LeftOnPage = # lines can still be printed for this page
 16684                                  ;		FileCnt = # files in this dir displayed before this one
 16685                                  ;		Bits contains /w setting
 16686                                  ;
 16687                                  ;	EXIT	nothing
 16688                                  ;
 16689                                  ;	USED	AX,DX
 16690                                  ;
 16691                                  ;	EFFECTS
 16692                                  ;
 16693                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16694                                  ;	   displayed.
 16695                                  ;	  LeftOnPage may be updated.
 16696                                  
 16697                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16698                                  
 16699                                  DisplayNext:
 16700 0000185B 833E[CD8A]00            	cmp	word [FileCnt],0
 16701 00001860 7415                    	je	short dn1st		; 1st file in directory
 16702 00001862 803E[C98A]00            	cmp	byte [LeftOnLine],0
 16703 00001867 7E08                    	jng	short dnEol		; no more room on this line
 16704                                  
 16705                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16706                                  ;	we still have room for more on this line.
 16707                                  ;	Tab to next position.
 16708                                  
 16709 00001869 BA[D280]                	mov	dx,tab_ptr
 16710 0000186C E86235                  	call	std_printf
 16711 0000186F EB0C                    	jmp	short dnDone
 16712                                  dnEol:	
 16713                                  ;	Start this entry on a new line.
 16714                                  
 16715 00001871 E85B0D                  	call	CRLF2		; start on new line
 16716 00001874 E8D2FE                  	call	UseLine
 16717                                  dn1st:
 16718 00001877 A0[CA8A]                	mov	al,[PerLine]
 16719 0000187A A2[C98A]                	mov	[LeftOnLine],al	; reset # entries left on line
 16720                                  
 16721                                  dnDone:
 16722 0000187D FE0E[C98A]              	dec	byte [LeftOnLine]
 16723                                  				; reflect the entry about to be displayed
 16724 00001881 C3                      	retn
 16725                                  
 16726                                  ; ---------------------------------------------------------------------------
 16727                                  
 16728                                  ;***	DisplayTheRest - display file size/dir, date, time
 16729                                  ;
 16730                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16731                                  ;		Display cursor is at end of file extension
 16732                                  ;
 16733                                  ;	EXIT	nothing
 16734                                  ;
 16735                                  ;	USED	AX,CX,DX,SI,DI,BP
 16736                                  ;
 16737                                  ;	EFFECTS
 16738                                  ;
 16739                                  ;	  File size, date, & time are displayed.
 16740                                  
 16741                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16742                                  DisplayTheRest:
 16743 00001882 06                      	push	es			; save TRANGROUP seg addr
 16744 00001883 8E06[A78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16745 00001887 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16746                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16747                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16748 00001889 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16749 0000188E 7408                    	jz	short drNonDir		; not a directory file
 16750                                  
 16751                                  ;	For a directory file, display <DIR> instead of size.
 16752                                  
 16753 00001890 BA[D580]                	mov	dx,dmes_ptr
 16754 00001893 E83B35                  	call	std_printf
 16755 00001896 EB16                    	jmp	short drCom		; skip to common fields
 16756                                  
 16757                                  drNonDir:
 16758                                  ;	For a non-directory file, display file size.
 16759                                  
 16760                                  	;;mov	dx,word ptr es:[bp].filesize
 16761                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16762 00001898 268B5611                	mov	dx,[es:bp+17]
 16763 0000189C 8916[0D8C]              	mov	[File_Size_Low],dx
 16764                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16765                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16766 000018A0 268B5613                	mov	dx,[es:bp+19]
 16767 000018A4 8916[0F8C]              	mov	[File_Size_High],dx
 16768 000018A8 BA[B580]                	mov	dx,disp_file_size_ptr
 16769 000018AB E82335                  	call	std_printf
 16770                                  drCom:
 16771                                  ;	For all files, display date & time.
 16772                                  
 16773                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16774                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16775 000018AE 268B460F                	mov	ax,[es:bp+15]
 16776 000018B2 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16777 000018B4 7448                    	jz	short drDone		; no date, skip date/time display
 16778 000018B6 89C3                    	mov	bx,ax			; BX = date word
 16779 000018B8 83E01F                  	and	ax,1Fh			; AX = day of month
 16780 000018BB 88C2                    	mov	dl,al			; DL = day of month
 16781 000018BD 89D8                    	mov	ax,bx			; AX = date word
 16782 000018BF B105                    	mov	cl,5
 16783 000018C1 D3E8                    	shr	ax,cl			; shift day out
 16784 000018C3 240F                    	and	al,0Fh			; AL = month
 16785 000018C5 88C6                    	mov	dh,al			; DH = month
 16786 000018C7 88F9                    	mov	cl,bh
 16787 000018C9 D0E9                    	shr	cl,1			; CL = year - 1980
 16788 000018CB 30ED                    	xor	ch,ch			; CX = year - 1980
 16789 000018CD 83C150                  	add	cx,80			; CX = 2-digit year
 16790 000018D0 80F964                  	cmp	cl,100
 16791 000018D3 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16792 000018D5 80E964                  	sub	cl,100			; adjust for 21st century
 16793                                  dr_1:	
 16794 000018D8 86F2                    	xchg	dh,dl			; DX = month/day
 16795 000018DA 890E[1381]              	mov	[DirDat_Yr],cx		; move year to msg block
 16796 000018DE 8916[1581]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16797                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16798                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16799 000018E2 268B4E0D                	mov	cx,[es:bp+13]
 16800 000018E6 E310                    	jcxz	drPrint			; no time field - go print
 16801 000018E8 D1E9                    	shr	cx,1
 16802 000018EA D1E9                    	shr	cx,1
 16803 000018EC D1E9                    	shr	cx,1			; CH = hours
 16804 000018EE D0E9                    	shr	cl,1
 16805 000018F0 D0E9                    	shr	cl,1			; CL = minutes
 16806 000018F2 86E9                    	xchg	ch,cl			; CX = hr/min
 16807 000018F4 890E[1E81]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16808                                  drPrint:
 16809 000018F8 BA[0E81]                	mov	dx,dirdattim_ptr
 16810 000018FB E8D334                  	call	std_printf		; print date & time
 16811                                  drDone:
 16812 000018FE 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16813 000018FF 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16814                                  dtrRet:
 16815                                  	; 19/02/2023
 16816 00001901 C3                      	retn
 16817                                  
 16818                                  ; ---------------------------------------------------------------------------
 16819                                  
 16820                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16821                                  ;
 16822                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16823                                  ;		FileCnt = # files listed
 16824                                  ;		FileSiz = total size of files listed
 16825                                  ;
 16826                                  ;	EXIT	nothing
 16827                                  ;
 16828                                  ;	USED
 16829                                  ;
 16830                                  ;	EFFECTS
 16831                                  ;
 16832                                  ;	  Trailing info lines are displayed
 16833                                  
 16834                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16835                                  
 16836                                  DisplayTrailer:
 16837                                  	;;;test	Bits,mask bare
 16838                                  	;;test	word [_Bits],8
 16839                                  	;test	byte [_Bits],8
 16840 00001902 F606[FC8B]08            	test	byte [_Bits],mask.bare
 16841 00001907 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16842                                  
 16843 00001909 E8C30C                  	call	CRLF2			; start on new line
 16844 0000190C E83AFE                  	call	UseLine
 16845 0000190F A1[CD8A]                	mov	ax,[FileCnt]		; AX = # files found
 16846                                  
 16847                                  ;	DisplayTotals uses this entry point.
 16848                                  ;
 16849                                  DisplayCntSiz:
 16850                                  ;	AX = # files
 16851                                  ;	FileSiz = dword total size of files
 16852                                  
 16853 00001912 A3[168C]                	mov	[Dir_Num],ax		; load # files
 16854 00001915 BA[3C7F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16855 00001918 E8B634                  	call	std_printf		; "nnn File(s)"
 16856                                  
 16857 0000191B BA[2A81]                	mov	dx,bytes_ptr
 16858 0000191E E8B034                  	call	std_printf		; "nnn bytes",cr,lf
 16859                                  	; 19/02/2023
 16860                                  	;call	UseLine
 16861                                  ;dtrRet:
 16862                                  	;retn
 16863                                  
 16864                                  	; 19/02/2023
 16865 00001921 E925FE                  	jmp	UseLine
 16866                                  
 16867                                  ; ---------------------------------------------------------------------------
 16868                                  
 16869                                  ;***	DisplayWide - display filename in wide format
 16870                                  ;
 16871                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16872                                  ;
 16873                                  ;	EXIT	nothing
 16874                                  ;
 16875                                  ;	USED	AX,CX,DX,SI,DI
 16876                                  ;
 16877                                  ;	EFFECTS
 16878                                  ;
 16879                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16880                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16881                                  
 16882                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16883                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16884                                  
 16885                                  DisplayWide:
 16886 00001924 1E                      	push	ds			; save TRANGROUP seg addr
 16887 00001925 8E1E[A78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16888                                  	;assume	ds:nothing
 16889                                  
 16890                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16891                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16892 00001929 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16893 0000192D 9C                      	pushf	; 03/08/2024
 16894 0000192E 7405                    	jz	short dw1		; not a subdirectory file
 16895 00001930 B05B                    	mov	al,'['
 16896 00001932 E8C604                  	call	PRINT_CHAR		; prefix subdirectory
 16897                                  dw1:	
 16898 00001935 E83BFE                  	call	DisplayDotForm		; display name.ext
 16899                                  
 16900                                  ;	DX = # chars displayed in name.ext
 16901                                  
 16902                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16903                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16904                                  	; 03/08/2024
 16905                                  	;test	byte [bx+12],ATTR_DIRECTORY
 16906 00001938 9D                      	popf	; 03/08/2024
 16907 00001939 7405                    	jz	short dw2		; not a subdirectory file
 16908 0000193B B05D                    	mov	al,']'
 16909 0000193D E8BB04                  	call	PRINT_CHAR		; postfix subdirectory
 16910                                  dw2:
 16911                                  ;	Pad field with blanks.
 16912                                  
 16913                                  	;mov	cx,size filename + size fileext + 1
 16914 00001940 B90C00                  	mov	cx,12 ; 8+3+1
 16915                                  					; CX = field size
 16916 00001943 29D1                    	sub	cx,dx			; CX = # pad char's
 16917 00001945 E307                    	jcxz	dwDone
 16918 00001947 B020                    	mov	al,' '
 16919                                  dw3:	
 16920 00001949 E8AF04                  	call	PRINT_CHAR
 16921 0000194C E2FB                    	loop	dw3
 16922                                  dwDone:	
 16923 0000194E 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16924                                  	;assume	ds:TRANGROUP
 16925 0000194F C3                      	retn
 16926                                  
 16927                                  ; ---------------------------------------------------------------------------
 16928                                  
 16929                                  ;***	GetDriveLtr - get target drive letter
 16930                                  ;
 16931                                  ;	ENTRY	FCB contains drive #
 16932                                  ;
 16933                                  ;	EXIT	AX = "d:"
 16934                                  ;
 16935                                  ;	USED	nothing
 16936                                  
 16937                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16938                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16939                                  GetDriveLtr:
 16940 00001950 A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16941 00001953 08C0                    	or	al,al
 16942 00001955 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16943 00001957 A0[B78A]                	mov	al,[CURDRV]	; AL = current drive #
 16944 0000195A FEC0                    	inc	al		; AL = 1-based drive #
 16945                                  gdl1:	
 16946 0000195C 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16947 0000195E B43A                    	mov	ah,':'		; AX = "d:"
 16948 00001960 C3                      	retn
 16949                                  
 16950                                  ; ---------------------------------------------------------------------------
 16951                                  
 16952                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16953                                  ;
 16954                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16955                                  ;	for system parser calls. Set up a message substitution block,
 16956                                  ;	etc. for invalid value strings. I copied the procedure from
 16957                                  ;	Setup_Parse_Error_Msg.
 16958                                  ;
 16959                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16960                                  ;		
 16961                                  ;
 16962                                  ;	EXIT	AX = system parser error return code for bad param format
 16963                                  ;		DX = ptr to message description block for Std_EPrintf
 16964                                  ;
 16965                                  ;	USED	SI
 16966                                  ;
 16967                                  ;	EFFECTS
 16968                                  ;
 16969                                  ;	  Msg_Disp_Class = parse error message class
 16970                                  ;	  Message block (see DX) is set up for parse error message
 16971                                  
 16972                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16973                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16974                                  SetupParamError:
 16975 00001961 B80900                  	mov	ax,9			; parse error #
 16976 00001964 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 16977                                  	;mov	byte [msg_disp_class],2
 16978 00001969 A3[FC7E]                	mov	[extend_buf_ptr],ax
 16979                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16980 0000196C 8B7704                  	mov	si,[bx+4]
 16981 0000196F 8936[118C]              	mov	[string_ptr_2],si
 16982 00001973 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 16983                                  	;mov	byte [extend_buf_sub],1
 16984 00001978 BA[FC7E]                	mov	dx,extend_buf_ptr
 16985 0000197B C3                      	retn
 16986                                  
 16987                                  ; ---------------------------------------------------------------------------
 16988                                  
 16989                                  ;***	ZeroTotals - zero grand total file count, size
 16990                                  ;
 16991                                  ;	ENTRY	nothing
 16992                                  ;
 16993                                  ;	EXIT	nothing
 16994                                  ;
 16995                                  ;	USED	AX
 16996                                  ;
 16997                                  ;	EFFECTS
 16998                                  ;
 16999                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 17000                                  ;
 17001                                  ;	NOTES
 17002                                  ;
 17003                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 17004                                  	
 17005                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17006                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 17007                                  ZeroTotals:
 17008 0000197C BF[D38A]                	mov	di,FileCntTotal
 17009                                  
 17010                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 17011 0000197F B90800                  	mov	cx,8
 17012                                  
 17013 00001982 30C0                    	xor	al,al
 17014 00001984 F3AA                    	rep	stosb
 17015 00001986 C3                      	retn	
 17016                                  
 17017                                  ; ---------------------------------------------------------------------------
 17018                                  
 17019                                  ;***	CtrlCHandler - our own control-c handler
 17020                                  ;
 17021                                  ;	Make sure user's default directory gets restored. See notes
 17022                                  ;	at InstallCtrlCHandler.
 17023                                  ;
 17024                                  ;	ENTRY	control-c
 17025                                  ;
 17026                                  ;	EXIT	to OldCtrlCHandler
 17027                                  ;
 17028                                  ;	USED	DS,flags
 17029                                  ;
 17030                                  ;	EFFECTS
 17031                                  ;
 17032                                  ;	  Restore user's default directory.
 17033                                  ;
 17034                                  ;	NOTES
 17035                                  ;
 17036                                  ;	  This handler is only installed after calling PathCrunch,
 17037                                  ;	  which sets UserDir1, so the restoration will work.
 17038                                  ;
 17039                                  ;	  The original control-c vector will be restored, whether
 17040                                  ;	  or not this one is invoked, in the HeadFix routine.
 17041                                  
 17042                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17043                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17044                                  
 17045                                  CtrlCHandler:	;proc	far
 17046                                  
 17047                                  ;SR;
 17048                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17049                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17050                                  ;
 17051 00001987 1E                      	push	ds
 17052 00001988 0E                      	push	cs
 17053 00001989 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17054 0000198A 50                      	push	ax
 17055 0000198B 52                      	push	dx
 17056 0000198C E8FD0A                  	call	RestUDir		; restore user's default directory
 17057 0000198F 5A                      	pop	dx
 17058 00001990 58                      	pop	ax
 17059 00001991 1F                      	pop	ds
 17060 00001992 2EFF2E[2395]            	jmp	far [cs:OldCtrlCHandler]
 17061                                  					; go to previous int 23 handler
 17062                                  
 17063                                  ; ---------------------------------------------------------------------------
 17064                                  
 17065                                  ;M010;start
 17066                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17067                                  ;
 17068                                  ;	ENTRY	AL = character to be displayed
 17069                                  ;
 17070                                  ;	EXIT	AL is lowercase
 17071                                  ;
 17072                                  ;	USED	nothing
 17073                                  
 17074                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17075                                  LowerCase:
 17076 00001997 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 17077 00001999 7206                    	jb	short lcRet
 17078 0000199B 3C5A                    	cmp	al,'Z'
 17079 0000199D 7702                    	ja	short lcRet
 17080                                  
 17081 0000199F 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17082                                  lcRet:
 17083 000019A1 C3                      	retn
 17084                                  
 17085                                  ; ---------------------------------------------------------------------------
 17086                                  
 17087                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17088                                  ;
 17089                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17090                                  ;		ES = DS
 17091                                  ;
 17092                                  ;	EXIT	nothing
 17093                                  ;	
 17094                                  ;	USED	AL,SI
 17095                                  
 17096                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17097                                  LowercaseString:
 17098 000019A2 57                      	push	di			; save di
 17099 000019A3 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17100 000019A5 FC                      	cld
 17101                                  NextChar: 
 17102 000019A6 AC                      	lodsb				; get character from string into al
 17103 000019A7 08C0                    	or	al,al			; are we at end of string?
 17104 000019A9 7406                    	jz	short EndOfString
 17105                                  
 17106 000019AB E8E9FF                  	call	LowerCase		; convert character to lowercase
 17107 000019AE AA                      	stosb				; store character back into buffer
 17108 000019AF EBF5                    	jmp	short NextChar		; repeat until end of string
 17109                                  
 17110                                  EndOfString:
 17111 000019B1 5F                      	pop	di			; restore di
 17112 000019B2 C3                      	retn
 17113                                  
 17114                                  ;M010;end
 17115                                  
 17116                                  ;============================================================================
 17117                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 17118                                  ;============================================================================
 17119                                  ; 09/10/2018 - Retro DOS v3.0
 17120                                  
 17121                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 17122                                  
 17123                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17124                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 17125                                  
 17126                                  ; =============== S U B	R O U T	I N E =======================================
 17127                                  
 17128                                  PAUSE:
 17129 000019B3 BA[8E7F]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 17130 000019B6 E81834                  	call	std_printf
 17131 000019B9 E898EB                  	call	GETKEYSTROKE
 17132                                  	;call	CRLF2
 17133                                  	;retn
 17134                                  	; 19/02/2023
 17135 000019BC E9100C                  	jmp	CRLF2
 17136                                  
 17137                                  ; ---------------------------------------------------------------------------
 17138                                  
 17139                                  ;****************************************************************
 17140                                  ;*
 17141                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 17142                                  ;*
 17143                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 17144                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 17145                                  ;*		up an error message and transfer control to CERROR.
 17146                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 17147                                  ;*		entered or SLASHP_ERASE if /P entered.
 17148                                  ;*
 17149                                  ;* INPUT:	command line at offset 81H
 17150                                  ;*
 17151                                  ;* OUTPUT:	if no error:
 17152                                  ;*		FCB at 5ch set up with filename(s) entered
 17153                                  ;*		Current directory set to entered directory
 17154                                  ;*
 17155                                  ;****************************************************************
 17156                                  
 17157                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17158                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 17159                                  	; 10/06/2023
 17160                                  ERASE:
 17161                                  	; MSDOS 6.0
 17162                                  
 17163                                  	;assume	ds:trangroup,es:trangroup
 17164                                  
 17165 000019BF BE8100                  	mov	si,81h		;AC000; get command line
 17166 000019C2 C706[BA8A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 17167 000019C8 BF[F984]                	mov	di,PARSE_ERASE
 17168                                  				;AN000; Get address of PARSE_ERASE
 17169 000019CB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17170                                  erase_scan:
 17171 000019CD 31D2                    	xor	dx,dx		;AN000;
 17172 000019CF E8E507                  	call	Parse_With_Msg	;AC018; call parser
 17173                                  
 17174                                  	;cmp	ax,-1  ; 0FFFFh
 17175                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 17176                                  	;je	short good_line	;AN000; yes - done parsing
 17177                                  	;;cmp	ax,0
 17178                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 17179                                  	;and	ax,ax		;AC000; did we have an error?
 17180                                  	;jnz	short errj2	;AC000; yes exit
 17181                                  	; 10/06/2023
 17182 000019D2 40                      	inc	ax  ; cmp ax,-1
 17183 000019D3 743C                    	jz	short good_line ; 0FFFFh -> 0
 17184 000019D5 48                      	dec	ax  ; cmp ax,0	
 17185 000019D6 7566                    	jnz	short errj2  ; 1 -> 0
 17186                                  	; ax = 0
 17187                                  
 17188 000019D8 813E[5195][6C84]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 17189                                  				;AN000; was /P entered?
 17190 000019DE 741C                    	je	short set_erase_prompt
 17191                                  				;AN000; yes - go set prompt
 17192                                  ;
 17193                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 17194                                  ;
 17195 000019E0 56                      	push	si		;AC000; save position in line
 17196 000019E1 C536[5395]              	lds	si,[PARSE1_ADDR]
 17197                                  				;AC000; get address of filespec
 17198                                  	;cmp	byte [si+1],colon_char
 17199 000019E5 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 17200 000019E9 750B                    	jne	short erase_drive_ok
 17201                                  				;AC000; no - continue
 17202                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 17203 000019EB 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 17204 000019EF 7505                    	jne	short erase_drive_ok
 17205                                  				;AC000; no - continue
 17206 000019F1 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 17207                                  				;AN022; get message number in control block
 17208 000019F4 EB3D                    	jmp	short extend_setup
 17209                                  				;AC000; exit
 17210                                  erase_drive_ok:
 17211 000019F6 E8AA12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17212 000019F9 5E                      	pop	si		;AC000; get position back
 17213 000019FA EBD1                    	jmp	short erase_scan
 17214                                  				;AN000; continue parsing
 17215                                  set_erase_prompt:
 17216 000019FC 833E[BA8A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 17217 00001A01 7408                    	jz	short ok_to_set_erase_prompt
 17218                                  				;AN018; no go set switch
 17219                                  	;mov	ax,1
 17220 00001A03 B80100                  	mov	ax,MoreArgs_Ptr 
 17221                                  				;AN018; set up too many arguments
 17222 00001A06 E8BD07                  	call	setup_parse_error_msg
 17223                                  				;AN018; set up an error message
 17224 00001A09 EB33                    	jmp	short errj2	;AN018; exit
 17225                                  
 17226                                  ok_to_set_erase_prompt: 	;AN018;
 17227 00001A0B FF06[BA8A]              	inc	word [COMSW]	;AN000; indicate /p specified
 17228 00001A0F EBBC                    	jmp	short erase_scan
 17229                                  				;AN000; continue parsing
 17230                                  good_line:			;G  We know line is good
 17231 00001A11 E8640C                  	call	PathCrunch
 17232 00001A14 730D                    	jnc	short checkdr
 17233 00001A16 A1[948D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17234                                  	;cmp	ax,0		;AN022; was message flag set?
 17235 00001A19 09C0                    	or	ax,ax
 17236 00001A1B 7516                    	jnz	short extend_setup
 17237                                  				;AN022; yes - print out message
 17238                                  	;cmp	byte [DestIsDir],0
 17239 00001A1D 3806[288C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 17240 00001A21 750D                    	jnz	short badpath_err
 17241                                  				;AC022; see if they should have
 17242                                  checkdr:
 17243 00001A23 833E[BA8A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 17244 00001A28 7403                    	jz	short notest2j	;AN000; no - go to notest2
 17245 00001A2A E9081B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 17246                                  notest2j:
 17247 00001A2D E9A01A                  	jmp	notest2
 17248                                  
 17249                                  badpath_err:			;AN022; "Path not found" message
 17250 00001A30 B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 17251                                  				;AN022; set up error number
 17252                                  extend_setup:			;AN022;
 17253                                  	;mov	byte [msg_disp_class],1
 17254 00001A33 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 17255                                  				;AN022; set up extended error msg class
 17256 00001A38 BA[FC7E]                	mov	dx,extend_buf_ptr
 17257                                  				;AC022; get extended message pointer
 17258 00001A3B A3[FC7E]                	mov	[extend_buf_ptr],ax
 17259                                  				;AN022; get message number in control block
 17260                                  errj2:				;AC022; exit jump
 17261 00001A3E E90F0F                  	jmp	cerror		;AN022;
 17262                                  
 17263                                  ; 20/02/2023
 17264                                  %if 0
 17265                                  	; MSDOS 3.3
 17266                                  	mov	dx,BADARGSPTR
 17267                                  	mov	si,80h
 17268                                  	lodsb
 17269                                  	or	al,al
 17270                                  	jz	short ERRJ2
 17271                                  	call	SCANOFF
 17272                                  	cmp	al,0Dh		; Return key
 17273                                  	jz	short ERRJ2	; If so no parameters specified
 17274                                  	push	dx
 17275                                  	push	si
 17276                                  	mov	dx,FNOTFOUNDPTR
 17277                                  ERASE_SCAN:
 17278                                  	lodsb
 17279                                  	call	DELIM
 17280                                  	jz	short ERASE_CHKDELIMCHR
 17281                                  	cmp	al,0Dh
 17282                                  	jz	short GOOD_LINE
 17283                                  	jmp	short ERASE_SCAN
 17284                                  ERASE_CHKDELIMCHR:
 17285                                  	cmp	al,20h
 17286                                  	jg	short ERRJ2
 17287                                  	lodsb
 17288                                  	call	DELIM
 17289                                  	jz	short ERASE_CHKDELIMCHR
 17290                                  	cmp	al,0Dh
 17291                                  	jz	short GOOD_LINE
 17292                                  	mov	dx,BADARGSPTR
 17293                                  	jmp	short ERRJ2
 17294                                  GOOD_LINE:
 17295                                  	pop	si
 17296                                  	pop	dx
 17297                                  	push	si
 17298                                  	call	PATHCRUNCH
 17299                                  	jnc	short CHECKDR
 17300                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17301                                  	jz	short CHECKDR	   ; see if they should have
 17302                                  BADCDERR:
 17303                                  	pop	si
 17304                                  	mov	dx,BADCDPTR
 17305                                  ERRJ2:
 17306                                  	jmp	CERROR
 17307                                  CHECKDR:
 17308                                  	mov	dx,FNOTFOUNDPTR
 17309                                  	pop	cx
 17310                                  	mov	al,' '
 17311                                  	;cmp	[5Dh],al
 17312                                  	cmp	[FCB+1],al
 17313                                  	jz	short ERRJ2
 17314                                  	add	cx,3
 17315                                  	cmp	si,cx
 17316                                  	jnz	short NOTEST2J
 17317                                  	mov	al,':'
 17318                                  	cmp	[si-2],al
 17319                                  	jz	short ERRJ2
 17320                                  NOTEST2J:
 17321                                  	jmp	NOTEST2
 17322                                  %endif
 17323                                  
 17324                                  ; ---------------------------------------------------------------------------
 17325                                  
 17326                                  ; ****************************************************************
 17327                                  ; *
 17328                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17329                                  ; *
 17330                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17331                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17332                                  ; *		 Make sure the second filespec only contains a
 17333                                  ; *		 filename. If both openands are valid, attempt
 17334                                  ; *		 to rename the file.
 17335                                  ; *
 17336                                  ; * INPUT:	 command line at offset 81H
 17337                                  ; *
 17338                                  ; * OUTPUT:	 none
 17339                                  ; *
 17340                                  ; ****************************************************************
 17341                                  
 17342                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17343                                  CRENAME:
 17344                                  	; MSDOS 6.0
 17345                                  	;assume	ds:trangroup,es:trangroup
 17346                                  
 17347 00001A41 BE8100                  	mov	si,81h		;AC000; Point to command line
 17348 00001A44 BF[7085]                	mov	di,PARSE_RENAME
 17349                                  				;AN000; Get address of PARSE_RENAME
 17350 00001A47 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17351 00001A49 31D2                    	xor	dx,dx		;AN000;
 17352 00001A4B E86907                  	call	Parse_With_Msg	;AC018; call parser
 17353                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17354 00001A4E 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17355                                  ;	jz	short crename_no_parse_error
 17356                                  				;AC000; no - continue
 17357 00001A50 752C                    	jnz	short crename_parse_error
 17358                                  				;AC000; Yes, fail. (need long jump)
 17359                                  ;
 17360                                  ;  Get first file name returned from parse into our buffer
 17361                                  ;
 17362                                  crename_no_parse_error:
 17363 00001A52 56                      	push	si		;AN000; save position in line
 17364 00001A53 C536[5395]              	lds	si,[PARSE1_ADDR]
 17365                                  				;AN000; get address of filespec
 17366 00001A57 E84912                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17367 00001A5A 5E                      	pop	si		;AN000; restore position in line
 17368                                  
 17369 00001A5B 31D2                    	xor	dx,dx		;AN000; clear dx
 17370 00001A5D E85707                  	call	Parse_With_Msg	;AC018; call parser
 17371                                  	;cmp	ax,RESULT_NO_ERROR
 17372 00001A60 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17373 00001A62 751A                    	jnz	short crename_parse_error
 17374                                  				;AN000; Yes, fail.
 17375                                  ;
 17376                                  ;  Check the second file name for drive letter colon
 17377                                  ;
 17378 00001A64 56                      	push	si		;AN000; save position in line
 17379 00001A65 C536[5395]              	lds	si,[PARSE1_ADDR]
 17380                                  				;AC000; get address of path
 17381                                  	;mov	al,':'		;AC000;
 17382                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17383 00001A69 807C013A                	cmp	byte [si+1],':'
 17384 00001A6D 7511                    	jnz	short ren_no_drive
 17385                                  				;AN000; Yes, error
 17386                                  	;mov	byte [msg_disp_class],2
 17387 00001A6F C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 17388                                  				;AN000; set up parse error msg class
 17389 00001A74 BA[FC7E]                	mov	dx,extend_buf_ptr
 17390                                  				;AC000; get extended message pointer
 17391                                  	;mov	word [extend_buf_ptr],0Ah
 17392 00001A77 C706[FC7E]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17393                                  				;AN000; get "Invalid parameter" message number
 17394 00001A7D 5E                      	pop	si		;AN000;
 17395                                  crename_parse_error:		;AC022;
 17396 00001A7E EB64                    	jmp	short errj	;AC000;
 17397                                  
 17398                                  ;  Get second file name returned from parse into the fCB. Save
 17399                                  ;  character after file name so we can later check to make sure it
 17400                                  ;  isn't a path character.
 17401                                  
 17402                                  ren_no_drive:
 17403 00001A80 BF6C00                  	mov	di,FCB+10h ; 6Ch
 17404                                  				;AC000; set up to parse second file name
 17405                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17406 00001A83 B80129                  	mov	ax,2901h
 17407 00001A86 CD21                    	int	21h		;AC000; do the function
 17408 00001A88 AC                      	lodsb			;AC000; Load char after filename
 17409 00001A89 A2[208C]                	mov	[One_Char_Val],al
 17410                                  				;AN000; save char after filename
 17411 00001A8C 5E                      	pop	si		;AN000; get line position back
 17412                                  ;
 17413                                  ; We have source and target. See if any args beyond.
 17414                                  ;
 17415 00001A8D BF[7085]                	mov	di,PARSE_RENAME
 17416                                  				;AC000; get address of parse_rename
 17417 00001A90 E80E07                  	call	parse_check_eol ;AC000; are we at end of line?
 17418 00001A93 75E9                    	jnz	short crename_parse_error
 17419                                  				;AN000; no, fail.
 17420                                  
 17421 00001A95 E8E00B                  	call	PathCrunch
 17422 00001A98 BA[0D7F]                	mov	dx,BADCPMES_PTR
 17423 00001A9B 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17424 00001A9D 730F                    	jnc	short notest3
 17425 00001A9F A1[948D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17426                                  	;cmp	ax,0		;AN022; was message flag set?
 17427 00001AA2 21C0                    	and	ax,ax ; 0 ?
 17428 00001AA4 758D                    	jnz	short extend_setup
 17429                                  				;AN022; yes - print out message
 17430                                  	;cmp	byte [DestIsDir],0
 17431 00001AA6 3806[288C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17432 00001AAA 7402                    	jz	short notest3 	; see if they should have
 17433 00001AAC EB82                    	Jmp	badpath_err	;AC022; set up error
 17434                                  notest3:
 17435 00001AAE A0[208C]                	mov	al,[One_Char_Val]
 17436                                  				;AN000; move char into AX
 17437 00001AB1 BA[2B7F]                	mov	dx,INORNOT_PTR 
 17438                                  				; Load invalid fname error ptr
 17439 00001AB4 E8B30B                  	call	pathchrcmp	; Is the char in al a path sep?
 17440 00001AB7 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17441                                  				;  filename only.
 17442                                  	;mov	ah,FCB_Rename
 17443 00001AB9 B417                    	mov	ah,17h
 17444 00001ABB BA5C00                  	mov	dx,FCB ; 5Ch
 17445 00001ABE CD21                    	int	21h
 17446 00001AC0 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17447 00001AC2 7506                    	jne	short renameok
 17448                                  
 17449 00001AC4 E82902                  	call	get_ext_error_number
 17450                                  				;AN022; get extended error
 17451 00001AC7 50                      	push	ax		;AC022; Save results
 17452 00001AC8 B0FF                    	mov	al,0FFh		; Restore original error state
 17453                                  renameok:
 17454 00001ACA 50                      	push	ax
 17455 00001ACB E8BE09                  	call	RestUDir
 17456 00001ACE 58                      	pop	ax
 17457 00001ACF FEC0                    	inc	al
 17458                                  	;;retnz
 17459                                  	;jz	short rn1
 17460                                  	;retn	
 17461 00001AD1 7514                    	jnz	short ret56
 17462                                  rn1:
 17463 00001AD3 58                      	pop	ax		;AC022; get the error number back
 17464 00001AD4 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17465                                  				;AN022; error file not found?
 17466 00001AD7 7408                    	jz	short use_renerr
 17467                                  				;AN022; yes - use generic error message
 17468 00001AD9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17469                                  				;AN022; error file not found?
 17470 00001ADC 7403                    	jz	short use_renerr
 17471                                  				;AN022; yes - use generic error message
 17472 00001ADE E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17473                                  
 17474                                  use_renerr:
 17475 00001AE1 BA[0A7F]                	mov	dx,RENERR_PTR	;AC022;
 17476                                  errj:
 17477 00001AE4 E9690E                  	jmp	cerror
 17478                                  ret56:
 17479                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17480 00001AE7 C3                      	retn
 17481                                  
 17482                                  ; 20/02/2023
 17483                                  %if 0
 17484                                  	; MSDOS 3.3
 17485                                  	mov	dx,BADARGSPTR
 17486                                  	call	SCANOFF
 17487                                  	cmp	al,0Dh
 17488                                  	jz	short ERRJ2
 17489                                  	call	PATHCRUNCH
 17490                                  	mov	dx,BADCPMESPTR
 17491                                  	jz	short ERRJ2
 17492                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17493                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17494                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17495                                  	jmp	short BADCDERR
 17496                                  
 17497                                  ;  Get first file name returned from parse into our buffer
 17498                                  
 17499                                  CRENAME_NO_PARSE_ERROR:
 17500                                  	mov	si,[PATHPOS]
 17501                                  	call	SCANOFF
 17502                                  	cmp	al,0Dh
 17503                                  	mov	dx,BADARGSPTR
 17504                                  	jz	short ERRJ
 17505                                  	mov	al,':'
 17506                                  	mov	dx,BADPARMPTR
 17507                                  	cmp	[si+1],al
 17508                                  	jz	short ERRJ
 17509                                  
 17510                                  ;  Get second file name returned from parse into the FCB. Save
 17511                                  ;  character after file name so we can later check to make sure it
 17512                                  ;  isn't a path character.
 17513                                  
 17514                                  REN_NO_DRIVE:
 17515                                  	;mov	di,6Ch
 17516                                  	mov	di,FCB+10h
 17517                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17518                                  	int	21h	; DOS -	PARSE FILENAME
 17519                                  			; DS:SI	-> string to parse
 17520                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17521                                  			; AL = bit mask	to control parsing
 17522                                  	mov	al,' '
 17523                                  	;cmp	[6Dh],al
 17524                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17525                                  	jz	short ERRJ	; Error if missing parameter
 17526                                  	lodsb
 17527                                  	mov	dx,INORNOTPTR
 17528                                  	call	PATHCHRCMP
 17529                                  	jz	short ERRJ
 17530                                  	mov	ah,FCB_RENAME ; 17h
 17531                                  	mov	dx,FCB ; 5Ch
 17532                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17533                                  			; DS:DX	-> FCB
 17534                                  			; FCB contains new name	starting at byte 17h.
 17535                                  	cmp	al,0FFh		; Did an error occur??	
 17536                                  	jnz	short RENAMEOK
 17537                                  	stc
 17538                                  	mov	dx,RENERRPTR
 17539                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17540                                  	push	dx
 17541                                  	mov	al,0FFh		; Restore original error state
 17542                                  RENAMEOK:
 17543                                  	push	ax
 17544                                  	call	RESTUDIR
 17545                                  	pop	ax
 17546                                  	inc	al
 17547                                  	jz	short RENAME_ERR
 17548                                  RENAME_RETN:
 17549                                  TYPELP_RET:
 17550                                  	retn
 17551                                  RENAME_ERR:
 17552                                  	pop	dx
 17553                                  ERRJ:				; Retro DOS v3.0
 17554                                  	call	STD_EPRINTF
 17555                                  	jmp	TCOMMAND
 17556                                  
 17557                                  ; ---------------------------------------------------------------------------
 17558                                  
 17559                                  ;ERRJ:
 17560                                  ;	jmp	CERROR
 17561                                  
 17562                                  ; ---------------------------------------------------------------------------
 17563                                  
 17564                                  ;TYPELP_RET:
 17565                                  ;	retn
 17566                                  
 17567                                  %endif
 17568                                  
 17569                                  ; ---------------------------------------------------------------------------
 17570                                  
 17571                                  ;****************************************************************
 17572                                  ;*
 17573                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17574                                  ;*		standard output device
 17575                                  ;*
 17576                                  ;* SYNTAX:	TYPE filespec
 17577                                  ;*
 17578                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17579                                  ;*		1Ah and display the contents to STDOUT.
 17580                                  ;*
 17581                                  ;* INPUT:	command line at offset 81H
 17582                                  ;*
 17583                                  ;* OUTPUT:	none
 17584                                  ;*
 17585                                  ;****************************************************************
 17586                                  
 17587                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17588                                  TYPEFIL:
 17589                                  	; MSDOS 6.0	
 17590                                  	;assume	ds:trangroup,es:trangroup
 17591                                  
 17592 00001AE8 BE8100                  	mov	si,81h
 17593 00001AEB BF[E784]                	mov	di,PARSE_MRDIR
 17594                                  				;AN000; Get address of PARSE_MRDIR
 17595 00001AEE 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17596 00001AF0 31D2                    	xor	dx,dx		;AN000;
 17597 00001AF2 E8C206                  	call	Parse_With_Msg	;AC018; call parser
 17598                                  	;cmp	ax,RESULT_NO_ERROR
 17599 00001AF5 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17600 00001AF7 751E                    	jnz	short typefil_parse_error
 17601                                  				;AN000; yes - issue error message
 17602                                  
 17603 00001AF9 56                      	push	si		;AC000; save position in line
 17604 00001AFA C536[5395]              	lds	si,[PARSE1_ADDR]
 17605                                  				;AC000; get address of filespec
 17606 00001AFE E8A211                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17607 00001B01 5E                      	pop	si		;AC000; get position back
 17608 00001B02 BF[E784]                	mov	di,PARSE_MRDIR
 17609                                  				;AC000; get address of parse_mrdir
 17610 00001B05 E89906                  	call	parse_check_eol ;AC000; are we at end of line?
 17611                                  	;jz	short gottarg 	;AC000; yes - continue
 17612                                  	; 20/02/2023
 17613                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17614                                  	;jmp	cerror
 17615 00001B08 750D                    	jnz	short typefil_parse_error
 17616                                  gottarg:
 17617 00001B0A E8DD0F                  	call	SETPATH
 17618 00001B0D F606[2C8C]02            	test	byte [DestInfo],00000010b ; 2
 17619                                  				; Does the filespec contain wildcards
 17620 00001B12 7406                    	jz	short nowilds 	; No, continue processing
 17621 00001B14 BA[2B7F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17622                                  	; 20/02/2023
 17623                                  typefil_parse_error:
 17624 00001B17 E9360E                  	jmp	cerror
 17625                                  nowilds:
 17626                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17627 00001B1A B8006C                  	mov	ax,6C00h
 17628                                  	;mov	bx,read_open_mode ; 0
 17629                                  				;AN000; get open mode for TYPE
 17630 00001B1D 31C9                    	xor	cx,cx		;AN000; no special files
 17631 00001B1F 89CB                    	mov	bx,cx ; 20/02/2023
 17632 00001B21 BA0101                  	mov	dx,101h
 17633                                  	;mov	dx,read_open_flag ; 101h
 17634                                  				;AN000; set up open flags
 17635 00001B24 BE[908C]                	mov	si,SrcBuf	;AN030; get file name
 17636 00001B27 CD21                    	int	21h
 17637 00001B29 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17638                                  
 17639                                  typerr: 			;AN022;
 17640 00001B2B 0E                      	push	cs		;AN022; make sure we have local segment
 17641 00001B2C 1F                      	pop	ds		;AN022;
 17642 00001B2D E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 17643 00001B30 C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf 
 17644                                  				;AC022; get address of failed string
 17645                                  	;mov	byte [extend_buf_sub],1
 17646 00001B36 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 17647                                  				;AC022; put number of subst in control block
 17648 00001B3B E9120E                  	jmp	cerror		;AC022; exit
 17649                                  
 17650                                  typecont:
 17651 00001B3E 89C3                    	mov	bx,ax		;AC000; get Handle
 17652                                  ;M043
 17653                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17654                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17655                                  ;indicate it is a device.
 17656                                  ;
 17657                                  	;mov	ax,(IOCTL shl 8) or 0
 17658 00001B40 B80044                  	mov	ax,4400h
 17659 00001B43 CD21                    	int	21h
 17660                                  
 17661 00001B45 F6C280                  	test	dl,80h		;is it a device?
 17662 00001B48 7408                    	jz	short not_device
 17663                                  				;no, a file
 17664                                  
 17665 00001B4A C706[4D95]FFFF          	mov	word [TypeFilSiz+2],-1
 17666                                  				;indicate it is a device
 17667 00001B50 EB17                    	jmp	short dotype
 17668                                  not_device:
 17669                                  ;SR;
 17670                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17671                                  ;start of file
 17672                                  
 17673                                  	;mov	ax,(LSEEK shl 8) or 2
 17674 00001B52 B80242                  	mov	ax,4202h
 17675 00001B55 31D2                    	xor	dx,dx
 17676 00001B57 89D1                    	mov	cx,dx		;seek  to end of file
 17677 00001B59 CD21                    	int	21h
 17678                                  
 17679 00001B5B A3[4B95]                	mov	[TypeFilSiz],ax
 17680 00001B5E 8916[4D95]              	mov	[TypeFilSiz+2],dx ;store filesize
 17681                                  	;mov	ax,(LSEEK shl 8) or 0
 17682 00001B62 B80042                  	mov	ax,4200h
 17683 00001B65 31D2                    	xor	dx,dx
 17684 00001B67 CD21                    	int	21h	        ;reset file pointer to start
 17685                                  dotype:				;M043
 17686 00001B69 C606[548D]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17687 00001B6E 8E1E[A78A]              	mov	ds,[TPA]
 17688 00001B72 31D2                    	xor	dx,dx
 17689                                  	;ASSUME	DS:NOTHING
 17690                                  typelp:
 17691 00001B74 2E803E[548D]00          	cmp	byte [cs:zflag],0
 17692                                  				;AC050; Is the ^Z flag set?
 17693                                  	;retnz			; Yes, return
 17694                                  	; 17/04/2023
 17695 00001B7A 7401                    	jz	short tf1
 17696 00001B7C C3                      	retn
 17697                                  tf1:
 17698 00001B7D 2E8B0E[C48A]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17699                                  
 17700                                  ;Update the filesize left to read
 17701                                  
 17702 00001B82 2E833E[4D95]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17703                                  				;is it a device? M043
 17704 00001B88 7431                    	je	short typ_read	;yes, just read from it; M043
 17705                                  
 17706 00001B8A 2E833E[4D95]00          	cmp	word [cs:TypeFilSiz+2],0
 17707                                  				;more than 64K left?
 17708 00001B90 740D                    	jz	short lt64k	;no, do word subtraction
 17709 00001B92 2E290E[4B95]            	sub	[cs:TypeFilSiz],cx
 17710 00001B97 2E831E[4D95]00          	sbb	word [cs:TypeFilSiz+2],0
 17711                                  				;update filesize
 17712 00001B9D EB1C                          	jmp	short typ_read	;do the read
 17713                                  lt64k:
 17714 00001B9F 2E3B0E[4B95]            	cmp	cx,[cs:TypeFilSiz]
 17715                                  				;readsize <= buffer?
 17716 00001BA4 7610                    	jbe	short gtbuf	; yes, just update readsize
 17717                                  
 17718                                  ;Buffer size is larger than bytes to read
 17719                                  
 17720 00001BA6 2E8B0E[4B95]            	mov	cx,[cs:TypeFilSiz]
 17721 00001BAB E361                    	jcxz	typelp_ret
 17722 00001BAD 2EC706[4B95]0000        	mov	word [cs:TypeFilSiz],0
 17723 00001BB4 EB05                    	jmp	short typ_read
 17724                                  gtbuf:
 17725 00001BB6 2E290E[4B95]            	sub	[cs:TypeFilSiz],cx
 17726                                  				;update filesize remaining
 17727                                  typ_read:
 17728                                  	;mov	ah,read
 17729 00001BBB B43F                    	mov	ah,3Fh
 17730 00001BBD CD21                    	int	21h
 17731 00001BBF 7303                    	jnc	short tf2	;M043
 17732 00001BC1 E967FF                  	jmp	typerr		;M043
 17733                                  tf2:				;M043
 17734                                  ;M043;	jc	typerr		;AN022; Exit if error
 17735                                  
 17736 00001BC4 89C1                    	mov	cx,ax
 17737 00001BC6 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17738 00001BC8 1E                      	push	ds
 17739 00001BC9 07                      	pop	es		; Check to see if a ^Z was read.
 17740                                  	;assume es:nothing
 17741 00001BCA 31FF                    	xor	di,di
 17742 00001BCC 50                      	push	ax
 17743 00001BCD B01A                    	mov	al,1Ah
 17744 00001BCF F2AE                    	repnz	scasb
 17745 00001BD1 58                      	pop	ax
 17746 00001BD2 91                      	xchg	ax,cx
 17747                                  	;cmp	ax,0
 17748 00001BD3 21C0                    	and	ax,ax
 17749 00001BD5 7506                    	jnz	short foundz	; Yes, handle it
 17750 00001BD7 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17751 00001BDB 750A                    	jnz	short typecont2	; No ^Z, continue
 17752                                  foundz:
 17753 00001BDD 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17754 00001BDF 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17755 00001BE0 0E                      	push	cs		;  will be typed.
 17756 00001BE1 07                      	pop	es
 17757                                  	;assume es:trangroup
 17758 00001BE2 26F616[548D]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17759                                  typecont2:			;  will quit after this write.
 17760 00001BE7 53                      	push	bx
 17761 00001BE8 BB0100                  	mov	bx,1
 17762                                  	;mov	ah,Write
 17763 00001BEB B440                    	mov	ah,40h
 17764 00001BED CD21                    	int	21h
 17765 00001BEF 5B                      	pop	bx
 17766 00001BF0 720C                    	jc	short Error_outputj
 17767 00001BF2 39C8                    	cmp	ax,cx
 17768 00001BF4 7503                    	jnz	short tf3	;M043
 17769 00001BF6 E97BFF                  	jmp	typelp		;M043
 17770                                  tf3:				;M043
 17771                                  ;M043;	jz	short typelp
 17772 00001BF9 49                      	dec	cx
 17773 00001BFA 39C8                    	cmp	ax,cx
 17774                                  	;;retz			; One less byte OK (^Z)
 17775                                  	;jnz	short Error_outputj
 17776                                  ;tf4:
 17777                                  	;retn
 17778 00001BFC 7410                    	jz	short typelp_ret ; 20/02/2023
 17779                                  
 17780                                  Error_outputj:
 17781 00001BFE BB0100                  	mov	bx,1
 17782                                  	;mov	ax,IOCTL SHL 8
 17783 00001C01 B80044                  	mov	ax,4400h
 17784 00001C04 CD21                    	int	21h
 17785 00001C06 F6C280                  	test	dl,80h
 17786                                  	;test	dl,devid_ISDEV
 17787                                  	;;retnz			; If device, no error message
 17788                                  	;jnz	short tf4
 17789 00001C09 7503                    	jnz	short typelp_ret
 17790 00001C0B E9420A                  	jmp	error_output
 17791                                  typelp_ret:
 17792 00001C0E C3                      	retn
 17793                                  
 17794                                  ; 20/02/2023
 17795                                  %if 0
 17796                                  	; MSDOS 3.3
 17797                                  	mov	si,81h
 17798                                  	call	SCANOFF		; Skip to first non-delim
 17799                                  	cmp	al,0Dh
 17800                                  	jnz	short GOTTARG
 17801                                  	mov	dx,BADARGSPTR
 17802                                  
 17803                                  	;jmp	CERROR
 17804                                  	jmp	short ERRJ	; No args
 17805                                  GOTTARG:
 17806                                  	call	SETPATH
 17807                                  	test	byte [DESTINFO],2
 17808                                  	jz	short NOWILDS
 17809                                  	mov	dx,INORNOTPTR
 17810                                  
 17811                                  	;jmp	CERROR
 17812                                  	jmp	short ERRJ
 17813                                  NOWILDS:
 17814                                  	mov	ax,OPEN*256 ; 3D00h
 17815                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17816                                  			; DS:DX	-> ASCIZ filename
 17817                                  			; AL = access mode
 17818                                  			; 0 - read
 17819                                  	jnc	short TYPECONT
 17820                                  	mov	dx,FNOTFOUNDPTR
 17821                                  	cmp	ax,2
 17822                                  	jz	short ERRJ
 17823                                  	mov	dx,BADCPMESPTR
 17824                                  	stc
 17825                                  	call	GET_EXT_ERR_NUMBER
 17826                                  	
 17827                                  	;jmp	CERROR
 17828                                  	jmp	short ERRJ
 17829                                  TYPECONT:
 17830                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17831                                  	mov	bx,ax		; Handle
 17832                                  	mov	ds,[TPA]
 17833                                  	xor	dx,dx
 17834                                  TYPELP:
 17835                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17836                                  	jnz	short RENAME_RETN ; Yes, return	
 17837                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17838                                  	mov	ah,READ ; 3Fh
 17839                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17840                                  			; BX = file handle,CX = number	of bytes to read
 17841                                  			; DS:DX	-> buffer
 17842                                  	mov	cx,ax
 17843                                  	jcxz	TYPELP_RET	; exit if nothing read
 17844                                  				; Check to see if a ^Z was read.
 17845                                  	push	ds
 17846                                  	pop	es		
 17847                                  	xor	di,di
 17848                                  	push	ax
 17849                                  	mov	al,1Ah
 17850                                  	repne	scasb
 17851                                  	pop	ax
 17852                                  	xchg	ax,cx
 17853                                  	cmp	ax,0
 17854                                  	jnz	short FOUNDZ	; Yes, handle it
 17855                                  	cmp	byte [di-1],1Ah	; No, double check
 17856                                  	jnz	short TYPECONT2	; No ^Z, continue
 17857                                  FOUNDZ:
 17858                                  	sub	cx,ax		; Otherwise change cx so that only those
 17859                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17860                                  	push	cs		;  will be typed.
 17861                                  	pop	es
 17862                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17863                                  				;  will quit after this write.
 17864                                  TYPECONT2:
 17865                                  	push	bx
 17866                                  	mov	bx,1
 17867                                  	mov	ah,WRITE ; 40h
 17868                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17869                                  			; BX = file handle, CX = number of bytes to write,
 17870                                  			; DS:DX -> buffer
 17871                                  	pop	bx
 17872                                  	jc	short ERROR_OUTPUTJ
 17873                                  	cmp	ax,cx
 17874                                  	jz	short TYPELP
 17875                                  	dec	cx
 17876                                  	cmp	ax,cx		; One less byte OK (^Z)
 17877                                  	jnz	short ERROR_OUTPUTJ
 17878                                  TYPEFIL_RETN:
 17879                                  	retn
 17880                                  ERROR_OUTPUTJ:
 17881                                  	mov	bx,1
 17882                                  	mov	ax,IOCTL*256 ; 4400h
 17883                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17884                                  			; BX = file or device handle
 17885                                  	;test	dl,devid_ISDEV
 17886                                  	test	dl,80h
 17887                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17888                                  	jmp	ERROR_OUTPUT
 17889                                  %endif
 17890                                  
 17891                                  ; ---------------------------------------------------------------------------
 17892                                  
 17893                                  ; VOLUME command displays the volume ID on the specified drive
 17894                                  
 17895                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17896                                  	; 10/06/2023
 17897                                  VOLUME:
 17898                                  	; MSDOS 6.0
 17899 00001C0F BE8100                  	mov	si,81h
 17900 00001C12 BF[D584]                	mov	di,PARSE_VOL
 17901                                  				;AN000; Get address of PARSE_VOL
 17902 00001C15 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17903 00001C17 31D2                    	xor	dx,dx		;AN000;
 17904 00001C19 E89B05                  	call	Parse_With_Msg	;AC018; call parser
 17905                                  
 17906                                  	;cmp	ax,-1 ; 0FFFFh
 17907                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17908                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 17909                                  	;;cmp	ax,RESULT_NO_ERROR
 17910                                  	;;cmp	ax,0		;AC000; did we have an error?
 17911                                  	;or	ax,ax ; 0?
 17912                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 17913                                  	; 10/06/2023
 17914 00001C1C 40                      	inc	ax  ; cmp ax,-1
 17915 00001C1D 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 17916 00001C1F 48                      	dec	ax  ; cmp ax,0
 17917 00001C20 750A                    	jnz	short badvolarg ; 1 -> 0
 17918                                  	; ax = 0
 17919                                  
 17920                                  ; We have parsed off the drive. See if there are any more chars left
 17921                                  
 17922 00001C22 BF[D584]                	mov	di,PARSE_VOL
 17923                                  				;AC000; get address of parse_vol
 17924 00001C25 31D2                    	xor	dx,dx		;AC000;
 17925 00001C27 E87705                  	call	parse_check_eol ;AC000; call parser
 17926 00001C2A 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17927                                  
 17928                                  ; The line was not interpretable. Report an error.
 17929                                  
 17930                                  badvolarg:
 17931 00001C2C E9210D                  	jmp	cerror
 17932                                  
 17933                                  ; 20/02/2023
 17934                                  %if 0
 17935                                  	; MSDOS 3.3
 17936                                  	mov	si,81h
 17937                                  	call	SCANOFF		; Skip to first non-delim
 17938                                  	;mov	ah,[5Ch]
 17939                                  	mov	ah,[FCB]
 17940                                  	;mov	byte [5Ch],0
 17941                                  	mov	byte [FCB],0
 17942                                  	cmp	al,0Dh		; are we at end of line?
 17943                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17944                                  	;mov	[5Ch],ah
 17945                                  	mov	[FCB],ah
 17946                                  	lodsb
 17947                                  	lodsb
 17948                                  	cmp	al,':'
 17949                                  	jnz	short VOLUME_ERR
 17950                                  	call	SCANOFF
 17951                                  	cmp	al,0Dh
 17952                                  	jz	short OKVOLARG
 17953                                  VOLUME_ERR:
 17954                                  	mov	dx,BADDRVPTR
 17955                                  	jmp	CERROR
 17956                                  
 17957                                  ; ---------------------------------------------------------------------------
 17958                                  
 17959                                  OKVOLARG:
 17960                                  	call	CRLF2
 17961                                  	push	ds
 17962                                  	pop	es
 17963                                  	;mov	di,55h
 17964                                  	mov	di,FCB-7	; Set up extended FCB
 17965                                  	mov	al,-1
 17966                                  	stosb
 17967                                  	xor	ax,ax
 17968                                  	stosw
 17969                                  	stosw
 17970                                  	stosb
 17971                                  	mov	al,8		; Look for volume label
 17972                                  	stosb
 17973                                  	inc	di		; Skip drive byte
 17974                                  	mov	cx,11
 17975                                  	mov	al,'?'
 17976                                  	rep stosb
 17977                                  	mov	dx,DIRBUF
 17978                                  	mov	ah,Set_DMA ; 1Ah
 17979                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17980                                  			; DS:DX	-> disk	transfer buffer
 17981                                  	;mov	dx,55h
 17982                                  	mov	dx,FCB-7
 17983                                  	mov	ah,Dir_Search_First ; 11h
 17984                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17985                                  			; DS:DX	-> FCB
 17986                                  	jmp	PRINTVOL
 17987                                  %endif
 17988                                  
 17989                                  ; ---------------------------------------------------------------------------
 17990                                  
 17991                                  ;***	DisAppend - disable APPEND
 17992                                  ;
 17993                                  ;	ENTRY	nothing
 17994                                  ;
 17995                                  ;	EXIT	nothing
 17996                                  ;
 17997                                  ;	USED	AX,BX
 17998                                  ;
 17999                                  ;	EFFECTS
 18000                                  ;
 18001                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 18002                                  ;	  after the command finishes, by the HeadFix routine.
 18003                                  ;
 18004                                  ;	NOTE
 18005                                  ;
 18006                                  ;	  This routine must not be called more than once during a single
 18007                                  ;	  command cycle. The second call would permanently disable APPEND.
 18008                                  
 18009                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18010                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 18011                                  
 18012                                  	; MSDOS 6.0
 18013                                  DisAppend:
 18014 00001C2F 1E                      	push	ds			; save DS
 18015 00001C30 06                      	push	es			; save ES
 18016 00001C31 57                      	push	di
 18017                                  
 18018                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 18019 00001C32 B800B7                  	mov	ax,0B700h
 18020 00001C35 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18021 00001C37 08C0                    	or	al,al
 18022 00001C39 7423                    	jz	short daRet		; APPEND not installed, return
 18023                                  
 18024                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 18025 00001C3B B802B7                  	mov	ax,0B702h
 18026 00001C3E CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18027 00001C40 83F8FF                  	cmp	ax,0FFFFh
 18028 00001C43 7519                    	jne	short daRet		; it's not a local version, return
 18029                                  
 18030                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 18031 00001C45 B806B7                  	mov	ax,0B706h
 18032 00001C48 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18033                                  
 18034 00001C4A 8E1E[A58A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 18035                                  
 18036 00001C4E 891E[AB01]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 18037 00001C52 C606[AD01]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 18038                                  
 18039 00001C57 31DB                    	xor	bx,bx			; BX = APPEND state = off
 18040                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 18041 00001C59 B807B7                  	mov	ax,0B707h
 18042 00001C5C CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18043                                  daRet:	
 18044 00001C5E 5F                      	pop	di
 18045 00001C5F 07                      	pop	es			; restore ES
 18046 00001C60 1F                      	pop	ds			; restore DS
 18047                                  
 18048 00001C61 C3                      	retn
 18049                                  
 18050                                  ; ---------------------------------------------------------------------------
 18051                                  
 18052                                  ; Find the Volume ID on the disk.
 18053                                  
 18054                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18055                                  
 18056                                  	; MSDOS 6.0
 18057                                  OkVolArg:
 18058 00001C62 E8CAFF                  	call	DisAppend		; disable APPEND
 18059 00001C65 E86709                  	call	CRLF2
 18060                                  	;mov	al,blank			
 18061 00001C68 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18062 00001C6A E88E01                  	call	PRINT_CHAR		;AN051;  before volume message
 18063 00001C6D 1E                      	push	ds
 18064 00001C6E 07                      	pop	es
 18065                                  
 18066                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 18067                                  ; of volume_id ONLY.
 18068                                  
 18069 00001C6F BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 18070 00001C72 B0FF                    	mov	al,-1			; Tag to indicate Extention
 18071 00001C74 AA                      	stosb
 18072 00001C75 31C0                    	xor	ax,ax			; Zero padding to volume label
 18073 00001C77 AB                      	stosw
 18074 00001C78 AB                      	stosw
 18075 00001C79 AA                      	stosb
 18076 00001C7A B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 18077 00001C7C AA                      	stosb
 18078 00001C7D 47                      	inc	di			; Skip drive byte; it is already set
 18079 00001C7E B90B00                  	mov	cx,11			; fill in remainder of file
 18080 00001C81 B03F                    	mov	al,'?'
 18081 00001C83 F3AA                    	rep	stosb
 18082                                  
 18083                                  ; Set up transfer address (destination of search first information)
 18084                                  
 18085 00001C85 BA[AA8B]                	mov	dx,DIRBUF
 18086                                  	;mov	ah,Set_DMA
 18087 00001C88 B41A                    	mov	ah,1Ah
 18088 00001C8A CD21                    	int	21h
 18089                                  
 18090                                  ; Do the search
 18091                                  
 18092 00001C8C BA5500                  	mov	dx,FCB-7 ; 55h
 18093                                  	;mov	ah,Dir_Search_First
 18094 00001C8F B411                    	mov	ah,11h
 18095 00001C91 CD21                    	int	21h
 18096                                  
 18097                                  ;********************************
 18098                                  ; Print volume ID info
 18099                                  
 18100 00001C93 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 18101 00001C94 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 18102 00001C97 0440                    	add	al,'@'  ; add al,40h
 18103 00001C99 3C40                    	cmp	al,'@'
 18104 00001C9B 7505                    	jne	short drvok
 18105 00001C9D A0[B78A]                	mov	al,[CURDRV]
 18106                                  	;add	al,capital_A
 18107 00001CA0 0441                    	add	al,'A'
 18108                                  drvok:
 18109 00001CA2 A2[228C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 18110 00001CA5 58                      	pop	ax			;AC000; get return code back
 18111 00001CA6 08C0                    	or	al,al			;AC000; volume label found?
 18112 00001CA8 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 18113 00001CAA BA[F77F]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 18114 00001CAD EB13                    	jmp	short print_serial	;AC000; go print it
 18115                                  
 18116                                  Get_vol_name:
 18117 00001CAF BF[DB8A]                	mov	di,CHARBUF
 18118 00001CB2 89FA                    	mov	dx,di
 18119 00001CB4 BE[B28B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 18120 00001CB7 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 18121 00001CBA F3A4                    	rep	movsb			;AN000;  3/3/KK
 18122                                  
 18123 00001CBC 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 18124 00001CBE AA                      	stosb
 18125 00001CBF BA[0580]                	mov	dx,VolMes_Ptr		;AC000; set up message
 18126                                  
 18127                                  print_serial:
 18128                                  
 18129                                  ; Attempt to get the volume serial number from the disk. If an error
 18130                                  ; occurs, do not print volume serial number.
 18131                                  
 18132 00001CC2 52                      	push	dx			;AN000; save message offset
 18133                                  	;mov	ax,(GetSetMediaID SHL 8)
 18134 00001CC3 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 18135 00001CC6 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 18136 00001CCA BA[798D]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 18137 00001CCD CD21                    	int	21h			;AN000; do the call
 18138                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 18139                                  			; AL = 00h get serial number / 01h set serial number
 18140                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 18141                                  			; DS:DX -> disk info
 18142 00001CCF 5A                      	pop	dx			;AN000; get message offset back
 18143 00001CD0 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 18144 00001CD2 E8FC30                  	call	std_printf		;AC000; go print volume message
 18145                                  	;mov	al,blank				
 18146 00001CD5 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18147 00001CD7 E82101                  	call	PRINT_CHAR		;AN051;  before volume message
 18148 00001CDA BA[1E80]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 18149                                  printvol_end:
 18150 00001CDD E9F130                  	jmp	std_printf		;AC000; go print and exit
 18151                                  
 18152                                  ; ---------------------------------------------------------------------------
 18153                                  
 18154                                  ;****************************************************************
 18155                                  ;*
 18156                                  ;* ROUTINE:	Set_ext_error_msg
 18157                                  ;*
 18158                                  ;* FUNCTION:	Sets up extended error message for printing
 18159                                  ;*
 18160                                  ;* INPUT:	return from INT 21
 18161                                  ;*
 18162                                  ;* OUTPUT:	extended error message set up in extended error
 18163                                  ;*		buffer.
 18164                                  ;*
 18165                                  ;****************************************************************
 18166                                  	
 18167                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18168                                  
 18169                                  	; MSDOS 6.0
 18170                                  Set_Ext_Error_Msg:			;AN000;
 18171 00001CE0 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 18172 00001CE3 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 18173                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 18174 00001CE8 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 18175 00001CEB A3[FC7E]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 18176 00001CEE F9                      	stc				;AN000; make sure carry is set
 18177 00001CEF C3                      	retn				;AN000; return
 18178                                  
 18179                                  ; ---------------------------------------------------------------------------
 18180                                  
 18181                                  ;****************************************************************
 18182                                  ;*
 18183                                  ;* ROUTINE:	Get_ext_error_number
 18184                                  ;*
 18185                                  ;* FUNCTION:	Does get extended error function call
 18186                                  ;*
 18187                                  ;* INPUT:	return from INT 21
 18188                                  ;*
 18189                                  ;* OUTPUT:	AX - extended error number
 18190                                  ;*
 18191                                  ;****************************************************************
 18192                                  
 18193                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18194                                  
 18195                                  	; MSDOS 6.0
 18196                                  get_ext_error_number:			;AN022;
 18197                                  
 18198                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 18199                                  					;AN022; save registers
 18200 00001CF0 53                      	push	bx
 18201 00001CF1 51                      	push	cx
 18202 00001CF2 52                      	push	dx
 18203 00001CF3 56                      	push	si
 18204 00001CF4 57                      	push	di
 18205 00001CF5 55                      	push	bp
 18206 00001CF6 06                      	push	es
 18207 00001CF7 1E                      	push	ds
 18208                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 18209 00001CF8 B459                    	mov	ah,59h
 18210 00001CFA 31DB                    	xor	bx,bx			;AN022; clear BX
 18211 00001CFC CD21                    	int	21h			;AN022;
 18212                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 18213                                  			; BX = version code (0000h for DOS 3.x)
 18214                                  
 18215                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 18216                                  					;AN022; restore registers
 18217 00001CFE 1F                      	pop	ds
 18218 00001CFF 07                      	pop	es
 18219 00001D00 5D                      	pop	bp
 18220 00001D01 5F                      	pop	di
 18221 00001D02 5E                      	pop	si
 18222 00001D03 5A                      	pop	dx
 18223 00001D04 59                      	pop	cx
 18224 00001D05 5B                      	pop	bx
 18225                                  
 18226 00001D06 C3                      	retn				;AN022; return
 18227                                  
 18228                                  ;============================================================================
 18229                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 18230                                  ;============================================================================
 18231                                  ; 08/10/2018 - Retro DOS v3.0
 18232                                  
 18233                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 18234                                  
 18235                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18236                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 18237                                  
 18238                                  ; ---------------------------------------------------------------------------
 18239                                  
 18240                                  ; MSDOS 6.0
 18241                                  ;***	Version - display DOS version
 18242                                  ;
 18243                                  ;	SYNTAX	ver [/debug]
 18244                                  ;
 18245                                  ;		/debug - display additional DOS configuration info
 18246                                  ;
 18247                                  ;	ENTRY	command-line tail is in PSP
 18248                                  ;
 18249                                  ;	EXIT	if successful, nothing
 18250                                  ;		if parse fails,
 18251                                  ;		  parse error message is set up (for Std_EPrintf)
 18252                                  ;		    AX = system parser error code
 18253                                  ;		    DX = ptr to message block
 18254                                  ;		  we jump to CError
 18255                                  ;
 18256                                  ;	EFFECTS
 18257                                  ;	  If parse fails, a parse error message is displayed.
 18258                                  ;	  Otherwise, version message is displayed.
 18259                                  ;	  If /debug is specified, additional DOS info is displayed.
 18260                                  
 18261                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18262                                  VERSION:
 18263                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 18264                                  
 18265                                  ;	Parse command line for /debug switch.
 18266                                  
 18267 00001D07 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 18268 00001D0A BF[8D85]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 18269 00001D0D 31C9                    	xor	cx,cx			; CX = # positional param's found
 18270 00001D0F E8A504                  	call	Parse_With_Msg
 18271                                  
 18272 00001D12 B301                    	mov	bl,1			; BL = flag = /debug present
 18273                                  	;cmp	ax,RESULT_NO_ERROR
 18274                                  	;cmp	ax,0
 18275                                  	;je	short verPrintVer	; something parsed - must be /debug
 18276 00001D14 09C0                    	or	ax,ax
 18277 00001D16 740A                    	jz	short verPrintVer 
 18278 00001D18 FECB                    	dec	bl			; BL = flag = no /debug present
 18279                                  	;cmp	ax,END_OF_LINE ; -1
 18280 00001D1A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18281                                  
 18282                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18283                                  %if 0
 18284                                  	je	short verPrintVer	; reached end of line - ok
 18285                                  %else
 18286 00001D1D 7414                    	je	short not_truever_sw
 18287                                  %endif
 18288                                  
 18289                                  ;	The parse failed. Error message has been set up.
 18290                                  
 18291 00001D1F E92E0C                  	jmp	cerror
 18292                                  
 18293                                  verPrintVer:
 18294                                  
 18295                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18296                                  %if 1
 18297                                  check_t_switch:
 18298 00001D22 813E[5195][AD85]        	cmp	word [PARSE1_SYN],SLASH_T_SYN ; "/T" ; /t switch
 18299 00001D28 7509                    	jne	short not_truever_sw
 18300 00001D2A BA[BF85]                	mov	dx,RD4CMD_VER_MSG
 18301 00001D2D B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9 ; print the message
 18302 00001D2F CD21                    	int	21h
 18303 00001D31 EB43                    	jmp	short verDone
 18304                                  not_truever_sw:
 18305                                  %endif
 18306 00001D33 53                      	push	bx			; save /debug flag
 18307 00001D34 E89808                  	call	CRLF2
 18308 00001D37 E83F00                  	call	PRINT_VERSION
 18309 00001D3A E89208                  	call	CRLF2
 18310 00001D3D 5B                      	pop	bx   			; BL = /debug flag
 18311 00001D3E 08DB                    	or	bl,bl
 18312 00001D40 7434                    	jz	short verDone		; /debug is false - we're done
 18313                                  
 18314                                  ;*	For /debug, display DOS internal revision and DOS location
 18315                                  ;	(low memory, HMA, or ROM).
 18316                                  
 18317                                  ;	Bugbug:	use symbols for bitmasks below.
 18318                                  
 18319                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 18320 00001D42 B80633                  	mov	ax,3306h
 18321 00001D45 CD21                    	int	21h
 18322                                  		; DOS - 5+ Get TRUE Version Number
 18323                                  		; (BL major, BH minor, DL revision, DH flags)
 18324 00001D47 88D0                    	mov	al,dl			;revision number in dl; M013
 18325 00001D49 88F7                    	mov	bh,dh			;flags in dh now; M013
 18326                                  ;M032	and	al,7			; AL = DOS internal revision
 18327 00001D4B 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18328                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18329 00001D4D 7602                    	jbe	short ver1
 18330 00001D4F B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18331                                  ;@@:
 18332                                  ver1:
 18333 00001D51 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18334 00001D53 A2[208C]                	mov	[One_Char_Val],al
 18335 00001D56 BA[4C81]                	mov	dx,dosrev_ptr
 18336 00001D59 E87530                  	call	std_printf		; print DOS internal revision
 18337                                  
 18338 00001D5C B104                    	mov	cl,4
 18339 00001D5E D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18340 00001D60 7209                    	jc	short verRom
 18341 00001D62 D0EF                    	shr	bh,1			; CY = DOS in HMA
 18342 00001D64 720A                    	jc	short verHma
 18343                                  
 18344                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18345                                  
 18346                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18347 00001D66 BA[6081]                	mov	dx,DosLow_Ptr
 18348 00001D69 EB08                    	jmp	short verPrintLoc
 18349                                  verRom: 
 18350                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18351 00001D6B BA[5A81]                	mov	dx,DosRom_Ptr
 18352 00001D6E EB03                    	jmp	short verPrintLoc
 18353                                  verHma: 
 18354                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18355 00001D70 BA[5D81]                	mov	dx,DosHma_Ptr
 18356                                  verPrintLoc:
 18357 00001D73 E85B30                  	call	std_printf
 18358                                  verDone:
 18359 00001D76 E95608                  	jmp	CRLF2
 18360                                  
 18361                                  ; 21/02/2023
 18362                                  ;	; MSDOS 3.3
 18363                                  ;VERSION:
 18364                                  ;	call	CRLF2
 18365                                  ;	call	PRINT_VERSION
 18366                                  ;	jmp	CRLF2
 18367                                  
 18368                                  ; =============== S U B	R O U T	I N E =======================================
 18369                                  
 18370                                  	; 21/02/2023 - Retro DOS v4.0
 18371                                  PRINT_VERSION:
 18372                                  	;mov	ah,GET_VERSION ; 30h
 18373 00001D79 B430                    	mov	ah,30h
 18374 00001D7B CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18375                                  			; Return: AL = major version number (00h for DOS 1.x)
 18376 00001D7D 50                      	push	ax
 18377 00001D7E 30E4                    	xor	ah,ah
 18378 00001D80 A3[1C8C]                	mov	[Major_Ver_Num],ax
 18379 00001D83 58                      	pop	ax
 18380 00001D84 86E0                    	xchg	ah,al
 18381 00001D86 30E4                    	xor	ah,ah
 18382 00001D88 A3[1E8C]                	mov	[Minor_Ver_Num],ax
 18383 00001D8B BA[DE7F]                	mov	dx,VerMes_Ptr
 18384 00001D8E E94030                  	jmp	std_printf
 18385                                  
 18386                                  ; =============== S U B	R O U T	I N E =======================================
 18387                                  
 18388                                  	; 21/02/2023 - Retro DOS v4.0
 18389                                  PRINT_PROMPT:
 18390 00001D91 1E                      	push	ds
 18391 00001D92 0E                      	push	cs
 18392 00001D93 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 18393 00001D94 06                      	push	es
 18394 00001D95 E87805                  	call	find_prompt	; Look for prompt string
 18395 00001D98 7206                    	jc	short PP0	; Can't find one
 18396 00001D9A 26803D00                	cmp	byte [es:di],0
 18397 00001D9E 7524                    	jnz	short PP1
 18398                                  PP0:				; Use default prompt
 18399 00001DA0 E86700                  	call	PRINT_DRIVE
 18400 00001DA3 B03E                    	mov	al,'>'
 18401                                  	;mov	al,SYM
 18402 00001DA5 E85300                  	call	PRINT_CHAR
 18403 00001DA8 EB36                    	jmp	short PP5
 18404                                  ;PP1:
 18405                                  ;	mov	al,[es:di]	; Get a char
 18406                                  ;	inc	di
 18407                                  ;	or	al,al
 18408                                  ;	jz	short PP5	; Nul terminated
 18409                                  ;	; 21/02/2023
 18410                                  ;	cmp	al,'$' ; 24h
 18411                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18412                                  ;	jz	short PP2	; Nope
 18413                                  ;	call	PRINT_CHAR
 18414                                  ;	jmp	short PP1
 18415                                  PP2:
 18416 00001DAA 268A05                  	mov	al,[es:di]
 18417 00001DAD 47                      	inc	di
 18418                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18419 00001DAE BB[6982]                	mov	bx,PROMPT_TABLE-3
 18420 00001DB1 08C0                    	or	al,al
 18421 00001DB3 742B                    	jz	short PP5
 18422                                  PP3:
 18423 00001DB5 83C303                  	add	bx,3
 18424                                  	; 21/02/2023
 18425 00001DB8 E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18426                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18427 00001DBB 3A07                    	cmp	al,[bx]
 18428 00001DBD 7416                    	jz	short PP4
 18429 00001DBF 803F00                  	cmp	byte [bx],0
 18430 00001DC2 75F1                    	jnz	short PP3
 18431                                  	;jmp	short PP1
 18432                                  	; 21/02/2023
 18433                                  PP1:
 18434 00001DC4 268A05                  	mov	al,[es:di]	; Get a char
 18435 00001DC7 47                      	inc	di
 18436 00001DC8 08C0                    	or	al,al
 18437 00001DCA 7414                    	jz	short PP5	; Nul terminated
 18438                                  	; 21/02/2023
 18439 00001DCC 3C24                    	cmp	al,'$' ; 24h
 18440                                  	;cmp	al,[DOLLAR]	; Meta character
 18441 00001DCE 74DA                    	jz	short PP2	; Nope
 18442 00001DD0 E82800                  	call	PRINT_CHAR
 18443 00001DD3 EBEF                    	jmp	short PP1
 18444                                  PP4:
 18445 00001DD5 06                      	push	es
 18446 00001DD6 57                      	push	di
 18447 00001DD7 0E                      	push	cs
 18448 00001DD8 07                      	pop	es
 18449 00001DD9 FF5701                  	call	word [bx+1]
 18450 00001DDC 5F                      	pop	di
 18451 00001DDD 07                      	pop	es
 18452 00001DDE EBE4                    	jmp	short PP1
 18453                                  PP5:
 18454 00001DE0 07                      	pop	es		; Restore segments
 18455 00001DE1 1F                      	pop	ds
 18456 00001DE2 C3                      	retn
 18457                                  
 18458                                  ; ---------------------------------------------------------------------------
 18459                                  
 18460                                  PRINT_BACK:
 18461                                  	; 21/02/2023
 18462 00001DE3 BA[D880]                	mov	dx,dback_ptr
 18463 00001DE6 E9E82F                  	jmp	std_printf
 18464                                  
 18465                                  ; ---------------------------------------------------------------------------
 18466                                  
 18467                                  PRINT_EQ:
 18468 00001DE9 B03D                    	mov	al,'='
 18469 00001DEB EB0E                    	jmp	short PRINT_CHAR
 18470                                  
 18471                                  ; ---------------------------------------------------------------------------
 18472                                  
 18473                                  PRINT_ESC:
 18474 00001DED B01B                    	mov	al,1Bh
 18475 00001DEF EB0A                    	jmp	short PRINT_CHAR
 18476                                  
 18477                                  ; ---------------------------------------------------------------------------
 18478                                  
 18479                                  	; 21/02/2023
 18480                                  PRINT_G:
 18481                                  	;mov	al,[RABRACKET]
 18482 00001DF1 B03E                    	mov	al,'>' ; 3Eh
 18483 00001DF3 EB06                    	jmp	short PRINT_CHAR
 18484                                  
 18485                                  ; ---------------------------------------------------------------------------
 18486                                  
 18487                                  	; 21/02/2023
 18488                                  PRINT_L:
 18489                                  	;mov	al,[LABRACKET]
 18490 00001DF5 B03C                    	mov	al,'<' ; 3Ch
 18491 00001DF7 EB02                    	jmp	short PRINT_CHAR
 18492                                  
 18493                                  ; ---------------------------------------------------------------------------
 18494                                  
 18495                                  	; 21/02/2023
 18496                                  Print_B:
 18497                                  	;mov	al,[VBAR]
 18498 00001DF9 B07C                    	mov	al,'|' ; 7Ch
 18499                                  
 18500                                  ; =============== S U B	R O U T	I N E =======================================
 18501                                  
 18502                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18503                                  PRINT_CHAR:
 18504                                  	; MSDOS 6.0
 18505                                  
 18506                                  ;	Bugbug:	Why bother with ds,es here?
 18507                                  		
 18508 00001DFB 06                      	push	es
 18509 00001DFC 1E                      	push	ds
 18510 00001DFD 07                      	pop	es
 18511 00001DFE 57                      	push	di
 18512 00001DFF 52                      	push	dx
 18513 00001E00 88C2                    	mov	dl,al		;AC000; Get char into al
 18514                                  	;mov	ah,STD_CON_OUTPUT
 18515                                  				;AC000; print the char to stdout
 18516 00001E02 B402                    	mov	ah,2
 18517 00001E04 CD21                    	int	21h		;AC000;
 18518 00001E06 5A                      	pop	dx
 18519 00001E07 5F                      	pop	di
 18520 00001E08 07                      	pop	es
 18521 00001E09 C3                      	retn
 18522                                  
 18523                                  ;21/02/2023
 18524                                  %if 0
 18525                                  	; MSDOS 3.3
 18526                                  	push	es
 18527                                  	push	ds
 18528                                  	pop	es
 18529                                  	push	di
 18530                                  	push	dx
 18531                                  	mov	di,ONE_CHAR_VAL	
 18532                                  	stosb
 18533                                  	mov	dx,ONECHRVALPTR
 18534                                  	call	STD_PRINTF
 18535                                  	pop	dx
 18536                                  	pop	di
 18537                                  	pop	es
 18538                                  	retn
 18539                                  %endif
 18540                                  
 18541                                  ; ---------------------------------------------------------------------------
 18542                                  
 18543                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18544                                  PRINT_DRIVE:
 18545                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18546 00001E0A B419                    	mov	ah,19h
 18547 00001E0C CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18548 00001E0E 0441                    	add	al,'A'
 18549                                  	;add	al,[CAPITAL_A]
 18550                                  	;call	PRINT_CHAR
 18551                                  	;retn
 18552                                  	; 21/02/2023
 18553 00001E10 EBE9                    	jmp	short PRINT_CHAR
 18554                                  
 18555                                  ; ---------------------------------------------------------------------------
 18556                                  
 18557                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18558                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18559                                  
 18560                                  build_dir_for_prompt:
 18561 00001E12 30D2                    	xor	dl,dl
 18562 00001E14 BE[AA8B]                	mov	si,BWDBUF
 18563 00001E17 89F7                    	mov	di,si
 18564 00001E19 A0[B78A]                	mov	al,[CURDRV]
 18565 00001E1C 0441                    	add	al,'A'
 18566 00001E1E B43A                    	mov	ah,':'
 18567 00001E20 AB                      	stosw
 18568 00001E21 A0[AA8A]                	mov	al,[DIRCHAR]
 18569 00001E24 AA                      	stosb
 18570 00001E25 87F7                    	xchg	si,di
 18571 00001E27 893E[118C]              	mov	[string_ptr_2],di
 18572                                  	;mov	ah,CURRENT_DIR ; 47h
 18573 00001E2B B447                    	mov	ah,47h
 18574 00001E2D CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18575                                  			; DL = drive (0=default,1=A,etc.)
 18576                                  			; DS:SI	points to 64-byte buffer area
 18577                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18578 00001E2F BA[C380]                	mov	dx,string_buf_ptr
 18579 00001E32 7303                    	jnc	short doprint
 18580                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18581 00001E34 BA[8B7F]                	mov	dx,BADCURDRV
 18582                                  doprint:
 18583                                  	;call	std_printf
 18584                                  	;retn
 18585 00001E37 E9972F                  	jmp	std_printf
 18586                                  
 18587                                  ; =============== S U B	R O U T	I N E =======================================
 18588                                  
 18589                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18590                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18591                                  
 18592                                  build_dir_for_chdir:
 18593 00001E3A E80D00                  	call	build_dir_string
 18594 00001E3D BA[AA8B]                	mov	dx,DIRBUF
 18595 00001E40 8916[118C]              	mov	[string_ptr_2],dx
 18596                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18597                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18598 00001E44 BA[C380]                	mov	dx,string_buf_ptr
 18599                                  	;call	std_printf
 18600                                  	;retn
 18601                                  	; 21/02/2023
 18602                                  	;jmp	short doprint
 18603 00001E47 E9872F                  	jmp	std_printf
 18604                                  
 18605                                  ; =============== S U B	R O U T	I N E =======================================
 18606                                  
 18607                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18608                                  build_dir_string:
 18609 00001E4A 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18610 00001E4E 88D0                    	mov	al,dl
 18611 00001E50 0440                    	add	al,'@'	; 40h
 18612 00001E52 3C40                    	cmp	al,'@'
 18613 00001E54 7506                    	jne	short gotdrive
 18614 00001E56 0206[B78A]              	add	al,[CURDRV]
 18615 00001E5A FEC0                    	inc	al
 18616                                  gotdrive:
 18617 00001E5C 50                      	push	ax
 18618 00001E5D BE[AD8B]                	mov	si,BWDBUF+3
 18619                                  	;mov	ah,CURRENT_DIR ; 47h
 18620 00001E60 B447                    	mov	ah,47h
 18621 00001E62 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18622                                  			; DL = drive (0=default,1=A,etc.)
 18623                                  			; DS:SI	points to 64-byte buffer area
 18624 00001E64 7305                    	jnc	short dpbisok
 18625 00001E66 0E                      	push	cs
 18626 00001E67 1F                      	pop	ds
 18627 00001E68 E9ED09                  	jmp	DRVBAD
 18628                                  dpbisok:
 18629 00001E6B BF[AA8B]                	mov	di,BWDBUF
 18630 00001E6E 89FA                    	mov	dx,di
 18631 00001E70 58                      	pop	ax
 18632 00001E71 B43A                    	mov	ah,':'
 18633 00001E73 AB                      	stosw
 18634 00001E74 A0[AA8A]                	mov	al,[DIRCHAR]
 18635 00001E77 AA                      	stosb
 18636 00001E78 C3                      	retn
 18637                                  
 18638                                  ; ---------------------------------------------------------------------------
 18639                                  
 18640                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18641                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18642                                  PATH:
 18643                                  	; MSDOS 6.0
 18644 00001E79 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18645 00001E7B BF[D387]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18646 00001E7E AA                      	stosb				;AN049; Initialize PATH to null
 18647 00001E7F 4F                      	dec	di			;AN049; point to the start of buffer
 18648 00001E80 E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 18649 00001E83 7460                    	jz	short disppath		; Print the current path
 18650                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18651 00001E85 3C3B                    	cmp	al,';' ; 3Bh
 18652 00001E87 7503                    	jne	short pathslp 		;AC049;
 18653 00001E89 46                      	inc	si			;AN049; point past semicolon
 18654 00001E8A EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18655                                  pathslp:					; Get the user specified path
 18656 00001E8C AC                      	lodsb				; Get a character
 18657 00001E8D 3C0D                    	cmp	al,0Dh
 18658                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18659 00001E8F 7434                    	je	short path_eol		;AC049; yes - end of command
 18660 00001E91 E82905                  	call	testkanj		;See if DBCS
 18661 00001E94 7405                    	jz	short notkanj2		;No - continue
 18662 00001E96 AA                      	stosb				;AC049; Yes - store the first byte
 18663 00001E97 AC                      	lodsb				;skip second byte of DBCS
 18664                                  path_hold:				;AN049;
 18665 00001E98 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18666 00001E99 EBF1                    	jmp	short pathslp		;continue parsing
 18667                                  notkanj2:
 18668 00001E9B E84905                  	call	UPCONV			;upper case the character
 18669                                  
 18670 00001E9E 3C3B                    	cmp	al,';' ; 3Bh
 18671                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18672 00001EA0 74F6                    	je	short path_hold		;AC049; go store it
 18673 00001EA2 E83F07                  	call	DELIM			;delimiter?
 18674 00001EA5 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18675                                  scan_white:				;AN049; make sure were at EOL
 18676 00001EA7 AC                      	lodsb				;AN049; get a character
 18677 00001EA8 3C0D                    	cmp	al,0Dh
 18678                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18679 00001EAA 7419                    	je	short path_eol		;AN049; yes - go set path
 18680 00001EAC 3C20                    	cmp	al,' ' ; 20h
 18681                                  	;cmp	al,blank		;AN049; whitespace?
 18682 00001EAE 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18683                                  	;cmp	al,9
 18684 00001EB0 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18685 00001EB2 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18686                                  
 18687 00001EB4 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18688                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18689 00001EB7 C706[FC7E]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18690                                  	;mov	byte [msg_disp_class],2		
 18691                                  					;AN049; set up parse error msg class
 18692 00001EBD C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 18693 00001EC2 E98B0A                  	jmp	cerror			;AN049;
 18694                                  path_eol:				;AN049; Parsing was clean
 18695 00001EC5 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18696 00001EC7 AA                      	stosb				;AN049;    buffer
 18697 00001EC8 E84004                  	call	find_path		;AN049; Find PATH in environment
 18698 00001ECB E81404                  	call	delete_path		;AC049; Delete any offending name
 18699 00001ECE E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 18700 00001ED1 E89A04                  	call	move_name		;AC049; move in PATH=
 18701 00001ED4 BE[D387]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18702                                  store_path:				;AN049; Store the PATH in the environment
 18703 00001ED7 AC                      	lodsb				;AN049; Get a character
 18704                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18705 00001ED8 20C0                    	and	al,al ; al=0 ?
 18706 00001EDA 7405                    	jz	short got_paths		;AN049; yes - exit
 18707 00001EDC E82A05                  	call	store_char		;AN049; no - store character
 18708 00001EDF EBF6                    	jmp	short store_path	;AN049; continue
 18709                                  got_paths:				;AN049; we're finished
 18710 00001EE1 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18711 00001EE3 AB                      	stosw				;    	the environment
 18712 00001EE4 C3                      	retn
 18713                                  disppath:
 18714 00001EE5 E82304                  	call	find_path		;AN049;
 18715 00001EE8 E80300                  	call	print_path
 18716                                  	;call	CRLF2
 18717                                  	;retn
 18718                                  	; 21/02/2023
 18719 00001EEB E9E106                  	jmp	CRLF2
 18720                                  
 18721                                  ; 21/02/2023
 18722                                  %if 0
 18723                                  	; MSDOS 3.3
 18724                                  	call	FIND_PATH		; Find PATH in environment
 18725                                  	call	PGETARG			; Pre scan for arguments
 18726                                  	jz	short DISPPATH		; Print the current path
 18727                                  	call	DELETE_PATH		; Delete any offending name
 18728                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18729                                  	call	MOVE_NAME		; Move in PATH=
 18730                                  	call	PGETARG
 18731                                  	cmp	al,';'
 18732                                  	jz	short GOTPATHS
 18733                                  PATHSLP:
 18734                                  	lodsb
 18735                                  	cmp	al,0Dh			; End of line (CR) ?		
 18736                                  	jz	short GOTPATHS		; yes - exit
 18737                                  	;call	UPCONV	; MSDOS 6.0
 18738                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18739                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18740                                  	jz	short NOTDELIM		; go set path
 18741                                  	call	DELIM			; is it delim/null char ?
 18742                                  	jz	short GOTPATHS		; yes - exit
 18743                                  NOTDELIM:
 18744                                  	call	STORE_CHAR		; no - store character
 18745                                  	jmp	short PATHSLP
 18746                                  GOTPATHS:
 18747                                  	xor	ax,ax			; null terminate the PATH
 18748                                  	stosw				; in the environment
 18749                                  	retn
 18750                                  DISPPATH:
 18751                                  	call	PRINT_PATH
 18752                                  	call	CRLF2
 18753                                  	retn
 18754                                  %endif
 18755                                  
 18756                                  ; =============== S U B	R O U T	I N E =======================================
 18757                                  
 18758                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18759                                  print_path:
 18760 00001EEE 26803D00                	cmp	byte [es:di],0
 18761 00001EF2 750A                    	jnz	short path1
 18762                                  path0:
 18763 00001EF4 BA[5180]                	mov	dx,NULLPATH_PTR
 18764 00001EF7 0E                      	push	cs
 18765 00001EF8 07                      	pop	es
 18766 00001EF9 0E                      	push	cs
 18767 00001EFA 1F                      	pop	ds
 18768 00001EFB E9D32E                  	jmp	std_printf
 18769                                  path1:
 18770 00001EFE 06                      	push	es
 18771 00001EFF 1F                      	pop	ds
 18772 00001F00 83EF05                  	sub	di,5
 18773 00001F03 89FE                    	mov	si,di
 18774 00001F05 E8AD04                  	call	SCASB2		; Look for null
 18775                                  	;cmp	cx,0FFh ; 255
 18776                                  	; 21/02/2023
 18777                                  	;ch = 0
 18778 00001F08 80F9FF                  	cmp	cl,255
 18779 00001F0B 74E7                    	je	short path0
 18780 00001F0D 0E                      	push	cs
 18781 00001F0E 07                      	pop	es
 18782 00001F0F BF[F692]                	mov	di,Arg_Buf
 18783                                  	;mov	dx,100h ; 256
 18784                                  	;sub	dx,cx
 18785                                  	;xchg	dx,cx
 18786                                  	; 21/02/2023
 18787 00001F12 F6D9                    	neg	cl ; 256-cl
 18788 00001F14 F3A4                    	rep	movsb
 18789 00001F16 BA[9980]                	mov	dx,arg_buf_ptr
 18790 00001F19 0E                      	push	cs
 18791 00001F1A 1F                      	pop	ds
 18792 00001F1B E9B32E                  	jmp	std_printf
 18793                                  
 18794                                  ; ---------------------------------------------------------------------------
 18795                                  
 18796                                  ; ****************************************************************
 18797                                  ; *
 18798                                  ; * ROUTINE:	 CLS
 18799                                  ; *
 18800                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18801                                  ; *		 installed, send a control string to clear the
 18802                                  ; *		 screen.
 18803                                  ; *
 18804                                  ; * INPUT:	 command line at offset 81H
 18805                                  ; *
 18806                                  ; * OUTPUT:	 none
 18807                                  ; *
 18808                                  ; ****************************************************************
 18809                                  
 18810                                  	; MSDOS 6.0
 18811                                  
 18812                                  ANSI_installed	equ 0FFh
 18813                                  
 18814                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18815                                  CLS:
 18816                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18817                                  	;mov	ah,1Ah
 18818                                  	;mov	al,0			;AN000;
 18819 00001F1E B8001A                  	mov	ax,1A00h
 18820 00001F21 CD2F                    	int	2Fh			;AN000;
 18821                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18822                                  		; Return: AL = FFh if installed
 18823 00001F23 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18824 00001F25 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18825                                  
 18826                                  check_lines:
 18827                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18828 00001F27 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18829                                  	;mov	bx,stdout		;AN000; lines for stdout
 18830 00001F2A BB0100                  	mov	bx,1   ; handle
 18831                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18832                                  	;mov	ch,3   ; CON device	
 18833                                  	;;mov	cl,get_generic		;AN000; get information
 18834                                  	;mov	cl,7Fh ; minor function, get display info
 18835                                  	; 25/04/2023
 18836 00001F2D B97F03                  	mov	cx,037Fh
 18837 00001F30 BA[678D]                	mov	dx,Display_Ioctl	;AN000;
 18838 00001F33 CD21                    	int	21h			;AN000;
 18839 00001F35 720A                    	jc	short no_variable	;AN000; function had error, use default
 18840                                  		; 21/02/2023
 18841                                  		; ds:dx = parameter block
 18842                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18843                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18844                                  		;   	 01h  byte  reserved
 18845                                  		;   	 02h  word  length of following data
 18846                                  		;   	 04h  word  control flags
 18847                                  		;	       bit 0 set for blink, clear for intensity
 18848                                  		;	       bits 1 to 15 reserved
 18849                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18850                                  		;   	 07h  byte  reserved
 18851                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18852                                  		;   	 0Ah  word  pixel columns
 18853                                  		;   	 0Ch  word  pixel rows
 18854                                  		;   	 0Eh  word  character columns
 18855                                  		;   	 10h  word  character rows
 18856                                  	
 18857                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18858                                  	;				;AN000; get number of rows returned
 18859                                  	;mov	dh,al			;AN000; set number of rows
 18860                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18861                                  	;				;AN000; get number of columns returned
 18862                                  	;mov	dl,al			;AN000; set number of columns
 18863                                  	; 21/02/2023
 18864 00001F37 8A16[758D]              	mov	dl,[display_width]
 18865 00001F3B 8A36[778D]              	mov	dh,[LinPerPag]
 18866 00001F3F EB3B                    	jmp	short regcls		;AN000; go do cls
 18867                                  
 18868                                  no_variable:
 18869                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18870                                  	;mov	bx,1
 18871                                  	; bx = 1
 18872                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18873 00001F41 B80044                  	mov	ax,4400h
 18874 00001F44 CD21                    	int	21h			;AC000;
 18875 00001F46 F6C280                  	test	dl,80h
 18876                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18877 00001F49 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18878 00001F4B F6C210                  	test	dl,10h
 18879                                  	;test	dl,devid_SPECIAL	;AC000;
 18880 00001F4E 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18881                                  
 18882                                  ansicls:
 18883 00001F50 E85200                  	call	ansi_cls		;AN000; clear the screen
 18884 00001F53 EB2C                    	jmp	short cls_ret		;AN000; exit
 18885                                  
 18886                                  ; Get video mode
 18887                                  
 18888                                  cls_normal:				;AC000;
 18889                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18890 00001F55 B40F                    	mov	ah,0Fh
 18891                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18892 00001F57 CD10                    	int	10h
 18893 00001F59 3C03                    	cmp	al,3
 18894                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18895 00001F5B 760A                    	jbe	short DoAlpha
 18896 00001F5D 3C07                    	cmp	al,7
 18897                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18898 00001F5F 7406                    	je	short DoAlpha
 18899                                  
 18900                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18901                                  ; be just as bogus and set the mode that we just got. This will blank the
 18902                                  ; screen too.
 18903                                  
 18904                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18905 00001F61 B400                    	mov	ah,0
 18906                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18907 00001F63 CD10                    	int	10h
 18908 00001F65 EB1A                    	jmp	short cls_ret		;AC000; exit
 18909                                  
 18910                                  DoAlpha:
 18911                                  
 18912                                  ; Get video mode and number of columns to scroll
 18913                                  
 18914                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18915                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18916                                  ;M01   area
 18917                                  ;M01   Commented out code here is the original
 18918                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18919                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18920                                  ;M01	mov	dl,ah
 18921                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18922                                  
 18923                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18924                                  
 18925 00001F67 1E                      	push	ds
 18926                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18927 00001F68 B84000                  	mov	ax,40h
 18928 00001F6B 8ED8                    	mov	ds,ax			;  *			M01
 18929                                  
 18930                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18931 00001F6D 8A164A00                	mov	dl,[4Ah]
 18932                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18933 00001F71 8A368400                	mov	dh,[84h]
 18934 00001F75 1F                      	pop	ds			;			M01
 18935                                  
 18936 00001F76 08F6                    	or	dh,dh			; Q:ZERO		M01
 18937 00001F78 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18938                                  
 18939                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18940                                  	; 25/04/2023
 18941 00001F7A B619                    	mov	dh,25
 18942                                  regcls:
 18943 00001F7C FEC6                    	inc	dh			; height+1		M018
 18944 00001F7E E80100                  	call	reg_cls 		; go clear the screen
 18945                                  cls_ret:
 18946 00001F81 C3                      	retn				; exit
 18947                                  
 18948                                  ; ---------------------------------------------------------------------------
 18949                                  
 18950                                  ; 21/02/2023
 18951                                  %if 0
 18952                                  	; MSDOS 3.3
 18953                                  CLS:
 18954                                  	mov	bx,STDOUT ; 1
 18955                                  	mov	ax,IOCTL*256 ; 4400h
 18956                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18957                                  			; BX = file or device handle
 18958                                  	test	dl,80h	; devid_ISDEV
 18959                                  	jz	short ANSICLS	; If a file put out ANSI
 18960                                  	test	dl,10h  ; devid_SPECIAL
 18961                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18962                                  
 18963                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18964                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18965                                  			; AL = interrupt number
 18966                                  			; Return: ES:BX	= value	of interrupt vector
 18967                                  	mov	dx,es
 18968                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18969                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18970                                  			; AL = interrupt number
 18971                                  			; Return: ES:BX	= value	of interrupt vector
 18972                                  	mov	ax,es
 18973                                  	cmp	dx,ax	; If not default driver, do ANSI
 18974                                  	ja	short ANSICLS
 18975                                  
 18976                                  	mov	ah,0Fh
 18977                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18978                                  			; Return: AH = number of columns on screen
 18979                                  			; AL = current video mode
 18980                                  			; BH = current active display page
 18981                                  	cmp	al,3
 18982                                  	jbe	short DOALPHA
 18983                                  	cmp	al,7
 18984                                  	jz	short DOALPHA
 18985                                  	mov	ah,0
 18986                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18987                                  			; AL = mode
 18988                                  	retn
 18989                                  
 18990                                  DOALPHA:
 18991                                  	mov	ah,0Bh	; Set overscan to black
 18992                                  	xor	bx,bx
 18993                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18994                                  			; BH = 00h, BL = border color
 18995                                  			; BH = 01h, BL = palette (0-3)
 18996                                  	mov	ah,0Fh
 18997                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18998                                  			; Return: AH = number of columns on screen
 18999                                  			; AL = current video mode
 19000                                  			; BH = current active display page
 19001                                  	mov	dl,ah
 19002                                  	dec	dl
 19003                                  	mov	dh,24
 19004                                  	xor	ax,ax
 19005                                  	mov	cx,ax
 19006                                  	mov	bx,700h
 19007                                  	mov	ah,6
 19008                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 19009                                  			; AL = number of lines to scroll window	
 19010                                  			;	(0 = blank whole window)
 19011                                  			; BH = attributes to be	used on	blanked	lines
 19012                                  			; CH,CL	= row,column of	upper left corner of window 
 19013                                  			;	  to scroll
 19014                                  			; DH,DL	= row,column of	lower right corner of window
 19015                                  	xor	dx,dx
 19016                                  	mov	bh,0
 19017                                  	mov	ah,2
 19018                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 19019                                  			; DH,DL	= row,column (0,0 = upper left)
 19020                                  			; BH = page number
 19021                                  	retn
 19022                                  
 19023                                  ANSICLS:
 19024                                  	mov	si,CLSSTRING
 19025                                  	lodsb
 19026                                  	mov	cl,al
 19027                                  	xor	ch,ch
 19028                                  	mov	ah,RAW_CON_IO ; 6
 19029                                  CLRLOOP:
 19030                                  	lodsb
 19031                                  	mov	dl,al
 19032                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 19033                                  			; DL = character <> FFh
 19034                                  			;  Return: ZF set = no character
 19035                                  			;   ZF clear = character recieved, AL = character
 19036                                  	loop	CLRLOOP
 19037                                  	retn
 19038                                  %endif
 19039                                  
 19040                                  ; ---------------------------------------------------------------------------
 19041                                  
 19042                                  ; MSDOS 6.0
 19043                                  
 19044                                  ; ****************************************************************
 19045                                  ; *
 19046                                  ; * ROUTINE:	 REG_CLS
 19047                                  ; *
 19048                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 19049                                  ; *
 19050                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 19051                                  ; *		 DH = NUMBER OF ROWS
 19052                                  ; *
 19053                                  ; * OUTPUT:	 none
 19054                                  ; *
 19055                                  ; ****************************************************************
 19056                                  
 19057                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19058                                  reg_cls:
 19059                                  ; Set overscan to black.
 19060                                  
 19061 00001F82 FECE                    	dec	dh			; decrement rows and columns
 19062 00001F84 FECA                    	dec	dl			;  to zero base
 19063 00001F86 52                      	push	dx			; save rows,columns
 19064                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 19065 00001F87 B40B                    	mov	ah,0Bh
 19066 00001F89 31DB                    	xor	bx,bx
 19067                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19068 00001F8B CD10                    	int	10h
 19069 00001F8D 5A                      	pop	dx			;  restore rows,colums
 19070                                  
 19071 00001F8E 31C0                    	xor	ax,ax			; zero out ax
 19072 00001F90 89C1                    	mov	cx,ax			;  and cx
 19073                                  
 19074                                  ; Scroll active page
 19075                                  
 19076                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 19077 00001F92 B406                    	mov	ah,6
 19078                                  	;mov	bh,video_attribute	; attribute for blank line
 19079 00001F94 B707                    	mov	bh,7
 19080 00001F96 30DB                    	xor	bl,bl			; set BL to 0
 19081                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19082 00001F98 CD10                    	int	10h
 19083                                  
 19084                                  ; Seek to cursor to 0,0
 19085                                  
 19086                                  ;M022 following two lines added
 19087                                  	;mov	ah,get_video_state	; get current video page in BH
 19088 00001F9A B40F                    	mov	ah,0Fh
 19089                                  	;int	video_io_int
 19090 00001F9C CD10                    	int	10h
 19091                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 19092 00001F9E B402                    	mov	ah,2
 19093 00001FA0 31D2                    	xor	dx,dx			; row and column 0
 19094                                  ;M022	mov	bh,0
 19095                                  	;int	video_io_int		; do into 10h - BIOS video IO
 19096 00001FA2 CD10                    	int	10h
 19097                                  
 19098 00001FA4 C3                      	retn
 19099                                  
 19100                                  ; ---------------------------------------------------------------------------
 19101                                  
 19102                                  ; MSDOS 6.0
 19103                                  
 19104                                  ; ****************************************************************
 19105                                  ; *
 19106                                  ; * ROUTINE:	 ANSI_CLS
 19107                                  ; *
 19108                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 19109                                  ; *		 to STDOUT.
 19110                                  ; *
 19111                                  ; * INPUT:	 none
 19112                                  ; *
 19113                                  ; * OUTPUT:	 none
 19114                                  ; *
 19115                                  ; ****************************************************************
 19116                                  
 19117                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19118                                  ansi_cls:			;AC000;
 19119 00001FA5 BE[6782]                	mov	si,CLSSTRING
 19120                                  			; db 4,1Bh,'[2J'
 19121 00001FA8 AC                      	lodsb
 19122 00001FA9 88C1                    	mov	cl,al	; al = 4
 19123 00001FAB 30ED                    	xor	ch,ch
 19124                                  	;mov	ah,Raw_CON_IO
 19125 00001FAD B406                    	mov	ah,6
 19126                                  clrloop:
 19127 00001FAF AC                      	lodsb
 19128 00001FB0 88C2                    	mov	dl,al
 19129 00001FB2 CD21                    	int	21h
 19130                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 19131 00001FB4 E2F9                    	loop	clrloop
 19132 00001FB6 C3                      	retn
 19133                                  
 19134                                  ;============================================================================
 19135                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 19136                                  ;============================================================================
 19137                                  ; 08/10/2018 - Retro DOS v3.0
 19138                                  
 19139                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 19140                                  
 19141                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19142                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 19143                                  
 19144                                  ; ---------------------------------------------------------------------------
 19145                                  
 19146                                  ; ****************************************************************
 19147                                  ; *
 19148                                  ; * ROUTINE:	 CTTY - Change console
 19149                                  ; *
 19150                                  ; * SYNTAX:	 CTTY device
 19151                                  ; *
 19152                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 19153                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 19154                                  ; *		 STDERR. This routine returns to LODCOM1.
 19155                                  ; *
 19156                                  ; * INPUT:	 command line at offset 81H
 19157                                  ; *
 19158                                  ; * OUTPUT:	 none
 19159                                  ; *
 19160                                  ; ****************************************************************
 19161                                  
 19162                                  	; 21/02/2023 - Retro DOS v4.0
 19163                                  	; 10/06/2023
 19164                                  CTTY:
 19165                                  	; MSDOS 6.0
 19166 00001FB7 1E                      	push	ds			;AN000; Get local ES
 19167 00001FB8 07                      	pop	es			;AN000;
 19168 00001FB9 BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 19169 00001FBC BF[7B85]                	mov	di,PARSE_CTTY
 19170                                  					;AC000; Get address of PARSE_CTTY
 19171 00001FBF 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 19172 00001FC1 31D2                    	xor	dx,dx			;AC000;
 19173 00001FC3 E85523                  	call	cmd_parse		;AC000; call parser
 19174                                  
 19175                                  	;cmp	ax,-1 ; 0FFFFh
 19176                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19177                                  	;je	short ctty_error	;AN000; yes - error
 19178                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 19179                                  	;and	ax,ax ; ax > 0 ?
 19180                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 19181                                  	; 10/06/2023
 19182 00001FC6 40                      	inc	ax  ; cmp ax,-1
 19183 00001FC7 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 19184 00001FC9 48                      	dec	ax  ; cmp ax,0
 19185 00001FCA 7531                    	jnz	short ctty_error  ; 1 -> 0
 19186                                  	; ax = 0
 19187                                  
 19188 00001FCC 56                      	push	si			;AN000; save position in line
 19189 00001FCD C536[5395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19190 00001FD1 BF[908C]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 19191                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 19192 00001FD4 AC                      	lodsb				;AN000; get a char from buffer
 19193 00001FD5 AA                      	stosb				;AN000; store in srcbuf
 19194                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 19195 00001FD6 08C0                    	or	al,al ; al = 0 ?
 19196 00001FD8 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 19197                                  					;AN000; no - keep moving
 19198 00001FDA 5E                      	pop	si			;AN000; get line position back
 19199 00001FDB BF[7B85]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 19200 00001FDE E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 19201                                  	;jz	short nocolon 		;AN000; yes - continue
 19202                                  	; 21/02/2023
 19203 00001FE1 751A                    	jnz	short ctty_error
 19204                                  ;ctty_error:
 19205                                  	;jmp	short isbaddev		;AC000; yes - exit
 19206                                  
 19207                                  	; 21/02/2023
 19208                                  	; MSDOS 3.3
 19209                                  	;call	SETPATH
 19210                                  	;dec	si
 19211                                  	;dec	si
 19212                                  	;cmp	byte [si],':'
 19213                                  	;jnz	short NOCOLON
 19214                                  	;mov	byte [si],0
 19215                                  nocolon:
 19216                                  	; 21/02/2023
 19217                                  	; MSDOS 6.0
 19218 00001FE3 BA[908C]                	mov	dx,SrcBuf
 19219                                  ;NOCOLON:
 19220                                  	; MSDOS 3.3 & MSDOS 6.0
 19221                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 19222                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 19223 00001FE6 B8023D                  	mov	ax,3D02h ; 21/02/2023
 19224 00001FE9 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 19225                                  			; DS:DX	-> ASCIZ filename
 19226                                  			; AL = access mode
 19227                                  			; 2 - read & write
 19228 00001FEB 7210                    	jc	short isbaddev
 19229 00001FED 89C3                    	mov	bx,ax
 19230                                  	;mov	ax,IOCTL*256 ; 4400h
 19231 00001FEF B80044                  	mov	ax,4400h
 19232 00001FF2 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 19233                                  			; BX = file or device handle
 19234 00001FF4 F6C280                  	test	dl,80h
 19235 00001FF7 750C                    	jnz	short devisok
 19236                                  closedev:
 19237                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 19238 00001FF9 B43E                    	mov	ah,3Eh
 19239 00001FFB CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19240                                  			; BX = file handle
 19241                                  ctty_error:
 19242                                  isbaddev:
 19243 00001FFD BA[5780]                	mov	dx,BADDEV_PTR
 19244 00002000 E8CE2D                  	call	std_printf
 19245 00002003 EB40                    	jmp	short resret
 19246                                  
 19247                                  	;nop
 19248                                  devisok:
 19249                                  	; 21/02/2023
 19250                                  	; MSDOS 6.0
 19251 00002005 52                      	push	dx		;AN007; save device info
 19252                                  	; 08/06/2023 (BugFix)
 19253 00002006 A1[DB80]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 19254                                  	;mov	dh,util_msg_class
 19255 00002009 B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 19256 0000200B 53                      	push	bx		;AN021; save handle
 19257 0000200C E8A52E                  	call	TSYSGETMSG	;AN021; get the address of the message
 19258 0000200F 89F2                    	mov	dx,si		;AN021; get address into dx
 19259                                  	;mov	ax,(Write shl 8)
 19260 00002011 B80040                  	mov	ax,4000h	;AN007; write to device
 19261 00002014 B90200                  	mov	cx,2		;AN007; write two bytes
 19262 00002017 CD21                    	int	21h		;AN007;
 19263 00002019 5B                      	pop	bx		;AN021; get back handle
 19264 0000201A 5A                      	pop	dx		;AN007; get back device info
 19265 0000201B 72DC                    	jc	short closedev	;AN007; if error, quit
 19266                                  
 19267                                  	; MSDOS 3.3 & MSDOS 6.0
 19268 0000201D 30F6                    	xor	dh,dh
 19269 0000201F 80CA03                  	or	dl,3
 19270                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 19271                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 19272 00002022 B80144                  	mov	ax,4401h
 19273 00002025 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 19274                                  			; BX = device handle,DH = 0
 19275                                  			; DL = device information to set 
 19276                                  			;	(bits 0-7 from	function 0)
 19277 00002027 53                      	push	bx
 19278 00002028 B90300                  	mov	cx,3
 19279 0000202B 31DB                    	xor	bx,bx
 19280                                  iclloop:			; Close basic handles
 19281                                  	;mov	ah,CLOSE ; 3Eh
 19282 0000202D B43E                    	mov	ah,3Eh
 19283 0000202F CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19284                                  			; BX = file handle
 19285 00002031 43                      	inc	bx
 19286 00002032 E2F9                    	loop	iclloop
 19287 00002034 5B                      	pop	bx		; Get handle
 19288                                  	;mov	ah,XDUP ; 45h
 19289 00002035 B445                    	mov	ah,45h
 19290 00002037 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19291                                  			; BX = file handle to duplicate
 19292                                  	;mov	ah,XDUP ; 45h
 19293 00002039 B445                    	mov	ah,45h
 19294 0000203B CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19295                                  			; BX = file handle to duplicate
 19296                                  	;mov	ah,XDUP ; 45h
 19297 0000203D B445                    	mov	ah,45h
 19298 0000203F CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19299                                  			; BX = file handle to duplicate
 19300                                  	;mov	ah,CLOSE ; 3Eh
 19301 00002041 B43E                    	mov	ah,3Eh
 19302 00002043 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19303                                  			; BX = file handle
 19304                                  resret:
 19305 00002045 8E1E[A58A]              	mov	ds,[RESSEG]
 19306 00002049 1E                      	push	ds
 19307                                  	;mov	ax,[18h]
 19308 0000204A A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 19309 0000204D A3[8A01]                	mov	[Io_Save],ax
 19310                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 19311                                  	;;mov	ax,LODCOM1
 19312                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 19313                                  	;mov	ax,175h ; MSDOS 6.0
 19314 00002050 B8[7400]                	mov	ax,TrnLodCom1_Trap
 19315 00002053 50                      	push	ax
 19316                                  
 19317 00002054 CB                      	retf		; Far return
 19318                                  
 19319                                  ; ---------------------------------------------------------------------------
 19320                                  
 19321                                  ;****************************************************************
 19322                                  ;*
 19323                                  ;* ROUTINE:	CHCP - Change code page internal command
 19324                                  ;*		(added DOS 3.30 07/21/86)
 19325                                  ;*
 19326                                  ;* SYNTAX:	CHCP [xxx]
 19327                                  ;*		where xxx is a valid code page
 19328                                  ;*
 19329                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 19330                                  ;*		6402H to set the code page to xxxx. If no parameters
 19331                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19332                                  ;*		to get global code page and display it to the user.
 19333                                  ;*
 19334                                  ;* INPUT:	command line at offset 81H
 19335                                  ;*
 19336                                  ;* OUTPUT:	none
 19337                                  ;*
 19338                                  ;****************************************************************
 19339                                  
 19340                                  NLSFUNC_installed equ  0FFh
 19341                                  set_global_cp	  equ  2
 19342                                  get_global_cp	  equ  1
 19343                                  
 19344                                  	; 21/02/2023 - Retro DOS v4.0
 19345                                  	; 09/06/2023
 19346                                  	; 10/06/2023
 19347                                  CHCP:
 19348                                  	; MSDOS 6.0
 19349 00002055 1E                      	push	ds		;AN000; Get local ES
 19350 00002056 07                      	pop	es		;AN000;
 19351 00002057 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19352 0000205A BF[9284]                	mov	di,PARSE_CHCP
 19353                                  				;AN000; Get address of PARSE_CHCP
 19354 0000205D 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19355 0000205F 31D2                    	xor	dx,dx		;AC000;
 19356 00002061 E85301                  	call    Parse_With_Msg	;AC018; call parser
 19357                                  
 19358                                  	;cmp	ax,-1
 19359                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19360                                  	;;jne	short setcp	;AC000; no go get number & set code page
 19361                                  	;je	short getcp	;AC000; yes - no parm - get code page
 19362                                  ;setcp:
 19363                                  	;;cmp	ax,0
 19364                                  	;;cmp	ax,RESULT_NO_ERROR
 19365                                  	;			;AN000; did we have an error?
 19366                                  	;;jne	short cp_error	;AC018; yes - go issue message
 19367                                  	;and	ax,ax ; ax > 0 ?
 19368                                  	;jnz	short cp_error	
 19369                                  	; 10/06/2023
 19370 00002064 40                      	inc	ax  ; cmp ax,-1	
 19371 00002065 745C                    	jz	short getcp ; 0FFFFh -> 0
 19372 00002067 48                      	dec	ax  ; cmp ax,0
 19373 00002068 7556                    	jnz	short cp_error ; 1 -> 0
 19374                                  	; ax = 0
 19375                                  
 19376                                  	;;push	cx		;AN000; save positional count
 19377                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 19378                                  	;;mov	cx,[bx]		;AN000;  into cx
 19379                                  	;;mov	[system_cpage],cx
 19380                                  	;			;AN000; save user input number
 19381                                  	;;pop	cx		;AC000; restore positional count
 19382                                  	;; 21/02/2023
 19383                                  	;mov	di,[bx]
 19384                                  	;mov	[system_cpage],di
 19385                                  	; 09/06/2023	
 19386 0000206A 8B1E[5395]              	mov	bx,[PARSE1_ADDR]
 19387 0000206E 891E[0B8C]              	mov	[system_cpage],bx
 19388                                  	;
 19389 00002072 BF[9284]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19390 00002075 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 19391 00002078 7546                    	jnz	short cp_error	;AC000; no - exit
 19392                                  okset:
 19393                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19394                                  	;mov	ah,14h
 19395                                  	;mov	al,0		;AN000;
 19396 0000207A B80014                  	mov	ax,1400h
 19397 0000207D CD2F                    	int	2Fh		;AN000;
 19398                                  	;cmp	al,0FFh
 19399 0000207F 3CFF                    	cmp	al,NLSFUNC_installed
 19400                                  				;AN000;
 19401 00002081 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19402 00002083 BA[857F]                	mov	dx,NLSFUNC_PTR
 19403                                  				;AN000; no - set up error message
 19404 00002086 EB38                    	jmp	short cp_error	;AN000; error exit
 19405                                  
 19406                                  ; 21/02/2023
 19407                                  %if 0
 19408                                  	; MSDOS 3.3
 19409                                  	mov	si,81h
 19410                                  	call	SCANOFF
 19411                                  	cmp	al,0Dh ; CR
 19412                                  	jnz	short SETCP
 19413                                  	jmp	short GETCP
 19414                                  
 19415                                  	;nop
 19416                                  SETCP:
 19417                                  	xor	bx,bx
 19418                                  	mov	cx,bx
 19419                                  	mov	ax,bx
 19420                                  GET_CP_DIGIT:
 19421                                  	lodsb
 19422                                  	cmp	al,'0'
 19423                                  	jb	short CHRNOTNUMBER
 19424                                  	cmp	al,'9'
 19425                                  	ja	short CHRNOTNUMBER
 19426                                  	sub	al,'0'
 19427                                  	inc	cl
 19428                                  	cmp	cl,4
 19429                                  	ja	short CHCP_BADPARM
 19430                                  	mov	dx,bx
 19431                                  	shl	dx,1
 19432                                  	shl	dx,1
 19433                                  	add	bx,dx
 19434                                  	shl	bx,1
 19435                                  	add	bx,ax
 19436                                  	jmp	short GET_CP_DIGIT
 19437                                  CP_NEXTCHR:
 19438                                  	lodsb
 19439                                  CHRNOTNUMBER:
 19440                                  	cmp	al,' '		; SPACE
 19441                                  	jz	short CP_NEXTCHR
 19442                                  	cmp	al,9		; TAB
 19443                                  	jz	short CP_NEXTCHR
 19444                                  	cmp	al,0Dh		; CR
 19445                                  	jz	short SET_CP_TBL_NUM
 19446                                  CHCP_BADPARM:
 19447                                  	mov	dx,BADPARMPTR
 19448                                  	jmp	CERROR
 19449                                  ;GOT_NLS:
 19450                                  %endif
 19451                                  	; 21/02/2023
 19452                                  got_NLS:
 19453                                  	; MSDOS 6.0
 19454 00002088 8B1E[0B8C]              	mov	bx,[system_cpage]
 19455                                  				;AN000; get user input code page
 19456                                  ;SET_CP_TBL_NUM:
 19457                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19458                                  	;
 19459                                  	; MSDOS 3.3 & MSDOS 6.0
 19460                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19461                                  	;mov	ah,66h
 19462                                  	;;mov	al,set_global_cp 
 19463                                  	;mov	al,2		;minor - set
 19464                                  	; 26/04/2023
 19465 0000208C B80266                  	mov	ax,6602h
 19466 0000208F CD21                    	int	21h
 19467                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19468                                  		; BX = active code page
 19469                                  		; DX = system code page (active page at boot time)
 19470                                  
 19471 00002091 733F                    	jnc	short chcp_return
 19472                                  				;no error - exit
 19473                                  
 19474 00002093 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19475 00002096 7515                    	jnz	short chcp_other_error
 19476                                  
 19477                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19478 00002098 B459                    	mov	ah,59h
 19479 0000209A 31DB                    	xor	bx,bx
 19480 0000209C CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19481                                  			; BX = version code (0000h for DOS 3.x)
 19482                                  
 19483 0000209E 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19484 000020A1 7505                    	jne	short no_countrysys ; 26/04/2023
 19485                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19486 000020A3 BA[887F]                	mov	dx,INV_CODE_PAGE
 19487                                  	;jmp	cerror
 19488 000020A6 EB18                    	jmp	short cp_error
 19489                                  
 19490                                  	; 21/02/2023
 19491                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19492                                  no_countrysys:
 19493                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19494                                  ;					;AN000; set up extended error msg class
 19495                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19496                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19497                                  					;AN000; get message number in control block
 19498 000020A8 BA[6981]                	mov	dx,NoCntry_Ptr
 19499 000020AB EB13                    	jmp	short cp_error
 19500                                  
 19501                                  chcp_other_error:		; end of p716
 19502                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19503 000020AD B459                    	mov	ah,59h
 19504 000020AF 31DB                    	xor	bx,bx
 19505 000020B1 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19506                                  			; BX = version code (0000h for DOS 3.x)
 19507 000020B3 83F841                  	cmp	ax,65		;was it access denied?
 19508 000020B6 7505                    	jne	short none_set	;no - assume all failed
 19509 000020B8 BA[697F]                	mov	dx,cp_not_all_ptr
 19510                                  				;set up message
 19511                                  	;jmp	cerror		;AC000; error exit
 19512 000020BB EB03                    	jmp     short cp_error
 19513                                  none_set:
 19514 000020BD BA[5B7F]                	mov	dx,cp_not_set_ptr
 19515                                  				;set up message
 19516                                  cp_error:
 19517 000020C0 E98D08                  	jmp	cerror		;exit
 19518                                  getcp:
 19519                                  	;;mov	ah,GETSETCDPG ; 66h
 19520                                  	;mov	ah,66h		;get/set global code page function	
 19521                                  	;;mov	al,get_global_cp ; 1
 19522                                  	;mov	al,1		;minor - get
 19523                                  	; 26/04/2023
 19524 000020C3 B80166                  	mov	ax,6601h
 19525 000020C6 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19526 000020C8 891E[0B8C]              	mov	[system_cpage],bx
 19527                                  				;get active cp for output
 19528 000020CC BA[777F]                	mov	dx,cp_active_ptr
 19529 000020CF E8FF2C                  	call	std_printf	;print it out
 19530                                  chcp_return:
 19531 000020D2 C3                      	retn
 19532                                  
 19533                                  ; ---------------------------------------------------------------------------
 19534                                  
 19535                                  ; ****************************************************************
 19536                                  ; *
 19537                                  ; * ROUTINE:	 TRUENAME
 19538                                  ; *
 19539                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19540                                  ; *		 Parses the command line. If a path is found, set
 19541                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19542                                  ; *		 set SRCXNAME to the drive letter. If no path
 19543                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19544                                  ; *		 current directory. Use the NAME TRANSLATE system
 19545                                  ; *		 call to get the real name and  then display the 
 19546                                  ; *		 real name. If an error occurs issue an error
 19547                                  ; *		 message and transfer control to  CERROR.
 19548                                  ; *
 19549                                  ; * INPUT:	 command line at offset 81H
 19550                                  ; *
 19551                                  ; * OUTPUT:	 none
 19552                                  ; *
 19553                                  ; ****************************************************************
 19554                                  
 19555                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19556                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19557                                  	; 10/06/2023
 19558                                  TRUENAME:				;AN000; TRUENAME entry point
 19559 000020D3 1E                      	push	ds			;AN000; Get local ES
 19560 000020D4 07                      	pop	es			;AN000;
 19561 000020D5 BE8100                  	mov	si,81h			;AN000; Get command line
 19562 000020D8 BF[F084]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19563 000020DB 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19564 000020DD 31D2                    	xor	dx,dx			;AN000;
 19565 000020DF E8D500                  	call	Parse_With_Msg		;AC018; call parser
 19566                                  
 19567 000020E2 BF[D387]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19568                                  	;cmp	ax,0FFFFh
 19569                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19570                                  	;je	short tn_eol		;AN000; yes - go process
 19571                                  	;; 22/02/2023
 19572                                  	;;cmp	ax,0
 19573                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19574                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 19575                                  	;and	ax,ax ; ax = 0 ?
 19576                                  	;jnz	short tn_parse_error ; no, parse error
 19577                                  	; 10/06/2023
 19578 000020E5 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 19579 000020E6 7433                    	jz	short tn_eol ; ah = 0 ; *
 19580 000020E8 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 19581 000020E9 752D                    	jnz	short tn_parse_error
 19582                                  
 19583                                  	;cmp	byte [PARSE1_TYPE],6
 19584 000020EB 803E[4F95]06            	cmp	byte [PARSE1_TYPE],result_drive
 19585                                  					;AN000; was a drive entered?
 19586                                  	;je	short tn_drive		;AN000; yes - go process
 19587                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19588                                  	; 23/02/2023
 19589 000020F0 7512                    	jne	short tn_filespec
 19590                                  
 19591                                  ;tn_eol: 
 19592                                  ;	;mov	ah,0			;AN000; no parameters on line
 19593                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19594                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19595                                  ;	mov	al,'.'
 19596                                  ;	stosw				;AN000; store in srcxname
 19597                                  ;	jmp	short tn_doit		;AN000; go do command
 19598                                  
 19599                                  tn_drive:				;AN000; a drive was entered
 19600 000020F2 56                      	push	si			;AN000; save position in line
 19601 000020F3 BE[5395]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19602 000020F6 AC                      	lodsb				;AN000; get the drive number
 19603 000020F7 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19604 000020F9 AA                      	stosb				;AN000; store it in srcxname
 19605                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19606 000020FA B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19607 000020FD AB                      	stosw				;AN000;  store in srcxname
 19608                                  	;mov	al,0
 19609 000020FE B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19610 00002100 AA                      	stosb				;AN000;
 19611 00002101 5E                      	pop	si			;AN000; get line position back
 19612 00002102 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19613                                  
 19614                                  tn_filespec:				;AN000; a filespec was entered
 19615 00002104 56                      	push	si			;AN000; save position in line
 19616 00002105 C536[5395]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19617                                  
 19618                                  tn_move_filename:			;AN000; put filespec in srcxname
 19619 00002109 AC                      	lodsb				;AN000; get a char from buffer
 19620 0000210A AA                      	stosb				;AN000; store in srcxname
 19621                                  	;;cmp	al,0
 19622                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19623 0000210B 08C0                    	or	al,al ; al = 0 ?
 19624 0000210D 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19625 0000210F 5E                      	pop	si			;AN000; get line position back
 19626                                  
 19627                                  tn_check_eol:				;AN000; make sure no extra parms
 19628 00002110 BF[F084]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19629 00002113 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19630 00002116 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 19631                                  tn_parse_error: 			;AN000; A parse error occurred
 19632 00002118 E93508                  	jmp	cerror			;AN000; Go to error routine
 19633                                  
 19634                                  tn_eol: 
 19635                                  	;23/02/2023
 19636                                  	;;mov	ah,0			;AN000; no parameters on line
 19637                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19638                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19639                                  	;mov	al,'.'
 19640                                  	; 10/06/2023
 19641                                  	;mov	ax,002Eh
 19642                                  	; ah = 0 ; *
 19643 0000211B B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 19644                                  	;
 19645 0000211D AB                      	stosw				;AN000; store in srcxname
 19646                                  	; 23/02/2023
 19647                                  	;jmp	short tn_doit		;AN000; go do command
 19648                                  
 19649                                  tn_doit:				;AN000;
 19650 0000211E BE[D387]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19651 00002121 BF[0489]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19652                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19653 00002124 B460                    	mov	ah,60h
 19654 00002126 CD21                    	int	21h			;AN000;
 19655 00002128 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19656                                  
 19657 0000212A E8B3FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19658 0000212D C706[118C][D387]        	mov	word [string_ptr_2],SRCXNAME
 19659                                  					;AN000; get address of failed string
 19660                                  	;mov	byte [extend_buf_sub],1
 19661 00002133 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 19662                                  					;AN000; put number of subst in control block
 19663 00002138 E91508                  	jmp	cerror			;AN000; Go to error routine
 19664                                  
 19665                                  tn_print_xname: 			;AN000;
 19666 0000213B C706[118C][0489]        	mov	word [string_ptr_2],COMBUF
 19667                                  					;AN000; Set up address of combuf
 19668 00002141 BA[C380]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19669 00002144 E88804                  	call	CRLF2			;AN000; print a crlf
 19670                                  	;call	Printf_Crlf		;AN000; print it out
 19671                                  	;retn				;AN000;
 19672                                  	; 23/02/2023
 19673 00002147 E9792C                  	jmp	Printf_Crlf
 19674                                  
 19675                                  ; ---------------------------------------------------------------------------
 19676                                  
 19677                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19678                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19679                                  _$EXIT:
 19680                                  	; MSDOS 6.0
 19681 0000214A 1E                      	push	ds			;AN000; save data segment
 19682 0000214B 8E1E[A58A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19683                                  	;assume	ds:resgroup		;AN000;
 19684                                  
 19685 0000214F 803E[8D01]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19686 00002154 740A                    	jz	short free_com		;AN045; no - free everything
 19687                                  
 19688                                  ;	We're a permanent command.
 19689                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19690                                  
 19691 00002156 833E[8E01]FF            	cmp	word [SingleCom],-1	;M034
 19692 0000215B 7412                    	je	short no_reset		;M034 ; exit singlecom
 19693 0000215D E9A4DF                  	jmp	TCOMMAND		;permanent command, recycle
 19694                                  
 19695                                  free_com:
 19696                                  	;mov	ax,(multdos shl 8 or message_2f)
 19697 00002160 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19698                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19699 00002163 B205                    	mov	dl,5
 19700 00002165 8B3E[A301]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19701 00002169 8E06[A501]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19702 0000216D CD2F                    	int	2Fh			;AN000; go set it
 19703                                  no_reset:				;AN045;
 19704 0000216F 1F                      	pop	ds			;AN000; restore local data segment
 19705                                  	;assume	ds:trangroup		;AN000;
 19706                                  ;M040
 19707                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19708                                  ;this, restores user dir if flag is set and resets the flag.
 19709                                  
 19710                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19711 00002170 E80C03                  	call	RestUDir1
 19712 00002173 8E06[A58A]              	mov	es,[RESSEG]
 19713                                  	;assume	es:resgroup
 19714                                  
 19715 00002177 26A1[2901]              	mov	ax,[es:Parent]
 19716                                  	;mov	[es:16h],ax
 19717                                  	;mov	[es:PDB_Parent_PID],ax
 19718 0000217B 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19719 0000217F 26A1[2B01]              	mov	ax,[es:OldTerm]
 19720                                  	;mov	[es:0Ah],ax
 19721                                  	;mov	[es:PDB_Exit],ax
 19722 00002183 26A30A00                	mov	[es:PDB.EXIT],ax
 19723 00002187 26A1[2D01]              	mov	ax,[es:OldTerm+2]
 19724                                  	;mov	[es:0Ch],ax
 19725                                  	;mov	[es:PDB_Exit+2],ax
 19726 0000218B 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19727                                  
 19728 0000218F 06                      	push	es
 19729 00002190 8E06[B38A]              	mov	es,[TRAN_TPA]
 19730                                  	;mov	ah,DEALLOC
 19731 00002194 B449                    	mov	ah,49h
 19732 00002196 CD21                    	int	21h			; Now running in "free" space
 19733 00002198 07                      	pop	es
 19734                                  
 19735                                  	;mov	ah,Exit
 19736 00002199 B44C                    	mov	ah,4Ch
 19737                                  	;mov	al,byte ptr RetCode
 19738 0000219B 26A0[8501]              	mov	al,[es:RetCode]
 19739 0000219F CD21                    	int	21h
 19740                                  
 19741                                  	;..........
 19742                                  
 19743                                  ; 23/02/2023
 19744                                  %if 0
 19745                                  _$EXIT:
 19746                                  	; MSDOS 3.3
 19747                                  	mov	es,[RESSEG]
 19748                                  	mov	ax,[es:PARENT]
 19749                                  	;mov	[es:16h],ax
 19750                                  	mov	[es:PDB.PARENT_PID],ax
 19751                                  	mov	ax,[es:OLDTERM]
 19752                                  	;mov	[es:0Ah],ax
 19753                                  	mov	[es:PDB.EXIT],ax
 19754                                  	mov	ax,[es:OLDTERM+2]
 19755                                  	;mov	[es:0Ch],ax
 19756                                  	mov	[es:PDB.EXIT+2],ax
 19757                                  	push	es
 19758                                  	mov	es,[TRAN_TPA]
 19759                                  	mov	ah,DEALLOC ; 49h
 19760                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19761                                  			; ES = segment address of area to be freed
 19762                                  	pop	es
 19763                                  	mov	ah,EXIT ; 4Ch
 19764                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19765                                  	mov	al,byte [es:RETCODE]
 19766                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19767                                  ;;here:
 19768                                  ;;	jmp	short here
 19769                                  %endif
 19770                                  
 19771                                  ; ---------------------------------------------------------------------------
 19772                                  
 19773                                  ; MSDOS 6.0
 19774                                  ; ****************************************************************
 19775                                  ; *
 19776                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19777                                  ; *
 19778                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19779                                  ; *		 If not end of line, set up to print parse
 19780                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19781                                  ; *		 EXPECTED!
 19782                                  ; *
 19783                                  ; * INPUT:	 DS:SI	  last output from parser
 19784                                  ; *		 ES:DI	  points to parse block
 19785                                  ; *		 CX	  last output from parser
 19786                                  ; *
 19787                                  ; * OUTPUT:	 AX	  parser return code
 19788                                  ; *
 19789                                  ; *		 if end of line found
 19790                                  ; *		     zero flag set
 19791                                  ; *		 else
 19792                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19793                                  ; *
 19794                                  ; ****************************************************************
 19795                                  
 19796                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19797                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19798                                  
 19799                                  parse_check_eol:
 19800 000021A1 31D2                    	xor	dx,dx			;AN000;
 19801 000021A3 8936[098C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19802 000021A7 E87121                  	call	cmd_parse		;AN000; call parser
 19803 000021AA 3CFF                    	cmp	al,-1 ; 0FFh
 19804                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19805 000021AC 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19806                                  	;cmp	ax,0
 19807                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19808 000021AE 21C0                    	and	ax,ax ; ax = 0 ?
 19809 000021B0 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19810 000021B2 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19811                                  ok_to_setup_pmsg:
 19812 000021B3 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19813                                  parse_good_eol:
 19814                                  parse_msg_good:	; 23/02/2023
 19815 000021B6 C3                      	retn				;AN000;
 19816                                  
 19817                                  ; ---------------------------------------------------------------------------
 19818                                  
 19819                                  ; MSDOS 6.0
 19820                                  ; ****************************************************************
 19821                                  ; *
 19822                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19823                                  ; *
 19824                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19825                                  ; *		 message is set up.
 19826                                  ; *
 19827                                  ; * INPUT:	 DS:SI	  last output from parser
 19828                                  ; *		 ES:DI	  points to parse block
 19829                                  ; *		 CX	  last output from parser
 19830                                  ; *
 19831                                  ; * OUTPUT:	 AX	  parser return code
 19832                                  ; *
 19833                                  ; *		 if no error
 19834                                  ; *		     outputs from parser
 19835                                  ; *		 else
 19836                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19837                                  ; *		     error message set up for STD_PRINTF
 19838                                  ; *
 19839                                  ; ****************************************************************
 19840                                  
 19841                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19842                                  Parse_With_Msg:
 19843 000021B7 8936[098C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19844 000021BB E85D21                  	call	cmd_parse		;AN018; call parser
 19845 000021BE 3CFF                    	cmp	al,-1 ; 0FFh
 19846                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19847 000021C0 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19848                                  	;cmp	ax,0
 19849                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19850 000021C2 09C0                    	or	ax,ax ; ax = 0 ?
 19851 000021C4 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19852                                  	; 23/02/2023
 19853                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19854                                  ;parse_msg_good:
 19855                                  	;retn				;AN018;
 19856                                  	; 23/02/2023
 19857                                  	;jmp	short setup_parse_error_msg	
 19858                                  
 19859                                  ; ---------------------------------------------------------------------------
 19860                                  
 19861                                  ; MSDOS 6.0
 19862                                  ; ****************************************************************
 19863                                  ; *
 19864                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19865                                  ; *
 19866                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19867                                  ; *		 message is set up.
 19868                                  ; *
 19869                                  ; * INPUT:	 AX	     Parse error number
 19870                                  ; *		 SI	     Set to past last parameter
 19871                                  ; *		 Parse_last  Set to start of last parameter
 19872                                  ; *
 19873                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19874                                  ; *		 error message set up for STD_PRINTF
 19875                                  ; *
 19876                                  ; ****************************************************************
 19877                                  
 19878                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19879                                  setup_parse_error_msg:
 19880 000021C6 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 19881                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19882 000021CB BA[FC7E]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19883 000021CE C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19884                                  					;AC018; terminate the parameter string
 19885 000021D1 A3[FC7E]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19886 000021D4 83F802                  	cmp	ax,2
 19887                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19888 000021D7 740D                    	je	short setup_parse_msg_ret
 19889                                  					;AN018;    no subst
 19890 000021D9 8B36[098C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19891 000021DD 8936[118C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19892 000021E1 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 19893                                  					;AC018; put number of subst in control block
 19894                                  	;mov	byte [extend_buf_sub],1
 19895                                  setup_parse_msg_ret:
 19896 000021E6 46                      	inc	si			;AN018; make sure zero flag not set
 19897 000021E7 C3                      	retn				;AC018;
 19898                                  
 19899                                  ;============================================================================
 19900                                  ; TENV.ASM, MSDOS 6.0, 1991
 19901                                  ;============================================================================
 19902                                  ; 08/10/2018 - Retro DOS v3.0
 19903                                  
 19904                                  ; TITLE	Part6 COMMAND Transient routines.
 19905                                  
 19906                                  ;	Environment utilities and misc. routines
 19907                                  
 19908                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19909                                  
 19910                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19911                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19912                                  
 19913                                  ; ---------------------------------------------------------------------------
 19914                                  
 19915                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19916                                  ADD_PROMPT:
 19917 000021E8 E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19918 000021EB E8AD01                  	call	scan_double_null
 19919                                  
 19920                                  ADD_PROMPT2:
 19921 000021EE 56                      	push	si
 19922 000021EF E89B01                  	call	GETARG
 19923 000021F2 5E                      	pop	si
 19924 000021F3 7501                    	jnz	short ADD_PROMPT3
 19925                                  ADD_PROMPT_RETN:
 19926 000021F5 C3                      	retn
 19927                                  ADD_PROMPT3:			; Pre scan for arguments
 19928 000021F6 E87501                  	call	move_name	; Move in name
 19929 000021F9 E89101                  	call	GETARG
 19930 000021FC 56                      	push	si
 19931 000021FD EB53                    	jmp	short ADD_NAME
 19932                                  
 19933                                  ;break	The SET command
 19934                                  
 19935                                  ; Input: DS:SI points to a CR terminated string
 19936                                  ; Output: carry flag is set if no room
 19937                                  ;	  otherwise name is added to environment
 19938                                  
 19939                                  DISP_ENVJ:
 19940 000021FF E9BC00                  	jmp	DISP_ENV
 19941                                  
 19942                                  ADD_NAME_TO_ENVIRONMENT:
 19943 00002202 E88801                  	call	GETARG
 19944 00002205 74F8                    	jz	short DISP_ENVJ
 19945                                  
 19946                                  ; check if line contains exactly one equals sign
 19947                                  
 19948 00002207 31DB                    	xor	bx,bx		; = count is 0
 19949 00002209 56                      	push	si		; Save pointer to beginning of line
 19950                                  EQLP:
 19951 0000220A AC                      	lodsb			; Get a char
 19952 0000220B 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19953 0000220D 740F                    	je	short QUEQ	
 19954 0000220F 3C3D                    	cmp	al,'='		; Look for = sign	
 19955 00002211 75F7                    	jne	short EQLP	; not there, get next char
 19956 00002213 FEC3                    	inc	bl		; Otherwise increment EQ count
 19957 00002215 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19958 00002218 75F0                    	jne	short EQLP
 19959 0000221A FEC7                    	inc	bh		; Set BH=1 means no parameters
 19960 0000221C EBEC                    	jmp	short EQLP	; And look for more
 19961                                  QUEQ:
 19962 0000221E 5E                      	pop	si		; Restore beginning of line
 19963 0000221F FECB                    	dec	bl		; Zero flag means only one EQ
 19964 00002221 7406                    	jz	short ONEQ	; Good line
 19965 00002223 BA[947F]                	mov	dx,SYNTMES_PTR
 19966 00002226 E92707                  	jmp	cerror
 19967                                  ONEQ:
 19968 00002229 53                      	push	bx
 19969 0000222A E8BD00                  	call	delete_name_in_environment
 19970 0000222D 5B                      	pop	bx
 19971 0000222E FECF                    	dec	bh
 19972 00002230 74C3                    	jz	short ADD_PROMPT_RETN
 19973 00002232 E86601                  	call	scan_double_null
 19974 00002235 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19975 00002237 E83401                  	call	move_name
 19976 0000223A 56                      	push	si
 19977 0000223B 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19978                                  				;  env var name
 19979                                  		
 19980                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19981                                  ; necessary in the resident for re-reading the transient. Let's look for
 19982                                  ; COMSPEC=
 19983                                  
 19984 0000223D C606[4284]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19985 00002242 BE[7881]                	mov	si,COMSPECSTR ; "COMSPEC="
 19986 00002245 B90400                  	mov	cx,4
 19987 00002248 F3A7                    	repe	cmpsw
 19988 0000224A 7504                    	jnz	short NOT_COMSPEC
 19989                                  				; Zero set => exact match
 19990 0000224C FE06[4284]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19991                                  	;mov	byte [COMSPEC_FLAG],1
 19992                                  NOT_COMSPEC:
 19993 00002250 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19994                                  ADD_NAME:
 19995 00002252 5E                      	pop	si		; Add the value of the new env var
 19996 00002253 56                      	push	si		;  to the environment.
 19997                                  ADD_NAME1:
 19998 00002254 AC                      	lodsb
 19999 00002255 3C0D                    	cmp	al,13 ; 0Dh
 20000 00002257 7405                    	je	short ADD_NAME_RET
 20001 00002259 E8AD01                  	call	store_char
 20002 0000225C EBF6                    	jmp	short ADD_NAME1
 20003                                  ADD_NAME_RET:
 20004 0000225E 5E                      	pop	si
 20005 0000225F 803E[4284]00            	cmp	byte [comspec_flag],0
 20006                                  				; If the new env var is comspec,	
 20007                                  ADD_NAME_JZ_RET:
 20008 00002264 748F                    	jz	short ADD_PROMPT_RETN 
 20009                                  				;  copy the value into the
 20010                                  				;  comspec var in the resident
 20011                                  
 20012                                  ; We have changed the COMSPEC variable. We need to update the resident
 20013                                  ; pieces necessary to reread in the info. First, skip all delimiters
 20014                                  
 20015 00002266 E87303                  	call	scanoff
 20016 00002269 8E06[A58A]              	mov	es,[RESSEG]	;  comspec var in the resident
 20017                                  
 20018                                  ; Make sure that the printer knows where the beginning of the string is
 20019                                  
 20020 0000226D BF[3601]                	mov	di,ComSpec
 20021 00002270 89FB                    	mov	bx,di
 20022                                  
 20023                                  ; Generate drive letter for display
 20024                                  
 20025 00002272 31C0                    	xor	ax,ax		;g assume no drive first
 20026 00002274 26A2[7F01]              	mov	[es:ComDrv],al
 20027                                  	; 23/02/2023
 20028                                  	; MSDOS 6.0 (& 5.0)
 20029 00002278 50                      	push	ax		;AN000; 3/3/KK
 20030 00002279 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 20031 0000227B E83F01                  	call	testkanj	;AN000; 3/3/KK	
 20032 0000227E 58                      	pop	ax		;AN000; 3/3/KK
 20033 0000227F 7518                    	jnz	short _GOTDRIVE
 20034                                  	;
 20035 00002281 807C013A                	cmp	byte [si+1],':'	; drive specified?
 20036 00002285 7512                    	jne	short _GOTDRIVE
 20037 00002287 8A04                    	mov	al,[si]		; get his specified drive
 20038                                  	; 23/02/2023
 20039 00002289 E85B01                  	call	UPCONV
 20040                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 20041 0000228C 2C41                    	sub	al,'A'		; convert to 0-based
 20042 0000228E 83C702                  	add	di,2
 20043 00002291 FEC0                    	inc	al		; convert to 1-based number
 20044 00002293 26A2[7F01]              	mov	[es:ComDrv],al
 20045                                  
 20046                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 20047                                  ; done here..
 20048                                  	;add	al,40h
 20049 00002297 0440                    	add	al,'A'-1
 20050                                  _GOTDRIVE:
 20051                                  	; 23/02/2023
 20052                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 20053                                  	;mov	[es:PUTBACKSUBSTPTR],di
 20054                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 20055 00002299 26893E[1501]            	mov	[es:PutBackComSpec],di
 20056                                  				;g point to beginning of name after drive
 20057                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 20058                                  	;mov	[es:PUTBACKDRV],al
 20059                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 20060 0000229E 26A2[1A01]              	mov	[es:PutBackDrv],al
 20061                                  
 20062                                  ; Copy chars until delim      	
 20063                                  
 20064 000022A2 89DF                    	mov	di,bx
 20065                                  COPY_COMSPEC:
 20066 000022A4 AC                      	lodsb
 20067 000022A5 E83C03                  	call	DELIM
 20068 000022A8 7407                    	jz	short COPYDONE
 20069 000022AA 3C0D                    	cmp	al,13 ; 0Dh
 20070 000022AC 7403                    	je	short COPYDONE
 20071 000022AE AA                      	stosb
 20072 000022AF EBF3                    	jmp	short COPY_COMSPEC
 20073                                  COPYDONE:
 20074 000022B1 30C0                    	xor	al,al		; Null terminate the string and quit
 20075 000022B3 AA                      	stosb
 20076                                  	;mov	byte [comspec_flag],0
 20077 000022B4 A2[4284]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 20078 000022B7 4F                      	dec	di
 20079 000022B8 26893E[7601]            	mov	[es:ComSpec_End],di
 20080 000022BD C3                      	retn
 20081                                  
 20082                                  DISP_ENV:
 20083 000022BE 8E1E[A58A]              	mov	ds,[RESSEG]
 20084 000022C2 8E1E[2703]              	mov	ds,[EnvirSeg]
 20085                                  	; assume ds:nothing
 20086 000022C6 31F6                    	xor	si,si
 20087                                  PENVLP:
 20088 000022C8 803C00                  	cmp	byte [si],0
 20089 000022CB 7497                    	jz	short ADD_NAME_JZ_RET
 20090 000022CD BF[F692]                	mov	di,Arg_Buf
 20091                                  PENVLP2:
 20092 000022D0 AC                      	lodsb
 20093 000022D1 AA                      	stosb
 20094 000022D2 08C0                    	or	al,al
 20095 000022D4 75FA                    	jnz	short PENVLP2
 20096 000022D6 BA[9980]                	mov	dx,arg_buf_ptr
 20097 000022D9 1E                      	push	ds
 20098 000022DA 06                      	push	es
 20099 000022DB 1F                      	pop	ds
 20100                                  	; assume ds:nothing
 20101 000022DC E8E42A                  	call	Printf_Crlf
 20102 000022DF 1F                      	pop	ds
 20103 000022E0 EBE6                    	jmp	short PENVLP
 20104                                  
 20105                                  ; =============== S U B	R O U T	I N E =======================================
 20106                                  
 20107                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20108                                  delete_path:
 20109 000022E2 BE[6C81]                	mov	si,PATH_TEXT ; "PATH="
 20110 000022E5 EB03                    	jmp	short delete_name_in_environment
 20111                                  
 20112                                  ; =============== S U B	R O U T	I N E =======================================
 20113                                  
 20114                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20115                                  delete_prompt:
 20116 000022E7 BE[7181]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20117                                  
 20118                                  ; ---------------------------------------------------------------------------
 20119                                  
 20120                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20121                                  delete_name_in_environment:
 20122                                  
 20123                                  ; Input: DS:SI points to a "=" terminated string
 20124                                  ; Output: carry flag is set if name not found
 20125                                  ;	  otherwise name is deleted
 20126                                  
 20127 000022EA 56                      	push	si
 20128 000022EB 1E                      	push	ds
 20129 000022EC E82C00                  	call	FIND		; ES:DI points to name
 20130 000022EF 7217                    	jc	short del1
 20131 000022F1 89FE                    	mov	si,di		; Save it
 20132 000022F3 E8BF00                  	call	SCASB2		; Scan for the nul
 20133 000022F6 87F7                    	xchg	si,di
 20134                                  ;SR;
 20135                                  ; If we have only one env string, then the double null is lost when the last
 20136                                  ;string is deleted and we have an invalid empty environment with only a 
 20137                                  ;single null. To avoid this, we will look for the double null case and then
 20138                                  ;move an extra null char.
 20139                                  ; Bugbug: The only possible problem is that the last pathstring 
 20140                                  ;will be followed by a triple null. Is this really a problem?
 20141                                  
 20142                                  	; MSDOS 6.0
 20143 000022F8 26803C00                	cmp	byte [es:si],0	;null char?
 20144 000022FC 7501                    	jnz	short not_dnull	;no, we are at a double null
 20145 000022FE 4E                      	dec	si		;point at the double null
 20146                                  not_dnull:
 20147                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20148 000022FF E86901                  	call	GETENVSIZ
 20149 00002302 29F1                    	sub	cx,si
 20150 00002304 06                      	push	es
 20151 00002305 1F                      	pop	ds		; ES:DI points to name
 20152                                  				; DS:SI points to next name
 20153 00002306 F3A4                    	rep	movsb
 20154                                  del1:
 20155 00002308 1F                      	pop	ds
 20156 00002309 5E                      	pop	si
 20157                                  find_retn:
 20158 0000230A C3                      	retn
 20159                                  
 20160                                  ; =============== S U B	R O U T	I N E =======================================
 20161                                  
 20162                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20163                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 20164                                  find_path:
 20165 0000230B BE[6C81]                	mov	si,PATH_TEXT ; "PATH="
 20166 0000230E EB03                    	jmp	short find_name_in_environment
 20167                                  
 20168                                  ; =============== S U B	R O U T	I N E =======================================
 20169                                  
 20170                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20171                                  find_prompt:
 20172 00002310 BE[7181]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20173                                  
 20174                                  ; ---------------------------------------------------------------------------
 20175                                  
 20176                                  find_name_in_environment:
 20177                                  
 20178                                  ; Input: DS:SI points to a "=" terminated string
 20179                                  ; Output: ES:DI points to the arguments in the environment
 20180                                  ;	  zero is set if name not found
 20181                                  ;	  carry flag is set if name not valid format
 20182                                  
 20183 00002313 E80500                  	call	FIND		; Find the name
 20184 00002316 72F2                    	jc	short find_retn	; Carry means not found	
 20185 00002318 E99600                  	jmp	SCASB1		; Scan for = sign
 20186                                  
 20187                                  ; ---------------------------------------------------------------------------
 20188                                  	;nop
 20189                                  
 20190                                  ; =============== S U B	R O U T	I N E =======================================
 20191                                  
 20192                                  ; On return of FIND1, ES:DI points to beginning of name
 20193                                  
 20194                                  FIND:
 20195 0000231B FC                      	cld
 20196 0000231C E84100                  	call	COUNT0		; CX = Length of name
 20197 0000231F 8E06[A58A]              	mov	es,[RESSEG]
 20198                                  	;assume es:RESGROUP
 20199 00002323 268E06[2703]            	mov	es,[es:EnvirSeg]
 20200                                  	;assume es:NOTHING
 20201 00002328 31FF                    	xor	di,di
 20202                                  find1:	
 20203 0000232A 51                      	push	cx
 20204 0000232B 56                      	push	si
 20205 0000232C 57                      	push	di
 20206                                  find11:
 20207 0000232D AC                      	lodsb
 20208                                  	; 23/02/2023 
 20209                                  	; MSDOS 6.0 (& 5.0)
 20210 0000232E E88C00                  	call	testkanj	
 20211 00002331 740F                    	jz	short notkanj3
 20212 00002333 4E                      	dec	si
 20213 00002334 AD                      	lodsw
 20214 00002335 47                      	inc	di
 20215 00002336 47                      	inc	di
 20216 00002337 263B45FE                	cmp	ax,[es:di-2]
 20217 0000233B 7511                    	jne	short find12
 20218 0000233D 49                      	dec	cx
 20219 0000233E E2ED                    	loop	find11
 20220 00002340 EB0C                    	jmp	short find12
 20221                                  notkanj3:
 20222 00002342 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 20223                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 20224 00002345 47                      	inc	di
 20225 00002346 263A45FF                	cmp	al,[es:di-1]
 20226 0000234A 7502                    	jne	short find12
 20227 0000234C E2DF                    	loop	find11
 20228                                  find12:
 20229 0000234E 5F                      	pop	di
 20230 0000234F 5E                      	pop	si
 20231 00002350 59                      	pop	cx
 20232 00002351 74B7                    	jz	short find_retn
 20233 00002353 51                      	push	cx
 20234 00002354 E85E00                  	call	SCASB2		; Scan for a nul
 20235 00002357 59                      	pop	cx
 20236 00002358 26803D00                	cmp	byte [es:di],0
 20237 0000235C 75CC                    	jnz	short find1
 20238 0000235E F9                      	stc			; Indicate not found
 20239 0000235F C3                      	retn
 20240                                  
 20241                                  ; =============== S U B	R O U T	I N E =======================================
 20242                                  
 20243                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20244                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 20245                                  COUNT0:
 20246 00002360 1E                      	push	ds
 20247 00002361 07                      	pop	es
 20248                                  	;assume es:nothing
 20249 00002362 89F7                    	mov	di,si
 20250                                  ;COUNT1:
 20251 00002364 57                      	push	di		; Count number of chars until "="
 20252 00002365 E84900                  	call	SCASB1
 20253                                  	; 23/02/2023
 20254                                  ;	jmp	short COUNTX
 20255                                  ;COUNT2:
 20256                                  ;	push	di		; Count number of chars until nul
 20257                                  ;	call	SCASB2
 20258                                  ;COUNTX:
 20259 00002368 59                      	pop	cx
 20260 00002369 29CF                    	sub	di,cx
 20261 0000236B 87F9                    	xchg	di,cx
 20262                                  move_name_retn:
 20263 0000236D C3                      	retn
 20264                                  
 20265                                  ; =============== S U B	R O U T	I N E =======================================
 20266                                  
 20267                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20268                                  move_name:
 20269 0000236E 803C0D                  	cmp	byte [si],13 ; 0Dh
 20270 00002371 74FA                    	je	short move_name_retn
 20271 00002373 AC                      	lodsb
 20272                                  	; 23/02/2023 
 20273                                  	; MSDOS 6.0 (& 5.0)
 20274 00002374 E84600                  	call	testkanj		
 20275 00002377 7409                    	jz	short notkanj1
 20276 00002379 E88D00                  	call	store_char
 20277 0000237C AC                      	lodsb
 20278 0000237D E88900                  	call	store_char
 20279 00002380 EBEC                    	jmp	short move_name
 20280                                  notkanj1: 
 20281 00002382 E86200                  	call	UPCONV
 20282                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 20283 00002385 E88100                  	call	store_char
 20284 00002388 3C3D                    	cmp	al,'='
 20285 0000238A 75E2                    	jne	short move_name
 20286                                  getarg_retn:
 20287 0000238C C3                      	retn
 20288                                  
 20289                                  ; =============== S U B	R O U T	I N E =======================================
 20290                                  
 20291                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20292                                  GETARG:
 20293 0000238D BE8000                  	mov	si,80h
 20294 00002390 AC                      	lodsb
 20295 00002391 08C0                    	or	al,al
 20296 00002393 74F7                    	jz	short getarg_retn
 20297 00002395 E84402                  	call	scanoff
 20298 00002398 3C0D                    	cmp	al,13 ; 0Dh
 20299                                  sdn_retn:
 20300 0000239A C3                      	retn
 20301                                  
 20302                                  ; =============== S U B	R O U T	I N E =======================================
 20303                                  
 20304                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 20305                                  ; there is NO double NULL, merely a string that is empty.
 20306                                  
 20307                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20308                                  scan_double_null:
 20309 0000239B 8E06[A58A]              	mov	es,[RESSEG]
 20310 0000239F 268E06[2703]            	mov	es,[es:EnvirSeg]
 20311 000023A4 31FF                    	xor	di,di
 20312                                  
 20313                                  ; Top cycle-point. If the string here is empty, then we are done
 20314                                  
 20315                                  sdn1:
 20316 000023A6 26803D00                	cmp	byte [es:di],0	; nul string?
 20317 000023AA 74EE                    	jz	short sdn_retn	; yep, all done
 20318 000023AC E80600                  	call	SCASB2
 20319 000023AF EBF5                    	jmp	short sdn1
 20320                                  
 20321                                  ; =============== S U B	R O U T	I N E =======================================
 20322                                  
 20323                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20324                                  SCASB1:
 20325 000023B1 B03D                    	mov	al,'='		; Scan for an =
 20326 000023B3 EB02                    	jmp	short SCASBX
 20327                                  
 20328                                  ; =============== S U B	R O U T	I N E =======================================
 20329                                  
 20330                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20331                                  SCASB2:
 20332 000023B5 30C0                    	xor	al,al		; Scan for a nul
 20333                                  
 20334                                  ; ---------------------------------------------------------------------------
 20335                                  
 20336                                  	; 23/02/2023
 20337                                  SCASBX:
 20338 000023B7 B90001                  	mov	cx,256
 20339 000023BA F2AE                    	repne	scasb
 20340 000023BC C3                      	retn
 20341                                  
 20342                                  ; =============== S U B	R O U T	I N E =======================================
 20343                                  
 20344                                  ; MSDOS 6.0
 20345                                  
 20346                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 20347                                  
 20348                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20349                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 20350                                  testkanj:
 20351 000023BD 1E                      	push	ds			;AN000;  3/3/KK
 20352 000023BE 56                      	push	si			;AN000;  3/3/KK
 20353 000023BF 50                      	push	ax			;AN000;  3/3/KK
 20354 000023C0 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20355 000023C5 C536[A701]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20356                                  ktlop:					;AN000;  3/3/KK
 20357 000023C9 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20358 000023CC 740E                    	je	short notlead 		;AN000;  3/3/KK
 20359 000023CE 58                      	pop	ax			;AN000;  3/3/KK
 20360 000023CF 50                      	push	ax			;AN000;  3/3/KK
 20361 000023D0 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20362 000023D2 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20363 000023D4 46                      	inc	si			;AN000;  3/3/KK
 20364 000023D5 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20365 000023D7 7607                    	jbe	short islead		;AN000;  3/3/KK
 20366 000023D9 46                      	inc	si			;AN000;  3/3/KK
 20367 000023DA EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20368                                  notlead:				;AN000;  3/3/KK
 20369 000023DC 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20370 000023DE EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20371                                  islead: 				;AN000;  3/3/KK
 20372 000023E0 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20373 000023E2 40                      	inc	ax			;AN000;  3/3/KK
 20374                                  ktret:					;AN000;  3/3/KK
 20375 000023E3 58                      	pop	ax			;AN000;  3/3/KK
 20376 000023E4 5E                      	pop	si			;AN000;  3/3/KK
 20377 000023E5 1F                      	pop	ds			;AN000;  3/3/KK
 20378 000023E6 C3                      	retn				;AN000;  3/3/KK
 20379                                  
 20380                                  ; =============== S U B	R O U T	I N E =======================================
 20381                                  
 20382                                  ; MSDOS 6.0
 20383                                  
 20384                                  ; ****************************************************************
 20385                                  ; *
 20386                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20387                                  ; *
 20388                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20389                                  ; *		 the character in AL from the file upper case table
 20390                                  ; *		 in DOS if character if above  ascii 128, else
 20391                                  ; *		 subtracts 20H if between "a" and "z".
 20392                                  ; *
 20393                                  ; * INPUT:	 AL	      char to be upper cased
 20394                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20395                                  ; *
 20396                                  ; * OUTPUT:	 AL	      upper cased character
 20397                                  ; *
 20398                                  ; ****************************************************************
 20399                                  
 20400                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20401                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20402                                  UPCONV:
 20403 000023E7 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20404 000023E9 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20405 000023EB 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20406 000023ED 1E                      	push	ds			;AN000;
 20407 000023EE 53                      	push	bx			;AN000;
 20408 000023EF 8E1E[A58A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20409                                  	;lds	bx,dword ptr FUCase_Addr+1
 20410 000023F3 C51E[9F01]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20411 000023F7 83C302                  	add	bx,2			;AN000;  skip over first word
 20412                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20413 000023FA D7                      	xlat
 20414 000023FB 5B                      	pop	bx			;AN000;
 20415 000023FC 1F                      	pop	ds			;AN000;
 20416                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20417                                  	; 24/02/2023
 20418 000023FD C3                      	retn
 20419                                  oth_fucase:				;AN000;
 20420 000023FE 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20421 00002400 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20422 00002402 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20423 00002404 7702                    	ja	short upconv_end	;AC000;
 20424 00002406 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20425                                  upconv_end:				;AN000;
 20426 00002408 C3                      	retn
 20427                                  
 20428                                  ; ---------------------------------------------------------------------------
 20429                                  
 20430                                  ; MSDOS 3.3
 20431                                  
 20432                                  	; 24/02/2023
 20433                                  ;UPCONV_MAPCALL:
 20434                                  	;			; If between "a" and "z"
 20435                                  	;cmp	al,[small_a]
 20436                                  	;jb	short UPCONV_END
 20437                                  	;cmp	al,[small_z]
 20438                                  	;ja	short UPCONV_END
 20439                                  	;sub	al,20h		; Change lower-case to upper
 20440                                  ;UPCONV_END:
 20441                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20442                                  	;			  ; 	  for (current) country
 20443                                  	;retn
 20444                                  
 20445                                  ; =============== S U B	R O U T	I N E =======================================
 20446                                  
 20447                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20448                                  
 20449                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20450                                  	; 10/06/2023
 20451                                  store_char:
 20452 00002409 51                      	push	cx
 20453 0000240A 53                      	push	bx
 20454                                  
 20455                                  	; 24/02/2023
 20456                                  	;;16/10/2018
 20457                                  	; MSDOS 6.0
 20458 0000240B 06                      	push	es		;AN056;*
 20459 0000240C 1E                      	push	ds		;AN056; Save local DS
 20460 0000240D 8E1E[A58A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20461 00002411 8E06[2703]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20462 00002415 1F                      	pop	ds		;AN056; Get local segment back
 20463                                  
 20464                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20465 00002416 E85200                  	call	GETENVSIZ
 20466 00002419 89CB                    	mov	bx,cx		; Save room for double nul
 20467 0000241B 83EB02                  	sub	bx,2
 20468 0000241E 39DF                    	cmp	di,bx
 20469 00002420 723F                    	jb	short store1
 20470 00002422 50                      	push	ax
 20471 00002423 51                      	push	cx
 20472 00002424 53                      	push	bx		; Save Size of environment
 20473 00002425 E8DCE2                  	call	FREE_TPA
 20474 00002428 5B                      	pop	bx
 20475 00002429 83C302                  	add	bx,2		; Recover true environment size
 20476                                  
 20477 0000242C 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20478 00002430 7203                    	jb	short envsiz_ok
 20479                                  bad_env_size:			;AN056;
 20480 00002432 F9                      	stc
 20481 00002433 EB16                    	jmp	short envnoset
 20482                                  	;nop
 20483                                  envsiz_ok:
 20484 00002435 B104                    	mov	cl,4
 20485 00002437 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20486 00002439 43                      	inc	bx
 20487                                  	; 24/02/2023
 20488                                  	; MSDOS 6.0
 20489 0000243A 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20490 0000243C 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20491 0000243E 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20492 00002441 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20493 00002443 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20494 00002445 73EB                    	jnb	short bad_env_size
 20495                                  				;AN056; Yes - don't do it!!!
 20496                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20497 00002447 B44A                    	mov	ah,4Ah
 20498                                  	;mov	ah,SETBLOCK ; 4Ah
 20499 00002449 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20500                                  			; ES = segment address of block	to change
 20501                                  			; BX = new size	in paragraphs
 20502                                  envnoset:
 20503 0000244B 9C                      	pushf
 20504 0000244C 06                      	push	es
 20505 0000244D 8E06[A58A]              	mov	es,[RESSEG]
 20506 00002451 E8C0E2                  	call	ALLOC_TPA
 20507 00002454 07                      	pop	es
 20508 00002455 9D                      	popf
 20509 00002456 59                      	pop	cx
 20510 00002457 58                      	pop	ax
 20511                                  	; 24/02/2023
 20512                                  	;pop	es ; MSDOS 6.0	;AN056;*	
 20513 00002458 7307                    	jnc	short store1
 20514                                  	; 10/06/2023 (BugFix)
 20515 0000245A 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20516 0000245B BA[137F]                	mov	dx,ENVERR_PTR
 20517 0000245E E9EF04                  	jmp	cerror
 20518                                  store1:	
 20519 00002461 AA                      	stosb
 20520 00002462 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20521                                  	; 24/02/2023
 20522 00002467 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20523 00002468 5B                      	pop	bx
 20524 00002469 59                      	pop	cx
 20525 0000246A C3                      	retn
 20526                                  
 20527                                  ; =============== S U B	R O U T	I N E =======================================
 20528                                  
 20529                                  	; 24/02/2023
 20530                                  GETENVSIZ:
 20531                                  
 20532                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20533                                  ;ES has environment segment
 20534                                  ;Size returned in CX, all other registers preserved
 20535                                  
 20536 0000246B 06                      	push	es
 20537 0000246C 50                      	push	ax
 20538 0000246D 8CC0                    	mov	ax,es
 20539 0000246F 48                      	dec	ax		;Point at arena
 20540 00002470 8EC0                    	mov	es,ax
 20541                                  	;mov	ax,[es:3]
 20542 00002472 26A10300                	mov	ax,[es:ARENA.size]
 20543 00002476 B104                    	mov	cl,4
 20544 00002478 D3E0                    	shl	ax,cl		;Convert to bytes
 20545 0000247A 89C1                    	mov	cx,ax
 20546 0000247C 58                      	pop	ax
 20547 0000247D 07                      	pop	es
 20548                                  getenvsiz_retn:
 20549 0000247E C3                      	retn
 20550                                  
 20551                                  ; =============== S U B	R O U T	I N E =======================================
 20552                                  
 20553                                  	; 24/02/2023
 20554                                  RestUDir1:
 20555 0000247F 1E                      	push	ds
 20556 00002480 8E1E[A58A]              	mov	ds,[RESSEG]
 20557 00002484 803E[8C01]00            	cmp	byte [RestDir],0
 20558 00002489 1F                      	pop	ds
 20559 0000248A 74F2                    	jz	short getenvsiz_retn
 20560                                  
 20561                                  ; =============== S U B	R O U T	I N E =======================================
 20562                                  
 20563                                  	; 24/02/2023
 20564                                  RestUDir:
 20565 0000248C BA[8789]                	mov	dx,USERDIR1
 20566 0000248F B43B                    	mov	ah,3Bh
 20567                                  	;mov	ah,CHDir ; 3Bh
 20568 00002491 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20569                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20570 00002493 30C0                    	xor	al,al
 20571                                  	;call	SETREST
 20572                                  	;retn
 20573                                  	; 24/02/2023
 20574 00002495 E94908                  	jmp	SETREST
 20575                                  
 20576                                  ;============================================================================
 20577                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20578                                  ;============================================================================
 20579                                  ; 07/10/2018 - Retro DOS v3.0
 20580                                  
 20581                                  ; TITLE	Part6 COMMAND Transient routines.
 20582                                  
 20583                                  ;	Environment utilities and misc. routines
 20584                                  
 20585                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20586                                  
 20587                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20588                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20589                                  
 20590                                  ; ---------------------------------------------------------------------------
 20591                                  
 20592                                  ; ****************************************************************
 20593                                  ; *
 20594                                  ; * ROUTINE:	 $CHDIR
 20595                                  ; *
 20596                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20597                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20598                                  ; *		 letter is found, get and display the current dir
 20599                                  ; *		 of the specified drive. If nothing is found, get
 20600                                  ; *		 and display the current dir of the default drive.
 20601                                  ; *
 20602                                  ; * INPUT:	 command line at offset 81H
 20603                                  ; *
 20604                                  ; * OUTPUT:	 none
 20605                                  ; *
 20606                                  ; ****************************************************************
 20607                                  
 20608                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20609                                  	; 10/06/2023
 20610                                  _$CHDIR:
 20611                                  	; MSDOS 6.0
 20612 00002498 BE8100                  	mov	si,81h
 20613 0000249B BF[F084]                	mov	di,PARSE_CHDIR
 20614                                  				;AN000; Get address of PARSE_CHDIR
 20615 0000249E 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20616 000024A0 31D2                    	xor	dx,dx		;AN000;
 20617 000024A2 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20618                                  	
 20619                                  	;cmp	ax,-1
 20620                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20621                                  	;je	short bwdj	; No args
 20622                                  	;;cmp	ax,0
 20623                                  	;;cmp	ax,RESULT_NO_ERROR
 20624                                  	;			;AC000; did we have an error?
 20625                                  	;or	ax,ax ; ax = 0 ?
 20626                                  	;jnz	short ChDirErr	;AC018; yes - exit
 20627                                  	
 20628                                  	; 10/06/2023
 20629 000024A5 40                      	inc	ax	; cmp ax,-1
 20630 000024A6 7414                    	jz	short bwdj ; 0FFFFh -> 0
 20631 000024A8 48                      	dec	ax	; cmp ax,0
 20632 000024A9 756D                    	jnz	short ChDirErr ; 1 -> 0
 20633                                  	; ax = 0	
 20634                                  
 20635                                  	;cmp	byte [PARSE1_TYPE],6
 20636 000024AB 803E[4F95]06            	cmp	byte [PARSE1_TYPE],result_drive
 20637                                  				;AC000; was a drive entered?
 20638 000024B0 7511                    	jne	short REALCD	; no
 20639                                  
 20640                                  ; D: was found. See if there is anything more.
 20641                                  
 20642 000024B2 BF[F084]                	mov	di,PARSE_CHDIR
 20643                                  				;AC000; get address of parse_chdir
 20644 000024B5 31D2                    	xor	dx,dx		;AC000;
 20645 000024B7 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 20646 000024BA 755C                    	jnz	short ChDirErr	;AC000;
 20647                                  bwdj:
 20648 000024BC E87BF9                  	call	build_dir_for_chdir
 20649                                  				; Drive only specified
 20650 000024BF E80D01                  	call	CRLF2
 20651                                  chdir_retn:
 20652 000024C2 C3                      	retn
 20653                                  
 20654                                  	; 24/02/2023
 20655                                  	; MSDOS 3.3
 20656                                  	;mov	ax,[COMSW]
 20657                                  	;or	ax,[ALLSWITCH]
 20658                                  	;mov	dx,BADPARMPTR
 20659                                  	;jnz	short CHDIR_ERR
 20660                                  	;mov	si,81h
 20661                                  	;call	SCANOFF
 20662                                  	;cmp	al,0Dh		; are we at end of line?
 20663                                  	;je	short BWDJ	; No args
 20664                                  	;inc	si
 20665                                  	;lodsb
 20666                                  	;cmp	al,':'
 20667                                  	;jne	short REALCD
 20668                                  	;push	si
 20669                                  	;call	SCANOFF
 20670                                  	;pop	si
 20671                                  	;cmp	al,0Dh		; was a drive entered?
 20672                                  	;jne	short REALCD	; no
 20673                                  ;BWDJ:
 20674                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20675                                  	;call	CRLF2
 20676                                  ;CHDIR_RETN:
 20677                                  	;retn
 20678                                  
 20679                                  	; 24/02/2023
 20680                                  	; MSDOS 6.0
 20681                                  REALCD:
 20682 000024C3 56                      	push	si		;AN000; save position in line
 20683 000024C4 C536[5395]              	lds	si,[PARSE1_ADDR]
 20684                                  				;AN000; get address of filespec
 20685 000024C8 E8D807                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20686 000024CB 5E                      	pop	si		;AN000; restore position in line
 20687 000024CC BF[F084]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20688 000024CF 31D2                    	xor	dx,dx		;AC000;
 20689 000024D1 E8CDFC                  	call	parse_check_eol ;AC000; call parser
 20690 000024D4 7542                    	jnz	short ChDirErr	;AC000;
 20691                                  	
 20692 000024D6 E81106                  	call	SETPATH
 20693 000024D9 F606[2C8C]02            	test	byte [DestInfo],2
 20694 000024DE 7518                    	jnz	short BadChDir
 20695                                  
 20696                                  	; 26/04/2023
 20697 000024E0 B43B                    	mov	ah,3Bh
 20698                                  	;mov	ah,CHDir
 20699 000024E2 CD21                    	int	21h
 20700 000024E4 73DC                    	jnc	short chdir_retn
 20701                                  	
 20702 000024E6 E807F8                  	call	get_ext_error_number
 20703                                  				;AN022; get the extended error
 20704 000024E9 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20705                                  				;AN022; see if path not found
 20706 000024EC 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20707                                  ;SR;
 20708                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20709                                  ;but is not a directory. The extended error returns "Access denied" which
 20710                                  ;is kind of confusing. Issue the old message if access denied error is 
 20711                                  ;returned
 20712                                  
 20713 000024EE 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20714 000024F1 7405                    	je	short BadChDir
 20715                                  	
 20716 000024F3 E89E00                  	call	set_ext_error_subst ;AN022;
 20717 000024F6 EB20                    	jmp	short ChDirErr	;AN022;
 20718                                  
 20719                                  BadChDir:
 20720 000024F8 BA[3780]                	mov	dx,badcd_ptr
 20721                                  ;ChDirErr:
 20722                                  ;	call	std_eprintf
 20723                                  ;mkdir_retn:
 20724                                  	;retn
 20725                                  	; 24/02/2023
 20726 000024FB EB1B                    	jmp	short ChDirErr	;AN022;
 20727                                  
 20728                                  	; 24/02/2023
 20729                                  	; MSDOS 3.3
 20730                                  ;REALCD:
 20731                                  	;call	SETPATH
 20732                                  	;test	byte [DESTINFO],2
 20733                                  	;jnz	short BADCHDIR
 20734                                  	;mov	ah,CHDir ; 3Bh
 20735                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20736                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20737                                  	;jnc	short CHDIR_RETN
 20738                                  ;BADCHDIR:
 20739                                  	;mov	dx,BADCDPTR
 20740                                  ;CHDIR_ERR:
 20741                                  	;call	STD_EPRINTF
 20742                                  ;MKDIR_RETN:
 20743                                  	;retn
 20744                                  
 20745                                  ; =============== S U B	R O U T	I N E =======================================
 20746                                  
 20747                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20748                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20749                                  _$MKDIR:
 20750                                  	; MSDOS 6.0
 20751 000024FD E86300                  	call	SETRMMK
 20752 00002500 7216                    	jc	short MkDirErr
 20753                                  
 20754 00002502 B439                    	mov	ah,39h
 20755                                  	;mov	ah,MKDIR
 20756 00002504 CD21                    	int	21h
 20757 00002506 7313                    	jnc	short mkdir_retn
 20758                                  
 20759 00002508 E8E5F7                  	call	get_ext_error_number	
 20760                                  				;AN022; get the extended error
 20761 0000250B 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20762                                  				;AN022; see if path not found
 20763 0000250E 742A                    	je	short MD_other_err
 20764                                  				;AN022; yes - issue old message
 20765 00002510 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20766                                  				;AN022; access denied?
 20767 00002513 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20768                                  	
 20769 00002515 E87C00                  	call	set_ext_error_subst
 20770                                  				;AN022;
 20771                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20772                                  	; 24/02/2023
 20773                                  ChDirErr:
 20774                                  MkDirErr:
 20775                                  RmDirErr:
 20776 00002518 E8AE28                  	call	std_eprintf
 20777                                  mkdir_retn:
 20778                                  rmdir_retn:
 20779 0000251B C3                      	retn
 20780                                  	
 20781                                  badmderr:
 20782 0000251C BA[D387]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20783 0000251F B41A                    	mov	ah,1Ah
 20784                                  	;mov	ah,Set_DMA	;AN006;
 20785 00002521 CD21                    	int	21h		;AN006;
 20786                                  	
 20787 00002523 B44E                    	mov	ah,4Eh
 20788                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20789                                  	;mov	cx,10h
 20790 00002525 B91000                  	mov	cx,ATTR_DIRECTORY
 20791                                  				;AN006;   search for directory
 20792 00002528 CD21                    	int	21h		;AN006;
 20793 0000252A 720E                    	jc	short MD_other_err
 20794                                  				;AN006; doesn't exist - must be something else
 20795                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20796                                  				;AN006; we found a file/dir
 20797                                  	;mov	dl,[SRCXNAME+21] 
 20798 0000252C 8A16[E887]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20799 00002530 F6C210                  	test	dl,ATTR_DIRECTORY
 20800                                  				;AN006; was it a directory?
 20801 00002533 7405                    	jz	short MD_other_err
 20802                                  				;AN006; no - must have been a file
 20803 00002535 BA[2781]                	mov	dx,MD_EXISTS_PTR
 20804                                  				;AN006; set up already exists error
 20805 00002538 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20806                                  MD_other_err:			;AN006;
 20807 0000253A BA[3A80]                	mov	dx,badmkd_ptr
 20808                                  ;MkDirErr:
 20809                                  	;call	std_eprintf
 20810                                  	;retn
 20811                                  	; 24/02/2023
 20812 0000253D EBD9                    	jmp	short MkDirErr
 20813                                  
 20814                                  	; 24/02/2023
 20815                                  	; MSDOS 3.3
 20816                                  	;call	SETRMMK
 20817                                  	;jb	short MKDIRERR
 20818                                  	;mov	ah,MKDIR ; 39h
 20819                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20820                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20821                                  	;jnc	short MKDIR_RETN
 20822                                  	;mov	dx,BADMKDPTR
 20823                                  	;call	GET_EXT_ERR_NUMBER
 20824                                  ;MKDIRERR:
 20825                                  	;call	STD_EPRINTF
 20826                                  	;retn
 20827                                  
 20828                                  ; =============== S U B	R O U T	I N E =======================================
 20829                                  
 20830                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20831                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20832                                  _$RMDIR:
 20833 0000253F E82100                  	call	SETRMMK
 20834 00002542 72D4                    	jb	short RmDirErr
 20835 00002544 7518                    	jnz	short badrderr
 20836                                  
 20837 00002546 B43A                    	mov	ah,3Ah
 20838                                  	;mov	ah,RMDIR ; 3Ah
 20839 00002548 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20840                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20841 0000254A 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20842                                  
 20843                                  	; 24/02/2023
 20844                                  	; MSDOS 6.0
 20845 0000254C E8A1F7                  	call	get_ext_error_number
 20846                                  				;AN022; get the extended error
 20847 0000254F 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20848                                  				;AN022; see if path not found
 20849 00002552 740A                    	je	short badrderr	;AN022; yes - issue old message
 20850 00002554 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20851                                  				;AN022; access denied?
 20852 00002557 7405                    	je	short badrderr	;AN022; yes - issue old message
 20853                                  
 20854 00002559 E83800                  	call	set_ext_error_subst
 20855                                  				;AN022;
 20856 0000255C EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20857                                  
 20858                                  	; MSDOS 6.0
 20859                                  badrderr:
 20860                                  	; 24/02/2023
 20861 0000255E BA[3D80]                	mov	dx,badrmd_ptr
 20862 00002561 EBB5                    	jmp	short RmDirErr
 20863                                  ;RmDirErr:
 20864                                  	;call	std_eprintf
 20865                                  ;;rmdir_retn
 20866                                  	;retn
 20867                                  
 20868                                  	; 24/02/2023
 20869                                  	; MSDOS 3.3
 20870                                  	;mov	dx,BADRMDPTR
 20871                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20872                                  ;RMDIRERR:
 20873                                  	;call	STD_EPRINTF
 20874                                  ;RMDIR_RETN:
 20875                                  	;retn
 20876                                  
 20877                                  ; =============== S U B	R O U T	I N E =======================================
 20878                                  
 20879                                  ; 	<Common MkDir/RmDir set up code>
 20880                                  ;****************************************************************
 20881                                  ;*
 20882                                  ;* ROUTINE:	SETRMMK
 20883                                  ;*
 20884                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20885                                  ;*		commands. Parses the command line for a required
 20886                                  ;*		filespec.
 20887                                  ;*
 20888                                  ;* INPUT:	command line at offset 81H
 20889                                  ;*
 20890                                  ;* OUTPUT:	carry clear
 20891                                  ;*		    DS:DX points to ASCIIZ argument
 20892                                  ;*		carry set
 20893                                  ;*		    DS:DX has error message pointer
 20894                                  ;*
 20895                                  ;****************************************************************
 20896                                  
 20897                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20898                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20899                                  SETRMMK:
 20900                                  	; MSDOS 6.0
 20901 00002563 BE8100                  	mov	si,81h
 20902 00002566 BF[E784]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20903 00002569 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20904 0000256B 31D2                    	xor	dx,dx		;AN000;
 20905                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20906 0000256D E847FC                  	call	Parse_With_Msg
 20907                                  	;cmp	ax,0
 20908                                  	;cmp	ax,RESULT_NO_ERROR
 20909 00002570 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20910 00002572 7519                    	jnz	short noargerr	;AC000; yes - exit
 20911                                  
 20912 00002574 BF[D387]                	mov	di,SRCXNAME
 20913                                  				;AN000; get address of srcxname
 20914 00002577 57                      	push	di		;AN000; save address
 20915 00002578 56                      	push	si		;AN000; save position in line
 20916 00002579 C536[5395]              	lds	si,[PARSE1_ADDR]
 20917                                  				;AN000; get address of path
 20918                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20919 0000257D AC                      	lodsb			;get a char from buffer
 20920 0000257E AA                      	stosb			;AN000; store in srcxname
 20921                                  	;cmp	al,0
 20922                                  	;cmp	al,END_OF_LINE_OUT
 20923 0000257F 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20924 00002581 75FA                    	jnz	short mrdir_move_filename
 20925                                  				;AC000; no - keep moving
 20926 00002583 5E                      	pop	si		;AN000; get line position back
 20927                                  
 20928                                  ; we have scanned an argument.	See if any args beyond.
 20929                                  
 20930 00002584 BF[E784]                	mov	di,PARSE_MRDIR
 20931 00002587 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20932 0000258A 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20933                                  	;retz			;yes - return no error
 20934 0000258B 7406                    	jz	short setrmmk_retn
 20935                                  noargerr:
 20936 0000258D BA[FC7E]                	mov	dx,extend_buf_ptr
 20937                                  				;AC000; get extended message pointer
 20938 00002590 31C0                    	xor	ax,ax
 20939 00002592 F9                      	stc
 20940                                  setrmmk_retn:
 20941 00002593 C3                      	retn
 20942                                  
 20943                                  	; 24/02/2023
 20944                                  	; MSDOS 3.3
 20945                                  ;SETRMMK:
 20946                                  	;mov	si,81h
 20947                                  	;call	SCANOFF
 20948                                  	;cmp	al,0Dh
 20949                                  	;je	short NOARGERR
 20950                                  	;mov	dx,si
 20951                                  ;SETRMMK1:
 20952                                  	;lodsb
 20953                                  	;call	DELIM
 20954                                  	;jz	short SETRMMK3
 20955                                  	;cmp	al,0Dh
 20956                                  	;jne	short SETRMMK1
 20957                                  	;mov	byte [si-1],0
 20958                                  ;SETRMMK2:
 20959                                  	;retn
 20960                                  ;SETRMMK3:
 20961                                  	;mov	byte [si-1],0
 20962                                  	;push	si
 20963                                  	;call	SCANOFF
 20964                                  	;pop	si
 20965                                  	;cmp	al,0Dh
 20966                                  	;je	short SETRMMK2
 20967                                  ;NOARGERR:
 20968                                  	;mov	dx,BADARGSPTR
 20969                                  	;xor	ax,ax
 20970                                  	;stc
 20971                                  ;SETRMMK_RETN:
 20972                                  	;retn
 20973                                  
 20974                                  ; =============== S U B	R O U T	I N E =======================================
 20975                                  
 20976                                  ; MSDOS 6.0
 20977                                  
 20978                                  ;****************************************************************
 20979                                  ;*
 20980                                  ;* ROUTINE:	Set_ext_error_subst
 20981                                  ;*
 20982                                  ;* FUNCTION:	Sets up substitution for extended error
 20983                                  ;*
 20984                                  ;* INPUT:	AX - extended error number
 20985                                  ;*		DX - offset of string
 20986                                  ;*
 20987                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20988                                  ;*
 20989                                  ;****************************************************************
 20990                                  
 20991                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20992                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20993                                  set_ext_error_subst:
 20994                                  	;mov	byte [msg_disp_class],1
 20995 00002594 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 20996                                  					;AN022; set up extended error msg class
 20997 00002599 8916[118C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20998                                  	;mov	byte [extend_buf_sub],1
 20999 0000259D C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst
 21000                                  	;AN022; put number of subst in control block
 21001 000025A2 BA[FC7E]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 21002 000025A5 A3[FC7E]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 21003                                  savudir_err_retn: ; 24/02/2023
 21004 000025A8 C3                      	retn				;AN022; return
 21005                                  
 21006                                  ; =============== S U B	R O U T	I N E =======================================
 21007                                  
 21008                                  ; <SavUDir - preserve the users current directory on a particular drive>
 21009                                  
 21010                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 21011                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 21012                                  ;   buffer
 21013                                  ;
 21014                                  ;   Inputs:	DL has 1-based drive number
 21015                                  ;		ES:DI has destination buffer (SavUDir1 only)
 21016                                  ;   Outputs:	Carry Clear
 21017                                  ;		    DS = TranGroup
 21018                                  ;		Carry Set
 21019                                  ;		    AX has error code
 21020                                  ;   Registers Modified: AX, SI
 21021                                  
 21022                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21023                                  SAVUDIR:
 21024 000025A9 BF[8789]                	mov	di,USERDIR1
 21025                                  ; --------------
 21026                                  SAVUDIR1:
 21027 000025AC 88D0                    	mov	al,dl
 21028 000025AE 0440                    	add	al,'@' ; 40h
 21029 000025B0 3C40                    	cmp	al,'@' ; 40h
 21030 000025B2 7506                    	jne	short GOTUDRV
 21031 000025B4 0206[B78A]              	add	al,[CURDRV]
 21032 000025B8 FEC0                    	inc	al		; A = 1
 21033                                  GOTUDRV:
 21034 000025BA AA                      	stosb
 21035 000025BB 8A26[AA8A]              	mov	ah,[DIRCHAR]
 21036 000025BF B03A                    	mov	al,':' ; 3Ah
 21037 000025C1 AB                      	stosw
 21038 000025C2 06                      	push	es
 21039 000025C3 1F                      	pop	ds
 21040 000025C4 89FE                    	mov	si,di
 21041 000025C6 B447                    	mov	ah,47h ; 24/02/2023
 21042                                  	;mov	ah,CURRENT_DIR	; 47h
 21043 000025C8 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 21044                                  			; DL = drive (0=default,1=A,etc.)
 21045                                  			; DS:SI	points to 64-byte buffer area
 21046 000025CA 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 21047 000025CC 0E                      	push	cs
 21048 000025CD 1F                      	pop	ds
 21049 000025CE C3                      	retn
 21050                                  
 21051                                  ; =============== S U B	R O U T	I N E =======================================
 21052                                  
 21053                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21054                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 21055                                  CRLF2:
 21056 000025CF 52                      	push	dx
 21057 000025D0 BA[DB80]                	mov	dx,acrlf_ptr
 21058 000025D3 1E                      	push	ds
 21059 000025D4 0E                      	push	cs
 21060 000025D5 1F                      	pop	ds
 21061 000025D6 E8F827                  	call	std_printf
 21062 000025D9 1F                      	pop	ds
 21063 000025DA 5A                      	pop	dx
 21064 000025DB C3                      	retn
 21065                                  
 21066                                  ; =============== S U B	R O U T	I N E =======================================
 21067                                  
 21068                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 21069                                  ; may NOT be TRANGROUP
 21070                                  
 21071                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21072                                  scanoff:
 21073 000025DC AC                      	lodsb
 21074 000025DD E80400                  	call	DELIM
 21075 000025E0 74FA                    	jz	short scanoff
 21076 000025E2 4E                      	dec	si		; Point to first non-delimiter
 21077                                  scanoff_retn:
 21078 000025E3 C3                      	retn
 21079                                  
 21080                                  ; =============== S U B	R O U T	I N E =======================================
 21081                                  
 21082                                  ; Input:    AL is character to classify
 21083                                  ; Output:   Z set if delimiter
 21084                                  ;	    NZ set otherwise
 21085                                  ; Registers modified: none
 21086                                  
 21087                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21088                                  DELIM:
 21089 000025E4 3C20                    	cmp	al,' '	 ;20h
 21090 000025E6 74FB                    	je	short scanoff_retn
 21091 000025E8 3C3D                    	cmp	al,'='  ; 3Dh
 21092 000025EA 74F7                    	je	short scanoff_retn
 21093 000025EC 3C2C                    	cmp	al,','	; 2Ch
 21094 000025EE 74F3                    	je	short scanoff_retn
 21095 000025F0 3C3B                    	cmp	al,';'	 ;3Bh
 21096 000025F2 74EF                    	je	short scanoff_retn
 21097 000025F4 3C09                    	cmp	al,9		; Check for TAB character
 21098 000025F6 74EB                    	je	short scanoff_retn
 21099 000025F8 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 21100 000025FA C3                      	retn
 21101                                  
 21102                                  
 21103                                  ; =============== S U B	R O U T	I N E =======================================
 21104                                  
 21105                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21106                                  FCB_TO_ASCZ:			
 21107                                  	; Convert DS:SI to ASCIZ ES:DI
 21108 000025FB B90800                  	mov	cx,8
 21109                                  MAINNAME:
 21110 000025FE AC                      	lodsb
 21111 000025FF 3C20                    	cmp	al,' ' ; 20h
 21112 00002601 7401                    	jz	short SKIPSPC
 21113 00002603 AA                      	stosb
 21114                                  SKIPSPC:
 21115 00002604 E2F8                    	loop	MAINNAME
 21116 00002606 AC                      	lodsb
 21117 00002607 3C20                    	cmp	al,' '
 21118 00002609 740F                    	je	short GOTNAME
 21119 0000260B 88C4                    	mov	ah,al
 21120                                  	; 24/02/2023
 21121 0000260D B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 21122                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 21123                                  	;stosb
 21124                                  	;xchg	al,ah
 21125                                  	;stosb
 21126                                  	; 24/02/2023
 21127 0000260F AB                      	stosw
 21128 00002610 B102                    	mov	cl,2
 21129                                  EXTNAME:
 21130 00002612 AC                      	lodsb
 21131 00002613 3C20                    	cmp	al,' '
 21132 00002615 7403                    	je	short GOTNAME
 21133 00002617 AA                      	stosb
 21134 00002618 E2F8                    	loop	EXTNAME
 21135                                  GOTNAME:
 21136 0000261A 30C0                    	xor	al,al
 21137 0000261C AA                      	stosb
 21138                                  STRCOMP_RETN:
 21139 0000261D C3                      	retn
 21140                                  
 21141                                  ; =============== S U B	R O U T	I N E =======================================
 21142                                  
 21143                                  ; Compare ASCIZ DS:SI with ES:DI.
 21144                                  ; SI,DI destroyed.
 21145                                  
 21146                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21147                                  STRCOMP:	
 21148 0000261E A6                      	cmpsb
 21149 0000261F 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 21150 00002621 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 21151                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 21152                                  	;jmp	short STRCOMP	; Equal so far, keep going
 21153                                  	; 24/02/2023
 21154 00002625 75F7                    	jnz	short STRCOMP
 21155 00002627 C3                      	retn
 21156                                  
 21157                                  ; =============== S U B	R O U T	I N E =======================================
 21158                                  
 21159                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21160                                  CRPRINT:
 21161 00002628 50                      	push	ax
 21162                                  	;mov	al,13	; 0Dh
 21163 00002629 B00D                    	mov	al,0Dh
 21164 0000262B 51                      	push	cx
 21165 0000262C 57                      	push	di
 21166 0000262D 89D7                    	mov	di,dx
 21167 0000262F B9FFFF                  	mov	cx,65535 ; 0FFFFh
 21168 00002632 06                      	push	es
 21169 00002633 1E                      	push	ds
 21170 00002634 07                      	pop	es
 21171 00002635 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 21172 00002637 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 21173 0000263B 07                      	pop	es
 21174 0000263C 8916[118C]              	mov	[string_ptr_2],dx
 21175                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 21176 00002640 BA[C380]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 21177 00002643 E88B27                  	call	std_printf
 21178                                  	;mov	byte [di-1],13
 21179 00002646 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 21180 0000264A 7204                    	jb	short error_output
 21181 0000264C 5F                      	pop	di
 21182 0000264D 59                      	pop	cx
 21183 0000264E 58                      	pop	ax
 21184 0000264F C3                      	retn
 21185                                  
 21186                                  ; ---------------------------------------------------------------------------
 21187                                  
 21188                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21189                                  error_output:
 21190 00002650 0E                      	push	cs
 21191 00002651 1F                      	pop	ds
 21192 00002652 8E06[A58A]              	mov	es,[RESSEG]
 21193 00002656 BA[107F]                	mov	dx,NOSPACE_PTR
 21194 00002659 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 21195 0000265F 7406                    	jz	short go_to_error
 21196 00002661 E80209                  	call	PipeOff
 21197 00002664 BA[5D80]                	mov	dx,PIPEEMES_PTR
 21198                                  go_to_error:
 21199 00002667 E9E602                  	jmp	cerror
 21200                                  
 21201                                  ; =============== S U B	R O U T	I N E =======================================
 21202                                  
 21203                                  ;---- Mod for path invocation ----
 21204                                  
 21205                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21206                                  pathchrcmp:
 21207                                  	; 18/03/2023	
 21208                                  	;push	ax
 21209                                  	;mov	ah,'/' ; 2Fh
 21210                                  	;cmp	[SWITCHAR],ah
 21211 0000266A 803E[A98A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 21212 0000266F 7404                    	je	short noslasht
 21213 00002671 3C2F                    	cmp	al,'/'
 21214 00002673 7402                    	je	short pccont
 21215                                  noslasht:
 21216 00002675 3C5C                    	cmp	al,'\' ; 5Ch
 21217                                  pccont:	
 21218                                  	;pop	ax
 21219 00002677 C3                      	retn
 21220                                  
 21221                                  ; =============== S U B	R O U T	I N E =======================================
 21222                                  
 21223                                  ; PATHCRUNCH -
 21224                                  ;
 21225                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 21226                                  ;       PathPos = ptr to string with pathname in it
 21227                                  ;       PathCnt = length of string
 21228                                  ;
 21229                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 21230                                  ;       PathCnt = length left in string
 21231                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 21232                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 21233                                  ;       If path crunched successfully,
 21234                                  ;         CY = clear
 21235                                  ;         Current directory is changed to directory in pathname
 21236                                  ;         UserDir1 contains previous directory for use by RestUDir
 21237                                  ;         RestDir = nonzero to flag later restoration of user's dir
 21238                                  ;         DestTail = ptr to beginning of filename
 21239                                  ;         If filename found in pathname,
 21240                                  ;           ZR = clear
 21241                                  ;           FCB filename fields contain filename
 21242                                  ;         If filename not found (pure directory path),
 21243                                  ;           ZR = set
 21244                                  ;           FCB filename fields are wildcarded with ?'s
 21245                                  ;       If pathcrunch failed (no ChDir's worked),
 21246                                  ;         CY = set
 21247                                  ;         Msg_Numb = extended error code
 21248                                  ;
 21249                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 21250                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 21251                                  ;       with the filename wildcarded.
 21252                                  
 21253                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21254                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 21255                                  
 21256                                  PathCrunch:
 21257                                  	; MSDOS 6.0
 21258 00002678 C706[948D]0000          	mov     word [Msg_Numb],0
 21259                                  				;AN022; Set up message flag
 21260                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21261                                  	;mov	dl,[5Ch]
 21262 0000267E 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 21263 00002682 E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 21264                                  	; MSDOS 6.0
 21265 00002685 7233                     	jc	short pcrunch_cderrj
 21266                                  				;AN022; if error on current dir - report
 21267 00002687 E86004                  	call	SETPATH		; scan past switches, whitespace
 21268                                  
 21269                                  ;       DX = ptr to pathname, NULL-terminated
 21270                                  ;       PathPos = ptr to byte after NULL at end of pathname
 21271                                  
 21272                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21273 0000268A F606[2C8C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 21274 0000268F 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 21275                                  
 21276                                  	;mov	ah,CHDir ; 3Bh
 21277 00002691 B43B                    	mov	ah,3Bh
 21278 00002693 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21279                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21280                                  	; MSDOS 6.0
 21281 00002695 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 21282                                  	
 21283 00002697 E856F6                  	call	get_ext_error_number    ;AN022; get the extended error
 21284 0000269A 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 21285 0000269D 741E                    	je	short trypeel		;AC022;    keep trying
 21286 0000269F 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 21287 000026A2 7419                    	je	short trypeel		;AC022;    keep trying
 21288 000026A4 A3[948D]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 21289 000026A7 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 21290                                  
 21291                                  	; MSDOS 3.3
 21292                                  	;jc	short trypeel
 21293                                  chdir_worked:
 21294                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21295 000026AA E83206                  	call	SetRest1	; set 'Restore Directory' flag true
 21296 000026AD B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 21297 000026AF BF5D00                  	mov	di,5Dh  ; FCB+1
 21298 000026B2 B90B00                  	mov	cx,11
 21299 000026B5 F3AA                    	rep	stosb
 21300 000026B7 30C0                    	xor	al,al		; return carry clear, zero set
 21301 000026B9 C3                      	retn
 21302                                  
 21303                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 21304 000026BA E98100                  	jmp	pcrunch_cderr	;AN022;
 21305                                  
 21306                                  trypeel:
 21307 000026BD 8B36[008C]              	mov	si,[PathPos]
 21308 000026C1 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 21309 000026C2 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 21310                                  	; 25/02/2023
 21311                                  	; MSDOS 5.0 (& 6.0)
 21312 000026C5 803E[AF8D]00            	cmp	byte [KPARSE],0
 21313 000026CA 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 21314                                  	
 21315 000026CC E89BFF                  	call	pathchrcmp
 21316 000026CF 7475                    	jz	short peelfail	; Trailing '/'
 21317                                  delstrt:
 21318 000026D1 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 21319 000026D3 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 21320 000026D5 52                      	push	dx		; save ptr to pathname
 21321                                  delloop:
 21322 000026D6 39CE                    	cmp	si,cx
 21323                                  	;jz	short BADRET
 21324                                  	; 25/02/2023
 21325 000026D8 7413                    	je	short gotdele	; no char's left, we have what we have
 21326 000026DA AC                      	lodsb			; AL = next char of pathname
 21327 000026DB E8DFFC                  	call	testkanj
 21328 000026DE 7403                    	jz	short notkanj8	; not Kanji, move along
 21329 000026E0 46                      	inc	si
 21330 000026E1 EBF3                    	jmp	short delloop	
 21331                                  
 21332                                  	; 25/02/2023
 21333                                  	; MSDOS 3.3
 21334                                  	;mov	al,[si]
 21335                                  	;call	PATHCHRCMP
 21336                                  	;jz	short TRYCD
 21337                                  	;dec	si
 21338                                  	;jmp	short delloop
 21339                                  
 21340                                  notkanj8:
 21341 000026E3 E884FF                  	call	pathchrcmp
 21342 000026E6 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 21343 000026E8 89F2                    	mov	dx,si
 21344 000026EA 4A                      	dec	dx		; DX = ptr to last delimiter found	
 21345 000026EB EBE9                    	jmp	short delloop	; go look for more
 21346                                  
 21347                                  	; 25/02/2023
 21348                                  	; MSDOS 5.0 (& 6.0)
 21349                                  gotdele:
 21350 000026ED 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 21351 000026EF 5A                      	pop	dx		; DX = ptr to pathname
 21352 000026F0 39D6                    	cmp	si,dx
 21353 000026F2 7454                    	je	short badret	; didn't find path delim
 21354 000026F4 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 21355 000026F6 89D6                    	mov	si,dx		; SI = ptr to pathname
 21356                                  delloop2:			; Set value of KPARSE
 21357 000026F8 39CE                    	cmp	si,cx
 21358 000026FA 7412                    	je	short trycd	; roll up till SI meets CX
 21359 000026FC C606[AF8D]00            	mov	byte [KPARSE],0
 21360 00002701 AC                      	lodsb
 21361 00002702 E8B8FC                  	call	testkanj
 21362 00002705 74F1                    	jz	short delloop2
 21363 00002707 46                      	inc	si
 21364 00002708 FE06[AF8D]              	inc	byte [KPARSE]
 21365 0000270C EBEA                    	jmp	short delloop2
 21366                                  
 21367                                  trycd:
 21368 0000270E 50                      	push	ax
 21369                                  	; 25/02/2023
 21370 0000270F B02E                    	mov	al,'.'
 21371                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21372                                  	; MSDOS 6.0
 21373 00002711 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21374                                  				;M019; allow continuation if '. ' or 
 21375                                  				;M019; '..' is not found.
 21376 00002714 7509                    	jne	short trycd1	;M019; '.' not found
 21377 00002716 384402                  	cmp	[si+2],al	;M019; check for '..'
 21378 00002719 7404                    	je	short trycd1	;M019; found '..'
 21379 0000271B 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21380                                  trycd1:	
 21381 0000271F 58                      	pop     ax
 21382 00002720 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21383                                  
 21384                                  	; 25/02/2023
 21385                                  	; MSDOS 3.3
 21386                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21387                                  	;pop	ax
 21388                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21389                                  
 21390                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21391 00002722 8A44FF                  	mov	al,[si-1]
 21392 00002725 3C3A                    	cmp	al,':' 		; Special case d:\file
 21393 00002727 741F                    	je	short badret
 21394                                  	; 25/02/2023
 21395                                  	; MSDOS 6.0
 21396 00002729 803E[AF8D]00            	cmp	byte [KPARSE],0
 21397 0000272E 7505                    	jnz	short notdoublesl
 21398 00002730 E837FF                  	call	pathchrcmp
 21399                                  	;jnz	short notdoublesl
 21400                                  				; Last char is 2nd KANJI byte, might be '\'
 21401                                  	; 25/02/2023
 21402 00002733 7411                    	jz	short peelfail 
 21403                                  ;peelfail:
 21404                                  	;stc
 21405                                  	;retn
 21406                                  
 21407                                  notdoublesl:
 21408 00002735 C60400                  	mov	byte [si],0
 21409                                  	;mov	ah,CHDir ; 3Bh
 21410 00002738 B43B                    	mov	ah,3Bh
 21411 0000273A CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21412                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21413 0000273C 7320                    	jnc	short cdsucc
 21414                                  
 21415                                  	; 25/02/2023
 21416                                  	; MSDOS 6.0
 21417                                  pcrunch_cderr:
 21418 0000273E E8AFF5                  	call	get_ext_error_number
 21419                                  				;AN022; get the extended error
 21420 00002741 A3[948D]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21421 00002744 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21422                                  peelfail: ; 25/02/2023
 21423 00002746 F9                      	stc			;AN022; set up carry flag
 21424                                  pcrunch_retn:
 21425 00002747 C3                      	retn
 21426                                  
 21427                                  badret:
 21428                                  	; MSDOS 3.3 & MSDOS 6.0
 21429 00002748 8A04                    	mov	al,[si]
 21430 0000274A E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21431 0000274D F9                      	stc
 21432 0000274E 75F7                    	jnz	short pcrunch_retn
 21433 00002750 30DB                    	xor	bl,bl
 21434 00002752 865C01                  	xchg	bl,[si+1]
 21435                                  	;mov	ah,CHDir ; 3Bh
 21436 00002755 B43B                    	mov	ah,3Bh
 21437 00002757 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21438                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21439                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21440                                  	; 25/02/2023
 21441 00002759 72E3                    	jc	short pcrunch_cderr
 21442                                  				;AN022; go to error exit 
 21443 0000275B 885C01                  	mov	[si+1],bl
 21444                                  cdsucc:
 21445 0000275E E87E05                  	call	SetRest1
 21446 00002761 46                      	inc	si		; Reset zero
 21447 00002762 8936[2A8C]              	mov	[DestTail],si
 21448                                  	; 25/02/2023
 21449                                  	; MSDOS 6.0
 21450 00002766 9C                      	pushf			;AN015; save flags
 21451 00002767 803E[088C]FF            	cmp	byte [DirFlag],-1
 21452                                  				;AN015; don't do parse if in DIR
 21453 0000276C 7408                    	je	short pcrunch_end
 21454                                  				;AN015;
 21455                                  	; MSDOS 3.3 & MSDOS 6.0
 21456 0000276E BF5C00                  	mov	di,FCB  ; 5Ch
 21457                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21458 00002771 B80229                  	mov	ax,2902h	
 21459 00002774 CD21                    	int	21h		; Parse with default drive
 21460                                  			; DOS -	PARSE FILENAME
 21461                                  			; DS:SI	-> string to parse
 21462                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21463                                  			; AL = bit mask	to control parsing
 21464                                  	; MSDOS 3.3
 21465                                  	;retn
 21466                                  
 21467                                  pcrunch_end:
 21468 00002776 9D                      	popf			;AN015; get flags back
 21469 00002777 C3                      	retn
 21470                                  
 21471                                  ;============================================================================
 21472                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21473                                  ;============================================================================
 21474                                  ; 05/10/2018 - Retro DOS v3.0
 21475                                  
 21476                                  ;TITLE	Part7 COMMAND Transient Routines
 21477                                  
 21478                                  ;	More misc routines
 21479                                  
 21480                                  ;---------------------------
 21481                                  ; We can get rid of this switch processing code if we can take
 21482                                  ; care of the remaining two calls to switch, later in the file.
 21483                                  ; However, I have not checked whether or not any other files use
 21484                                  ; switch -- after all, it IS public!
 21485                                  ;---------------------------
 21486                                  
 21487                                  ; 28/03/2023
 21488                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21489                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21490                                  
 21491                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21492                                  
 21493                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21494                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21495                                  
 21496                                  ; ---------------------------------------------------------------------------
 21497                                  
 21498                                  	; 25/02/2023
 21499                                  RETSW:
 21500 00002778 93                      	xchg	ax,bx		; Put switches in AX
 21501 00002779 C3                      	retn
 21502                                  
 21503                                  ; =============== S U B	R O U T	I N E =======================================
 21504                                  
 21505                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21506                                  SWITCH:
 21507 0000277A 31DB                    	xor	bx,bx		; Initialize - no switches set
 21508                                  SWLOOP:
 21509 0000277C E85DFE                  	call	scanoff		; Skip any delimiters
 21510 0000277F 3A06[A98A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21511 00002783 75F3                    	jnz	short RETSW	; No -- we're finished
 21512 00002785 81CB0080                	or	bx,8000h
 21513                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21514 00002789 46                      	inc	si		; Skip over the switch character
 21515 0000278A E84FFE                  	call	scanoff
 21516 0000278D 3C0D                    	cmp	al,0Dh
 21517 0000278F 74E7                    	je	short RETSW	; Oops
 21518 00002791 46                      	inc	si
 21519                                  
 21520                                  	; Convert lower case input to upper case
 21521                                  
 21522 00002792 E852FC                  	call	UPCONV
 21523                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21524                                  
 21525 00002795 BF[3184]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21526                                  				; ("VBAPW" (for MSDOS 3.3))
 21527 00002798 B90600                  	mov	cx,6  ; MSDOS 6.0
 21528                                  	;mov	cx,5  ; MSDOS 3.3
 21529                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21530                                  		
 21531                                  	;nop
 21532                                  		
 21533 0000279B F2AE                    	repne	scasb		; Look for matching switch
 21534 0000279D 7507                    	jnz	short BADSW
 21535 0000279F B80100                  	mov	ax,1
 21536 000027A2 D3E0                    	shl	ax,cl		; Set a bit for the switch
 21537 000027A4 09C3                    	or	bx,ax
 21538                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21539 000027A6 EBD4                    	jmp	short SWLOOP
 21540                                  ;BADSW:
 21541                                  	;jmp	short SWLOOP
 21542                                  ;DRVBAD:
 21543                                  ;	mov	dx,baddrv_ptr
 21544                                  ;	jmp	cerror
 21545                                  EXTERNALJ:
 21546 000027A8 E90501                  	jmp	EXTERNAL
 21547                                  FNDCOM:				; search the internal command table
 21548 000027AB 08C0                    	or	al,al		; Get real length of first arg
 21549 000027AD 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21550                                  				;  to be external.
 21551                                  ; barryf code starts here
 21552                                  
 21553 000027AF E82703                  	call	test_append	; see if APPEND installed
 21554 000027B2 7429                    	jz	short CONTCOM	; not loaded
 21555                                  
 21556                                  APPEND_INTERNAL:
 21557 000027B4 8A0E[2B8B]              	mov	cl,[IDLEN]
 21558 000027B8 B500                    	mov	ch,0
 21559 000027BA 890E[008C]              	mov	[PathPos],cx
 21560                                  	
 21561                                  	; 25/02/2023	
 21562                                  	; MSDOS 6.0
 21563 000027BE FE06[968D]              	inc 	byte [append_exec]
 21564                                  				;AN041; set APPEND to ON
 21565 000027C2 E8B603                  	call	IOSET		; re-direct the o'l io
 21566                                  
 21567 000027C5 BE[2B8B]                	mov	si,IDLEN	; address command name, DS already set	
 21568 000027C8 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21569                                  		
 21570                                  	; MSDOS 6.0
 21571 000027CB BF[BB4D]                	mov	di,append_parse
 21572                                  				;AN010; Get the entry point for PARSE for APPEND
 21573                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21574 000027CE B801AE                  	mov	ax,0AE01h
 21575 000027D1 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21576                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21577                                  			; DX = FFFFh, DS:SI -> buffer
 21578                                  			; Return: buffer at DS:SI filled with a	length byte
 21579                                  			; followed by the uppercase internal command
 21580                                  			; to execute (if length not 0)
 21581                                  	; 25/02/2023
 21582                                  	; INT 2Fh
 21583                                  	; 	AX = AE01h
 21584                                  	; entry:
 21585                                  	; 	DX = magic value FFFFh
 21586                                  	; 	CH = 00h
 21587                                  	; 	CL = length of command name
 21588                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21589                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21590                                  	; return:
 21591                                  	;	DS:SI buffer updated
 21592                                  	;	if length byte is nonzero, the following bytes contain
 21593                                  	;	the uppercase internal command to execute and the command line
 21594                                  	; 	buffer contains the command's parameters
 21595                                  	;	(the first DS:[SI] bytes are ignored)
 21596                                  	;
 21597                                  	; Format of COMMAND.COM command line buffer:
 21598                                  	;	Offset  Size    Description
 21599                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21600                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21601                                  	;	N BYTEs command line text, terminated by 0Dh
 21602                                  	;
 21603                                  	; Format of command name buffer:
 21604                                  	;	Offset  Size    Description
 21605                                  	;	00h     BYTE    length of command name
 21606                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21607                                  
 21608 000027D3 803E[2B8B]00            	cmp	byte [IDLEN],0 ; execute requested
 21609 000027D8 7503                    	jne	short CONTCOM
 21610 000027DA E9A300                  	jmp	CMD_DONE
 21611                                  
 21612                                  	;nop
 21613                                  CONTCOM:			; continue with internal scan
 21614 000027DD BF[B082]                	mov	di,COMTAB
 21615 000027E0 31C9                    	xor	cx,cx
 21616                                  FINDCOM:
 21617 000027E2 BE[2C8B]                	mov	si,ID		; pointer to command argument
 21618 000027E5 8A0D                    	mov	cl,[di]		; load length of internal command
 21619 000027E7 47                      	inc	di		; advance past length
 21620 000027E8 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21621 000027EA 3A0E[2B8B]              	cmp	cl,[IDLEN]	; that of the command argument
 21622 000027EE 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21623 000027F0 890E[008C]              	mov	[PathPos],cx	; store length of command
 21624 000027F4 F3A6                    	repe	cmpsb
 21625                                  ABCD:					
 21626 000027F6 9F                      	lahf			; save the good ol' flags
 21627 000027F7 01CF                    	add	di,cx		; skip over remaining internal, if any
 21628 000027F9 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21629 000027FB A2[B58A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21630 000027FE 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21631 000027FF 8B1D                    	mov	bx,[di]		; load internal command address
 21632 00002801 47                      	inc	di		; skip over the puppy
 21633 00002802 47                      	inc	di
 21634                                  		
 21635                                  	; MSDOS 6.0
 21636 00002803 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21637 00002805 47                      	inc	di
 21638 00002806 47                      	inc	di
 21639 00002807 9E                      	sahf			; remember those flags?
 21640 00002808 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21641                                  
 21642                                  ; All messages get redirected.
 21643                                  
 21644 0000280A 803E[968D]00            	cmp     byte [append_exec],0
 21645                                  				;AN041; APPEND just executed?
 21646 0000280F 7503                    	jnz 	short DONT_SET_IO
 21647                                  				;AN041; Yes - this junk is already set
 21648 00002811 E86703                  	call	IOSET		; re-direct the ol' i/o
 21649                                  
 21650                                  DONT_SET_IO:			;AN041;
 21651                                  
 21652                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21653                                  ; respond to /? only if it is the only command-line argument.
 21654                                  
 21655 00002814 A1[BA8A]                	mov	ax,[COMSW]	; AX = switches after command
 21656 00002817 0B06[C08A]              	or	ax,[AllSwitch]	; AX = all switches
 21657                                  	;and	ax,SwitchQues	
 21658 0000281B 83E020                  	and	ax,20h
 21659 0000281E 7426                    	jz	short DRIVE_CHECK
 21660                                  				; /? not in command line
 21661 00002820 F606[B58A]04            	test	byte [CHKDRV],4	
 21662                                  	;test	byte [CHKDRV],fLimitHelp
 21663 00002825 7407                    	jz	short DO_HELP	; /? allowed in combination
 21664                                  
 21665                                  ; Make sure /? is the only argument on the command line.
 21666                                  
 21667 00002827 833E[7090]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21668 0000282C 7518                    	jne	short DRIVE_CHECK
 21669                                  				; /? not only arg - ignore
 21670                                  
 21671                                  ; Note: this is all the check we need, even against things like /??.
 21672                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21673                                  
 21674                                  DO_HELP:
 21675                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21676                                  
 21677 0000282E 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21678                                      	;mov	ax,no_subst	; AL = no subst's code
 21679 00002830 B80000                  	mov	ax,0
 21680 00002833 50                      	push	ax		; build subst block on stack
 21681                                  
 21682                                  NEXT_HELP_MSG:
 21683 00002834 AD                      	lodsw			; AX = help msg # or zero
 21684 00002835 09C0                    	or	ax,ax
 21685 00002837 7409                    	jz	short HELP_DONE
 21686 00002839 50                      	push	ax		; SS:SP = ptr to subst block
 21687                                  				; (msg # and no_subst byte)
 21688                                  ;; We assume DS = SS.
 21689                                  	
 21690 0000283A 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21691 0000283C E89225                  	call	std_printf	; display help message	
 21692 0000283F 58                      	pop	ax		; remove msg # from stack
 21693 00002840 EBF2                    	jmp	short NEXT_HELP_MSG
 21694                                  
 21695                                  HELP_DONE:
 21696 00002842 58                      	pop	ax		; clean up stack
 21697 00002843 E9BED8                  	jmp	TCOMMAND	
 21698                                  
 21699                                  	; 25/02/2023
 21700                                  	; MSDOS 3.3
 21701                                  	;sahf			; remember those flags?
 21702                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21703                                  	;call	IOSET		; re-direct the ol' i/o
 21704                                  
 21705                                  DRIVE_CHECK:
 21706 00002846 F606[B58A]01            	test	byte [CHKDRV],1
 21707                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21708                                  				; did we wanna check those drives?
 21709 0000284B 7411                    	jz	short NOCHECK
 21710 0000284D A0[B88A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21711 00002850 0A06[B98A]              	or	al,[PARM2]	; us whether those drives were OK
 21712 00002854 3CFF                    	cmp	al,-1
 21713 00002856 7506                    	jne	short NOCHECK
 21714                                  	;jmp	DRVBAD
 21715                                  	; 25/02/2023
 21716                                  DRVBAD:
 21717 00002858 BA[587F]                	mov	dx,baddrv_ptr
 21718 0000285B E9F200                  	jmp	cerror
 21719                                  
 21720                                  ; The user may have omitted the space between the command and its arguments.
 21721                                  ; We need to copy the remainder of the user's command line into the buffer.
 21722                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21723                                  ; into the command line at 80.
 21724                                  
 21725                                  NOCHECK:
 21726 0000285E E85B02                  	call	cmd_copy
 21727                                  SWITCHECK:
 21728                                  	;test	byte [CHKDRV],2
 21729 00002861 F606[B58A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21730                                  				; Does the command take switches
 21731 00002866 7516                    	jnz	short REALWORK	; Yes, process the command
 21732 00002868 E82F00                  	call	noswit		; No, check to see if any switches
 21733 0000286B 7511                    	jnz	short REALWORK	; None, process the command
 21734                                  
 21735                                  	; MSDOS 6.0
 21736                                  	;mov	byte [msg_disp_class],2
 21737 0000286D C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class
 21738                                  				;AN000; set up parse error msg class
 21739 00002872 BA[FC7E]                	mov	dx,extend_buf_ptr	
 21740                                  				;AC000; get extended message pointer
 21741                                  	;mov	word [extend_buf_ptr],3
 21742 00002875 C706[FC7E]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21743                                  				;AN000; get "Invalid switch" message number
 21744 0000287B E9D200                  	jmp	cerror		; Print error and chill out...
 21745                                  
 21746                                  	; 25/02/2023
 21747                                  	; MSDOS 3.3
 21748                                  	;mov	dx,BADPARMPTR
 21749                                  	;jmp	CERROR
 21750                                  
 21751                                  REALWORK:
 21752 0000287E FFD3                    	call	bx		; do some real work, at last
 21753                                  
 21754                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21755                                  ; otherwise, go get another command.
 21756                                  
 21757                                  CMD_DONE:
 21758 00002880 0E                      	push	cs		; g  restore data segment
 21759 00002881 1F                      	pop	ds		; g
 21760 00002882 1E                      	push	ds
 21761 00002883 8E1E[A58A]              	mov	ds,[RESSEG]	; g  save data segment
 21762                                  	;cmp	byte [Call_Flag],1
 21763                                  				; G  Is a call in progress?
 21764 00002887 803E[9901]01            	cmp	byte [Call_Flag],call_in_progress
 21765 0000288C C606[9901]00            	mov	byte [Call_Flag],0
 21766                                  				; G  Either way, reset flag
 21767 00002891 1F                      	pop	ds		; g  get data segment back
 21768 00002892 7403                    	jz	short INCALL	; G
 21769 00002894 E96DD8                  	jmp	TCOMMAND	; chill out...
 21770                                  INCALL:
 21771 00002897 E93DDA                  	jmp	DOCOM1
 21772                                  
 21773                                  ; =============== S U B	R O U T	I N E =======================================
 21774                                  
 21775                                  	; 25/02/2023
 21776                                  noswit:
 21777 0000289A 57                      	push	di		; Save di
 21778 0000289B BF8100                  	mov	di,81h		; di = ptr to command args
 21779 0000289E BE8000                  	mov	si,80h		; Get address of length of command args
 21780 000028A1 AC                      	lodsb			; Load length
 21781 000028A2 88C1                    	mov	cl,al		; Move length to cl
 21782 000028A4 30ED                    	xor	ch,ch		; Zero ch
 21783 000028A6 2EA0[A98A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21784                                  	;cmp	al,0		; Turn off ZF
 21785                                  	; 25/02/2023
 21786 000028AA 20C0                    	and	al,al
 21787 000028AC F2AE                    	repne	scasb		; Scan for a switch character and return
 21788 000028AE 5F                      	pop	di		;  with ZF set if one was found
 21789 000028AF C3                      	retn
 21790                                  
 21791                                  ; ---------------------------------------------------------------------------
 21792                                  
 21793                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21794                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21795                                  
 21796                                  EXTERNAL:
 21797 000028B0 E82602                  	call	test_append	; check to see if append installed
 21798 000028B3 7403                    	jz	short NOT_BARRYF
 21799                                  				; no - truly external command
 21800 000028B5 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21801                                  
 21802                                  NOT_BARRYF:
 21803 000028B8 2EC606[B68A]00          	mov	byte [cs:FILTYP],0
 21804 000028BE 2E8A16[C38A]            	mov	dl,[cs:SPECDRV]
 21805 000028C3 2E8816[2B8B]            	mov	[cs:IDLEN],dl
 21806 000028C8 2EC606[238C]00          	mov	byte [cs:ROM_CALL],0
 21807 000028CE 52                      	push	dx
 21808 000028CF BA[2B8B]                	mov	dx,IDLEN
 21809 000028D2 E825DB                  	call	ROM_SCAN
 21810 000028D5 5A                      	pop	dx
 21811                                  	;jnc	short POSTSAVE
 21812 000028D6 7305                    	jnc	short DO_SCAN
 21813 000028D8 2EFE06[238C]            	inc	byte [cs:ROM_CALL]
 21814                                  	;jmp	short POSTSAVE
 21815                                  
 21816                                  	;nop
 21817                                  DO_SCAN:
 21818                                  POSTSAVE:
 21819 000028DD BF[CD89]                	mov	di,EXECPATH
 21820 000028E0 C60500                  	mov	byte [di],0	; Initialize to current directory
 21821                                  	
 21822 000028E3 2E803E[238C]00          	cmp	byte [cs:ROM_CALL],0
 21823                                  	;jz	short RESEARCH
 21824                                  	; 25/02/2023
 21825                                  	;jmp	short NEOEXECUTE
 21826 000028E9 750F                    	jnz	short NEOEXECUTE	
 21827                                  
 21828                                  	;nop
 21829                                  RESEARCH:
 21830 000028EB E87208                  	call	path_search	; find the mother (result in execpath)
 21831 000028EE 09C0                    	or	ax,ax		; did we find anything?
 21832                                  	;jz	short BADCOMJ45	; null means no (sob)
 21833                                  	; 25/02/2023
 21834 000028F0 7459                    	jz	short BADCOM
 21835 000028F2 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21836                                  				; fuckin' sixteen-bit machine ought
 21837                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21838                                  				; DISPLACEMENT!!
 21839                                  	;;jmp	short NEOEXECUTE
 21840                                  	;jmp	short EXECUTE	
 21841                                  	; 25/02/2023
 21842 000028F5 7D03                    	jnl	short EXECUTE ; jge
 21843                                  
 21844                                  	; 02H is .bat
 21845                                  
 21846                                  	;nop
 21847                                  BATCOMJ:
 21848 000028F7 E990DE                  	jmp	BATCOM
 21849                                  
 21850                                  	; 25/02/2023
 21851                                  ;BADCOMJ45:
 21852                                  	;jmp	short BADCOM
 21853                                  
 21854                                  	;nop
 21855                                  EXECUTE:
 21856                                  NEOEXECUTE:
 21857 000028FA E87E02                  	call	IOSET
 21858                                  
 21859                                  ; MSDOS 6.0
 21860                                  ;M051
 21861                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21862                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21863                                  ;After a close, this would still leave one open active resulting in sharing
 21864                                  ;errors on subsequent opens of the redirected file.
 21865                                  
 21866                                  LH_EXECUTE:			;M051	
 21867 000028FD 8E06[B38A]              	mov	es,[TRAN_TPA]
 21868                                  	;mov	ah,DEALLOC ; 49h
 21869 00002901 B449                    	mov	ah,49h
 21870 00002903 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21871                                  			; ES = segment address of area to be freed
 21872                                  				; Now running in "free" space
 21873 00002905 8E06[A58A]              	mov	es,[RESSEG]
 21874 00002909 26FE06[8401]            	inc	byte [es:ExtCom] ; Indicate external command
 21875 0000290E 26C606[8C01]00          	mov	byte [es:RestDir],0 
 21876                                  				; Since USERDIR1 is in transient, insure
 21877                                  				; this flag value for re-entry to COMMAND
 21878                                  	; MSDOS 6.0
 21879 00002914 BE[CD89]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21880 00002917 BF[4903]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21881                                  	;mov	cx,LENMSGORPATHBUF
 21882 0000291A B95000                  	mov	cx,80
 21883 0000291D FC                      	cld
 21884 0000291E F3A4                    	rep	movsb		; copy program pathname to resident
 21885                                  
 21886                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21887 00002920 BF5C00                  	mov	di,FCB ; 5Ch
 21888 00002923 89FE                    	mov	si,di
 21889                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21890 00002925 B152                    	mov	cl,82 ; 25/02/2023
 21891 00002927 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21892                                  	
 21893                                  	; 25/02/2023
 21894                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21895                                  	; MSDOS 6.0 (& 5.0)
 21896                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21897 00002929 BA[4903]                	mov	dx,SafePathBuffer
 21898 0000292C 06                      	push	es
 21899 0000292D 1F                      	pop	ds
 21900                                  
 21901                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21902 0000292E BB[2703]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21903                                  	;mov	ax,EXEC*256 ; 4B00h
 21904 00002931 B8004B                  	mov	ax,4B00h
 21905                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21906 00002934 2EF606[238C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21907 0000293A 7403                    	jz	short OK_EXEC
 21908 0000293C E934DB                  	jmp	ROM_EXEC
 21909                                  
 21910                                  OK_EXEC:
 21911                                  
 21912                                  ; we are now running in free space. Anything we do from here on may get
 21913                                  ; trashed. Move the stack (also in free space) to allocated space because
 21914                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21915                                  
 21916 0000293F 8CC1                    	mov	cx,es
 21917 00002941 8ED1                    	mov	ss,cx
 21918 00002943 BC[1E04]                	mov	sp,RStack
 21919                                  	; MSDOS 3.3
 21920                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21921                                  	; 25/02/2023
 21922                                  	; MSDOS 6.0
 21923 00002946 2EFF2E[AB8A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21924                                  
 21925                                  ; ---------------------------------------------------------------------------
 21926                                  
 21927                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21928                                  BADCOM:
 21929 0000294B 0E                      	push	cs
 21930 0000294C 1F                      	pop	ds
 21931 0000294D BA[1F7F]                	mov	dx,BADNAM_PTR
 21932                                  cerror:		
 21933 00002950 E87624                  	call	std_eprintf
 21934 00002953 E9AED7                  	jmp	TCOMMAND
 21935                                  
 21936                                  ; =============== S U B	R O U T	I N E =======================================
 21937                                  
 21938                                  ; Prescan converts the input buffer into a canonicalized form.
 21939                                  ; All redirections and pipes are removed.
 21940                                  
 21941                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21942                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21943                                  
 21944                                  PRESCAN:
 21945 00002956 31C9                    	xor	cx,cx
 21946 00002958 8E06[A58A]              	mov	es,[RESSEG]
 21947 0000295C BE[0689]                	mov	si,COMBUF+2
 21948 0000295F 89F7                    	mov	di,si
 21949                                  COUNTQUOTES:
 21950 00002961 AC                      	lodsb			; get a byte
 21951 00002962 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21952 00002964 7504                    	jne	short COUNTEND	; no, try for end of road
 21953 00002966 FEC5                    	inc	ch		; bump count
 21954 00002968 EBF7                    	jmp	short COUNTQUOTES
 21955                                  				; go get next char
 21956                                  COUNTEND:
 21957 0000296A 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21958 0000296C 75F3                    	jne	short COUNTQUOTES
 21959                                  				; no, go back for next char
 21960                                  	; 26/02/2023
 21961                                  	; MSDOS 5.0 (& 6.0)
 21962 0000296E 51                      	push	cx		; save count
 21963 0000296F 89FE                    	mov	si,di		; restore pointer to begining
 21964                                  KanjiScan:
 21965 00002971 AC                      	lodsb			; get a byte
 21966 00002972 E848FA                  	call	testkanj	; is it a leadin byte
 21967 00002975 740F                    	jz	short KanjiQuote
 21968                                  				; no, check for quotes
 21969 00002977 88C4                    	mov	ah,al		; save leadin
 21970 00002979 AC                      	lodsb			; get trailing byte
 21971 0000297A 3D2020                  	cmp	ax,2020h
 21972                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21973 0000297D 75F2                    	jne	short KanjiScan	; no, go get next
 21974 0000297F C744FE2020              	mov	word [si-2],2020h
 21975                                  				; replace with spaces
 21976 00002984 EBEB                    	jmp	short KanjiScan	; go get next char
 21977                                  	
 21978                                  KanjiQuote:
 21979 00002986 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21980 00002988 750D                    	jne	short KanjiEnd	; no, check for end
 21981 0000298A FECD                    	dec	ch		; drop count
 21982 0000298C 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21983                                  KanjiQuoteLoop:
 21984 0000298E AC                      	lodsb			; get next byte
 21985 0000298F 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21986 00002991 75FB                    	jne	short KanjiQuoteLoop
 21987                                  				; no, get another
 21988 00002993 FECD                    	dec	ch		; yes, drop count
 21989 00002995 EBDA                    	jmp	short KanjiScan	; go get next char
 21990                                  KanjiEnd:
 21991 00002997 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21992 00002999 75D6                    	jne	short KanjiScan	; go back to beginning
 21993 0000299B 59                      	pop	cx		; get back original count
 21994                                  	; 26/04/2023
 21995 0000299C 89FE                    	mov	si,di		; restore pointer to beginning
 21996                                  	
 21997                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21998                                  PRESCANLP:
 21999 0000299E AC                      	lodsb
 22000                                  	; 26/02/2023
 22001 0000299F E81BFA                  	call	testkanj
 22002 000029A2 740C                    	jz	short NOTKANJ6
 22003                                  	; MSDOS 6.0
 22004 000029A4 8805                    	mov	[di],al
 22005 000029A6 47                      	inc	di		; fake STOSB into DS
 22006 000029A7 AC                      	lodsb			; grab second byte
 22007 000029A8 8805                    	mov	[di],al		; fake stosb into DS
 22008 000029AA FEC1                    	inc	cl
 22009 000029AC FEC1                    	inc	cl
 22010 000029AE EBEE                    	jmp	short PRESCANLP
 22011                                  
 22012                                  NOTKANJ6:
 22013                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22014 000029B0 3C22                    	cmp	al,'"'	; 22h	; " character
 22015 000029B2 7510                    	jne	short TRYGREATER
 22016 000029B4 FECD                    	dec	ch
 22017 000029B6 740C                    	jz	short TRYGREATER
 22018                                  QLOOP:
 22019 000029B8 8805                    	mov	[di],al
 22020 000029BA 47                      	inc	di
 22021 000029BB FEC1                    	inc	cl
 22022 000029BD AC                      	lodsb
 22023 000029BE 3C22                    	cmp	al,'"'		; " character
 22024 000029C0 75F6                    	jne	short QLOOP
 22025 000029C2 FECD                    	dec	ch
 22026                                  TRYGREATER:
 22027 000029C4 3C3E                    	cmp	al,'>' ; 3Eh
 22028                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 22029                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 22030 000029C6 7557                    	jne	short NOOUT
 22031                                  
 22032                                  ; We have found a ">" char. We need to see if there is another ">"
 22033                                  ; following it.
 22034                                  
 22035 000029C8 3804                    	cmp	[si],al
 22036 000029CA 7506                    	jne	short NOAPPND
 22037 000029CC AC                      	lodsb
 22038 000029CD 26FE06[AE01]            	inc	byte [es:Re_Out_App] ; Flag >>
 22039                                  NOAPPND:
 22040                                  ; Now we attempt to find the file name. First, scan off all whitespace
 22041                                  
 22042 000029D2 E807FC                  	call	scanoff
 22043                                  
 22044                                  	; 26/02/2023
 22045                                  	; MSDOS 6.0
 22046 000029D5 3C3C                    	cmp	al,'<' ; 3Ch
 22047                                  	;cmp	al,labracket	;AN040; was there no filename?
 22048 000029D7 7404                    	je	short REOUT_ERRSET
 22049                                  				;AN040; yes - set up error
 22050                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22051 000029D9 3C0D                    	cmp	al,0Dh
 22052 000029DB 750D                    	jnz	short GOTREOFIL
 22053                                  
 22054                                  ; There was no file present. Set us up at end-of-line.
 22055                                  
 22056                                  REOUT_ERRSET:			;AN040; set up for an error
 22057 000029DD C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 22058 000029E0 26C706[AF01]0900        	mov	word [es:Re_OutStr],9
 22059                                  				; Cause an error later
 22060 000029E7 E9A900                  	jmp	PRESCANEND
 22061                                  
 22062                                  GOTREOFIL:
 22063 000029EA 57                      	push	di
 22064                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 22065 000029EB BF[AF01]                	mov	di,Re_OutStr
 22066 000029EE 89FB                    	mov	bx,di
 22067 000029F0 06                      	push	es
 22068                                  
 22069                                  	; 26/02/2023
 22070                                  	; MSDOS 6.0
 22071                                  SETREOUTSTR:			; Get the output redirection name
 22072                                  				; MSKK06 07/14/89
 22073 000029F1 51                      	push	cx		; save cx
 22074 000029F2 B94D00                  	mov	cx,64+13	; CX = max string length
 22075                                  SETREOUTSTR_LOOP:
 22076 000029F5 AC                      	lodsb
 22077 000029F6 3C0D                    	cmp	al,0Dh
 22078 000029F8 741A                    	je	short GOTRESTR_J
 22079 000029FA E8E7FB                  	call	DELIM
 22080 000029FD 7415                    	jz	short GOTRESTR_J
 22081 000029FF 3A06[A98A]              	cmp	al,[SWITCHAR]
 22082 00002A03 740F                    	je	short GOTRESTR_J
 22083 00002A05 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 22084 00002A07 7413                    	je	short PIPEERRSYNJ5_J
 22085                                  				;AN033; Yes - get out quick - or system crashes
 22086 00002A09 3C3C                    	cmp	al,'<' ; 3Ch
 22087                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 22088 00002A0B 7404                    	je	short ABRACKET_TERM
 22089                                  				;AN002; yes - end of string
 22090 00002A0D 3C3E                    	cmp	al,'>' ; 3Eh
 22091                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 22092 00002A0F 7506                    	jne	short NO_ABRACKET
 22093                                  				;AN002; no - not end of string
 22094                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 22095 00002A11 4E                      	dec	si		;AN002; back up over symbol
 22096 00002A12 B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 22097                                  GOTRESTR_J:
 22098 00002A14 59                      	pop	cx		; MSKK06 07/14/89
 22099 00002A15 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 22100                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 22101 00002A17 AA                      	stosb			; store it into resgroup
 22102 00002A18 E2DB                    	loop	SETREOUTSTR_LOOP
 22103                                  				; MSKK06 07/14/89
 22104 00002A1A EBF8                    	jmp	short GOTRESTR_J
 22105                                  PIPEERRSYNJ5_J:
 22106 00002A1C 59                      	pop	cx		; recover CX
 22107 00002A1D EB4B                    	jmp	short PIPEERRSYNJ5
 22108                                  
 22109                                  	; 26/02/2023
 22110                                  ;	; MSDOS 3.3
 22111                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 22112                                  ;	lodsb
 22113                                  ;	cmp	al,0Dh
 22114                                  ;	jz	short GOTRESTR
 22115                                  ;	call	DELIM
 22116                                  ;	jz	short GOTRESTR
 22117                                  ;	cmp	al,[SWITCHAR]
 22118                                  ;	je	short GOTRESTR
 22119                                  ;	cmp	al,'"'
 22120                                  ;	jne	short NO_ABRACKET
 22121                                  ;	dec	ch
 22122                                  ;NO_ABRACKET:
 22123                                  ;	stosb
 22124                                  ;	jmp	short SETREOUTSTR_LOOP
 22125                                  
 22126                                  NOOUT:
 22127                                  	; 26/02/2023
 22128                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22129 00002A1F 3C3C                    	cmp	al, '<' ; 3Ch
 22130                                  	;cmp	al,labracket	; MSDOS 6.0
 22131                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 22132 00002A21 7523                    	jne	short CHKPIPE
 22133 00002A23 89F3                    	mov	bx,si		; Save loc of "<"
 22134 00002A25 E8B4FB                  	call	scanoff
 22135                                  	; MSDOS 6.0
 22136 00002A28 3C3E                    	cmp	al,'>' ; 3Eh
 22137                                  	;cmp	al,rabracket	;AN040; was there no filename?
 22138 00002A2A 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 22139                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22140 00002A2C 3C0D                    	cmp	al,0Dh
 22141 00002A2E 750B                    	jne	short GOTREIFIL
 22142                                  REIN_ERRSET:			;AN040; set up for error
 22143 00002A30 C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 22144 00002A33 C706[508A]0900          	mov	word [RE_INSTR],9 
 22145                                  				; Cause an error later
 22146 00002A39 EB58                    	jmp	short PRESCANEND
 22147                                  GOTREIFIL:
 22148 00002A3B 57                      	push	di
 22149 00002A3C BF[508A]                	mov	di,RE_INSTR
 22150 00002A3F 89FB                    	mov	bx,di
 22151 00002A41 06                      	push	es
 22152 00002A42 0E                      	push	cs
 22153 00002A43 07                      	pop	es		; store in TRANGROUP
 22154                                  	; 26/04/2023
 22155                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 22156 00002A44 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 22157                                  				; Get the input redirection name
 22158                                  CHKPIPE:
 22159 00002A46 88C4                    	mov	ah,al
 22160                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22161 00002A48 80FC7C                  	cmp	ah,'|' ; 7Ch
 22162                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 22163                                  	;je	short ISPIPE3
 22164                                  	;; MSDOS 6.0
 22165                                  	;cmp	ah,'|' ; 7Ch
 22166                                  	;;cmp	al,vbar ; 7Ch
 22167                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 22168 00002A4B 7539                    	jne	short CONTPRESCAN
 22169                                  ISPIPE3:
 22170                                  ; Only push the echo flag if we are entering the pipe for the first time.
 22171                                  
 22172 00002A4D 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22173 00002A53 7505                    	jne	short NOECHOPUSH
 22174 00002A55 26D026[8801]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 22175                                  NOECHOPUSH:
 22176 00002A5A 26FE06[0002]            	inc	byte [es:PipeFlag]
 22177 00002A5F E87AFB                  	call	scanoff
 22178 00002A62 3C0D                    	cmp	al,0Dh
 22179 00002A64 7404                    	je	short PIPEERRSYNJ5
 22180                                  	; 26/02/2023
 22181 00002A66 3C7C                    	cmp	al,'|' ; 7Ch
 22182                                  	;cmp	al,ALTPIPECHR ; 7Ch
 22183                                  	;je	short PIPEERRSYNJ5
 22184                                  	;; MSDOS 6.0
 22185                                  	;cmp	al,'|' ; 7Ch
 22186                                  	;;cmp	al,vbar ; 7Ch
 22187                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 22188 00002A68 751C                    	jne	short CONTPRESCAN
 22189                                  
 22190                                  PIPEERRSYNJ5:
 22191 00002A6A 06                      	push	es
 22192 00002A6B 1F                      	pop	ds
 22193 00002A6C E99C02                  	jmp	PIPEERRSYN
 22194                                  
 22195                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 22196                                  ; than just a : in the redir string.
 22197                                  
 22198                                  GOTRESTR:
 22199 00002A6F 86E0                    	xchg	ah,al
 22200 00002A71 B03A                    	mov	al,':' ; 3Ah
 22201 00002A73 29FB                    	sub	bx,di		; compute negative of number of chars
 22202 00002A75 83FBFF                  	cmp	bx,-1		; is there just a :?
 22203 00002A78 7407                    	je	short NOTRAILCOL ; yep, don't change
 22204 00002A7A 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 22205 00002A7E 7501                    	jne	short NOTRAILCOL
 22206 00002A80 4F                      	dec	di		; Back up over trailing ':'
 22207                                  NOTRAILCOL:
 22208 00002A81 30C0                    	xor	al,al
 22209 00002A83 AA                      	stosb			; NUL terminate the string
 22210 00002A84 07                      	pop	es
 22211 00002A85 5F                      	pop	di		; Remember the start
 22212                                  CONTPRESCAN:
 22213 00002A86 8825                    	mov	[di],ah		; "delete" the redirection string
 22214 00002A88 47                      	inc	di
 22215 00002A89 80FC0D                  	cmp	ah,0Dh
 22216 00002A8C 7405                    	je	short PRESCANEND
 22217 00002A8E FEC1                    	inc	cl
 22218 00002A90 E90BFF                  	jmp	PRESCANLP
 22219                                  PRESCANEND:
 22220 00002A93 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22221 00002A99 7414                    	jz	short ISNOPIPE
 22222                                  
 22223                                  	; 26/02/2023
 22224                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 22225                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 22226                                  	;;			; (EndInit+160]
 22227                                  	;mov	di,offset RESGROUP:PIPESTR
 22228 00002A9B BF[A202]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 22229                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 22230                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 22231 00002A9E 26893E[A002]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 22232                                  	
 22233 00002AA3 BE[0689]                	mov	si,COMBUF+2
 22234 00002AA6 E833FB                  	call	scanoff
 22235                                  PIPESETLP:			; Transfer the pipe into the resident
 22236 00002AA9 AC                      	lodsb			; pipe buffer
 22237 00002AAA AA                      	stosb
 22238 00002AAB 3C0D                    	cmp	al,0Dh
 22239 00002AAD 75FA                    	jnz	short PIPESETLP
 22240                                  ISNOPIPE:
 22241 00002AAF 880E[0589]              	mov	[COMBUF+1],cl
 22242 00002AB3 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22243 00002AB9 0E                      	push	cs
 22244 00002ABA 07                      	pop	es
 22245 00002ABB C3                      	retn
 22246                                  
 22247                                  ; =============== S U B	R O U T	I N E =======================================
 22248                                  
 22249                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22250                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 22251                                  cmd_copy:
 22252 00002ABC BE[0689]                	mov	si,COMBUF+2
 22253 00002ABF E81AFB                  	call	scanoff		; advance past separators...
 22254 00002AC2 0336[008C]              	add	si,[PathPos]
 22255 00002AC6 BF8100                  	mov	di,81h
 22256 00002AC9 31C9                    	xor	cx,cx
 22257                                  cmdcopy:
 22258 00002ACB AC                      	lodsb
 22259 00002ACC AA                      	stosb
 22260 00002ACD 3C0D                    	cmp	al,0Dh
 22261 00002ACF 7403                    	je	short copy_done
 22262 00002AD1 41                      	inc	cx
 22263 00002AD2 EBF7                    	jmp	short cmdcopy
 22264                                  copy_done:
 22265 00002AD4 880E8000                	mov	[80h],cl
 22266 00002AD8 C3                      	retn
 22267                                  
 22268                                  ; =============== S U B	R O U T	I N E =======================================
 22269                                  
 22270                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22271                                  test_append:
 22272 00002AD9 BB[0489]                	mov	bx,COMBUF	; barry can address
 22273 00002ADC BE[2B8B]                	mov	si,IDLEN	; address command name, DS already set 	
 22274 00002ADF BAFFFF                  	mov	dx,-1
 22275 00002AE2 B800AE                  	mov	ax,0AE00h
 22276 00002AE5 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 22277                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 22278                                  			; DX = FFFFh,[BX -> command line
 22279                                  			; Return: AL = FFh if this command is a TSR extension 
 22280                                  			;		   to COMMAND.COM
 22281                                  			; AL = 00h if the command should be executed as	usual
 22282                                  	;cmp	al,0
 22283 00002AE7 08C0                    	or	al,al ; 25/02/2023
 22284 00002AE9 C3                      	retn
 22285                                  
 22286                                  	; 25/02/2023
 22287                                  	; INT 2Fh
 22288                                  	; 	AX = AE00h
 22289                                  	; entry:
 22290                                  	; 	DX = magic value FFFFh
 22291                                  	; 	CH = FFh
 22292                                  	; 	CL = length of command line tail
 22293                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22294                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22295                                  	; return:
 22296                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 22297                                  	;	AL = 00h if the command should be executed as usual
 22298                                  	;
 22299                                  	; Format of COMMAND.COM command line buffer:
 22300                                  	;	Offset  Size    Description
 22301                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22302                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22303                                  	;	N BYTEs command line text, terminated by 0Dh
 22304                                  	;
 22305                                  	; Format of command name buffer:
 22306                                  	;	Offset  Size    Description
 22307                                  	;	00h     BYTE    length of command name
 22308                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22309                                  
 22310                                  ;============================================================================
 22311                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 22312                                  ;============================================================================
 22313                                  ; 05/10/2018 - Retro DOS v3.0
 22314                                  
 22315                                  ;	More misc routines
 22316                                  
 22317                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 22318                                  
 22319                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22320                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 22321                                  
 22322                                  ; =============== S U B	R O U T	I N E =======================================
 22323                                  
 22324                                  SETPATH:
 22325                                  
 22326                                  ; ENTRY PathPos = ptr to string
 22327                                  ;       PathCnt = length of string
 22328                                  ;
 22329                                  ; EXIT  PathPos = ptr to string after pathname
 22330                                  ;       PathCnt = length of rest of string
 22331                                  ;       DX = ptr to pathname in string, made ASCIIZ
 22332                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 22333                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 22334                                  ;
 22335                                  ;       A null character is dropped at the end of the pathname. If the
 22336                                  ;       character in that spot previously was CR, it is copied into the
 22337                                  ;       following byte. So there must be at least two two character 
 22338                                  ;       positions in the buffer following the pathname.
 22339                                  
 22340                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22341                                  	; 11/06/2023
 22342                                  	; MSDOS 6.0
 22343                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 22344                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 22345                                  
 22346                                  	; 26/02/2023
 22347                                  	; MSDOS 3.3
 22348                                  	;mov	si,80h
 22349                                  	;lodsb
 22350                                  	;xor	ah,ah
 22351                                  	;mov	[PATCNT],ax
 22352                                  	;mov	[PATHPOS],si
 22353                                  GETPATH:
 22354                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22355 00002AEA C606[2C8C]00            	mov	byte [DestInfo],0
 22356 00002AEF C606[288C]00            	mov	byte [DestIsDir],0
 22357 00002AF4 8B36[008C]              	mov	si,[PathPos]	; SI = ptr to string
 22358 00002AF8 8B0E[FE8B]              	mov	cx,[PathCnt]	; CX = string length
 22359 00002AFC 89F2                    	mov	dx,si		; DX = ptr to string
 22360 00002AFE E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 22361 00002B00 51                      	push	cx		; save string length
 22362 00002B01 56                      	push	si		; save ptr to string
 22363 00002B02 E875FC                  	call	SWITCH
 22364                                  
 22365                                  ;       After Switch, SI has been scanned past any switches, and
 22366                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22367                                  
 22368 00002B05 A3[028C]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22369 00002B08 5B                      	pop	bx		; BX = ptr to original string
 22370 00002B09 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22371 00002B0B 59                      	pop	cx		; CX = string length
 22372 00002B0C 01D9                    	add	cx,bx		; CX = string length from current SI
 22373 00002B0E 89F2                    	mov	dx,si		; DX = ptr to current string
 22374                                  SKIPPATH:
 22375                                  	; 26/02/2023
 22376                                  	; MSDOS 6.0
 22377 00002B10 C606[AF8D]00            	mov	byte [KPARSE],0
 22378                                  SKIPPATH2:
 22379 00002B15 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22380 00002B17 49                      	dec	cx		; CX = length left after next char
 22381 00002B18 AC                      	lodsb			; AL = next char of string
 22382                                  				; SI = ptr to char after this one
 22383                                  	; 26/02/2023
 22384 00002B19 E8A1F8                  	call	testkanj
 22385 00002B1C 7408                    	jz	short TESTPPSEP
 22386 00002B1E 49                      	dec	cx
 22387 00002B1F 46                      	inc	si
 22388 00002B20 FE06[AF8D]              	inc	byte [KPARSE]
 22389 00002B24 EBEF                    	jmp	short SKIPPATH2
 22390                                  TESTPPSEP:
 22391 00002B26 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 22392 00002B29 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22393 00002B2B FE06[288C]              	inc	byte [DestIsDir]
 22394                                  				; DestIsDir = 1, signalling path char
 22395                                  TESTPMETA:
 22396 00002B2F 3C3F                    	cmp	al,'?'
 22397 00002B31 7505                    	jne	short TESTPSTAR	; char is not '?'
 22398 00002B33 800E[2C8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22399                                  TESTPSTAR:
 22400 00002B38 3C2A                    	cmp	al,'*'
 22401                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22402 00002B3A 7505                    	jne	short TESTPDELIM ; char is not '*'
 22403 00002B3C 800E[2C8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22404                                  TESTPDELIM:
 22405 00002B41 E8A0FA                  	call	DELIM		; compare AL to all delimiters
 22406 00002B44 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22407 00002B46 3A06[A98A]              	cmp	al,[SWITCHAR]
 22408 00002B4A 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22409                                  PATHDONEDEC:
 22410 00002B4C 4E                      	dec	si		; SI = ptr to char after pathname
 22411                                  PATHDONE:
 22412 00002B4D 30C0                    	xor	al,al		; AL = NULL
 22413 00002B4F 8604                    	xchg	al,[si]		; place NULL after pathname
 22414 00002B51 46                      	inc	si		; SI = ptr to byte after NULL
 22415 00002B52 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22416 00002B54 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22417 00002B56 8804                    	mov	[si],al		; save EOL after NULL
 22418                                  NOPSTORE:
 22419 00002B58 8936[008C]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22420 00002B5C 890E[FE8B]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22421                                  SETPATH_RETN:
 22422 00002B60 C3                      	retn
 22423                                  
 22424                                  ; ---------------------------------------------------------------------------
 22425                                  
 22426                                  PGETARG:
 22427 00002B61 BE8000                  	mov	si,80h
 22428 00002B64 AC                      	lodsb
 22429 00002B65 08C0                    	or	al,al
 22430 00002B67 74F7                    	jz	short SETPATH_RETN
 22431 00002B69 E80300                  	call	PSCANOFF
 22432 00002B6C 3C0D                    	cmp	al,0Dh
 22433 00002B6E C3                      	retn
 22434                                  
 22435                                  ; ---------------------------------------------------------------------------
 22436                                  
 22437                                  PSCANOFF:
 22438 00002B6F AC                      	lodsb
 22439 00002B70 E871FA                  	call	DELIM
 22440 00002B73 7504                    	jnz	short PSCANOFFD
 22441 00002B75 3C3B                    	cmp	al,';' ; 3Bh
 22442 00002B77 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22443                                  PSCANOFFD:
 22444 00002B79 4E                      	dec	si		; Point to first non-delimiter
 22445 00002B7A C3                      	retn
 22446                                  
 22447                                  ; =============== S U B	R O U T	I N E =======================================
 22448                                  
 22449                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22450                                  IOSET:
 22451                                  	; ALL REGISTERS PRESERVED
 22452 00002B7B 1E                      	push	ds
 22453 00002B7C 52                      	push	dx
 22454 00002B7D 50                      	push	ax
 22455 00002B7E 53                      	push	bx
 22456 00002B7F 51                      	push	cx
 22457 00002B80 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22458 00002B85 803E[0002]00            	cmp	byte [PipeFlag],0
 22459 00002B8A 750D                    	jne	short NOREDIR
 22460 00002B8C F606[9301]FF            	test	byte [IfFlag],0FFh
 22461 00002B91 7506                    	jnz	short NOREDIR
 22462 00002B93 E88C00                  	call	TESTDOREIN
 22463 00002B96 E80600                  	call	TESTDOREOUT
 22464                                  NOREDIR:
 22465 00002B99 59                      	pop	cx
 22466 00002B9A 5B                      	pop	bx
 22467 00002B9B 58                      	pop	ax
 22468 00002B9C 5A                      	pop	dx
 22469 00002B9D 1F                      	pop	ds
 22470                                  IOSET_RETN:	; 06/08/2024
 22471 00002B9E C3                      	retn
 22472                                  
 22473                                  ; =============== S U B	R O U T	I N E =======================================
 22474                                  
 22475                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22476                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22477                                  	; 06/08/2024
 22478                                  TESTDOREOUT:
 22479 00002B9F 803E[AF01]00            	cmp	byte [Re_OutStr],0
 22480                                  	;je	short NOREOUT  ; MSDOS 3.3
 22481                                  	; 26/02/2023
 22482                                  	;jne	short REOUTEXISTS
 22483                                  	;jmp	NOREOUT
 22484                                  	; 06/08/2024
 22485 00002BA4 74F8                    	jz	short IOSET_RETN
 22486                                  REOUTEXISTS:
 22487 00002BA6 803E[AE01]00            	cmp	byte [Re_Out_App],0
 22488 00002BAB 745D                    	je	short REOUTCRT
 22489                                  
 22490 00002BAD BA[AF01]                	mov	dx,Re_OutStr
 22491                                  
 22492                                  	; 26/02/2023
 22493                                  	; MSDOS 6.0
 22494                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22495 00002BB0 B8023D                  	mov	ax,3D02h
 22496                                  	; MSDOS 3.3
 22497                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22498                                  	
 22499                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22500 00002BB3 50                      	push	ax
 22501 00002BB4 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22502                                  			; DS:DX	-> ASCIZ filename
 22503                                  			; AL = access mode
 22504                                  			; 1 - write
 22505 00002BB6 5B                      	pop	bx
 22506 00002BB7 724B                    	jc	short OpenWriteError
 22507                                  
 22508                                  	; 26/02/2023
 22509                                  	; MSDOS 6.0
 22510 00002BB9 89C3                    	mov	bx,ax
 22511                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22512 00002BBB B80044                  	mov	ax,4400h
 22513 00002BBE CD21                    	int	21h			;AN035;
 22514                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22515                                  			; BX = file or device handle
 22516 00002BC0 F6C280                  	test	dl,80h
 22517                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22518 00002BC3 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22519                                  
 22520                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22521 00002BC5 B80242                  	mov	ax,4202h
 22522 00002BC8 B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22523 00002BCB 89CA                    	mov	dx,cx			;AC011;
 22524 00002BCD CD21                    	int	21h
 22525                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22526                                  			; AL = method: offset from end of file
 22527 00002BCF 0E                      	push	cs			;AN011; Get transient seg to DS
 22528 00002BD0 1F                      	pop	ds			;AN011;
 22529                                  
 22530                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22531 00002BD1 B8003F                  	mov	ax,3F00h
 22532 00002BD4 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22533 00002BD7 BA[208C]                	mov	dx,One_Char_Val		;AN011;
 22534 00002BDA CD21                    	int	21h			;AN011;
 22535                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22536                                  			; BX = file handle, CX = number of bytes to read
 22537                                  			; DS:DX -> buffer
 22538 00002BDC 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22539 00002BDE 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22540 00002BE0 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22541                                  
 22542 00002BE2 803E[208C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22543 00002BE7 8E1E[A58A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22544 00002BEB 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22545                                  	
 22546                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22547 00002BED B80142                  	mov	ax,4201h
 22548 00002BF0 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22549                                  setreout_p:	; 26/02/2023
 22550 00002BF3 89CA                    	mov	dx,cx			;AN011;
 22551 00002BF5 CD21                    	int	21h			;AN011;
 22552 00002BF7 EB20                    	jmp	short SET_REOUT
 22553                                  reout_0_length: 			;AN017; We have a 0 length file
 22554                                  	; ds = cs ; 26/02/2023
 22555                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22556                                  					;AN017; Get resident segment back
 22557                                  	; 26/02/2023
 22558 00002BF9 8E1E[A58A]              	mov	ds,[RESSEG]
 22559                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22560 00002BFD B80042                  	mov	ax,4200h
 22561 00002C00 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22562                                  	;mov	dx,cx			;AN017;
 22563                                  	;int	21h			;AN017;
 22564                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22565                                  	; 26/02/2023
 22566 00002C02 EBEF                    	jmp	short setreout_p
 22567                                  
 22568                                  	; 26/02/2023
 22569                                  	; MSDOS 3.3
 22570                                  	;xor	dx,dx
 22571                                  	;xor	cx,cx
 22572                                  	;mov	bx,ax
 22573                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22574                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22575                                  	;		; AL = method: offset from end of file
 22576                                  	;jmp	short SET_REOUT
 22577                                  
 22578                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22579                                  OpenWriteError:	
 22580                                  	;cmp	ax,5
 22581 00002C04 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22582 00002C07 F9                      	stc
 22583                                  	;;je	short REDIRERR ; MSDOS 3.3
 22584                                  	; 26/02/2023
 22585                                  	;jnz	short REOUTCRT
 22586                                  	;jmp	REDIRERR
 22587 00002C08 743B                    	je	short REDIRERR
 22588                                  
 22589                                  REOUTCRT:
 22590 00002C0A BA[AF01]                	mov	dx,Re_OutStr
 22591 00002C0D 31C9                    	xor	cx,cx
 22592                                  	;mov	ah,CREAT ; 3Ch
 22593 00002C0F B43C                    	mov	ah,3Ch
 22594 00002C11 50                      	push	ax
 22595 00002C12 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22596                                  			; CX = attributes for file
 22597                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22598 00002C14 5B                      	pop	bx
 22599                                  	;jc	short REDIRERR ; MSDOS 3.3
 22600                                  	; 26/02/2023
 22601                                  	;jnc	short NOREDIRERR
 22602                                  	;jmp	REDIRERR
 22603 00002C15 722E                    	jc	short REDIRERR
 22604                                  
 22605                                  NOREDIRERR:
 22606 00002C17 89C3                    	mov	bx,ax
 22607                                  SET_REOUT:
 22608                                  
 22609                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22610                                  ; spot. We invalidate the new JFN we got.
 22611                                  
 22612 00002C19 B0FF                    	mov	al,0FFh
 22613                                  	;xchg	al,[bx+18h]
 22614 00002C1B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22615 00002C1E A21900                  	mov	[PDB.JFN_TABLE+1],al
 22616                                  	; 06/08/2024
 22617                                  NOREOUT:
 22618                                  ;IOSET_RETN:	; 17/04/2023
 22619 00002C21 C3                      	retn
 22620                                  
 22621                                  ; =============== S U B	R O U T	I N E =======================================
 22622                                  
 22623                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22624                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22625                                  	; 06/08/2024
 22626                                  TESTDOREIN:
 22627 00002C22 2E803E[508A]00          	cmp	byte [cs:RE_INSTR],0
 22628                                  	;jz	short IOSET_RETN
 22629                                  	; 06/08/2024
 22630 00002C28 74F7                    	jz	short NOREOUT
 22631 00002C2A 1E                      	push	ds
 22632 00002C2B 0E                      	push	cs
 22633 00002C2C 1F                      	pop	ds
 22634 00002C2D BA[508A]                	mov	dx,RE_INSTR
 22635                                  	;mov	ax,OPEN*256 ; 3D00h
 22636 00002C30 B8003D                  	mov	ax,3D00h
 22637 00002C33 89C3                    	mov	bx,ax
 22638 00002C35 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22639                                  			; DS:DX	-> ASCIZ filename
 22640                                  			; AL = access mode
 22641                                  			; 0 - read
 22642 00002C37 1F                      	pop	ds
 22643                                  
 22644 00002C38 720B                    	jc	short REDIRERR
 22645                                  
 22646 00002C3A 89C3                    	mov	bx,ax
 22647 00002C3C B0FF                    	mov	al,0FFh
 22648                                  
 22649                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22650                                  ; spot. We invalidate the new JFN we got.
 22651                                  
 22652                                  	;xchg	al,[bx+18h]
 22653 00002C3E 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22654 00002C41 A21800                  	mov	[PDB.JFN_TABLE],al
 22655 00002C44 C3                      	retn
 22656                                  
 22657                                  ; ---------------------------------------------------------------------------
 22658                                  
 22659                                  ; We had some kind of error on the redirection. Figure out what the
 22660                                  ; appropriate message should be; BX has the system call that failed
 22661                                  
 22662                                  REDIRERR:
 22663 00002C45 0E                      	push	cs
 22664 00002C46 1F                      	pop	ds
 22665 00002C47 E82E00                  	call	TriageError  ; MSDOS 6.0
 22666                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22667                                  
 22668                                  ; At this point, we have recognized the network-generated access denied error.
 22669                                  ; The correct message is in DX
 22670                                  
 22671 00002C4A 83F841                  	cmp	ax,65
 22672 00002C4D 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22673 00002C4F 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22674 00002C52 7406                    	je	short OpenError
 22675 00002C54 BA[167F]                	mov	dx,FULLDIR_PTR
 22676                                  _CERRORJ:
 22677 00002C57 E9F6FC                  	jmp	cerror
 22678                                  
 22679                                  OpenError:
 22680                                  ; The system call was an OPEN. Report either file not found or path not found.
 22681                                  
 22682                                  	; 26/02/2023
 22683                                  	; MSDOS 6.0
 22684                                  	;mov	byte [cs:msg_disp_class],1
 22685 00002C5A 2EC606[FA7E]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22686                                  				;AN000; set up extended error msg class
 22687 00002C60 BA[FC7E]                	mov	dx,extend_buf_ptr
 22688                                  				;AC000; get extended message pointer
 22689 00002C63 2EA3[FC7E]              	mov	[cs:extend_buf_ptr],ax
 22690                                  				;AN000; get message number in control block
 22691 00002C67 E9E6FC                  	jmp	cerror
 22692                                  
 22693                                  	; 26/02/2023
 22694                                  	; MSDOS 3.3
 22695                                  	;mov	dx,FNOTFOUNDPTR
 22696                                  	;;cmp	ax,2
 22697                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22698                                  	;je	short _CERRORJ
 22699                                  	;mov	dx,ACCDENPTR
 22700                                  	;;cmp	ax,5 ; Access denied error
 22701                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22702                                  	;je	short _CERRORJ
 22703                                  	;	; ERROR_PATH_NOT_FOUND
 22704                                  	;mov	dx,PNOTFOUNDPTR
 22705                                  	;jmp	CERROR
 22706                                  
 22707                                  ; =============== S U B	R O U T	I N E =======================================
 22708                                  
 22709                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22710                                  ; registers
 22711                                  
 22712                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22713                                  dstrlen:
 22714 00002C6A 50                      	push	ax
 22715 00002C6B 31C9                    	xor	cx,cx
 22716 00002C6D FC                      	cld
 22717                                  dloop:
 22718 00002C6E AC                      	lodsb
 22719 00002C6F 41                      	inc	cx
 22720 00002C70 08C0                    	or	al,al
 22721 00002C72 75FA                    	jnz	short dloop
 22722 00002C74 29CE                    	sub	si,cx
 22723 00002C76 58                      	pop	ax
 22724                                  TRIAGEERR_RETN:
 22725 00002C77 C3                      	retn
 22726                                  
 22727                                  ; =============== S U B	R O U T	I N E =======================================
 22728                                  
 22729                                  ;Break	<Extended error support>
 22730                                  
 22731                                  TriageError:  ; MSDOS 6.0
 22732                                  
 22733                                  ; TriageError will examine the return from a carry-set system call and
 22734                                  ; return the correct error if applicable.
 22735                                  ;
 22736                                  ;   Inputs:	outputs from a carry-settable system call
 22737                                  ;		No system calls may be done in the interrim
 22738                                  ;   Outputs:	If carry was set on input
 22739                                  ;		   carry set on output
 22740                                  ;		   DX contains trangroup offset to printf message
 22741                                  ;		else
 22742                                  ;		   No registers changed
 22743                                  
 22744                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22745                                  
 22746                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22747                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22748                                  
 22749                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22750 00002C78 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22751 00002C7A 9C                      	pushf
 22752 00002C7B 53                      	push	bx
 22753 00002C7C 51                      	push	cx
 22754 00002C7D 56                      	push	si
 22755 00002C7E 57                      	push	di
 22756 00002C7F 55                      	push	bp
 22757 00002C80 06                      	push	es
 22758 00002C81 1E                      	push	ds
 22759 00002C82 50                      	push	ax
 22760 00002C83 52                      	push	dx
 22761 00002C84 B459                    	mov	ah,59h
 22762                                  	;mov	ah,GETEXTENDEDERROR
 22763 00002C86 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22764                                  			; BX = version code (0000h for DOS 3.x)
 22765 00002C88 59                      	pop	cx
 22766 00002C89 5B                      	pop	bx		; restore original AX
 22767 00002C8A BA[227F]                	mov	dx,ACCDEN_PTR
 22768 00002C8D 83F841                  	cmp	ax,65		; network access denied?
 22769 00002C90 7404                    	je	short NoMove	; Yes, return it.
 22770 00002C92 89D8                    	mov	ax,bx
 22771 00002C94 89CA                    	mov	dx,cx
 22772                                  NoMove:
 22773 00002C96 1F                      	pop	ds
 22774 00002C97 07                      	pop	es
 22775 00002C98 5D                      	pop	bp
 22776 00002C99 5F                      	pop	di
 22777 00002C9A 5E                      	pop	si
 22778 00002C9B 59                      	pop	cx
 22779 00002C9C 5B                      	pop	bx
 22780 00002C9D 9D                      	popf
 22781 00002C9E C3                      	retn
 22782                                  
 22783                                  ; =============== S U B	R O U T	I N E =======================================
 22784                                  
 22785                                  	; Far call from resident portion/segment of COMMAND.COM
 22786                                  
 22787                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22788                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22789                                  
 22790                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22791                                  Triage_Init:
 22792 00002C9F E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22793                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22794 00002CA2 CB                      	retf
 22795                                  
 22796                                  ; =============== S U B	R O U T	I N E =======================================
 22797                                  
 22798                                  ; MSDOS 6.0
 22799                                  
 22800                                  ; ****************************************************************
 22801                                  ; *
 22802                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22803                                  ; *
 22804                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22805                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22806                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22807                                  ; *
 22808                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22809                                  ; *		 ES    points to TRANGROUP
 22810                                  ; *
 22811                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22812                                  ; *		 PATHCNT set to length of string
 22813                                  ; *		 PATHPOS set to start of SRCBUF
 22814                                  ; *		 CX,AX	 changed
 22815                                  ; *
 22816                                  ; ****************************************************************
 22817                                  
 22818                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22819                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22820                                  Move_To_SrcBuf:
 22821 00002CA3 56                      	push	si			;AN000;  save si,di
 22822 00002CA4 57                      	push	di			;AN000;
 22823 00002CA5 51                      	push	cx			;AN000;
 22824 00002CA6 BF[908C]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22825 00002CA9 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22826 00002CAB 89C8                    	mov	ax,cx			;AN000; clear ax
 22827 00002CAD 57                      	push	di			;AN000; save start of srcbuf
 22828 00002CAE AC                      	lodsb				;AN000; get a character from DS:SI
 22829                                  mts_get_chars:				;AN000;
 22830                                  	;cmp	al,0			;AN000; was it a null char?
 22831 00002CAF 20C0                    	and 	al,al ; al = 0 ?
 22832 00002CB1 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22833 00002CB3 AA                      	stosb				;AN000; no - store it in srcbuf
 22834 00002CB4 41                      	inc	cx			;AN000; increment length count
 22835 00002CB5 AC                      	lodsb				;AN000; get a character from DS:SI
 22836 00002CB6 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22837                                  mts_end_string: 			;AN000; we've reached the end of line
 22838                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22839 00002CB8 B00D                    	mov	al,0Dh
 22840 00002CBA AA                      	stosb				;AN000;
 22841 00002CBB 5F                      	pop	di			;AN000; restore start of srcbuf
 22842 00002CBC 0E                      	push	cs			;AN000; set DS to local segment
 22843 00002CBD 1F                      	pop	ds			;AN000;
 22844 00002CBE 890E[FE8B]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22845 00002CC2 893E[008C]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22846 00002CC6 59                      	pop	cx			;AN000; restore cx,di,si
 22847 00002CC7 5F                      	pop	di			;AN000;
 22848 00002CC8 5E                      	pop	si			;AN000;
 22849 00002CC9 C3                      	retn				;AN000; exit
 22850                                  
 22851                                  ;============================================================================
 22852                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22853                                  ;============================================================================
 22854                                  ; 03/10/2018 - Retro DOS v3.0
 22855                                  
 22856                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22857                                  
 22858                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22859                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22860                                  
 22861                                  ; =============== S U B	R O U T	I N E =======================================
 22862                                  
 22863                                  	; 26/02/2023
 22864                                  SINGLETEST:
 22865 00002CCA 1E                      	push	ds
 22866 00002CCB 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22867 00002CD0 833E[8E01]00            	cmp	word [SingleCom],0
 22868 00002CD5 7406                    	jz	short TESTDONE
 22869 00002CD7 813E[8E01]FFEF          	cmp	word [SingleCom],0EFFFh
 22870                                  TESTDONE:
 22871 00002CDD 1F                      	pop	ds
 22872 00002CDE C3                      	retn
 22873                                  
 22874                                  ; =============== S U B	R O U T	I N E =======================================
 22875                                  
 22876                                  	; 26/02/2023
 22877                                  SetRest1:
 22878 00002CDF B001                    	mov	al,1
 22879                                  
 22880                                  ; ---------------------------------------------------------------------------
 22881                                  
 22882                                  SETREST:
 22883 00002CE1 1E                      	push	ds
 22884 00002CE2 8E1E[A58A]              	mov	ds,[RESSEG]
 22885 00002CE6 A2[8C01]                	mov	[RestDir],al
 22886 00002CE9 1F                      	pop	ds
 22887 00002CEA C3                      	retn
 22888                                  
 22889                                  ; =============== S U B	R O U T	I N E =======================================
 22890                                  
 22891                                  ; Note that we need to handle the same thing that RestDir handles: the
 22892                                  ; requirement that we try only once to restore the user's environment after
 22893                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22894                                  ; disappear, we just give up.
 22895                                  
 22896                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22897                                  PIPEDEL:
 22898 00002CEB 1E                      	push	ds
 22899 00002CEC 52                      	push	dx
 22900 00002CED 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 22901                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22902                                  			; Pipe1 = offset RESGROUP:EndInit
 22903 00002CF2 BA[0202]                	mov	dx,Pipe1	; Clean up in case ^C
 22904                                  	;mov	ah,Unlink ; 41h
 22905 00002CF5 B441                    	mov	ah,41h
 22906 00002CF7 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22907                                  			; DS:DX	-> ASCIZ pathname of file to delete
 22908                                  			;		(no wildcards allowed)
 22909                                  
 22910                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22911                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22912 00002CF9 BA[5102]                	mov	dx,Pipe2
 22913                                  	;mov	ah,Unlink ; 41h
 22914 00002CFC B441                    	mov	ah,41h
 22915 00002CFE CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22916                                  			; DS:DX	-> ASCIZ pathname of file to delete
 22917                                  			;		(no wildcards allowed)
 22918 00002D00 5A                      	pop	dx
 22919 00002D01 E86202                  	call	PipeOff
 22920 00002D04 C606[0102]00            	mov	byte [PipeFiles],0
 22921 00002D09 1F                      	pop	ds
 22922 00002D0A C3                      	retn
 22923                                  
 22924                                  ; ---------------------------------------------------------------------------
 22925                                  
 22926                                  	; 26/02/2023
 22927                                  PIPEERRSYN:
 22928 00002D0B BA[947F]                	mov	dx,SYNTMES_PTR
 22929 00002D0E E8DAFF                  	call	PIPEDEL
 22930 00002D11 0E                      	push	cs
 22931 00002D12 1F                      	pop	ds
 22932 00002D13 E93AFC                  	jmp	cerror
 22933                                  
 22934                                  ; ---------------------------------------------------------------------------
 22935                                  
 22936                                  	; 26/02/2023
 22937                                  PIPERR:
 22938 00002D16 9C                      	pushf
 22939 00002D17 E85EFF                  	call    TriageError
 22940                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22941 00002D1A 50                      	push	ax		; Save results from TriageError
 22942 00002D1B 52                      	push	dx
 22943 00002D1C BA[5D80]                	mov	dx,PIPEEMES_PTR
 22944 00002D1F E8C9FF                  	call	PIPEDEL
 22945 00002D22 0E                      	push	cs
 22946 00002D23 1F                      	pop	ds
 22947 00002D24 E8A220                  	call	std_eprintf
 22948 00002D27 5A                      	pop	dx		; Restore results from TriageError
 22949 00002D28 58                      	pop	ax
 22950 00002D29 9D                      	popf
 22951 00002D2A 83F841                  	cmp	ax,65
 22952 00002D2D 7503                    	jne	short TCOMMANDJ
 22953 00002D2F E91EFC                  	jmp	cerror
 22954                                  
 22955                                  TCOMMANDJ:
 22956 00002D32 E9CFD3                  	jmp	TCOMMAND
 22957                                  
 22958                                  ; ---------------------------------------------------------------------------
 22959                                  
 22960                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22961                                  PIPEPROCSTRT:
 22962 00002D35 8E1E[A58A]              	mov	ds,[RESSEG]
 22963 00002D39 FE06[0102]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22964                                  
 22965                                  	; MSDOS 6.0
 22966 00002D3D 06                      	push	es
 22967 00002D3E 57                      	push	di
 22968 00002D3F 1E                      	push	ds
 22969 00002D40 56                      	push	si
 22970                                  	
 22971 00002D41 1E                      	push	ds
 22972 00002D42 06                      	push	es
 22973 00002D43 1F                      	pop	ds			;ds = TRANGROUP
 22974 00002D44 BE[B985]                	mov	si,TempVarName		;ds:si = "TEMP="
 22975                                  
 22976                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22977                                  ;so the routine is not really general
 22978                                  
 22979 00002D47 E8C9F5                  	call	find_name_in_environment
 22980                                  					;es:di points at path
 22981 00002D4A 1F                      	pop	ds			;ds = DATARES again
 22982 00002D4B 721F                    	jc	short no_temp_path
 22983                                  	
 22984 00002D4D 1E                      	push	ds
 22985 00002D4E 06                      	push	es
 22986 00002D4F 1F                      	pop	ds
 22987 00002D50 07                      	pop	es			;swap ds and es
 22988 00002D51 89FE                    	mov	si,di			;ds:si points at path
 22989                                  	
 22990 00002D53 E8AA02                  	call	skip_white		;skip white space chars
 22991                                  
 22992                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22993                                  
 22994 00002D56 E8B302                  	call	copy_pipe_path		;copy the pipe path
 22995                                  	
 22996                                  ;Check if the TEMP path is valid
 22997                                  
 22998 00002D59 06                      	push	es
 22999 00002D5A 1F                      	pop	ds			;ds = DATARES
 23000                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 23001                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 23002 00002D5B BA[0202]                	mov	dx,Pipe1
 23003                                  	;mov	ax,(CHMOD shl 8) or 0
 23004 00002D5E B80043                  	mov	ax,4300h
 23005 00002D61 CD21                    	int	21h
 23006 00002D63 7207                    	jc	short no_temp_path
 23007                                  	
 23008 00002D65 F7C11000                	test	cx,10h			;is it a directory?
 23009 00002D69 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 23010                                  	
 23011 00002D6B F9                      	stc				;no, indicate fail
 23012                                  no_temp_path:
 23013 00002D6C 5E                      	pop	si
 23014 00002D6D 1F                      	pop	ds
 23015 00002D6E 5F                      	pop	di
 23016 00002D6F 07                      	pop	es
 23017 00002D70 730B                    	jnc	short crt_temp		;path found, create tempfiles
 23018                                  
 23019                                  	; 27/02/2023
 23020                                  	; MSDOS 3.3
 23021                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 23022                                  	;				; Get current drive
 23023                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 23024                                  	;add	al,[cs:CAPITAL_A]
 23025                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 23026                                  	;mov	bx,PIPE1
 23027                                  	;mov	[bx],al
 23028                                  	;xor	ah,ah			; nul terminate path names
 23029                                  	;mov	byte [PIPE1+3],ah
 23030                                  	;mov	byte [PIPE2+3],ah
 23031                                  
 23032                                  	; MSDOS 6.0
 23033                                  ;SR;
 23034                                  ; We want to create temp files in the current directory rather than in the 
 23035                                  ;root of the drive. This is because the number of files that can be present
 23036                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 23037                                  
 23038                                  	;mov	ah,'.'
 23039                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 23040                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 23041                                  	;xor	ah,ah
 23042                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 23043                                  	;mov	[Pipe2+1],ah		;create files in current dir
 23044                                  	; 27/02/2023
 23045 00002D72 B92E00                  	mov	cx,002Eh
 23046 00002D75 890E[0202]              	mov	[Pipe1],cx
 23047 00002D79 890E[5102]              	mov	[Pipe2],cx
 23048                                  crt_temp:
 23049                                  	; MSDOS 6.0
 23050                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 23051                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 23052 00002D7D BA[0202]                	mov	dx,Pipe1
 23053                                  	; MSDOS 3.3
 23054                                  	;mov	dx,bx
 23055                                  	
 23056                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23057 00002D80 31C9                    	xor	cx,cx
 23058                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23059 00002D82 B45A                    	mov	ah,5Ah
 23060 00002D84 CD21                    	int	21h
 23061                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23062                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23063                                  		; receive generated filename
 23064                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23065 00002D86 728E                    	jc	short PIPERR	; Couldn't create
 23066                                  
 23067 00002D88 89C3                    	mov	bx,ax
 23068                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23069 00002D8A B43E                    	mov	ah,3Eh
 23070 00002D8C CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23071                                  			; BX = file handle
 23072                                  	;;mov	dx,PIPE2
 23073                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 23074 00002D8E BA[5102]                	mov	dx,Pipe2
 23075                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23076 00002D91 B45A                    	mov	ah,5Ah
 23077 00002D93 CD21                    	int	21h
 23078                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23079                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23080                                  		; receive generated filename
 23081                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23082                                  	; 17/04/2023
 23083                                  	;jc	short PIPERR
 23084                                  	; 27/02/2023
 23085 00002D95 7303                    	jnc	short pps1
 23086 00002D97 E97CFF                  	jmp	PIPERR
 23087                                  pps1:
 23088 00002D9A 89C3                    	mov	bx,ax
 23089 00002D9C B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23090 00002D9E CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23091                                  				; BX = file handle
 23092                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 23093 00002DA0 E87FFE                  	call	TESTDOREIN
 23094 00002DA3 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23095 00002DA7 833E[8E01]FF            	cmp	word [SingleCom],-1
 23096 00002DAC 7506                    	jne	short NOSINGP
 23097 00002DAE C706[8E01]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 23098                                  NOSINGP:
 23099 00002DB4 EB29                    	jmp	short FIRSTPIPE
 23100                                  
 23101                                  ; ---------------------------------------------------------------------------
 23102                                  
 23103                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23104                                  PIPEPROC:
 23105 00002DB6 8026[8801]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 23106 00002DBB 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23107 00002DBF AC                      	lodsb
 23108                                  	; 27/02/2023
 23109 00002DC0 3C7C                    	cmp	al,'|'		
 23110                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 23111                                  	;je	short ISPIPE1	; Yes
 23112                                  	;cmp	al,'|'
 23113                                  	;;cmp	al,[cs:VBAR]
 23114 00002DC2 7403                    	je	short ISPIPE1
 23115 00002DC4 E98400                  	jmp	PIPEEND		; Pipe done
 23116                                  ISPIPE1:
 23117 00002DC7 8B16[2303]              	mov	dx,[InPipePtr]	; Get the input file name
 23118                                  	;mov	ax,OPEN*256 ; 3D00h
 23119 00002DCB B8003D                  	mov	ax,3D00h
 23120 00002DCE CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23121                                  			; DS:DX	-> ASCIZ filename
 23122                                  			; AL = access mode
 23123                                  			; 0 - read
 23124                                  PIPEERRJ:
 23125 00002DD0 7303                    	jnc	short NO_PIPEERR
 23126 00002DD2 E941FF                  	jmp	PIPERR		; Lost the pipe file
 23127                                  NO_PIPEERR:
 23128 00002DD5 89C3                    	mov	bx,ax
 23129 00002DD7 B0FF                    	mov	al,0FFh
 23130                                  	;xchg	al,[bx+18h]
 23131 00002DD9 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23132 00002DDC A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 23133                                  FIRSTPIPE:
 23134 00002DDF BF[0689]                	mov	di,COMBUF+2
 23135 00002DE2 31C9                    	xor	cx,cx
 23136 00002DE4 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 23137 00002DE7 7503                    	jne	short PIPEOK1
 23138                                  PIPEERRSYNJ:
 23139 00002DE9 E91FFF                  	jmp	PIPEERRSYN
 23140                                  PIPEOK1:
 23141                                  	;;;mov	al,[cs:VBAR]
 23142                                  	; 27/02/2023
 23143                                  	;;mov	al,vbar
 23144                                  	;mov	al,'|'
 23145                                  	;cmp	[si],al		; '||'
 23146                                  	;je	short PIPEERRSYNJ
 23147 00002DEC 803C7C                  	cmp	byte [si],'|'
 23148                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 23149 00002DEF 74F8                    	je	short PIPEERRSYNJ
 23150                                  PIPECOMLP:
 23151 00002DF1 AC                      	lodsb
 23152 00002DF2 AA                      	stosb
 23153                                  	; 27/02/2023
 23154 00002DF3 E8C7F5                  	call	testkanj
 23155 00002DF6 7405                    	jz	short NOTKANJ5
 23156 00002DF8 A4                      	movsb
 23157                                  ;  Added following 2 commands to the fix pipe bug.
 23158 00002DF9 41                      	inc	cx		;AN000;  3/3/KK
 23159 00002DFA 41                      	inc	cx		;AN000;  3/3/KK
 23160 00002DFB EBF4                    	jmp	short PIPECOMLP
 23161                                  NOTKANJ5:
 23162 00002DFD 3C0D                    	cmp	al,0Dh
 23163 00002DFF 7438                    	je	short LASTPIPE
 23164 00002E01 41                      	inc	cx
 23165                                  	; 27/02/2023
 23166 00002E02 3C7C                    	cmp	al,'|'
 23167                                  	;cmp	al,ALTPIPECHR
 23168                                  	;je	short ISPIPE2
 23169                                  	;;cmp	al,[cs:VBAR]
 23170                                  	;cmp	al,vbar
 23171 00002E04 75EB                    	jne	short PIPECOMLP
 23172                                  ISPIPE2:
 23173 00002E06 26C645FF0D              	mov	byte [es:di-1],0Dh
 23174 00002E0B 49                      	dec	cx
 23175                                  	;mov	[cs:COMBUF+1],cl
 23176                                  	; 27/02/2023
 23177 00002E0C 26880E[0589]            	mov	[es:COMBUF+1],cl
 23178 00002E11 4E                      	dec	si
 23179                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23180 00002E12 8936[A002]              	mov	[PipePtr],si		; On to next pipe element
 23181                                  			; mov [EndInit+158],si
 23182 00002E16 8B16[2503]              	mov	dx,[OutPipePtr]
 23183 00002E1A 51                      	push	cx
 23184 00002E1B 31C9                    	xor	cx,cx
 23185                                  	;mov	ax,CREAT*256 ; 3C00h
 23186 00002E1D B8003C                  	mov	ax,3C00h
 23187 00002E20 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23188                                  			; CX = attributes for file
 23189                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23190 00002E22 59                      	pop	cx
 23191 00002E23 72AB                    	jc	short PIPEERRJ		; Lost the file
 23192 00002E25 89C3                    	mov	bx,ax
 23193 00002E27 B0FF                    	mov	al,0FFh
 23194                                  	;xchg	al,[bx+18h]
 23195 00002E29 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23196 00002E2C A21900                  	mov	[PDB.JFN_TABLE+1],al
 23197 00002E2F 8716[2303]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 23198 00002E33 8916[2503]              	mov	[OutPipePtr],dx
 23199 00002E37 EB0D                    	jmp	short PIPECOM
 23200                                  LASTPIPE:
 23201                                  	;mov	[cs:COMBUF+1],cl 
 23202                                  	; 27/02/2023
 23203 00002E39 26880E[0589]            	mov	[es:COMBUF+1],cl
 23204 00002E3E 4E                      	dec	si
 23205                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23206 00002E3F 8936[A002]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 23207                                  		; mov [EndInit+158],si
 23208 00002E43 E859FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 23209                                  PIPECOM:
 23210 00002E46 0E                      	push	cs
 23211 00002E47 1F                      	pop	ds
 23212 00002E48 E997D4                  	jmp	NOPIPEPROC	; Process the pipe element
 23213                                  PIPEEND:
 23214 00002E4B E89DFE                  	call	PIPEDEL
 23215 00002E4E 813E[8E01]00F0          	cmp	word [SingleCom],0F000h
 23216 00002E54 7506                    	jnz	short NOSINGP2
 23217 00002E56 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 23218                                  NOSINGP2:
 23219 00002E5C E9A5D2                  	jmp	TCOMMAND
 23220                                  
 23221                                  ; =============== S U B	R O U T	I N E =======================================
 23222                                  
 23223                                  ; Date and time are set during initialization and use
 23224                                  ; this routines since they need to do a long return
 23225                                  
 23226                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23227                                  DATINIT:
 23228 00002E5F 2E8C1E[A58A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 23229 00002E64 06                      	push	es
 23230 00002E65 1E                      	push	ds		; Going to use the previous stack
 23231 00002E66 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 23232 00002E68 8EC0                    	mov	es,ax
 23233 00002E6A 8ED8                    	mov	ds,ax
 23234 00002E6C E83F20                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 23235 00002E6F BA[FE94]                	mov	dx,INTERNATVARS
 23236 00002E72 B80038                  	mov	ax,3800h
 23237                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 23238 00002E75 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23239                                  			; get current-country info
 23240                                  			; DS:DX	-> buffer for returned info
 23241                                  	; 20/10/2018
 23242 00002E77 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 23243 00002E7D C606[0489]80            	mov	byte [COMBUF],128 ; Init COMBUF
 23244 00002E82 C706[0589]010D          	mov	word [COMBUF+1],0D01h
 23245 00002E88 E80600                  	call	DATE
 23246 00002E8B E86200                  	call	CTIME
 23247 00002E8E 1F                      	pop	ds
 23248 00002E8F 07                      	pop	es
 23249 00002E90 CB                      	retf	; far return
 23250                                  
 23251                                  ; =============== S U B	R O U T	I N E =======================================
 23252                                  
 23253                                  ; MSDOS 6.0
 23254                                  
 23255                                  ; ****************************************************************
 23256                                  ; *
 23257                                  ; * ROUTINE:	 DATE - Set system date
 23258                                  ; *
 23259                                  ; * FUNCTION:	 If a date is specified, set the system date,
 23260                                  ; *		 otherwise display the current system date and
 23261                                  ; *		 prompt the user for a new date.  If an invalid
 23262                                  ; *		 date is specified, issue an error message and
 23263                                  ; *		 prompt for a new date.  If the user enters
 23264                                  ; *		 nothing when prompted for a date, terminate.
 23265                                  ; *
 23266                                  ; * INPUT:	 command line at offset 81H
 23267                                  ; *
 23268                                  ; * OUTPUT:	 none
 23269                                  ; *
 23270                                  ; ****************************************************************
 23271                                  
 23272                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23273                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 23274                                  	; 11/06/2023
 23275                                  DATE:
 23276 00002E91 BE8100                  	mov	si,81h			; Accepting argument for date inline
 23277 00002E94 BF[B184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23278 00002E97 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23279 00002E99 31D2                    	xor	dx,dx			;AN000;
 23280 00002E9B E87D14                  	call	cmd_parse		;AC000; call parser
 23281                                  	
 23282                                  	; 27/02/2023
 23283                                  	;cmp	ax,-1
 23284                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23285                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 23286                                  	;;cmp	ax,0
 23287                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23288                                  	;;jne	short DATERR		;AN000; yes - go issue message
 23289                                  	; 26/04/2023
 23290                                  	;or	ax,ax ; ax = 0 ?
 23291                                  	;jnz	short DATERR
 23292                                  	;;jmp	short COMDAT		;AC000; we have a date
 23293                                  	; 11/06/2023
 23294 00002E9E 40                      	inc	ax  ; cmp ax,-1
 23295 00002E9F 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 23296 00002EA1 48                      	dec	ax  ; cmp ax,0
 23297 00002EA2 7541                    	jnz	short DATERR ; 1 -> 0
 23298                                  	; ax = 0
 23299                                  	
 23300                                  	; 27/02/2023
 23301                                  COMDAT:
 23302 00002EA4 8B0E[5B95]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 23303 00002EA8 8A36[5D95]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 23304 00002EAC 8A16[5E95]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 23305 00002EB0 51                      	push	cx			;AC000; save date
 23306 00002EB1 52                      	push	dx			;AC000;
 23307 00002EB2 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 23308 00002EB5 31D2                    	xor	dx,dx			;AN029;
 23309 00002EB7 E86114                  	call	cmd_parse		;AN029; call parser
 23310 00002EBA 3CFF                    	cmp	al,0FFh ; -1
 23311                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23312 00002EBC 5A                      	pop	dx			;AC000; retrieve date
 23313 00002EBD 59                      	pop	cx			;AC000;
 23314 00002EBE 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 23315                                  	; 26/04/2023
 23316                                  	;mov	ah,SET_DATE		;yes - set date
 23317 00002EC0 B42B                    	mov	ah,2Bh
 23318 00002EC2 CD21                    	int	21h
 23319                                  			; DOS - SET CURRENT DATE
 23320                                  			; DL = day, DH = month, CX = year
 23321                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 23322 00002EC4 08C0                    	or	al,al
 23323 00002EC6 751D                    	jnz	short DATERR
 23324                                  date_end:
 23325 00002EC8 C3                      	retn
 23326                                  
 23327                                  PRMTDAT:
 23328                                  	; Print "Current date is
 23329                                  
 23330 00002EC9 E81708                  	call	GetDate 		;AN000; get date for output
 23331 00002ECC 86F2                    	xchg	dh,dl			;AN000; switch month & day
 23332 00002ECE 890E[AA7F]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 23333 00002ED2 8916[AC7F]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 23334 00002ED6 BA[9A7F]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 23335 00002ED9 E8F51E                  	call	std_printf
 23336                                  
 23337                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 23338                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 23339                                  
 23340                                  GET_NEW_DATE:				;AN000;
 23341 00002EDC E8BC00                  	call	GETDAT			;AC000; prompt user for date
 23342                                  	
 23343                                  	; 11/06/2023
 23344                                  	;cmp	ax,0FFFFh ; -1
 23345                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23346                                  	;je	short date_end		;AC000; yes - exit
 23347                                  	; 26/04/2023
 23348                                  	;;cmp	ax,0
 23349                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23350                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 23351                                  	;; 27/02/2023
 23352                                  	;;jz	short COMDAT
 23353                                  	; 26/04/2023
 23354                                  	;and	ax,ax ; 0 ?
 23355                                  	;jz	short COMDAT
 23356                                  
 23357                                  	; 11/06/2023
 23358 00002EDF 40                      	inc	ax  ; cmp ax,-1
 23359 00002EE0 74E6                    	jz	short date_end ; 0FFFFh -> 0
 23360 00002EE2 48                      	dec	ax  ; cmp ax,0
 23361 00002EE3 74BF                    	jz	short COMDAT ; 1 -> 0
 23362                                  	; ax > 0
 23363                                  
 23364                                  ;COMDAT:
 23365                                  ;	....
 23366                                  DATERR:
 23367 00002EE5 E8E7F6                  	call	CRLF2			;AN028; print out a blank line
 23368 00002EE8 BA[977F]                	mov	dx,BADDAT_PTR
 23369 00002EEB E8E31E                  	call	std_printf
 23370 00002EEE EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 23371                                  
 23372                                  ; =============== S U B	R O U T	I N E =======================================
 23373                                  
 23374                                  ; MSDOS 6.0
 23375                                  
 23376                                  ; TIME gets and sets the time
 23377                                  
 23378                                  ; ****************************************************************
 23379                                  ; *
 23380                                  ; * ROUTINE:	 TIME - Set system time
 23381                                  ; *
 23382                                  ; * FUNCTION:	 If a time is specified, set the system time,
 23383                                  ; *		 otherwise display the current system time and
 23384                                  ; *		 prompt the user for a new time.  If an invalid
 23385                                  ; *		 time is specified, issue an error message and
 23386                                  ; *		 prompt for a new time.  If the user enters
 23387                                  ; *		 nothing when prompted for a time, terminate.
 23388                                  ; *
 23389                                  ; * INPUT:	 command line at offset 81H
 23390                                  ; *
 23391                                  ; * OUTPUT:	 none
 23392                                  ; *
 23393                                  ; ****************************************************************
 23394                                  
 23395                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23396                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23397                                  	; 11/06/2023
 23398                                  CTIME:
 23399 00002EF0 BE8100                  	mov	si,81h			; Accepting argument for time inline
 23400 00002EF3 BF[C384]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23401 00002EF6 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23402 00002EF8 31D2                    	xor	dx,dx			;AN000;
 23403 00002EFA E81E14                  	call	cmd_parse		;AC000; call parser
 23404                                  	
 23405                                  	; 27/02/2023
 23406                                  	;cmp	ax,-1
 23407                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23408                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 23409                                  	;;cmp	ax,0
 23410                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23411                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23412                                  	;and	ax,ax ; ax = 0 ?
 23413                                  	;jnz	short TIMERR
 23414                                  	;;jmp	short COMTIM		;AC000; we have a time
 23415                                  	; 11/06/2023
 23416 00002EFD 40                      	inc	ax  ; cmp ax,-1
 23417 00002EFE 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 23418 00002F00 48                      	dec	ax  ; cmp ax,0
 23419 00002F01 7548                    	jnz	short TIMERR ; 1 -> 0
 23420                                  	; ax = 0
 23421                                  	
 23422                                  	; 27/02/2023
 23423                                  COMTIM:
 23424 00002F03 8A2E[6395]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23425 00002F07 8A0E[6495]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23426 00002F0B 8A36[6595]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23427 00002F0F 8A16[6695]              	mov	dl,[TIME_FRACTION]	;AC000;
 23428 00002F13 51                      	push	cx			;AC000; save time
 23429 00002F14 52                      	push	dx			;AC000;
 23430 00002F15 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23431 00002F18 31D2                    	xor	dx,dx			;AN029;
 23432 00002F1A E8FE13                  	call	cmd_parse		;AN029; call parser
 23433 00002F1D 3CFF                    	cmp	al, -1
 23434                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23435 00002F1F 5A                      	pop	dx			;AC000; retieve time
 23436 00002F20 59                      	pop	cx			;AC000;
 23437 00002F21 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23438                                  SAVTIM:
 23439                                  	;mov	ah,SET_TIME
 23440 00002F23 B42D                    	mov	ah,2Dh
 23441 00002F25 CD21                    	int	21h
 23442 00002F27 08C0                    	or	al,al
 23443 00002F29 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23444                                  time_end:
 23445 00002F2B C3                      	retn
 23446                                  
 23447                                  PRMTTIM:
 23448                                  	;Printf "Current time is ... "
 23449                                  
 23450                                  	;mov	ah,Get_Time		;AC000; get the current time
 23451 00002F2C B42C                    	mov	ah,2Ch
 23452 00002F2E CD21                    	int	21h			;AC000;   Get time in CX:DX
 23453 00002F30 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23454 00002F32 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23455 00002F34 890E[CC7F]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23456 00002F38 8916[CE7F]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23457 00002F3C BA[C77F]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23458 00002F3F E88F1E                  	call	std_printf
 23459                                  
 23460                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23461                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23462                                  
 23463                                  GET_NEW_TIME:
 23464 00002F42 E8AE00                  	call	GETTIM			;AC000;
 23465                                  	
 23466                                  	; 11/06/2023
 23467                                  	;cmp	ax,-1
 23468                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23469                                  	;je	short time_end		;AC000;
 23470                                  	;;cmp	ax,0
 23471                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23472                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23473                                  	;or	ax,ax  ; ax = 0 ?
 23474                                  	;;jnz	short TIMERR
 23475                                  	; 27/02/2023
 23476                                  	;jz	short COMTIM
 23477                                  
 23478                                  	; 11/06/2023
 23479 00002F45 40                      	inc	ax  ; cmp ax,-1
 23480 00002F46 74E3                    	jz	short time_end ; 0FFFFh -> 0
 23481 00002F48 48                      	dec	ax  ; cmp ax,0
 23482 00002F49 74B8                    	jz	short COMTIM ; 1 -> 0
 23483                                  	; ax > 0
 23484                                  
 23485                                  ;COMTIM:
 23486                                  ;	....
 23487                                  TIMERR:
 23488 00002F4B E881F6                  	call	CRLF2			;AN028; print out a blank line
 23489 00002F4E BA[C47F]                	mov	dx,BadTim_Ptr
 23490 00002F51 E87D1E                  	call	std_printf		; Print error message
 23491 00002F54 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23492                                  
 23493                                  ; =============== S U B	R O U T	I N E =======================================
 23494                                  
 23495                                  ; MSDOS 6.0
 23496                                  
 23497                                  ; Set the special flag in the INIT flag to the value in CX.
 23498                                  
 23499                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23500                                  SetInitFlag:
 23501 00002F56 8E1E[A58A]              	mov	ds,[RESSEG]
 23502                                  
 23503 00002F5A 8026[FF01]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23504                                  	;and	byte [InitFlag],0FDh
 23505 00002F5F 080E[FF01]              	or	byte [InitFlag],cl
 23506 00002F63 0E                      	push	cs
 23507 00002F64 1F                      	pop	ds
 23508 00002F65 C3                      	retn
 23509                                  
 23510                                  ; =============== S U B	R O U T	I N E =======================================
 23511                                  
 23512                                  ; MSDOS 6.0
 23513                                  
 23514                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23515                                  PipeOff:
 23516 00002F66 1E                      	push	ds
 23517 00002F67 50                      	push	ax
 23518 00002F68 2E8E1E[A58A]            	mov	ds,[cs:RESSEG]
 23519 00002F6D 30C0                    	xor	al,al
 23520 00002F6F 8606[0002]              	xchg	[PipeFlag],al
 23521 00002F73 08C0                    	or	al,al
 23522 00002F75 7404                    	jz	short PipeOffDone
 23523 00002F77 D02E[8801]              	shr	byte [EchoFlag],1
 23524                                  PipeOffDone:
 23525 00002F7B 58                      	pop	ax
 23526 00002F7C 1F                      	pop	ds
 23527 00002F7D C3                      	retn
 23528                                  
 23529                                  ; =============== S U B	R O U T	I N E =======================================
 23530                                  
 23531                                  ; MSDOS 6.0
 23532                                  
 23533                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23534                                  PRINT_TIME:
 23535                                  	;mov	ah,Get_Time
 23536 00002F7E B42C                    	mov	ah,2Ch
 23537 00002F80 CD21                    	int	21h			; Get time in CX:DX
 23538                                  
 23539 00002F82 06                      	push	es
 23540 00002F83 0E                      	push	cs
 23541 00002F84 07                      	pop	es
 23542 00002F85 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23543 00002F87 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23544 00002F89 2E890E[0581]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23545 00002F8E 2E8916[0781]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23546 00002F93 BA[0081]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23547 00002F96 E8381E                  	call	std_printf
 23548                                  
 23549                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23550                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23551                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23552                                  					;AC000;  pointers in control block
 23553 00002F99 07                      	pop	es
 23554 00002F9A C3                      	retn
 23555                                  
 23556                                  ; =============== S U B	R O U T	I N E =======================================
 23557                                  
 23558                                  ; MSDOS 6.0
 23559                                  
 23560                                  ; ****************************************************************
 23561                                  ; *
 23562                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23563                                  ; *
 23564                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23565                                  ; *		 INFORMATION and issues the "Enter new date"
 23566                                  ; *		 message with the proper date format. COMBUF
 23567                                  ; *		 is reset to get a date from the command line.
 23568                                  ; *		 The PARSE_DATE blocks are then reset and the
 23569                                  ; *		 PARSE function call is issued.
 23570                                  ; *
 23571                                  ; * INPUT:	 NONE
 23572                                  ; *
 23573                                  ; * OUTPUT:	 COMBUF
 23574                                  ; *		 PARSER RETURN CODES
 23575                                  ; *
 23576                                  ; ****************************************************************
 23577                                  
 23578                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23579                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23580                                  GETDAT:
 23581                                  	;mov	ax,(International SHL 8)
 23582 00002F9B B80038                  	mov	ax,3800h
 23583                                  					; Determine what format the date
 23584 00002F9E BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23585 00002FA1 CD21                    	int	21h			;  print a message describing it
 23586                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23587                                  			; get current-country info
 23588                                  			; DS:DX -> buffer for returned info
 23589 00002FA3 89D6                    	mov	si,dx
 23590 00002FA5 AD                      	lodsw
 23591 00002FA6 2E8B16[DE80]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23592 00002FAB 48                      	dec	ax
 23593 00002FAC 780C                    	js	short printformat
 23594 00002FAE 2E8B16[E180]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23595 00002FB3 7405                    	jz	short printformat
 23596 00002FB5 2E8B16[E480]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23597                                  printformat:
 23598 00002FBA 89D0                    	mov	ax,dx			;AN000; get message number of format
 23599                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23600 00002FBC B6FF                    	mov	dh,-1 ; 0FFh
 23601 00002FBE E8F31E                  	call	TSYSGETMSG		;AN000; get the address of the message
 23602 00002FC1 2E8936[BB7F]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23603 00002FC6 BA[B67F]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23604 00002FC9 E8051E                  	call	std_printf
 23605                                  	;mov	word [cs:NewDat_Format],no_subst
 23606                                  					;AN000; reset subst block
 23607 00002FCC 2EC706[BB7F]0000        	mov	word [cs:NewDat_Format],0
 23608                                  
 23609                                  	; 28/02/2023
 23610 00002FD3 BF[B184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23611                                  ; 28/02/2023
 23612                                  gettim_p:	
 23613                                  	;mov	ah,Std_Con_String_Input
 23614 00002FD6 B40A                    	mov	ah,0Ah
 23615 00002FD8 BA[0489]                	mov	dx,COMBUF
 23616 00002FDB B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23617 00002FDE E875FF                  	call	SetInitFlag		;  prompting for date.
 23618 00002FE1 CD21                    	int	21h			; Get input line
 23619 00002FE3 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23620 00002FE5 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23621 00002FE8 E8E4F5                  	call	CRLF2
 23622                                  	; 28/02/2023
 23623                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23624                                  ;gettim_p: ; 28/02/2023
 23625 00002FEB BE[0689]                	mov	si,COMBUF+2
 23626                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23627 00002FEE 31D2                    	xor	dx,dx			;AN000;
 23628                                  	;call	cmd_parse		;AC000; call parser
 23629                                  	;retn
 23630                                  	; 28/02/2023
 23631 00002FF0 E92813                  	jmp	cmd_parse
 23632                                  
 23633                                  ; =============== S U B	R O U T	I N E =======================================
 23634                                  
 23635                                  ; MSDOS 6.0
 23636                                  
 23637                                  ; ****************************************************************
 23638                                  ; *
 23639                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23640                                  ; *
 23641                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23642                                  ; *		 INFORMATION and issues the "Enter new time"
 23643                                  ; *		 message. COMBUF is reset to get a time from the
 23644                                  ; *		 command line. The PARSE_TIME blocks are then
 23645                                  ; *		 reset and the PARSE function call is issued.
 23646                                  ; *
 23647                                  ; * INPUT:	 NONE
 23648                                  ; *
 23649                                  ; * OUTPUT:	 COMBUF
 23650                                  ; *		 PARSER RETURN CODES
 23651                                  ; *
 23652                                  ; ****************************************************************
 23653                                  
 23654                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23655                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23656                                  GETTIM:
 23657 00002FF3 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23658 00002FF5 BA[D57F]                	mov	dx,NewTim_Ptr
 23659 00002FF8 E8D61D                  	call	std_printf
 23660                                  
 23661                                  	; 28/02/2023
 23662 00002FFB BF[C384]                	mov	di,PARSE_TIME
 23663 00002FFE EBD6                    	jmp	short gettim_p
 23664                                  
 23665                                  ; 28/02/2023
 23666                                  ;	;mov	ah,Std_Con_String_Input
 23667                                  ;	mov	ah,0Ah
 23668                                  ;	mov	dx,COMBUF
 23669                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23670                                  ;	call	SetInitFlag		;  prompting for time.
 23671                                  ;	int	21h			; Get input line
 23672                                  ;	; 28/02/2023
 23673                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23674                                  ;	call	SetInitFlag		;  prompting for time.
 23675                                  ;	call	CRLF2
 23676                                  ;	; 28/02/2023
 23677                                  ;	;mov	si,COMBUF+2
 23678                                  ;	; 28/02/2023
 23679                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23680                                  ;	; 28/02/2023
 23681                                  ;	jmp	short gettim_p	
 23682                                  ;	; 28/02/2023
 23683                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23684                                  ;	;xor	dx,dx			;AN000;
 23685                                  ;	;call	cmd_parse		;AC000; call parser
 23686                                  ;	;retn
 23687                                  
 23688                                  
 23689                                  ; =============== S U B	R O U T	I N E =======================================
 23690                                  
 23691                                  ; MSDOS 6.0
 23692                                  
 23693                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23694                                  ;the '=' sign in the environment variable before the actual path.
 23695                                  ;
 23696                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23697                                  ;
 23698                                  ;	EXIT:	ds:si = start of the path
 23699                                  ;
 23700                                  ;	REGISTERS AFFECTED: ax
 23701                                  
 23702                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23703                                  skip_white:
 23704 00003000 FC                      	cld
 23705                                  skw_lp:
 23706 00003001 AC                      	lodsb
 23707 00003002 3C20                    	cmp	al,' '			;blank char?
 23708 00003004 74FB                    	jz	short skw_lp		;yes, skip it
 23709 00003006 3C09                    	cmp	al,9			;tab char?
 23710 00003008 74F7                    	jz	short skw_lp		;yes, skip it
 23711 0000300A 4E                      	dec	si			;point at first non-white
 23712 0000300B C3                      	retn
 23713                                  
 23714                                  ; =============== S U B	R O U T	I N E =======================================
 23715                                  
 23716                                  ; MSDOS 6.0
 23717                                  
 23718                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23719                                  ;variable into the path buffers Pipe1 & Pipe2.
 23720                                  ;
 23721                                  ;	ENTRY:	ds:si = path to be copied
 23722                                  ;		es = RESGROUP
 23723                                  ;
 23724                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23725                                  ;
 23726                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23727                                  
 23728                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23729                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23730                                  
 23731                                  copy_pipe_path:
 23732 0000300C B9FFFF                  	mov	cx,0FFFFh ; 65535
 23733 0000300F 30C0                    	xor	al,al
 23734                                  
 23735 00003011 89F7                    	mov	di,si
 23736 00003013 06                      	push	es			;save es
 23737 00003014 1E                      	push	ds
 23738 00003015 07                      	pop	es			;es:di = path to be copied
 23739                                  	
 23740 00003016 FC                      	cld
 23741 00003017 57                      	push	di
 23742 00003018 F2AE                    	repnz	scasb			;look for the null char
 23743 0000301A 5F                      	pop	di
 23744                                  
 23745 0000301B 07                      	pop	es			;es = RESGROUP again
 23746                                  
 23747 0000301C F7D1                    	not	cx			;length including the null
 23748                                  
 23749                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23750                                  	;mov	di,offset DATARES:Pipe1
 23751 0000301E BF[0202]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23752 00003021 57                      	push	di
 23753 00003022 51                      	push	cx			
 23754 00003023 F3A4                    	rep	movsb			;copy path into Pipe1
 23755 00003025 59                      	pop	cx
 23756 00003026 5F                      	pop	di
 23757                                  
 23758 00003027 1E                      	push	ds
 23759 00003028 06                      	push	es
 23760 00003029 1F                      	pop	ds			;ds:si = Pipe1
 23761 0000302A 89FE                    	mov	si,di
 23762                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23763                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23764 0000302C BF[5102]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23765 0000302F F3A4                    	rep	movsb			;copy path into Pipe2
 23766 00003031 1F                      	pop	ds
 23767 00003032 C3                      	retn
 23768                                  
 23769                                  ; 28/02/2023
 23770                                  %if 0
 23771                                  
 23772                                  ;============================================================================
 23773                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23774                                  ;============================================================================
 23775                                  ; 05/10/2018 - Retro DOS v3.0
 23776                                  
 23777                                  ; DATE - Gets and sets the time
 23778                                  
 23779                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23780                                  
 23781                                  ; =============== S U B	R O U T	I N E =======================================
 23782                                  
 23783                                  DATE_CXDX:
 23784                                  	mov	bx,cx
 23785                                  
 23786                                  ; =============== S U B	R O U T	I N E =======================================
 23787                                  
 23788                                  P_DATE:
 23789                                  	mov	ax,bx
 23790                                  	mov	cx,dx
 23791                                  	mov	dl,100
 23792                                  	div	dl
 23793                                  	xchg	al,ah
 23794                                  	xchg	ax,dx
 23795                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23796                                  	;mov	ax,[INTERNATVARS]
 23797                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23798                                  	or	ax,ax
 23799                                  	jz	short USPDAT
 23800                                  	dec	ax
 23801                                  	jz	short EUPDAT
 23802                                  	mov	bh,0	 ; Disable leading zero suppression	
 23803                                  	call	P_YR
 23804                                  	call	P_DSEP
 23805                                  	call	P_MON
 23806                                  	call	P_DSEP
 23807                                  	call	P_DAY
 23808                                  	retn
 23809                                  
 23810                                  USPDAT:
 23811                                  	call	P_MON
 23812                                  	call	P_DSEP
 23813                                  	call	P_DAY
 23814                                  PLST:
 23815                                  	call	P_DSEP
 23816                                  	call	P_YR
 23817                                  	retn
 23818                                  
 23819                                  EUPDAT:
 23820                                  	call	P_DAY
 23821                                  	call	P_DSEP
 23822                                  	call	P_MON
 23823                                  	jmp	short PLST
 23824                                  
 23825                                  ; ---------------------------------------------------------------------------
 23826                                  
 23827                                  P_MON:
 23828                                  	mov	al,ch
 23829                                  	call	OUT2
 23830                                  	retn
 23831                                  
 23832                                  ; ---------------------------------------------------------------------------
 23833                                  
 23834                                  P_DSEP:
 23835                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23836                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23837                                  	stosb
 23838                                  	retn
 23839                                  
 23840                                  ; ---------------------------------------------------------------------------
 23841                                  
 23842                                  P_DAY:
 23843                                  	mov	al,cl
 23844                                  	call	OUT2
 23845                                  	retn
 23846                                  
 23847                                  ; ---------------------------------------------------------------------------
 23848                                  
 23849                                  P_YR:
 23850                                  	mov	al,dh
 23851                                  	or	al,al
 23852                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23853                                  	call	OUT2
 23854                                  TWODIGYR:
 23855                                  	mov	al,dl
 23856                                  	call	OUT2
 23857                                  DATE_RETN:
 23858                                  	retn
 23859                                  
 23860                                  ; =============== S U B	R O U T	I N E =======================================
 23861                                  
 23862                                  DATE:				 ; Accepting argument for date inline
 23863                                  	mov	si,81h
 23864                                  	call	SCANOFF
 23865                                  	cmp	al,0Dh
 23866                                  	jz	short PRMTDAT
 23867                                  	jmp	short COMDAT
 23868                                  
 23869                                  	;nop
 23870                                  PRMTDAT:
 23871                                  	; MSDOS 3.3
 23872                                  	mov	dx,CURDATPTR
 23873                                  	call	STD_PRINTF	; Print "Current date is "	
 23874                                  	call	PRINT_DATE
 23875                                  GETDAT:	
 23876                                  	mov	dx,NEWDATPTR
 23877                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23878                                  
 23879                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23880                                  				; Determine what format the date
 23881                                  	mov	dx,5Ch		;  should be entered in and
 23882                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23883                                  			; get current-country info
 23884                                  			; DS:DX	-> buffer for returned info
 23885                                  	mov	si,dx		;  print a message describing it
 23886                                  	lodsw
 23887                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23888                                  	dec	ax
 23889                                  	js	short PRINTFORMAT
 23890                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23891                                  	jz	short PRINTFORMAT
 23892                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23893                                  PRINTFORMAT:
 23894                                  	call	STD_PRINTF
 23895                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23896                                  	mov	dx,COMBUF
 23897                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23898                                  	call	SETINITFLAG	;  prompting for date.
 23899                                  	int	21h		; Get input line
 23900                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23901                                  	call	SETINITFLAG	;  prompting for date.
 23902                                  	call	CRLF2
 23903                                  	mov	si,COMBUF+2
 23904                                  	cmp	byte [si],0Dh
 23905                                  	jz	short DATE_RETN
 23906                                  COMDAT:
 23907                                  	;mov	ax,[INTERNATVARS]
 23908                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23909                                  	or	ax,ax
 23910                                  	jz	short USSDAT
 23911                                  	dec	ax
 23912                                  	jz	short EUSDAT
 23913                                  	call	GET_YR
 23914                                  	jc	short DATERRJ
 23915                                  	call	GET_DSEP
 23916                                  	jc	short DATERRJ
 23917                                  	call	GET_MON
 23918                                  	jc	short DATERRJ
 23919                                  	call	GET_DSEP
 23920                                  	jc	short DATERRJ
 23921                                  	call	GET_DAY
 23922                                  DAT_SET:
 23923                                  	jnc	short DATSET
 23924                                  	jmp	DATERR
 23925                                  
 23926                                  ; ---------------------------------------------------------------------------
 23927                                  
 23928                                  DATSET:
 23929                                  	lodsb
 23930                                  	cmp	al,' '
 23931                                  	jz	short DATSET
 23932                                  	cmp	al,9
 23933                                  	jz	short DATSET
 23934                                  	cmp	al,0Dh
 23935                                  	jnz	short DATERR
 23936                                  	mov	ah,SET_DATE ; 2Bh
 23937                                  	int	21h	; DOS -	SET CURRENT DATE
 23938                                  			; DL = day,DH = month,	CX = year
 23939                                  			; Return: AL = 00h if no error 
 23940                                  			; 	     = FFh if bad value sent to routine
 23941                                  	or	al,al
 23942                                  	jnz	short DATERR
 23943                                  DAT_SET_RETN:
 23944                                  	retn
 23945                                  
 23946                                  ; ---------------------------------------------------------------------------
 23947                                  
 23948                                  USSDAT:
 23949                                  	call	GET_MON
 23950                                  	jb	short DATERR
 23951                                  	call	GET_DSEP
 23952                                  DATERRJ:
 23953                                  	jc	short DATERR
 23954                                  	call	GET_DAY
 23955                                  TGET:
 23956                                  	jc	short DATERR
 23957                                  	call	GET_DSEP
 23958                                  	jc	short DATERR
 23959                                  	call	GET_YR
 23960                                  	jmp	short DAT_SET
 23961                                  
 23962                                  ; ---------------------------------------------------------------------------
 23963                                  
 23964                                  EUSDAT:
 23965                                  	call	GET_DAY
 23966                                  	jc	short DATERR
 23967                                  	call	GET_DSEP
 23968                                  	jc	short DATERR
 23969                                  	call	GET_MON
 23970                                  	jmp	short TGET
 23971                                  
 23972                                  ; =============== S U B	R O U T	I N E =======================================
 23973                                  
 23974                                  GET_MON:
 23975                                  	call	GETNUM		; Get one or two digit number
 23976                                  	jc	short DAT_SET_RETN
 23977                                  	mov	dh,ah		; Put in position
 23978                                  	retn
 23979                                  
 23980                                  
 23981                                  ; =============== S U B	R O U T	I N E =======================================
 23982                                  
 23983                                  GET_DAY:
 23984                                  		call	GETNUM
 23985                                  		mov	dl,ah		; Put in position
 23986                                  GET_DAY_RETN:
 23987                                  		retn
 23988                                  
 23989                                  ; =============== S U B	R O U T	I N E =======================================
 23990                                  
 23991                                  GET_YR:
 23992                                  	call	GETNUM
 23993                                  	jc	short GET_DAY_RETN
 23994                                  	mov	cx,1900
 23995                                  	call	GET_DSEP
 23996                                  	pushf
 23997                                  	dec	si
 23998                                  	popf
 23999                                  	jz	short BIAS
 24000                                  	cmp	byte [si],0Dh
 24001                                  	je	short BIAS
 24002                                  	cmp	byte [si],' '
 24003                                  	je	short BIAS
 24004                                  	cmp	byte [si],9
 24005                                  	je	short BIAS
 24006                                  	push	bx
 24007                                  	mov	bl,100
 24008                                  	mov	al,ah
 24009                                  	mul	bl
 24010                                  	pop	bx
 24011                                  	mov	cx,ax
 24012                                  	call	GETNUM
 24013                                  	jc	short GET_DAY_RETN
 24014                                  BIAS:
 24015                                  	mov	al,ah
 24016                                  	mov	ah,0
 24017                                  	add	cx,ax
 24018                                  BIAS_RETN:
 24019                                  	retn
 24020                                  
 24021                                  ; ---------------------------------------------------------------------------
 24022                                  
 24023                                  DATERR:
 24024                                  	mov	dx,BADDATPTR
 24025                                  	call	STD_PRINTF
 24026                                  	jmp	GETDAT
 24027                                  
 24028                                  ; =============== S U B	R O U T	I N E =======================================
 24029                                  
 24030                                  GET_DSEP:
 24031                                  	lodsb
 24032                                  	cmp	al,'/'
 24033                                  	je	short BIAS_RETN
 24034                                  	;cmp	al,'.'
 24035                                  	cmp	al,[DOT_CHR]
 24036                                  	je	short BIAS_RETN
 24037                                  	;cmp	al,'-'
 24038                                  	cmp	al,[CHAR_SUB]
 24039                                  	je	short BIAS_RETN
 24040                                  	stc
 24041                                  	retn
 24042                                  
 24043                                  ; =============== S U B	R O U T	I N E =======================================
 24044                                  
 24045                                  ; TIME gets and sets the time
 24046                                  
 24047                                  CTIME:
 24048                                  	mov	si,81h		; Accepting argument for time inline
 24049                                  	call	SCANOFF
 24050                                  	cmp	al,0Dh
 24051                                  	je	short PRMTTIM
 24052                                  	mov	bx,2E3Ah ; ":."
 24053                                  	call	INLINE
 24054                                  	jmp	COMTIM
 24055                                  
 24056                                  ; =============== S U B	R O U T	I N E =======================================
 24057                                  
 24058                                  PRINT_TIME:
 24059                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 24060                                  	int	21h	; DOS -	GET CURRENT TIME
 24061                                  			; Return: CH = hours,CL = minutes,DH = seconds
 24062                                  			; DL = hundredths of seconds
 24063                                  	push	di
 24064                                  	push	es
 24065                                  	push	cs
 24066                                  	pop	es
 24067                                  	mov	di,CHARBUF
 24068                                  	mov	bl,1	; Always 24 hour time
 24069                                  	call	P_TIME
 24070                                  	xor	ax,ax
 24071                                  	stosb
 24072                                  	mov	dx,CHARBUF
 24073                                  	mov	[STRING_PTR_2],dx
 24074                                  	mov	dx,STRINGBUF2PTR
 24075                                  	call	STD_PRINTF
 24076                                  	pop	es
 24077                                  	pop	di
 24078                                  P_TIME_RETN:
 24079                                  	retn
 24080                                  
 24081                                  ; =============== S U B	R O U T	I N E =======================================
 24082                                  
 24083                                  P_TIME:
 24084                                  	mov	al,ch	
 24085                                  	test	bl,7Fh		; Ignore high bit
 24086                                  	jnz	short T24	; 24 hr time?
 24087                                  	mov	bh,'a'		; Assume A.M.
 24088                                  	cmp	al,12		; In the afternoon?
 24089                                  	jb	short MORN
 24090                                  	mov	bh,'p'
 24091                                  	jz	short MORN
 24092                                  	sub	al,12		; Keep it to 12 hours or less
 24093                                  MORN:
 24094                                  	or	al,al		; Before 1 am?
 24095                                  	jnz	short T24
 24096                                  	mov	al,12
 24097                                  T24:
 24098                                  	push	bx
 24099                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 24100                                  	call	OUT2
 24101                                  	call	P_TSEP
 24102                                  	mov	al,cl
 24103                                  	call	OUT2
 24104                                  	pop	bx
 24105                                  	push	bx
 24106                                  	test	bl,80h
 24107                                  	jnz	short PAP	; If from DIR, go directly to am pm
 24108                                  	mov	bh,0		; Disable leading zero suppression
 24109                                  	call	P_TSEP
 24110                                  	mov	al,dh
 24111                                  	call	OUT2
 24112                                  	;mov	al,'.'
 24113                                  	mov	al,[DECIMAL_SEP]
 24114                                  	stosb
 24115                                  	mov	al,dl
 24116                                  	call	OUT2
 24117                                  PAP:
 24118                                  	pop	bx
 24119                                  	test	bl,7Fh		; Ignore high bit
 24120                                  	jnz	short P_TIME_RETN
 24121                                  	mov	al,bh
 24122                                  	stosb
 24123                                  	retn
 24124                                  
 24125                                  ; =============== S U B	R O U T	I N E =======================================
 24126                                  
 24127                                  P_TSEP:
 24128                                  	;mov	al,[TIME_SEP]
 24129                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 24130                                  	stosb
 24131                                  P_TSEP_RETN:
 24132                                  	retn
 24133                                  
 24134                                  ; ---------------------------------------------------------------------------
 24135                                  
 24136                                  PRMTTIM:
 24137                                  	mov	dx,CURTIMPTR
 24138                                  	call	STD_PRINTF	; Print "Current time is "
 24139                                  	call	PRINT_TIME
 24140                                  GETTIM:
 24141                                  	xor	cx,cx		; Initialize hours and minutes to zero
 24142                                  	mov	dx,NEWTIMPTR
 24143                                  	call	STD_PRINTF
 24144                                  	;mov	bx,':.'
 24145                                  	mov	bx,[TIMECHARS] 
 24146                                  	call	GETBUF
 24147                                  COMTIM:
 24148                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 24149                                  	jc	short TIMEERR
 24150                                  	mov	cx,dx
 24151                                  	xor	dx,dx
 24152                                  	lodsb
 24153                                  	cmp	al,0Dh
 24154                                  	je	short SAVTIM
 24155                                  	cmp	al,' '
 24156                                  	je	short GOTSEC2
 24157                                  	cmp	al,9
 24158                                  	je	short GOTSEC2
 24159                                  	cmp	al,bl
 24160                                  	je	short GOTSEC
 24161                                  	cmp	al,bh
 24162                                  	jne	short TIMEERR
 24163                                  GOTSEC:
 24164                                  	call	GETNUM
 24165                                  	jc	short TIMEERR
 24166                                  	mov	dh,ah		; Position seconds
 24167                                  	lodsb
 24168                                  	cmp	al,0Dh
 24169                                  	je	short SAVTIM
 24170                                  	cmp	al,' '
 24171                                  	je	short GOTSEC2
 24172                                  	cmp	al,9
 24173                                  	je	short GOTSEC2
 24174                                  	;cmp	al,'.'
 24175                                  	cmp	al,[DECIMAL_SEP]
 24176                                  	jne	short TIMEERR
 24177                                  	call	GETNUM
 24178                                  	jc	short TIMEERR
 24179                                  	mov	dl,ah
 24180                                  GOTSEC2:
 24181                                  	lodsb
 24182                                  	cmp	al,' '
 24183                                  	je	short GOTSEC2
 24184                                  	cmp	al,9
 24185                                  	je	short GOTSEC2
 24186                                  	cmp	al,0Dh
 24187                                  	jne	short TIMEERR
 24188                                  SAVTIM:
 24189                                  	mov	ah,SET_TIME ; 2Dh
 24190                                  	int	21h	; DOS -	SET CURRENT TIME
 24191                                  			; CH = hours,CL = minutes,DH = seconds,
 24192                                  			;		DL = hundredths of seconds
 24193                                  			; Return: AL = 00h if no error 
 24194                                  			;	     = FFh if bad value sent to routine
 24195                                  	or	al,al
 24196                                  P_TSEP_JRETN:
 24197                                  	jz	short P_TSEP_RETN ; Error in time?
 24198                                  TIMEERR:
 24199                                  	mov	dx,BADTIMPTR
 24200                                  	call	STD_PRINTF	; Print "Enter new time: "
 24201                                  	jmp	short GETTIM
 24202                                  
 24203                                  ; =============== S U B	R O U T	I N E =======================================
 24204                                  
 24205                                  GETBUF:
 24206                                  	mov	ah,Std_Con_String_Input ; 0Ah
 24207                                  	mov	dx,COMBUF
 24208                                  	mov	cx,2
 24209                                  	call	SETINITFLAG
 24210                                  	int	21h		; Get input line
 24211                                  	xor	cx,cx
 24212                                  	call	SETINITFLAG
 24213                                  	call	CRLF2
 24214                                  	mov	si,COMBUF+2
 24215                                  	cmp	byte [si],0Dh	; Check if new time entered
 24216                                  	jz	short P_TSEP_JRETN
 24217                                  
 24218                                  ; =============== S U B	R O U T	I N E =======================================
 24219                                  
 24220                                  INLINE:
 24221                                  	call	GETNUM		; Get one or two digit number
 24222                                  	jnb	short INLINE1
 24223                                  	retn
 24224                                  INLINE1:
 24225                                  	mov	dh,ah		; Put in position
 24226                                  	lodsb
 24227                                  	cmp	al,bl
 24228                                  	jz	short NEXT
 24229                                  	cmp	al,bh
 24230                                  	jz	short NEXT
 24231                                  	dec	si		; Clears zero flag
 24232                                  	clc
 24233                                  	mov	dl,0
 24234                                  	retn			; Time may have only an hour specified
 24235                                  NEXT:
 24236                                  	call	GETNUM
 24237                                  	mov	dl,ah		; Put in position
 24238                                  INLINE_RETN:
 24239                                  	retn
 24240                                  
 24241                                  ;============================================================================
 24242                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 24243                                  ;============================================================================
 24244                                  ; 05/10/2018 - Retro DOS v3.0
 24245                                  
 24246                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 24247                                  
 24248                                  ; =============== S U B	R O U T	I N E =======================================
 24249                                  
 24250                                  GETNUM:
 24251                                  	call	INDIG
 24252                                  	jb	short INLINE_RETN
 24253                                  	mov	ah,al		; Save first digit
 24254                                  	call	INDIG		; Another digit?
 24255                                  	jb	short OKRET
 24256                                  	aad			; Convert unpacked BCD to decimal
 24257                                  	mov	ah,al
 24258                                  OKRET:
 24259                                  	or	al,1
 24260                                  GETNUM_RETN:
 24261                                  	retn
 24262                                  
 24263                                  ; =============== S U B	R O U T	I N E =======================================
 24264                                  
 24265                                  INDIG:
 24266                                  	mov	al,[si]
 24267                                  	sub	al,'0'
 24268                                  	jc	short GETNUM_RETN
 24269                                  	cmp	al,10
 24270                                  	cmc
 24271                                  	jc	short GETNUM_RETN
 24272                                  	inc	si
 24273                                  	retn
 24274                                  
 24275                                  ; =============== S U B	R O U T	I N E =======================================
 24276                                  
 24277                                  OUT2:				; Output binary number as two ASCII digits
 24278                                  	aam			; Convert binary to unpacked BCD
 24279                                  	xchg	al,ah
 24280                                  	or	ax,3030h	; Add "0" bias to both digits
 24281                                  	cmp	al,'0'		; Is MSD zero?
 24282                                  	jnz	short NOSUP
 24283                                  	sub	al,bh		; Suppress leading zero if enabled
 24284                                  NOSUP:
 24285                                  	mov	bh,0		; Disable zero suppression
 24286                                  	stosw
 24287                                  	retn
 24288                                  
 24289                                  ; ---------------------------------------------------------------------------
 24290                                  	;stosb
 24291                                  	;retn
 24292                                  
 24293                                  ;============================================================================
 24294                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 24295                                  ;============================================================================
 24296                                  ; 03/10/2018 - Retro DOS v3.0
 24297                                  
 24298                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 24299                                  
 24300                                  ; =============== S U B	R O U T	I N E =======================================
 24301                                  
 24302                                  ; Set the special flag in the INIT flag to the value in CX.
 24303                                  
 24304                                  SETINITFLAG:
 24305                                  	mov	ds,[RESSEG]
 24306                                  	;and	byte [INITFLAG],0FDh
 24307                                  	and	byte [INITFLAG],~INITSPECIAL
 24308                                  	or	byte [INITFLAG],cl
 24309                                  	push	cs
 24310                                  	pop	ds
 24311                                  	retn
 24312                                  
 24313                                  ; =============== S U B	R O U T	I N E =======================================
 24314                                  
 24315                                  PIPEOFF:
 24316                                  	push	ds
 24317                                  	push	ax
 24318                                  	mov	ds,[cs:RESSEG]
 24319                                  	xor	al,al
 24320                                  	xchg	al,byte [PIPEFLAG]
 24321                                  	or	al,al
 24322                                  	jz	short PIPEOFFDONE
 24323                                  	shr	byte [ECHOFLAG],1
 24324                                  PIPEOFFDONE:
 24325                                  	pop	ax
 24326                                  	pop	ds
 24327                                  	retn
 24328                                  
 24329                                  ; ---------------------------------------------------------------------------
 24330                                  	;db    0,0,0,0,0
 24331                                  	;times 5 db 0
 24332                                  
 24333                                  align 16
 24334                                  
 24335                                  %endif
 24336                                  
 24337                                  ;============================================================================
 24338                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24339                                  ;============================================================================
 24340                                  ; 03/10/2018 - Retro DOS v3.0
 24341                                  
 24342                                  ;----------------------------------------------------------------------------
 24343                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24344                                  ; argv[argvcnt] array. The most important difference between this array and
 24345                                  ; the tradition UNIX format is the extra cparse information included with
 24346                                  ; each argument element.
 24347                                  ;---------------
 24348                                  ; ENTRY:
 24349                                  ;	BL	     special delimiter for cparse -- not implemented)
 24350                                  ;---------------
 24351                                  ; EXIT:
 24352                                  ;	CF	    set if error
 24353                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24354                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24355                                  ;	argvcnt     argument count
 24356                                  ;---------------
 24357                                  ; NOTE(S):
 24358                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24359                                  ;	*   Parseflags record contains cparse flags, as follows:
 24360                                  ;		sw_flag 	--	was this arg a switch?
 24361                                  ;		wildcard	--	whether or not it contained a * or ?
 24362                                  ;		path_sep	--	maybe it was a pathname
 24363                                  ;		unused		--	for future expansion
 24364                                  ;		special_delim	--	was there an initial special delimiter?
 24365                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24366                                  ;	*   Relationship between input, cparse output, and comtail can be
 24367                                  ;	    found in the following chart. Despite the claim of the cparse
 24368                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24369                                  ;	    tokens", such is not the case (see column two, row two).
 24370                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24371                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24372                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24373                                  ;	    documentation error.
 24374                                  ;	*   cparse also returns a switch code in BP for each switch it
 24375                                  ;	    recognizes on the command line.
 24376                                  ;	*   arglen for each token does NOT include the terminating null.
 24377                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24378                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24379                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24380                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24381                                  ;	    line parsing may result in slightly different behavior than
 24382                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24383                                  ;
 24384                                  ;	    Input		    Cparse		Command Line (80H)
 24385                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24386                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24387                                  ;	foo.bat 		foo.bat 		foo.bat
 24388                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24389                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24390                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24391                                  
 24392                                  ; =============== S U B	R O U T	I N E =======================================
 24393                                  
 24394                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24395                                  
 24396                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24397                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24398                                  
 24399                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24400                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24401                                  
 24402                                  ; 27/07/2024 - Retro DOS v4.0-v4.1-v4.2-v5.0 COMMAND.COM (PARSELINE)
 24403                                  ; PCDOS 7.1 - COMMAND.COM, transient portion/segment offset 35F5h
 24404                                  
 24405                                  PARSELINE:
 24406 00003033 50                      	push	ax			; most of these are clobbered
 24407 00003034 53                      	push	bx			; by cparse...
 24408 00003035 51                      	push	cx
 24409 00003036 52                      	push	dx
 24410 00003037 57                      	push	di
 24411 00003038 56                      	push	si
 24412 00003039 9C                      	pushf
 24413                                  	;mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24414 0000303A C706[7693]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24415 00003040 31C0                    	xor	ax,ax
 24416                                  	;;mov	cx,1348
 24417                                  	; 27/07/2024
 24418                                  	;mov	cx,1092  ; PCDOS 7.1 COMMAND.COM
 24419 00003042 B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092
 24420 00003045 A2[158C]                	mov	[cpyflag],al ; 0 ; 27/07/2024
 24421 00003048 BF[B08D]                	mov	di,ARG
 24422 0000304B F3AA                    	rep	stosb
 24423                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24424 0000304D C706[F492][7490]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24425                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24426                                  	;mov	word [ARG+ARG_UNIT.argswinfo],0
 24427 00003053 A3[7290]                	mov	[ARG+ARG_UNIT.argswinfo],ax ; 0 ; 27/07/2024
 24428                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24429                                  	;mov	word [ARG+ARG_UNIT.argvcnt],0
 24430 00003056 A3[7090]                	mov	[ARG+ARG_UNIT.argvcnt],ax ; 0 ; 27/07/2024 
 24431 00003059 BE[0689]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24432                                  
 24433                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24434                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24435                                  ; otherwise. This is done so that commands can get arg pointers into their
 24436                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24437                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24438                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24439                                  ; the command to be repeated or the transient part of command has been
 24440                                  ; reloaded.
 24441                                  
 24442 0000305C 1E                      	push	ds
 24443 0000305D 8E1E[A58A]              	mov	ds,[RESSEG]
 24444                                  	;cmp	byte [ForFlag],0
 24445 00003061 3806[9401]              	cmp	[ForFlag],al ; 0 ; 27/07/2024
 24446 00003065 1F                      	pop	ds
 24447 00003066 7510                    	jnz	short PCONT
 24448                                  	;mov	di,ARG_ARGFORCOMBUF
 24449 00003068 BF[7491]                	mov	di,ARG+ARG_UNIT.argforcombuf
 24450 0000306B 30ED                    	xor	ch,ch
 24451 0000306D 8A0E[0589]              	mov	cl,[COMBUF+1]
 24452 00003071 FEC1                    	inc	cl
 24453 00003073 F3A4                    	rep	movsb
 24454                                  	;mov	si,ARG_ARGFORCOMBUF
 24455 00003075 BE[7491]                	mov	si,ARG+ARG_UNIT.argforcombuf
 24456                                  PCONT:
 24457 00003078 BF[F692]                	mov	di,TPBUF	; destination is temporary token buffer
 24458 0000307B B320                    	mov	bl,' '		; no special delimiter, for now
 24459                                  PARSELOOP:
 24460 0000307D 8936[7893]              	mov	[COMPTR],si	; save ptr into original command buffer
 24461 00003081 31ED                    	xor	bp,bp		; switch information put here by cparse
 24462 00003083 C606[928D]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24463 00003088 E851F5                  	call	scanoff		; skip leading blanks...
 24464 0000308B E8C810                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24465 0000308E 730B                    	jnb	short MORE_PRSE
 24466 00003090 09ED                    	or	bp,bp		; Check for trailing switch character
 24467 00003092 7403                    	jz	short PARSEDONE
 24468 00003094 E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24469                                  				;   typical cause of this is that a
 24470                                  				;   switch char IMMEDIATELY preceeds
 24471                                  				;   the CR. We have an argument, but it
 24472                                  				;   is sort of an error.
 24473                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24474                                  	; 01/03/2023
 24475                                  PARSEDONE:
 24476 00003097 9D                      	popf
 24477 00003098 F8                      	clc
 24478 00003099 EB0C                    	jmp	short PARSE_EXIT
 24479                                  
 24480                                  MORE_PRSE:
 24481 0000309B C606[158C]02            	mov	byte [cpyflag],2
 24482                                  				; tell CPARSE that 1st token is done
 24483 000030A0 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24484 000030A3 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24485                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24486                                  	; 01/03/2023
 24487                                  ;PARSEDONE:
 24488                                  	;popf
 24489                                  	;clc
 24490                                  	;jmp	short PARSE_EXIT
 24491                                  
 24492                                  PARSE_ERROR:			; error entry (er, exit) point
 24493 000030A5 9D                      	popf
 24494 000030A6 F9                      	stc
 24495                                  PARSE_EXIT:			; depend on not changing CF
 24496 000030A7 5E                      	pop	si
 24497 000030A8 5F                      	pop	di
 24498 000030A9 5A                      	pop	dx
 24499 000030AA 59                      	pop	cx
 24500 000030AB 5B                      	pop	bx
 24501 000030AC 58                      	pop	ax
 24502 000030AD C3                      	retn
 24503                                  
 24504                                  ; =============== S U B	R O U T	I N E =======================================
 24505                                  
 24506                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24507                                  ;
 24508                                  ; ENTRY:
 24509                                  ;   BH			argflags
 24510                                  ;   CX			character count in argstring
 24511                                  ;   DI			pointer to argstring
 24512                                  ;   comptr		ptr to starting loc of current token in original command
 24513                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24514                                  ; EXIT:
 24515                                  ;   argbufptr		points to next free section of argbuffer
 24516                                  ;   arg.argbuf		contains null-terminated argument strings
 24517                                  ;   arg.argvcnt 	argument count
 24518                                  ;   arg.argv[]		array of flags and pointers
 24519                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24520                                  ;   CF			set if error
 24521                                  ;   AL			carry set:  error code; otherwise, zero
 24522                                  
 24523                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24524                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24525                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM 
 24526                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 24527                                  newarg:
 24528 000030AE 53                      	push	bx
 24529 000030AF 51                      	push	cx
 24530 000030B0 52                      	push	dx
 24531 000030B1 57                      	push	di
 24532 000030B2 56                      	push	si
 24533 000030B3 9C                      	pushf
 24534 000030B4 E86200                  	call	arg_switch		; if it's a switch, record switch info
 24535                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24536                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24537                                  
 24538                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24539 000030B7 833E[7090]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24540 000030BC 7D50                    	jge	short to_many_args	; exceeded array limits
 24541 000030BE 88FE                    	mov	dh,bh			
 24542                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24543 000030C0 8B1E[7090]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24544                                  	;inc	word [ARG_ARGVCNT]
 24545 000030C4 FF06[7090]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24546                                  	;mov	ax,ARG_ARGV
 24547 000030C8 B8[B08D]                	mov	ax,ARG+ARG_UNIT.argv
 24548 000030CB E87E00                  	call	argv_calc		; convert offset to pointer
 24549                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24550                                  	;mov	word [bx+7],0
 24551 000030CE C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24552                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24553                                  	;mov	[bx+5],cx
 24554 000030D3 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24555                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24556                                  	;mov	[bx+2],dh
 24557 000030D6 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24558 000030D9 8B36[F492]              	mov	si,[ARGBUF_PTR]
 24559                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24560                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24561 000030DD 8937                    	mov	[bx],si			
 24562 000030DF 0336[578D]              	add	si,[STARTEL]		; save startel from new location
 24563 000030E3 29FE                    	sub	si,di			; form pointer into argbuf
 24564                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24565                                  	;mov	[bx+3],si
 24566 000030E5 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24567 000030E8 8B36[7893]              	mov	si,[COMPTR]
 24568                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24569                                  	;mov	[bx+9],si
 24570 000030EC 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24571 000030EF 89FE                    	mov	si,di			; now save argstring in argbuffer
 24572 000030F1 8B3E[F492]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24573                                  
 24574                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24575                                  ; PCDOS 7.1 COMMAND.COM
 24576                                  %if 0
 24577                                  	add	di,cx			; sure we're not about to run off
 24578                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24579                                  	;;cmp	di,ARG_ARGBUF+255
 24580                                  	;cmp	di,ARG+ARG_UNIT.argbuf+127
 24581                                  	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24582                                  	jge	short buf_oflow		; the end of the buffer (plus null byte)
 24583                                  	sub	di,cx
 24584                                  %else
 24585                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24586                                  	;mov	bx,ARG_ARGBUF+127
 24587 000030F5 BB[F390]                	mov	bx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24588 000030F8 29FB                    	sub	bx,di	; sure we're not about to run off
 24589 000030FA 39CB                    	cmp	bx,cx
 24590 000030FC 7302                    	jnb	short newarg_@
 24591 000030FE 89D9                    	mov	cx,bx	
 24592                                  %endif
 24593                                  
 24594                                  newarg_@:	; 27/07/2024
 24595 00003100 FC                      	cld
 24596 00003101 F3A4                    	rep	movsb
 24597 00003103 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24598 00003105 AA                      	stosb
 24599 00003106 893E[F492]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24600                                  newarg_done:
 24601 0000310A 9D                      	popf
 24602 0000310B F8                      	clc
 24603 0000310C EB05                    	jmp	short newarg_exit
 24604                                  
 24605                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24606                                  ; PCDOS 7.1 COMMAND.COM
 24607                                  %if 0
 24608                                  to_many_args:
 24609                                  	mov	ax,1
 24610                                  	jmp	short newarg_error
 24611                                  buf_oflow:
 24612                                  	mov	ax,2
 24613                                  %else
 24614                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24615                                  ;buf_oflow:
 24616                                  ;	; 27/07/2024
 24617                                  ;	; PCDOS 7.1 COMMAND.COM
 24618                                  ;	sub	di,cx
 24619                                  ;	;mov	cx,ARG_ARGBUF+7Fh
 24620                                  ;	mov	cx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24621                                  ;	sub	cx,di
 24622                                  ;	jmp     short newarg_@
 24623                                  to_many_args:
 24624 0000310E B80100                  	mov	ax,1
 24625                                  %endif
 24626                                  
 24627                                  newarg_error:
 24628 00003111 9D                      	popf
 24629 00003112 F9                      	stc
 24630                                  newarg_exit:
 24631 00003113 5E                      	pop	si
 24632 00003114 5F                      	pop	di
 24633 00003115 5A                      	pop	dx
 24634 00003116 59                      	pop	cx
 24635 00003117 5B                      	pop	bx
 24636 00003118 C3                      	retn
 24637                                  
 24638                                  ; =============== S U B	R O U T	I N E =======================================
 24639                                  
 24640                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24641                                  ; event that it is, and we can recognize
 24642                                  ;
 24643                                  ; ENTRY:
 24644                                  ;   As in <newarg>.
 24645                                  ; EXIT:
 24646                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24647                                  ; NOTE(S):
 24648                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24649                                  ;	on the order of definition in the <switch_list> variable and the
 24650                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24651                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24652                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24653                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24654                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24655                                  ;   *	An ugly routine.
 24656                                  
 24657                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24658                                  arg_switch:
 24659 00003119 50                      	push	ax
 24660 0000311A 53                      	push	bx
 24661 0000311B 51                      	push	cx
 24662 0000311C 57                      	push	di
 24663 0000311D 9C                      	pushf
 24664 0000311E F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24665 00003121 741C                    	jz	short arg_no_switch0
 24666 00003123 833E[7693]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24667 00003128 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24668 0000312A 8B1E[7693]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24669                                  	;mov	ax,offset TRANGROUP:arg.argv
 24670                                  	;mov	ax,ARG_ARGV
 24671 0000312E B8[B08D]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24672 00003131 E81800                  	call	argv_calc
 24673                                  	;or	[BX].argsw_word,BP
 24674                                  	;or	[bx+7],bp
 24675 00003134 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24676                                  	;or	arg.argswinfo,BP
 24677                                  	;or	[ARG_ARGSWINFO],bp
 24678 00003137 092E[7290]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24679                                  arg_yes_switch:
 24680 0000313B 9D                      	popf
 24681 0000313C F9                      	stc
 24682 0000313D EB08                    	jmp	short arg_switch_exit
 24683                                  
 24684                                  arg_no_switch0:
 24685                                  	;mov	ax,[ARG_ARGVCNT]
 24686 0000313F A1[7090]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24687 00003142 A3[7693]                	mov	[LASTARG],ax
 24688                                  arg_no_switch1:
 24689 00003145 9D                      	popf
 24690 00003146 F8                      	clc
 24691                                  arg_switch_exit:
 24692 00003147 5F                      	pop	di
 24693 00003148 59                      	pop	cx
 24694 00003149 5B                      	pop	bx
 24695 0000314A 58                      	pop	ax
 24696 0000314B C3                      	retn
 24697                                  
 24698                                  ; =============== S U B	R O U T	I N E =======================================
 24699                                  
 24700                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24701                                  ; the supplied array.  Method used for computing the address is:
 24702                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24703                                  ; ENTRY:
 24704                                  ;   AX	    --	    base of array
 24705                                  ;   BX	    --	    array index
 24706                                  ; EXIT:
 24707                                  ;   BX	    --	    byte offset
 24708                                  
 24709                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24710                                  argv_calc:
 24711 0000314C 50                      	push	ax		; Save base
 24712 0000314D 88D8                    	mov	al,bl		; al = array index
 24713                                  	;mov	bl,11
 24714 0000314F B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24715 00003151 F6E3                    	mul	bl		; ax = base offset
 24716 00003153 5B                      	pop	bx		; Get base
 24717 00003154 01D8                    	add	ax,bx		; Add in base offset
 24718 00003156 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24719 00003157 C3                      	retn
 24720                                  
 24721                                  ; ---------------------------------------------------------------------------
 24722                                  	
 24723                                  	;db 0Ah dup(0)
 24724                                  	;times 10 db 0
 24725                                  
 24726 00003158 90<rep 8h>              align 16
 24727                                  
 24728                                  ;============================================================================
 24729                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24730                                  ;============================================================================
 24731                                  ; 03/10/2018 - Retro DOS v3.0
 24732                                  
 24733                                  ;----------------------------------------------------------------------------
 24734                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24735                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24736                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24737                                  ;    file on disk. Directories specified in the user's search path will be
 24738                                  ;    searched for a matching file, if a match is not found in the current
 24739                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24740                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24741                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24742                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24743                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24744                                  ;    (easily) modified to make no assumptions about where its input is found.
 24745                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24746                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24747                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24748                                  ;    else that wants to save the whole shebang and then process other command
 24749                                  ;    lines.
 24750                                  ;
 24751                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24752                                  ;
 24753                                  ; ENTRY:
 24754                                  ;   <Path_Search>:	    argv[0].
 24755                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24756                                  ; EXIT:
 24757                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24758                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24759                                  ; NOTE(S):
 24760                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24761                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24762                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24763                                  ;	does not function as specified; see <Parseline> for more details.
 24764                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24765                                  ;	need to know about. This extra information is stored in a switch_flag
 24766                                  ;	word with each command-line argument; the switches themselves will not
 24767                                  ;	appear in the resulting arg structure.
 24768                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24769                                  ;----------------------------------------------------------------------------
 24770                                  
 24771                                  ; =============== S U B	R O U T	I N E =======================================
 24772                                  
 24773                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24774                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24775                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24776                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24777                                  ; have a match, either in the current working directory if we were handed
 24778                                  ; a filename, or in the specified directory, given a pathname. If this call
 24779                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24780                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24781                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24782                                  ; either the first invocation of search or on one of the succeeding calls
 24783                                  ; sets up the appropriate information for copying the successful pathname
 24784                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24785                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24786                                  ;
 24787                                  ; ENTRY:
 24788                                  ;   argv[0]		--	command name and associated information
 24789                                  ; EXIT:
 24790                                  ;   AX			--	non-zero indicates type of file found
 24791                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24792                                  ; NOTE(S):
 24793                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24794                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24795                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24796                                  ;	if search returns an .exe or .bat.
 24797                                  ;   5)	Clobbers dma address.
 24798                                  
 24799                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24800                                  PATH_SEP_CHAR	EQU	';'
 24801                                  
 24802                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24803                                  
 24804                                  	;special_delim equ 128
 24805                                  	;path_sep equ 4
 24806                                  	;wildcard equ 2
 24807                                  	;sw_flag  equ 1
 24808                                  
 24809                                  ;----------------------------------------------------------------------------
 24810                                  
 24811                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24812                                  
 24813                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24814                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24815                                  
 24816                                  path_search:
 24817 00003160 53                      	push	bx
 24818 00003161 51                      	push	cx
 24819 00003162 52                      	push	dx		; could use a "stack 'em" instruction
 24820 00003163 56                      	push	si
 24821 00003164 57                      	push	di
 24822 00003165 55                      	push	bp
 24823 00003166 9C                      	pushf
 24824                                  
 24825                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24826                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24827 00003167 F606[B28D]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24828 0000316C 7403                    	jz	short path_search_ok
 24829                                  path_failure_jmp:
 24830 0000316E E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24831                                  
 24832                                  path_search_ok:
 24833 00003171 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24834 00003174 BA[7A93]                	mov	dx,FBUF		; clobber old dma value with
 24835 00003177 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24836 0000317A CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24837                                  			; DS:DX	-> disk	transfer buffer
 24838 0000317C 06                      	push	es
 24839 0000317D E88BF1                  	call	find_path	; get a handle (ES:DI) on user path
 24840 00003180 8C06[A593]              	mov	[pathinfo+0],es	; and squirrel it away
 24841 00003184 893E[A793]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24842 00003188 893E[A993]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24843 0000318C 07                      	pop	es
 24844                                  	
 24845 0000318D BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24846 00003190 BE[CD89]                	mov	si,EXECPATH
 24847 00003193 E88002                  	call	STRIP
 24848 00003196 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24849                                  		
 24850 00003198 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24851 0000319A C706[FA93][587F]        	mov	word [search_error],baddrv_ptr
 24852 000031A0 E89F01                  	call	PSEARCH		; must do at least one search
 24853 000031A3 09C0                    	or	ax,ax		; find anything?
 24854 000031A5 7469                    	jz	short path_noinit
 24855                                  				; failure ... search farther
 24856 000031A7 89C5                    	mov	bp,ax		; success... save filetype code
 24857 000031A9 BF[CD89]                	mov	di,EXECPATH
 24858                                  	;mov	si,ds:arg.argv[0].argpointer
 24859                                  	;mov	si,[ARG_ARGV]
 24860 000031AC 8B36[B08D]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24861                                  	;mov	cx,ds:arg.argv[0].argstartel
 24862                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24863 000031B0 8B0E[B38D]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24864 000031B4 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24865                                  
 24866                                  ; We have the number of bytes in the prefix (up to the final component).
 24867                                  ; We need to form the complete pathname including leading drive and current
 24868                                  ; directory.
 24869                                  ;
 24870                                  ; Is there a drive letter present?
 24871                                  
 24872 000031B6 B43A                    	mov	ah,':'
 24873 000031B8 83F902                  	cmp	cx,2		; room for drive letter?
 24874 000031BB 7205                    	jb	short adddrive	; no, stick it in
 24875 000031BD 386401                  	cmp	[si+1],	ah	; colon present?
 24876 000031C0 7408                    	je	short movedrive	; yes, just move it
 24877                                  adddrive:
 24878 000031C2 A0[B78A]                	mov	al,[CURDRV]	; get current drive
 24879 000031C5 0441                    	add	al,'A'		; convert to uppercase letter
 24880 000031C7 AB                      	stosw			; store d:
 24881 000031C8 EB05                    	jmp	short checkpath
 24882                                  
 24883                                  movedrive:
 24884 000031CA AD                      	lodsw			; move d:
 24885 000031CB AB                      	stosw
 24886 000031CC 83E902                  	sub	cx,2		; 2 bytes less to move
 24887                                  checkpath:
 24888 000031CF 0C20                    	or	al,20h
 24889 000031D1 88C2                    	mov	dl,al
 24890                                  	;sub	dl,60h
 24891 000031D3 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24892                                  
 24893                                  ; Stick in beginning path char
 24894                                  
 24895 000031D6 A0[AB93]                	mov	al,[psep_char]
 24896 000031D9 AA                      	stosb
 24897                                  
 24898                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24899                                  ; Otherwise, get current dir for DL.
 24900                                  
 24901 000031DA 83F901                  	cmp	cx,1		; is there room for path char?
 24902 000031DD 720A                    	jb	short addpath	; no, go add path
 24903 000031DF AC                      	lodsb
 24904 000031E0 49                      	dec	cx
 24905 000031E1 3A06[AB93]              	cmp	al,[psep_char]	; is there a path separator?
 24906 000031E5 741C                    	je	short movepath	; yes, go move remainder of path
 24907 000031E7 41                      	inc	cx
 24908 000031E8 4E                      	dec	si		; undo the lodsb
 24909                                  addpath:
 24910 000031E9 56                      	push	si
 24911 000031EA 89FE                    	mov	si,di		; remainder of buffer
 24912 000031EC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24913 000031EF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24914                                  			; DL = drive (0=default,1=A,etc.)
 24915                                  			; DS:SI	points to 64-byte buffer area
 24916                                  
 24917                                  ; The previous current dir will succeed a previous find_first already worked.
 24918                                  ;
 24919                                  ; Find end of string.
 24920                                  
 24921 000031F1 89F7                    	mov	di,si
 24922 000031F3 5E                      	pop	si
 24923 000031F4 A0[AB93]                	mov	al,[psep_char]
 24924 000031F7 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24925 000031FA 7407                    	jz	short movepath	; yes, no need for path char
 24926                                  scanend:
 24927                                  	;cmp	byte [di],0	; end of string?
 24928                                  	;jz	short foundend
 24929                                  	;inc	di
 24930                                  	;jmp	short scanend
 24931                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24932 000031FC 47                      	inc	di
 24933 000031FD 803D00                  	cmp	byte [di],0
 24934 00003200 75FA                    	jnz	short scanend
 24935                                  
 24936                                  ; Stick in a trailing path char.
 24937                                  
 24938                                  foundend:
 24939 00003202 AA                      	stosb
 24940                                  
 24941                                  ; Move remaining part of path. Skip leading path char if present.
 24942                                  
 24943                                  movepath:
 24944 00003203 3804                    	cmp	[si],al		; first char a path char?
 24945 00003205 7502                    	jne	short copypath
 24946                                  	; 26/04/2023
 24947 00003207 46                      	inc	si		; move past leading char
 24948 00003208 49                      	dec	cx		; drop from count
 24949                                  copypath:
 24950 00003209 E302                    	jcxz	_copydone	; no chars to move!
 24951 0000320B F3A4                    	rep	movsb
 24952                                  _copydone:
 24953 0000320D E9A100                  	jmp	path_success
 24954                                  				; run off and form complete pathname
 24955                                  path_noinit:
 24956                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24957                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24958 00003210 F606[B28D]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24959 00003215 751B                    	jnz	short path_failure
 24960                                  				; complete pathname specified ==> fail
 24961                                  	;mov	bh,';'
 24962 00003217 B73B                    	mov	bh,PATH_SEP_CHAR
 24963                                  				; semicolon terminates pathstring
 24964                                  	;mov	dx,ds:arg.argv[0].argstartel
 24965                                  				; this is where the last element starts
 24966                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24967 00003219 8B16[B38D]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24968                                  	;sub	dx,ds:arg.argv[0].argpointer
 24969                                  				; form pointer into EXECPATH,
 24970                                  	;sub	dx,[ARG_ARGV]
 24971 0000321D 2B16[B08D]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24972 00003221 81C2[CD89]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24973                                  path_loop:
 24974 00003225 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24975 00003228 89C5                    	mov	bp,ax		; save filetype code
 24976 0000322A 9F                      	lahf			; save flags, just in case
 24977 0000322B 09ED                    	or	bp,bp		; did path_crunch find anything?
 24978 0000322D 7508                    	jnz	short path_found
 24979 0000322F 9E                      	sahf			; see? needed those flags, after all!
 24980 00003230 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24981                                  path_failure:
 24982 00003232 31C0                    	xor	ax,ax
 24983 00003234 E98700                  	jmp	path_exit
 24984                                  
 24985                                  path_found:				; pathinfo[] points to winner
 24986 00003237 BF[CD89]                	mov	di,EXECPATH
 24987                                  	;mov	cx,pathinfo[4]
 24988 0000323A 8B0E[A993]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24989                                  	;mov	si,pathinfo[2]
 24990 0000323E 8B36[A793]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24991                                  
 24992                                  ;	BAS Nov 20/84
 24993                                  ;   Look at the pathname and expand . and .. if they are the first element
 24994                                  ;   in the pathname (after the drive letter)
 24995                                  
 24996 00003242 06                      	push	es
 24997                                  	;push	pathinfo[0]
 24998 00003243 FF36[A593]              	push	word [pathinfo+0]
 24999 00003247 07                      	pop	es
 25000                                  ;SR;
 25001                                  ; Oops! Gets fooled if path= \;..
 25002                                  ; We should also check if a drive letter is really present
 25003                                  ;
 25004 00003248 26807C022E              	cmp	byte [es:si+2],'.'
 25005                                  				; Look for Current dir at start of path
 25006 0000324D 7534                    	jne	short path_cpy
 25007                                  
 25008                                  	; 18/03/2023
 25009                                  	; MSDOS 6.0
 25010 0000324F 26807C013A              	cmp	byte [es:si+1],':'
 25011                                  				; does path have drive letter?
 25012 00003254 752D                    	jne	short path_cpy	; no, copy the path string
 25013                                  
 25014 00003256 51                      	push	cx		; Save pointer to end of string
 25015                                  	;mov	al,[es:si]
 25016                                  	;mov	[di],al		; Copy drive letter, :, and root char
 25017                                  	;mov	al,[es:si+1]	; to EXECPATH
 25018                                  	;mov	[di+1],al
 25019                                  	; 05/05/2023
 25020 00003257 268B04                  	mov	ax,[es:si]
 25021 0000325A 8905                    	mov	[di],ax
 25022 0000325C A0[AB93]                	mov	al,[psep_char]
 25023 0000325F 884502                  	mov	[di+2],al
 25024 00003262 56                      	push	si		; Save pointer to begining of string
 25025 00003263 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25026 00003266 80CA20                  	or	dl,20h
 25027                                  	;sub	dl,60h
 25028 00003269 80EA60                  	sub	dl,'a'-1
 25029 0000326C 89FE                    	mov	si,di		; pointer to EXECPATH
 25030 0000326E 83C603                  	add	si,3		; Don't wipe out drive and root info
 25031 00003271 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25032 00003274 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25033                                  			; DL = drive (0=default,1=A,etc.)
 25034                                  			; DS:SI	points to 64-byte buffer area
 25035 00003276 E8F1F9                  	call	dstrlen		; Determine length of present info
 25036 00003279 01CE                    	add	si,cx		; Don't copy over drive and root info
 25037 0000327B 4E                      	dec	si
 25038 0000327C 89F7                    	mov	di,si		; Point to end of target string
 25039 0000327E 5E                      	pop	si		; Restore pointer to begining of string
 25040 0000327F 83C603                  	add	si,3		; Point past drive letter, :, .
 25041 00003282 59                      	pop	cx		; Restore pointer to end of string
 25042                                  path_cpy:
 25043 00003283 07                      	pop	es
 25044 00003284 29F1                    	sub	cx,si		; yields character count
 25045 00003286 1E                      	push	ds		; time to switch segments
 25046 00003287 FF36[A593]              	push	word [pathinfo+0]
 25047                                  				; string lives in this segment
 25048 0000328B 1F                      	pop	ds
 25049 0000328C FC                      	cld
 25050                                  
 25051                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25052                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25053                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25054                                  kloop:
 25055 0000328D AC                      	lodsb			;AN000;  3/3/KK
 25056 0000328E AA                      	stosb			;AN000;  3/3/KK
 25057 0000328F E82BF1                  	call	testkanj	;AN000;  3/3/KK
 25058 00003292 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25059 00003294 49                      	dec	cx		;AN000;  3/3/KK
 25060 00003295 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25061 00003297 A4                      	movsb			;AN000;  3/3/KK
 25062 00003298 49                      	dec	cx		;AN000;  3/3/KK
 25063 00003299 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25064 0000329C 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25065                                  popdone:			;AN000;  3/3/KK
 25066 0000329E 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25067 0000329F A0[AB93]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25068 000032A2 EB0C                    	jmp	short path_store
 25069                                  				;AN000;  3/3/KK
 25070                                  _notkanj1:
 25071                                  	; 26/04/2023
 25072 000032A4 E2E7                    	loop	kloop
 25073 000032A6 1F                      	pop	ds		; return to our segment
 25074 000032A7 4F                      	dec	di		; overwrite terminator
 25075 000032A8 A0[AB93]                	mov	al,[psep_char]	; with a pathname separator
 25076 000032AB 3A45FF                  	cmp	al,[di-1]
 25077 000032AE 7401                    	je	short path_success
 25078                                  path_store:
 25079 000032B0 AA                      	stosb
 25080                                  path_success:
 25081 000032B1 BE[AD93]                	mov	si,search_best_buf
 25082 000032B4 31C9                    	xor	cx,cx
 25083                                  path_succ_loop:
 25084 000032B6 AC                      	lodsb			; append winning filename to path
 25085 000032B7 AA                      	stosb			; (including terminating null)
 25086 000032B8 08C0                    	or	al,al
 25087 000032BA 75FA                    	jnz	short path_succ_loop
 25088 000032BC 89E8                    	mov	ax,bp		; retrieve filetype code
 25089                                  path_exit:
 25090 000032BE 9D                      	popf
 25091 000032BF 5D                      	pop	bp
 25092 000032C0 5F                      	pop	di
 25093 000032C1 5E                      	pop	si		; chill out...
 25094 000032C2 5A                      	pop	dx
 25095 000032C3 59                      	pop	cx
 25096 000032C4 5B                      	pop	bx
 25097 000032C5 C3                      	retn
 25098                                  
 25099                                  ; =============== S U B	R O U T	I N E =======================================
 25100                                  
 25101                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25102                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25103                                  ;
 25104                                  ; ENTRY:
 25105                                  ; EXIT:
 25106                                  ; NOTE(S):
 25107                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25108                                  
 25109                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25110                                  STORE_PCHAR:
 25111 000032C6 50                      	push	ax
 25112 000032C7 B02F                    	mov	al,'/'		; is the pathname-element separator
 25113 000032C9 E89EF3                  	call	pathchrcmp	; a regular slash?
 25114 000032CC 7402                    	jz	short STORE_SLASH
 25115                                  				; if yes, remember slash
 25116 000032CE B05C                    	mov	al,'\'
 25117                                  	; 18/03/2023
 25118                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25119                                  	;pop	ax
 25120                                  	;retn
 25121                                  STORE_SLASH:
 25122 000032D0 A2[AB93]                	mov	[psep_char],al
 25123 000032D3 58                      	pop	ax
 25124 000032D4 C3                      	retn
 25125                                  
 25126                                  ; =============== S U B	R O U T	I N E =======================================
 25127                                  
 25128                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25129                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25130                                  ; additional separator to use for breaking up the path-string. Null is the
 25131                                  ; default. Once the user-string has been formed, search is invoked to see
 25132                                  ; what's out there.
 25133                                  ;
 25134                                  ; ENTRY:
 25135                                  ;   BH			--	additional terminator character
 25136                                  ;   SI			--	pointer into pathstring to be dissected
 25137                                  ;   DX			--	pointer to stripped filename
 25138                                  ; EXIT:
 25139                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25140                                  ;   SI			--	moves along pathstring from call to call
 25141                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25142                                  ;   [tpbuf]		--	clobbered
 25143                                  ; NOTE(S):
 25144                                  ;   *	Implicit in this code is the ability to specify when to search
 25145                                  ;	the current directory (if at all) through the PATH defined by
 25146                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25147                                  ;	current directory before the bin and etc directories of drive c).
 25148                                  
 25149                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25150                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25151                                  
 25152                                  path_crunch:
 25153 000032D5 53                      	push	bx
 25154 000032D6 51                      	push	cx
 25155 000032D7 52                      	push	dx
 25156 000032D8 57                      	push	di
 25157 000032D9 56                      	push	si
 25158                                  	;pushf	; ** ; 18/03/2023
 25159 000032DA E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25160 000032DD BF[F692]                	mov	di,TPBUF	; destination of concatenated string
 25161 000032E0 8B36[A993]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25162 000032E4 8936[A793]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25163 000032E8 1E                      	push	ds		; save old segment pointer
 25164 000032E9 FF36[A593]              	push	word [pathinfo+0]
 25165                                  				; replace with pointer to userpath's
 25166 000032ED 1F                      	pop	ds		; segment
 25167                                  	; 26/04/2023
 25168 000032EE 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK
 25169                                  path_cr_copy:
 25170 000032F0 AC                      	lodsb			; get a pathname byte
 25171 000032F1 08C0                    	or	al,al		; check for terminator(s)
 25172 000032F3 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25173 000032F5 38F8                    	cmp	al,bh
 25174 000032F7 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25175                                  	;
 25176                                  	; 18/03/2023
 25177                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25178 000032F9 E8C1F0                  	call	testkanj	;AN000; 3/3/KK
 25179 000032FC 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25180 000032FE AA                      	stosb			;AN000; 3/3/KK
 25181 000032FF A4                      	movsb			;AN000; 3/3/KK
 25182 00003300 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK
 25183 00003302 EBEC                    	jmp	short path_cr_copy
 25184                                  _notkanj2:
 25185 00003304 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25186                                  	;
 25187 00003306 AA                      	stosb
 25188 00003307 EBE7                    	jmp	short path_cr_copy
 25189                                  
 25190                                  path_seg:
 25191 00003309 1F                      	pop	ds		; restore old data segment
 25192 0000330A 8936[A993]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25193 0000330E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25194                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25195 00003310 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25196 00003312 81FF[F692]              	cmp	di,TPBUF	; was there really anything in pathstr?
 25197 00003316 7421                    	je	short path_cr_leave
 25198                                  				; if nothing was copied, pathstr empty
 25199                                  path_cr_look:
 25200 00003318 A0[AB93]                	mov	al,[psep_char]	; form complete pathname
 25201                                  	;
 25202                                  	; 18/03/2023
 25203                                  	; MSDOS 6.0
 25204 0000331B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25205 0000331D 7505                    	jnz	short path_cr_store
 25206                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25207                                  	;
 25208 0000331F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25209 00003322 7401                    	je	short path_cr_l1
 25210                                  path_cr_store:
 25211 00003324 AA                      	stosb
 25212                                  path_cr_l1:
 25213 00003325 89D6                    	mov	si,dx
 25214                                  path_cr_l2:
 25215 00003327 AC                      	lodsb			; tack the stripped filename onto
 25216 00003328 AA                      	stosb			; the end of the path, up to and
 25217 00003329 08C0                    	or	al,al		; including the terminating null
 25218 0000332B 75FA                    	jnz	short path_cr_l2
 25219 0000332D BA[F692]                	mov	dx,TPBUF	; and look for an appropriate file...
 25220 00003330 C706[FA93][5480]        	mov	word [search_error],BADPMES_PTR
 25221                                  	;invoke search
 25222 00003336 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25223                                  
 25224                                  	; 18/03/2023
 25225                                  ;path_cr_leave:
 25226                                  	;or	bl,bl		; did we finish off the pathstring?
 25227                                  	;jz	short path_cr_empty
 25228                                  	;			; null in BL means all gone...
 25229                                  	;popf	; **		; otherwise, plenty left
 25230                                  	;clc
 25231                                  	;jmp	short path_cr_exit
 25232                                  ;path_cr_empty:
 25233                                  	;popf	; **
 25234                                  	;stc
 25235                                  ;path_cr_exit:
 25236                                  
 25237                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25238                                  path_cr_leave:
 25239                                  	;popf ; ** ; 18/03/2023
 25240 00003339 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25241                                  
 25242                                  path_cr_exit:
 25243 0000333C 5E                      	pop	si
 25244 0000333D 5F                      	pop	di
 25245 0000333E 5A                      	pop	dx
 25246 0000333F 59                      	pop	cx
 25247 00003340 5B                      	pop	bx
 25248 00003341 C3                      	retn
 25249                                  
 25250                                  ;============================================================================
 25251                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25252                                  ;============================================================================
 25253                                  ; 02/10/2018 - Retro DOS v3.0
 25254                                  
 25255                                  ;----------------------------------------------------------------------------
 25256                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25257                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25258                                  ; lowest priority). Where conflicts arise, the extension with
 25259                                  ; the highest priority is favored.
 25260                                  ; ENTRY:
 25261                                  ;   DX		--	pointer to null-terminated pathname
 25262                                  ;   fbuf	--	dma buffer for findfirst/next
 25263                                  ; EXIT:
 25264                                  ;   AX		--	8)  file found with .com extension
 25265                                  ;			4)  file found with .exe extension
 25266                                  ;			2)  file found with .bat extension
 25267                                  ;			0)  no such file to be found
 25268                                  ;   (if AX is non-zero:)
 25269                                  ;   [search_best]	identical to AX
 25270                                  ;   [search_best_buf]	null-terminated filename
 25271                                  ; NOTES:
 25272                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25273                                  ;---------------
 25274                                  ; CONSTANTS:
 25275                                  ;---------------
 25276                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25277                                  SEARCH_COM		EQU	8
 25278                                  SEARCH_EXE		EQU	4
 25279                                  SEARCH_BAT		EQU	2
 25280                                  FNAME_LEN		EQU	8
 25281                                  FNAME_MAX_LEN		EQU	13
 25282                                  DOT			EQU	'.'
 25283                                  WILDCHAR		EQU	'?'
 25284                                  
 25285                                  
 25286                                  ; =============== S U B	R O U T	I N E =======================================
 25287                                  
 25288                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25289                                  
 25290                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25291                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25292                                  	
 25293                                  PSEARCH:
 25294 00003342 51                      	push	cx
 25295 00003343 52                      	push	dx
 25296 00003344 57                      	push	di
 25297 00003345 56                      	push	si
 25298                                  	;pushf	; ** ; 18/03/2023
 25299 00003346 52                      	push	dx		; check drivespec (save pname ptr)
 25300 00003347 89D7                    	mov	di,dx		; working copy of pathname
 25301 00003349 BE[BA93]                	mov	si,search_curdir_buf
 25302 0000334C 31D2                    	xor	dx,dx		; zero means current drive
 25303 0000334E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25304 00003352 7508                    	jne	short SEARCH_DIR_CHECK
 25305 00003354 8A15                    	mov	dl,[di]		; get the drive byte
 25306 00003356 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25307 00003359 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25308                                  SEARCH_DIR_CHECK:
 25309 0000335C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25310 0000335F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25311                                  			; DL = drive (0=default,1=A,etc.)
 25312                                  			; DS:SI	points to 64-byte buffer area
 25313 00003361 5A                      	pop	dx		; directory? If we can't we'll
 25314 00003362 724C                    	jc	short SEARCH_INVALID_DRIVE
 25315                                  				; assume it's a bad drive...
 25316 00003364 B91300                  	mov	cx,search_attr	; 13h
 25317                                  				; filetypes to search for
 25318 00003367 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25319 0000336A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25320                                  			; CX = search attributes
 25321                                  			; DS:DX	-> ASCIZ filespec
 25322                                  			; (drive,path, and wildcards allowed)
 25323 0000336C 7249                    	jc	short SEARCH_NO_FILE
 25324 0000336E C606[AC93]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25325 00003373 C606[AD93]00            	mov	byte [search_best_buf],ANULL
 25326                                  				; 0 ; nothing's been found, yet
 25327                                  SEARCH_LOOP:
 25328 00003378 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25329 0000337B 3A06[AC93]              	cmp	al,[search_best]
 25330                                  				; better than what we've found so far?
 25331 0000337F 7E13                    	jle	short SEARCH_NEXT
 25332                                  				; no, look for another
 25333 00003381 A2[AC93]                	mov	[search_best],al
 25334                                  				; found something... save its code
 25335                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25336                                  	;mov	si,FBUF_PNAME
 25337 00003384 BE[9893]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25338 00003387 BF[AD93]                	mov	di,search_best_buf
 25339 0000338A B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25340 0000338D FC                      	cld
 25341 0000338E F3A4                    	rep	movsb		; save complete pathname representation
 25342 00003390 3C08                    	cmp	al,SEARCH_COM	; 8
 25343                                  				; have we found the best of all?
 25344 00003392 740A                    	je	short SEARCH_DONE
 25345                                  SEARCH_NEXT:			; keep on looking
 25346 00003394 B91300                  	mov	cx,search_attr ; 13h
 25347 00003397 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25348 0000339A CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25349                                  			; [DTA]	= data block from
 25350                                  			; last AH = 4Eh/4Fh call
 25351 0000339C 73DA                    	jnc	short SEARCH_LOOP
 25352                                  SEARCH_DONE:			; it's all over with...
 25353 0000339E A0[AC93]                	mov	al,[search_best]
 25354                                  				; pick best to return with
 25355                                  	; 18/03/2023
 25356                                  	; MSDOS 6.0
 25357 000033A1 803E[668D]01            	cmp	byte [ext_entered],1
 25358                                  				;AN005; Did user request a specific ext?
 25359 000033A6 7411                    	je	short SEARCH_EXIT
 25360                                  				;AN005; no - exit
 25361 000033A8 A0[668D]                	mov	al,[ext_entered]
 25362                                  				;AN005; yes - get the real file type back
 25363 000033AB A2[AC93]                	mov	[search_best],al
 25364                                  				;AN005; save the real file type
 25365                                  	;
 25366 000033AE EB09                    	jmp	short SEARCH_EXIT
 25367                                  
 25368                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25369 000033B0 8B16[FA93]              	mov	dx,[search_error]
 25370                                  				; appropriate error message
 25371 000033B4 E81A1A                  	call	std_printf	; and pretend no file found
 25372                                  
 25373                                  SEARCH_NO_FILE:			; couldn't find a match
 25374                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25375                                  	; 18/03/2023
 25376 000033B7 31C0                    	xor	ax,ax
 25377                                  SEARCH_EXIT:
 25378                                  	;popf	; ** ; 18/03/2023
 25379 000033B9 5E                      	pop	si
 25380 000033BA 5F                      	pop	di
 25381 000033BB 5A                      	pop	dx
 25382 000033BC 59                      	pop	cx
 25383 000033BD C3                      	retn
 25384                                  
 25385                                  ; =============== S U B	R O U T	I N E =======================================
 25386                                  
 25387                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25388                                  ;
 25389                                  ; ENTRY:
 25390                                  ;   fbuf    --	dma buffer containing filename
 25391                                  ; EXIT:
 25392                                  ;   AX	    --	file code, as given in search header
 25393                                  ; NOTE(S):
 25394                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25395                                  
 25396                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25397                                  
 25398                                  SEARCH_FTYPE:
 25399 000033BE 57                      	push	di
 25400 000033BF 56                      	push	si
 25401                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25402                                  	; 18/02/2023
 25403 000033C0 31C0                    	xor	ax,ax ; ax = 0		
 25404                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25405                                  	;mov	di,FBUF_PNAME
 25406 000033C2 BF[9893]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25407 000033C5 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25408 000033C8 FC                      	cld
 25409 000033C9 F2AE                    	repnz	scasb		; search for the terminating null
 25410 000033CB 7535                    	jnz	short FTYPE_EXIT
 25411                                  				; weird... no null byte at end
 25412 000033CD 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25413                                  
 25414                                  	; Compare .COM
 25415                                  
 25416 000033D0 BE[2584]                	mov	si,comext ; ".COM"
 25417 000033D3 89F8                    	mov	ax,di
 25418 000033D5 A7                      	cmpsw
 25419 000033D6 7508                    	jnz	short FTYPE_EXE
 25420 000033D8 A7                      	cmpsw
 25421 000033D9 7505                    	jnz	short FTYPE_EXE
 25422                                  	;mov	ax,8
 25423 000033DB B80800                  	mov	ax,SEARCH_COM	; success!
 25424 000033DE EB22                    	jmp	short FTYPE_EXIT
 25425                                  
 25426                                  	; Compare .EXE
 25427                                  FTYPE_EXE:			; still looking... now for '.exe'
 25428 000033E0 89C7                    	mov	di,ax
 25429 000033E2 BE[2984]                	mov	si,exeext ; ".EXE"
 25430 000033E5 A7                      	cmpsw
 25431 000033E6 7508                    	jnz	short FTYPE_BAT
 25432 000033E8 A7                      	cmpsw
 25433 000033E9 7505                    	jnz	short FTYPE_BAT
 25434                                  	;mov	ax,4
 25435 000033EB B80400                  	mov	ax,SEARCH_EXE	; success!
 25436 000033EE EB12                    	jmp	short FTYPE_EXIT
 25437                                  
 25438                                  	; Compare .BAT
 25439                                  FTYPE_BAT:			; still looking... now for '.bat'
 25440 000033F0 89C7                    	mov	di,ax
 25441 000033F2 BE[2D84]                	mov	si,batext ; ".BAT"
 25442 000033F5 A7                      	cmpsw
 25443 000033F6 7508                    	jnz	short FTYPE_FAIL
 25444 000033F8 A7                      	cmpsw
 25445 000033F9 7505                    	jnz	short FTYPE_FAIL
 25446                                  	;mov	ax,2
 25447 000033FB B80200                  	mov	ax,SEARCH_BAT	; success!
 25448 000033FE EB02                    	jmp	short FTYPE_EXIT
 25449                                  
 25450                                  FTYPE_FAIL:			; file doesn't match what we need
 25451                                  	;mov	ax,ANULL ; 0
 25452                                  	; 18/03/2023
 25453 00003400 29C0                    	sub	ax,ax  ; ax = 0
 25454                                  FTYPE_EXIT:
 25455                                  	; 18/03/2023
 25456                                  	; MSDOS 6.0
 25457 00003402 803E[668D]01            	cmp	byte [ext_entered],1
 25458                                  				;AN005; was an extension entered?
 25459 00003407 740A                    	jz	short FTYPE_DONE
 25460                                  				;AN005; no - exit
 25461                                  	;cmp	ax,ANULL	;AN005; was any match found
 25462 00003409 21C0                    	and	ax,ax  ; ax = 0 ?
 25463 0000340B 7406                    	jz	short FTYPE_DONE
 25464                                  				;AN005; no - exit
 25465 0000340D A2[668D]                	mov	[ext_entered],al
 25466                                  				;AN005; save the match type found
 25467 00003410 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25468                                  FTYPE_DONE:
 25469 00003413 5E                      	pop	si
 25470 00003414 5F                      	pop	di
 25471 00003415 C3                      	retn
 25472                                  
 25473                                  ; =============== S U B	R O U T	I N E =======================================
 25474                                  
 25475                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25476                                  ; replacing any extension with wildcards.
 25477                                  ;
 25478                                  ; ENTRY:
 25479                                  ;	BX	--	maximum length of destination buffer
 25480                                  ;	DS:SI	--	address of destination buffer
 25481                                  ;	argv[0] --	command name to be stripped
 25482                                  ; EXIT:
 25483                                  ;	CF	--	set if failure, clear if successful
 25484                                  ; NOTE(S):
 25485                                  
 25486                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25487                                  
 25488                                  STRIP:
 25489 00003416 50                      	push	ax
 25490 00003417 53                      	push	bx
 25491 00003418 51                      	push	cx
 25492 00003419 52                      	push	dx
 25493 0000341A 57                      	push	di
 25494 0000341B 56                      	push	si
 25495                                  	;pushf	; ** ; 18/03/2023
 25496                                  		
 25497                                  	; 05/05/2023
 25498                                  	; MSDOS 6.0
 25499 0000341C C606[668D]01            	mov	byte [ext_entered],1
 25500                                  				;AN005; assume no extension on file name
 25501                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25502                                  	;mov	dx,[ARG_ARGV]
 25503                                  	;mov	dx,ds:arg.argv[0].argpointer
 25504                                  				; save pointer to beginning of argstring
 25505                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25506 00003421 8B16[B08D]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25507                                  	;mov	di,ds:arg.argv[0].argstartel
 25508                                  				; beginning of last pathname element
 25509                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25510 00003425 8B3E[B38D]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25511 00003429 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25512 0000342C 743D                    	je	short STRIP_ERROR
 25513 0000342E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25514                                  	;add	cx,ds:arg.argv[0].arglen
 25515                                  	;add	cx,[ARGV0_ARGLEN]
 25516 00003430 030E[B58D]              	add	cx,[ARG+ARGV_ELE.arglen]
 25517 00003434 29F9                    	sub	cx,di		; and then find length of last element
 25518 00003436 41                      	inc	cx		; include null as well
 25519 00003437 B02E                    	mov	al,'.'
 25520                                  	;mov	al,DOT		; let's find the filetype extension
 25521 00003439 FC                      	cld
 25522 0000343A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25523                                  
 25524                                  	; 18/03/2023
 25525                                  	; MSDOS 6.0
 25526 0000343C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25527 0000343E B000                    	mov	al,0 ; 18/03/2023
 25528                                  	;mov	byte [ext_entered],0
 25529 00003440 A2[668D]                	mov	[ext_entered],al
 25530                                  				;AN005; we found an extension
 25531                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25532                                  	;mov	al,0
 25533 00003443 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25534                                  PROCESS_EXT:
 25535                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25536 00003445 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25537 00003447 29D1                    	sub	cx,dx		; number of bytes to be copied
 25538 00003449 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25539 0000344C 39D9                    	cmp	cx,bx
 25540 0000344E 7F1B                    	jg	short STRIP_ERROR
 25541                                  				; if not, we must have a bad pathname
 25542 00003450 89F7                    	mov	di,si		; destination buffer
 25543 00003452 89D6                    	mov	si,dx		; source is beginning of pathname
 25544 00003454 FC                      	cld
 25545 00003455 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25546                                  
 25547                                  	; 18/03/2023
 25548                                  	; MSDOS 6.0
 25549 00003457 803E[668D]01            	cmp	byte [ext_entered],1
 25550                                  				;AN005; if an extension was entered
 25551 0000345C 750A                    	jne	short SKIP_WILDS
 25552                                  				;AN005;    don't set up wildcard ext.
 25553                                  
 25554                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25555 0000345E 4F                      	dec	di		; overwrite null or dot
 25556 0000345F AA                      	stosb			; with a dot
 25557 00003460 B03F                    	mov	al,'?'
 25558                                  	;mov	al,WILDCHAR	; now add wildcards
 25559 00003462 AA                      	stosb
 25560 00003463 AA                      	stosb
 25561 00003464 AA                      	stosb
 25562 00003465 B000                    	mov	al,0
 25563                                  	;mov	al,ANULL	; and a terminating null	
 25564 00003467 AA                      	stosb
 25565                                  SKIP_WILDS:
 25566                                  	;popf	; ** ; 18/03/2023
 25567 00003468 F8                      	clc
 25568 00003469 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25569                                  
 25570                                  STRIP_ERROR:
 25571                                  	;popf	; ** ; 18/03/2023
 25572 0000346B F9                      	stc
 25573                                  STRIP_EXIT:
 25574 0000346C 5E                      	pop	si
 25575 0000346D 5F                      	pop	di
 25576 0000346E 5A                      	pop	dx
 25577 0000346F 59                      	pop	cx
 25578 00003470 5B                      	pop	bx
 25579 00003471 58                      	pop	ax
 25580 00003472 C3                      	retn
 25581                                  
 25582                                  ; =============== S U B	R O U T	I N E =======================================
 25583                                  
 25584                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25585                                  ;
 25586                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25587                                  ; beginning of this area. The caller indicates how much extra space is
 25588                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25589                                  ; an offset into that area, indicating where the caller may preserve its own
 25590                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25591                                  ; ENTRY:
 25592                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25593                                  ; EXIT:
 25594                                  ;   AX	    --	segment of new area.
 25595                                  ;   CF	    --	set if unable to save a copy.
 25596                                  ; NOTE(S):
 25597                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25598                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25599                                  ;	paragraphs.
 25600                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25601                                  ;	as the caller of Save_Args requests.
 25602                                  ;   3)	AX is undefined if CF indicates an error.
 25603                                  
 25604                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25605                                  
 25606                                  SAVE_ARGS:
 25607 00003473 53                      	push	bx
 25608 00003474 51                      	push	cx
 25609 00003475 52                      	push	dx
 25610 00003476 57                      	push	di
 25611 00003477 56                      	push	si
 25612 00003478 55                      	push	bp
 25613                                  	; 01/05/2023
 25614                                  	; 26/04/2023
 25615                                  	;pushf ; **
 25616                                  	;add	bx,1363		; space for arg structure, round up
 25617 00003479 81C35304                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25618                                  			; 1092+15 ; 31/07/2024
 25619 0000347D B104                    	mov	cl,4		; to paragraph size and convert
 25620 0000347F D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25621 00003481 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25622 00003484 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25623                                  			; BX = number of 16-byte paragraphs desired
 25624 00003486 7241                    	jc	short SAVE_ERROR ; ***
 25625 00003488 89C5                    	mov	bp,ax		; save segment id
 25626 0000348A 06                      	push	es		; save TRANGROUP address
 25627 0000348B 8EC0                    	mov	es,ax		; switch to new memory segment
 25628                                  	; assume es:nothing
 25629                                  	;mov	cx,1348		; get back structure size
 25630 0000348D B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092 ; 31/07/2024
 25631 00003490 31FF                    	xor	di,di		; destination is new memory area
 25632                                  	;mov	si,ARG_ARGV
 25633 00003492 BE[B08D]                	mov	si,ARG		; source is arg structure
 25634                                  	; 09/08/2024
 25635 00003495 56                      	push	si
 25636 00003496 F3A4                    	rep	movsb		; move that sucker!
 25637                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25638                                  	;mov	cx,[ARG_ARGVCNT]
 25639 00003498 8B0E[7090]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25640 0000349C 31C0                    	xor	ax,ax		; base address for argv_calc
 25641                                  
 25642                                  ;	Bugbug:	What did they mean by this?
 25643                                  ;	Note that the replacement line produces exactly the same code.
 25644                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25645                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25646                                  
 25647                                  	;;mov	si,ARG_ARGV
 25648                                  	;mov	si,ARG
 25649                                  	; 09/08/2024
 25650 0000349E 5E                      	pop	si
 25651                                  SAVE_PTR_LOOP:
 25652 0000349F 49                      	dec	cx		; exhausted all args?
 25653 000034A0 7C24                    	jl	short SAVE_DONE
 25654 000034A2 89CB                    	mov	bx,cx		; get arg index and
 25655 000034A4 E8A5FC                  	call	argv_calc	; convert to a pointer
 25656                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25657                                  	;mov	dx,[ARG_ARGV+bx]
 25658 000034A7 8B97[B08D]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25659 000034AB 29F2                    	sub	dx,si		; adjust argpointer
 25660                                  	;mov	es:argv[BX].argpointer,dx
 25661                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25662 000034AD 268917                  	mov	[es:bx],dx
 25663                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25664                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25665 000034B0 8B97[B38D]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25666 000034B4 29F2                    	sub	dx,si		; and adjust argstartel
 25667                                  	;mov	es:argv[bx].argstartel,dx
 25668                                  	;mov	[es:bx+3],dx
 25669 000034B6 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25670                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25671                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25672 000034BA 8B97[B98D]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25673 000034BE 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25674                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25675                                  	;mov	[es:bx+9],dx
 25676 000034C0 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25677 000034C4 EBD9                    	jmp	short SAVE_PTR_LOOP
 25678                                  SAVE_DONE:
 25679 000034C6 07                      	pop	es		; back we go to TRANGROUP
 25680                                  	; assume es:nothing
 25681 000034C7 89E8                    	mov	ax,bp		; restore segment id
 25682                                  	; 26/04/2023
 25683                                  	; cf = 0 ; *
 25684                                  	;jmp	short SAVE_OK
 25685                                  
 25686                                  	; 26/04/2023
 25687                                  ;SAVE_ERROR:
 25688                                  ;	; 26/04/2023
 25689                                  ;	;popf ; **
 25690                                  ;	stc
 25691                                  ;	jmp	short SAVE_EXIT
 25692                                  
 25693                                  SAVE_OK:
 25694                                  	; 26/04/2023
 25695                                  	;popf ; **
 25696                                  	; 26/04/2023
 25697                                  	; cf = 0 ; *
 25698                                  	;clc
 25699                                  SAVE_EXIT:
 25700                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25701 000034C9 5D                      	pop	bp
 25702 000034CA 5E                      	pop	si
 25703 000034CB 5F                      	pop	di
 25704 000034CC 5A                      	pop	dx
 25705 000034CD 59                      	pop	cx
 25706 000034CE 5B                      	pop	bx
 25707                                  answ_no:	; 26/04/2023
 25708 000034CF C3                      	retn
 25709                                  
 25710                                  ;============================================================================
 25711                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25712                                  ;============================================================================
 25713                                  ; 02/10/2018 - Retro DOS v3.0
 25714                                  
 25715                                  ; Title	COMMAND Language midifiable Code Transient
 25716                                  
 25717                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25718                                  
 25719                                  ; =============== S U B	R O U T	I N E =======================================
 25720                                  
 25721                                  ; ****************************************************************
 25722                                  ; *
 25723                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25724                                  ; *
 25725                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25726                                  ; *		 user for Y/N if necessary. If an error occurs,
 25727                                  ; *		 set up an error message and go to CERROR.
 25728                                  ; *
 25729                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25730                                  ; *		 Current directory set to entered directory
 25731                                  ; *
 25732                                  ; * OUTPUT:	 none
 25733                                  ; *
 25734                                  ; ****************************************************************
 25735                                  ;
 25736                                  ; ARE YOU SURE prompt when deleting *.*
 25737                                  
 25738                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25739                                  
 25740                                  notest2:
 25741 000034D0 B90B00                  	mov	cx,11
 25742 000034D3 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25743                                  ambspec:
 25744 000034D6 AC                      	lodsb
 25745 000034D7 3C3F                    	cmp	al,'?'
 25746 000034D9 7502                    	jne	short allfil
 25747 000034DB E2F9                    	loop	ambspec
 25748                                  allfil:
 25749                                  	; 19/03/2023
 25750                                  	;cmp	cx,0
 25751 000034DD 09C9                    	or	cx,cx
 25752 000034DF 752E                    	jnz	short noprmpt
 25753                                  askagn:	
 25754 000034E1 BA[DB7F]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25755 000034E4 E8EA18                  	call	std_printf
 25756 000034E7 BE8000                  	mov	si,80h
 25757 000034EA 89F2                    	mov	dx,si
 25758 000034EC C7047800                	mov	word [si],120	; zero length
 25759                                  	;mov	ax,0C0Ah
 25760 000034F0 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25761 000034F3 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25762                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25763 000034F5 AD                      	lodsw
 25764 000034F6 08E4                    	or	ah,ah
 25765 000034F8 74E7                    	jz	short askagn
 25766 000034FA E8DFF0                  	call	scanoff
 25767                                  	; 19/03/2023
 25768                                  	; MSDOS 6.0
 25769 000034FD E80C02                  	call	char_in_xlat	; Convert to upper case
 25770                                  	;retc			; return if function not supported
 25771                                  	; 19/03/2023
 25772                                  	;jnc	short check_yn
 25773                                  ;answ_no:
 25774                                  	;retn
 25775 00003500 72CD                    	jc	short answ_no
 25776                                  
 25777                                  	; 19/03/2023
 25778                                  	; AL = 0 if it was (country depended) NO character
 25779                                  	; AL = 1 if it was (country depenced) YES character
 25780                                  
 25781                                  	; MSDOS 3.3
 25782                                  	;call	UPCONV
 25783                                  
 25784                                  	; 19/03/2023	
 25785                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25786                                  	;cmp	al,[CAPITAL_N]
 25787                                  	;jne	short CHECK_Y
 25788                                  	;retn
 25789                                  ;CHECK_Y:
 25790                                  	;cmp	al,[CAPITAL_Y]
 25791                                  	;pushf
 25792                                  	;call	CRLF2
 25793                                  	;popf
 25794                                  	;jne	short ASKAGN
 25795                                  
 25796                                  check_yn:
 25797                                  	; 19/03/2023
 25798                                  	;cmp	al,0	; NO character
 25799 00003502 08C0                    	or	al,al
 25800 00003504 74C9                    	jz	short answ_no
 25801                                  	;cmp	al,1	 ;YES character
 25802 00003506 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25803 00003508 9C                      	pushf
 25804 00003509 E8C3F0                  	call	CRLF2
 25805 0000350C 9D                      	popf
 25806 0000350D 75D2                    	jnz	short askagn
 25807                                  noprmpt:
 25808 0000350F B413                    	mov	ah,FCB_Delete ; 13h
 25809 00003511 BA5C00                  	mov	dx,FCB ; 5Ch
 25810 00003514 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25811                                  			; DS:DX	-> FCB with filename field filled with
 25812                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25813                                  			; Return: AL = 00h file	found,FFh file	not found
 25814 00003516 FEC0                    	inc	al
 25815 00003518 7403                    	jz	short eraerr
 25816                                  	; 26/04/2023
 25817                                  	;call	RestUDir
 25818                                  ;answ_no:
 25819                                  	;retn
 25820 0000351A E96FEF                  	jmp	RestUDir ; 26/04/2023
 25821                                  
 25822                                  	; 19/03/2023
 25823                                  	; MSDOS 6.0
 25824                                  eraerr:
 25825                                  	;invoke	set_ext_error_msg
 25826                                  				;AN022; set up the extended error
 25827 0000351D E8C0E7                  	call	Set_Ext_Error_Msg
 25828 00003520 52                      	push	dx		;AN022; save message
 25829                                  	;invoke	RESTUDIR
 25830 00003521 E868EF                  	call	RestUDir
 25831 00003524 5A                      	pop	dx		;AN022; restore message
 25832                                  	
 25833 00003525 833E[FC7E]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25834                                  				;AN022; convert no more files to
 25835 0000352A 7506                    	jne	short cerrorj2	;AN022;  file not found
 25836 0000352C C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25837                                  				;AN000; get message number in control block
 25838                                  cerrorj2:
 25839 00003532 E91BF4                  	jmp	cerror
 25840                                  	
 25841                                  	; 19/03/2023
 25842                                  	; MSDOS 3.3
 25843                                  ;ERAERR:	
 25844                                  	;mov	ah,Set_DMA ; 1Ah
 25845                                  	;mov	dx,FCB ; 5Ch
 25846                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25847                                  	;			; DS:DX	-> disk	transfer buffer
 25848                                  	;mov	ah,Dir_Search_First ; 11h
 25849                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25850                                  	;			; DS:DX	-> FCB
 25851                                  	;push	ax
 25852                                  	;call	RESTUDIR
 25853                                  	;pop	ax
 25854                                  	;mov	dx,FNOTFOUNDPTR
 25855                                  	;inc	al
 25856                                  	;jz	short CERRORJ
 25857                                  	;mov	dx,ACCDENPTR
 25858                                  	;jmp	CERROR
 25859                                  
 25860                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25862                                  
 25863                                  ; ****************************************************************
 25864                                  ; *
 25865                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25866                                  ; *
 25867                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25868                                  ; *		 user for Y/N where necessary. If an error occurs
 25869                                  ; *		 set up and error message and transfer control
 25870                                  ; *		 to CERROR.
 25871                                  ; *
 25872                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25873                                  ; *		 Current directory set to entered directory
 25874                                  ; *
 25875                                  ; * OUTPUT:	 none
 25876                                  ; *
 25877                                  ; ****************************************************************
 25878                                  
 25879                                  	; 19/03/2023
 25880                                  slashp_erase:				;AN000; entry point
 25881                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25882 00003535 E812E9                  	call	build_dir_string
 25883                                  
 25884 00003538 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25885                                  	;mov	dx,offset trangroup:destdir
 25886 0000353A BA[678B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25887 0000353D CD21                    	int	21h			;AN000;
 25888                                  
 25889                                  	;mov	ah,11h
 25890 0000353F B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25891 00003541 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25892 00003544 CD21                    	int	21h			;AN000;
 25893 00003546 FEC0                    	inc	al			;AN000; did an error occur
 25894                                  	;jz	short eraerr		;AN022; go to error exit
 25895                                  	; 26/04/2023
 25896 00003548 7502                    	jnz	short delete_prompt_loop
 25897                                  
 25898                                  	; 26/04/2023
 25899                                  stop_del:
 25900 0000354A EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25901                                  
 25902                                  delete_prompt_loop:			;AN000;
 25903                                  	;mov	si,offset trangroup:destdir+1
 25904 0000354C BE[688B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25905                                  	;mov	di,offset trangroup:dest
 25906 0000354F BF[378B]                	mov	di,DEST			;AN000; set up dest as target
 25907 00003552 A0[AA8A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25908 00003555 AA                      	stosb				;AN000;   of DEST
 25909                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25910 00003556 E8A2F0                  	call	FCB_TO_ASCZ
 25911                                  
 25912                                  slashp_askagn:				;AN000;
 25913 00003559 E873F0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25914                                  	;mov	dx,offset trangroup:bwdbuf
 25915 0000355C BA[AA8B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25916 0000355F 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25917 00003561 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25918                                  					;AN000; see if only D:\,0
 25919 00003565 7504                    	jnz	short not_del_root	;AN000; no continue
 25920 00003567 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25921                                  					;AN000; yes, get rid of \ ;
 25922                                  not_del_root:				;AN000;
 25923 0000356B 8916[118C]              	mov	[string_ptr_2],dx 	;AN000;
 25924                                  	;mov	dx,offset trangroup:string_buf_ptr
 25925 0000356F BA[C380]                	mov	dx,string_buf_ptr	;AN000;
 25926                                  	;invoke	std_printf		;AN000;
 25927 00003572 E85C18                  	call	std_printf
 25928                                  	;mov	dx,offset trangroup:dest
 25929 00003575 BA[378B]                	mov	dx,DEST			;AN000; print out file name string
 25930 00003578 8916[118C]              	mov	[string_ptr_2],dx 	;AN000;
 25931                                  	;mov	dx,offset trangroup:string_buf_ptr
 25932 0000357C BA[C380]                	mov	dx,string_buf_ptr	;AN000;
 25933                                  	;invoke	std_printf		;AN000;
 25934 0000357F E84F18                  	call	std_printf
 25935                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25936 00003582 BA[D87F]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25937                                  	;invoke	std_printf		;AN000;
 25938 00003585 E84918                  	call	std_printf
 25939                                  
 25940                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25941                                  ;;M029	mov	dx,si			;AN000;
 25942                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25943                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25944                                  ;;M029	int	21h			;AN000; get input from the user
 25945                                  ;;M029	lodsw				;AN000;
 25946                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25947                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25948                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25949                                  
 25950                                  ;	Get a single character input.
 25951                                  
 25952                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25953                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25954 00003588 B8010C                  	mov	ax,0C01h
 25955 0000358B CD21                    	int	21h			;M029
 25956                                  
 25957 0000358D E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25958                                  	;retc				;AN000; return if function not supported
 25959                                  	; 19/03/2023
 25960 00003590 7301                    	jnc	short slashp_check_yn
 25961                                  slashp_ans_no:
 25962 00003592 C3                      	retn
 25963                                  
 25964                                  slashp_check_yn:
 25965                                  	; 19/03/2023
 25966                                  	; AL = 0 if it was (country depended) NO character
 25967                                  	; AL = 1 if it was (country depenced) YES character
 25968                                  
 25969                                  	;cmp	al,capital_n		;AN000; was it no?
 25970                                  	;cmp	al,0
 25971 00003593 20C0                    	and	al,al ; 0
 25972 00003595 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25973                                  	;cmp	al,capital_y		;AN000; was it yes?
 25974                                  	;cmp	al,1
 25975 00003597 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25976                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25977                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25978                                  	; 19/03/2023
 25979 00003599 75BE                    	jnz	short slashp_askagn
 25980                                  
 25981                                  delete_this_file:			;AN000;
 25982 0000359B B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25983                                  	;mov	dx,offset trangroup:destdir
 25984 0000359D BA[678B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25985 000035A0 CD21                    	int	21h			;AN000;
 25986 000035A2 FEC0                    	inc	al			;AN000; did an error occur?
 25987 000035A4 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25988                                  ;
 25989                                  ;M041; Begin changes
 25990                                  ; We got an error deleting the file. If this is access denied, we can go on
 25991                                  ;to the next file after printing an error message.
 25992                                  ;
 25993                                  	;invoke	Get_ext_error_number	;see what error we got
 25994 000035A6 E847E7                  	call	get_ext_error_number
 25995 000035A9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25996                                  					;is it access denied?
 25997 000035AC 759C                    	jne	short stop_del		;no, some other error
 25998                                  	;invoke	CrLf2			;print a CR-LF
 25999 000035AE E81EF0                  	call	CRLF2
 26000                                  	;invoke set_ext_error_msg	;error message
 26001 000035B1 E82CE7                  	call	Set_Ext_Error_Msg
 26002                                  	;invoke	std_eprintf		;"Access denied"
 26003 000035B4 E81218                  	call	std_eprintf
 26004                                  	; 26/04/2023
 26005                                  	;jmp	short next_del_file	;try next file
 26006                                  	; 26/04/2023
 26007                                  ;stop_del:
 26008                                  ;;
 26009                                  ;;M041; End changes
 26010                                  ;;
 26011                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 26012                                  
 26013                                  next_del_file:				;AN000;
 26014                                  ;
 26015                                  ; M050 - begin
 26016                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 26017                                  ;       with /protect+ and /light+ makes it intercept all
 26018                                  ;       deletes. This hook does not save and restore the DTA correctly.
 26019                                  ;       They save the DWORD in a WORD by mistake! They save both the
 26020                                  ;       segment and the offset in the SAME variable (WORD)!!!
 26021                                  ;
 26022 000035B7 B41A                    	mov	ah,Set_DMA ; 1Ah
 26023                                  	;mov	dx,offset trangroup:destdir
 26024 000035B9 BA[678B]                	mov	dx,DESTDIR
 26025 000035BC CD21                    	int	21h
 26026                                  ;
 26027                                  ; M050 - end
 26028                                  
 26029 000035BE B412                    	mov	ah,Dir_Search_Next ; 12h
 26030                                  					;AN000; search for another file
 26031 000035C0 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26032 000035C3 CD21                    	int	21h			;AN000;
 26033 000035C5 FEC0                    	inc	al			;AN000; was a file found?
 26034                                  	;jz	short slash_p_exit	;AN000; no - exit
 26035                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26036                                  	; 26/04/2023
 26037 000035C7 7583                    	jnz	short delete_prompt_loop
 26038                                  
 26039                                  slash_p_exit:
 26040                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26041 000035C9 E824E7                  	call	get_ext_error_number
 26042 000035CC 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26043 000035CF 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26044 000035D1 E95FE4                  	jmp	extend_setup		;AN022; go issue error message
 26045                                  
 26046                                  good_erase_exit:
 26047                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26048 000035D4 E8B5EE                  	call	RestUDir
 26049                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26050                                  	;retn				;AN000; exit
 26051                                  	; 19/03/2023
 26052 000035D7 E9F5EF                  	jmp	CRLF2
 26053                                  
 26054                                  ; =============== S U B	R O U T	I N E =======================================
 26055                                  
 26056                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26057                                  
 26058                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26059                                  _ECHO:
 26060 000035DA E89900                  	call	ON_OFF
 26061 000035DD 7212                    	jb	short DOEMES
 26062 000035DF 8E1E[A58A]              	mov	ds,[RESSEG]
 26063 000035E3 7506                    	jnz	short ECH_OFF
 26064 000035E5 800E[8801]01            	or	byte [EchoFlag],1
 26065 000035EA C3                      	retn
 26066                                  
 26067                                  ECH_OFF:
 26068 000035EB 8026[8801]FE            	and	byte [EchoFlag],0FEh
 26069 000035F0 C3                      	retn
 26070                                  
 26071                                  	; 19/03/2023
 26072                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26073                                  ;CERRORJ:
 26074                                  	;jmp	cerror
 26075                                  
 26076                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26077                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26078                                  
 26079                                  DOEMES:
 26080                                  	; 19/03/2023
 26081                                  	; MSDOS 6.0
 26082                                  	;cmp	cl,0		;AC000; was anything on the line?
 26083 000035F1 20C9                    	and	cl,cl
 26084 000035F3 7409                    	jz	short PECHO	; just display current state.
 26085 000035F5 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26086 000035F8 E82DF0                  	call	CRPRINT
 26087 000035FB E9D1EF                  	jmp	CRLF2
 26088                                  
 26089                                  	; 19/03/2023
 26090                                  	; MSDOS 3.3
 26091                                  	;call	MOVE_TO_FIRST_ARG
 26092                                  	;jz	short PECHO
 26093                                  	;mov	dx,82h
 26094                                  	;call	CRPRINT
 26095                                  	;jmp	CRLF2
 26096                                  
 26097                                  PECHO:
 26098                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26099 000035FE 8E1E[A58A]              	mov	ds,[RESSEG]
 26100 00003602 8A1E[8801]              	mov	bl,[EchoFlag]
 26101 00003606 0E                      	push	cs
 26102 00003607 1F                      	pop	ds
 26103 00003608 80E301                  	and	bl,1
 26104 0000360B BA[7F80]                	mov	dx,EchoMes_Ptr
 26105 0000360E EB24                    	jmp	short PYN
 26106                                  
 26107                                  ; ---------------------------------------------------------------------------
 26108                                  
 26109                                  	; 19/03/2023
 26110                                  	; MSDOS 3.3
 26111                                  CERRORJ:
 26112 00003610 E93DF3                  	jmp	cerror
 26113                                  
 26114                                  ; =============== S U B	R O U T	I N E =======================================
 26115                                  
 26116                                  	; 19/03/2023
 26117                                  	; MSDOS 3.3
 26118                                  ;MOVE_TO_FIRST_ARG:
 26119                                  	;mov	si,81h
 26120                                  	;call	SCANOFF
 26121                                  	;cmp	al,0Dh
 26122                                  	;retn
 26123                                  
 26124                                  ; =============== S U B	R O U T	I N E =======================================
 26125                                  
 26126                                  CNTRLC:
 26127 00003613 E86000                  	call	ON_OFF
 26128 00003616 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26129 00003619 720C                    	jc	short PCNTRLC
 26130 0000361B 7505                    	jnz	short CNTRLC_OFF
 26131 0000361D B201                    	mov	dl,1
 26132 0000361F CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26133                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26134                                  			; DL = 00h for OFF or 01h for ON
 26135 00003621 C3                      	retn
 26136                                  
 26137                                  ; ---------------------------------------------------------------------------
 26138                                  
 26139                                  CNTRLC_OFF:
 26140 00003622 30D2                    	xor	dl,dl
 26141 00003624 CD21                    	int	21h		; Turn off ^C check
 26142 00003626 C3                      	retn
 26143                                  
 26144                                  ; ---------------------------------------------------------------------------
 26145                                  
 26146                                  PCNTRLC:
 26147                                  	; 19/03/2023
 26148                                  	; MSDOS 6.0
 26149                                  	;cmp	cl,0		;AC000; rest of line blank?
 26150 00003627 08C9                    	or	cl,cl
 26151 00003629 75E5                    	jnz	short CERRORJ 	; no, oops!
 26152                                  
 26153                                  	; 19/03/2023
 26154                                  	; MSDOS 3.3
 26155                                  	;call	MOVE_TO_FIRST_ARG
 26156                                  	;jnz	short CERRORJ
 26157                                  ;pccont:
 26158                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26159 0000362B 30C0                    	xor	al,al
 26160 0000362D CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26161 0000362F 88D3                    	mov	bl,dl
 26162 00003631 BA[6380]                	mov	dx,CtrlcMes_Ptr
 26163                                  
 26164                                  ; ---------------------------------------------------------------------------
 26165                                  
 26166                                  PYN:	; write "ON" or "OFF" state 
 26167                                  
 26168                                  	; 26/04/2023
 26169                                  	; 19/03/2023
 26170                                  	; MSDOS 3.3
 26171                                  	;call	STD_PRINTF
 26172                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26173                                  	;or	bl,bl
 26174                                  	;jnz	short PRINTVAL
 26175                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26176                                  	
 26177                                  	; 26/04/2023
 26178                                  	; 19/03/2023
 26179                                  	; MSDOS 6.0
 26180 00003634 BE[9080]                	mov	si,ONMES_PTR
 26181 00003637 08DB                    	or	bl,bl
 26182 00003639 7503                    	jnz	short PRINTVAL
 26183 0000363B BE[8D80]                	mov	si,OFFMES_PTR
 26184                                  PRINTVAL:
 26185                                  	; 19/03/2023
 26186                                  	; MSDOS 3.3
 26187                                  	;jmp	STD_PRINTF
 26188                                  
 26189                                  	; 19/03/2023
 26190                                  	; MSDOS 6.0
 26191 0000363E 52                      	push	dx		;AN000; save offset of message block
 26192 0000363F 89D3                    	mov	bx,dx		;AN000; save offset value
 26193 00003641 AD                      	lodsw			;AN000; get message number of on or off
 26194 00003642 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26195                                  				;AN000; this is a utility message
 26196 00003644 E86D18                  	call	TSYSGETMSG	;AN000; get the address of the message
 26197                                  	;add	bx,5
 26198 00003647 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26199                                  	
 26200 0000364A 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26201 0000364C 5A                      	pop	dx		;AN000; get message back
 26202 0000364D E88117                  	call	std_printf	;AC000; go print message
 26203 00003650 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26204 00003654 C3                      	retn			;AN000; exit
 26205                                  
 26206                                  ; =============== S U B	R O U T	I N E =======================================
 26207                                  
 26208                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26209                                  VERIFY:
 26210 00003655 E81E00                  	call	ON_OFF
 26211 00003658 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26212 0000365B 720A                    	jc	short PVERIFY
 26213 0000365D 7503                    	jnz	short VER_OFF
 26214 0000365F CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26215                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26216 00003661 C3                      	retn
 26217                                  
 26218                                  ; ---------------------------------------------------------------------------
 26219                                  
 26220                                  VER_OFF:
 26221 00003662 FEC8                    	dec	al
 26222 00003664 CD21                    	int	21h		; Turn off verify after write
 26223 00003666 C3                      	retn
 26224                                  
 26225                                  ; ---------------------------------------------------------------------------
 26226                                  
 26227                                  PVERIFY:
 26228                                  	; 19/03/2023
 26229                                  	; MSDOS 6.0
 26230                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26231 00003667 20C9                    	and	cl,cl
 26232 00003669 75A5                    	jnz	short CERRORJ 	; nope...
 26233                                  
 26234                                  	 ;19/03/2023
 26235                                  	; MSDOS 3.3
 26236                                  	;call	MOVE_TO_FIRST_ARG
 26237                                  	;jnz	short CERRORJ
 26238                                  
 26239 0000366B B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26240 0000366D CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26241                                  				; Return: AL = 00h if flag OFF
 26242                                  				; AL = 01h if flag ON
 26243 0000366F 88C3                    	mov	bl,al
 26244 00003671 BA[7180]                	mov	dx,VeriMes_Ptr
 26245 00003674 EBBE                    	jmp	short PYN
 26246                                  
 26247                                  ; =============== S U B	R O U T	I N E =======================================
 26248                                  
 26249                                  ; ****************************************************************
 26250                                  ; *
 26251                                  ; * ROUTINE:	 ON_OFF
 26252                                  ; *
 26253                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26254                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26255                                  ; *		 routines.
 26256                                  ; *
 26257                                  ; * INPUT:	 command line at offset 81H
 26258                                  ; *		 PARSE_BREAK control block
 26259                                  ; *
 26260                                  ; * OUTPUT:	 If carry is clear
 26261                                  ; *		    If ON is found
 26262                                  ; *		       Zero flag set
 26263                                  ; *		    If OFF is found
 26264                                  ; *		       Zero flag clear
 26265                                  ; *		 If carry set
 26266                                  ; *		    If nothing on command line
 26267                                  ; *		       CL set to zero
 26268                                  ; *		    If error
 26269                                  ; *		       CL contains error value from parse
 26270                                  ; *
 26271                                  ; ****************************************************************
 26272                                  
 26273                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26274                                  ON_OFF:
 26275 00003676 BE8100                  	mov	si,81h
 26276                                  
 26277                                  	; 19/03/2023
 26278                                  	; MSDOS 3.3
 26279                                  	;call	SCANOFF		; scan off leading blanks & equal
 26280                                  	;cmp	al,0Dh		; are we at end of line?
 26281                                  	;je	short BAD_ONF	; yes, return error
 26282                                  	;lodsw
 26283                                  	;or	ax,2020h	; convert to lowercase
 26284                                  	;cmp	ax,6E6Fh ;'on'
 26285                                  	;je	short ON_CHECK
 26286                                  	;cmp	ax,666Fh ;'of'
 26287                                  	;jne	short BAD_ONF
 26288                                  	;lodsb
 26289                                  	;or	al,20h		; convert to lowercase		
 26290                                  	;cmp	al,66h	 ; 'f'
 26291                                  	;jne	short BAD_ONF	
 26292                                  	;or	al,66h ; or al,'f'
 26293                                  	;jmp	short OFF_CHECK
 26294                                  ;ON_CHECK:
 26295                                  	;xor	al,al
 26296                                  ;OFF_CHECK:
 26297                                  	;lahf
 26298                                  	;mov	bx,ax
 26299                                  	;call	SCANOFF		; scan off leading blanks & equal
 26300                                  	;cmp	al,0Dh		; are we at end of line?	
 26301                                  	;jne	short BAD_ONF	; no, return error
 26302                                  	;mov	ax,bx
 26303                                  	;sahf
 26304                                  	;clc
 26305                                  	;retn
 26306                                  
 26307                                  	; 19/03/2023
 26308                                  	; MSDOS 6.0
 26309                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26310 00003679 AC                      	lodsb			;AN032; get a char
 26311                                  	;cmp	al,blank	;AN032; if whitespace
 26312 0000367A 3C20                    	cmp	al,20h
 26313 0000367C 74FB                    	je	short scan_on_off
 26314                                  				;AN032;    keep scanning
 26315 0000367E 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26316                                  	;cmp	al,09h
 26317 00003680 74F7                    	je	short scan_on_off
 26318                                  				;AN032;    keep scanning
 26319                                  	;cmp	al,equal_chr	;AN032; if equal char
 26320 00003682 3C3D                    	cmp	al,'=' ; 3Dh
 26321 00003684 7401                    	je	short parse_on_off
 26322                                  				;AN032;    start parsing
 26323 00003686 4E                      	dec	si		;AN032; if none of above - back up
 26324                                  
 26325                                  parse_on_off:			;AN032;    and start parsing
 26326 00003687 BF[6F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26327 0000368A 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26328 0000368C 31D2                    	xor	dx,dx		;AN000;
 26329 0000368E E88A0C                  	call	cmd_parse	;AC000; call parser
 26330                                  	;cmp	ax,-1 ; 0FFFFh
 26331 00003691 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26332 00003694 742E                    	je	short BADONF	;AC000; yes, return error
 26333                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26334                                  	;cmp	ax,0
 26335 00003696 21C0                    	and	ax,ax ; ax = 0 ?
 26336 00003698 7404                    	jz	short on_off_there
 26337                                  				;AN000; no - continue
 26338 0000369A 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26339 0000369C EB26                    	jmp	short BADONF	;AN000; return error
 26340                                  
 26341                                  on_off_there:
 26342 0000369E 803E[5095]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26343                                  				;AN014; was a valid positional present?
 26344 000036A3 7505                    	jnz	short good_on_off
 26345                                  				;AN014; yes - continue
 26346 000036A5 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26347                                  	;mov	cx,10 ; 0Ah
 26348 000036A8 EB1A                    	jmp	short BADONF	;AN014; return error
 26349                                  
 26350                                  good_on_off:				;AN014;
 26351 000036AA 31C0                    	xor	ax,ax		;AC000; set up return code for
 26352 000036AC 0A06[5095]              	or	al,[PARSE1_CODE]
 26353                                  				;AC000;    ON or OFF in AX
 26354 000036B0 9C                      	pushf			;AN000; save flags
 26355 000036B1 BF[6F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26356 000036B4 31D2                    	xor	dx,dx		;AN000;
 26357 000036B6 E8620C                  	call	cmd_parse	;AN000; call parser
 26358 000036B9 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26359                                  	;cmp	ax,-1 ; 0FFFFh
 26360 000036BC 7503                    	jne	short BADONF_flags
 26361                                  				;AN000; NO, return error
 26362 000036BE 9D                      	popf			;AN000; restore flags
 26363 000036BF F8                      	clc			;AC000; no error
 26364                                  	;jmp	short on_off_end
 26365                                  				;AN000; return to caller
 26366                                  	; 26/04/2023
 26367 000036C0 C3                      	retn
 26368                                  
 26369                                  BADONF_flags:
 26370 000036C1 89C1                    	mov	cx,ax
 26371 000036C3 9D                      	popf
 26372                                  
 26373                                  ; ---------------------------------------------------------------------------
 26374                                  
 26375                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26376                                  ; and return the error
 26377                                  
 26378                                  BADONF:
 26379 000036C4 BA[4080]                	mov	dx,bad_on_off_ptr
 26380 000036C7 F9                      	stc
 26381                                  on_off_end:
 26382 000036C8 C3                      	retn
 26383                                  
 26384                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26385                                  %if 0
 26386                                  
 26387                                  ;============================================================================
 26388                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 26389                                  ;============================================================================
 26390                                  ; 02/10/2018 - Retro DOS v3.0
 26391                                  
 26392                                  ; Print volume ID info
 26393                                  
 26394                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 26395                                  
 26396                                  ; ---------------------------------------------------------------------------
 26397                                  
 26398                                  PRINTVOL:
 26399                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 26400                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 26401                                  	add	al,'@'
 26402                                  	cmp	al,'@'
 26403                                  	jnz	short DRVOK
 26404                                  	mov	al,[CURDRV]
 26405                                  	add	al,[CAPITAL_A]
 26406                                  DRVOK:
 26407                                  	mov	[VOL_DRV],al	; get drive letter into argument
 26408                                  	pop	ax		; get return code back
 26409                                  	mov	dx,NOVOL ; "has	no label" 
 26410                                  	or	al,al		; volume label found?
 26411                                  	jnz	short PRINTVOL2	; print no volume message
 26412                                  GOODVOL:
 26413                                  	; MSDOS 3.3
 26414                                  	mov	di,CHARBUF
 26415                                  	mov	dx,di
 26416                                  	mov	si,IS	; "is "
 26417                                  	call	STRCPY
 26418                                  	dec	di
 26419                                  	mov	si,DIRBUF+8
 26420                                  	mov	cx,11
 26421                                  	rep	movsb
 26422                                  	xor	ax,ax
 26423                                  	;xor	al,al  ; MSDOS 6.0
 26424                                  	stosb			; store a zero to terminate the string
 26425                                  PRINTVOL2:
 26426                                  	mov	[VOLNAME_ADDR],dx
 26427                                  	mov	dx,VOLMESPTR
 26428                                  	jmp	PRINTF_CRLF
 26429                                  
 26430                                  	; MSDOS 6.0
 26431                                  ;drvok:
 26432                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 26433                                  ;	pop	ax		;AC000; get return code back
 26434                                  ;	or	al,al		;AC000; volume label found?
 26435                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 26436                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 26437                                  ;				;AC000; set up no volume message
 26438                                  ;	jmp	short print_serial ;AC000; go print it
 26439                                  ;
 26440                                  ;Get_vol_name:
 26441                                  ;	mov	di,offset trangroup:charbuf
 26442                                  ;	mov	dx,di
 26443                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 26444                                  ;	mov	cx,11				;AN000;  3/3/KK
 26445                                  ;	rep	movsb				;AN000;  3/3/KK
 26446                                  ;
 26447                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 26448                                  ;	stosb
 26449                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 26450                                  ;
 26451                                  ;PRINT_SERIAL:
 26452                                  ;
 26453                                  ;; Attempt to get the volume serial number from the disk.  If an error
 26454                                  ;; occurs, do not print volume serial number.
 26455                                  ;
 26456                                  ;	push	dx		;AN000; save message offset
 26457                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 26458                                  ;				;AC036; Get the volume serial info
 26459                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 26460                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 26461                                  ;	int	21h		;AN000; do the call
 26462                                  ;	pop	dx		;AN000; get message offset back
 26463                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26464                                  ;	call	std_printf	;AC000; go print volume message
 26465                                  ;	mov	al,blank	;AN051; Print out a blank
 26466                                  ;	invoke	print_char	;AN051;   before volume message
 26467                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26468                                  ;				;AN000; get serial number message
 26469                                  ;printvol_end:
 26470                                  ;	jmp	std_printf	;AC000; go print and exit
 26471                                  
 26472                                  %endif
 26473                                  
 26474                                  ;============================================================================
 26475                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26476                                  ;============================================================================
 26477                                  ; 02/10/2018 - Retro DOS v3.0
 26478                                  
 26479                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26480                                  
 26481                                  ; =============== S U B	R O U T	I N E =======================================
 26482                                  
 26483                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26484                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26485                                  	
 26486                                  PRINT_DATE:
 26487                                  	; 20/03/2023
 26488                                  	; MSDOS 3.3
 26489                                  	;push	es
 26490                                  	;push	di
 26491                                  	;push	cs
 26492                                  	;pop	es
 26493                                  	;mov	di,ARG_BUF
 26494                                  	;mov	ah,Get_Date ; 2Ah
 26495                                  	;int	21h	; DOS -	GET CURRENT DATE
 26496                                  	;		; Return: DL = day,DH = month,	CX = year
 26497                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26498                                  	;cbw
 26499                                  	;call	GETDATE
 26500                                  	;call	P_DATE
 26501                                  	;xor	al,al
 26502                                  	;stosb
 26503                                  	;mov	dx,ARG_BUF_PTR
 26504                                  	;call	STD_PRINTF
 26505                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26506                                  	;pop	es ; !!??!! 
 26507                                  	;pop	di
 26508                                  	;retn
 26509                                  
 26510                                  	; 20/03/2023
 26511                                  	; MSDOS 6.0
 26512 000036C9 06                      	push	es
 26513 000036CA 57                      	push	di
 26514 000036CB 0E                      	push	cs
 26515 000036CC 07                      	pop	es
 26516 000036CD E81300                  	call	GetDate 		; get date
 26517 000036D0 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26518 000036D2 890E[F780]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26519 000036D6 8916[F980]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26520 000036DA BA[E780]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26521 000036DD E8F116                  	call	std_printf
 26522                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26523                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26524 000036E0 5F                      	pop	di			;AC000; restore di,es
 26525 000036E1 07                      	pop	es			;AC000;
 26526 000036E2 C3                      	retn
 26527                                  
 26528                                  ; ---------------------------------------------------------------------------
 26529                                  
 26530                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26531                                  
 26532                                  ;GETDATE:
 26533                                  	; 21/03/2023
 26534                                  	; MSDOS 3.3
 26535                                  	;mov	si,ax
 26536                                  	;shl	si,1
 26537                                  	;add	si,ax
 26538                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26539                                  	;mov	bx,cx
 26540                                  	;mov	cx,3
 26541                                  	;rep	movsb
 26542                                  	;mov	al,' '
 26543                                  	;stosb
 26544                                  	;retn
 26545                                  
 26546                                  	; 21/03/2023
 26547                                  	; MSDOS 6.0
 26548                                  
 26549                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26550                                  ; for output. Date will be returned in CX,DX.
 26551                                  
 26552                                  GetDate:
 26553 000036E3 BF[F692]                	mov	di,Arg_Buf		;AC000; target for day of week
 26554 000036E6 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26555 000036E8 CD21                    	int	21h			;AC000; Get date in CX:DX
 26556 000036EA 98                      	cbw				;AC000;
 26557 000036EB 51                      	push	cx			;AN000; save date returned in
 26558 000036EC 52                      	push	dx			;AN000;  CX:DX
 26559 000036ED 89C6                    	mov	si,ax
 26560 000036EF D1E6                    	shl	si,1
 26561 000036F1 01C6                    	add	si,ax			; SI=AX*3
 26562 000036F3 89F1                    	mov	cx,si			;AN000; save si
 26563 000036F5 A1[B37F]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26564 000036F8 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26565 000036FA 57                      	push	di			;AN000; save argument buffer
 26566 000036FB E8B617                  	call	TSYSGETMSG		;AN000; get the address of the message
 26567 000036FE 5F                      	pop	di			;AN000; retrieve argument buffer
 26568 000036FF 01CE                    	add	si,cx			;AC000; get day of week
 26569 00003701 B90300                  	mov	cx,3
 26570 00003704 F3A4                      	rep	movsb
 26571 00003706 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26572 00003708 AA                      	stosb
 26573 00003709 5A                      	pop	dx			;AN000; get back date
 26574 0000370A 59                      	pop	cx			;AN000;
 26575 0000370B C3                      	retn
 26576                                  
 26577                                  ; =============== S U B	R O U T	I N E =======================================
 26578                                  
 26579                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26580                                  
 26581                                  	; MSDOS 6.0
 26582                                  
 26583                                  ; This routine determines whether the character in AL is a
 26584                                  ; Yes or No character. On return, if AL=0, the character is
 26585                                  ; No, if AL=1, the character is Yes.
 26586                                  
 26587                                  ;	assume	ds:trangroup
 26588                                  
 26589                                  char_in_xlat:	; proc	near
 26590                                  	; 21/03/2023
 26591 0000370C 88C2                    	mov	dl,al			;AC000; get character into DX
 26592 0000370E 30F6                    	xor	dh,dh			;AC000;
 26593                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26594 00003710 B82365                  	mov	ax,6523h
 26595 00003713 CD21                    	int	21h			;AC000;
 26596 00003715 C3                      	retn
 26597                                  
 26598                                  ;char_in_xlat	endp
 26599                                  
 26600                                  ;============================================================================
 26601                                  ; TENV.ASM, MSDOS 6.0, 1991
 26602                                  ;============================================================================
 26603                                  ; 02/10/2018 - Retro DOS v3.0
 26604                                  
 26605                                  ;	Environment utilities and misc. routines
 26606                                  
 26607                                  ; MSDOS 6.0
 26608                                  ; ****************************************************************
 26609                                  ; *
 26610                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26611                                  ; *
 26612                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26613                                  ; *		 the character in AL from the file upper case table
 26614                                  ; *		 in DOS if character if above  ascii 128, else
 26615                                  ; *		 subtracts 20H if between "a" and "z".
 26616                                  ; *
 26617                                  ; * INPUT:	 AL	      char to be upper cased
 26618                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26619                                  ; *
 26620                                  ; * OUTPUT:	 AL	      upper cased character
 26621                                  ; *
 26622                                  ; ****************************************************************
 26623                                  ;
 26624                                  ;assume	ds:trangroup				;AN000;
 26625                                  ;
 26626                                  ;upconv	proc	near				;AN000;
 26627                                  ;
 26628                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26629                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26630                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26631                                  ;	push	ds				;AN000;
 26632                                  ;	push	bx				;AN000;
 26633                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26634                                  ;assume	ds:resgroup				;AN000;
 26635                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26636                                  ;	add	bx,2				;AN000;  skip over first word
 26637                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26638                                  ;	pop	bx				;AN000;
 26639                                  ;	pop	ds				;AN000;
 26640                                  ;assume	ds:trangroup				;AN000;
 26641                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26642                                  ;
 26643                                  ;oth_fucase:					;AN000;
 26644                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26645                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26646                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26647                                  ;	ja	upconv_end			;AC000;
 26648                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26649                                  ;
 26650                                  ;upconv_end:					;AN000;
 26651                                  ;	ret
 26652                                  ;
 26653                                  ;upconv	endp					;AN000;
 26654                                  
 26655                                  
 26656                                  ; =============== S U B	R O U T	I N E =======================================
 26657                                  
 26658                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26659                                  
 26660                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26661                                  %if 0
 26662                                  
 26663                                  UPCONV:
 26664                                  	cmp	al,80h
 26665                                  	jb	short OTH_UCASE
 26666                                  	sub	al,80h
 26667                                  	push	ds
 26668                                  	push	bx
 26669                                  	mov	ds,[RESSEG]
 26670                                  	lds	bx,[UPPERCASETBL]
 26671                                  	add	bx,2
 26672                                  	xlat
 26673                                  	pop	bx
 26674                                  	pop	ds
 26675                                  	jmp	short UPCONV_RETN
 26676                                  
 26677                                  OTH_UCASE:
 26678                                  	cmp	al,'a'
 26679                                  	jb	short UPCONV_RETN
 26680                                  	cmp	al,'z'
 26681                                  	ja	short UPCONV_RETN
 26682                                  	sub	al,20h
 26683                                  
 26684                                  UPCONV_RETN:
 26685                                  	retn
 26686                                  
 26687                                  %endif
 26688                                  
 26689                                  ;============================================================================
 26690                                  ; COPY.ASM, MSDOS 6.0, 1991
 26691                                  ;============================================================================
 26692                                  ; 01/10/2018 - Retro DOS v3.0
 26693                                  
 26694                                  ;	title	COMMAND COPY routines.
 26695                                  
 26696                                  ;/*
 26697                                  ; *                      Microsoft Confidential
 26698                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26699                                  ; *                      All Rights Reserved.
 26700                                  ; */
 26701                                  
 26702                                  ;***	COPY.ASM
 26703                                  
 26704                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26705                                  
 26706                                  
 26707                                  ;***	MODIFICATION HISTORY
 26708                                  
 26709                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26710                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26711                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26712                                  ;	     to tokens which begin with path characters so that PARSELINE
 26713                                  ;	     will work correctly.
 26714                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26715                                  ;	     individual tokens. That distinction is no longer needed for
 26716                                  ;	     FOR loop processing.
 26717                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26718                                  ;	     1 when Cparse is called from COPY.
 26719                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26720                                  ;	     mod. It now is conditional on flag like previous mod.
 26721                                  ;11/21/83 NP  Added printf
 26722                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26723                                  ;	     be added to a token.
 26724                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26725                                  ;	     NOTE: DestHand is the destination handle. There are two
 26726                                  ;	     special values: -1 meaning destination was never opened and
 26727                                  ;	     0 which means that the destination has been openned and
 26728                                  ;	     closed.
 26729                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26730                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26731                                  ;	     lost on large and multiple file (wildcard) copies.
 26732                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26733                                  ;	     destination are not equal.
 26734                                  ;
 26735                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26736                                  ;	     first source file AND we run out of disk space before
 26737                                  ;	     completing the concatenation, restore the first source
 26738                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26739                                  ;
 26740                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26741                                  ;		instead of compatibility mode. This gives lesser sharing
 26742                                  ;		violations when files are opened for read on a copy.
 26743                                  
 26744                                  ; ---------------------------------------------------------------------------
 26745                                  ;***	COPY CODE
 26746                                  ; ---------------------------------------------------------------------------
 26747                                  
 26748                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26749                                  
 26750                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26751                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26752                                  
 26753                                  COPY:
 26754                                  	; 	Initialize internal variables.
 26755                                  
 26756 00003716 31C0                    	xor	ax,ax		; AX = 0
 26757 00003718 A3[138C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26758 0000371B A3[418D]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26759 0000371E A3[8D8C]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26760 00003721 A2[C28A]                	mov	[CFLAG],al	; 'destination file created' = false
 26761 00003724 A3[C68A]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26762 00003727 A3[BE8A]                	mov	[DestSwitch],ax	; destination switches = none
 26763 0000372A A3[578D]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26764 0000372D A3[2A8C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26765 00003730 A2[C38A]                	mov	[DestClosed],al	; 'destination file closed' = false
 26766 00003733 A2[298C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26767 00003736 A2[8C8C]                	mov	[SrcSiz],al	; length of source pathname = 0
 26768 00003739 A2[2C8C]                	mov	[DestInfo],al	; destination pathname flags = none
 26769 0000373C A2[8F8C]                	mov	[SrcInfo],al	; source pathname flags = none
 26770 0000373F A2[438D]                	mov	[INEXACT],al	; 'inexact copy' = false
 26771 00003742 A2[288C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26772 00003745 A2[8B8C]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26773 00003748 A2[8789]                	mov	[USERDIR1],al	; saved working directory = null
 26774 0000374B A2[448D]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26775 0000374E A2[B68A]                	mov	[RDEOF],al	; 'read end of file' = false
 26776 00003751 A3[E78C]                	mov	[SRCHAND],ax	; source handle = 0
 26777 00003754 A3[4C8D]                	mov	[CPDATE],ax	; copy date = 0
 26778 00003757 A3[4E8D]                	mov	[CPTIME],ax	; copy time = 0
 26779 0000375A A2[E98C]                	mov	[SRCISDEV],al	; 'source is device' = false
 26780                                  	; 23/03/2023
 26781                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26782 0000375D A2[548D]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26783 00003760 A3[508D]                	mov	[OFilePtr_Lo],ax
 26784 00003763 A3[528D]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26785 00003766 A2[488D]                	mov	[TERMREAD],al	; 'terminate read' = false
 26786 00003769 A2[068C]                	mov	[comma],al	; '"+,," found' = false
 26787 0000376C A2[078C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26788 0000376F A2[938D]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26789 00003772 A3[C08A]                	mov	[AllSwitch],ax	; all switches = none
 26790 00003775 A2[B98A]                	mov	[ArgC],al	; source/dest argument count = 0
 26791 00003778 A2[4A8D]                	mov	[PLUS],al	; '"+" in command line' = false
 26792 0000377B A2[458D]                	mov	[BINARY],al	; 'binary copy' = false
 26793 0000377E A2[498D]                	mov	[ASCII],al	; 'ascii copy' = false
 26794 00003781 A3[CD8A]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26795 00003784 A3[468D]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26796 00003787 A2[B88A]                	mov	[Concat],al	; 'concatenating' = false
 26797 0000378A A2[888C]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26798 0000378D A3[898C]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 26799                                  
 26800                                  	;	Initialize buffers with double-nulls.
 26801                                  
 26802 00003790 A3[EA8C]                	mov	[ScanBuf],ax
 26803 00003793 A3[2D8C]                	mov	[DestBuf],ax
 26804 00003796 A3[908C]                	mov	[SrcBuf],ax
 26805 00003799 A3[F08B]                	mov	[SDIRBUF],ax
 26806 0000379C A3[AA8B]                	mov	[DIRBUF],ax
 26807 0000379F A3[678B]                	mov	[DestFcb],ax
 26808                                  
 26809 000037A2 A2[4B8D]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26810                                  		
 26811 000037A5 48                      	dec	ax ; -1		; AX = 0FFFFh
 26812 000037A6 A3[848C]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26813 000037A9 A2[C88A]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26814 000037AC A2[878C]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26815 000037AF A2[288C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26816                                  		
 26817 000037B2 BE8100                  	mov	si,81h		; SI = ptr to command line
 26818                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26819                                  	; 23/03/2023
 26820 000037B5 B32B                    	mov	bl,'+'
 26821 000037B7 FE06[928D]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26822 000037BB C606[158C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26823                                  
 26824                                  	;*	Scan the command line for destination information.
 26825                                  
 26826                                  DESTSCAN:
 26827 000037C0 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26828 000037C2 BF[EA8C]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26829                                  	; 23/03/2023
 26830 000037C5 8936[098C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26831 000037C9 E88A09                  	call	cparse			; parse next object
 26832 000037CC 9C                      	pushf				; save CParse flags
 26833 000037CD FE06[4B8D]              	inc	byte [objcnt]		; count object
 26834 000037D1 F6C780                  	test	bh,80h
 26835 000037D4 7405                    	jz	short NOCOPY		; no "+" delimiter
 26836 000037D6 C606[4A8D]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26837                                  NOCOPY:
 26838 000037DB F6C701                  	test	bh,1
 26839 000037DE 742E                    	jz	short TESTP2		; not a switch
 26840                                  
 26841                                  	;	Found a switch.
 26842                                  
 26843                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26844                                  	; MSDOS 6.0
 26845 000037E0 F7C51000                	test	bp,10h
 26846                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26847 000037E4 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26848 000037E6 F606[C08A]10            	test	byte [AllSwitch],10h
 26849                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26850 000037EB 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26851                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26852                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26853 000037ED 81CD0040                	or	bp,4000h
 26854                                  NOT_SLASHV:
 26855 000037F1 092E[BE8A]              	or	[DestSwitch],bp		; assume destination
 26856 000037F5 092E[C08A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26857                                  
 26858                                  	; 23/03/2023
 26859                                  	; MSDOS 6.0
 26860                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26861 000037F9 F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26862 000037FD 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26863 000037FF 9D                      	popf				;AN018; fix up stack
 26864 00003800 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26865 00003803 E8C0E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26866 00003806 E947F1                  	jmp	cerror			;AC018; exit
 26867                                  NOT_BAD_SWITCH:
 26868 00003809 9D                      	popf				; restore CParse flags
 26869 0000380A 7231                    	jc	short CHECKDONE		; found CR
 26870 0000380C EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26871                                  TESTP2:
 26872 0000380E 9D                      	popf				; restore CParse flags
 26873 0000380F 722C                    	jc	short CHECKDONE		; found CR
 26874 00003811 F6C780                  	test	bh,80h
 26875 00003814 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26876 00003816 FE06[B98A]              	inc	byte [ArgC]		; count independent pathname args
 26877                                  GOTPLUS:
 26878 0000381A 56                      	push	si			; save cmd line ptr
 26879 0000381B A1[578D]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26880 0000381E BE[EA8C]                	mov	si,ScanBuf		; SI = ptr to path string
 26881 00003821 29F0                    	sub	ax,si			; AX = offset of last element
 26882 00003823 BF[2D8C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26883 00003826 01F8                    	add	ax,di			; AX = ptr to last element in
 26884                                  					;  destination path buffer
 26885 00003828 A3[2A8C]                	mov	[DestTail],ax		; save ptr to last element
 26886 0000382B 880E[298C]              	mov	[DestSiz],cl		; save path string length
 26887 0000382F 41                      	inc	cx			; CX = mov length (incl null)
 26888 00003830 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26889 00003832 883E[2C8C]              	mov	[DestInfo],bh		; save CParse info flags
 26890                                  	;mov	word [DestSwitch],0	; clear destination switches
 26891                                  	; 10/08/2024
 26892 00003836 890E[BE8A]              	mov	[DestSwitch],cx ; 0
 26893 0000383A 5E                      	pop	si			; SI = ptr into cmd line again
 26894 0000383B EB83                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26895                                  
 26896                                  CHECKDONE:
 26897                                  	;	We reached the CR. The destination scan is finished.
 26898                                  
 26899                                  	;	Disallow "copy file1+" as file overwriting itself.
 26900                                  	;
 26901                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26902                                  	;	equivalent to "copy file1+file2".)
 26903                                  
 26904                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26905                                  	;	through this check, since the switch would count
 26906                                  	;	as another object in ObjCnt.
 26907                                  
 26908 0000383D 803E[4A8D]01            	cmp	byte [PLUS],1		; "+" with
 26909 00003842 7514                    	jnz	short CDCONT
 26910 00003844 803E[B98A]01            	cmp	byte [ArgC],1		; one arg,
 26911 00003849 750D                    	jnz	short CDCONT
 26912 0000384B 803E[4B8D]02            	cmp	byte [objcnt],2		; two objects..
 26913 00003850 7506                    	jnz	short CDCONT
 26914 00003852 BA[257F]                	mov	dx,OVERWR_PTR
 26915 00003855 E91A06                  	jmp	COPYERR			; is file overwrite
 26916                                  
 26917                                  CDCONT:
 26918 00003858 A0[4A8D]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26919 0000385B A2[B88A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26920 0000385E D0E0                    	shl	al,1
 26921 00003860 D0E0                    	shl	al,1
 26922 00003862 A2[438D]                	mov	[INEXACT],al		; therefore making an inexact copy
 26923                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26924 00003865 A0[B98A]                	mov	al,[ArgC]		; AL = # independent arguments
 26925                                  
 26926                                  	; 23/03/2023
 26927                                  	; MSDOS 3.3		
 26928                                  	;or	al,al
 26929                                  	;jz	short CERROR4J
 26930                                  	; MSDOS 6.0
 26931 00003868 08C0                    	or	al,al
 26932 0000386A 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26933                                  		
 26934 0000386C BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26935 0000386F C706[FC7E]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26936                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26937 00003875 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26938                                  
 26939                                  	; more than 0 args; check if too many
 26940                                  TRY_TOO_MANY:
 26941 00003877 3C02                    	cmp	al,2
 26942 00003879 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26943                                  
 26944                                  	; 23/03/2023
 26945                                  	; MSDOS 6.0
 26946 0000387B BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26947 0000387E C706[FC7E]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26948                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26949                                  CERROR_PARSEJ:
 26950 00003884 C606[FA7E]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26951                                  					; parse error message	
 26952                                  CERROR4J:
 26953 00003889 E9C4F0                  	jmp	cerror
 26954                                  
 26955                                  ACOUNTOK:
 26956 0000388C BD[288C]                	mov	bp,DestVars		; BP = base of dest variables
 26957                                  
 26958 0000388F 3C01                    	cmp	al,1
 26959 00003891 7520                    	jnz	short GOT2ARGS
 26960                                  
 26961                                  	;	Only one independent pathname argument on command line.
 26962                                  	;	Set destination to d:*.*, where d: is current drive.
 26963                                  
 26964                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26965                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26966                                  
 26967 00003893 A0[B78A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26968                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26969                                  	; 23/03/2023
 26970 00003896 0441                    	add	al,'A'
 26971 00003898 B43A                    	mov	ah,':'			; AX = "d:"
 26972                                  	;mov	byte [bp+1],2
 26973 0000389A C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26974                                  
 26975 0000389E BF[2D8C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26976 000038A1 AB                      	stosw				; store "d:"
 26977                                  		
 26978 000038A2 C706[BE8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26979                                  	;mov	byte [bp+4],2		
 26980 000038A8 C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26981                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26982                                  	;mov	byte [bp+0],0		
 26983 000038AC C6460000                	mov	byte [bp],0
 26984 000038B0 E87408                  	call	SETSTARS		; add wildcards
 26985                                  GOT2ARGS:
 26986                                  	;	If destination pathname is "d:", add full wildcard filename
 26987                                  
 26988                                  	;cmp	byte [bp+1],2
 26989 000038B3 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26990 000038B7 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26991 000038B9 B03A                    	mov	al,':'  ; 3Ah
 26992 000038BB 3806[2E8C]              	cmp	byte [DestBuf+1],al
 26993 000038BF 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26994                                  	;or	byte [bp+4],2
 26995 000038C1 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26996 000038C5 BF[2F8C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26997                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26998                                  	;mov	byte [bp+0],0		
 26999 000038C8 C6460000                	mov	byte [bp],0
 27000 000038CC E85808                  	call	SETSTARS		; add wildcards
 27001                                  NOTSHORTDEST:
 27002                                  	;	If destination pathname ends with "\", try to make
 27003                                  	;	sure it's "d:\".
 27004                                  
 27005                                  	;mov	di,[bp+2]
 27006 000038CF 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 27007 000038D2 803D00                  	cmp	byte [di],0
 27008 000038D5 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 27009                                  
 27010 000038D7 BA[3780]                	mov	dx,badcd_ptr
 27011 000038DA B03A                    	mov	al,':'
 27012 000038DC 3845FE                  	cmp	[di-2],al
 27013 000038DF 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 27014                                  	;mov	byte [bp+0],2
 27015                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 27016 000038E1 C6460002                	mov	byte [bp],2
 27017                                  	;or	byte [bp+4],6
 27018 000038E5 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 27019                                  					  ;  path character
 27020 000038E9 E83B08                  	call	SETSTARS		; add wildcards
 27021                                  CHKSWTCHES:
 27022                                  	;	We have enough information about the destination for now.
 27023                                  
 27024                                  	;	Turn on verify if requested. Save the current verify flag.
 27025                                  
 27026                                  	; 23/03/2023
 27027                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 27028                                  	;mov	dx,BADPARMPTR
 27029                                  	
 27030 000038EC A1[C08A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 27031                                  
 27032                                  	; 23/03/2023
 27033                                  	; MSDOS 3.3
 27034                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27035                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27036                                  	;jnz	short CERROR4J
 27037                                  	
 27038                                  	; 23/03/2023
 27039                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27040                                  	;test	ax,SwitchV ; 10h
 27041                                  	; 18/04/2023
 27042                                  	;test	ax,10h
 27043 000038EF A810                    	test	al,10h  ; test al,SwitchV
 27044 000038F1 7414                    	jz	short NOVERIF		; no /v, no verify
 27045                                  
 27046 000038F3 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27047 000038F5 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27048                                  				; Return: AL = 00h if flag OFF
 27049                                  				; AL = 01h if flag ON
 27050 000038F7 1E                      	push	ds
 27051 000038F8 8E1E[A58A]              	mov	ds,[RESSEG]
 27052 000038FC 30E4                    	xor	ah,ah
 27053 000038FE A3[9001]                	mov	[VerVal],ax		; save current verify flag
 27054 00003901 1F                      	pop	ds
 27055 00003902 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27056 00003905 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27057                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27058                                  NOVERIF:
 27059                                  	;*	Scan for first source.
 27060                                  
 27061 00003907 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27062 00003909 BE8100                  	mov	si,81h			; SI = ptr into command line
 27063                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27064                                  	; 23/03/2023
 27065 0000390C B32B                    	mov	bl,'+' ; 2Bh
 27066                                  SCANFSRC:
 27067 0000390E BF[EA8C]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27068 00003911 E84208                  	call	cparse			; parse first source pathname
 27069 00003914 F6C701                  	test	bh,1			; switch?
 27070 00003917 75F5                    	jnz	short SCANFSRC		; yes, try again
 27071 00003919 092E[BE8A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27072                                  
 27073                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27074                                  
 27075                                  	; 23/03/2023
 27076 0000391D F7C50800                	test	bp,8
 27077                                  	;test	bp,SWITCHB
 27078 00003921 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27079 00003923 803E[B88A]00            	cmp	byte [Concat],0
 27080 00003928 7405                    	jz	short NOSETCASC		; we're not concatenating
 27081 0000392A C606[498D]04            	mov	byte [ASCII],4
 27082                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27083                                  NOSETCASC:
 27084 0000392F E8B503                  	call	SOURCE_SET		; set source variables
 27085 00003932 E84400                  	call	FRSTSRC			; set up first source copy
 27086 00003935 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27087                                  
 27088                                  ; ---------------------------------------------------------------------------
 27089                                  
 27090                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27091                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27092                                  ENDCOPY:
 27093                                  	;*	End of the road. Close destination, display # files
 27094                                  	;	copied (meaning # destinations), and go back to main
 27095                                  	;	transient COMMAND code.
 27096                                  
 27097 00003938 E8C102                  	call	CLOSEDEST
 27098                                  ENDCOPY2:
 27099 0000393B BA[2E7F]                	mov	dx,copied_ptr
 27100 0000393E 8B36[CD8A]              	mov	si,[FileCnt]
 27101 00003942 8936[138C]              	mov	[Copy_num],si
 27102 00003946 E88814                  	call	std_printf
 27103 00003949 E9B8C7                  	jmp	TCOMMAND		; stack could be messed up
 27104                                  
 27105                                  ; ---------------------------------------------------------------------------
 27106                                  
 27107                                  SRCNONEXIST:
 27108                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27109                                  	;	Otherwise, say 'file not found' and quit.
 27110                                  
 27111 0000394C 803E[B88A]00            	cmp	byte [Concat],0
 27112 00003951 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27113                                  
 27114                                  	; 24/03/2023
 27115                                  	; MSDOS 3.3
 27116                                  	;mov	dx,SRCBUF
 27117                                  	;mov	[STRING_PTR_1],dx
 27118                                  	;mov	dx,STRINGBUF1PTR
 27119                                  	;call	STD_PRINTF
 27120                                  	;mov	dx,FNOTFOUNDPTR
 27121                                  	;jmp	COPYERR
 27122                                  
 27123                                  	; 24/*03/2023
 27124                                  	; MSDOS 6.0
 27125                                  	;	Set up error message.
 27126 00003953 C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27127                                  				  	; extended error msg
 27128 00003958 BA[FC7E]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27129 0000395B C706[FC7E]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27130                                  					; 'file not found' msg#
 27131 00003961 C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf
 27132                                  					; point at bad pathname
 27133 00003967 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27134                                  					; 1 substitution
 27135 0000396C E90305                  	jmp	COPYERR			; print msg and clean up
 27136                                  
 27137                                  ; ---------------------------------------------------------------------------
 27138                                  
 27139                                  SOURCEPROC:
 27140                                  
 27141                                  	;*	Preparatory processing for each source file.
 27142                                  	;	Called at FrstSrc for first source file.
 27143                                  
 27144 0000396F E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 27145 00003972 803E[B88A]00            	cmp	byte [Concat],0
 27146 00003977 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27147                                  
 27148                                  ; ---------------------------------------------------------------------------
 27149                                  
 27150                                  FRSTSRC:
 27151 00003979 31C0                    	xor	ax,ax
 27152 0000397B A2[C28A]                	mov	[CFLAG],al		; 'destination not created'
 27153 0000397E A3[C68A]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27154 00003981 A2[C38A]                	mov	[DestClosed],al		; 'destination not closed'
 27155                                  
 27156                                  LEAVECFLAG:
 27157 00003984 8936[418D]              	mov	[SRCPT],si		; save cmd-line ptr
 27158 00003988 BF[8789]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27159                                  						;   current dir
 27160 0000398B BD[8B8C]                	mov	bp,SrcVars		; BP = base of source variables
 27161 0000398E E84606                  	call	BUILDPATH		; cd to source dir, figure
 27162                                  						;   out stuff about source
 27163 00003991 8B36[8D8C]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27164 00003995 C3                      	retn
 27165                                  
 27166                                  ; ---------------------------------------------------------------------------
 27167                                  
 27168                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27169                                  NEXTSRC:
 27170                                  	;*	Next source. Come here after handling each pathname.
 27171                                  	;	We're done unless there are additional source pathnames
 27172                                  	;	to be appended.
 27173                                  	;
 27174                                  	;	Note that all files matching an ambiguous pathname
 27175                                  	;	are processed before coming here.
 27176                                  
 27177 00003996 803E[4A8D]00            	cmp	byte [PLUS],0
 27178                                  	;jne	short MORECP		; copying "+" sources - keep going
 27179                                  	; 26/04/2023
 27180                                  ;ENDCOPYJ2:
 27181                                  	;jmp	short ENDCOPY
 27182 0000399B 749B                    	je	short ENDCOPY
 27183                                  MORECP:
 27184 0000399D 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27185 0000399F 8B36[418D]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27186                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27187 000039A3 B32B                    	mov	bl,'+' ; 2Bh
 27188                                  SCANSRC:
 27189 000039A5 BF[EA8C]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27190 000039A8 E8AB07                  	call	cparse			; parse first source name
 27191                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27192                                  	; 26/04/2023
 27193 000039AB 728B                    	jb	short ENDCOPY
 27194                                  
 27195 000039AD F6C780                  	test	bh,80h
 27196                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27197                                  	; 26/04/2023
 27198 000039B0 7486                    	jz	short ENDCOPY
 27199                                  
 27200 000039B2 F6C701                  	test	bh,1
 27201 000039B5 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27202                                  
 27203                                  	;	ScanBuf contains the next source pathname.
 27204                                  
 27205 000039B7 E8B5FF                  	call	SOURCEPROC		; prepare this source
 27206 000039BA 803E[068C]01            	cmp	byte [comma],1		; was +,, found last time?
 27207 000039BF 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27208 000039C1 C606[078C]01            	mov	byte [plus_comma],1	; yes - set flag
 27209 000039C6 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27210                                  
 27211                                  NOSTAMP:
 27212 000039C8 C606[078C]00            	mov	byte [plus_comma],0	; reset +,, flag
 27213                                  
 27214                                  ; ---------------------------------------------------------------------------
 27215                                  
 27216                                  FIRSTENT:
 27217                                  
 27218                                  ;M047
 27219                                  ; The only case we need to worry about is when the source is wildcarded and
 27220                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27221                                  ;concatenation. We check for this case.
 27222                                  ;
 27223                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27224                                  ;right place to do this check.
 27225                                  
 27226                                  	;	This is where we enter the loop with the first source.
 27227                                  
 27228 000039CD BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27229 000039D0 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27230 000039D3 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27231                                  				; DS:SI	-> string to parse
 27232                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27233                                  				; AL = bit mask	to control parsing
 27234 000039D5 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27235 000039D8 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27236 000039DA A1[908C]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27237 000039DD 80FC3A                  	cmp	ah,':'
 27238 000039E0 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27239 000039E2 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27240                                  DRVSPEC1:
 27241 000039E4 0C20                    	or	al,20h			; AL = lowercase drive letter
 27242 000039E6 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27243                                  	;mov	[5Ch],al
 27244 000039E8 A25C00                  	mov	[FCB],al		; put drive id in FCB
 27245                                  
 27246                                  	;	FCB contains drive and filename to search.
 27247                                  		
 27248 000039EB B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'
 27249 000039ED E8FC00                  	call	SEARCH
 27250                                  SRCHDONE:
 27251 000039F0 9C                      	pushf				; save flags from Search
 27252 000039F1 E88BEA                  	call	RestUDir1		; restore users current directory
 27253 000039F4 9D                      	popf				; restore flags from search
 27254 000039F5 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27255 000039F7 E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27256                                  
 27257                                  NEXTAMBIG0:
 27258 000039FA 30C0                    	xor	al,al
 27259 000039FC 8606[C88A]              	xchg	al,[FRSTSRCH]
 27260 00003A00 08C0                    	or	al,al
 27261 00003A02 740B                    	jz	short NEXTAMBIG
 27262                                  SETNMEL:
 27263 00003A04 B90C00                  	mov	cx,12
 27264 00003A07 BF[F08B]                	mov	di,SDIRBUF
 27265 00003A0A BE[AA8B]                	mov	si,DIRBUF
 27266 00003A0D F3A4                    	rep	movsb			; save very first source name
 27267                                  NEXTAMBIG:
 27268 00003A0F 30C0                    	xor	al,al
 27269 00003A11 A2[448D]                	mov	[NOWRITE],al		; turn off nowrite
 27270 00003A14 8B3E[8D8C]              	mov	di,[SrcTail]
 27271 00003A18 BE[AB8B]                	mov	si,DIRBUF+1
 27272 00003A1B E8DDEB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27273                                  MELDO:
 27274 00003A1E 803E[B88A]00            	cmp	byte [Concat],0
 27275 00003A23 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27276 00003A25 F606[8F8C]02            	test	byte [SrcInfo],2	; wildcard - show name
 27277 00003A2A 7409                    	jz	short DOREAD
 27278                                  SHOWCPNAM:
 27279                                  	; 25/03/2023
 27280                                  	; MSDOS 3.3
 27281                                  	;mov	dx,SRCBUF
 27282                                  	;mov	[STRING_PTR_2],dx
 27283                                  	;mov	dx,STRINGBUF2PTR
 27284                                  	;call	STD_PRINTF
 27285                                  	;call	CRLF2
 27286                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27287                                  	; MSDOS 6.0 (& MSDOS 5.0
 27288 00003A2C BA[A780]                	mov	dx,file_name_ptr
 27289 00003A2F E89F13                  	call	std_printf
 27290 00003A32 E89AEB                  	call	CRLF2
 27291                                  DOREAD:
 27292 00003A35 E8C500                  	call	DOCOPY
 27293 00003A38 803E[B88A]00            	cmp	byte [Concat],0
 27294 00003A3D 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27295                                  
 27296 00003A3F E8BA01                  	call	CLOSEDEST		; close current destination
 27297 00003A42 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27298                                  
 27299 00003A44 C606[C28A]00            	mov	byte [CFLAG],0		; 'destination not created'
 27300                                  NODCLOSE:
 27301 00003A49 803E[B88A]00            	cmp	byte [Concat],0
 27302 00003A4E 740A                    	jz	short NOFLUSH
 27303                                  
 27304                                  ;	Concatenating - flush output between source files so LostErr
 27305                                  ;	stuff works correctly.
 27306                                  
 27307                                  	;invoke	FlshFil  ; MSDOS 6.0
 27308                                  	; 25/03/2023
 27309 00003A50 E8E202                  	call	FlshFil
 27310                                  	;call	FLUSHFIL ; MSDOS 3.3
 27311                                  
 27312 00003A53 F606[888C]FF            	test	byte [MELCOPY],0FFh
 27313                                  	;jz	short NOFLUSH
 27314                                  	;jmp	short DOMELCOPY
 27315                                  	; 25/03/2023
 27316 00003A58 750C                    	jnz	short DOMELCOPY
 27317                                  NOFLUSH:
 27318 00003A5A E88300                  	call	SEARCHNEXT		; try next match
 27319 00003A5D 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 27320                                  					;   this source spec
 27321 00003A5F C606[C38A]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27322 00003A64 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 27323                                  
 27324                                  DOMELCOPY:
 27325 00003A66 803E[888C]FF            	cmp	byte [MELCOPY],0FFh
 27326 00003A6B 740D                    	je	short CONTMEL
 27327 00003A6D 8B36[418D]              	mov	si,[SRCPT]
 27328 00003A71 8936[898C]              	mov	[MELSTART],si
 27329 00003A75 C606[888C]FF            	mov	byte [MELCOPY],0FFh
 27330                                  
 27331                                  CONTMEL:
 27332 00003A7A 31ED                    	xor	bp,bp
 27333 00003A7C 8B36[418D]              	mov	si,[SRCPT]
 27334                                  	;mov	bl,[PLUS_CHR]
 27335                                  	; 25/03/2023
 27336 00003A80 B32B                    	mov	bl,'+'
 27337                                  SCANSRC2:
 27338 00003A82 BF[EA8C]                	mov	di,ScanBuf
 27339 00003A85 E8CE06                  	call	cparse
 27340 00003A88 F6C780                  	test	bh,80h
 27341 00003A8B 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 27342 00003A8D F6C701                  	test	bh,1
 27343 00003A90 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27344 00003A92 E8DAFE                  	call	SOURCEPROC
 27345 00003A95 E8E7E9                  	call	RestUDir1
 27346 00003A98 BF[2B8B]                	mov	di,DESTFCB2
 27347 00003A9B B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27348 00003A9E CD21                    	int	21h		; DOS -	PARSE FILENAME
 27349                                  				; DS:SI	-> string to parse
 27350                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27351                                  				; AL = bit mask	to control parsing
 27352 00003AA0 BB[F18B]                	mov	bx,SDIRBUF+1
 27353 00003AA3 BE[2C8B]                	mov	si,DESTFCB2+1
 27354 00003AA6 8B3E[8D8C]              	mov	di,[SrcTail]
 27355                                  
 27356 00003AAA E8FB04                  	call	BUILDNAME
 27357                                  
 27358 00003AAD 803E[B88A]00            	cmp	byte [Concat],0
 27359 00003AB2 7405                    	je	short MELDOJ		; not concatenating - continue
 27360                                  
 27361                                  	;	Yes, turn off nowrite because this part of the code 
 27362                                  	;	is only reached after the first file has been dealt with.
 27363                                  
 27364 00003AB4 C606[448D]00            	mov	byte [NOWRITE],0
 27365                                  MELDOJ:
 27366 00003AB9 E962FF                  	jmp	MELDO
 27367                                  NEXTSRCJ:
 27368 00003ABC E9D7FE                  	jmp	NEXTSRC
 27369                                  
 27370                                  NEXTMEL:
 27371 00003ABF E83A01                  	call	CLOSEDEST
 27372 00003AC2 31C0                    	xor	ax,ax
 27373 00003AC4 A2[C28A]                	mov	[CFLAG],al
 27374 00003AC7 A3[C68A]                	mov	[NXTADD],ax
 27375 00003ACA A2[C38A]                	mov	[SPECDRV],al
 27376 00003ACD 8B36[898C]              	mov	si,[MELSTART]
 27377 00003AD1 8936[418D]              	mov	[SRCPT],si
 27378 00003AD5 E80800                  	call	SEARCHNEXT
 27379 00003AD8 7403                    	jz	short SETNMELJ
 27380 00003ADA E95EFE                  	jmp	ENDCOPY2
 27381                                  SETNMELJ:
 27382 00003ADD E924FF                  	jmp	SETNMEL
 27383                                  
 27384                                  ; ---------------------------------------------------------------------------
 27385                                  
 27386                                  SEARCHNEXT:
 27387 00003AE0 B412                    	mov	ah,Dir_Search_Next ; 12h
 27388 00003AE2 F606[8F8C]02            	test	byte [SrcInfo],2
 27389 00003AE7 7503                    	jnz	short SEARCH		; do search-next if ambig
 27390 00003AE9 08E4                    	or	ah,ah			; reset zero flag
 27391 00003AEB C3                      	retn
 27392                                  
 27393                                  ; ---------------------------------------------------------------------------
 27394                                  
 27395                                  SEARCH:
 27396 00003AEC 50                      	push	ax
 27397 00003AED B41A                    	mov	ah,Set_DMA ; 1Ah
 27398 00003AEF BA[AA8B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27399 00003AF2 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27400                                  			; DS:DX	-> disk	transfer buffer
 27401 00003AF4 58                      	pop	ax		; restore search first/next command
 27402 00003AF5 BA5C00                  	mov	dx,FCB ; 5Ch
 27403 00003AF8 CD21                    	int	21h		; Do the search
 27404 00003AFA 08C0                    	or	al,al
 27405 00003AFC C3                      	retn
 27406                                  
 27407                                  ; ---------------------------------------------------------------------------
 27408                                  
 27409                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27410                                  DOCOPY:
 27411 00003AFD BE[908C]                	mov	si,SrcBuf	; do name translate of source
 27412 00003B00 BF[D387]                	mov	di,SRCXNAME	; save for name comparison
 27413 00003B03 B460                    	mov	ah,xNameTrans ; 60h
 27414 00003B05 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27415                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27416                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27417 00003B07 C606[B68A]00            	mov	byte [RDEOF],0	; no EOF yet
 27418                                  
 27419                                  	; MSDOS 6.0
 27420                                  	;mov	ax,ExtOpen shl 8	; open the file
 27421                                  	; 26/03/2023
 27422 00003B0C B8006C                  	mov	ax,6C00h
 27423                                  ;M046
 27424                                  ; For reads, the sharing mode should be deny none so that any process can
 27425                                  ;open this file again in any other sharing mode. This is mainly to allow
 27426                                  ;multiple command.com's to access the same file without getting sharing
 27427                                  ;violations
 27428                                  ;
 27429                                  	;mov	bx,deny_none|read_open_mode
 27430 00003B0F BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27431 00003B12 31C9                    	xor	cx,cx			; no special files
 27432                                  	;mov	dx,read_open_flag	; set up open flags
 27433 00003B14 BA0101                  	mov	dx,101h
 27434 00003B17 CD21                    	int	21h
 27435                                  	; 26/03/2023
 27436 00003B19 7230                    	jc	short Error_On_Source
 27437                                  	;jnc	short OPENOK
 27438                                  
 27439                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27440                                  	;	They asked for it...
 27441                                  
 27442                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27443                                  
 27444                                  	; 26/03/2023
 27445                                  	; MSDOS 3.3
 27446                                  	;mov	dx,SRCBUF
 27447                                  	;mov	ax,OPEN*256 ; 3D00h
 27448                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27449                                  	;			; DS:DX	-> ASCIZ filename
 27450                                  	;			; AL = access mode
 27451                                  	;			; 0 - read
 27452                                  	;jnc	short OPENOK
 27453                                  	;call	GET_EXT_ERR_NUMBER
 27454                                  	;pushf
 27455                                  	;cmp	ax,65
 27456                                  	;jnz	short DOCOPY_ERR
 27457                                  	;mov	dx,ACCDENPTR
 27458                                  	;call	STD_PRINTF
 27459                                  ;DOCOPY_ERR:
 27460                                  	;popf
 27461                                  	;retn
 27462                                  
 27463                                  	; 26/03/2023
 27464                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27465                                  OPENOK:
 27466 00003B1B 89C3                    	mov	bx,ax
 27467 00003B1D 891E[E78C]              	mov	[SRCHAND],bx		; save handle
 27468 00003B21 B80057                  	mov	ax,File_Times*256 ; 5700h
 27469 00003B24 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27470                                  				; BX = file handle
 27471                                  
 27472 00003B26 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 27473                                  
 27474 00003B28 8916[4C8D]              	mov	[CPDATE],dx		; save date
 27475 00003B2C 890E[4E8D]              	mov	[CPTIME],cx		; save time
 27476                                  
 27477                                  	; MSDOS 6.0
 27478                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27479                                  	; 26/04/2023
 27480                                  No_Copy_Xa:
 27481                                  	; 26/03/2023
 27482                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27483                                  
 27484                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27485 00003B30 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27486 00003B33 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27487                                  				; BX = file or device handle
 27488                                  	;and	dl,devid_ISDEV ; 80h
 27489                                  	; 18/04/2023
 27490 00003B35 80E280                  	and	dl,80h ; devid_ISDEV
 27491 00003B38 8816[E98C]              	mov	[SRCISDEV],dl		; set source info
 27492 00003B3C 7436                    	jz	short COPYLP		; source not a device
 27493 00003B3E 803E[458D]00            	cmp	byte [BINARY],0
 27494 00003B43 742F                    	je	short COPYLP		; ascii device ok
 27495 00003B45 BA[6080]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27496 00003B48 E92703                  	jmp	COPYERR
 27497                                  
 27498                                  Error_On_Source:			;AN022; we have a BAD error
 27499 00003B4B E892E1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27500 00003B4E C706[118C][908C]        	mov	word [string_ptr_2],SrcBuf
 27501                                  				;AN022; get address of failed string
 27502 00003B54 C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27503                                  				;AN022; put number of subst in control block
 27504 00003B59 E86D12                  	call	std_eprintf		;AN022; print it
 27505                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27506 00003B5C 8B1E[E78C]              	mov	bx,[SRCHAND]
 27507                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27508                                  	;je	short No_Close_Src	;AN022; no - don't close
 27509 00003B60 09DB                    	or	bx,bx
 27510 00003B62 7403                    	jz	short No_Close_Src
 27511                                  	;call	CLOSESRC		;AN022; clean up
 27512                                  	; 26/03/2023
 27513 00003B64 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27514                                  No_Close_Src:				;AN022;
 27515 00003B67 803E[C28A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27516 00003B6C 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27517 00003B6E E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27518                                  EndCopyJ3:				;AN022;
 27519 00003B71 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27520                                  
 27521                                  	; 26/04/2023
 27522                                  ;No_Copy_Xa:
 27523                                  ;	; 26/03/2023
 27524                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27525                                  ;
 27526                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27527                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27528                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27529                                  ;				; BX = file or device handle
 27530                                  ;	;and	dl,devid_ISDEV ; 80h
 27531                                  ;	; 18/04/2023
 27532                                  ;	and	dl,80h ; devid_ISDEV
 27533                                  ;	mov	[SRCISDEV],dl		; set source info
 27534                                  ;	jz	short COPYLP		; source not a device
 27535                                  ;	cmp	byte [BINARY],0
 27536                                  ;	je	short COPYLP		; ascii device ok
 27537                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27538                                  ;	jmp	COPYERR
 27539                                  
 27540                                  COPYLP:
 27541                                  	; 26/03/2023
 27542 00003B74 8B1E[E78C]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27543 00003B78 8B0E[C48A]              	mov	cx,[BYTCNT]
 27544 00003B7C 8B16[C68A]              	mov	dx,[NXTADD]
 27545 00003B80 29D1                    	sub	cx,dx			; compute available space
 27546 00003B82 750E                    	jnz	short GOTROOM
 27547 00003B84 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27548                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27549 00003B87 803E[488D]00            	cmp	byte [TERMREAD],0
 27550 00003B8C 7565                    	jne	short CLOSESRC		; give up
 27551 00003B8E 8B0E[C48A]              	mov	cx,[BYTCNT]
 27552                                  GOTROOM:
 27553 00003B92 1E                      	push	ds
 27554 00003B93 8E1E[A78A]              	mov	ds,[TPA]
 27555 00003B97 B43F                    	mov	ah,READ ; 3Fh
 27556 00003B99 CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27557                                  				; BX = file handle,CX = number of bytes to read
 27558                                  				; DS:DX	-> buffer
 27559 00003B9B 1F                      	pop	ds
 27560                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27561                                  	; 26/03/2023
 27562 00003B9C 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27563 00003B9E 89C1                    	mov	cx,ax			; get count
 27564 00003BA0 E351                    	jcxz	CLOSESRC		; no more to read
 27565 00003BA2 803E[E98C]00            	cmp	byte [SRCISDEV],0
 27566 00003BA7 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27567 00003BA9 803E[498D]00            	cmp	byte [ASCII],0
 27568 00003BAE 741B                    	je	short BINREAD
 27569                                  NOTESTA:
 27570 00003BB0 89CA                    	mov	dx,cx
 27571 00003BB2 8B3E[C68A]              	mov	di,[NXTADD]
 27572 00003BB6 B01A                    	mov	al,1Ah
 27573 00003BB8 06                      	push	es
 27574 00003BB9 8E06[A78A]              	mov	es,[TPA]		; scan for EOF
 27575 00003BBD F2AE                    	repne	scasb
 27576 00003BBF 07                      	pop	es
 27577 00003BC0 7505                    	jnz	short USEALL
 27578 00003BC2 FE06[B68A]              	inc	byte [RDEOF]
 27579 00003BC6 41                      	inc	cx
 27580                                  USEALL:
 27581 00003BC7 29CA                    	sub	dx,cx
 27582 00003BC9 89D1                    	mov	cx,dx
 27583                                  BINREAD:
 27584 00003BCB 030E[C68A]              	add	cx,[NXTADD]
 27585 00003BCF 890E[C68A]              	mov	[NXTADD],cx
 27586 00003BD3 3B0E[C48A]              	cmp	cx,[BYTCNT]		; is buffer full?
 27587 00003BD7 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27588                                  	; 26/03/2023
 27589 00003BD9 E85901                  	call	FlshFil
 27590                                  	;call	FLUSHFIL
 27591 00003BDC 803E[488D]00            	cmp	byte [TERMREAD],0
 27592 00003BE1 7510                    	jne	short CLOSESRC		; give up
 27593 00003BE3 EB8F                    	jmp	short COPYLP
 27594                                  TESTDEV:
 27595 00003BE5 803E[E98C]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27596 00003BEA 7407                    	je	short CLOSESRC
 27597 00003BEC 803E[B68A]00            	cmp	byte [RDEOF],0
 27598 00003BF1 7481                    	je	short COPYLP		; on device, go till ^Z
 27599                                  CLOSESRC:
 27600 00003BF3 8B1E[E78C]              	mov	bx,[SRCHAND]
 27601                                  CLOSESRC2:
 27602 00003BF7 B43E                    	mov	ah,CLOSE ; 3Eh
 27603 00003BF9 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27604                                  				; BX = file handle
 27605                                  CLOSESRCDEST_RETN:
 27606 00003BFB C3                      	retn
 27607                                  
 27608                                  ; ---------------------------------------------------------------------------
 27609                                  
 27610                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27611                                  CLOSEDEST:
 27612                                  
 27613                                  	;	We are called to close the destination.
 27614                                  	;	We need to note whether or not there is any internal data left
 27615                                  	;	to be flushed out.
 27616                                  
 27617 00003BFC 803E[C38A]00            	cmp	byte [DestClosed],0
 27618 00003C01 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27619 00003C03 A0[BE8A]                	mov	al,[DestSwitch]
 27620 00003C06 E8C502                  	call	SETASC			; check for b or a switch
 27621 00003C09 742E                    	jz	short BINCLOS		;   on destination
 27622 00003C0B 8B1E[C68A]              	mov	bx,[NXTADD]
 27623                                  ;
 27624                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27625                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27626                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27627                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27628                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27629                                  ;performance overhead on single ASCII file copies which now always involve
 27630                                  ;2 writes instead of 1 before. Is this really that important?
 27631                                  ;
 27632                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27633                                  ;M048;	jne	short PutZ
 27634                                  
 27635                                  	; 26/03/2023
 27636                                  	; MSDOS 3.3
 27637                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27638                                  	;jne	short PUTZ
 27639                                  
 27640                                  	; 26/03/2023
 27641 00003C0F E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27642 00003C12 7402                    	jz	short NOCONC
 27643                                  CONCHNG:
 27644 00003C14 F9                      	stc
 27645 00003C15 C3                      	retn
 27646                                  
 27647                                  NOCONC:	
 27648 00003C16 31DB                    	xor	bx,bx
 27649                                  PUTZ:
 27650 00003C18 1E                      	push	ds
 27651 00003C19 8E1E[A78A]              	mov	ds,[TPA]
 27652 00003C1D C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27653 00003C21 1F                      	pop	ds
 27654 00003C22 FF06[C68A]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27655 00003C26 C606[448D]00            	mov	byte [NOWRITE],0
 27656 00003C2B A1[468D]                	mov	ax,[WRITTEN]
 27657 00003C2E 0306[C68A]              	add	ax,[NXTADD]
 27658 00003C32 7205                    	jc	short BINCLOS	; > 1
 27659 00003C34 83F801                  	cmp	ax,1
 27660 00003C37 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27661                                  BINCLOS:
 27662 00003C39 E8EC00                  	call	TRYFLUSH
 27663 00003C3C 75D6                    	jnz	short CONCHNG
 27664                                  
 27665                                  	; 26/04/2023
 27666 00003C3E 833E[468D]00            	cmp	word [WRITTEN],0
 27667                                  	; 26/03/2023
 27668 00003C43 7503                    	jnz	short NO_FORGET
 27669                                  FORGETITJ:
 27670                                  	;jz	short FORGETIT	; never wrote nothing
 27671                                  	; 26/03/2023
 27672 00003C45 E98500                  	jmp	FORGETIT ; 18/04/2023
 27673                                  NO_FORGET:			; wrote something
 27674 00003C48 8B1E[848C]              	mov	bx,[DESTHAND]
 27675 00003C4C 8B0E[4E8D]              	mov	cx,[CPTIME]
 27676 00003C50 8B16[4C8D]              	mov	dx,[CPDATE]
 27677 00003C54 803E[438D]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27678 00003C59 7431                    	je	short DODCLOSE	; if no, copy date & time
 27679 00003C5B B42C                    	mov	ah,Get_Time ; 2Ch
 27680 00003C5D CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27681                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27682                                  				; DL = hundredths of seconds
 27683 00003C5F D0E1                    	shl	cl,1
 27684 00003C61 D0E1                    	shl	cl,1		; left justify min in cl
 27685 00003C63 D1E1                    	shl	cx,1
 27686 00003C65 D1E1                    	shl	cx,1
 27687 00003C67 D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27688 00003C69 D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27689 00003C6B 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27690 00003C6D 51                      	push	cx		; save packed time
 27691 00003C6E B42A                    	mov	ah,Get_Date ; 2Ah
 27692 00003C70 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27693                                  				; Return: DL = day,DH = month,	CX = year
 27694                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27695 00003C72 81E9BC07                	sub	cx,1980
 27696 00003C76 86E9                    	xchg	ch,cl
 27697 00003C78 D1E1                    	shl	cx,1		; year to high 7 bits
 27698 00003C7A D0E6                    	shl	dh,1		; month to high 3 bits
 27699 00003C7C D0E6                    	shl	dh,1
 27700 00003C7E D0E6                    	shl	dh,1
 27701 00003C80 D0E6                    	shl	dh,1
 27702 00003C82 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27703 00003C84 80D500                  	adc	ch,0		; put that bit next to year
 27704 00003C87 08F2                    	or	dl,dh		; or low three of month into day
 27705 00003C89 88EE                    	mov	dh,ch		; get year and high bit of month
 27706 00003C8B 59                      	pop	cx
 27707                                  DODCLOSE:
 27708 00003C8C 83FB00                  	cmp	bx,0
 27709 00003C8F 7E36                    	jle	short CLOSEDONE
 27710 00003C91 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27711 00003C94 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27712                                  				; BX = file handle,CX = time to be set
 27713                                  				; DX = date to be set
 27714                                  	; 26/03/2023
 27715                                  	; MSDOS 6.0
 27716 00003C96 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27717                                  
 27718                                  	;	See if the destination has *anything* in it.
 27719                                  	;	If not, just close and delete it.
 27720                                  
 27721 00003C98 B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27722 00003C9B 31D2                    	xor	dx,dx
 27723 00003C9D 89D1                    	mov	cx,dx
 27724 00003C9F CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27725                                  			; AL = method: offset from end of file
 27726                                  	;	DX:AX is file size
 27727                                  
 27728 00003CA1 09C2                    	or	dx,ax
 27729 00003CA3 9C                      	pushf
 27730 00003CA4 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27731 00003CA7 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27732                                  			; BX = file or device handle
 27733 00003CA9 52                      	push	dx		; save them away
 27734 00003CAA B43E                    	mov	ah,CLOSE ; 3Eh
 27735 00003CAC CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27736                                  			; BX = file handle
 27737 00003CAE 5A                      	pop	dx
 27738                                  
 27739                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27740                                  	; MSDOS 6.0
 27741 00003CAF 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27742 00003CB1 9D                      	popf			;AN022; get the flags back
 27743                                  Cleanup_Err: 			;AN022;
 27744 00003CB2 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27745                                  	; 26/03/2023
 27746                                  	;call	DestDelete	;AN022; attempt to delete the target
 27747                                  	;jmp	short FILECLOSED
 27748                                  	;			;AN022; close the file
 27749                                  	; 26/03/2023
 27750                                  DestDel_fclosed:
 27751 00003CB5 E82700                  	call	DestDelete
 27752                                  FILECLOSED:
 27753 00003CB8 FE06[C38A]              	inc	byte [DestClosed]
 27754                                  RET50:
 27755 00003CBC F8                      	clc
 27756 00003CBD C3                      	retn
 27757                                  	
 27758                                  Close_Cont:			;AN022; no error - co
 27759                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27760 00003CBE 9D                      	popf
 27761 00003CBF 7506                    	jnz	short CLOSEDONE
 27762 00003CC1 F7C28000                	test	dx,80h		; is the destination a device?
 27763                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27764                                  	;call	DestDelete
 27765                                  	;jmp	short FILECLOSED
 27766                                  	; 26/03/2023
 27767 00003CC5 74EE                    	jz	short DestDel_fclosed
 27768                                  CLOSEDONE:
 27769 00003CC7 FF06[CD8A]              	inc	word [FileCnt]
 27770                                  	; 26/03/2023
 27771 00003CCB EBEB                    	jmp	short FILECLOSED
 27772                                  	
 27773                                  ;FILECLOSED:
 27774                                  ;	inc	byte [DestClosed]
 27775                                  ;RET50:
 27776                                  	;clc
 27777                                  	;retn
 27778                                  
 27779                                  FORGETIT:
 27780 00003CCD 8B1E[848C]              	mov	bx,[DESTHAND]
 27781 00003CD1 E8B8FF                  	call	DODCLOSE	 ; close the dest
 27782 00003CD4 E80800                  	call	DestDelete
 27783 00003CD7 C706[CD8A]0000          	mov	word [FileCnt],0 ; no files transferred
 27784 00003CDD EBDD                    	jmp	short RET50
 27785                                  
 27786                                  ; ---------------------------------------------------------------------------
 27787                                  
 27788                                  	; 26/03/2023
 27789                                  DestDelete:
 27790 00003CDF BA[2D8C]                	mov	dx,DestBuf
 27791 00003CE2 B441                    	mov	ah,Unlink ; 41h
 27792 00003CE4 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27793                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27794                                  			;		(no wildcards allowed)
 27795 00003CE6 C3                      	retn
 27796                                  
 27797                                  ; ---------------------------------------------------------------------------
 27798                                  
 27799                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27800                                  SOURCE_SET:
 27801 00003CE7 56                      	push	si
 27802 00003CE8 A1[578D]                	mov	ax,[STARTEL]
 27803 00003CEB BE[EA8C]                	mov	si,ScanBuf	; adjust to copy
 27804 00003CEE 29F0                    	sub	ax,si
 27805 00003CF0 BF[908C]                	mov	di,SrcBuf
 27806 00003CF3 01F8                    	add	ax,di
 27807 00003CF5 A3[8D8C]                	mov	[SrcTail],ax
 27808 00003CF8 880E[8C8C]              	mov	[SrcSiz],cl	; save its size
 27809 00003CFC 41                      	inc	cx		; include the nul
 27810 00003CFD F3A4                    	rep	movsb		; save this source
 27811 00003CFF 883E[8F8C]              	mov	[SrcInfo],bh	; save info about it
 27812 00003D03 5E                      	pop	si
 27813 00003D04 89E8                    	mov	ax,bp		; switches so far
 27814 00003D06 E8C501                  	call	SETASC		; set a,b switches accordingly
 27815 00003D09 E86EEA                  	call	SWITCH		; get any more switches on this arg
 27816                                  	;call	SETASC		; set
 27817                                  	;retn
 27818                                  	; 26/03/2023
 27819 00003D0C E9BF01                  	jmp	SETASC
 27820                                  
 27821                                  ; =============== S U B	R O U T	I N E =======================================
 27822                                  
 27823                                  ; MSDOS 6.0
 27824                                  
 27825                                  ;****************************************************************
 27826                                  ;*
 27827                                  ;* ROUTINE:	CleanupErr
 27828                                  ;*
 27829                                  ;* FUNCTION:	Issues extended error message for destination
 27830                                  ;*		if not alreay issued
 27831                                  ;*
 27832                                  ;* INPUT:	return from INT 21
 27833                                  ;*
 27834                                  ;* OUTPUT:	none
 27835                                  ;*
 27836                                  ;****************************************************************
 27837                                  
 27838                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27839                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27840                                  CleanUpErr:	; proc	near		;AN022;
 27841                                  
 27842 00003D0F 803E[938D]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27843 00003D14 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27844 00003D16 E8C7DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27845 00003D19 C706[118C][2D8C]        	mov	word [string_ptr_2],DestBuf 
 27846                                  					;AN022; get address of failed string
 27847 00003D1F C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27848                                  					;AN022; put number of subst in control block
 27849 00003D24 E8A210                  	call	std_eprintf		;AN022; issue the error message
 27850                                  CleanupErr_Cont:			;AN022;
 27851 00003D27 C3                      	retn				;AN022; return to caller
 27852                                  
 27853                                  ;CleanUpErr	endp			;AN022;
 27854                                  
 27855                                  ;============================================================================
 27856                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27857                                  ;============================================================================
 27858                                  ; 01/10/2018 - Retro DOS v3.0
 27859                                  
 27860                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27861                                  
 27862                                  ; =============== S U B	R O U T	I N E =======================================
 27863                                  
 27864                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27865                                  ;
 27866                                  ;	EXIT	ZR set if concatenate flag unchanged
 27867                                  
 27868                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27869                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27870                                  TRYFLUSH:
 27871 00003D28 A0[B88A]                	mov	al,[Concat]
 27872 00003D2B 50                      	push	ax
 27873                                  	;call	FLUSHFIL
 27874 00003D2C E80600                  	call	FlshFil
 27875 00003D2F 58                      	pop	ax
 27876 00003D30 3A06[B88A]              	cmp	al,[Concat]
 27877 00003D34 C3                      	retn
 27878                                  
 27879                                  ; =============== S U B	R O U T	I N E =======================================
 27880                                  
 27881                                  	; 26/03/2023
 27882                                  	; MSDOS 3.3
 27883                                  ;FLUSHFIL:
 27884                                  	;mov	al,[BINARY]
 27885                                  	;mov	ah,[ASCII]
 27886                                  	;push	ax
 27887                                  	;call	FLSHFIL
 27888                                  	;pop	ax
 27889                                  	;mov	[ASCII],ah
 27890                                  	;mov	[BINARY],al
 27891                                  	;retn
 27892                                  
 27893                                  ; =============== S U B	R O U T	I N E =======================================
 27894                                  
 27895                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27896                                  ;
 27897                                  ;	Inputs:
 27898                                  ;	  [NXTADD] = No. of bytes to write
 27899                                  ;	  [CFLAG] <> 0 if file has been created
 27900                                  ;	Outputs:
 27901                                  ;	  [NXTADD] = 0
 27902                                  
 27903                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27904                                  FlshFil:
 27905 00003D35 C606[488D]00            	mov	byte [TERMREAD],0
 27906 00003D3A 803E[C28A]00            	cmp	byte [CFLAG],0
 27907 00003D3F 7403                    	jz	short NotExists
 27908 00003D41 E99600                  	jmp	Exists
 27909                                  NotExists:
 27910 00003D44 E8A101                  	call	BUILDDEST		; find out all about the destination
 27911 00003D47 E8F903                  	call	COMPNAME		; source and dest. the same?
 27912 00003D4A 7519                    	jnz	short ProcDest		; if not, go ahead
 27913 00003D4C 803E[E98C]00            	cmp	byte [SRCISDEV],0
 27914 00003D51 7512                    	jnz	short ProcDest		; same name on device ok
 27915 00003D53 803E[B88A]00            	cmp	byte [Concat],0		; concatenation?
 27916 00003D58 BA[257F]                	mov	dx,OVERWR_PTR
 27917                                  	;je	short COPERR		; not concatenating - overwrite error
 27918                                  	; 26/03/2023
 27919 00003D5B 7503                    	jne	short No_Concat_Err
 27920 00003D5D E91201                  	jmp	COPYERR
 27921                                  	
 27922                                  No_Concat_Err:	; concatenating
 27923 00003D60 C606[448D]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27924                                  ProcDest:
 27925                                  	; MSDOS 6.0
 27926                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27927                                  	; 26/03/2023
 27928 00003D65 B8006C                  	mov	ax,6C00h
 27929 00003D68 BE[2D8C]                	mov	si,DestBuf		; get file name
 27930                                  ;M046
 27931                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27932                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27933                                  ;writing to the same file. Also, because we opened the source file with
 27934                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27935                                  ;would happen when we append to an existing file.
 27936                                  
 27937                                  	; 26/03/2023
 27938                                  	;mov	bx,deny_write|write_open_mode
 27939 00003D6B BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27940 00003D6E 31C9                    	xor	cx,cx			; no special files
 27941                                  	;mov	dx,write_open_flag	; set up open flags
 27942 00003D70 BA0101                  	mov	dx,101h	
 27943                                  
 27944 00003D73 803E[448D]00            	cmp	byte [NOWRITE],0
 27945 00003D78 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27946                                  	;mov	dx,creat_open_flag	; set up create flags
 27947 00003D7A BA1201                  	mov	dx,112h
 27948                                  
 27949                                  	; 26/03/2023
 27950                                  	; MSDOS 3.3
 27951                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27952                                  	;cmp	byte [NOWRITE],0
 27953                                  	;jne	short DODESTOPEN
 27954                                  	;mov	ah,CREAT ; 3Ch
 27955                                  	;xor	cx,cx
 27956                                  ;DODESTOPEN:
 27957                                  	;mov	dx,DESTBUF
 27958                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27959                                  	;		; CX = attributes for file
 27960                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27961                                  
 27962                                  ; 26/03/2023
 27963                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27964                                  ;	;mov	dx,FULDIRPTR
 27965                                  ;	;call	GET_EXT_ERR_NUMBER
 27966                                  ;	;jc	short COPERR
 27967                                  ;
 27968                                  ;	; 01/10/2018
 27969                                  ;	;jnc	short DEST_OPEN_OKAY
 27970                                  ;		
 27971                                  ;	;mov	dx,FULDIRPTR
 27972                                  ;	;call	GET_EXT_ERR_NUMBER
 27973                                  ;	;jmp	short COPERR
 27974                                  ;
 27975                                  ;	jc	short DEST_OPEN_ERROR
 27976                                  
 27977                                  	; 26/03/2023
 27978                                  DoDestOpen:
 27979 00003D7D CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27980                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27981                                  			; BH = flags
 27982                                  			; CX = create attribute
 27983                                  			; DL = action if file exists/does not exists
 27984                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27985                                  
 27986                                  ;	We assume that the error is normal.
 27987                                  ;	TriageError will correct the DX value appropriately.
 27988                                  	
 27989 00003D7F 7311                    	jnc	short Dest_Open_Okay
 27990                                  Xa_Set_Error:				;AN030; error occurred on XA
 27991 00003D81 E85CDF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27992                                  
 27993                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27994                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27995                                  Ext_Err_Set:				;AN030;
 27996 00003D84 C706[118C][2D8C]        	mov	word [string_ptr_2],DestBuf
 27997                                  					;AN000; get address of failed string
 27998 00003D8A C606[FE7E]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27999                                  					;AN030; put number of subst in control block
 28000                                  CopErrJ2:				;AN030;
 28001 00003D8F E9E000                  	jmp	COPYERR			;AN030; go issue message
 28002                                  
 28003                                  ;DEST_OPEN_OKAY:
 28004                                  	; 26/03/2023
 28005                                  Dest_Open_Okay:
 28006 00003D92 A3[848C]                	mov	[DESTHAND],ax		; save handle
 28007 00003D95 C606[C28A]01            	mov	byte [CFLAG],1		; destination now exists
 28008 00003D9A 89C3                    	mov	bx,ax
 28009 00003D9C B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 28010 00003D9F CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 28011                                  			   	; BX = file or device handle
 28012                                  
 28013 00003DA1 8816[868C]              	mov	[DESTISDEV],dl		; set dest info
 28014                                  	; 18/04/2023
 28015 00003DA5 F6C280                  	test	dl,80h
 28016                                  	;test	dl,devid_ISDEV
 28017 00003DA8 7430                    	jz	short Exists		; Dest not a device
 28018                                  
 28019                                  ;	Destination is device.
 28020                                  
 28021 00003DAA A0[BE8A]                	mov	al,[DestSwitch]
 28022                                  	; 26/03/2023
 28023 00003DAD 240C                    	and	al,0Ch
 28024                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 28025 00003DAF 7509                    	jnz	short TestBoth
 28026 00003DB1 A0[498D]                	mov	al,[ASCII]		; neither set, use current setting
 28027 00003DB4 0A06[458D]              	or	al,[BINARY]
 28028 00003DB8 7416                    	jz	short ExSetA		; neither set, default to ascii
 28029                                  TestBoth:
 28030 00003DBA 7A1E                    	jpe	short Exists		; both are set, ignore
 28031 00003DBC A808                    	test	al,8
 28032                                  	;test	al,SWITCHB
 28033 00003DBE 741A                    	jz	short Exists
 28034                                  	;mov	ax,(IOCTL shl 8) or 1
 28035 00003DC0 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28036 00003DC3 30F6                    	xor	dh,dh
 28037                                  	; 18/04/2023
 28038 00003DC5 80CA20                  	or	dl,20h
 28039                                  	;or	dl,devid_RAW
 28040 00003DC8 8816[868C]              	mov	[DESTISDEV],dl
 28041 00003DCC CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28042                                  			; BX = device handle,DH = 0
 28043                                  			; DL = device information to set (bits 0-7 from	function 0)
 28044 00003DCE EB0A                    	jmp	short Exists
 28045                                  
 28046                                  	; 26/03/2023
 28047                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28048                                  ;DEST_OPEN_ERROR:
 28049                                  	;mov	dx,FULDIRPTR
 28050                                  	;call	GET_EXT_ERR_NUMBER
 28051                                  ;COPERR:
 28052                                  	; 26/03/2023
 28053                                  ;CopyErrj:
 28054                                  	;jmp	short COPYERR
 28055                                  
 28056                                  ExSetA:
 28057                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28058                                  
 28059 00003DD0 C606[498D]04            	mov	byte [ASCII],4
 28060                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28061 00003DD5 800E[438D]04            	or	byte [INEXACT],4
 28062                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28063                                  Exists:
 28064 00003DDA 803E[448D]00            	cmp	byte [NOWRITE],0
 28065 00003DDF 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28066 00003DE1 803E[078C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28067 00003DE6 741D                    	jz	short NoChecking
 28068 00003DE8 E85803                  	call	COMPNAME		; source and dest. the same?
 28069 00003DEB 7518                    	jnz	short NoChecking	; if not, go ahead
 28070 00003DED 803E[E98C]00            	cmp	byte [SRCISDEV],0
 28071 00003DF2 7511                    	jne	short NoChecking	; same name on device ok
 28072                                  
 28073                                  ;	At this point we know in append (would have gotten overwrite error
 28074                                  ;	on first destination create otherwise), and user trying to specify
 28075                                  ;	destination which has been scribbled already (if dest had been named
 28076                                  ;	first, NoWrite would be set).
 28077                                  
 28078 00003DF4 BA[287F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28079                                  	;invoke	Std_EprintF		;ac022;
 28080                                  	; 26/03/2023
 28081 00003DF7 E8CF0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28082                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28083 00003DFA C706[C68A]0000          	mov	word [NXTADD],0		; set return
 28084 00003E00 FE06[488D]              	inc	byte [TERMREAD]		; tell read to give up
 28085                                  Ret60:
 28086 00003E04 C3                      	retn
 28087                                  
 28088                                  NoChecking:
 28089 00003E05 8B1E[848C]              	mov	bx,[DESTHAND]		; get handle
 28090 00003E09 31C9                    	xor	cx,cx
 28091 00003E0B 870E[C68A]              	xchg	cx,[NXTADD]
 28092 00003E0F E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28093 00003E11 FF06[468D]              	inc	word [WRITTEN]		; flag that we wrote something
 28094 00003E15 803E[448D]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28095 00003E1A 7514                    	jnz	short SeekEnd
 28096 00003E1C 31D2                    	xor	dx,dx
 28097 00003E1E 1E                      	push	ds
 28098 00003E1F 8E1E[A78A]              	mov	ds,[TPA]
 28099 00003E23 B440                    	mov	ah,Write ; 40h
 28100 00003E25 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28101                                  			; BX = file handle,CX = number of bytes to write,DS:DX -> buffer
 28102 00003E27 1F                      	pop	ds
 28103 00003E28 BA[107F]                	mov	dx,NOSPACE_PTR
 28104                                  	;jc	short COPERRP		; failure
 28105                                  	; 26/03/2023
 28106                                  	; MSDOS 6.0
 28107 00003E2B 7326                    	jnc	short NoChecking2
 28108 00003E2D E951FF                  	jmp	Xa_Set_Error
 28109                                  
 28110                                  	; 18/04/2023
 28111                                  	; 26/03/2023
 28112                                  SeekEnd:
 28113 00003E30 31D2                    	xor	dx,dx
 28114 00003E32 87D1                    	xchg	dx,cx
 28115                                  	;mov	ax,(LSEEK shl 8) or 1
 28116 00003E34 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28117 00003E37 CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28118                                  				; AL = method: offset from present location
 28119                                  
 28120                                  	; 26/03/2023
 28121                                  	; MSDOS 6.0
 28122                                  
 28123                                  ;	Save the file pointer in DX:AX to restore the file
 28124                                  ;	with in case the copy should fail.
 28125                                  
 28126 00003E39 A3[508D]                	mov	[OFilePtr_Lo],ax
 28127 00003E3C 8916[528D]              	mov	[OFilePtr_Hi],dx
 28128                                  
 28129                                  	; 26/03/2023
 28130                                  	; MSDOS 3.3  MSDOS 6.0
 28131                                  
 28132 00003E40 803E[B68A]00            	cmp	byte [RDEOF],0
 28133 00003E45 740B                    	jz	short Retz60
 28134                                  
 28135                                  ;	^Z has been read - we must set the file size to the current
 28136                                  ;	file pointer location
 28137                                  
 28138 00003E47 B440                    	mov	ah,Write ; 40h
 28139 00003E49 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28140                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28141                                  
 28142                                  	; 26/03/2023
 28143                                  	; MSDOS 6.0
 28144 00003E4B 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28145                                  
 28146                                  ;	Make note that ^Z was removed, in case the
 28147                                  ;	copy should fail and we need to restore the file.
 28148                                  
 28149 00003E4D C606[548D]1A            	mov	byte [OCtrlZ],1Ah
 28150                                  Retz60:
 28151 00003E52 C3                      	retn
 28152                                  
 28153                                  NoChecking2:
 28154 00003E53 29C1                    	sub	cx,ax
 28155 00003E55 74AD                    	jz	short Ret60		; wrote all supposed to
 28156                                  	; 18/04/2023
 28157 00003E57 F606[868C]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28158                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28159 00003E5C 7414                    	jz	short COPYERR		; is a file, error
 28160 00003E5E F606[868C]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28161                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28162 00003E63 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28163 00003E65 803E[438D]00            	cmp	byte [INEXACT],0
 28164 00003E6A 7598                    	jnz	short Ret60		; inexact so ok
 28165 00003E6C 49                      	dec	cx
 28166                                  ;Retz60:
 28167 00003E6D 7495                    	jz	short Ret60		; wrote one byte less (the ^z)
 28168                                  
 28169                                  DevWrtErr:
 28170 00003E6F BA[9380]                	mov	dx,DEVWMES_PTR
 28171                                  	; 26/03/2023
 28172                                  COPYERR:
 28173                                  	;invoke	Std_EPrintF		;AC022;
 28174 00003E72 E8540F                  	call	std_eprintf  ; MSDOS 6.0
 28175                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28176                                  CopErrP:
 28177 00003E75 FE06[C38A]              	inc	byte [DestClosed]
 28178 00003E79 803E[C28A]00            	cmp	byte [CFLAG],0
 28179 00003E7E 7448                    	jz	short EndCopyJ		; never actually got it open
 28180 00003E80 8B1E[848C]              	mov	bx,[DESTHAND]
 28181 00003E84 83FB00                  	cmp	bx,0
 28182 00003E87 7E33                    	jle	short NoClose
 28183                                  
 28184                                  ;	Check to see if we should save part of the destination file.
 28185                                  
 28186                                  	; 26/03/2023
 28187                                  	; MSDOS 6.0
 28188 00003E89 8B0E[528D]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 28189 00003E8D 8B16[508D]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 28190                                  			
 28191 00003E91 89C8                    	mov	ax,cx
 28192 00003E93 09D0                    	or	ax,dx
 28193 00003E95 7421                    	jz	short ceClose		; null file ptr means nothing to save
 28194                                  
 28195                                  ;	Destination was also the first source. Do the best we can to
 28196                                  ;	restore it. Truncate it back to the size we took from it (which
 28197                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 28198                                  ;	file). If a Ctrl-Z was originally read, put it back.
 28199                                  
 28200 00003E97 B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 28201 00003E9A CD21                    	int	21h
 28202                                  
 28203 00003E9C 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 28204 00003E9E B440                    	mov	ah,Write ; 40h
 28205 00003EA0 CD21                    	int	21h			; truncate file
 28206                                  
 28207 00003EA2 803E[548D]00            	cmp	byte [OCtrlZ],0
 28208 00003EA7 7408                    	je	short ceClose0		; no ctrl-z removed from original
 28209 00003EA9 41                      	inc	cx			; CX = # bytes to write = 1
 28210 00003EAA BA[548D]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 28211 00003EAD B440                    	mov	ah,Write ; 40h
 28212 00003EAF CD21                    	int	21h			; write ctrl-z
 28213                                  ceClose0:
 28214 00003EB1 B43E                    	mov	ah,CLOSE ; 3Eh
 28215 00003EB3 CD21                    	int	21h			; close it
 28216                                  ;;	;mov	byte [CFLAG],0
 28217 00003EB5 E980FA                  	jmp	ENDCOPY			; and go home
 28218                                  
 28219                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28220                                  ceClose:
 28221 00003EB8 B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 28222 00003EBA CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28223                                  				; BX = file handle
 28224                                  NoClose:
 28225 00003EBC BA[2D8C]                	mov	dx,DestBuf
 28226 00003EBF B441                    	mov	ah,Unlink ; 41h 	; and delete it
 28227 00003EC1 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 28228                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 28229 00003EC3 C606[C28A]00            	mov	byte [CFLAG],0
 28230                                  EndCopyJ:
 28231 00003EC8 E96DFA                  	jmp	ENDCOPY
 28232                                  
 28233                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 28234 00003ECB E9B3FE                  	jmp	Xa_Set_Error
 28235                                  
 28236                                  ;============================================================================
 28237                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 28238                                  ;============================================================================
 28239                                  ; 01/10/2018 - Retro DOS v3.0
 28240                                  
 28241                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 28242                                  
 28243                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28244                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 28245                                  
 28246                                  ; =============== S U B	R O U T	I N E =======================================
 28247                                  
 28248                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 28249                                  ;
 28250                                  ;	Given switch vector in AX,
 28251                                  ;	  Set Ascii flag if /a is set
 28252                                  ;	  Clear Ascii flag if /b is set
 28253                                  ;	  Binary set if /b specified
 28254                                  ;	  Leave Ascii unchanged if neither or both are set
 28255                                  ; 	Also sets Inexact if Ascii is ever set. 
 28256                                  ;	AL = Ascii on exit, flags set
 28257                                  
 28258                                  	; 26/03/2023
 28259                                  SETASC:
 28260                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 28261 00003ECE 240C                    	and	al,0Ch ; 4+8
 28262 00003ED0 7A10                    	jpe	short LOADSW	; even parity - both or neither
 28263 00003ED2 50                      	push	ax
 28264                                  	;and	al,SWITCHB  ; 8
 28265 00003ED3 2408                    	and	al,8
 28266 00003ED5 A2[458D]                	mov	[BINARY],al
 28267 00003ED8 58                      	pop	ax
 28268                                  	;and	al,SWITCHA
 28269 00003ED9 2404                    	and	al,4	
 28270 00003EDB A2[498D]                	mov	[ASCII],al
 28271 00003EDE 0806[438D]              	or	[INEXACT],al
 28272                                  LOADSW:
 28273 00003EE2 A0[498D]                	mov	al,[ASCII]
 28274 00003EE5 08C0                    	or	al,al
 28275 00003EE7 C3                      	retn
 28276                                  
 28277                                  ; =============== S U B	R O U T	I N E =======================================
 28278                                  
 28279                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28280                                  BUILDDEST:
 28281 00003EE8 803E[288C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 28282 00003EED 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 28283 00003EEF BF[8789]                	mov	di,USERDIR1
 28284 00003EF2 BD[288C]                	mov	bp,DestVars
 28285 00003EF5 E8DF00                  	call	BUILDPATH
 28286 00003EF8 E884E5                  	call	RestUDir1
 28287                                  
 28288                                  ;	We now know all about the destination
 28289                                  
 28290                                  KNOWABOUTDEST:
 28291 00003EFB 30C0                    	xor	al,al
 28292 00003EFD 8606[878C]              	xchg	al,[FIRSTDEST]
 28293 00003F01 08C0                    	or	al,al
 28294 00003F03 7503                    	jnz	short FIRSTDST
 28295 00003F05 E98C00                  	jmp	NOFIRSTDEST
 28296                                  
 28297                                  FIRSTDST:
 28298                                  ;	Create an fcb of the original dest.
 28299                                  
 28300 00003F08 8B36[2A8C]              	mov	si,[DestTail]
 28301 00003F0C BF[678B]                	mov	di,DestFcb
 28302 00003F0F B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 28303 00003F12 CD21                    	int	21h		; DOS -	PARSE FILENAME
 28304                                  				; DS:SI	-> string to parse
 28305                                  				; ES:DI	-> buffer to fill with unopened	FCB
 28306                                  				; AL = bit mask	to control parsing
 28307 00003F14 803C00                  	cmp	byte [si],0
 28308 00003F17 7406                    	jz	short GOODPARSE
 28309                                  
 28310                                  	; 27/03/2023	
 28311                                  	; MSDOS 6.0
 28312                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 28313                                  	
 28314 00003F19 BA[167F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 28315 00003F1C E953FF                  	jmp	COPYERR			;AN052;
 28316                                  GOODPARSE:
 28317 00003F1F A1[2D8C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 28318 00003F22 80FC3A                  	cmp	ah,':'
 28319 00003F25 7402                    	jz	short DRVSPEC4
 28320 00003F27 B040                    	mov	al,'@'  ; 40h
 28321                                  DRVSPEC4:
 28322                                  ;	AX = "d:" for following FCB drive computation
 28323                                  
 28324 00003F29 8A0E[498D]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 28325 00003F2D 0C20                    	or	al,20h
 28326 00003F2F 2C60                    	sub	al,60h
 28327 00003F31 A2[678B]                	mov	[DestFcb],al		; store drive # in FCB
 28328                                  
 28329                                  ;*	Figure out what copy mode we're in.
 28330                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 28331                                  ;	+n stands for additional sources delimited by +'s.
 28332                                  ;
 28333                                  ;	copy a b	not concatenating
 28334                                  ;	copy a *	not concatenating
 28335                                  ;	copy * a	concatenating
 28336                                  ;	copy * *	not concatenating
 28337                                  ;	copy a+n b	concatenating
 28338                                  ;	copy *+n a	concatenating
 28339                                  ;	copy *+n *	concatenating, Mel Hallerman style
 28340                                  
 28341                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28342                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28343                                  
 28344 00003F34 A0[2C8C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28345 00003F37 8A26[8F8C]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28346 00003F3B 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28347 00003F3E 08C0                    	or	al,al
 28348 00003F40 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28349                                  
 28350                                  ;	Destination is wildcarded.
 28351                                  	
 28352 00003F42 38E0                    	cmp	al,ah
 28353 00003F44 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28354                                  
 28355                                  ;	Source and destination are both wildcarded.
 28356                                  
 28357 00003F46 803E[4A8D]00            	cmp	byte [PLUS],0
 28358 00003F4B 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28359                                  
 28360                                  ;	Source and destination are wildcarded, and source includes +'s.
 28361                                  ;	It's Mel Hallorman copy time.
 28362                                  
 28363 00003F4D FE06[888C]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28364 00003F51 30C0                    	xor	al,al
 28365 00003F53 EB06                    	jmp	short SETCONC
 28366                                  
 28367                                  NOTMELCOPY:
 28368 00003F55 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28369 00003F57 20E0                    	and	al,ah
 28370 00003F59 D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28371                                  					;   (implies concatenation)
 28372                                  SETCONC:
 28373 00003F5B 0A06[4A8D]              	or	al,[PLUS]		; "+" always infers concatenation
 28374                                  
 28375                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28376                                  
 28377 00003F5F A2[B88A]                	mov	[Concat],al
 28378 00003F62 D0E0                    	shl	al,1
 28379 00003F64 D0E0                    	shl	al,1
 28380 00003F66 A2[438D]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28381 00003F69 803E[458D]00            	cmp	byte [BINARY],0
 28382 00003F6E 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy
 28383                                  
 28384 00003F70 A2[498D]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode
 28385 00003F73 08C9                    	or	cl,cl
 28386 00003F75 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly
 28387 00003F77 08C0                    	or	al,al
 28388 00003F79 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28389                                  
 28390                                  ;	At this point there may already be binary read data in the read
 28391                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28392                                  ;	amount of data in the buffer correctly.
 28393                                  
 28394 00003F7B 8B0E[C68A]              	mov	cx,[NXTADD]
 28395 00003F7F E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28396 00003F81 B01A                    	mov	al,1Ah
 28397 00003F83 06                      	push	es
 28398 00003F84 31FF                    	xor	di,di
 28399 00003F86 8E06[A78A]              	mov	es,[TPA]
 28400 00003F8A F2AE                    	repne	scasb			; scan for EOF
 28401 00003F8C 07                      	pop	es
 28402 00003F8D 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28403 00003F8F 4F                      	dec	di			; point at ^z
 28404 00003F90 893E[C68A]              	mov	[NXTADD],di		; new buffer length
 28405                                  
 28406                                  NOFIRSTDEST:
 28407 00003F94 BB[AB8B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28408 00003F97 803E[B88A]00            	cmp	byte [Concat],0
 28409 00003F9C 7403                    	jz	short GOTCHRSRC		; Not a concat
 28410 00003F9E BB[F18B]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28411                                  GOTCHRSRC:
 28412 00003FA1 BE[688B]                	mov	si,DestFcb+1		; Original dest name
 28413 00003FA4 8B3E[2A8C]              	mov	di,[DestTail]		; Where to put result
 28414                                  
 28415                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28416                                  
 28417                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28418                                  BUILDNAME:
 28419 00003FA8 B90800                  	mov	cx,8
 28420                                  BUILDMAIN:
 28421 00003FAB AC                      	lodsb
 28422 00003FAC 3C3F                    	cmp	al,'?'
 28423 00003FAE 7502                    	jne	short NOTAMBIG
 28424 00003FB0 8A07                    	mov	al,[bx]
 28425                                  NOTAMBIG:
 28426 00003FB2 3C20                    	cmp	al,' '
 28427 00003FB4 7401                    	je	short NOSTORE
 28428 00003FB6 AA                      	stosb
 28429                                  NOSTORE:
 28430 00003FB7 43                      	inc	bx
 28431 00003FB8 E2F1                    	loop	BUILDMAIN
 28432 00003FBA B103                    	mov	cl,3
 28433                                  	;mov	al,' ' ; 20h
 28434                                  	;cmp	[si],al
 28435                                  	; 27/03/2023
 28436 00003FBC 803C20                  	cmp	byte [si],20h ; ' '
 28437 00003FBF 7412                    	je	short ENDDEST		; No extension
 28438                                  	;mov	al,[DOT_CHR]
 28439                                  	; 27/03/2023
 28440 00003FC1 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28441 00003FC3 AA                      	stosb
 28442                                  BUILDEXT:
 28443 00003FC4 AC                      	lodsb
 28444 00003FC5 3C3F                    	cmp	al,'?'
 28445 00003FC7 7502                    	jne	short NOTAMBIGE
 28446 00003FC9 8A07                    	mov	al,[bx]
 28447                                  NOTAMBIGE:
 28448 00003FCB 3C20                    	cmp	al,' '
 28449 00003FCD 7401                    	je	short NOSTOREE
 28450 00003FCF AA                      	stosb
 28451                                  NOSTOREE:
 28452 00003FD0 43                      	inc	bx
 28453 00003FD1 E2F1                    	loop	BUILDEXT
 28454                                  ENDDEST:
 28455 00003FD3 30C0                    	xor	al,al
 28456 00003FD5 AA                      	stosb				; NUL terminate
 28457 00003FD6 C3                      	retn
 28458                                  
 28459                                  ; =============== S U B	R O U T	I N E =======================================
 28460                                  	
 28461                                  	; 28/03/2023
 28462                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28463                                  BUILDPATH:
 28464 00003FD7 F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 28465 00003FDB 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28466 00003FDD 89EA                    	mov	dx,bp			; Set DX to spec
 28467 00003FDF 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28468                                  
 28469                                  	; 27/03/2023
 28470                                  	; MSDOS 6.0
 28471 00003FE2 57                      	push	di			;AN000;
 28472 00003FE3 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28473                                  	;mov	bx,deny_none|read_open_mode
 28474 00003FE6 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28475 00003FE9 31C9                    	xor	cx,cx			;AN000; no special files
 28476 00003FEB 89D6                    	mov	si,dx			;AN030; get file name offset
 28477                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28478 00003FED BA0101                  	mov	dx,101h
 28479 00003FF0 CD21                    	INT	21h
 28480 00003FF2 5F                      	pop	di			;AN000;
 28481 00003FF3 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28482 00003FF5 E8F8DC                  	call	get_ext_error_number	;AN022; get the extended error
 28483                                  	;cmp	ax,2
 28484 00003FF8 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28485 00003FFB 7423                    	jz	short NOTPFILE		;AN022;
 28486                                  	;cmp	ax,3
 28487 00003FFD 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28488 00004000 741E                    	jz	short NOTPFILE		;AN022;
 28489                                  	;cmp	ax,5
 28490 00004002 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28491 00004005 7419                    	jz	short NOTPFILE		;AN022;
 28492 00004007 E929DA                  	jmp	extend_setup		;AN022; exit with error
 28493                                  
 28494                                  	; 27/03/2023
 28495                                  	; MSDOS 3.3
 28496                                  	;mov	ax,OPEN*256 ; 3D00h
 28497                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28498                                  	;			; DS:DX	-> ASCIZ filename
 28499                                  	;			; AL = access mode
 28500                                  	;			; 0 - read
 28501                                  	;jc	short NOTPFILE
 28502                                  
 28503                                  PURE_FILE:
 28504 0000400A 89C3                    	mov	bx,ax
 28505 0000400C B80044                  	mov	ax,IOCTL*256 ; 4400h
 28506 0000400F CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28507                                  				; BX = file or device handle
 28508 00004011 B43E                    	mov	ah,CLOSE ;3Eh
 28509 00004013 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28510                                  				; BX = file handle
 28511                                  	; 18/04/2023
 28512 00004015 F6C280                  	test	dl,80h
 28513                                  	;test	dl,devid_ISDEV ; test dl,80h
 28514 00004018 7553                    	jnz	short ISADEV
 28515 0000401A F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28516 0000401E 744D                    	jz	short ISADEV
 28517                                  NOTPFILE:
 28518 00004020 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28519                                  	
 28520                                  	; 27/03/2023
 28521                                  	; MSDOS 6.0
 28522 00004023 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28523 00004026 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28524                                  
 28525 00004028 80FE3A                  	cmp	dh,':'
 28526 0000402B 7402                    	je	short DRVSPEC5
 28527                                  SET_DRIVE_SPEC:
 28528 0000402D B240                    	mov	dl,'@' ; 40h
 28529                                  DRVSPEC5:
 28530 0000402F 80CA20                  	or	dl,20h
 28531 00004032 80EA60                  	sub	dl,60h		; A = 1
 28532 00004035 E874E5                  	call	SAVUDIR1
 28533                                  	
 28534                                  	; 27/03/2023
 28535                                  	; MSDOS 6.0
 28536 00004038 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28537 0000403A E8B3DC                  	call	get_ext_error_number	;AN022; get the extended error
 28538 0000403D E9F3D9                  	jmp	extend_setup		;AN022; exit with error
 28539                                  
 28540                                  CURDIR_OK:
 28541 00004040 89EA                    	mov	dx,bp
 28542                                  	;add	dx,5
 28543 00004042 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28544                                  	;mov	bh,[bp+4]
 28545 00004045 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28546 00004048 80E706                  	and	bh,6
 28547 0000404B 80FF06                  	cmp	bh,6			; Ambig and path ?
 28548 0000404E 7518                    	jne	short CHECKAMB		; jmp if no
 28549                                  	;mov	si,[bp+2]
 28550 00004050 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28551 00004053 B33A                    	mov	bl,':'
 28552 00004055 385CFE                  	cmp	[si-2],bl
 28553 00004058 7506                    	jne	short KNOWNOTSPEC
 28554                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28555                                  					; Know is d:/file
 28556                                  	;mov	byte [bp+0],2
 28557 0000405A C6460002                	mov	byte [bp],2
 28558 0000405E EB05                    	jmp	short DOPCDJ
 28559                                  KNOWNOTSPEC:
 28560                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28561                                  					; Know is path/file
 28562                                  	;mov	byte [bp+0],1
 28563 00004060 C6460001                	mov	byte [bp],1
 28564 00004064 4E                      	dec	si
 28565                                  DOPCDJ:
 28566 00004065 E98300                  	jmp	DOPCD
 28567                                  CHECKAMB:
 28568 00004068 80FF02                  	cmp	bh,2
 28569 0000406B 7505                    	jnz	short CHECKCD
 28570                                  ISSIMPFILE:
 28571                                  ISADEV:
 28572                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28573                                  	;mov	byte [bp+0],0
 28574 0000406D C6460000                	mov	byte [bp],0
 28575 00004071 C3                      	retn
 28576                                  CHECKCD:
 28577 00004072 E86AEC                  	call	SetRest1
 28578 00004075 B43B                    	mov	ah,CHDir ; 3Bh
 28579 00004077 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28580                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28581 00004079 7239                    	jb	short NOTPDIR
 28582 0000407B 89D7                    	mov	di,dx
 28583 0000407D 31C0                    	xor	ax,ax
 28584 0000407F 89C1                    	mov	cx,ax
 28585 00004081 49                      	dec	cx
 28586                                  	; 14/06/2023
 28587                                  	;repne	scasb	 ; MSDOS 3.3
 28588                                  
 28589                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28590                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28591                                  	; MSDOS 6.0
 28592                                  Kloop:					;AN000;  3/3/KK
 28593 00004082 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28594 00004085 47                      	inc	di			;AN000;  3/3/KK
 28595 00004086 08C0                    	or	al,al			;AN000;  3/3/KK
 28596 00004088 740C                    	jz	short DONE		;AN000;  3/3/KK
 28597 0000408A 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28598 0000408C E82EE3                  	call	testkanj		;AN000;  3/3/KK
 28599 0000408F 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28600 00004091 47                      	inc	di			;AN000;  3/3/KK
 28601 00004092 FEC4                    	inc	ah			;AN000;  3/3/KK
 28602 00004094 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28603                                  DONE:
 28604 00004096 4F                      	dec	di
 28605 00004097 A0[AA8A]                	mov	al,[DIRCHAR]
 28606                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28607                                  	;mov	byte [bp+0],2
 28608 0000409A C6460002                	mov	byte [bp],2
 28609                                  	; 27/03/2023
 28610                                  	; MSDOS 6.0
 28611 0000409E 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28612 000040A0 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK
 28613                                  					;this is the trailing byte of ECS code
 28614                                  	;
 28615 000040A2 3A45FF                  	cmp	al,[di-1]
 28616 000040A5 7405                    	jz	short GOTSRCSLSH
 28617                                  _STORE_PCHAR:
 28618 000040A7 AA                      	stosb
 28619                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28620                                  	;mov	byte [bp+0],1
 28621 000040A8 C6460001                	mov	byte [bp],1
 28622                                  GOTSRCSLSH:
 28623                                  	;or	byte [bp+4],6
 28624 000040AC 804E0406                	or 	byte [bp+VARSTRUC.INFO],6
 28625 000040B0 E87400                  	call	SETSTARS
 28626                                  NOTPDIR_RETN:
 28627 000040B3 C3                      	retn
 28628                                  
 28629                                  	; 28/03/2023
 28630                                  NOTPDIR:
 28631                                  	; MSDOS 6.0
 28632 000040B4 E839DC                  	call	get_ext_error_number	;AN022; get the extended error
 28633                                  	;cmp	ax,3
 28634 000040B7 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28635 000040BA 7405                    	je	short NOTPDIR_TRY	;AN022;
 28636                                  	;cmp	ax,5
 28637 000040BC 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28638 000040BF 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28639                                  NOTPDIR_TRY:
 28640                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28641                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28642                                  	;mov	byte [bp+0],0
 28643 000040C1 C6460000                	mov	byte [bp],0
 28644                                  	;mov	bh,[bp+4]
 28645 000040C5 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28646 000040C8 F6C704                  	test	bh,4
 28647 000040CB 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28648                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28649                                  	;mov	byte [bp+0],2
 28650 000040CD C6460002                	mov	byte [bp],2
 28651                                  	;mov	si,[bp+2]
 28652 000040D1 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28653 000040D4 803C00                  	cmp	byte [si],0
 28654 000040D7 744B                    	je	short BADCDERRJ2	; Trailing '/'
 28655                                  	;mov	bl,[DOT_CHR]
 28656                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28657                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28658 000040D9 B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28659 000040DB 381C                    	cmp	[si],bl
 28660 000040DD 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28661 000040DF B33A                    	mov	bl,':'  ; 3Ah
 28662 000040E1 385CFE                  	cmp	[si-2],bl
 28663 000040E4 7405                    	je	short DOPCD		; Know d:/file
 28664                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28665                                  					; Know path/file
 28666                                  	;mov	byte [bp+0],1
 28667 000040E6 C6460001                	mov	byte [bp],1
 28668 000040EA 4E                      	dec	si			; Point at last '/'
 28669                                  DOPCD:
 28670 000040EB 30DB                    	xor	bl,bl
 28671 000040ED 861C                    	xchg	bl,[si]			; Stick in a NUL
 28672 000040EF E8EDEB                  	call	SetRest1
 28673                                  
 28674                                  	; 28/03/2023
 28675                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28676 000040F2 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28677 000040F4 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28678 000040F6 56                      	push	si			;AN000;  3/3/KK
 28679 000040F7 51                      	push	cx			;AN000;  3/3/KK
 28680 000040F8 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28681 000040FA 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28682                                  Kloop2: 				;AN000;  3/3/KK
 28683 000040FC AC                      	lodsb				;AN000;  3/3/KK
 28684 000040FD E8BDE2                  	call	testkanj		;AN000;  3/3/KK
 28685 00004100 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28686 00004102 AC                      	lodsb				;AN000;  3/3/KK
 28687 00004103 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28688 00004105 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28689 00004107 59                      	pop	cx			;AN000;  3/3/KK
 28690 00004108 5E                      	pop	si			;AN000;  3/3/KK
 28691 00004109 EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28692                                  					;		 trailing path sep
 28693                                  NotKanj4:				;AN000;  3/3/KK
 28694 0000410B 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28695 0000410D 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28696 0000410F 59                      	pop	cx			;AN000;  3/3/KK
 28697 00004110 5E                      	pop	si			;AN000;  3/3/KK
 28698                                  LookBack:				;AN000;  3/3/KK
 28699                                  	; 28/03/2023
 28700                                  	; MSDOS 3.3 & MSDOS 6.0
 28701 00004111 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28702 00004114 740E                    	je	short BADCDERRJ2
 28703                                  DoCdr:
 28704 00004116 B43B                    	mov	ah,CHDir ; 3Bh
 28705 00004118 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28706                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28707 0000411A 861C                    	xchg	bl,[si]
 28708 0000411C 7395                    	jnc	short NOTPDIR_RETN
 28709                                  	
 28710                                  	; 28/03/2023
 28711                                  	; MSDOS 3.3
 28712                                  ;BADCDERRJ2:
 28713                                  	;stc
 28714                                  	;jmp	BADCDERR
 28715                                  
 28716                                  	; 28/03/2023
 28717                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28718 0000411E E8CFDB                  	call	get_ext_error_number	;AN022; get the extended error
 28719                                  EXTEND_SETUPJ:				;AN022;
 28720 00004121 E90FD9                  	jmp	extend_setup		;AN022; go issue the error message
 28721                                  BADCDERRJ2:
 28722 00004124 E909D9                  	jmp	badpath_err		;AC022; go issue path not found message
 28723                                  
 28724                                  ; =============== S U B	R O U T	I N E =======================================
 28725                                  
 28726                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28727                                  SETSTARS:
 28728                                  	;mov	[bp+2],di
 28729 00004127 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28730                                  	;add	byte [bp+1],12
 28731 0000412A 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28732                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28733                                  	; 28/03/2023
 28734                                  	; MSDOS 6.0
 28735 0000412E B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28736                                  	;mov	ax,'?.' ; dot_qmark
 28737                                  
 28738 00004131 B90800                  	mov	cx,8
 28739 00004134 F3AA                    	rep	stosb
 28740 00004136 86C4                    	xchg	al,ah
 28741 00004138 AA                      	stosb
 28742 00004139 86C4                    	xchg	al,ah
 28743 0000413B B103                    	mov	cl,3
 28744 0000413D F3AA                    	rep	stosb
 28745 0000413F 30C0                    	xor	al,al
 28746 00004141 AA                      	stosb
 28747 00004142 C3                      	retn
 28748                                  
 28749                                  ; =============== S U B	R O U T	I N E =======================================
 28750                                  
 28751                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28752                                  COMPNAME:
 28753 00004143 BE[2D8C]                	mov	si,DestBuf	; do name translate of target
 28754 00004146 BF[2A88]                	mov	di,TRGXNAME	; save for name comparison
 28755 00004149 B460                    	mov	ah,xNameTrans ; 60h
 28756 0000414B CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28757                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28758                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28759 0000414D BE[D387]                	mov	si,SRCXNAME	; get name translate of source
 28760 00004150 BF[2A88]                	mov	di,TRGXNAME	; get name translate of target
 28761                                  	;call	STRCOMP
 28762                                  	;retn
 28763                                  	; 28/03/2023
 28764 00004153 E9C8E4                  	jmp	STRCOMP
 28765                                  
 28766                                  ;============================================================================
 28767                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28768                                  ;============================================================================
 28769                                  ; 30/09/2018 - Retro DOS v3.0
 28770                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28771                                  
 28772                                  ;-----------------------------------------------------------------------;
 28773                                  ; ENTRY:								;
 28774                                  ;	DS:SI	Points input buffer					;
 28775                                  ;	ES:DI	Points to the token buffer				;
 28776                                  ;	BL	Special delimiter for this call 			;
 28777                                  ;		    Always checked last 				;
 28778                                  ;		    set it to space if there is no special delimiter	;
 28779                                  ; EXIT: 								;
 28780                                  ;	DS:SI	Points to next char in the input buffer 		;
 28781                                  ;	ES:DI	Points to the token buffer				;
 28782                                  ;	[STARTEL] Points to start of last element of path in token	;
 28783                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28784                                  ;	CX	Character count 					;
 28785                                  ;	BH	Condition Code						;
 28786                                  ;			Bit 1H of BH set if switch character		;
 28787                                  ;				Token buffer contains char after	;
 28788                                  ;				switch character			;
 28789                                  ;				BP has switch bits set (ORing only)	;
 28790                                  ;			Bit 2H of BH set if ? or * in token		;
 28791                                  ;				if * found element ? filled		;
 28792                                  ;			Bit 4H of BH set if path sep in token		;
 28793                                  ;			Bit 80H of BH set if the special delimiter	;
 28794                                  ;			   was skipped at the start of this token	;
 28795                                  ;		Token buffer always starts d: for non switch tokens	;
 28796                                  ;	CARRY SET							;
 28797                                  ;	    if CR on input						;
 28798                                  ;		token buffer not altered				;
 28799                                  ;									;
 28800                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28801                                  ; MODIFIES:								;
 28802                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28803                                  ;									;
 28804                                  ;-----------------------------------------------------------------------;
 28805                                  
 28806                                  ; Modifications to cparse: recognition of right and left parentheses
 28807                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28808                                  ;
 28809                                  ; Both modifications were installed in the course of adding a coherent
 28810                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28811                                  ; structure for command-line arguments. This parser relies on cparse to
 28812                                  ; recognize individual tokens.
 28813                                  ;
 28814                                  ; To process for-loops correctly, parentheses must therefore be
 28815                                  ; recognized as tokens. The upper-case conversion code was removed so
 28816                                  ; that commands (such as for and echo) would be able to use the "original"
 28817                                  ; text of the command line.
 28818                                  ;
 28819                                  ; Note also the modification to prevent the automatic conversion of colons
 28820                                  ; into spaces WITHIN THE SOURCE TEXT!
 28821                                  ;
 28822                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28823                                  ; on the command line.
 28824                                  ;
 28825                                  ; Alan L, OS/MSDOS				    14 August 1983
 28826                                  
 28827                                  ; ---------------------------------------------------------------------------
 28828                                  
 28829                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28830                                  
 28831                                  ;FSWITCH	EQU	8000h
 28832                                  ;FBADSWITCH	EQU	4000h
 28833                                  
 28834                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28835                                  
 28836                                  ; =============== S U B	R O U T	I N E =======================================
 28837                                  		
 28838                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28839                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28840                                  
 28841                                  cparse:
 28842 00004156 31C0                    	xor	ax,ax
 28843 00004158 893E[578D]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28844 0000415C A2[5A8D]                	mov	[ELPOS],al		; Start in 8 char prefix
 28845                                  	; MSDOS 3.3
 28846                                  	;mov	[SOURCE],al		
 28847                                  	; MSDOS 6.0
 28848 0000415F A2[5B8D]                	mov	[SKPDEL], al		; No skip delimiter yet
 28849 00004162 88C7                    	mov	bh,al			; Init nothing
 28850 00004164 9C                      	pushf				; save flags
 28851 00004165 57                      	push	di			; save the token buffer addrss
 28852 00004166 31C9                    	xor	cx,cx			; no chars in token buffer
 28853 00004168 880E[068C]              	mov	[comma],cl		; reset comma flag
 28854                                  moredelim:
 28855 0000416C AC                      	lodsb
 28856 0000416D E874E4                  	call	DELIM
 28857 00004170 751D                    	jnz	short SCANCDONE
 28858 00004172 3C20                    	cmp	al,' '
 28859 00004174 74F6                    	jz	short moredelim
 28860 00004176 3C09                    	cmp	al,9
 28861 00004178 74F2                    	jz	short moredelim
 28862                                  	;xchg	al,[SOURCE]
 28863                                  	; 28/03/2023
 28864 0000417A 8606[5B8D]              	xchg	al,[SKPDEL]
 28865 0000417E 08C0                    	or	al,al
 28866 00004180 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28867 00004182 F6C780                  	test	bh,80h			; has a special char been found?
 28868 00004185 7405                    	jz	short no_comma		; no - just exit
 28869 00004187 C606[068C]01            	mov	byte [comma],1		; set comma flag
 28870                                  no_comma:
 28871 0000418C E92A01                  	jmp	x_done			; Nul argument
 28872                                  
 28873                                  SCANCDONE:
 28874                                  	; 28/03/2023
 28875                                  	; MSDOS 6.0
 28876                                  	; -----------------------------------
 28877                                  	; Mod to avoid upper-case conversion.
 28878                                  	; -----------------------------------
 28879                                  	; MSDOS 3.3
 28880                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28881                                  	;jnz	short cpcont1		; 3/3/KK
 28882                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28883                                  cpcont1:
 28884                                  	; -----------------------------------
 28885                                  	; 28/03/2023
 28886 0000418F 38D8                    	cmp	al,bl			; Special delimiter?
 28887 00004191 7505                    	jne	short nospec
 28888 00004193 80CF80                  	or	bh,80h
 28889 00004196 EBD4                    	jmp	short moredelim
 28890                                  nospec:
 28891 00004198 3C0D                    	cmp	al,0Dh			; a CR?
 28892 0000419A 7503                    	jne	short ncperror
 28893 0000419C E91501                  	jmp	cperror
 28894                                  ncperror:
 28895 0000419F 3A06[A98A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28896 000041A3 7503                    	jne	short na_switch		; yes, process...
 28897 000041A5 E91401                  	jmp	a_switch
 28898                                  na_switch:
 28899 000041A8 B23A                    	mov	dl,':'
 28900 000041AA 3814                    	cmp	[si],dl
 28901 000041AC 751D                    	jne	short anum_chard	; Drive not specified
 28902                                  	; 28/03/2023
 28903                                  	; MSDOS 6.0 
 28904 000041AE 803E[158C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28905 000041B3 7503                    	jne	short cpcont2		; 3/3/KK
 28906 000041B5 E82FE2                  	call	UPCONV			; 3/3/KK
 28907                                  cpcont2:
 28908 000041B8 E85901                  	call	move_char
 28909 000041BB AC                      	lodsb				; Get the ':'
 28910 000041BC E85501                  	call	move_char
 28911 000041BF 893E[578D]              	mov	[STARTEL],di
 28912 000041C3 C606[598D]00            	mov	byte [ELCNT],0
 28913 000041C8 E9B300                  	jmp	anum_test
 28914                                  anum_chard:
 28915 000041CB 893E[578D]              	mov	[STARTEL],di
 28916 000041CF C606[598D]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28917 000041D4 803E[158C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28918 000041D9 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28919 000041DB E88CE4                  	call	pathchrcmp		; Starts with a pathchar?
 28920 000041DE 7518                    	jnz	short anum_char		; no
 28921 000041E0 50                      	push	ax
 28922 000041E1 A0[B78A]                	mov	al,[CURDRV]		; Insert drive spec
 28923                                  	;add	al,[CAPITAL_A]
 28924                                  	; 28/03/2023
 28925                                  	; MSDOS 6.0
 28926 000041E4 0441                    	add	al,'A' ; 41h
 28927 000041E6 E82B01                  	call	move_char
 28928 000041E9 B03A                    	mov	al,':' ; 3Ah
 28929 000041EB E82601                  	call	move_char
 28930 000041EE 58                      	pop	ax
 28931 000041EF 893E[578D]              	mov	[STARTEL],di
 28932 000041F3 C606[598D]00            	mov	byte [ELCNT],0
 28933                                  anum_char:
 28934                                  	; 28/03/2023
 28935                                  	; MSDOS 6.0
 28936 000041F8 E8C2E1                  	call	testkanj		;AC048			
 28937 000041FB 7406                    	jz	short NOTKANJ		;AC048;
 28938 000041FD E81401                  	call	move_char
 28939 00004200 AC                      	lodsb
 28940 00004201 EB78                    	jmp	short notspecial
 28941                                  
 28942                                  NOTKANJ:				;AN048; If not kanji
 28943 00004203 803E[158C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28944 00004208 7503                    	jne	short TESTDOT 		;AN048;
 28945 0000420A E8DAE1                  	call	UPCONV			;AN048; upper case the char
 28946                                  TESTDOT:
 28947                                  	; 28/03/2023
 28948                                  	;cmp	al,dot_chr  ; 2Eh
 28949 0000420D 3C2E                    	cmp	al,'.'
 28950 0000420F 7509                    	jne	short testquest
 28951 00004211 FE06[5A8D]              	inc	byte [ELPOS] 		; flag in extension
 28952 00004215 C606[598D]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28953                                  testquest:
 28954 0000421A 3C3F                    	cmp	al,'?'  ; 3Fh
 28955 0000421C 7503                    	jnz	short testsplat
 28956 0000421E 80CF02                  	or	bh,2
 28957                                  testsplat:
 28958                                  	;cmp	al,[STAR]
 28959 00004221 3C2A                    	cmp	al,star	; 2Ah
 28960                                  	; 27/04/2023
 28961                                  	;cmp	al,'*' 
 28962 00004223 7530                    	jne	short testpath
 28963 00004225 80CF02                  	or	bh,2
 28964 00004228 803E[928D]00            	cmp	byte [expand_star],0
 28965 0000422D 7504                    	jne	short expand_filename
 28966 0000422F EB24                    	jmp	short testpath
 28967                                  
 28968                                  BADPERR2J:
 28969                                  	;jmp	BADPERR2
 28970                                  	; 28/03/2023
 28971                                  	; MSDOS 6.0
 28972 00004231 EB75                    	jmp	short BADPERR2
 28973                                  
 28974                                  expand_filename:
 28975 00004233 B407                    	mov	ah,7
 28976 00004235 803E[5A8D]00            	cmp	byte [ELPOS],0
 28977 0000423A 7402                    	jz	short gotelcnt
 28978 0000423C B402                    	mov	ah,2
 28979                                  gotelcnt:
 28980 0000423E B03F                    	mov	al,'?'
 28981 00004240 2A26[598D]              	sub	ah,[ELCNT]
 28982 00004244 72EB                    	jb	short BADPERR2J
 28983 00004246 86E1                    	xchg	ah,cl
 28984 00004248 E309                    	jcxz	testpathx
 28985                                  qmove:
 28986 0000424A 86E1                    	xchg	ah,cl
 28987 0000424C E8C500                  	call	move_char
 28988 0000424F 86E1                    	xchg	ah,cl
 28989 00004251 E2F7                    	loop	qmove
 28990                                  testpathx:
 28991 00004253 86E1                    	xchg	ah,cl
 28992                                  testpath:
 28993 00004255 E812E4                  	call	pathchrcmp
 28994 00004258 7521                    	jnz	short notspecial
 28995 0000425A 80CF04                  	or	bh,4
 28996 0000425D 803E[928D]00            	cmp	byte [expand_star],0
 28997 00004262 7405                    	jz	short no_err_check
 28998 00004264 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28999 00004267 7545                    	jnz	short BADPERR
 29000                                  no_err_check:
 29001 00004269 893E[578D]              	mov	[STARTEL],di	  	; New element
 29002 0000426D FF06[578D]              	inc	word [STARTEL]	  	; Point to char after /
 29003 00004271 C606[598D]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 29004 00004276 C606[5A8D]00            	mov	byte [ELPOS],0
 29005                                  notspecial:
 29006 0000427B E89600                  	call	move_char		; just an alphanum string
 29007                                  anum_test:
 29008 0000427E AC                      	lodsb
 29009                                  
 29010                                  	; 28/03/2023
 29011                                  	; MSDOS 6.0
 29012                                  	; -----------------------------------
 29013                                  	; Mod to avoid upper-case conversion.
 29014                                  	; -----------------------------------
 29015                                  	; MSDOS 3.3
 29016                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29017                                  	;jnz	short cpcont3		; 3/3/KK
 29018                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29019                                  cpcont3:
 29020                                  	; -----------------------------------
 29021                                  
 29022 0000427F E862E3                  	call	DELIM
 29023 00004282 7435                    	jz	short x_done
 29024 00004284 3C0D                    	cmp	al,0Dh
 29025 00004286 7431                    	je	short x_done
 29026 00004288 3A06[A98A]              	cmp	al,[SWITCHAR]
 29027 0000428C 742B                    	je	short x_done
 29028 0000428E 38D8                    	cmp	al,bl
 29029 00004290 7427                    	je	short x_done
 29030 00004292 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 29031                                  	; 28/03/2023
 29032                                  	; MSDOS 3.3
 29033                                  	;jnz	short ANUM_CHARJ 
 29034                                  	; MSDOS 6.0
 29035 00004294 7403                    	je	short FOO15
 29036 00004296 E95FFF                  	jmp	anum_char
 29037                                  
 29038                                  ; Modification made for parseline.
 29039                                  ; Why would it be necessary to change colons to spaces? In this
 29040                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29041                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29042                                  
 29043                                  FOO15:
 29044 00004299 803E[158C]02            	cmp	byte [cpyflag],2
 29045 0000429E 7505                    	jnz	short cpcont4
 29046 000042A0 E87100                  	call	move_char
 29047 000042A3 EBD9                    	jmp	short anum_test
 29048                                  cpcont4:
 29049 000042A5 46                      	inc	si			; Skip the ':'
 29050 000042A6 EB11                    	jmp	short x_done
 29051                                  
 29052                                  	; 28/03/2023
 29053                                  ;ANUM_CHARJ:
 29054                                  	;jmp	anum_char
 29055                                  
 29056                                  BADPERR2:
 29057 000042A8 BA[0D7F]                	mov	dx,BADCPMES_PTR
 29058 000042AB E9A2E6                  	jmp	cerror
 29059                                  
 29060                                  BADPERR:
 29061                                  	; 28/03/2023
 29062                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29063                                  BADCDERR:
 29064                                  	; MSDOS 6.0
 29065 000042AE BA[3780]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29066 000042B1 E99CE6                  	jmp	cerror			;AC022;  message
 29067                                  	
 29068                                  cperror:
 29069 000042B4 4E                      	dec	si			; adjust the pointer
 29070 000042B5 5F                      	pop	di			; retrieve token buffer address
 29071 000042B6 9D                      	popf				; restore flags
 29072 000042B7 F9                      	stc				; set the carry bit
 29073 000042B8 C3                      	retn
 29074                                  
 29075                                  x_done:
 29076 000042B9 4E                      	dec	si			; adjust for next round
 29077                                  
 29078                                  ; Mod to recognize right and left parens as integral tokens.
 29079                                  ;x_done2:
 29080 000042BA EB51                    	jmp	short out_token
 29081                                  
 29082                                  a_switch:
 29083 000042BC 80CF01                  	or	bh,1			; Indicate switch
 29084                                  	;or	bp,FSWITCH ; 8000h
 29085                                  	; 28/03/2023
 29086 000042BF 81CD0080                	or	bp,8000h
 29087 000042C3 E816E3                  	call	scanoff
 29088 000042C6 46                      	inc	si
 29089                                  	; 28/03/2023
 29090                                  	; MSDOS 6.0
 29091 000042C7 E8F3E0                  	call	testkanj		;AN057; See if DBCS lead byte
 29092 000042CA 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29093 000042CC E84500                  	call	move_char		;AN057; DBCS - store first byte
 29094 000042CF AC                      	lodsb				;AN057; get second byte
 29095 000042D0 E84100                  	call	move_char		;AN057; store second byte
 29096                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29097 000042D3 81CD0040                	or	bp,4000h
 29098 000042D7 EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29099                                  a_switch_notkanj:			;AN057;
 29100 000042D9 3C0D                    	cmp	al,0Dh
 29101 000042DB 7509                    	jne	short Store_swt
 29102 000042DD B000                    	mov	al,0
 29103 000042DF AA                      	stosb
 29104                                  	;or	bp,FBADSWITCH ; 4000h
 29105 000042E0 81CD0040                	or	bp,4000h
 29106 000042E4 EBCE                    	jmp	short cperror		; Trailing switch character error
 29107                                  					;   BP = fSwitch but no switch
 29108                                  					;   bit is set (unknown switch)
 29109                                  Store_swt:
 29110 000042E6 E82B00                  	call	move_char		; store the character
 29111                                  
 29112                                  ; This upconv call must stay. It is used to identify copy-switches
 29113                                  ; on the command line, and won't store anything into the output buffer.
 29114                                  
 29115                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29116                                  	; 28/03/2023
 29117 000042E9 E8FBE0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29118                                  	
 29119 000042EC 06                      	push	es
 29120 000042ED 57                      	push	di
 29121 000042EE 51                      	push	cx
 29122 000042EF 0E                      	push	cs
 29123 000042F0 07                      	pop	es
 29124                                  	; 28/03/2023
 29125                                  	; MSDOS 3.3
 29126                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 29127                                  	; MSDOS 6.0
 29128 000042F1 BF[3184]                	mov	di,switch_list ; "?VBAPW"
 29129                                  	; MSDOS 3.3
 29130                                  	;mov	cx,SWCOUNT ; 5
 29131                                  	; MSDOS 6.0
 29132 000042F4 B90600                  	mov	cx,6  ; SWCOUNT = 6
 29133                                  	;or	bp,FBADSWITCH  ; 4000h
 29134 000042F7 81CD0040                	or	bp,4000h
 29135 000042FB F2AE                    	repne	scasb
 29136 000042FD 750B                    	jnz	short out_tokenp
 29137                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29138 000042FF 81E5FFBF                	and	bp,0BFFFh
 29139 00004303 B80100                  	mov	ax,1
 29140 00004306 D3E0                    	shl	ax,cl
 29141 00004308 09C5                    	or	bp,ax
 29142                                  out_tokenp:
 29143 0000430A 59                      	pop	cx
 29144 0000430B 5F                      	pop	di
 29145 0000430C 07                      	pop	es
 29146                                  out_token:
 29147 0000430D B000                    	mov	al,0			; null at the end
 29148 0000430F AA                      	stosb
 29149 00004310 5F                      	pop	di			; restore token buffer pointer
 29150 00004311 9D                      	popf
 29151 00004312 F8                      	clc				; clear carry flag
 29152 00004313 C3                      	retn
 29153                                  
 29154                                  ; =============== S U B	R O U T	I N E =======================================
 29155                                  
 29156                                  	; 28/03/2023
 29157                                  move_char:
 29158 00004314 AA                      	stosb				; store char in token buffer
 29159 00004315 41                      	inc	cx			; increment char count
 29160 00004316 FE06[598D]              	inc	byte [ELCNT]		; increment element count for * substi
 29161 0000431A C3                      	retn
 29162                                  
 29163                                  ;============================================================================
 29164                                  ; PARSE.ASM, MSDOS 6.0, 1991
 29165                                  ;============================================================================
 29166                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29167                                  
 29168                                  ; -----------------------------
 29169                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 29170                                  ; -----------------------------
 29171                                  
 29172                                  ;**** Equation field
 29173                                  ;-------- Character code definition
 29174                                  
 29175                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 29176                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 29177                                  $P_Period	   equ	"."             ;AN020;
 29178                                  $P_Slash	   equ	"/"             ;AN020;
 29179                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 29180                                  $P_Comma	   equ	","             ;AN000;
 29181                                  $P_Switch	   equ	"/"             ;AN000;
 29182                                  $P_Keyword	   equ	"="             ;AN000;
 29183                                  $P_Colon	   equ	":"             ;AN000;
 29184                                  $P_Plus 	   equ	"+"             ;AN000;
 29185                                  $P_Minus	   equ	"-"             ;AN000;
 29186                                  $P_Rparen	   equ	")"             ;AN000;
 29187                                  $P_Lparen	   equ	"("             ;AN000;
 29188                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 29189                                  $P_DQuote	   equ	'"'             ;AN000;
 29190                                  $P_NULL 	   equ	0		;AN000;
 29191                                  $P_TAB		   equ	9		;AN000;
 29192                                  $P_CR		   equ	0Dh		;AN000;
 29193                                  $P_LF		   equ	0Ah		;AN000;
 29194                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 29195                                  
 29196                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 29197                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 29198                                  
 29199                                  $P_error_filespec  equ  1
 29200                                  
 29201                                  ;----------------------------------------------------------------------------
 29202                                  ; PARMS LABEL	BYTE
 29203                                  ;	DW	PARMSX
 29204                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 29205                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29206                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 29207                                  ;				; TYPICAL ARE ";", "="
 29208                                  ;				; "," & WHITESPACE ALWAYS
 29209                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29210                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 29211                                  ;----------------------------------------------------------------------------
 29212                                  
 29213                                  struc $P_PARMS_BLK			;AN000;
 29214 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 29215 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 29216 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 29217                                  endstruc 				;AN000;
 29218                                  
 29219                                  $P_Len_PARMS	   equ	4		;AN000;
 29220                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 29221                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 29222                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 29223                                  
 29224                                  ;----------------------------------------------------------------------------
 29225                                  ; PARMSX LABEL	BYTE
 29226                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 29227                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 29228                                  ;	:				; REPEATS maxp-1 TIMES
 29229                                  ;	DB	maxs			; # OF SWITCHES
 29230                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 29231                                  ;	:				; REPEATS maxs-1 TIMES
 29232                                  ;	DB	maxk			; # OF KEYWORD
 29233                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 29234                                  ;	:				; REPEATS maxk-1 TIMES
 29235                                  ;----------------------------------------------------------------------------
 29236                                  
 29237                                  struc $P_PARMSX_BLK			;AN000;
 29238 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 29239 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 29240 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 29241                                  endstruc				;AN000;
 29242                                  
 29243                                  ; 31/03/2023
 29244                                  ;----------------------------------------------------------------------------
 29245                                  ; << Control field definition >>
 29246                                  ;
 29247                                  ;CONTROL   LABEL   BYTE
 29248                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 29249                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 29250                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 29251                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 29252                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 29253                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 29254                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 29255                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 29256                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 29257                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 29258                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 29259                                  ;				; 0002H=REPEATS ALLOWED
 29260                                  ;				; 0001H=OPTIONAL
 29261                                  ;	   DW FUNCTION_FLAGS
 29262                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 29263                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 29264                                  ;				; 0010H=REMOVE ":" AT END
 29265                                  ; (tm10)			; 0020H=colon is not necessary for switch
 29266                                  ;
 29267                                  ;	   DW RESULT		; RESULT BUFFER
 29268                                  ;	   DW VALUES		; VALUE LISTS
 29269                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 29270                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 29271                                  ;	   :
 29272                                  ;
 29273                                  ;Note:
 29274                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 29275                                  ;      DATE bit simalteniously.
 29276                                  ;
 29277                                  ;      The parser examins each bit along with the following priority.
 29278                                  ;
 29279                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 29280                                  ;      FILE SPEC -> SIMPLE STRING.
 29281                                  ;
 29282                                  ;
 29283                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 29284                                  ;      in the result buffer is capitalized.
 29285                                  ;
 29286                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 29287                                  ;
 29288                                  ;
 29289                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 29290                                  ;      switch, for example, '/A', then STRING points to;
 29291                                  ;
 29292                                  ;		DB    1 	; number of following synonyms
 29293                                  ;		DB   '/A',0
 29294                                  ;
 29295                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 29296                                  ;
 29297                                  ;		DB    1 	; number of following synonyms
 29298                                  ;		DB   'CODEPAGE=',0
 29299                                  ;
 29300                                  ;
 29301                                  ;    - "..." must consist of upper case characters only because the parser
 29302                                  ;      performs pattern matching after converting input to upper case (by
 29303                                  ;      using the current country upper case table)
 29304                                  ;
 29305                                  ;
 29306                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 29307                                  ;      example /A and /B, the format will be;
 29308                                  ;
 29309                                  ;		DB    2 	; number of following synonyms
 29310                                  ;		DB    '/A',0
 29311                                  ;		DB    '/B',0
 29312                                  ;----------------------------------------------------------------------------
 29313                                  
 29314                                  ;**** Match_Flags
 29315                                  
 29316                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 29317                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 29318                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 29319                                  $P_Date_S	   equ	1000h		;AN000; Date string
 29320                                  $P_Time_S	   equ	0800h		;AN000; Time string
 29321                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 29322                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 29323                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 29324                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 29325                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 29326                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 29327                                  $P_Optional	   equ	0001h		;AN000; Optional
 29328                                  
 29329                                  ;**** Function flags
 29330                                  
 29331                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 29332                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 29333                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 29334                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 29335                                  
 29336                                  ;-------------------------------- Control block structure
 29337                                  struc $P_CONTROL_BLK
 29338 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 29339 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 29340 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 29341 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 29342 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 29343 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29344                                  endstruc
 29345                                  
 29346                                  ; 31/03/2023
 29347                                  ;----------------------------------------------------------------------------
 29348                                  ;
 29349                                  ;VALUES LABEL	BYTE
 29350                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29351                                  ;	+-
 29352                                  ;	| DB	nrng		; NUMBER OF RANGES
 29353                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29354                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29355                                  ;	|	:
 29356                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29357                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29358                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29359                                  ;	|	:
 29360                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29361                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29362                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29363                                  ;	+-	:
 29364                                  ;
 29365                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29366                                  ;
 29367                                  ;Note:
 29368                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29369                                  ;      when no choice lists are provided.
 29370                                  ;
 29371                                  ;    - STRING must consist of upper case characters only because the parser
 29372                                  ;      performs pattern matching after converting input to upper case (by
 29373                                  ;      using the current country upper case table)
 29374                                  ;----------------------------------------------------------------------------
 29375                                  
 29376                                  $P_nval_None	equ 0		;AN000; no value list ID
 29377                                  $P_nval_Range	equ 1		;AN000; range list ID
 29378                                  $P_nval_Value	equ 2		;AN000; value list ID
 29379                                  $P_nval_String	equ 3		;AN000; string list ID
 29380                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29381                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29382                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29383                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29384                                  
 29385                                  struc $P_VAL_LIST
 29386 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29387 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29388 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29389 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29390 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29391                                  endstruc
 29392                                  
 29393                                  ; 31/03/2023
 29394                                  ;----------------------------------------------------------------------------
 29395                                  ;
 29396                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29397                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29398                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29399                                  ;					;	3=STRING, 4=COMPLEX,
 29400                                  ;					;	5=FILESPEC, 6=DRIVE
 29401                                  ;					;	7=DATE, 8=TIME
 29402                                  ;					;	9=QUOTED STRING
 29403                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29404                                  ;
 29405                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29406                                  ;
 29407                                  ;       +-
 29408                                  ;       | DD	n			; VALUE IF NUMBER
 29409                                  ;       | or
 29410                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29411                                  ;       |				; (ES presents Segment address)
 29412                                  ;       | or
 29413                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29414                                  ;       | or
 29415                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29416                                  ;       | or
 29417                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29418                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29419                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29420                                  ;       | or
 29421                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29422                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29423                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29424                                  ;       |	DB HUNDREDTHS ;(0-99)
 29425                                  ;       +-
 29426                                  ;
 29427                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29428                                  ;      list.
 29429                                  ;
 29430                                  ;      YEAR: If the input value for the year is less than 100, parser
 29431                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 29432                                  ;	     the year value, he returns 1987.
 29433                                  ;----------------------------------------------------------------------------
 29434                                  
 29435                                  ;-------------------------------- Result block structure
 29436                                  struc $P_RESULT_BLK;
 29437 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 29438 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 29439 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 29440 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 29441                                  endstruc
 29442                                  
 29443                                  ;**** values for the type field in the result block
 29444                                  
 29445                                  $P_EOL		 equ 0		;AN000; End of line
 29446                                  $P_Number	 equ 1		;AN000; Number
 29447                                  $P_List_Idx	 equ 2		;AN000; List Index
 29448                                  $P_String	 equ 3		;AN000; String
 29449                                  $P_Complex	 equ 4		;AN000; Complex
 29450                                  $P_File_Spec	 equ 5		;AN000; File Spec
 29451                                  $P_Drive	 equ 6		;AN000; Drive
 29452                                  $P_Date_F	 equ 7		;AN000; Date
 29453                                  $P_Time_F	 equ 8		;AN000; Time
 29454                                  $P_Quoted_String equ 9		;AN000; Quoted String
 29455                                  
 29456                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 29457                                  
 29458                                  ;**** Return code
 29459                                  ;
 29460                                  ; following return code will be returned in the AX register.
 29461                                  
 29462                                  $P_No_Error	 equ 0		;AN000; No error
 29463                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 29464                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 29465                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 29466                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 29467                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29468                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29469                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29470                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29471                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29472                                  
 29473                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29474                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29475                                  $P_Neg		 equ 02h	;AN000; Negative value
 29476                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29477                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29478                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29479                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29480                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29481                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29482                                  
 29483                                  ;-------- Masks
 29484                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29485                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29486                                  
 29487                                  ;-------------
 29488                                  
 29489                                  struc $P_DOS_TBL
 29490 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29491 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29492 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29493                                  endstruc
 29494                                  
 29495                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29496                                  				;AN000; following parameters are set
 29497                                  				;AN000; to get casemap table.
 29498                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29499                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29500                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29501                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29502                                  				; By this call following information
 29503                                  				; is returned.
 29504                                  
 29505                                  ; 03/04/2023
 29506                                  ;-------------------------------- country dependent information
 29507                                  
 29508                                  $P_DOS_Get_CDI	equ 3800h
 29509                                  
 29510                                  struc $P_CDI
 29511 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29512 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29513 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29514 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29515 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29516 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29517 0000000E ??                      		resb 1		;AN000;
 29518 0000000F ??                      		resb 1		;AN000;
 29519 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29520 00000011 ????????                		resw 2		;AN000;
 29521 00000015 ????                    		resb 2		;AN000;
 29522 00000017 <res Ah>                		resw 5		;AN000;
 29523                                  endstruc
 29524                                  
 29525                                  $P_Date_MDY	equ 0		;AN000;
 29526                                  $P_Date_DMY	equ 1		;AN000;
 29527                                  $P_Date_YMD	equ 2		;AN000;
 29528                                  
 29529                                  ; ----------------------------
 29530                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29531                                  ; ----------------------------
 29532                                  
 29533                                  ;***********************************************************************
 29534                                  ; SysParse;
 29535                                  ;
 29536                                  ;  Function : Parser Entry
 29537                                  ;
 29538                                  ;  Input: DS:SI -> command line
 29539                                  ;	  ES:DI -> parameter block
 29540                                  ;	  psdata_seg -> psdata.inc
 29541                                  ;	  CX = operand ordinal
 29542                                  ;
 29543                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29544                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29545                                  ;		 is in DS.
 29546                                  ;
 29547                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29548                                  ;		    invalid value list. But this parser does NOT implement
 29549                                  ;		    this feature. Therefore CY always zero.
 29550                                  ;
 29551                                  ;	   CY = 0   AX = return code
 29552                                  ;		    BL = terminated delimiter code
 29553                                  ;		    CX = new operand ordinal
 29554                                  ;		    SI = set past scaned operand
 29555                                  ;		    DX = selected result buffer
 29556                                  ;
 29557                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29558                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29559                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29560                                  ;
 29561                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29562                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29563                                  ;
 29564                                  ;-------- Modification History -----------------------------------------
 29565                                  ;
 29566                                  ;  4/04/87 : Created by K. K,
 29567                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29568                                  ;	   : JMP SHORT assemble error (tm02)
 29569                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29570                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29571                                  ;	     DateSW equ 1)	      (tm04)
 29572                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29573                                  ;				      (tm05) in PSDATA.INC
 29574                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29575                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29576                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29577                                  ;	     value-list block	      (tm07)
 29578                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29579                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29580                                  ;	     (tm08)
 29581                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29582                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29583                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29584                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29585                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29586                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29587                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29588                                  ;					  (tm12)
 29589                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29590                                  ;					  (tm13)
 29591                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29592                                  ;					  (tm14)
 29593                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29594                                  ;					  (tm15)
 29595                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29596                                  ;
 29597                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29598                                  ;
 29599                                  ;  7/28/87 : Kerry S (;AN018;)
 29600                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29601                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29602                                  ;	     affected: $P_Chk_SW_Control.
 29603                                  ;
 29604                                  ;  7/29/87 : Kerry S (;AN019;)
 29605                                  ;	     Now allow the optional bit in match flags for switches.  This
 29606                                  ;	     allows the switch to be encountered with a value or without a
 29607                                  ;	     value and no error is returned.
 29608                                  ;
 29609                                  ;
 29610                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29611                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29612                                  ;	     within a date response, instead of checking just for the one
 29613                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29614                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29615                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29616                                  ;
 29617                                  ;  9/1/87  : Kerry S (;AN021)
 29618                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29619                                  ;	     the command line with the string in the control block the
 29620                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29621                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29622                                  ;	     string on the command line than in the synonym list in the control
 29623                                  ;	     block.  I put in a test for a null in the control block so the
 29624                                  ;	     string in the control block must be the same length as the string
 29625                                  ;	     preceeding the colon or equal on the command line.
 29626                                  ;
 29627                                  ;  8/28/87 : Kerry S (;AN022;)
 29628                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29629                                  ;	     problems for people who included it themselves in a segment other
 29630                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29631                                  ;	     segment.
 29632                                  ;
 29633                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29634                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29635                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29636                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29637                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29638                                  ;	     BL be used if TIME is being parsed.
 29639                                  ;
 29640                                  ;  9/24/87 : Ed K
 29641                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29642                                  ;	     invocations with their normally expanded code; made comments
 29643                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29644                                  ;
 29645                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29646                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29647                                  ;	     pointed to by non-existant CONTROL.
 29648                                  ;
 29649                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29650                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29651                                  ;	     support to frame quoted text string with single quote.
 29652                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29653                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29654                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29655                                  ;
 29656                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29657                                  ;	     quote chars within a quoted string is supposed to be reported as
 29658                                  ;	     one quote character, but is reported as two quotes.  This changed
 29659                                  ;	     two instructions in PROC $P_Quoted_Str.
 29660                                  ;
 29661                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29662                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29663                                  ;
 29664                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29665                                  ;
 29666                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29667                                  ;	     psdata buffer should have psdata_seg.
 29668                                  ;
 29669                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29670                                  ;	     positional missing.
 29671                                  ;
 29672                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29673                                  ;	     as a line delimiter, should use carriage return.
 29674                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29675                                  ;
 29676                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29677                                  ;
 29678                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29679                                  ;	     endless loop since SI is returned still pointing to start
 29680                                  ;	     of that parm.
 29681                                  ;
 29682                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29683                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29684                                  ;	     when tried to fix it on previous version, changed similar
 29685                                  ;	     but wrong place.
 29686                                  ;
 29687                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29688                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29689                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29690                                  ;
 29691                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29692                                  ;	     in a filespec, then flag an error.
 29693                                  ;
 29694                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29695                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29696                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29697                                  ;  -->	     local parser data. Why were some references to local data changed
 29698                                  ;	     to do this before, but not all ?????
 29699                                  ;
 29700                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29701                                  ;
 29702                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29703                                  ;
 29704                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29705                                  ;
 29706                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29707                                  ;
 29708                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29709                                  ;	     separator in TIME before hundredths field.
 29710                                  ;
 29711                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29712                                  ;			strings as keywords.
 29713                                  ;
 29714                                  ;***********************************************************************
 29715                                  
 29716                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29717                                  cmd_parse:
 29718                                  	;call	sysparse
 29719                                  	;retn
 29720                                  
 29721                                  ; -----------------------------------
 29722                                  
 29723                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29724                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29725                                  
 29726                                  sysparse:
 29727 0000431B 2EC706[FD85]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29728 00004322 2E890E[8786]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29729 00004327 2E8926[8986]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29730 0000432C 2E8936[8B86]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29731                                  $P_Redo_Time:				;AN039; try to parse time again
 29732 00004331 FC                      	cld				;AN000; confirm forward direction
 29733 00004332 2E890E[F085]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29734                                  	;mov	word [cs:$P_RC],$P_No_Error
 29735 00004337 2EC706[F285]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29736 0000433E 2EC706[0586]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29737                                  					;AC034; initalize synonym pointer
 29738 00004345 2EC706[F685]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29739                                  
 29740                                  ;M029 -- Begin changes
 29741                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29742                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29743                                  ;corrupts this table but does not corrupt the checksum region will leave
 29744                                  ;command.com parsing in an inconsistent state.
 29745                                  ; NB: The special characters string has been hardcoded here. If any change
 29746                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29747                                  
 29748 0000434C 2EC706[C286]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29749 00004353 2EC706[C486]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29750 0000435A 2EC706[C686]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29751 00004361 2EC706[C886]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29752                                  
 29753                                  ;M029 -- End of changes
 29754                                  
 29755 00004368 E82209                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29756 0000436B 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29757                                  
 29758                                  ;--------------------------- End of Line
 29759                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29760 0000436D B8FFFF                  	mov	ax,0FFFFh
 29761 00004370 53                      	push	bx			;AN000;
 29762                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29763 00004371 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29764                                  	
 29765                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29766 00004374 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29767 00004377 7304                    	jae	short $P_Fin		;AN000; positional found.
 29768                                  
 29769                                  	;mov	ax,2
 29770 00004379 B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29771                                  	; 27/04/2023
 29772 0000437C F8                      	clc
 29773                                  $P_Fin: 				;AN000;
 29774 0000437D 5B                      	pop	bx			;AN000;
 29775                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29776                                  	; 27/04/2023
 29777                                  	; cf = 0
 29778                                  	;clc
 29779 0000437E C3                      	retn
 29780                                  
 29781                                  ;---------------------------
 29782                                  $P_Start:				;AN000;
 29783 0000437F 2E8936[FF85]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034; save ptr to command line for later use by complex,
 29784 00004384 53                      	push	bx			;AN000; quoted string or file spec.
 29785 00004385 57                      	push	di			;AN000;
 29786 00004386 55                      	push	bp			;AN000;
 29787 00004387 8D1E[0786]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29788 0000438B 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29789                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29790 00004391 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29791                                  $P_Pack_Loop:				;AN000;
 29792 00004393 AC                      	lodsb				;AN000; Pick a operand from buffer
 29793 00004394 E8A909                  	call	$P_Chk_Switch		;AN000; Check switch character
 29794 00004397 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29795                                  
 29796 00004399 E81309                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29797 0000439C 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29798                                  
 29799 0000439E E84009                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29800 000043A1 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29801                                  
 29802 000043A3 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29803                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29804 000043A9 7505                    	jnz	short $P_Pack_End_backup_si
 29805                                  					;AN000; (tm08)
 29806 000043AB E8DF08                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29807 000043AE EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29808                                  
 29809                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29810 000043B0 2EF606[FE85]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29811                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29812 000043B6 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29813                                  
 29814 000043B8 4E                      	dec	si			;AN000; (tm08)
 29815 000043B9 EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29816                                  $P_PL01:				;AN000;
 29817 000043BB 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29818                                  	;cmp	al,'='
 29819 000043BE 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29820 000043C0 7506                    	jne	short $P_PL00 		;AN000; then
 29821                                  
 29822 000043C2 2E800E[FE85]01          	or	byte [cs:$P_Flags2],$P_equ
 29823                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29824                                  $P_PL00:				;AN000;
 29825 000043C8 43                      	inc	bx			;AN000; ready to see next byte
 29826 000043C9 E89F09                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29827 000043CC 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29828                                  
 29829 000043CE AC                      	lodsb				;AN000; if yes, store
 29830 000043CF 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29831 000043D2 43                      	inc	bx			;AN000; update pointer
 29832 000043D3 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29833                                  
 29834                                  $P_Pack_End_BY_EOL:			;AN000;
 29835 000043D5 4E                      	dec	si			;AN000; backup si pointer
 29836                                  $P_Pack_End:				;AN000;
 29837 000043D6 2E8936[F485]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29838                                  	;mov	byte [cs:bx],0
 29839 000043DB 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29840 000043DF 2E891E[0386]            	mov	[cs:$P_Save_EOB],bx
 29841                                  					;AC034; 3/17/87 keep the address for later use of complex
 29842                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29843 000043E4 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29844 000043E7 8D36[0786]              	lea	si,$P_STRING_BUF	;AC034;
 29845                                  	;cmp	byte [cs:si],'/'
 29846 000043EB 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29847 000043EF 7442                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29848                                  
 29849 000043F1 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29850 000043F5 7408                    	je	short $P_Positional_Manager
 29851                                  					;M005;if so, process as one!
 29852 000043F7 2EF606[FE85]01          	test	byte [cs:$P_Flags2],$P_equ
 29853                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29854 000043FD 7556                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29855                                  
 29856                                  $P_Positional_Manager:			;AN000; else process as positional
 29857                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29858 000043FF 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29859 00004403 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29860 00004405 2E3906[F085]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29861 0000440A 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29862                                  
 29863 0000440C 2EA1[F085]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29864 00004410 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29865 00004412 43                      	inc	bx			;AC035; add '2' to
 29866 00004413 43                      	inc	bx			;AC035;  BX reg
 29867                                  					;AN000; now bx points to 1st CONTROL
 29868 00004414 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29869 00004416 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29870 00004419 E88000                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29871 0000441C EB61                    	jmp	short $P_Return_to_Caller
 29872                                  					;AN000; and return to the caller
 29873                                  $P_Too_Many_Error:			;AN000;
 29874                                  	;mov	word [cs:$P_RC],1
 29875 0000441E 2EC706[F285]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29876                                  					;AC034; set exit code
 29877 00004425 EB58                    	jmp	short $P_Return_to_Caller
 29878                                  					;AN000; and return to the caller
 29879                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 29880                                  %if 0
 29881                                  $P_SW_Manager:				;AN000;
 29882                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29883                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29884                                  	xor	ah,ah			;AN000; ax = maxp
 29885                                  	inc	ax			;AN000;
 29886                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 29887                                  	add	bx,ax			;AN000; now bx points to maxs
 29888                                  	mov	cl,[es:bx]		;AN000;
 29889                                  	xor	ch,ch			;AN000; cx = maxs
 29890                                  	or	cx,cx			;AN000; at least one switch ?
 29891                                  	jz	short $P_SW_Not_Found 	;AN000;
 29892                                  	inc	bx			;AN000; now bx points to 1st CONTROL address
 29893                                  %else
 29894                                  $P_get_max_ptr:
 29895                                  	;mov	al,[es:bx+1]		; get maxp
 29896 00004427 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29897 0000442B 30E4                    	xor	ah,ah			; ax = maxp
 29898 0000442D 40                      	inc	ax
 29899 0000442E D1E0                    	shl	ax,1			; ax = (ax+1)*2
 29900 00004430 01C3                    	add	bx,ax			; now bx points to maxs
 29901 00004432 C3                      	retn
 29902                                  
 29903                                  $P_SW_Manager:
 29904 00004433 E8F1FF                  	call	$P_get_max_ptr
 29905 00004436 268A0F                  	mov	cl,[es:bx]
 29906 00004439 30ED                    	xor	ch,ch			; cx = maxs
 29907                                  					; at least one switch ?
 29908 0000443B E30F                    	jcxz	$P_SW_Not_Found 	; no
 29909 0000443D 43                      	inc	bx			; now bx points to 1st CONTROL address
 29910                                  %endif
 29911                                  
 29912                                  $P_SW_Mgr_Loop: 			;AN000;
 29913 0000443E 53                      	push	bx			;AN000;
 29914 0000443F 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29915 00004442 E8B700                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29916 00004445 5B                      	pop	bx			;AN000;
 29917 00004446 7337                    	jnc	short $P_Return_to_Caller
 29918                                  					;AN000; if the CONTROL is for the switch, exit
 29919 00004448 43                      	inc	bx			;AC035; add '2' to
 29920 00004449 43                      	inc	bx			;AC035;  BX reg
 29921                                  					;AN000; else bx points to the next CONTROL
 29922 0000444A E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29923                                  $P_SW_Not_Found:			;AN000;
 29924                                  	;mov	word [cs:$P_RC],3
 29925 0000444C 2EC706[F285]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29926                                  					;AC034; here no CONTROL for the switch has
 29927 00004453 EB2A                    	jmp	short $P_Return_to_Caller0
 29928                                  					;AN000; not been found, means error.
 29929                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 29930                                  %if 0
 29931                                  $P_Key_Manager:				;AN000;
 29932                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29933                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29934                                  	xor	ah,ah			;AN000; ax = maxp
 29935                                  	inc	ax			;AN000;
 29936                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 29937                                  	add	bx,ax			;AN000; now bx points to maxs
 29938                                  	mov	al,[es:bx]		;AN000;
 29939                                  	xor	ah,ah			;AN000; ax = maxs
 29940                                  	shl	ax,1			;AN000;
 29941                                  	inc	ax			;AN000; ax = ax*2+1
 29942                                  	add	bx,ax			;AN000; now bx points to maxk
 29943                                  	mov	cl,[es:bx]		;AN000;
 29944                                  	xor	ch,ch			;AN000; cx = maxk
 29945                                  	or	cx,cx			;AN000; at least one keyword ?
 29946                                  	jz	short $P_Key_Not_Found	;AN000;
 29947                                  	inc	bx			;AN000; now bx points to 1st CONTROL
 29948                                  %else
 29949                                  $P_Key_Manager:
 29950 00004455 E8CFFF                  	call	$P_get_max_ptr
 29951 00004458 268A07                  	mov	al,[es:bx]
 29952 0000445B 30E4                    	xor	ah,ah			; ax = maxs
 29953 0000445D D1E0                    	shl	ax,1
 29954 0000445F 40                      	inc	ax			; ax = ax*2+1
 29955 00004460 01C3                    	add	bx,ax			; now bx points to maxk
 29956 00004462 268A0F                  	mov	cl,[es:bx]
 29957 00004465 30ED                    	xor	ch,ch			; cx = maxk
 29958                                  					; at least one keyword ?
 29959 00004467 E30F                    	jcxz	$P_Key_Not_Found
 29960 00004469 43                      	inc	bx			; now bx points to 1st CONTROL
 29961                                  %endif
 29962                                  
 29963                                  $P_Key_Mgr_Loop:			;AN000;
 29964 0000446A 53                      	push	bx			;AN000;
 29965 0000446B 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29966 0000446E E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29967 00004471 5B                      	pop	bx			;AN000;
 29968 00004472 730B                    	jnc	short $P_Return_to_Caller
 29969                                  					;AN000; if the CONTROL is for the keyword, exit
 29970 00004474 43                      	inc	bx			;AC035; add '2' to
 29971 00004475 43                      	inc	bx			;AC035;  BX reg
 29972                                  					;AN000; else bx points to the next CONTROL
 29973 00004476 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29974                                  $P_Key_Not_Found:			;AN000;
 29975                                  	;mov	word [cs:$P_RC],4
 29976 00004478 2EC706[F285]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29977                                  					;AC034; here no CONTROL for the keyword has
 29978                                  $P_Return_to_Caller0:
 29979                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29980 0000447F 5D                      	pop	bp			;AN000;
 29981 00004480 5F                      	pop	di			;AN000;
 29982 00004481 5B                      	pop	bx			;AN000;
 29983 00004482 2E8B0E[F085]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29984 00004487 2EA1[F285]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29985 0000448B 2E8B36[F485]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29986 00004490 2E8B16[F685]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29987 00004495 2E8A1E[F885]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29988                                  $P_Single_Exit: 			;AN000;
 29989 0000449A F8                      	clc				;AN000;
 29990 0000449B C3                      	retn				;AN000;
 29991                                  
 29992                                  ;***********************************************************************
 29993                                  ; $P_Chk_Pos_Control
 29994                                  ;
 29995                                  ; Function: Parse CONTROL block for a positional
 29996                                  ;
 29997                                  ; Input:     ES:BX -> CONTROL block
 29998                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29999                                  ;
 30000                                  ; Output:    None
 30001                                  ;
 30002                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 30003                                  ;
 30004                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 30005                                  ;***********************************************************************
 30006                                  
 30007                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30008                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 30009                                  
 30010                                  $P_Chk_Pos_Control:
 30011 0000449C 50                      	push	ax			;AN000;
 30012                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30013 0000449D 268B07                  	mov	ax,[es:bx]		;AN000;
 30014                                  	;test	ax,2
 30015 000044A0 A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 30016 000044A3 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 30017                                  
 30018 000044A5 2EFF06[F085]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 30019                                  $P_CPC00:				;AN000;
 30020                                  	;cmp	byte [cs:si],0
 30021 000044AA 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 30022 000044AE 7516                    	jne	short $P_CPC01		;AN000;
 30023                                  
 30024                                  	;test	ax,1
 30025 000044B0 A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 30026 000044B3 7509                    	jnz	short $P_CPC02		;AN000;
 30027                                  
 30028 000044B5 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30029                                  					;AC034; no, then error	 3/17/87
 30030 000044BC EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 30031                                  $P_CPC02:				;AN000;
 30032                                  	; 27/04/2023
 30033                                  	;push	ax ; *			;AN000;
 30034                                  	;
 30035                                  	;;mov	al,3
 30036                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 30037                                  	;;mov	ah,0FFh
 30038                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 30039                                  	; 31/03/2023
 30040 000044BE B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30041 000044C1 E89500                  	call	$P_Fill_Result		;AN000;
 30042                                  	; 27/04/2023
 30043                                  	;pop	ax ; *			;AN000;
 30044 000044C4 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 30045                                  $P_CPC01:				;AN000;
 30046 000044C6 E81101                  	call	$P_Check_Match_Flags	;AN000;
 30047                                  $P_CPC_Exit:				;AN000;
 30048 000044C9 58                      	pop	ax			;AN000;
 30049 000044CA C3                      	retn				;AN000;
 30050                                  
 30051                                  ;***********************************************************************
 30052                                  ; $P_Chk_Key_Control
 30053                                  ;
 30054                                  ; Function: Parse CONTROL block for a keyword
 30055                                  ;
 30056                                  ; Input:     ES:BX -> CONTROL block
 30057                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30058                                  ;
 30059                                  ; Output:    CY = 1 : not match
 30060                                  ;
 30061                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30062                                  ;
 30063                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30064                                  ;***********************************************************************
 30065                                  
 30066                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30067                                  $P_Chk_Key_Control:			;AN000;
 30068 000044CB F9                      	stc				;AN000;this logic works when the KeySW
 30069 000044CC C3                      	retn				;AN000;is reset.
 30070                                  
 30071                                  ;***********************************************************************
 30072                                  ; $P_Search_KEYorSW:
 30073                                  ;
 30074                                  ; Function: Seach specified keyword or switch from CONTROL
 30075                                  ;
 30076                                  ; Input:     ES:BX -> CONTROL block
 30077                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30078                                  ;
 30079                                  ; Output:    CY = 1 : not match
 30080                                  ;
 30081                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30082                                  ;***********************************************************************
 30083                                  
 30084                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30085                                  	; 14/06/2023
 30086                                  $P_Search_KEYorSW:
 30087 000044CD 55                      	push	bp			;AN000;
 30088 000044CE 51                      	push	cx			;AN000;
 30089 000044CF 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30090                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30091                                  	; 14/06/2023
 30092                                  	;xor	ch,ch			;AN000; and set it to cx
 30093                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30094 000044D3 08C9                    	or	cl,cl
 30095 000044D5 740E                    	jz	short $P_KEYorSW_Not_Found
 30096                                  					;AN000; then indicate not found by CY
 30097 000044D7 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30098                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30099                                  $P_KEYorSW_Loop:			;AN000;
 30100 000044DB E8E703                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30101 000044DE 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30102 000044E0 E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30103 000044E3 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30104                                  $P_KEYorSW_Not_Found:			;AN000;
 30105 000044E5 F9                      	stc				;AN000; indicate not found in synonym list
 30106 000044E6 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30107                                  $P_KEYorSW_Found:			;AN000;
 30108 000044E8 2E892E[0586]            	mov	[cs:$P_Found_SYNONYM],bp
 30109                                  					;AC034; set synonym pointer
 30110                                  	; 27/04/2023
 30111                                  	; cf = 0
 30112                                  	;clc				;AN000; indicate found
 30113                                  $P_KEYorSW_Exit:			;AN000;
 30114 000044ED 59                      	pop	cx			;AN000;
 30115 000044EE 5D                      	pop	bp			;AN000;
 30116 000044EF C3                      	retn				;AN000;
 30117                                  
 30118                                  ;***********************************************************************
 30119                                  ; $P_MoveBP_NUL
 30120                                  ;***********************************************************************
 30121                                  
 30122                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30123                                  
 30124                                  $P_MoveBP_NUL:
 30125                                  $P_MBP_Loop:				;AN000;
 30126                                  	;cmp	byte [es:bp+0],0
 30127 000044F0 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30128 000044F5 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30129 000044F7 45                      	inc	bp			;AN000; until
 30130 000044F8 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30131                                  $P_MBP_Exit:				;AN000;
 30132 000044FA 45                      	inc	bp			;AN000; bp points to next to NULL
 30133 000044FB C3                      	retn				;AN000;
 30134                                  
 30135                                  ;***********************************************************************
 30136                                  ; $P_Chk_SW_Control
 30137                                  ;
 30138                                  ; Function: Parse CONTROL block for a switch
 30139                                  ;
 30140                                  ; Input:     ES:BX -> CONTROL block
 30141                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30142                                  ;
 30143                                  ; Output:    CY = 1 : not match
 30144                                  ;
 30145                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30146                                  ;
 30147                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30148                                  ;***********************************************************************
 30149                                  
 30150                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30151                                  
 30152                                  $P_Chk_SW_Control:
 30153 000044FC 2E800E[FE85]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 30154                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 30155 00004502 E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 30156 00004505 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 30157                                  
 30158 00004507 2E8026[FE85]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 30159                                  	;and	byte [cs:$P_Flags2],0EFh
 30160                                  					;AC034; reset the indicator previously set
 30161 0000450D 50                      	push	ax			;AN000;       /switch:
 30162 0000450E 2EA1[0186]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 30163 00004512 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 30164 00004514 2E0106[FF85]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 30165 00004519 58                      	pop	ax			;AN000;
 30166                                  
 30167 0000451A 2E8B36[0186]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 30168                                  	;cmp	byte [cs:si],0
 30169 0000451F 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 30170 00004523 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 30171                                  
 30172                                  	;cmp	byte [cs:si],':'
 30173 00004525 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 30174                                  					;AN000; if no, the switch terminated by colon ?
 30175 0000452A 7509                    	jne	short $P_Chk_if_data_required
 30176                                  					;AN000; if yes,
 30177                                  
 30178 0000452C 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30179                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 30180 00004533 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 30181                                  
 30182                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 30183                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 30184                                  	; 27/04/2023
 30185 00004535 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 30186 00004539 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 30187                                  
 30188                                  	;;test	word [es:bx],1 ; $P_Optional
 30189                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 30190 0000453B 26F60701                	test	byte [es:bx],$P_Optional
 30191                                  					;AN019; see if no value is valid
 30192 0000453F 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 30193                                  
 30194 00004541 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30195                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 30196 00004548 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 30197                                  
 30198                                  $P_CSW00:				;AN000;
 30199 0000454A E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 30200 0000454D F8                      	clc				;AN000; indicate match
 30201                                  	;jmp	short $P_Chk_SW_Single_Exit
 30202 0000454E C3                      	retn	; 31/03/2023		;AN000;
 30203                                  	; 31/03/2023
 30204                                  ;$P_Chk_SW_Err0: 			;AN000;
 30205                                  ;	stc				;AN000; not found in switch synonym list
 30206                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 30207                                  ;	retn	; 31/03/2023		;AN000;
 30208                                  	
 30209                                  $P_Chk_SW_Exit: 			;AN000;
 30210 0000454F 50                      	push	ax			;AN000;
 30211                                  	; 31/03/2023
 30212 00004550 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30213                                  	;;mov	al,3
 30214                                  	;;mov	ah,0FFh
 30215                                  	;mov	al,$P_String		;AN000; set
 30216                                  	;mov	ah,$P_No_Tag		;AN000;    result
 30217 00004553 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 30218 00004556 58                      	pop	ax			;AN000;
 30219 00004557 F8                      	clc				;AN000;
 30220                                  	; 31/03/2023
 30221                                  $P_Chk_SW_Err0:
 30222                                  $P_Chk_SW_Single_Exit:			;AN000;
 30223 00004558 C3                      	retn				;AN000;
 30224                                  
 30225                                  ;***********************************************************************
 30226                                  ; $P_Fill_Result
 30227                                  ;
 30228                                  ; Function: Fill the result buffer
 30229                                  ;
 30230                                  ; Input:    AH = Item tag
 30231                                  ;	    AL = type
 30232                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 30233                                  ;		  AL = 2: DX has index(offset) into value list
 30234                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 30235                                  ;		  AL = 7: DX has year, CL has month and CH has date
 30236                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 30237                                  ;			  amd CH has hundredths
 30238                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 30239                                  ;	    ES:BX -> CONTROL block
 30240                                  ;
 30241                                  ; Output:   None
 30242                                  ;
 30243                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 30244                                  ;
 30245                                  ; Vars: $P_DX(W)
 30246                                  ;***********************************************************************
 30247                                  
 30248                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30249                                  
 30250                                  $P_Fill_Result:
 30251 00004559 57                      	push	di			;AN000;
 30252 0000455A 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 30253                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 30254 0000455E 2E893E[F685]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 30255                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 30256                                  	;;mov	[es:di],al		;AN000; store type
 30257                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 30258                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 30259                                  	; 31/03/2023
 30260 00004563 268905                  	mov	[es:di],ax
 30261 00004566 50                      	push	ax			;AN000;
 30262 00004567 2EA1[0586]              	mov	ax,[cs:$P_Found_SYNONYM]
 30263                                  					;AC034; if yes,
 30264 0000456B 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 30265                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 30266 0000456F 58                      	pop	ax			;AN000;
 30267                                  $P_RLT04:				;AN000;
 30268                                  	;cmp	al,1
 30269 00004570 3C01                    	cmp	al,$P_Number		;AN000; if number
 30270 00004572 750A                    	jne	short $P_RLT00		;AN000;
 30271                                  $P_RLT02:				;AN000;
 30272 00004574 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30273                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 30274 00004578 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 30275                                  	;mov	[es:di+6],cx		;AN000;	number
 30276 0000457C EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 30277                                  $P_RLT00:				;AN000;
 30278                                  	;cmp	al,2
 30279 0000457E 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 30280 00004580 7506                    	jne	short $P_RLT01		;AN000;
 30281 00004582 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30282                                  	;mov	[es:di+4],dx		;AN000; then store list index
 30283 00004586 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 30284                                  $P_RLT01:				;AN000;
 30285                                  	;cmp	al,7
 30286 00004588 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 30287 0000458A 74E8                    	je	short $P_RLT02		;AN000;
 30288                                  	;cmp	al,8
 30289 0000458C 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 30290 0000458E 74E4                    	je	short $P_RLT02		;AN000;
 30291                                  	;cmp	al,6
 30292 00004590 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 30293 00004592 7506                    	jne	short $P_RLT03		;AN000;
 30294                                  
 30295 00004594 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 30296                                  	;mov	[es:di+4],dl		;AN000; store drive number
 30297 00004598 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 30298                                  
 30299                                  $P_RLT03:				;AN000;
 30300                                  	;cmp	al,4
 30301 0000459A 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 30302 0000459C 750F                    	jne	short $P_RLT05		;AN000;
 30303                                  
 30304 0000459E 2EA1[FF85]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 30305 000045A2 40                      	inc	ax			;AN000; skip left Parentheses
 30306 000045A3 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 30307                                  	;mov	[es:di+4],ax		;AN000; store offset
 30308 000045A7 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 30309                                  	;mov	[es:di+6],ds		;AN000; store segment
 30310 000045AB EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 30311                                  
 30312                                  $P_RLT05:				;AN000;
 30313                                  ;------------------------  AL = 3, 5, or 9
 30314 000045AD 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 30315                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 30316 000045B1 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 30317                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 30318                                  
 30319 000045B5 50                      	push	ax			;AN000;
 30320 000045B6 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 30321                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 30322 000045BB 7404                    	jz	short $P_RLT_CAP00	;AN000;
 30323                                  
 30324                                  	;mov	al,4
 30325 000045BD B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 30326 000045BF EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 30327                                  
 30328                                  $P_RLT_CAP00:				;AN000;
 30329 000045C1 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 30330                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 30331 000045C6 7405                    	jz	short $P_RLT_CAP01	;AN000;
 30332                                  
 30333                                  	;mov	al,2
 30334 000045C8 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 30335                                  $P_RLT_CAP02:				;AN000;
 30336 000045CA E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 30337                                  $P_RLT_CAP01:				;AN000;
 30338 000045CD 58                      	pop	ax			;AN000;
 30339 000045CE 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 30340                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 30341 000045D3 7403                    	jz	short $P_RLT_Exit	;AN000;
 30342                                  
 30343 000045D5 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 30344                                  $P_RLT_Exit:				;AN000;
 30345 000045D8 5F                      	pop	di			;AN000;
 30346 000045D9 C3                      	retn				;AN000;
 30347                                  
 30348                                  ;***********************************************************************
 30349                                  ; $P_Check_Match_Flags
 30350                                  ;
 30351                                  ; Function:  Check the mutch_flags and make the exit code and set the
 30352                                  ;	     result buffer
 30353                                  ;
 30354                                  ;	    Check for types in this order:
 30355                                  ;		Complex
 30356                                  ;		Date
 30357                                  ;		Time
 30358                                  ;		Drive
 30359                                  ;		Filespec
 30360                                  ;		Quoted String
 30361                                  ;		Simple String
 30362                                  ;
 30363                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30364                                  ;	     ES:BX -> CONTROL block
 30365                                  ;
 30366                                  ; Output:    None
 30367                                  ;
 30368                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 30369                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 30370                                  ;	     $P_Drive_Format
 30371                                  ;***********************************************************************
 30372                                  
 30373                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30374                                  
 30375                                  $P_Check_Match_Flags:
 30376 000045DA 2EC606[CB86]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 30377                                  					;AN033;AC034;; clear filespec error flag.
 30378 000045E0 50                      	push	ax			;AN000;
 30379                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30380 000045E1 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 30381 000045E4 09C0                    	or	ax,ax			;AC035; test ax for zero
 30382 000045E6 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 30383 000045E8 50                      	push	ax			;AN000; (tm12)
 30384 000045E9 53                      	push	bx			;AN000; (tm12)
 30385 000045EA 52                      	push	dx			;AN000; (tm12)
 30386 000045EB 57                      	push	di			;AN000; (tm12)
 30387 000045EC 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30388                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30389                                  	; 31/03/2023
 30390 000045F3 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30391                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30392                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30393 000045F6 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30394 000045F9 5F                      	pop	di			;AN000; (tm12)
 30395 000045FA 5A                      	pop	dx			;AN000; (tm12)
 30396 000045FB 5B                      	pop	bx			;AN000; (tm12)
 30397 000045FC 58                      	pop	ax			;AN000; (tm12)
 30398                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30399                                  	; 31/03/2023
 30400                                  $P_Bridge:	; 18/04/2023		;AN000;
 30401 000045FD E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30402                                  $P_Mat: 				;AN000; (tm12)
 30403                                  $P_Match01:				;AN000;
 30404                                  	;test	ax,1000h
 30405 00004600 A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30406 00004603 7412                    	jz	short $P_Match02	;AN000;
 30407 00004605 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30408                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30409 0000460C E85403                  	call	$P_Date_Format		;AN000; do process
 30410 0000460F 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30411                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30412                                  	; 18/04/2023
 30413 00004615 75E6                    	jne	short $P_Bridge		;AN000;
 30414                                  $P_Match02:				;AN000;
 30415                                  	;test	ax,800h
 30416 00004617 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30417 0000461A 7412                    	jz	short $P_Match03	;AN000;
 30418 0000461C 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30419                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30420 00004623 E85404                  	call	$P_Time_Format		;AN000; do process
 30421 00004626 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30422                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30423                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30424                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30425                                  	; 31/03/2023
 30426 0000462C 756E                    	jne	short $P_Match_Exit
 30427                                  ;$P_Bridge:				;AN000;
 30428                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30429                                  $P_Match03:				;AN000;
 30430                                  	;test	ax,8000h
 30431 0000462E A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30432 00004631 7412                    	jz	short $P_Match04	;AN000;
 30433 00004633 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30434                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30435 0000463A E82701                  	call	$P_Value		;AN000; do process
 30436 0000463D 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30437                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30438 00004643 7557                    	jne	short $P_Match_Exit	;AN000;
 30439                                  $P_Match04:				;AN000;
 30440                                  	;test	ax,4000h
 30441 00004645 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30442 00004648 7412                    	jz	short $P_Match05	;AN000;
 30443 0000464A 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30444                                  					;AC034; assume no error
 30445 00004651 E8EC00                  	call	$P_SValue		;AN000; do process
 30446 00004654 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30447                                  					;AC034; if error, examine the next type
 30448 0000465A 7540                    	jne	short $P_Match_Exit	;AN000;
 30449                                  $P_Match05:				;AN000;
 30450                                  	;test	ax,100h
 30451 0000465C A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30452 0000465F 7415                    	jz	short $P_Match06	;AN000;
 30453 00004661 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30454                                  					;AC034; assume no error
 30455 00004668 E85C05                  	call	$P_File_Format		;AN000; 1st, call file format
 30456 0000466B E8DD05                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30457 0000466E 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30458                                  					;AC034; if error, examinee the next type
 30459 00004674 7526                    	jne	short $P_Match_Exit	;AN000;
 30460                                  $P_Match06:				;AN000;
 30461                                  	;test	ax,200h
 30462 00004676 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 30463 00004679 7412                    	jz	short $P_Match07	;AN000;
 30464 0000467B 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30465                                  					;AC034; assume no error
 30466 00004682 E84205                  	call	$P_File_Format		;AN000; do process
 30467 00004685 2E833E[F285]09          	cmp	word [cs:$P_RC],$P_Syntax
 30468                                  					;AC034; if error, examine the next type
 30469 0000468B 750F                    	jne	short $P_Match_Exit	;AN000;
 30470                                  $P_Match07:				;AN000;
 30471                                  $P_Match08:				;AN000;
 30472                                  	;test	ax,2000h
 30473 0000468D A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 30474 00004690 740A                    	jz	short $P_Match09	;AN000;
 30475 00004692 2EC706[F285]0000        	mov	word [cs:$P_RC],$P_No_Error
 30476                                  					;AC034; assume no error
 30477 00004699 E8C501                  	call	$P_Simple_String	;AN000; do process
 30478                                  $P_Match09:				;AN000;
 30479                                  $P_Match_Exit:				;AN000;
 30480 0000469C 2E833E[CB86]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 30481                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 30482 000046A2 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30483 000046A4 2E833E[F285]00          	cmp	word [cs:$P_RC],$P_No_Error
 30484                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 30485 000046AA 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30486 000046AC 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 30487                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 30488                                  $P_Match2_Exit: 			;AN033;
 30489 000046B3 58                      	pop	ax			;AN000;
 30490 000046B4 C3                      	retn
 30491                                  
 30492                                  ;***********************************************************************
 30493                                  ; $P_Remove_Colon;
 30494                                  ;
 30495                                  ; Function: Remove colon at end
 30496                                  ;
 30497                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 30498                                  ;
 30499                                  ; Output:   None
 30500                                  ;
 30501                                  ; Use:	$P_Chk_DBCS
 30502                                  ;***********************************************************************
 30503                                  
 30504                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30505                                  
 30506                                  $P_Remove_Colon:
 30507 000046B5 50                      	push	ax			;AN000;
 30508 000046B6 56                      	push	si			;AN000;
 30509                                  $P_RCOL_Loop:				;AN000;
 30510 000046B7 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30511 000046BA 08C0                    	or	al,al			;AN000; end of string ?
 30512 000046BC 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30513                                  
 30514 000046BE 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30515 000046C0 750E                    	jne	short $P_RCOL00		;AN000;
 30516                                  
 30517                                  	;cmp	byte [cs:si+1],0
 30518 000046C2 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30519 000046C7 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30520                                  
 30521 000046C9 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30522                                  	; 31/03/2023
 30523                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30524                                  $P_RCOL_Exit:
 30525 000046CD 5E                      	pop	si
 30526 000046CE 58                      	pop	ax
 30527 000046CF C3                      	retn
 30528                                  
 30529                                  $P_RCOL00:				;AN000;
 30530 000046D0 E89806                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30531 000046D3 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30532                                  
 30533 000046D5 46                      	inc	si			;AN000; if yes, skip trailing byte
 30534                                  $P_RCOL01:				;AN000;
 30535 000046D6 46                      	inc	si			;AN000; si points to next byte
 30536 000046D7 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30537                                  
 30538                                  	; 31/03/2023
 30539                                  ;$P_RCOL_Exit:				;AN000;
 30540                                  	;pop	si			;AN000;
 30541                                  	;pop	ax			;AN000;
 30542                                  	;retn
 30543                                  
 30544                                  ;***********************************************************************
 30545                                  ; $P_Do_CAPS_String;
 30546                                  ;
 30547                                  ; Function: Perform capitalization along with the file case map table
 30548                                  ;	    or character case map table.
 30549                                  ;
 30550                                  ; Input:    AL = 2 : Use character table
 30551                                  ;	    AL = 4 : Use file table
 30552                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30553                                  ;
 30554                                  ; Output:   None
 30555                                  ;
 30556                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30557                                  ;***********************************************************************
 30558                                  
 30559                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30560                                  
 30561                                  $P_Do_CAPS_String:
 30562 000046D9 56                      	push	si			;AN000;
 30563 000046DA 52                      	push	dx			;AN000;
 30564 000046DB 88C2                    	mov	dl,al			;AN000; save info id
 30565                                  $P_DCS_Loop:				;AN000;
 30566 000046DD 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30567 000046E0 E88806                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30568 000046E3 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30569                                  
 30570 000046E5 08C0                    	or	al,al			;AN000; end of string ?
 30571 000046E7 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30572                                  
 30573 000046E9 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30574 000046EC 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30575 000046EF EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30576                                  $P_DCS00:				;AN000;
 30577 000046F1 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30578                                  $P_DCS01:				;AN000;
 30579 000046F2 46                      	inc	si			;AN000; si point to next byte
 30580 000046F3 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30581                                  $P_DCS_Exit:				;AN000;
 30582 000046F5 5A                      	pop	dx			;AN000;
 30583 000046F6 5E                      	pop	si			;AN000;
 30584 000046F7 C3                      	retn
 30585                                  
 30586                                  ;***********************************************************************
 30587                                  ; $P_Do_CAPS_Char;
 30588                                  ;
 30589                                  ; Function: Perform capitalization along with the file case map table
 30590                                  ;	    or character case map table.
 30591                                  ;
 30592                                  ; Input:    DL = 2 : Use character table
 30593                                  ;	    DL = 4 : Use file table
 30594                                  ;	    AL = character to be capitalized
 30595                                  ;
 30596                                  ; Output:   None
 30597                                  ;
 30598                                  ; Use:	INT 21h /w AH=65h
 30599                                  ;***********************************************************************
 30600                                  
 30601                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30602                                  
 30603                                  $P_Do_CAPS_Char:
 30604 000046F8 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30605 000046FA 730B                    	jae	short $P_DCC_Go		;AN000;
 30606                                  
 30607 000046FC 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30608 000046FE 723F                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30609                                  
 30610 00004700 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30611 00004702 773B                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30612                                  
 30613 00004704 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30614                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30615                                  	; 18/04/2023
 30616 00004706 C3                      	retn
 30617                                  
 30618                                  $P_DCC_Go:				;AN000;
 30619 00004707 53                      	push	bx			;AN000;
 30620 00004708 06                      	push	es			;AN000;
 30621 00004709 57                      	push	di			;AN000;
 30622                                  	; 18/04/2023
 30623 0000470A 8D3E[BD86]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30624 0000470E 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30625 00004711 7404                    	je	short $P_DCC00		;AN000;
 30626                                  	; 27/04/2023
 30627 00004713 8D3E[B886]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 30628                                  $P_DCC00:				;AN000;
 30629 00004717 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30630 0000471A 7416                    	je	short $P_DCC01		;AN000; if no,
 30631                                  
 30632                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30633                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30634                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30635                                  
 30636 0000471C 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30637 0000471D 51                      	push	cx			;AN000;
 30638 0000471E 52                      	push	dx			;AN000;
 30639 0000471F 0E                      	push	cs			;AC036; pass current base seg into
 30640                                  					;(Note: this used to push CS. BUG...
 30641 00004720 07                      	pop	es			;AN000;   ES reg, required for
 30642                                  					;get extended country information
 30643                                  	; 31/03/2023
 30644 00004721 B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30645                                  	;mov	ah,65h
 30646 00004723 88D0                    	mov	al,dl			;AN000; upper case table
 30647                                  	;mov	bx,-1 ; 0FFFFh
 30648                                  	;mov	cx,5
 30649                                  	;mov	dx,-1
 30650 00004725 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30651 00004728 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30652                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30653 0000472B 89DA                    	mov	dx,bx
 30654                                  	;mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30655                                  					;DI already set to point to buffer
 30656 0000472D CD21                    	int	21h			;AN000; es:di point to buffer that
 30657                                  					;now has been filled in with info
 30658 0000472F 5A                      	pop	dx			;AN000;
 30659 00004730 59                      	pop	cx			;AN000;
 30660 00004731 58                      	pop	ax			;AN000;
 30661                                  
 30662                                  $P_DCC01:				;AN000;
 30663                                  
 30664                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30665                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30666                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30667                                  
 30668                                  	;mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30669                                  	;;mov	bx,[cs:di+1]		;AN000; get offset of table
 30670                                  	;mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30671                                  	;;mov	es,[cs:di+3]		;AN000; get segment of table
 30672                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30673                                  	;les	bx,[cs:di+1]
 30674 00004732 2EC45D01                	les	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30675                                  	;
 30676 00004736 43                      	inc	bx			;AC035; add '2' to
 30677 00004737 43                      	inc	bx			;AC035;  BX reg
 30678                                  					;AN000; skip length field
 30679 00004738 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30680                                  	;xlat	es:[bx] 		;AN000; perform case map
 30681                                  	; 31/03/2023
 30682 0000473A 26D7                    	es	xlat
 30683                                  
 30684 0000473C 5F                      	pop	di			;AN000;
 30685 0000473D 07                      	pop	es			;AN000;
 30686 0000473E 5B                      	pop	bx			;AN000;
 30687                                  $P_CAPS_Ret:				;AN000;
 30688 0000473F C3                      	retn
 30689                                  
 30690                                  ;***********************************************************************
 30691                                  ; $P_Value / $P_SValue
 30692                                  ;
 30693                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30694                                  ;	     and make result buffer.
 30695                                  ;	     $P_SValue is an entry point for the signed value
 30696                                  ;	     and this will simply call $P_Value after the handling
 30697                                  ;	     of the sign character, "+" or "-"
 30698                                  ;
 30699                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30700                                  ;	     ES:BX -> CONTROL block
 30701                                  ;
 30702                                  ; Output:    None
 30703                                  ;
 30704                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30705                                  ;
 30706                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30707                                  ;***********************************************************************
 30708                                  
 30709                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30710                                  $P_SValue:
 30711 00004740 50                      	push	ax			;AN000;
 30712                                  	;or	byte [cs:$P_Flags2],80h
 30713 00004741 2E800E[FE85]80          	or	byte [cs:$P_Flags2],$P_Signed
 30714                                  					;AC034; indicate a signed numeric
 30715                                  	;and	byte [cs:$P_Flags2],0FDh
 30716 00004747 2E8026[FE85]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30717                                  					;AC034; assume positive value
 30718 0000474D 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30719 00004750 3C2B                    	cmp	al,'+' ; 2Bh
 30720                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30721 00004752 740A                    	je	short $P_SVal00		;AN000;
 30722                                  
 30723 00004754 3C2D                    	cmp	al,'-' ; 2Dh
 30724                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30725 00004756 7507                    	jne	short $P_Sval01		;AN000; else
 30726                                  
 30727 00004758 2E800E[FE85]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30728                                  					;AC034; set this is negative value
 30729                                  $P_SVal00:				;AN000;
 30730 0000475E 46                      	inc	si			;AN000; skip sign char
 30731                                  $P_Sval01:				;AN000;
 30732 0000475F E80200                  	call	$P_Value		;AN000; and process value
 30733 00004762 58                      	pop	ax			;AN000;
 30734                                  $P_Check_OVF_ok: ; 11/08/2024
 30735 00004763 C3                      	retn				;AN000;
 30736                                  
 30737                                  ;***********************************************************************
 30738                                  
 30739                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30740                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30741                                  
 30742                                  	; 11/08/2024
 30743                                  $P_Value:
 30744 00004764 50                      	push	ax			;AN000;
 30745 00004765 51                      	push	cx			;AN000;
 30746 00004766 52                      	push	dx			;AN000;
 30747 00004767 56                      	push	si			;AN000;
 30748 00004768 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30749 0000476A 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30750 0000476C 53                      	push	bx			;AN000; save control pointer
 30751                                  $P_Value_Loop:				;AN000;
 30752 0000476D 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30753 00004770 08C0                    	or	al,al			;AN000; end of line ?
 30754 00004772 7436                    	jz	short $P_Value00	;AN000;
 30755                                  
 30756 00004774 E8DF00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30757 00004777 722D                    	jc	short $P_Value_Err0	;AN000;
 30758                                  
 30759                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30760                                  %if 0
 30761                                  	xor	ah,ah			;AN000;
 30762                                  	mov	bp,ax			;AN000; save binary number
 30763                                  	shl	dx,1			;AN000; to have 2*x
 30764                                  	rcl	cx,1			;AN000; shift left w/ carry
 30765                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30766                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30767                                  
 30768                                  	mov	bx,dx			;AN000; save low(2*x)
 30769                                  	mov	ax,cx			;AN000; save high(2*x)
 30770                                  	shl	dx,1			;AN000; to have 4*x
 30771                                  	rcl	cx,1			;AN000; shift left w/ carry
 30772                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30773                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30774                                  
 30775                                  	shl	dx,1			;AN000; to have 8*x
 30776                                  	rcl	cx,1			;AN000; shift left w/ carry
 30777                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30778                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30779                                  
 30780                                  	add	dx,bx			;AN000; now have 10*x
 30781                                  	adc	cx,ax			;AN000; 32bit ADD
 30782                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30783                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30784                                  
 30785                                  	add	dx,bp			;AN000; Add the current one degree decimal
 30786                                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30787                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30788                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 30789                                  
 30790                                  	inc	si			;AN000; update pointer
 30791                                  	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30792                                  %else
 30793 00004779 30E4                    	xor	ah,ah
 30794 0000477B 89C5                    	mov	bp,ax			; save binary number
 30795 0000477D E81C00                  	call	$P_Check_OVF_shl32	; check Overflow (after shl32)
 30796 00004780 89D3                    	mov	bx,dx			; save low(2*x)
 30797 00004782 89C8                    	mov	ax,cx			; save high(2*x)
 30798 00004784 E81500                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 30799 00004787 E81200                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 30800 0000478A 01DA                    	add	dx,bx			; now have 10*x
 30801 0000478C 11C1                    	adc	cx,ax			; 32bit ADD
 30802 0000478E E80F00                  	call	$P_Check_OVF_@		; check OverFlow
 30803 00004791 01EA                    	add	dx,bp			; Add the current one degree decimal
 30804 00004793 83D100                  	adc	cx,0			; if carry, add 1 to high 16bit
 30805 00004796 E80700                  	call	$P_Check_OVF_@		; check Overflow
 30806 00004799 46                      	inc	si			; update pointer
 30807 0000479A EBD1                    	jmp	short $P_Value_Loop	; loop until NULL encountered
 30808                                  
 30809                                  $P_Check_OVF_shl32:
 30810 0000479C D1E2                    	shl	dx,1
 30811 0000479E D1D1                    	rcl	cx,1
 30812                                  $P_Check_OVF_@:
 30813 000047A0 E8A100                  	call	$P_Check_OVF
 30814                                  	;jc	short $P_Value_Err0_@
 30815                                  	;retn
 30816                                  	; 11/08/2024
 30817 000047A3 73BE                    	jnc	short $P_Check_OVF_ok
 30818                                  
 30819                                  $P_Value_Err0_@:
 30820                                  	;inc	sp
 30821                                  	;inc	sp
 30822                                  	; 11/08/2024
 30823 000047A5 5B                      	pop	bx
 30824                                  %endif
 30825                                  
 30826                                  $P_Value_Err0:				;AN000;
 30827 000047A6 5B                      	pop	bx			;AN000;
 30828 000047A7 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30829                                  
 30830                                  $P_Value00:				;AN000;
 30831 000047AA 5B                      	pop	bx			;AN000; restore control pointer
 30832 000047AB 2EF606[FE85]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30833                                  					;AC034; here cx,dx = 32bit value
 30834 000047B1 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30835                                  
 30836 000047B3 F7D1                    	not	cx			;AN000; +
 30837 000047B5 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30838 000047B7 83C201                  	add	dx,1			;AN000; |
 30839 000047BA 83D100                  	adc	cx,0			;AN000; +
 30840                                  $P_Value01:				;AN000; / nval =0
 30841 000047BD 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30842                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30843 000047C1 268A04                  	mov	al,[es:si]		;AN000; get nval
 30844 000047C4 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30845 000047C6 7505                    	jne	short $P_Value02	;AN000;
 30846                                  
 30847                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30848                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30849                                  	; 31/03/2023
 30850 000047C8 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30851 000047CB EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30852                                  
 30853                                  $P_Value02:				;AN000; / nval = 1
 30854 000047CD 46                      	inc	si			;AN000;
 30855 000047CE 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30856 000047D1 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30857 000047D3 745D                    	je	short $P_Value03	;AN000; (tm07)
 30858                                  
 30859 000047D5 46                      	inc	si			;AN000; si points to 1st item_tag
 30860                                  $P_Val02_Loop:				;AN000;
 30861 000047D6 2EF606[FE85]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30862                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30863 000047DC 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30864                                  
 30865 000047DE 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30866                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30867 000047E2 723B                    	jb	short $P_Val02_Next	;AN000;
 30868 000047E4 7706                    	ja	short $P_Val_In		;AN000;
 30869                                  
 30870 000047E6 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30871                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30872 000047EA 7233                    	jb	short $P_Val02_Next	;AN000;
 30873                                  
 30874                                  $P_Val_In:				;AN000;
 30875 000047EC 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30876                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30877 000047F0 772D                    	ja	short $P_Val02_Next	;AN000;
 30878 000047F2 7224                    	jb	short $P_Val_Found	;AN000;
 30879                                  
 30880 000047F4 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30881                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30882 000047F8 7725                    	ja	short $P_Val02_Next	;AN000;
 30883                                  
 30884 000047FA EB1C                    	jmp	short $P_Val_Found	;AN000;
 30885                                  
 30886                                  $P_Val02_Sign:				;AN000;
 30887 000047FC 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30888                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30889 00004800 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30890 00004802 7F06                    	jg	short $P_SVal_In	;AN000;
 30891                                  
 30892 00004804 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30893                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30894 00004808 7C15                    	jl	short $P_Val02_Next	;AN000;
 30895                                  
 30896                                  $P_SVal_In:				;AN000;
 30897 0000480A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30898                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30899 0000480E 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30900 00004810 7C06                    	jl	short $P_Val_Found	;AN000;
 30901                                  
 30902 00004812 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30903                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30904 00004816 7F07                    	jg	short $P_Val02_Next	;AN000;
 30905                                  
 30906                                  	;jmp	short $P_Val_Found	;AN000;
 30907                                  	; 27/04/2023
 30908                                  $P_Val_Found:				;AN000;
 30909 00004818 B001                    	mov	al,$P_Number ; 1	;AN000;
 30910 0000481A 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30911 0000481D EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30912                                  
 30913                                  $P_Val02_Next:				;AN000;
 30914 0000481F 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30915 00004822 FEC8                    	dec	al			;AN000; loop nrng times in AL
 30916 00004824 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30917                                  					; / Not found
 30918 00004826 2EC706[F285]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30919                                  	;mov	word [cs:$P_RC],6	;AC034;
 30920                                  	
 30921                                  	;mov	al,$P_Number ; 1	;AN000;
 30922                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30923                                  	; 31/03/2023
 30924 0000482D B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30925 00004830 EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30926                                  
 30927                                  	; 27/04/2023
 30928                                  ;$P_Val_Found:				;AN000;
 30929                                  	;mov	al,$P_Number ; 1	;AN000;
 30930                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30931                                  	;jmp	short $P_Value_Exit	;AN000;
 30932                                  
 30933                                  $P_Value03:				;AN000; / nval = 2
 30934                                  $P_Value04:				;AN000; / nval = 3 or else
 30935                                  $P_Value_Err:				;AN000;
 30936 00004832 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30937                                  					;AC034;
 30938                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30939                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30940                                  	; 31/03/2023
 30941 00004839 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30942                                  $P_Value_Exit:				;AN000;
 30943 0000483C E81AFD                  	call	$P_Fill_Result		;AN000;
 30944 0000483F 5E                      	pop	si			;AN000;
 30945 00004840 5A                      	pop	dx			;AN000;
 30946 00004841 59                      	pop	cx			;AN000;
 30947 00004842 58                      	pop	ax			;AN000;
 30948 00004843 C3                      	retn				;AN000;
 30949                                  
 30950                                  ;***********************************************************************
 30951                                  ; $P_Check_OVF
 30952                                  ;
 30953                                  ; Function:  Check if overflow is occurred with consideration of
 30954                                  ;	     signed or un-signed numeric value
 30955                                  ;
 30956                                  ; Input:     Flag register
 30957                                  ;
 30958                                  ; Output:    CY = 1  :	Overflow
 30959                                  ;
 30960                                  ; Vars:     $P_Flags(R)
 30961                                  ;***********************************************************************
 30962                                  
 30963                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30964                                  $P_Check_OVF:
 30965 00004844 9C                      	pushf				;AN000;
 30966 00004845 2EF606[FE85]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30967                                  					;AC034; is it negative value ?
 30968 0000484B 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30969 0000484D 9D                      	popf				;AN000; by the CY bit
 30970 0000484E C3                      	retn				;AN000;
 30971                                  $P_COVF:				;AN000;
 30972 0000484F 9D                      	popf				;AN000; else,
 30973 00004850 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30974 00004852 F8                      	clc				;AN000; indicate it with CY bit
 30975 00004853 C3                      	retn				;AN000; CY=0 means no overflow
 30976                                  $P_0099Err:	; 31/03/2023
 30977                                  $P_COVF00:				;AN000;
 30978 00004854 F9                      	stc				;AN000; and CY=1 means overflow
 30979                                  $P_0099Err2:	; 31/03/2023
 30980 00004855 C3                      	retn				;AN000;
 30981                                  
 30982                                  ;***********************************************************************
 30983                                  ; $P_0099;
 30984                                  ;
 30985                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30986                                  ;
 30987                                  ; Input:     AL = character code
 30988                                  ;
 30989                                  ; Output:    CY = 1 : AL is not number
 30990                                  ;	     CY = 0 : AL contains binary value
 30991                                  ;***********************************************************************
 30992                                  
 30993                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30994                                  $P_0099:
 30995 00004856 3C30                    	cmp	al,"0"                  ;AN000;
 30996                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30997                                  	; 31/03/2023
 30998 00004858 72FB                    	jb	short $P_0099Err2
 30999                                  
 31000 0000485A 3C39                    	cmp	al,"9"                  ;AN000;
 31001 0000485C 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31002                                  
 31003 0000485E 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 31004                                  	; 31/03/2023
 31005                                  	;clc				;AN000; indicate no error
 31006 00004860 C3                      	retn				;AN000;
 31007                                  	 ;31/03/2023
 31008                                  ;$P_0099Err:				;AN000;
 31009                                  ;	stc				;AN000; indicate error
 31010                                  ;	retn				;AN000;
 31011                                  
 31012                                  ;***********************************************************************
 31013                                  ; $P_Simple_String
 31014                                  ;
 31015                                  ; Function:  See value list for the simple string
 31016                                  ;	     and make result buffer.
 31017                                  ;
 31018                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31019                                  ;	     ES:BX -> CONTROL block
 31020                                  ;
 31021                                  ; Output:    None
 31022                                  ;
 31023                                  ; Use:	$P_Fill_Result, $P_String_Comp
 31024                                  ;
 31025                                  ; Vars: $P_RC(W)
 31026                                  ;***********************************************************************
 31027                                  
 31028                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31029                                  
 31030                                  $P_Simple_String:
 31031 00004861 50                      	push	ax			;AN000;
 31032 00004862 53                      	push	bx			;AN000;
 31033 00004863 52                      	push	dx			;AN000;
 31034 00004864 57                      	push	di			;AN000;
 31035 00004865 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31036                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 31037 00004869 268A05                  	mov	al,[es:di]		;AN000; get nval
 31038 0000486C 08C0                    	or	al,al			;AN000; no value list ?
 31039 0000486E 7502                    	jnz	short $P_Sim00		;AN000; then
 31040                                  	; 31/03/2023
 31041                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31042 00004870 EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 31043                                  $P_Sim00:				;AN000;
 31044 00004872 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 31045 00004874 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 31046                                  
 31047 00004876 47                      	inc	di			;AN000;
 31048 00004877 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 31049 0000487A B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 31050 0000487C F6E4                    	mul	ah			;AN000;  Skip nrng field
 31051 0000487E 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 31052 0000487F 01C7                    	add	di,ax			;AN000; di points to nnval
 31053 00004881 268A05                  	mov	al,[es:di]		;AN000; get nnval
 31054 00004884 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 31055 00004886 F6E4                    	mul	ah			;AN000; Skip nnval field
 31056 00004888 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 31057 00004889 01C7                    	add	di,ax			;AN000; di points to nstrval
 31058 0000488B 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 31059 0000488E 47                      	inc	di			;AC035; add '2' to
 31060 0000488F 47                      	inc	di			;AC035;  DI reg
 31061                                  					;AN000; di points to 1st string in list
 31062                                  $P_Sim_Loop:				;AN000;
 31063 00004890 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 31064 00004893 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 31065 00004896 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 31066                                  
 31067 00004898 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 31068 0000489B FEC8                    	dec	al			;AN000; loop nstval times in AL
 31069 0000489D 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 31070                                  					;AN000; / Not found
 31071 0000489F 2EC706[F285]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 31072                                  	;mov	[cs:$P_RC],8		;AC034;
 31073                                  	; 31/03/2023
 31074                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31075 000048A6 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 31076                                  $P_Sim_Found:				;AN000;
 31077 000048A8 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 31078 000048AC B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 31079 000048AE 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 31080 000048B1 EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 31081                                  $P_Sim01:				;AN000;
 31082 000048B3 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 31083                                  	;mov	word [cs:$P_RC],9	;AC034;
 31084                                  $P_Sim_Exit:
 31085                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31086                                  ;$P_Sim_Exit:				;AN000;
 31087                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31088                                  	; 31/03/2023
 31089 000048BA B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31090                                  $P_Sim_Exit0:				;AN000;
 31091 000048BD E899FC                  	call	$P_Fill_Result		;AN000;
 31092 000048C0 5F                      	pop	di			;AN000;
 31093 000048C1 5A                      	pop	dx			;AN000;
 31094 000048C2 5B                      	pop	bx			;AN000;
 31095 000048C3 58                      	pop	ax			;AN000;
 31096 000048C4 C3                      	retn				;AN000;
 31097                                  
 31098                                  ;***********************************************************************
 31099                                  ; $P_String_Comp:
 31100                                  ;
 31101                                  ; Function:  Compare two string
 31102                                  ;
 31103                                  ; Input:     psdata_seg:SI -> 1st string
 31104                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 31105                                  ;	     ES:BX -> CONTROL block
 31106                                  ;
 31107                                  ; Output:    CY = 1 if not match
 31108                                  ;
 31109                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 31110                                  ;
 31111                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 31112                                  ;***********************************************************************
 31113                                  
 31114                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31115                                  
 31116                                  $P_String_Comp:
 31117 000048C5 50                      	push	ax			;AN000;
 31118 000048C6 55                      	push	bp			;AN000;
 31119 000048C7 52                      	push	dx			;AN000;
 31120 000048C8 56                      	push	si			;AN000;
 31121 000048C9 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31122                                  $P_SCOM_Loop:				;AN000;
 31123 000048CB 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31124 000048CE E89A04                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31125 000048D1 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31126                                  
 31127 000048D3 E822FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31128                                  	
 31129 000048D6 2EF606[FE85]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31130                                  					;AC034; keyword search ?
 31131 000048DC 740D                    	jz	short $P_SCOM04		;AN000;
 31132                                  
 31133                                  	;cmp	al,'=' ; 3Dh
 31134 000048DE 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31135 000048E0 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31136                                  
 31137 000048E2 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31138 000048E7 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31139                                  
 31140 000048E9 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31141                                  
 31142                                  $P_SCOM04:				;AN000;
 31143 000048EB 2EF606[FE85]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31144                                  					;AC034; switch search ?
 31145 000048F1 740E                    	jz	short $P_SCOM03		;AN000;
 31146                                  
 31147 000048F3 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 31148 000048F5 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 31149                                  
 31150 000048F7 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 31151 000048FC 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 31152                                  
 31153                                  $P_SCOM05:				;AN000;   found a match
 31154 000048FE 46                      	inc	si			;AN000; si points to just after "=" or ":"
 31155 000048FF EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 31156                                  
 31157                                  $P_SCOM03:				;AN000;
 31158 00004901 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 31159 00004905 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 31160                                  
 31161 00004907 08C0                    	or	al,al			;AN000; end of line
 31162 00004909 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 31163                                  
 31164 0000490B 46                      	inc	si			;AN000; update operand pointer
 31165 0000490C 45                      	inc	bp			;AN000;    and synonym pointer
 31166 0000490D EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 31167                                  
 31168                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 31169 0000490F 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 31170 00004913 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 31171                                  
 31172 00004915 46                      	inc	si			;AN000; else, load next byte
 31173 00004916 2E8A04                  	mov	al,[cs:si]		;AN000; and
 31174 00004919 45                      	inc	bp			;AN000;
 31175 0000491A 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 31176 0000491E 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 31177                                  
 31178 00004920 46                      	inc	si			;AN000; else update operand pointer
 31179 00004921 45                      	inc	bp			;AN000; 	and synonym pointer
 31180                                  $P_SCOM01:				;AN000;
 31181 00004922 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 31182                                  
 31183                                  $P_SCOM_Differ0:			;AN000;
 31184 00004924 2EF606[FE85]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h
 31185                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 31186 0000492A 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 31187                                  
 31188                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31189                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 31190                                  	; 03/04/2023
 31191 0000492C 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31192 00004931 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 31193                                  
 31194 00004933 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 31195 00004938 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 31196                                  
 31197                                  $P_not_applicable:			;AN000;(tm10)
 31198                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31199                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 31200                                  	; 03/04/2023
 31201 0000493A 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31202 0000493E 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 31203                                  
 31204 00004940 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 31205 00004942 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 31206                                  
 31207 00004944 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 31208                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 31209                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 31210                                  	; 01/04/2023
 31211 00004949 740E                    	je	short $P_SCOM_Same
 31212                                  $P_SCOM_Differ:
 31213 0000494B F9                      	stc
 31214 0000494C EB10                    	jmp	short $P_SCOM_Exit
 31215                                  
 31216                                  $P_SCOM02:				;AN000;
 31217 0000494E 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 31218 00004950 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 31219                                  
 31220                                  	;cmp	byte [es:bp],':'
 31221 00004952 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 31222                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 31223                                  	; 01/04/2023
 31224 00004957 75F2                    	jne	short $P_SCOM_Differ
 31225                                  ;$P_SCOM_Differ: 			;AN000;
 31226                                  	;stc				;AN000; indicate not found
 31227                                  	;jmp	short $P_SCOM_Exit	;AN000;
 31228                                  
 31229                                  $P_SCOM_Same:				;AN000;
 31230 00004959 2E8936[0186]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 31231                                  	; 01/04/2023
 31232                                  	;clc
 31233                                  	; cf = 0			;AN000; indicate found
 31234                                  $P_SCOM_Exit:				;AN000;
 31235 0000495E 5E                      	pop	si			;AN000;
 31236 0000495F 5A                      	pop	dx			;AN000;
 31237 00004960 5D                      	pop	bp			;AN000;
 31238 00004961 58                      	pop	ax			;AN000;
 31239 00004962 C3                      	retn				;AN000;
 31240                                  
 31241                                  ;***********************************************************************
 31242                                  ; $P_Date_Format
 31243                                  ;
 31244                                  ; Function:  Convert a date string to DOS date format for int 21h
 31245                                  ;	     with format validation.
 31246                                  ;
 31247                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31248                                  ;	     ES:BX -> CONTROL block
 31249                                  ;
 31250                                  ; Output:    None
 31251                                  ;
 31252                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 31253                                  ;
 31254                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 31255                                  ;***********************************************************************
 31256                                  
 31257                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31258                                  	; 11/08/2024
 31259                                  $P_Date_Format:
 31260 00004963 50                      	push	ax			;AN000;
 31261 00004964 51                      	push	cx			;AN000;
 31262 00004965 52                      	push	dx			;AN000;
 31263 00004966 56                      	push	si			;AN000;
 31264 00004967 53                      	push	bx			;AN000;
 31265 00004968 56                      	push	si			;AN000;
 31266 00004969 E8A400                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 31267                                  	; 03/04/2023
 31268                                  	;pop	si			;AN000;
 31269                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31270                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31271                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31272 0000496C 31F6                    	xor	si,si
 31273 0000496E 2E8936[B086]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 31274 00004973 2E8936[B286]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 31275                                  	; 11/08/2024
 31276 00004978 2E8936[B486]            	mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 31277 0000497D 5E                      	pop	si
 31278 0000497E E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 31279                                  	;jc	short $P_DateF_Err0	;AN000;-----------------------+
 31280                                  	; 11/08/2024
 31281 00004981 727A                    	jc	short $P_DateF_Error
 31282 00004983 2EA3[B086]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 31283 00004987 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31284 00004989 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31285 0000498B E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 31286 0000498E 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 31287 00004990 2EA3[B286]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 31288 00004994 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31289 00004996 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31290 00004998 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 31291                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 31292 0000499B 7260                    	jc	short $P_DateF_Error	;AN000;
 31293 0000499D 2EA3[B486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31294 000049A1 08DB                    	or	bl,bl			;AN000; end of line ?
 31295 000049A3 7558                    	jnz	short $P_DateF_Error	;AN000;
 31296                                  $P_DateF_YMD:				;AN000;
 31297 000049A5 2E8B1E[8E86]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 31298                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 31299 000049AA 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 31300 000049AD 7422                    	je	short $P_DateF00	;AN000;
 31301 000049AF 2EA1[B086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31302 000049B3 08E4                    	or	ah,ah			;AN000;
 31303 000049B5 7546                    	jnz	short $P_DateF_Error	;AN000;
 31304 000049B7 88C1                    	mov	cl,al			;AN000; set month
 31305 000049B9 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31306 000049BD 08E4                    	or	ah,ah			;AN000; if overflow, error.
 31307 000049BF 753C                    	jnz	short $P_DateF_Error	;AN000;
 31308 000049C1 88C5                    	mov	ch,al			;AN000; set date
 31309 000049C3 2E8B16[B486]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 31310 000049C8 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 31311 000049CB 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 31312 000049CD 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 31313                                  $P_DateF01:				;AN000;
 31314 000049CF EB19                    	jmp	short $P_DateF02	;AN000;
 31315                                  $P_DateF00:				;AN000; / here format = YMD
 31316 000049D1 2E8B16[B086]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 31317 000049D6 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31318 000049DA 08E4                    	or	ah,ah			;AN000; if overflow, error
 31319 000049DC 751F                    	jnz	short $P_DateF_Error	;AN000;
 31320                                  
 31321 000049DE 88C1                    	mov	cl,al			;AN000; set month
 31322 000049E0 2EA1[B486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31323 000049E4 08E4                    	or	ah,ah			;AN000; if overflow, error
 31324 000049E6 7515                    	jnz	short $P_DateF_Error	;AN000;
 31325 000049E8 88C5                    	mov	ch,al			;AN000; set date
 31326                                  $P_DateF02:				;AN000;
 31327 000049EA 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 31328 000049ED 7304                    	jae	short $P_DateF03	;AN000;
 31329 000049EF 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 31330                                  $P_DateF03:				;AN000;
 31331 000049F3 5B                      	pop	bx			;AN000; recover CONTROL block
 31332 000049F4 5E                      	pop	si			;AN000; recover string pointer
 31333                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31334                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 31335                                  	; 03/04/2023
 31336 000049F5 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 31337 000049F8 E85EFB                  	call	$P_Fill_Result		;AN000;        buffer
 31338 000049FB EB0F                    	jmp	short $P_Date_Format_Exit
 31339                                  					;AN000;	to Date
 31340                                  $P_DateF_Error: 			;AN000;
 31341 000049FD 5B                      	pop	bx			;AN000; recover CONTROL block
 31342 000049FE 5E                      	pop	si			;AN000; recover string pointer
 31343                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31344                                  	;mov	al,$P_String ; 3	;AN000;   result
 31345                                  	; 03/04/2023
 31346 000049FF B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31347 00004A02 E854FB                  	call	$P_Fill_Result		;AN000; 	buffer
 31348                                  					;AN000; to string
 31349 00004A05 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31350                                  					;AC034; indicate syntax error
 31351                                  $P_Date_Format_Exit:			;AN000;
 31352 00004A0C 5A                      	pop	dx			;AN000;
 31353 00004A0D 59                      	pop	cx			;AN000;
 31354 00004A0E 58                      	pop	ax			;AN000;
 31355 00004A0F C3                      	retn				;AN000;
 31356                                  
 31357                                  ;***********************************************************************
 31358                                  ; $P_Set_CDI:
 31359                                  ;
 31360                                  ; Function: Read CDI from DOS if it has not been read yet
 31361                                  ;
 31362                                  ; Input:    None
 31363                                  ;
 31364                                  ; Output:   psdata_seg:SI -> CDI
 31365                                  ;
 31366                                  ; Use:	INT 21h w/ AH = 38h
 31367                                  ;***********************************************************************
 31368                                  
 31369                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31370                                  $P_Set_CDI:
 31371                                  	; 18/04/2023
 31372 00004A10 8D36[8E86]              	lea	si,$P_Country_Info	;AC034;
 31373                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 31374 00004A14 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 31375                                  					;AN000; already read ?
 31376                                  	;je	short $P_Read_CDI	;AN000;
 31377                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 31378                                  	; 03/04/2023
 31379 00004A18 750F                    	jne	short $P_Set_CDI_Exit
 31380                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 31381 00004A1A 1E                      	push	ds			;AN000;
 31382 00004A1B 52                      	push	dx			;AN000;
 31383 00004A1C 50                      	push	ax			;AN000;
 31384 00004A1D 0E                      	push	cs			;AC023;
 31385 00004A1E 1F                      	pop	ds			;AN000; set segment register
 31386                                  	;mov	ax,3800h
 31387 00004A1F B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 31388 00004A22 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 31389 00004A24 CD21                    	int	21h			;AN000;
 31390 00004A26 58                      	pop	ax			;AN000;
 31391 00004A27 5A                      	pop	dx			;AN000;
 31392 00004A28 1F                      	pop	ds			;AN000;
 31393                                  $P_Set_CDI_Exit:			;AN000;
 31394 00004A29 C3                      	retn				;AN000;
 31395                                  
 31396                                  ;***********************************************************************
 31397                                  ; $P_Get_DecNum:
 31398                                  ;
 31399                                  ; Function:  Read a character code from psdata_seg:SI until specified delimiter
 31400                                  ;	     or NULL encountered. And make a decimal number.
 31401                                  ;
 31402                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31403                                  ;
 31404                                  ; Output:    BL = delimiter code or NULL
 31405                                  ;	     AX = Decimal number
 31406                                  ;	     SI advanced to the next number
 31407                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 31408                                  ;
 31409                                  ; Use:	$P_0099
 31410                                  ;***********************************************************************
 31411                                  
 31412                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31413                                  $P_Get_DecNum:
 31414 00004A2A 51                      	push	cx			;AN000;
 31415 00004A2B 52                      	push	dx			;AN000;
 31416 00004A2C 31C9                    	xor	cx,cx			;AN000; cx will have final value
 31417                                  $P_GetNum_Loop: 			;AN000;
 31418 00004A2E 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31419 00004A31 08C0                    	or	al,al			;AN000; end of line ?
 31420 00004A33 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 31421 00004A35 2E803E[8D86]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 31422 00004A3B 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 31423                                  
 31424                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 31425                                  	;cmp	bl,$P_colon_period
 31426 00004A3D 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 31427 00004A40 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 31428                                  
 31429 00004A42 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31430 00004A44 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31431                                  
 31432                                  	; 03/04/2023
 31433 00004A46 EB08                    	jmp	short $P_Do_Time_Delim1
 31434                                  ;$P_Do_Time_Delim1:			;AN000;
 31435                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31436                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31437                                  	;
 31438                                  	;jmp	short $P_Neither_Delims ;AN023;
 31439                                  
 31440                                  $P_Do_Date_Delims:			;AN000;
 31441                                  ;Regardless of the date delimiter character specified in the country
 31442                                  ;dependent information, check for the presence of any one of these
 31443                                  ;three field delimiters: "-", "/", or ".".
 31444 00004A48 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31445 00004A4A 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31446                                  
 31447 00004A4C 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31448 00004A4E 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31449                                  
 31450                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31451 00004A50 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31452 00004A52 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31453                                  
 31454                                  $P_Neither_Delims:			;AN023;
 31455 00004A54 E8FFFD                  	call	$P_0099 		;AN000; convert it to binary
 31456 00004A57 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31457                                  
 31458 00004A59 B400                    	mov	ah,0			;AN000;
 31459 00004A5B 91                      	xchg	ax,cx			;AN000;
 31460 00004A5C BA0A00                  	mov	dx,10			;AN000;
 31461 00004A5F F7E2                    	mul	dx			;AN000; ax = ax * 10
 31462 00004A61 09D2                    	or	dx,dx			;AN000; overflow
 31463 00004A63 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31464                                  
 31465 00004A65 01C8                    	add	ax,cx			;AN000;
 31466 00004A67 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31467                                  
 31468 00004A69 91                      	xchg	ax,cx			;AN000;
 31469 00004A6A 46                      	inc	si			;AN000;
 31470 00004A6B EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31471                                  
 31472                                  $P_GetNum00:				;AN000;
 31473 00004A6D 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31474                                  	;03/04/2023
 31475                                  	; cf=0
 31476                                  	;clc				;AN000; indicate no error
 31477 00004A6F EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31478                                  
 31479                                  $P_GetNum01:				;AN000;
 31480 00004A71 46                      	inc	si			;AN000; si points to next number
 31481                                  	;03/04/2023
 31482                                  	; cf=0
 31483                                  	;clc				;AN000; indicate no error
 31484 00004A72 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31485                                  
 31486                                  $P_GetNum02:				;AN000;
 31487 00004A74 F9                      	stc				;AN000; indicate error
 31488                                  $P_GetNum_Exit: 			;AN000;
 31489 00004A75 89C8                    	mov	ax,cx			;AN000;return value
 31490 00004A77 5A                      	pop	dx			;AN000;
 31491 00004A78 59                      	pop	cx			;AN000;
 31492 00004A79 C3                      	retn				;AN000;
 31493                                  
 31494                                  ;***********************************************************************
 31495                                  ; $P_Time_Format
 31496                                  ;
 31497                                  ; Function:  Convert a time string to DOS time format for int 21h
 31498                                  ;	     with format validation.
 31499                                  ;
 31500                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31501                                  ;	     ES:BX -> CONTROL block
 31502                                  ;
 31503                                  ; Output:    None
 31504                                  ;
 31505                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 31506                                  ;
 31507                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 31508                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 31509                                  ;***********************************************************************
 31510                                  
 31511                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31512                                  	; 12/08/2024
 31513                                  $P_Time_Format:				;AN000;
 31514 00004A7A 50                      	push	ax			;AN000;
 31515 00004A7B 51                      	push	cx			;AN000;
 31516 00004A7C 52                      	push	dx			;AN000;
 31517 00004A7D 56                      	push	si			;AN000;
 31518 00004A7E 53                      	push	bx			;AN000;
 31519 00004A7F 56                      	push	si			;AN000;
 31520 00004A80 E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 31521                                  					; information before process
 31522                                  	;test	byte [cs:si+11h], 1
 31523 00004A83 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 31524                                  					;AN000; 24 hour system
 31525 00004A88 5E                      	pop	si			;AN000;
 31526 00004A89 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 31527 00004A8B E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 31528                                  $P_TimeF00:				;AN000;
 31529                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31530                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31531                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31532                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 31533                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 31534                                  	; 03/04/2023
 31535 00004A8E 31DB                    	xor	bx,bx
 31536 00004A90 2E891E[B086]            	mov	[cs:$P_1st_Val],bx ; 0
 31537 00004A95 2E891E[B286]            	mov	[cs:$P_2nd_Val],bx ; 0
 31538 00004A9A 2E891E[B486]            	mov	[cs:$P_3rd_Val],bx ; 0
 31539 00004A9F 2E891E[B686]            	mov	[cs:$P_4th_Val],bx ; 0
 31540                                  	;inc	bl
 31541                                  	;mov	[cs:$P_Got_Time],bl ; 1
 31542                                  
 31543                                  	;mov	bl,$P_colon_period
 31544                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 31545                                  					; delimiters between hours,
 31546                                  					;  minutes,seconds
 31547                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 31548 00004AA4 FEC3                    	inc	bl ; bl = 1
 31549 00004AA6 2E881E[8D86]            	mov	[cs:$P_Got_Time],bl ; 1
 31550                                  	;
 31551 00004AAB E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 31552                                  	;jc	short $P_TimeF_Err0	;AN000;
 31553                                  	; 12/08/2024
 31554 00004AAE 725A                    	jc	short $P_TimeF_Error
 31555 00004AB0 2EA3[B086]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31556 00004AB4 08DB                    	or	bl,bl			;AN000; end of line ?
 31557 00004AB6 7478                    	jz	short $P_TimeF_Rlt	;AN000;
 31558 00004AB8 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31559                                  	;jc	short $P_TimeF_Err0	;AC038; if OK
 31560                                  	; 12/08/2024
 31561 00004ABB 724D                    	jc	short $P_TimeF_Error
 31562 00004ABD 2EA3[B286]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31563 00004AC1 08DB                    	or	bl,bl			;AN000; end of line ?
 31564 00004AC3 746B                    	jz	short $P_TimeF_Rlt	;AN000;
 31565 00004AC5 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31566 00004AC7 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31567                                  	;jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31568                                  	; 12/08/2024
 31569 00004ACA 723E                    	jc	short $P_TimeF_Error
 31570 00004ACC 2EA3[B486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31571 00004AD0 08DB                    	or	bl,bl			;AN000; end of line ?
 31572 00004AD2 754F                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31573                                  					;AN039;   GO TO 4TH NUMBER
 31574                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31575 00004AD4 2EF606[FD85]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31576                                  					;AN039;    BEEN REPEATED?
 31577 00004ADA 7554                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31578                                  					;AN039;   the end of line
 31579                                  					;AN039; no, time has not been repeated
 31580 00004ADC 2E8B36[F485]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31581                                  					;AN039;   in command line
 31582 00004AE1 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31583                                  					;AN039; look at delimiter
 31584                                  					;AN039;   from command line
 31585 00004AE5 7549                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31586                                  					;AN039;  really end of line
 31587                                  					;AN039; is comma before hundredths,
 31588                                  					;AN039;   redo TIME
 31589 00004AE7 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31590                                  					;AN039; change that ambiguous
 31591                                  					;AN039;    comma to a decimal point
 31592                                  					;AN039;     parse can understand
 31593 00004AEB 2EC706[FD85]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31594                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31595 00004AF2 2E800E[FD85]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31596                                  					;AN039; is being repeated
 31597 00004AF8 2E8B0E[8786]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31598 00004AFD 2E8B26[8986]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31599                                  					;AN039;   OF STACK FROM SP
 31600 00004B02 2E8B36[8B86]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31601                                  					;AN039;   PARSE POINTER FROM SI
 31602 00004B07 E927F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31603                                  
 31604                                  	; 12/08/2024
 31605                                  $P_TimeF_Error: 			;AN000;
 31606                                  $P_TimeF_Err:				;AN000;
 31607 00004B0A 5B                      	pop	bx			;AN000; recover CONTROL block
 31608 00004B0B 5E                      	pop	si			;AN000; recover string pointer
 31609                                  	;mov	ah,$P_No_Tag		;AN000; set
 31610                                  	;mov	al,$P_String		;AN000;     result
 31611                                  	; 03/04/2023
 31612 00004B0C B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31613 00004B0F E847FA                  	call	$P_Fill_Result		;AN000; 	  buffer
 31614                                  					;AN000; to string
 31615 00004B12 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31616                                  					;AC034; return syntax error
 31617                                  $P_Time_Format_Exit:			;AN000;
 31618 00004B19 2EC606[8D86]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31619 00004B1F 5A                      	pop	dx			;AN000;
 31620 00004B20 59                      	pop	cx			;AN000;
 31621 00004B21 58                      	pop	ax			;AN000;
 31622 00004B22 C3                      	retn
 31623                                  
 31624                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31625 00004B23 E804FF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31626                                  $P_TimeF_Err0:				;AN000; Bridge
 31627 00004B26 72E2                    	jc	short $P_TimeF_Error	;AN000;
 31628                                  	;
 31629 00004B28 2EA3[B686]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31630 00004B2C 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31631 00004B2E 75DA                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31632                                  $P_TimeF_Rlt:				;AN000;
 31633 00004B30 2EA1[B086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31634 00004B34 08E4                    	or	ah,ah			;AN000; if overflow then error
 31635 00004B36 75D2                    	jnz	short $P_TimeF_Err	;AN000;
 31636                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31637 00004B38 2EF606[FD85]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31638 00004B3E 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31639                                  					;since "AM" was specified,
 31640 00004B40 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31641 00004B42 77C6                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31642 00004B44 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31643 00004B46 30C0                    	xor	al,al			;AN038; set hour = zero
 31644                                  $P_Time_notAM:				;AN038;
 31645                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31646 00004B48 2EF606[FE85]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31647 00004B4E 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31648 00004B50 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31649 00004B52 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31650 00004B54 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31651 00004B56 72B2                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31652 00004B58 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31653 00004B5A 77AE                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31654                                  $P_TimeSkip00:				;AN000;
 31655 00004B5C 88C2                    	mov	dl,al			;AN000; set hour
 31656 00004B5E 2EA1[B286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31657 00004B62 08E4                    	or	ah,ah			;AN000; if overflow then error
 31658 00004B64 75A4                    	jnz	short $P_TimeF_Err	;AN000;
 31659 00004B66 88C6                    	mov	dh,al			;AN000; set minute
 31660 00004B68 2EA1[B486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31661 00004B6C 08E4                    	or	ah,ah			;AN000; if overflow then error
 31662 00004B6E 759A                    	jnz	short $P_TimeF_Err	;AN000;
 31663 00004B70 88C1                    	mov	cl,al			;AN000; set second
 31664 00004B72 2EA1[B686]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31665 00004B76 08E4                    	or	ah,ah			;AN000; if overflow then error
 31666 00004B78 7590                    	jnz	short $P_TimeF_Err	;AN000;
 31667 00004B7A 88C5                    	mov	ch,al			;AN000; set hundredth
 31668 00004B7C 5B                      	pop	bx			;AN000; recover CONTROL block
 31669 00004B7D 5E                      	pop	si			;AN000; recover string pointer
 31670                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31671                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31672                                  	; 03/04/2023
 31673 00004B7E B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31674 00004B81 E8D5F9                  	call	$P_Fill_Result		;AN000;        buffer
 31675 00004B84 EB93                    	jmp	short $P_Time_Format_Exit
 31676                                  					;AN000; to time
 31677                                  
 31678                                  ;***********************************************************************
 31679                                  ; $P_Time_2412:
 31680                                  ;
 31681                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31682                                  ;
 31683                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31684                                  ;
 31685                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31686                                  ;	     or "pm"
 31687                                  ;
 31688                                  ; Vars:  $P_Flags(W)
 31689                                  ;***********************************************************************
 31690                                  
 31691                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31692                                  
 31693                                  $P_Time_2412:				;AN000;
 31694 00004B86 50                      	push	ax			;AN000;
 31695 00004B87 56                      	push	si			;AN000;
 31696                                  $P_T12_Loop:				;AN000;
 31697 00004B88 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31698 00004B8B 46                      	inc	si			;AN000;     si
 31699 00004B8C 08C0                    	or	al,al			;AN000;       to
 31700 00004B8E 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31701                                  
 31702 00004B90 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31703                                  	;or	al,20h
 31704 00004B94 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31705 00004B96 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31706 00004B98 7425                    	je	short $P_T1200		;AN000;
 31707                                  
 31708 00004B9A 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31709 00004B9C 7413                    	je	short $P_T1201		;AN000;
 31710                                  
 31711 00004B9E 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31712 00004BA0 751A                    	jne	short $P_T12_Exit	;AN000;
 31713                                  
 31714 00004BA2 4E                      	dec	si			;AN000;
 31715 00004BA3 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31716                                  	;or	al,20h
 31717 00004BA7 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31718 00004BA9 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31719 00004BAB 7412                    	je	short $P_T1200		;AN000;
 31720                                  
 31721 00004BAD 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31722                                  	;je	short $P_T1201		;AN000; go process "a"
 31723                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31724                                  	; 05/04/2023
 31725 00004BAF 750B                    	jne	short $P_T12_Exit
 31726                                  
 31727                                  ;$P_T1200:				;AN000; "P" found
 31728                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31729                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31730                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31731                                  
 31732                                  $P_T1201:				;AN000; "A" found
 31733                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31734 00004BB1 2E800E[FD85]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31735                                  $P_Tclr_chr:				;AN038;
 31736 00004BB7 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31737                                  $P_T12_Exit:				;AN000;
 31738 00004BBC 5E                      	pop	si			;AN000;
 31739 00004BBD 58                      	pop	ax			;AN000;
 31740 00004BBE C3                      	retn				;AN000;
 31741                                  
 31742                                  	; 05/04/2023
 31743                                  $P_T1200:				;AN000; "P" found
 31744                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31745 00004BBF 2E800E[FE85]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31746 00004BC5 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31747                                  
 31748                                  ;***********************************************************************
 31749                                  ; $P_File_Format;
 31750                                  ;
 31751                                  ; Function:  Check if the input string is valid file spec format.
 31752                                  ;	     And set the result buffer.
 31753                                  ;
 31754                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31755                                  ;	     ES:BX -> CONTROL block
 31756                                  ;
 31757                                  ; Output:    None
 31758                                  ;
 31759                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31760                                  ;
 31761                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31762                                  ;	$P_SaveSI_Cmpx(R)
 31763                                  ;***********************************************************************
 31764                                  
 31765                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31766                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31767                                  $P_File_Format:
 31768 00004BC7 50                      	push	ax			;AN000;
 31769 00004BC8 57                      	push	di			;AN000;
 31770 00004BC9 56                      	push	si			;AN000;
 31771 00004BCA 2E8B3E[FF85]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31772 00004BCF 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31773 00004BD2 08C0                    	or	al,al			;AN000; end of line ?
 31774 00004BD4 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31775 00004BD6 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31776 00004BD9 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31777 00004BDB 2EC606[CB86]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31778                                  					;AN033;AC034;; set error flag- bad char.
 31779 00004BE1 5E                      	pop	si			;AN033;
 31780 00004BE2 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31781 00004BE6 5F                      	pop	di			;AN033;
 31782 00004BE7 EB3E                    	jmp	short $P_FileF02	;AN033;
 31783                                  $P_FileF_Err:				;AN000;
 31784 00004BE9 5E                      	pop	si			;AN000;
 31785 00004BEA 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31786 00004BEE 5F                      	pop	di			;AN000;
 31787                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31788                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31789 00004BEF 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31790 00004BF3 7532                    	jnz	short $P_FileF02	;AN000;
 31791 00004BF5 2EC706[F285]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31792                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31793 00004BFC EB29                    	jmp	short $P_FileF02	;AN000;
 31794                                  $P_FileF03:				;AN000;
 31795 00004BFE 58                      	pop	ax			;AN000; discard save si
 31796 00004BFF 56                      	push	si			;AN000; save new si
 31797                                  $P_FileF_Loop1: 			;AN000;
 31798 00004C00 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31799 00004C03 08C0                    	or	al,al			;AN000; end of line ?
 31800 00004C05 741E                    	jz	short $P_FileF_RLT	;AN000;
 31801 00004C07 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31802 00004C0A 740B                    	jz	short $P_FileF00	;AN000;
 31803 00004C0C E85C01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31804 00004C0F 7302                    	jnc	short $P_FileF01	;AN000;
 31805 00004C11 47                      	inc	di			;AN000; if yes, skip next byte
 31806 00004C12 46                      	inc	si			;AN000;
 31807                                  $P_FileF01:				;AN000;
 31808 00004C13 47                      	inc	di			;AN000;
 31809 00004C14 46                      	inc	si			;AN000;
 31810 00004C15 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31811                                  $P_FileF00:				;AN000;
 31812 00004C17 2EA2[F885]              	mov	[cs:$P_Terminator],al	;AC034;
 31813 00004C1B 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31814 00004C1F 47                      	inc	di			;AN000;
 31815 00004C20 2E893E[F485]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31816                                  $P_FileF_RLT:				;AN000;
 31817 00004C25 5E                      	pop	si			;AN000;
 31818 00004C26 5F                      	pop	di			;AN000;
 31819                                  $P_FileF02:				;AN000;
 31820 00004C27 58                      	pop	ax			;AN000; (tm14)
 31821                                  	;;test	ax,200h
 31822                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31823                                  	; 05/04/2023
 31824 00004C28 F6C402                  	test	ah,($P_File_Spc>>8)
 31825 00004C2B 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31826 00004C2D 50                      	push	ax			;AN000; (tm14)
 31827                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31828                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31829                                  	; 05/04/2023
 31830 00004C2E B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31831 00004C31 E825F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31832 00004C34 58                      	pop	ax			;AN000;
 31833                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31834 00004C35 C3                      	retn				;AN000;
 31835                                  
 31836                                  ;***********************************************************************
 31837                                  ; $P_FileSp_Chk
 31838                                  ;
 31839                                  ; Function:  Check if the input byte is one of file special characters
 31840                                  ;
 31841                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31842                                  ;	     AL = character code to be examineed
 31843                                  ;
 31844                                  ; Output:    ZF = 1 , AL is one of special characters
 31845                                  ;***********************************************************************
 31846                                  
 31847                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31848                                  $P_FileSp_Chk:
 31849 00004C36 53                      	push	bx			;AN000;
 31850 00004C37 51                      	push	cx			;AN000;
 31851                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31852 00004C38 8D1E[C286]              	lea	bx,$P_FileSp_Char
 31853 00004C3C B90900                  	mov	cx,$P_FileSp_Len ; 9
 31854                                  	;mov	cx,9			;AN000; load length of it
 31855                                  $P_FileSp_Loop: 			;AN000;
 31856 00004C3F 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31857 00004C42 7404                    	je	short $P_FileSp_Exit	;AN000;
 31858 00004C44 43                      	inc	bx			;AN000;
 31859 00004C45 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31860 00004C47 41                      	inc	cx			;AN000; reset ZF
 31861                                  $P_FileSp_Exit: 			;AN000;
 31862 00004C48 59                      	pop	cx			;AN000;
 31863 00004C49 5B                      	pop	bx			;AN000;
 31864 00004C4A C3                      	retn				;AN000;
 31865                                  
 31866                                  ;***********************************************************************
 31867                                  ; $P_Drive_Format;
 31868                                  ;
 31869                                  ; Function:  Check if the input string is valid drive only format.
 31870                                  ;	     And set the result buffer.
 31871                                  ;
 31872                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31873                                  ;	     ES:BX -> CONTROL block
 31874                                  ;
 31875                                  ; Output:    None
 31876                                  ;
 31877                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31878                                  ;
 31879                                  ; Vars: $P_RC(W)
 31880                                  ;***********************************************************************
 31881                                  
 31882                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31883                                  $P_Drive_Format:
 31884 00004C4B 50                      	push	ax			;AN000;
 31885 00004C4C 52                      	push	dx			;AN000;
 31886 00004C4D 2E8A04                  	mov	al,[cs:si]		;AN000;
 31887 00004C50 08C0                    	or	al,al			;AN000; if null string
 31888 00004C52 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31889 00004C54 E81401                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31890 00004C57 722A                    	jc	short $P_Drv_Err	;AN000;
 31891                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31892 00004C59 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31893 00004C5E 740D                    	je	short $P_DrvF00		;AN000;
 31894                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31895                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31896 00004C60 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31897 00004C64 741D                    	jz	short $P_Drv_Err	;AN000;
 31898 00004C66 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31899 00004C6B 7516                    	jne	short $P_Drv_Err	;AN000;
 31900                                  $P_DrvF00:				;AN000;
 31901 00004C6D 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31902 00004C6F 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31903 00004C71 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31904 00004C73 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31905 00004C75 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31906 00004C77 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31907 00004C79 88C2                    	mov	dl,al			;AN000; set
 31908                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31909                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31910                                  	; 05/04/2023
 31911 00004C7B B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31912 00004C7E E8D8F8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31913 00004C81 EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31914                                  $P_Drv_Err:				;AN000;
 31915 00004C83 2EC706[F285]0900        	mov	word [cs:$P_RC],$P_Syntax
 31916                                  	;mov	word [cs:$P_RC],9	;AC034;
 31917                                  $P_Drv_Exit:				;AN000;
 31918 00004C8A 5A                      	pop	dx			;AN000;
 31919 00004C8B 58                      	pop	ax			;AN000;
 31920 00004C8C C3                      	retn				;AN000;
 31921                                  
 31922                                  ;***********************************************************************
 31923                                  ; $P_Skip_Delim;
 31924                                  ;
 31925                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31926                                  ;	    and comma.
 31927                                  ;
 31928                                  ; Input:    DS:SI -> Command String
 31929                                  ;	    ES:DI -> Parameter List
 31930                                  ;
 31931                                  ; Output:   CY = 1 if the end of line encounterd
 31932                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31933                                  ;	    AL = Last examineed character
 31934                                  ;
 31935                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31936                                  ;
 31937                                  ; Vars:     $P_Flags(R)
 31938                                  ;***********************************************************************
 31939                                  
 31940                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31941                                  
 31942                                  $P_Skip_Delim:				;AN000;
 31943                                  $P_Skip_Delim_Loop:			;AN000;
 31944 00004C8D AC                      	lodsb				;AN000;
 31945 00004C8E E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31946 00004C91 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31947                                  
 31948 00004C93 E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31949 00004C96 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31950                                  
 31951 00004C98 2EF606[FE85]20          	test	byte [cs:$P_Flags2],$P_Extra
 31952                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31953 00004C9E 74ED                    	jz	short $P_Skip_Delim_Loop
 31954                                  					;AN000; if no, loop
 31955 00004CA0 2EF606[FE85]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31956                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31957                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31958                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31959                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31960                                  	; 05/04/2023
 31961 00004CA6 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31962                                  $P_Exit_At_Extra:			;AN000;
 31963                                  	; cf = 0
 31964                                  	;clc				;AN000; indicate extra delim
 31965 00004CA8 C3                      	retn				;AN000;
 31966                                  
 31967                                  $P_Skip_Delim_CY:			;AN000;
 31968 00004CA9 F9                      	stc				;AN000; indicate EOL
 31969 00004CAA EB01                    	jmp	short $P_Skip_Delim_Exit
 31970                                  					;AN000;
 31971                                  $P_Skip_Delim_NCY:			;AN000;
 31972 00004CAC F8                      	clc				;AN000; indicate non delim
 31973                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31974 00004CAD 4E                      	dec	si ; *			;AN000;  backup index pointer
 31975 00004CAE C3                      	retn				;AN000;
 31976                                  	; 05/04/2023
 31977                                  ;$P_Exit_At_Extra:			;AN000;
 31978                                  	;clc				;AN000; indicate extra delim
 31979                                  	;retn				;AN000;
 31980                                  
 31981                                  ;***********************************************************************
 31982                                  ; $P_Chk_EOL;
 31983                                  ;
 31984                                  ; Function: Check if AL is one of End of Line characters.
 31985                                  ;
 31986                                  ; Input:    AL = character code
 31987                                  ;	    ES:DI -> Parameter List
 31988                                  ;
 31989                                  ; Output:   ZF = 1 if one of End of Line characters
 31990                                  ;***********************************************************************
 31991                                  
 31992                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31993                                  
 31994                                  $P_Chk_EOL:
 31995 00004CAF 53                      	push	bx			;AN000;
 31996 00004CB0 51                      	push	cx			;AN000;
 31997 00004CB1 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31998 00004CB3 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31999 00004CB5 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 32000 00004CB7 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32001 00004CB9 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 32002                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 32003 00004CBE 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 32004 00004CC0 31DB                    	xor	bx,bx			;AN000;
 32005 00004CC2 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32006                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 32007 00004CC6 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 32008 00004CC9 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 32009                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 32010 00004CCD 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 32011 00004CCF 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 32012 00004CD1 268A09                  	mov	cl,[es:bx+di]		;AN000;
 32013                                  $P_Chk_EOL_Loop:			;AN000;
 32014 00004CD4 43                      	inc	bx			;AN000;
 32015 00004CD5 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 32016 00004CD8 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32017 00004CDA E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 32018                                  $P_Chk_EOL_NZ:				;AN000;
 32019 00004CDC 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 32020                                  $P_Chk_EOL_Exit:			;AN000;
 32021 00004CDE 59                      	pop	cx			;AN000;
 32022 00004CDF 5B                      	pop	bx			;AN000;
 32023 00004CE0 C3                      	retn				;AN000;
 32024                                  
 32025                                  ;***********************************************************************
 32026                                  ; $P_Chk_Delim;
 32027                                  ;
 32028                                  ; Function: Check if AL is one of delimiter characters.
 32029                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 32030                                  ;	    blanks.
 32031                                  ;
 32032                                  ; Input:    AL = character code
 32033                                  ;	    DS:SI -> Next Character
 32034                                  ;	    ES:DI -> Parameter List
 32035                                  ;
 32036                                  ; Output:   ZF = 1 if one of delimiter characters
 32037                                  ;	    SI points to the next character
 32038                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 32039                                  ;***********************************************************************
 32040                                  
 32041                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32042                                  	; 12/08/2024
 32043                                  $P_Chk_Delim:
 32044 00004CE1 53                      	push	bx			;AN000;
 32045 00004CE2 51                      	push	cx			;AN000;
 32046 00004CE3 2EC606[F885]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 32047                                  					;AC034; Assume terminated by space
 32048 00004CE9 2E8026[FE85]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 32049                                  					;AC034;
 32050 00004CEF 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 32051 00004CF1 7434                    	je	short $P_Chk_Delim_Exit	;AN000;
 32052                                  
 32053 00004CF3 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 32054 00004CF5 7430                    	je	short $P_Chk_Delim_Exit	;AN000;
 32055                                  
 32056 00004CF7 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 32057 00004CF9 742F                    	je	short $P_Chk_Delim_Exit0
 32058                                  					;AN000;
 32059                                  $P_Chk_Delim00: 			;AN000;
 32060 00004CFB 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 32061 00004CFD 750C                    	jne	short $P_Chk_Delim01	;AN000;
 32062 00004CFF 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 32063                                  					;AN000; 2nd byte of DBCS Space ?
 32064 00004D02 7507                    	jne	short $P_Chk_Delim01	;AN000;
 32065 00004D04 B020                    	mov	al,$P_Space ; 20h	;AN000;
 32066 00004D06 46                      	inc	si			;AN000; make si point to next character
 32067 00004D07 38C0                    	cmp	al,al			;AN000; Set ZF
 32068 00004D09 EB1C                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32069                                  
 32070                                  $P_Chk_Delim01: 			;AN000;
 32071                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 32072 00004D0B 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 32073                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 32074 00004D10 7215                    	jb	short $P_Chk_Delim_Exit	;AN000;
 32075                                  
 32076 00004D12 31C9                    	xor	cx,cx			;AN000;
 32077 00004D14 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32078                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 32079                                  	;or	cx,cx			;AN000; No extra Delim character ?
 32080                                  	;jz	short $P_Chk_Delim_NZ	;AN000;
 32081                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 32082 00004D18 E30B                    	jcxz	$P_Chk_Delim_NZ
 32083                                  
 32084 00004D1A BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 32085                                  $P_Chk_Delim_Loop:			;AN000;
 32086 00004D1D 43                      	inc	bx			;AN000;
 32087 00004D1E 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 32088 00004D21 7407                    	je	short $P_Chk_Delim_Exit0
 32089                                  					;AN000;
 32090 00004D23 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 32091                                  
 32092                                  $P_Chk_Delim_NZ:			;AN000;
 32093 00004D25 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 32094                                  $P_Chk_Delim_Exit:			;AN000;
 32095 00004D27 59                      	pop	cx			;AN000;
 32096 00004D28 5B                      	pop	bx			;AN000;
 32097 00004D29 C3                      	retn				;AN000;
 32098                                  
 32099                                  $P_Chk_Delim_Exit0:			;AN000;
 32100 00004D2A 2EA2[F885]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 32101 00004D2E 2EF606[FE85]01          	test	byte [cs:$P_Flags2],$P_equ
 32102                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 32103 00004D34 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 32104                                  
 32105 00004D36 2E800E[FE85]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 32106                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 32107                                  $P_No_Set_Extra:			;AN027;
 32108 00004D3C 38C0                    	cmp	al,al			;AN000; set ZF
 32109 00004D3E EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32110                                  
 32111                                  ;***********************************************************************
 32112                                  ; $P_Chk_Switch;
 32113                                  ;
 32114                                  ; Function: Check if AL is the switch character not in first position of
 32115                                  ;	    $P_STRING_BUF
 32116                                  ;
 32117                                  ; Input:    AL = character code
 32118                                  ;	    BX = current pointer within $P_String_Buf
 32119                                  ;	    SI =>next char on command line (following the one in AL)
 32120                                  ;
 32121                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 32122                                  ;		 position, and has no chance of being part of a date string,
 32123                                  ;		 i.e. should be treated as a delimiter.
 32124                                  ;
 32125                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 32126                                  ;		 position, or is a slash but may be part of a date string, i.e.
 32127                                  ;		 should not be treated as a delimiter.
 32128                                  ;
 32129                                  ; Vars:  $P_Terminator(W)
 32130                                  ;
 32131                                  ; Use:	 $P_0099
 32132                                  ;***********************************************************************
 32133                                  
 32134                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32135                                  
 32136                                  $P_Chk_Switch:
 32137                                  	; 18/04/2023
 32138 00004D40 8D2E[0786]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 32139                                  
 32140 00004D44 39EB                    	cmp	bx,bp			;AN000;
 32141 00004D46 7418                    	je	short $P_STRUC_L2	;AN000;
 32142                                  
 32143 00004D48 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32144 00004D4A 7512                    	jne	short $P_STRUC_L5	;AN000;
 32145                                  
 32146 00004D4C F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 32147 00004D4D 50                      	push	ax			;AN020;save input char
 32148 00004D4E 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 32149 00004D52 E801FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 32150 00004D55 7205                    	jc	short $P_STRUC_L7	;AN000;
 32151                                  
 32152 00004D57 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 32153 00004D59 E8FAFA                  	call	$P_0099			;AN020;return carry set if not numeric
 32154                                  $P_STRUC_L7:				;AN000;
 32155 00004D5C 58                      	pop	ax			;AN020;restore AL to input char
 32156                                  	;jmp	short $P_STRUC_L1	;AN000;
 32157                                  	; 18/04/2023
 32158 00004D5D C3                      	retn
 32159                                  
 32160                                  $P_STRUC_L5:				;AN000;
 32161 00004D5E F8                      	clc				;AN020;not a slash
 32162                                  	;jmp	short $P_STRUC_L1	;AN000;
 32163                                  	 ;18/04/2023
 32164 00004D5F C3                      	retn
 32165                                  
 32166                                  $P_STRUC_L2:				;AN000;
 32167 00004D60 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32168                                  	;jne	short $P_STRUC_L12	;AN000;
 32169                                  	; 18/04/2023
 32170 00004D62 75FA                    	jne	short $P_STRUC_L5
 32171                                  
 32172 00004D64 2E800E[FE85]40          	or	byte [cs:$P_Flags2],$P_SW
 32173                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 32174                                  	; 18/04/2023
 32175                                  ;$P_STRUC_L12:				;AN000;
 32176                                  	;clc				;AN020;CF=0 indicating first char
 32177                                  $P_STRUC_L1:				;AN000;
 32178 00004D6A C3                      	retn				;AN000;
 32179                                  
 32180                                  ;**************************************************************************
 32181                                  ; $P_Chk_DBCS:
 32182                                  ;
 32183                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 32184                                  ;
 32185                                  ;  Input:
 32186                                  ;	  AL	= Code to be examineed
 32187                                  ;
 32188                                  ;  Output:
 32189                                  ;	  If CF is on then a lead byte of DBCS
 32190                                  ;
 32191                                  ; Use: INT 21h w/AH=63
 32192                                  ;
 32193                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 32194                                  ;***************************************************************************
 32195                                  
 32196                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32197                                  	; 12/08/2024
 32198                                  $P_Chk_DBCS:
 32199 00004D6B 1E                      	push	ds			;AN000;
 32200 00004D6C 56                      	push	si			;AN000;
 32201 00004D6D 53                      	push	bx			;AN000; (tm11)
 32202 00004D6E 2E833E[FB85]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 32203                                  					;AC034; ALREADY SET ?
 32204 00004D74 7527                    	jne	short $P_DBCS00		;AN000;
 32205 00004D76 50                      	push	ax			;AN000;
 32206 00004D77 1E                      	push	ds			;AN000; (tm11)
 32207 00004D78 51                      	push	cx			;AN000;
 32208 00004D79 52                      	push	dx			;AN000;
 32209 00004D7A 57                      	push	di			;AN000;
 32210 00004D7B 55                      	push	bp			;AN000;
 32211 00004D7C 06                      	push	es			;AN000;
 32212 00004D7D 31F6                    	xor	si,si			;AN000;
 32213 00004D7F 8EDE                    	mov	ds,si			;AN000;
 32214                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 32215 00004D81 B80063                  	mov	ax,6300h
 32216 00004D84 CD21                    	int	21h			;AN000;
 32217 00004D86 8CDB                    	mov	bx,ds			;AN000; (tm11)
 32218 00004D88 09DB                    	or	bx,bx			;AN000; (tm11)
 32219 00004D8A 07                      	pop	es			;AN000;
 32220 00004D8B 5D                      	pop	bp			;AN000;
 32221 00004D8C 5F                      	pop	di			;AN000;
 32222 00004D8D 5A                      	pop	dx			;AN000;
 32223 00004D8E 59                      	pop	cx			;AN000;
 32224 00004D8F 1F                      	pop	ds			;AN000; (tm11)
 32225 00004D90 58                      	pop	ax			;AN000;
 32226 00004D91 7424                    	jz	short $P_NON_DBCS	;AN000;
 32227                                  $P_DBCS02:				;AN000;
 32228 00004D93 2E8936[F985]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 32229 00004D98 2E891E[FB85]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 32230                                  $P_DBCS00:				;AN000;
 32231                                  	;mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 32232                                  	;mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 32233                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 32234 00004D9D 2EC536[F985]            	lds	si,[cs:$P_DBCSEV_OFF]
 32235                                  $P_DBCS_LOOP:				;AN000;
 32236 00004DA2 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 32237 00004DA5 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 32238 00004DA7 3A04                    	cmp	al,[si] 		;AN000;
 32239 00004DA9 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 32240 00004DAB 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 32241 00004DAE 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 32242 00004DB0 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 32243 00004DB1 EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 32244                                  $P_DBCS01:				;AN000;
 32245 00004DB3 46                      	inc	si			;AC035; add '2' to
 32246 00004DB4 46                      	inc	si			;AC035;  SI reg
 32247                                  					;AN000; get next vector
 32248 00004DB5 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 32249                                  
 32250                                  $P_NON_DBCS:				;AN000;
 32251                                  	; 18/04/2023
 32252                                  	; cf=0
 32253                                  	;clc				;AN000; indicate SBCS
 32254                                  $P_DBCS_EXIT:				;AN000;
 32255 00004DB7 5B                      	pop	bx			;AN000; (tm11)
 32256 00004DB8 5E                      	pop	si			;AN000;
 32257 00004DB9 1F                      	pop	ds			;AN000;
 32258 00004DBA C3                      	retn				;AN000;
 32259                                  
 32260                                  ;============================================================================
 32261                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 32262                                  ;============================================================================
 32263                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32264                                  
 32265                                  ; ****************************************************************
 32266                                  ; *
 32267                                  ; * ROUTINE:	 CMD_PARSE
 32268                                  ; *
 32269                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 32270                                  ; *		 SYSPARSE.
 32271                                  ; *
 32272                                  ; * INPUT:	 inputs to SYSPARSE
 32273                                  ; *
 32274                                  ; * OUTPUT:	 outputs from SYSPARSE
 32275                                  ; *
 32276                                  ; ****************************************************************
 32277                                  
 32278                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32279                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 32280                                  ;cmd_parse:
 32281                                  	;call	sysparse		;AN000;
 32282                                  	;retn				;AN000;
 32283                                  	; 06/04/2023
 32284                                  	;jmp	sysparse
 32285                                  
 32286                                  append_parse:
 32287 00004DBB E85DF5                  	call	sysparse		;AN010;
 32288 00004DBE CB                      	retf				;AN010;
 32289                                  
 32290                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32291                                  %if 0
 32292                                  
 32293                                  ;============================================================================
 32294                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 32295                                  ;============================================================================
 32296                                  ; 30/09/2018 - Retro DOS v3.0
 32297                                  
 32298                                  ; BREAK	<Message Printing Routine>
 32299                                  
 32300                                  ;
 32301                                  ;	MSDOS V3.00 PRINT
 32302                                  ;
 32303                                  ;	Message Printing Routine
 32304                                  ;
 32305                                  
 32306                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 32307                                  ;
 32308                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 32309                                  ;
 32310                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 32311                                  ;
 32312                                  ; Characters are output to PFHandle according to the
 32313                                  ; specifications contained in the Control String.
 32314                                  ;
 32315                                  ; The conversion characters are as follow:
 32316                                  ;
 32317                                  ;               %c - output the next argument as a character
 32318                                  ;               %s - output the next argument as a string
 32319                                  ;               %x - output the next argument as a hexidecimal number
 32320                                  ;                    using abcedf
 32321                                  ;               %X - output the next argument as a hexidecimal number
 32322                                  ;                    using ABCDEF
 32323                                  ;               %d - output the next argument as a decimal number
 32324                                  ;
 32325                                  ;
 32326                                  ; Other format specifiers that may precede the conversion character are:
 32327                                  ;
 32328                                  ;               - (minus sign) - causes the field to be left-adjusted
 32329                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 32330                                  ;               n - digit specifing the minimum field width (default to 1)
 32331                                  ;               L - specifing a long integer
 32332                                  ;
 32333                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 32334                                  ;   to an argument list.
 32335                                  ;
 32336                                  ;   ____________________
 32337                                  ;   |   Ret Addr       |      <= SP
 32338                                  ;   --------------------
 32339                                  ;   |  Ptr to Arg List |
 32340                                  ;   --------------------
 32341                                  ;
 32342                                  ;   And the argument list contains the following:
 32343                                  ;
 32344                                  ;       String_ptr                  (a pointer to the control string)
 32345                                  ;       Arg 1
 32346                                  ;       Arg 2
 32347                                  ;         .
 32348                                  ;         .
 32349                                  ;         .
 32350                                  ;       Arg n-1
 32351                                  ;       Arg n
 32352                                  ;
 32353                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 32354                                  ;   or character.
 32355                                  ;
 32356                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 32357                                  
 32358                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 32359                                  
 32360                                  ; =============== S U B	R O U T	I N E =======================================
 32361                                  
 32362                                  PRINTF_INIT:
 32363                                  	call	STD_PRINTF
 32364                                  	retf
 32365                                  
 32366                                  ; =============== S U B	R O U T	I N E =======================================
 32367                                  
 32368                                  PRINTF_CRLF:
 32369                                  	call	STD_PRINTF
 32370                                  	;call	CRLF2
 32371                                  	;retn
 32372                                  	; 07/04/2023
 32373                                  	jmp	CRLF2
 32374                                  
 32375                                  ; =============== S U B	R O U T	I N E =======================================
 32376                                  
 32377                                  STD_EPRINTF:
 32378                                  	mov	word [cs:PRINTF_HANDLE],2
 32379                                  	jmp	short new_printf
 32380                                  
 32381                                  ; =============== S U B	R O U T	I N E =======================================
 32382                                  
 32383                                  STD_PRINTF:
 32384                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 32385                                  
 32386                                  	mov	word [cs:PRINTF_HANDLE],1
 32387                                  NEW_PRINTF:				;Save the callers' registers
 32388                                  	cld
 32389                                  	push	dx
 32390                                  	push	bp
 32391                                  	mov	bp,sp
 32392                                  	push	cx
 32393                                  	push	bx
 32394                                  	push	ax
 32395                                  	push	di
 32396                                  	push	si
 32397                                  	push	es
 32398                                  	push	ds
 32399                                  	push	cs
 32400                                  	pop	es		;ES points to Printf segment
 32401                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 32402                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 32403                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 32404                                  	mov	si,[ds:bp] ; bp
 32405                                  	add	bp,2
 32406                                  	xor	bx,bx
 32407                                  	call	CLEAR_FLAGS	; initialize the world
 32408                                  
 32409                                  GET_CHAR:
 32410                                  	lodsb			;Get a character
 32411                                  	cmp	al,'%'		;Is it a conversion specifier?
 32412                                  	jz	short CONV_CHAR	;Yes - find out which one
 32413                                  	or	al,al		;Is it the end of the control string?
 32414                                  	jz	short PRINTF_DONE ;Yes - then we're done
 32415                                  PRINTF_PERCENT:				
 32416                                  	call	OUTCHR		;Otherwise store the character
 32417                                  	jmp	short GET_CHAR	;And go get another
 32418                                  
 32419                                  PRINTF_DONE:
 32420                                  	call	FLUSH
 32421                                  	pop	ds
 32422                                  	pop	es
 32423                                  	pop	si
 32424                                  	pop	di
 32425                                  	pop	ax
 32426                                  	pop	bx
 32427                                  	pop	cx
 32428                                  	pop	bp
 32429                                  	pop	dx
 32430                                  	retn
 32431                                  
 32432                                  CONV_CHAR:
 32433                                  	mov	byte [cs:PRINTF_LEFT],0
 32434                                  
 32435                                  NXT_CONV_CHAR:	
 32436                                  	;Look for any format specifiers preceeding the conversion character
 32437                                  	lodsb
 32438                                  	cmp	al,'%'			;Just print the %
 32439                                  	jz	short PRINTF_PERCENT
 32440                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 32441                                  	jz	short LEFT_ADJ
 32442                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 32443                                  	jz	short CONV_CHAR
 32444                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 32445                                  	jz	short LONG_INT
 32446                                  	cmp	al,[cs:char_l]	 ; "l"		
 32447                                  	jz	short LONG_INT
 32448                                  	cmp	al,'0'			;Is it a precision specification
 32449                                  	jb	short LOOK_CONV_CHAR
 32450                                  	cmp	al,'9'
 32451                                  	ja	short LOOK_CONV_CHAR
 32452                                  	cmp	al,'0'
 32453                                  	jnz	short NOT_PAD
 32454                                  	cmp	word [cs:PRINTF_WIDTH],0
 32455                                  	jnz	short NOT_PAD
 32456                                  	mov	ah,'0'
 32457                                  	mov	[cs:PAD_CHAR],ah
 32458                                  NOT_PAD:					;Adjust decimal place on precision
 32459                                  	push	ax
 32460                                  	mov	ax,[cs:PRINTF_WIDTH]
 32461                                  	mov	cx,10
 32462                                  	mul	cx
 32463                                  	pop	dx
 32464                                  	xor	dh,dh
 32465                                  	sub	dl,'0'
 32466                                  	add	ax,dx
 32467                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 32468                                  	jmp	short NXT_CONV_CHAR
 32469                                  
 32470                                  LEFT_ADJ:
 32471                                  	mov	byte [cs:PRINTF_LEFT],1
 32472                                  	jmp	short NXT_CONV_CHAR
 32473                                  
 32474                                  LONG_INT:
 32475                                  	or	byte [cs:PRINTF_LONG],1
 32476                                  	jmp	short NXT_CONV_CHAR
 32477                                  
 32478                                  LOOK_CONV_CHAR:
 32479                                  	and	al,0DFh
 32480                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 32481                                  	jz	short HEX_UP
 32482                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 32483                                  	jz	short DECIMAL
 32484                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 32485                                  	jz	short C_PUT_CHAR
 32486                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 32487                                  	jz	short S_PUT_STRG
 32488                                  	call	CLEAR_FLAGS
 32489                                  	jmp	GET_CHAR
 32490                                  
 32491                                  HEX_UP:
 32492                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 32493                                  	jmp	short CONV_TO_NUM
 32494                                  DECIMAL:
 32495                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 32496                                  	jmp	short CONV_TO_NUM
 32497                                  
 32498                                  C_PUT_CHAR:
 32499                                  	call	NEXT_CHRS
 32500                                  	mov	al,dl
 32501                                  	call	OUTCHR
 32502                                  	call	CLEAR_FLAGS
 32503                                  	jmp	GET_CHAR
 32504                                  
 32505                                  S_PUT_STRG:
 32506                                  	push	si			;Save pointer to control string
 32507                                  	call	NEXT_CHRS
 32508                                  	mov	si,dx
 32509                                  S_PUT_1:
 32510                                  	mov	cx,[cs:PRINTF_WIDTH]
 32511                                  	or	cx,cx
 32512                                  	jz	short S_PUT_2
 32513                                  	cmp	byte [cs:PRINTF_LEFT],0
 32514                                  	jnz	short S_PUT_2
 32515                                  	call	PAD_STRING
 32516                                  S_PUT_2:
 32517                                  	push	si
 32518                                  S_PUT_3:
 32519                                  	lodsb
 32520                                  	or	al,al
 32521                                  	jz	short S_PUT_4
 32522                                  	call	OUTCHR			;Put it into our buffer
 32523                                  	jmp	short S_PUT_3
 32524                                  S_PUT_4:
 32525                                  	pop	si
 32526                                  	cmp	byte [cs:PRINTF_LEFT],0
 32527                                  	jz	short C_S_END
 32528                                  	mov	cx,[cs:PRINTF_WIDTH]
 32529                                  	or	cx,cx
 32530                                  	jz	short C_S_END
 32531                                  	call	PAD_STRING
 32532                                  C_S_END:
 32533                                  	pop	si			;Restore control string pointer
 32534                                  	call	CLEAR_FLAGS
 32535                                  	jmp	GET_CHAR		;Go get another character	
 32536                                  
 32537                                  
 32538                                  ; =============== S U B	R O U T	I N E =======================================
 32539                                  
 32540                                  PAD_STRING:
 32541                                  	xor	dx,dx
 32542                                  	push	si
 32543                                  
 32544                                  COUNT_LOOP:
 32545                                  	lodsb
 32546                                  	or	al,al
 32547                                  	jz	short COUNT_DONE
 32548                                  	inc	dx
 32549                                  	jmp	short COUNT_LOOP
 32550                                  
 32551                                  COUNT_DONE:
 32552                                  	pop	si
 32553                                  	sub	cx,dx
 32554                                  	jbe	short COUNT_RET
 32555                                  	call	PAD
 32556                                  
 32557                                  COUNT_RET:
 32558                                  	retn
 32559                                  
 32560                                  ; ---------------------------------------------------------------------------
 32561                                  
 32562                                  CONV_TO_NUM:
 32563                                  	call	NEXT_CHRS
 32564                                  	mov	ax,dx
 32565                                  	xor	dx,dx
 32566                                  	cmp	byte [cs:PRINTF_LONG],0 
 32567                                  			;Is this is a short or long integer?
 32568                                  	jz	short NOT_LONG_INT
 32569                                  	call	NEXT_CHRS
 32570                                  
 32571                                  NOT_LONG_INT:
 32572                                  	push	bx
 32573                                  	push	si
 32574                                  	mov	si,[cs:PRINTF_BASE]
 32575                                  	mov	cx,[cs:PRINTF_WIDTH]
 32576                                  	call	PNUM
 32577                                  	pop	si
 32578                                  	pop	bx
 32579                                  	call	PAD
 32580                                  	call	CLEAR_FLAGS
 32581                                  	jmp	GET_CHAR
 32582                                  
 32583                                  
 32584                                  ; =============== S U B	R O U T	I N E =======================================
 32585                                  
 32586                                  PNUM:
 32587                                  	dec	cx
 32588                                  	push	ax
 32589                                  	mov	ax,dx
 32590                                  	xor	dx,dx
 32591                                  	div	si
 32592                                  	mov	bx,ax
 32593                                  	pop	ax
 32594                                  	div	si
 32595                                  	xchg	bx,dx
 32596                                  	push	ax
 32597                                  	or	ax,dx
 32598                                  	pop	ax
 32599                                  	jz	short DO_PAD
 32600                                  	push	bx
 32601                                  	call	PNUM
 32602                                  	pop	bx
 32603                                  	jmp	short REM
 32604                                  
 32605                                  DO_PAD:
 32606                                  	cmp	byte [cs:PRINTF_LEFT],0
 32607                                  	jnz	short REM
 32608                                  	call	PAD
 32609                                  REM:
 32610                                  	cmp	bl,10
 32611                                  	jb	short NOT_HEX
 32612                                  	add	bx,6
 32613                                  NOT_HEX:
 32614                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32615                                  	push	cx
 32616                                  	call	OUTCHR
 32617                                  	pop	cx
 32618                                  	retn
 32619                                  
 32620                                  ; =============== S U B	R O U T	I N E =======================================
 32621                                  
 32622                                  PAD:
 32623                                  	or	cx,cx
 32624                                  	jle	short PAD_DONE
 32625                                  	mov	al,[cs:PAD_CHAR]
 32626                                  PAD_LOOP:
 32627                                  	push	cx
 32628                                  	call	OUTCHR
 32629                                  	pop	cx
 32630                                  	loop	PAD_LOOP
 32631                                  PAD_DONE:
 32632                                  	retn
 32633                                  
 32634                                  ; =============== S U B	R O U T	I N E =======================================
 32635                                  
 32636                                  OUTCHR:
 32637                                  	stosb
 32638                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32639                                  	je	short FLUSH
 32640                                  OUTCHR_RETN:
 32641                                  	retn
 32642                                  
 32643                                  ; =============== S U B	R O U T	I N E =======================================
 32644                                  
 32645                                  FLUSH:
 32646                                  	mov	cx,PRINTF_BUF
 32647                                  	xchg	cx,di
 32648                                  	sub	cx,di
 32649                                  	jz	short OUTCHR_RETN
 32650                                  WRITE_CHARS:
 32651                                  	push	bx
 32652                                  	mov	bx,[cs:PRINTF_HANDLE]
 32653                                  	push	ds
 32654                                  	push	cs
 32655                                  	pop	ds
 32656                                  	mov	dx,PRINTF_BUF
 32657                                  	mov	ah,Write ; 40h
 32658                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32659                                  				; BX = file handle, CX = number	of bytes to write,
 32660                                  				; DS:DX -> buffer
 32661                                  	jnb	short FOOB2_1
 32662                                  	call	GET_EXT_ERR_NUMBER
 32663                                  	cmp	ax,6
 32664                                  	jz	short FOOB2_4
 32665                                  	jmp	short FOOB2_2
 32666                                  
 32667                                  FOOB2_1:
 32668                                  	cmp	cx,ax
 32669                                  	jz	short FOOB2_4
 32670                                  FOOB2_2:
 32671                                  	mov	bx,dx
 32672                                  	add	bx,ax
 32673                                  	cmp	byte [bx],1Ah
 32674                                  	jz	short FOOB2_4
 32675                                  	pop	ds
 32676                                  	pop	bx
 32677                                  	mov	es,[cs:RESSEG]
 32678                                  	mov	dx,NOSPACEPTR
 32679                                  	test	byte [es:PIPEFLAG],0FFh
 32680                                  	jz	short PRINT_ERR_EXIT
 32681                                  	call	PIPEOFF
 32682                                  	mov	dx,PIPEEMESPTR
 32683                                  PRINT_ERR_EXIT:	
 32684                                  	jmp	CERROR
 32685                                  
 32686                                  FOOB2_4:
 32687                                  	pop	ds
 32688                                  	pop	bx
 32689                                  	retn
 32690                                  
 32691                                  ; =============== S U B	R O U T	I N E =======================================
 32692                                  
 32693                                  NEXT_CHRS:
 32694                                  	push	si		;Save pointer to control string
 32695                                  	mov	si,bx		;Get index into argument list
 32696                                  	add	bx,2		;Increment the index
 32697                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32698                                  	mov	dx,[si]		; Get (address of the) next argument			
 32699                                  	pop	si
 32700                                  	retn
 32701                                  
 32702                                  ; =============== S U B	R O U T	I N E =======================================
 32703                                  
 32704                                  CLEAR_FLAGS:
 32705                                  	xor	ax,ax
 32706                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32707                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32708                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32709                                  	mov	al,' '			
 32710                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32711                                  	retn
 32712                                  
 32713                                  ; ---------------------------------------------------------------------------
 32714                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32715                                  
 32716                                  	; times 7 db 0
 32717                                  
 32718                                  %endif
 32719                                  
 32720                                  ;============================================================================
 32721                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32722                                  ;============================================================================
 32723                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32724                                  
 32725                                  ; ----------------------------
 32726                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32727                                  ; ----------------------------
 32728                                  
 32729                                  ;; Replacable parameters are described by a sublist structure
 32730                                  
 32731                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32732 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32733 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32734 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32735 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32736 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32737 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32738 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32739 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32740                                  endstruc
 32741                                  
 32742                                  ; ---------------------------------------------------------------------------
 32743                                  ; ---------------------------------------------------------------------------
 32744                                  
 32745                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32746                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32747                                  
 32748                                  Printf_Init:
 32749 00004DBF E80F00                  	call	std_printf
 32750 00004DC2 CB                      	retf
 32751                                  
 32752                                  Printf_Crlf:
 32753 00004DC3 E80B00                  	call	std_printf
 32754                                  	;call	CRLF2
 32755                                  	;retn
 32756                                  	; 07/04/2023
 32757 00004DC6 E906D8                  	jmp	CRLF2
 32758                                  
 32759                                  
 32760                                  ;****************************************************************
 32761                                  ;*
 32762                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32763                                  ;*
 32764                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32765                                  ;*		Set up substitutions if utility message.  Make
 32766                                  ;*		sure any changes to message variables in TDATA
 32767                                  ;*		are reset to avoid reloading the transient.
 32768                                  ;*
 32769                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32770                                  ;*		Msg_Cont_Flag	-  set to control flags
 32771                                  ;*		DS	points to transient segment
 32772                                  ;*
 32773                                  ;*		if utility message:
 32774                                  ;*		DX	points to a block with message number
 32775                                  ;*			(word), number of substitutions (byte),
 32776                                  ;*			followed by substitution list if there
 32777                                  ;*			are substitutions.  If substitutions
 32778                                  ;*			are not in transient segment they must
 32779                                  ;*			be set.
 32780                                  ;*		else
 32781                                  ;*		AX	set to message number
 32782                                  ;*
 32783                                  ;* OUTPUT:	none
 32784                                  ;*
 32785                                  ;****************************************************************
 32786                                  
 32787                                  std_eprintf:
 32788 00004DC9 C706[D187]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32789 00004DCF EB06                    	jmp	short new_printf		;AC000;
 32790                                  
 32791                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32792                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32793                                  	; 15/06/2023
 32794                                  	; 12/08/2024
 32795                                  std_printf:
 32796 00004DD1 C706[D187]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32797                                  
 32798                                  new_printf:
 32799 00004DD7 50                      	push	ax				;AN000;save registers
 32800 00004DD8 53                      	push	bx				;AN000;
 32801 00004DD9 51                      	push	cx				;AN000;
 32802 00004DDA 06                      	push	es				;AN000;get local ES
 32803 00004DDB 1E                      	push	ds				;AN000;
 32804 00004DDC 07                      	pop	es				;AN000;
 32805 00004DDD 57                      	push	di				;AN000;
 32806 00004DDE 56                      	push	si				;AN000;
 32807 00004DDF 52                      	push	dx				;AN000;
 32808                                  
 32809                                  	; 07/04/2023
 32810                                  	;mov	word [print_err_flag],0		;AN000;
 32811 00004DE0 31C9                    	xor	cx,cx
 32812 00004DE2 890E[978D]              	mov	[print_err_flag],cx ; 0
 32813                                  
 32814 00004DE6 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32815 00004DE8 AD                      	lodsw					;AN000;load message number
 32816                                  	; 15/06/2023
 32817                                  	;push	ax				;AN000;save it
 32818                                  	;lodsb					;AN000;get number of substitutions
 32819                                  	;mov	cl,al				;AN000;set up CX as # of subst
 32820                                  	;; 07/04/2023
 32821                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 32822                                  	;pop	ax				;AN000;get message number back
 32823                                  	; 15/06/2023
 32824 00004DE9 8A0C                    	mov	cl,[si]
 32825 00004DEB 46                      	inc	si
 32826                                  	
 32827                                  	;cmp	cx,0				;AN000;Any substitutions?
 32828                                  	; 07/04/2023
 32829                                  	;and	cx,cx
 32830                                  	;jz	short ready_to_print		;AN000;No - continue
 32831                                  	; 12/08/2024
 32832 00004DEC E35C                    	jcxz	ready_to_print
 32833                                  
 32834 00004DEE BF[998D]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32835 00004DF1 57                      	push	di				;AN061; save it
 32836 00004DF2 51                      	push	cx				;AN061; save number of subst
 32837                                  
 32838                                  move_subst:
 32839 00004DF3 51                      	push	cx				;AN061;save number of subst
 32840 00004DF4 89F3                    	mov	bx,si				;AN061;save start of sublist
 32841                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32842                                  	; 07/04/2023
 32843 00004DF6 B10B                    	mov	cl,parm_block_size ; 11
 32844 00004DF8 F3A4                    	rep	movsb				;AN061;move sublist
 32845                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32846 00004DFA F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32847                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32848 00004DFE 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32849                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32850                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32851 00004E00 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32852                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32853                                  	;mov	word [bx+4],0			;AN061;
 32854 00004E03 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32855                                  
 32856                                  move_subst_cont:				;AN061;
 32857 00004E06 59                      	pop	cx				;AN061;get number of subst back
 32858 00004E07 E2EA                    	loop	move_subst			;AN061;move cx sublists
 32859                                  
 32860 00004E09 59                      	pop	cx				;AN061;get number of subst
 32861 00004E0A 50                      	push	ax				;AN061;save message number
 32862 00004E0B 803E[FA7E]FF            	cmp	byte [msg_disp_class],util_msg_class
 32863                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32864 00004E10 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32865                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32866 00004E12 C606[938D]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32867 00004E17 BF[FC7E]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32868 00004E1A 31C0                    	xor	ax,ax				;AN061;clear ax register
 32869 00004E1C AB                      	stosw					;AN061;clear out message number
 32870 00004E1D AA                      	stosb					;AN061;clear out subst count
 32871                                  
 32872                                  check_fix:					;AN061;
 32873 00004E1E 58                      	pop	ax				;AN061;get message number back
 32874 00004E1F 5F                      	pop	di				;AN061;get start of sublists
 32875 00004E20 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32876 00004E22 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32877 00004E24 51                      	push	cx				;AN061;save number of subst
 32878                                  
 32879                                  set_subst:					;AN061;store the segment of the subst
 32880 00004E25 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32881                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32882 00004E29 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32883 00004E2B F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32884                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32885                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32886 00004E2F 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32887 00004E31 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32888                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32889                                  
 32890                                  subst_seg_set:					;AN061;
 32891 00004E34 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32892 00004E37 E2EC                    	loop	set_subst			;AN061;loop CX times
 32893 00004E39 59                      	pop	cx				;AN061;get number of subst back
 32894                                  
 32895 00004E3A 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32896 00004E3C 817F02[118C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32897                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32898 00004E41 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32899                                  	; 01/05/2023
 32900 00004E43 8B16[118C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32901 00004E47 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32902                                  						;AN061;put it into the subst block
 32903                                  	;mov	[bx+2],dx
 32904                                  
 32905                                  ready_to_print:
 32906 00004E4A 8B1E[D187]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32907 00004E4E 8A16[FB7E]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32908 00004E52 8A36[FA7E]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32909 00004E56 C606[FB7E]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32910                                  						;AN061;reset flags to avoid
 32911 00004E5B C606[FA7E]FF            	mov	byte [msg_disp_class],util_msg_class
 32912                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32913                                  
 32914 00004E60 1E                      	push	ds				;AN026;
 32915 00004E61 06                      	push	es				;AN026;
 32916                                  
 32917 00004E62 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32918                                  
 32919 00004E65 07                      	pop	es				;AN026; restore registers
 32920 00004E66 1F                      	pop	ds				;AN026;
 32921                                  
 32922 00004E67 7303                    	jnc	short print_success		;AN000; everything went okay
 32923 00004E69 A3[978D]                	mov	[print_err_flag],ax		;AN000;
 32924                                  
 32925                                  print_success:
 32926 00004E6C 5A                      	pop	dx				;AN061;restore dx
 32927 00004E6D 5E                      	pop	si				;AN000;restore registers
 32928 00004E6E 5F                      	pop	di				;AN000;
 32929 00004E6F 07                      	pop	es				;AN000;restore registers
 32930 00004E70 59                      	pop	cx				;AN000;
 32931 00004E71 5B                      	pop	bx				;AN000;
 32932 00004E72 58                      	pop	ax				;AN000;
 32933 00004E73 833E[978D]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32934 00004E78 7501                    	jnz	short print_err			;AN000;
 32935                                  
 32936 00004E7A C3                      	retn					;AC000;
 32937                                  
 32938                                  print_err:
 32939 00004E7B 0E                      	push	cs
 32940 00004E7C 07                      	pop	es
 32941 00004E7D 833E[D187]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32942 00004E82 7503                    	jne	short not_stderr		;AN026;no - continue
 32943 00004E84 E97DB2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32944                                  
 32945                                  not_stderr:
 32946 00004E87 A1[978D]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32947 00004E8A 8E06[A58A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32948                                  						;  right error msg, and jmp to cerror.
 32949 00004E8E 26F606[0002]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32950 00004E94 7408                    	jz	short _go_to_error
 32951 00004E96 E8CDE0                  	call	PipeOff
 32952 00004E99 BA[5D80]                	mov	dx,PIPEEMES_PTR
 32953 00004E9C EB0B                    	jmp	short print_err_exit		;AC000;
 32954                                  
 32955                                  _go_to_error:
 32956 00004E9E C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class
 32957                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32958 00004EA3 BA[FC7E]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32959 00004EA6 A3[FC7E]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32960                                  
 32961                                  print_err_exit: 				;AC000;
 32962 00004EA9 0E                      	push	cs
 32963 00004EAA 07                      	pop	es
 32964 00004EAB E9A2DA                  	jmp	cerror
 32965                                  
 32966                                  ;****************************************************************
 32967                                  ;*
 32968                                  ;* ROUTINE:	TSYSLOADMSG
 32969                                  ;*
 32970                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32971                                  ;*		names since these routines are also used in the
 32972                                  ;*		resident.
 32973                                  ;*
 32974                                  ;* INPUT:	Inputs to SYSLOADMSG
 32975                                  ;*
 32976                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32977                                  ;*
 32978                                  ;****************************************************************
 32979                                  
 32980                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32981                                  TSYSLOADMSG:
 32982 00004EAE 53                      	push	bx				;AN000;
 32983 00004EAF E80800                  	call	SYSLOADMSG			;AN000; call routine
 32984 00004EB2 5B                      	pop	bx				;AN000;
 32985 00004EB3 C3                      	retn					;AN000; exit
 32986                                  
 32987                                  ;****************************************************************
 32988                                  ;*
 32989                                  ;* ROUTINE:	TSYSGETMSG
 32990                                  ;*
 32991                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32992                                  ;*		names since these routines are also used in the
 32993                                  ;*		resident.
 32994                                  ;*
 32995                                  ;* INPUT:	Inputs to SYSGETMSG
 32996                                  ;*
 32997                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32998                                  ;*
 32999                                  ;****************************************************************
 33000                                  
 33001                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33002                                  TSYSGETMSG:
 33003 00004EB4 51                      	push	cx				;AN000;
 33004 00004EB5 E8B500                  	call	SYSGETMSG			;AN000; call routine
 33005 00004EB8 59                      	pop	cx				;AN000;
 33006 00004EB9 C3                      	retn					;AN000; exit
 33007                                  
 33008                                  ;============================================================================
 33009                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 33010                                  ;============================================================================
 33011                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33012                                  
 33013                                  ; ---------------------------------------------------------------------------
 33014                                  ; MODULE NAME: MSGSERV.SAL
 33015                                  ;
 33016                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 33017                                  ;
 33018                                  ; FUNCTION: This module incorporates all the messages services and
 33019                                  ;	    is called upon at build time to INCLUDE the code requested
 33020                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 33021                                  ;
 33022                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 33023                                  ;	    requested procedure.
 33024                                  ;
 33025                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 33026                                  ;	    function requested.
 33027                                  ;
 33028                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 33029                                  ;
 33030                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 33031                                  ;
 33032                                  ; INTERNAL REFERENCES: (list of included subroutines)
 33033                                  ;
 33034                                  ;	- SYSLOADMSG
 33035                                  ;	- SYSDISPMSG
 33036                                  ;	- SYSGETMSG
 33037                                  ;
 33038                                  ; EXTERNAL REFERENCES: None
 33039                                  ;
 33040                                  ; NOTES: At build time, some modules must be included. These are only included
 33041                                  ;	 once using assembler switches. Other logic is included at the request
 33042                                  ;	 of the utility.
 33043                                  ;
 33044                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 33045                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 33046                                  ;	 storage and multiple EQUates.
 33047                                  ;
 33048                                  ; REVISION HISTORY: Created MAY 1987
 33049                                  ;
 33050                                  ;     Label: DOS - - Message Retriever
 33051                                  ;	     (c) Copyright 1988 Microsoft
 33052                                  ; ---------------------------------------------------------------------------
 33053                                  
 33054                                  ;	Revision History
 33055                                  ;	================
 33056                                  ;
 33057                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 33058                                  ;				$M_DISPLAY_H_STRING to properly
 33059                                  ;				handle Ctrl-Z being passed
 33060                                  ;
 33061                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 33062                                  ;				these routines are no longer assembled.
 33063                                  ;
 33064                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 33065                                  ;				CR-LF string also gets reinitialized
 33066                                  ;				on every cycle.
 33067                                  ;
 33068                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 33069                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 33070                                  
 33071                                  ; ---------------------------------------------------------------------------
 33072                                  
 33073                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33074                                  
 33075                                  ;;; Replacable parameters are described by a sublist structure
 33076                                  ;
 33077                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 33078                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33079                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33080                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33081                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 33082                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33083                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33084                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33085                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33086                                  ;endstruc
 33087                                  
 33088                                  ;; Each class will be defined by this structure.
 33089                                  
 33090                                  struc $M_CLASS_ID		;;AN000;;
 33091 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 33092 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 33093 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 33094                                   .size:
 33095                                  endstruc
 33096                                  
 33097                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 33098                                  
 33099                                  ;; Each message will be defined by this structure.
 33100                                  
 33101                                  struc $M_ID			;;AN000;;
 33102 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 33103 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 33104                                   .size:	
 33105                                  endstruc
 33106                                  
 33107                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 33108                                  
 33109                                  ; ---------------------------
 33110                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33111                                  ; ---------------------------
 33112                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 33113                                  
 33114                                  ; --------------------------- 
 33115                                  
 33116                                  ; 07/04/2023
 33117                                  $M_NUM_CLS equ 3
 33118                                  
 33119                                  ;; Resident data area definition of variables
 33120                                  
 33121                                  struc $M_RES_ADDRS			;;AN000;;
 33122 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 33123 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 33124 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 33125 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 33126 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 33127 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 33128 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 33129 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 33130 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 33131 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 33132 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33133 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33134 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33135 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33136 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33137 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33138 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33139 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33140 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33141 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33142 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33143 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33144 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33145                                   .size:
 33146                                  endstruc				;;AN000;;
 33147                                  
 33148                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33149                                  
 33150                                  ;; Important fields of the Get Country Information call
 33151                                  
 33152                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33153 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33154                                  					;;AN000;; Go past first part of struc
 33155 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33156 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33157 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33158 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33159 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33160 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33161 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33162 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33163 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33164                                  endstruc				;;AN000;;
 33165                                  
 33166                                  ; ---------------------------------------------------------------------------
 33167                                  
 33168                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33169                                  ;;
 33170                                  ;;	PROC NAME: SYSLOADMSG
 33171                                  ;;
 33172                                  ;;	FUNCTION:
 33173                                  ;;	INPUTS:
 33174                                  ;;
 33175                                  ;;	OUTPUTS:
 33176                                  ;;
 33177                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33178                                  
 33179                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33180                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33181                                  
 33182                                  SYSLOADMSG:
 33183 00004EBA 50                      	push	ax				;;AN000;
 33184 00004EBB 53                      	push	bx				;;AN000;
 33185 00004EBC 52                      	push	dx				;;AN000;
 33186 00004EBD 06                      	push	es				;;AN000;
 33187 00004EBE 57                      	push	di				;;AN000;
 33188 00004EBF 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33189 00004EC1 8EC1                    	mov	es,cx				;;AN000;
 33190 00004EC3 31FF                    	xor	di,di				;;AN000;
 33191 00004EC5 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33192 00004EC8 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33193 00004ECA CD2F                    	int	2Fh				;;AN000;; Private interface
 33194                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33195                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33196                                  		; Return: ES:DI -> error table
 33197                                  	
 33198 00004ECC 8C06[D686]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33199                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33200 00004ED0 893E[D486]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33201                                  	;mov	[$M_RT+8],di			;;AN000;;
 33202                                  
 33203 00004ED4 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33204 00004ED7 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33205 00004ED9 CD2F                    	int	2Fh				;;AN000;; Private interface
 33206                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33207                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33208                                  		; ES:DI -> error table
 33209                                  
 33210 00004EDB 8C06[DE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33211                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33212 00004EDF 893E[DC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33213                                  	;mov	[$M_RT+16],di			;;AN000;;
 33214                                  
 33215 00004EE3 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33216 00004EE6 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33217 00004EE8 CD2F                    	int	2Fh				;;AN000;; Private interface
 33218                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33219                                  		; DL = subfunction - get ??? error table
 33220                                  		; ES:DI -> error table
 33221                                  
 33222 00004EEA 8C06[EE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33223                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33224 00004EEE 893E[EC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33225                                  	;mov	[$M_RT+32],di			;;AN000;;
 33226                                  
 33227 00004EF2 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33228 00004EF5 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33229 00004EF7 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33230                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33231                                  		; DL = subfunction - get ??? error table
 33232                                  		; ES:DI -> error table
 33233                                  
 33234 00004EF9 8C06[D286]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33235                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33236 00004EFD 893E[D086]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33237                                  	;mov	[$M_RT+4],di			;;AN001;;
 33238                                  
 33239 00004F01 E8D12F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33240                                  						;;AN000;;
 33241 00004F04 8C06[CE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33242                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33243 00004F08 893E[CC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33244                                  	;mov	[$M_RT+0],di			;;AN000;;
 33245 00004F0C 8C06[EA86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33246                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33247 00004F10 893E[E886]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33248                                  	;mov	[$M_RT+28],di			;;AN000;;
 33249                                  
 33250 00004F14 E8DC2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33251                                  
 33252 00004F17 8C06[E286]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33253                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33254 00004F1B 893E[E086]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33255                                  	;mov	[$M_RT+20],di			;;AN000;;
 33256                                  
 33257 00004F1F B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33258 00004F22 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33259 00004F24 CD2F                    	int	2Fh				;;AN001;; Private interface
 33260                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33261                                  		; DL = subfunction - get ??? error table
 33262                                  		; ES:DI -> error table
 33263                                  
 33264 00004F26 8C06[F686]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33265                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33266 00004F2A 893E[F486]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33267                                  	;mov	[$M_RT+40],di			;;AN001;;
 33268                                  
 33269                                  ;M016; M020
 33270                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33271                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33272                                  
 33273 00004F2E C706[0F87]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33274                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33275 00004F34 C606[5887]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33276                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33277 00004F39 C706[1487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33278                                  	;mov	word [$M_RT+72],0		; M020
 33279 00004F3F C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33280                                  	;mov	word [$M_RT+74],10		; M020
 33281                                  
 33282                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33283                                  	; --------------------------
 33284                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33285                                  	; --------------------------
 33286                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33287                                  
 33288                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33289 00004F45 E82A2F                  	call    $M_CLS_3			; Get addressibility to class F
 33290 00004F48 893E[F886]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33291                                  	;mov	[$M_RT+44],di
 33292                                  	
 33293 00004F4C E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33294                                  
 33295                                  	; 15/04/2023
 33296                                  	;clc					;;AN000;; Make sure carry is clear
 33297                                  	;jc	short $MIF20
 33298                                  	
 33299 00004F4F 5F                      	pop	di				;;AN000;; Restore REGS
 33300 00004F50 07                      	pop	es				;;AN000;;
 33301 00004F51 5A                      	pop	dx				;;AN000;;
 33302 00004F52 5B                      	pop	bx				;;AN000;;
 33303 00004F53 58                      	pop	ax				;;AN000;;
 33304                                  	;jmp	short $MEN20
 33305                                  	; 15/04/2023
 33306 00004F54 C3                      	retn
 33307                                  
 33308                                  	; 15/04/2023
 33309                                  ;$MIF20:
 33310                                  	;add	sp,10				;;AN000;;
 33311                                  	;stc					;;AN000;; Reset carry flag
 33312                                  ;$MEN20:
 33313                                  	;retn					;;AN000;;
 33314                                  
 33315                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33316                                  ;;
 33317                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33318                                  ;;
 33319                                  ;;  Function:	Get the DBCS vector and save it for later use
 33320                                  ;;
 33321                                  ;;  Inputs:	None
 33322                                  ;;
 33323                                  ;;  Outputs:	None
 33324                                  ;;
 33325                                  ;;  Regs Changed:
 33326                                  ;;
 33327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33328                                  
 33329                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33330                                  
 33331                                  $M_GET_DBCS_VEC:
 33332 00004F55 50                      	push	ax				;;AN000;; Save character to check
 33333 00004F56 56                      	push	si				;;AN000;;
 33334 00004F57 1E                      	push	ds				;;AN000;;
 33335 00004F58 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33336 00004F5B CD21                    	int	21h				;;AN000;; Get environment pointer
 33337 00004F5D 1E                      	push	ds				;;AN000;; Get environment pointer
 33338 00004F5E 07                      	pop	es				;;AN000;; Get environment pointer
 33339 00004F5F 1F                      	pop	ds				;;AN000;; Get environment pointer
 33340 00004F60 7208                    	jc	short $MIF23
 33341                                  	
 33342 00004F62 8936[0887]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33343                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33344 00004F66 8C06[0A87]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33345                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33346                                  $MIF23:
 33347 00004F6A 5E                      	pop	si				;;AN000;;
 33348 00004F6B 58                      	pop	ax				;;AN000;; Retrieve character to check
 33349 00004F6C C3                      	retn					;;AN000;; Return
 33350                                  
 33351                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33352                                  ;;
 33353                                  ;;  Proc Name:	SYSGETMSG
 33354                                  ;;
 33355                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33356                                  ;;		message text to the caller based on a message number.
 33357                                  ;;		The GET function will not display the message thus assumes
 33358                                  ;;		caller will handle replaceable parameters.
 33359                                  ;;
 33360                                  ;;  Inputs:
 33361                                  ;;
 33362                                  ;;  Outputs:
 33363                                  ;;
 33364                                  ;;  Psuedocode:
 33365                                  ;;		Call $M_GET_MSG_ADDRESS
 33366                                  ;;		IF MSG_NUM exists THEN
 33367                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33368                                  ;;		   CARRY_FLAG = 0
 33369                                  ;;		ELSE
 33370                                  ;;		   CARRY_FLAG = 1
 33371                                  ;;		ENDIF
 33372                                  ;;
 33373                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33374                                  
 33375                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33376                                  	; 15/06/2023
 33377                                  
 33378                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33379                                  
 33380                                  SYSGETMSG:
 33381                                  	;; Save registers needed later
 33382 00004F6D 50                      	push	ax				;;AN000;; Save changed regs
 33383 00004F6E 06                      	push	es				;;AN000;;
 33384 00004F6F 57                      	push	di				;;AN000;;
 33385 00004F70 55                      	push	bp				;;AN000;;
 33386                                  
 33387 00004F71 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33388 00004F74 720D                    	jc	short $MIF31
 33389                                  	
 33390 00004F76 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33391                                  	;clc					;;AN000;;
 33392 00004F79 7404                    	je	short $MIF32			;;AN000;;
 33393                                  	; 15/06/2023
 33394 00004F7B F8                      	clc	
 33395                                  
 33396 00004F7C 06                      	push	es				;;AN000;;
 33397                                  	;pop	ds				;;AN000;;
 33398 00004F7D EB01                    	jmp	short $MEN32
 33399                                  $MIF32:
 33400 00004F7F 0E                      	push	cs				;;AN000;;			
 33401                                  	;pop	ds				;;AN000;;
 33402                                  $MEN32:
 33403                                  	; 07/04/2023
 33404 00004F80 1F                      	pop	ds
 33405 00004F81 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33406                                  $MIF31:
 33407 00004F83 5D                      	pop	bp				;;AN000;; Restore changed regs
 33408 00004F84 5F                      	pop	di				;;AN000;;
 33409 00004F85 07                      	pop	es				;;AN000;;
 33410 00004F86 58                      	pop	ax				;;AN000;;
 33411 00004F87 C3                      	retn					;;AN000;; Return
 33412                                  
 33413                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33414                                  ;;
 33415                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33416                                  ;;
 33417                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33418                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33419                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33420                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33421                                  ;;	REGS CHANGED: ES,DI,CX
 33422                                  ;;
 33423                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33424                                  
 33425                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33426                                  
 33427                                  $M_GET_MSG_ADDRESS:
 33428 00004F88 56                      	push	si				;;AN000;;
 33429 00004F89 53                      	push	bx				;;AN000;;
 33430 00004F8A 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33431 00004F8C 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33432                                  $MDO36:
 33433 00004F8E 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33434 00004F91 7508                    	jne	short $MIF37			;;AN000;; No			
 33435                                  	
 33436                                  	; 07/04/2023
 33437                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33438 00004F93 8BBC[F886]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33439                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33440 00004F97 89FB                    	mov	bx,di				;;AN000;;
 33441 00004F99 EB21                    	jmp	short $MEN37
 33442                                  $MIF37:
 33443 00004F9B F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33444 00004F9E 7406                    	jz	short $MIF39
 33445                                  	
 33446                                  	; 07/04/2023
 33447                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33448 00004FA0 C4BC[DC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33449                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33450                                  	
 33451                                  	; 07/04/2023
 33452                                  	;mov	bx,es ; *			;;AN000;;
 33453 00004FA4 EB14                    	jmp	short $MEN39
 33454                                  $MIF39:
 33455 00004FA6 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33456 00004FA9 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33457                                  
 33458 00004FAB 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33459 00004FAE 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33460                                  
 33461                                  	; 07/04/2023
 33462                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33463 00004FB0 C4BC[E886]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33464                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33465                                  	
 33466                                  	; 07/04/2023
 33467                                  	;mov	bx,es ; *			;;AN000;;
 33468 00004FB4 EB04                    	jmp	short $MEN41
 33469                                  $MIF41:
 33470                                  	; 07/04/2023
 33471                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33472 00004FB6 C4BC[CC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33473                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33474                                  	
 33475                                  	; 07/04/2023
 33476                                  	;mov	bx,es ; *			;;AN000;;
 33477                                  $MEN41:
 33478                                  $MEN39:
 33479                                  	; 07/04/2023
 33480 00004FBA 8CC3                    	mov	bx,es ; *
 33481                                  $MEN37:						;;AN000;;
 33482 00004FBC 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33483 00004FBF 7515                    	jne	short $MIF46			;;AN000;; No
 33484                                  
 33485 00004FC1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33486 00004FC4 7503                    	jne	short $MIF47			;;AN000;; No
 33487 00004FC6 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33488                                  	; 07/04/2023
 33489                                  	;jmp	short $MEN47 ; **-
 33490 00004FC7 EB1B                    	jmp	short $MEN36 ; **-
 33491                                  $MIF47:
 33492 00004FC9 A3[1487]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 33493                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33494 00004FCC B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33495 00004FCF BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33496 00004FD2 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33497                                  	; 28/04/2023
 33498                                  	; 07/04/2023
 33499                                  	;clc	; **+				;;AN000;;
 33500                                  ;$MEN47:
 33501                                  	;jmp	short $MEN46 ; ***
 33502 00004FD4 EB0A                    	jmp	short $MEN47 ; ***
 33503                                  $MIF46:
 33504                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33505 00004FD6 21DB                    	and	bx,bx ; 0 ?
 33506 00004FD8 7403                    	jz	short $MIF51			;;AN000;; No
 33507                                  	
 33508 00004FDA E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33509                                  $MIF51:
 33510 00004FDD 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33511                                  	; 07/04/2023
 33512                                  	;clc					;;AN000;;
 33513                                  ;$MEN46:
 33514                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33515                                  $MEN47:	; 07/04/2023	; **+
 33516 00004FE0 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33517                                  	;jnz	short $MXL2			;;AN000;; Yes
 33518                                  	;jmp	short $MDO36
 33519                                  	; 07/04/2023
 33520 00004FE2 74AA                    	jz	short $MDO36	
 33521                                  $MXL2:
 33522                                  $MEN36:
 33523 00004FE4 9C                      	pushf 					;;AN006;; Save the flag state
 33524                                  	
 33525 00004FE5 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33526                                  	;jne	short $MIF56			;;AN006;; No
 33527                                  	; 28/04/2023
 33528 00004FE8 752A                    	jne	short $M_MYRET	
 33529                                  
 33530 00004FEA 52                      	push	dx				;;AN006;; Save all needed registers
 33531 00004FEB 55                      	push	bp				;;AN006;;
 33532 00004FEC 51                      	push	cx				;;AN006;;
 33533 00004FED 06                      	push	es				;;AN006;;
 33534 00004FEE 57                      	push	di				;;AN006;;
 33535 00004FEF 50                      	push	ax				;;AN006;;
 33536                                  
 33537 00004FF0 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33538 00004FF3 CD2F                    	int	2Fh				;;AN006;;
 33539                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33540                                  		; Return: AL = 00h not installed, OK to install
 33541                                  		; 01h not installed, can't install
 33542                                  		; FFh installed
 33543                                  
 33544 00004FF5 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33545 00004FF7 58                      	pop	ax				;;AN006;; Restore msg number
 33546 00004FF8 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33547                                  
 33548 00004FFA 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33549 00004FFC B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33550 00004FFF CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33551                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33552                                  
 33553                                  	;jmp	short $MEN57			;;AN006;;
 33554                                  	; 28/04/2023
 33555 00005001 720B                    	jc	short $MEN57
 33556                                  $MIF60:
 33557 00005003 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33558 00005006 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33559                                  $MEN60:
 33560 00005009 5D                      	pop	bp				;;AN006;; Restore other Regs
 33561 0000500A 5A                      	pop	dx				;;AN006;;
 33562                                  $MIF56:
 33563                                  	; 07/04/2023
 33564                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33565 0000500B EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33566                                  
 33567                                  $MIF57:
 33568 0000500D F9                      	stc					;;AN006;; Carry conditon
 33569                                  $MEN57:
 33570                                  	; 28/04/2023
 33571                                  	;jnc	short $MIF60			;;AN006;;
 33572                                  
 33573 0000500E 5F                      	pop	di				;;AN006;;
 33574 0000500F 07                      	pop	es				;;AN006;; Restore old pointer
 33575 00005010 59                      	pop	cx				;;AN006;;
 33576 00005011 EBF6                    	jmp	short $MEN60
 33577                                  
 33578                                  ;$MIF60:
 33579                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33580                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33581                                  ;$MEN60:
 33582                                  ;	pop	bp				;;AN006;; Restore other Regs
 33583                                  ;	pop	dx				;;AN006;;
 33584                                  ;$MIF56:
 33585                                  ;	; 07/04/2023
 33586                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33587                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33588                                  
 33589                                  ; 07/04/2023
 33590                                  ; ---------------------------
 33591                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33592                                  ; ---------------------------
 33593                                  	; $M_POPF macro
 33594                                  	;jmp	short $+3
 33595                                  m_popf_iret:
 33596 00005013 CF                      	iret
 33597                                  $M_MYRET:
 33598 00005014 0E                      	push	cs
 33599 00005015 E8FBFF                  	call	m_popf_iret
 33600                                  	;;; end macro	
 33601                                  ; ---------------------------
 33602                                  
 33603 00005018 5B                      	pop	bx				;;AN000;;
 33604 00005019 5E                      	pop	si				;;AN000;;
 33605 0000501A C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33606                                  
 33607                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33608                                  
 33609                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33610                                  $M_SET_LEN_IN_CX:			
 33611 0000501B 57                      	push	di				;;AN006;; Save position
 33612 0000501C 50                      	push	ax				;;AN006;;
 33613 0000501D B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33614 00005020 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33615 00005022 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33616 00005024 F7D1                    	not	cx				;;AN006;; Change decrement into number
 33617 00005026 49                      	dec	cx				;;AN006;; Don't include the zero
 33618 00005027 58                      	pop	ax				;;AN006;;
 33619 00005028 5F                      	pop	di				;;AN006;; Restore position
 33620 00005029 C3                      	retn					;;AN006;;
 33621                                  
 33622                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33623                                  ;;
 33624                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33625                                  ;;
 33626                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33627                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33628                                  ;;		   CX contains the number of messages in class
 33629                                  ;;		   DH contains the message class
 33630                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33631                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33632                                  ;;
 33633                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33634                                  
 33635                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33636                                  	; 15/06/2023
 33637                                  $M_FIND_SPECIFIED_MSG:
 33638 0000502A 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33639 0000502D 751F                    	jne	short $MIF64
 33640 0000502F 833E[F486]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33641                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33642                                  	; 15/06/2023 (BugFix)
 33643 00005034 7418                    	je	short $MIF64
 33644                                  
 33645 00005036 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33646 00005039 750B                    	jne	short $MIF65
 33647                                  	
 33648 0000503B 50                      	push	ax				;;AN004;; Reset the special message number
 33649 0000503C A1[1487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33650                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33651 0000503F FF1E[F486]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33652                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33653 00005043 58                      	pop	ax				;;AN004;; Reset the special message number
 33654                                  	; 28/04/2023
 33655 00005044 EB04                    	jmp	short $MEN65
 33656                                  	; 18/04/2023
 33657                                  	;jmp	short $MEN64
 33658                                  $MIF65:
 33659 00005046 FF1E[F486]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33660                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33661                                  $MEN65:
 33662                                  	; 28/04/2023
 33663 0000504A 7344                    	jnc	short $MIF75
 33664                                  	;
 33665 0000504C EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33666                                  $MIF64:
 33667 0000504E 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33668 00005050 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33669 00005053 7406                    	je	short $MIF69
 33670                                  	
 33671 00005055 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33672                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33673 00005059 EB09                    	jmp	short $MEN69
 33674                                  $MIF69:
 33675                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33676                                  	;cmp	[cs:di+0],dh
 33677 0000505B 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33678 0000505E 7504                    	jne	short $MIF71
 33679                                  
 33680 00005060 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33681                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33682                                  $MIF71:						;;AN001;;
 33683                                  $MEN69:
 33684 00005064 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33685                                  	; 02/05/2023
 33686                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33687                                  $MEN64:
 33688                                  	;jnc	short $MIF75
 33689                                  	; 28/04/2023
 33690                                  	; (or instruction clears carry flag)
 33691                                  	;clc					;;AN004;; No, reset carry
 33692                                  $MDO76:
 33693 00005067 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33694 00005069 7417                    	jz	short $MEN76
 33695                                  
 33696 0000506B 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33697 0000506E 7405                    	je	short $MIF78
 33698                                  
 33699                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33700 00005070 263B05                  	cmp	ax,[es:di]
 33701 00005073 EB03                    	jmp	short $MEN78
 33702                                  $MIF78:
 33703                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33704 00005075 2E3B05                  	cmp	ax,[cs:di]
 33705                                  $MEN78:
 33706                                  	;jne	short $MIF76
 33707                                  	;jmp	short $MSR76
 33708                                  	; 07/04/2023
 33709 00005078 740B                    	je	short $MSR76 ; *
 33710                                  $MIF76:
 33711 0000507A 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33712 0000507B 7405                    	jz	short $MEN76
 33713                                  
 33714 0000507D 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33715 00005080 EBE5                    	jmp	short $MDO76			;;AN000;;
 33716                                  $MEN76:
 33717 00005082 F9                      	stc					;;AN000;;
 33718                                  ;$MSR76:	; 07/04/2023
 33719                                  	;jc	short $MIF86			;;AN000;;
 33720                                  	; 07/04/2023
 33721                                  	;jc	short $MIF91
 33722 00005083 EB11                    	jmp	short $MIF91 ;*
 33723                                  $MSR76:	; 07/04/2023 ; *	
 33724 00005085 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33725                                  	; 07/04/2023
 33726                                  	;clc					;;AN001;;
 33727 00005088 7502                    	jne	short $MIF87
 33728                                  
 33729 0000508A 0E                      	push	cs				;;AN000;;
 33730 0000508B 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33731                                  $MIF87:
 33732                                  	;add	di,[es:di+2]
 33733 0000508C 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33734                                  $MIF86:
 33735                                  ;$MIF75:
 33736                                  	; 02/05/2023
 33737                                  	;jc	short $MIF91
 33738                                  $MIF75:	; 28/04/2023
 33739 00005090 30ED                    	xor	ch,ch				;;AN000;;
 33740 00005092 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33741 00005095 47                      	inc	di				;;AN000;; Increment past length
 33742                                  $MIF91:
 33743 00005096 C606[0E87]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33744                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33745 0000509B C3                      	retn					;;AN000;; Return
 33746                                  
 33747                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33748                                  ;;
 33749                                  ;;  Proc Name:	SYSDISPMSG
 33750                                  ;;
 33751                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33752                                  ;;		requested by the caller. It also provides function to display
 33753                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33754                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33755                                  ;;		defined previous to entry.
 33756                                  ;;
 33757                                  ;;		It is assumes that a PRELOAD function has already determined
 33758                                  ;;		the addressibilty internally to the message retriever services.
 33759                                  ;;  Inputs:
 33760                                  ;;
 33761                                  ;;  Outputs:
 33762                                  ;;
 33763                                  ;;  Psuedocode:
 33764                                  ;;		Save registers needed later
 33765                                  ;;		Get address of the message requested
 33766                                  ;;		IF Message number exists THEN
 33767                                  ;;		  IF replacable parameters were specified THEN
 33768                                  ;;		     Display message with replacable parms
 33769                                  ;;		  ELSE
 33770                                  ;;		     Display string without replacable parms
 33771                                  ;;		  ENDIF
 33772                                  ;;		  IF character input was requested THEN
 33773                                  ;;		     Wait for character input
 33774                                  ;;		  ENDIF
 33775                                  ;;		  Clear CARRY FLAG
 33776                                  ;;		ELSE
 33777                                  ;;		   Set CARRY FLAG
 33778                                  ;;		ENDIF
 33779                                  ;;		Return
 33780                                  ;;
 33781                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33782                                  
 33783                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33784                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33785                                  
 33786                                  SYSDISPMSG:
 33787                                  	;; Save registers and values needed later
 33788 0000509C 50                      	push	ax				;;AN000;; Save changed REGs
 33789 0000509D 53                      	push	bx				;;AN000;;
 33790 0000509E 51                      	push	cx				;;AN000;;
 33791 0000509F 55                      	push	bp				;;AN000;;
 33792 000050A0 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33793 000050A1 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33794 000050A2 52                      	push	dx				;;AN000;; Save Input/Class request
 33795                                  
 33796 000050A3 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33797 000050A5 891E[0C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33798                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33799 000050A9 8836[1187]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33800                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33801                                  
 33802                                  	;; Get address of the message requested
 33803 000050AD E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33804 000050B0 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33805 000050B2 7420                    	jz	short $MIF93
 33806                                  						;;AN000;; Yes, Message address in ES:DI
 33807                                  	
 33808                                  	;; Test if replacable parameters were specified
 33809 000050B4 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33810 000050B6 7505                    	jnz	short $MIF94
 33811                                  
 33812                                  	;; Display string without replacable parms
 33813 000050B8 E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33814 000050BB EB03                    	jmp	short $MEN94
 33815                                  $MIF94:
 33816                                  	;; Display message with replacable parms
 33817 000050BD E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33818                                  $MEN94:
 33819 000050C0 720D                    	jc	short $MIF97
 33820 000050C2 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33821 000050C3 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33822 000050C6 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33823 000050C7 5F                      	pop	di				;;AN000;;
 33824                                  	;jmp	short $MEN97 ; ***
 33825                                  	; 08/04/2023
 33826                                  	;jmp	short $MEN93 ; **
 33827                                  
 33828                                  	; 08/04/2023
 33829                                  ;$MEN93:
 33830 000050C8 720D                    	jc	short $MIF104
 33831                                  ;$MEN97:
 33832 000050CA 5D                      	pop	bp				;;AN000;;
 33833 000050CB 59                      	pop	cx				;;AN000;;
 33834 000050CC 5B                      	pop	bx				;;AN000;;
 33835 000050CD 58                      	pop	ax				;;AN000;;
 33836 000050CE C3                      	retn
 33837                                   
 33838                                  $MIF97:
 33839                                  	; 08/04/2023
 33840                                  	;add	sp,6				;;AN000;;
 33841                                  	;stc					;;AN000;; Reset carry flag
 33842                                  ;$MEN97: ; ***
 33843                                  	;jmp	short $MEN93
 33844                                  	; 08/04/2023
 33845                                  	;jmp	short $MIF104
 33846                                  	; 08/04/2023
 33847 000050CF 83C40E                  	add	sp,14 ; 6+8
 33848 000050D2 F9                      	stc
 33849 000050D3 C3                      	retn
 33850                                  $MIF93:
 33851                                  	; 08/04/2023
 33852                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33853                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33854 000050D4 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33855 000050D5 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33856 000050D6 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33857                                  	;stc	; * 				;;AN000;; Set carry flag
 33858                                  	; 08/04/2023
 33859                                  	;jmp short $MIF104 ; *
 33860                                  
 33861                                  ;$MEN93: ; **
 33862                                  ;	jc	short $MIF104
 33863                                  ;$MEN97: ; 08/04/2023
 33864                                  ;	pop	bp				;;AN000;;
 33865                                  ;	pop	cx				;;AN000;;
 33866                                  ;	pop	bx				;;AN000;;
 33867                                  ;	pop	ax				;;AN000;;
 33868                                  ;	;jmp	short $MEN104
 33869                                  ;	; 08/04/2023
 33870                                  ;	retn
 33871                                  
 33872                                  $MIF104: ; *
 33873 000050D7 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33874 000050DA F9                      	stc					;;AN000;;
 33875                                  $MEN104:
 33876 000050DB C3                      	retn					;;AN000;; Return
 33877                                  
 33878                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33879                                  ;;
 33880                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33881                                  ;;
 33882                                  ;;	FUNCTION:  Will display or write string
 33883                                  ;;	INPUTS:    ES:DI points to beginning of message
 33884                                  ;;		   CX contains the length of string to write (if applicable)
 33885                                  ;;	OUTPUTS:   None
 33886                                  ;;	REGS Revised: None
 33887                                  ;;
 33888                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33889                                  
 33890                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33891                                  
 33892                                  $M_DISPLAY_STRING:
 33893 000050DC 50                      	push	ax				;;AN000;;
 33894 000050DD 53                      	push	bx				;;AN000;;
 33895 000050DE 52                      	push	dx				;;AN000;;
 33896 000050DF 8B1E[0C87]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33897                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33898                                  	
 33899 000050E3 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33900 000050E6 7505                    	jne	short $MIF107
 33901                                  
 33902 000050E8 E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33903 000050EB EB03                    	jmp	short $MEN107
 33904                                  $MIF107:
 33905 000050ED E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33906                                  $MEN107:
 33907 000050F0 730D                    	jnc	short $MIF110
 33908                                  	
 33909 000050F2 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33910                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33911                                  	; 08/04/2023
 33912 000050F4 31DB                    	xor	bx,bx
 33913 000050F6 CD21                    	int	21h				;;AN000;;
 33914                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33915                                  		; BX = version code (0000h for DOS 3.x)
 33916 000050F8 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33917                                  $MEN110: ; 08/04/2023 ; ***
 33918 000050FA 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33919 000050FD F9                      	stc					;;AN000;; Flag that there was an error
 33920                                  	;jmp	short $MEN110 ; ****
 33921                                  	; 08/04/2023
 33922 000050FE C3                      	retn
 33923                                  $MIF110:
 33924                                  	;cmp	bx,$M_NO_HANDLE
 33925 000050FF 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33926 00005102 7409                    	je	short $MIF112 ; *  ; cf = 0
 33927 00005104 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33928 00005106 7405                    	je	short $MIF113 ; ** ; cf = 0
 33929 00005108 E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33930                                  	;add	sp,6				;;AN001;; Clean up stack
 33931                                  	;stc					;;AN001;; Flag that there was an error
 33932                                  	; 08/04/2023
 33933 0000510B EBED                    	jmp	short $MEN110 ; ***
 33934                                  	; 08/04/2023
 33935                                  ;$MIF112:
 33936                                  ;$MEN110: ; ****
 33937                                  	;jc	short $MIF117
 33938                                  $MIF112: ; 08/04/2023	; *
 33939                                  $MIF113:	; **
 33940 0000510D 5A                      	pop	dx				;;AN000;; Restore regs
 33941 0000510E 5B                      	pop	bx				;;AN000;;
 33942 0000510F 58                      	pop	ax				;;AN000;;
 33943                                  $MIF117:
 33944 00005110 C3                      	retn
 33945                                  
 33946                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33947                                  ;;
 33948                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33949                                  ;;
 33950                                  ;;	FUNCTION:  Will display a $ terminated string
 33951                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33952                                  ;;	OUTPUTS:   None
 33953                                  ;;	REGS USED: AX,DX
 33954                                  ;;
 33955                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33956                                  
 33957                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33958                                  
 33959                                  $M_DISPLAY_$_STRING:
 33960 00005111 1E                      	push	ds				;;AN000;;
 33961 00005112 06                      	push	es				;;AN000;;
 33962 00005113 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33963                                  
 33964                                  	; 08/04/2023
 33965 00005114 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33966                                  
 33967                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33968 00005116 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33969 00005119 7518                    	jne	short $MIF119			;;AN000;; No
 33970                                  	
 33971                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33972 0000511B 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33973 0000511E CD21                    	int	21h				;;AN000;; Write character
 33974                                  		; DOS - DISPLAY OUTPUT
 33975                                  		; DL = character to send to standard output
 33976 00005120 1F                      	pop	ds				;;AN000;;
 33977 00005121 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33978 00005123 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33979 00005126 1E                      	push	ds				;;AN000;;
 33980 00005127 06                      	push	es				;;AN000;;
 33981 00005128 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33982 00005129 7316                    	jnc	short $MIF120 ; *
 33983                                  
 33984 0000512B 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33985 0000512F CD21                    	int	21h				;;AN000;; Write character
 33986                                  		; DOS - DISPLAY OUTPUT
 33987                                  		; DL = character to send to standard output
 33988                                  	; 08/04/2023
 33989                                  	;clc					;;AN000;; Clear the DBCS indicator
 33990                                  ;$MIF120:
 33991 00005131 EB0D                    	jmp	short $MEN119
 33992                                  $MIF119:
 33993                                  	; 08/04/2023
 33994                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33995                                  ;$MDO123:
 33996 00005133 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33997                                  	;jz	short $MEN123
 33998                                  	; 18/04/2023
 33999 00005135 740A                    	jz	short $MIF120 ; cf = 0
 34000                                  $MDO123: ; 08/04/2023
 34001 00005137 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 34002 0000513A CD21                    	int	21h				;;AN002;; Display the character
 34003                                  		; DOS - DISPLAY OUTPUT
 34004                                  		; DL = character to send to standard output
 34005 0000513C 47                      	inc	di				;;AN002;; Set pointer to next character
 34006 0000513D 49                      	dec	cx				;;AN002;; Count this character
 34007 0000513E 75F7                    	jnz	short $MDO123
 34008                                  ;$MEN123:
 34009                                  $MEN119:
 34010 00005140 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 34011                                  $MIF120: ; 08/04/2023 ; *
 34012 00005141 1F                      	pop	ds				;;AN000;;
 34013 00005142 C3                      	retn
 34014                                  
 34015                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34016                                  ;;
 34017                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 34018                                  ;; truncates it at the Ctrl-Z if any present.
 34019                                  ;;
 34020                                  ;;	ENTRY:	ds:dx = String to be displayed
 34021                                  ;;		cx = number of chars to be displayed
 34022                                  ;;
 34023                                  ;;	EXIT:	cx = number of chars to be displayed
 34024                                  ;;
 34025                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34026                                  
 34027                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34028                                  scan_ctrlz:
 34029 00005143 57                      	push	di
 34030 00005144 50                      	push	ax
 34031 00005145 06                      	push	es
 34032 00005146 53                      	push	bx
 34033                                  
 34034 00005147 89D7                    	mov	di,dx
 34035 00005149 1E                      	push	ds
 34036 0000514A 07                      	pop	es   			;es:di points at string
 34037                                  
 34038 0000514B 89CB                    	mov	bx,cx			;save current count
 34039                                  
 34040 0000514D B01A                    	mov	al,1Ah	; Ctrl-Z
 34041 0000514F FC                      	cld
 34042 00005150 F2AE                    	repne	scasb			;find first Ctrl-Z
 34043 00005152 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 34044                                  
 34045 00005154 29CB                    	sub	bx,cx
 34046 00005156 4B                      	dec	bx			;bx = new count to display
 34047                                  noCtrlZ:
 34048 00005157 89D9                    	mov	cx,bx			;cx = actual display count
 34049                                  
 34050 00005159 5B                      	pop	bx
 34051 0000515A 07                      	pop	es
 34052 0000515B 58                      	pop	ax
 34053 0000515C 5F                      	pop	di
 34054                                  $MIF127:	; 08/04/2023
 34055 0000515D C3                      	retn
 34056                                  
 34057                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34058                                  ;;
 34059                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 34060                                  ;;
 34061                                  ;;	FUNCTION:  Will display a string to a specified handle
 34062                                  ;;	INPUTS:    ES:DI points to beginning of message
 34063                                  ;;		   CX contains the number of bytes to write
 34064                                  ;;		   BX contains the handle to write to
 34065                                  ;;	OUPUTS:    None
 34066                                  ;;	REGS USED: AX,DX
 34067                                  ;;
 34068                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34069                                  
 34070                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34071                                  
 34072                                  $M_DISPLAY_H_STRING:
 34073 0000515E 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 34074 00005160 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 34075 00005162 74F9                    	jz	short $MIF127
 34076                                  	
 34077 00005164 1E                      	push	ds			;;AN000;;
 34078 00005165 06                      	push	es			;;AN000;;
 34079 00005166 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34080                                  	
 34081 00005167 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34082 00005169 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 34083                                  
 34084 0000516B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 34085 0000516E 7528                    	jne	short $MIF128		;;AN000;; No
 34086                                  
 34087 00005170 CD21                    	int	21h			;;AN000;; Write character
 34088                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34089                                  		; BX = file handle, CX = number of bytes to writ
 34090                                  
 34091 00005172 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34092 00005173 50                      	push	ax			;;AN000;;
 34093 00005174 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 34094 00005177 E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 34095 0000517A 58                      	pop	ax			;;AN000;;
 34096 0000517B 1E                      	push	ds			;;AN000;;
 34097 0000517C 06                      	push	es			;;AN000;;
 34098 0000517D 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34099 0000517E 7306                    	jnc	short $MIF129
 34100                                  	
 34101 00005180 F8                      	clc				;;AN000;; Clear the DBCS indicator
 34102 00005181 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34103 00005183 42                      	inc	dx			;;AN000;; Point to next character
 34104 00005184 CD21                    	int	21h			;;AN000;; Write character
 34105                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34106                                  		; BX = file handle, CX = number of bytes to write, 
 34107                                  $MIF129:
 34108                                  ;SR;
 34109                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 34110                                  ;0 chars written making the caller think there was an error writing. To 
 34111                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 34112                                  ;the char was written, thus fooling the caller.
 34113                                  
 34114 00005186 9C                      	pushf				;save flags
 34115 00005187 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 34116 0000518B 7502                    	jne	short m_popf_j		;no, continue
 34117                                  
 34118 0000518D 89C8                    	mov	ax,cx			;yes, fake as if it was written
 34119                                  m_popf_j:
 34120                                  	; 08/04/2023
 34121                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34122 0000518F EB01                    	jmp	short m_popf		;restore flags
 34123                                  
 34124                                  ; 07/04/2023
 34125                                  ; ---------------------------
 34126                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34127                                  ; ---------------------------
 34128                                  	; $M_POPF macro
 34129                                  	;jmp	short $+3
 34130                                  intret:
 34131 00005191 CF                      	iret
 34132                                  m_popf:
 34133 00005192 0E                      	push	cs
 34134 00005193 E8FBFF                  	call	intret
 34135                                  	;;; end macro	
 34136                                  ; ---------------------------
 34137                                  
 34138 00005196 EB18                    	jmp	short $MEN128
 34139                                  
 34140                                  $MIF128:
 34141                                  ;SR;
 34142                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34143                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34144                                  
 34145 00005198 55                      	push	bp			; M007
 34146 00005199 51                      	push	cx
 34147 0000519A E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34148 0000519D 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34149 0000519F 59                      	pop	cx			;get old count back ;M007
 34150                                  	
 34151 000051A0 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34152                                  	;jnc	short chk_count		;no error, adjust return count
 34153                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34154                                  	; 08/04/2023
 34155 000051A2 720B                    	jc	short m_cnt_ok
 34156                                  ;M007
 34157                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34158                                  ;return count will be much less and if this returns to the caller we can get
 34159                                  ;spurious error messages. We check here if the count returned is same as
 34160                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34161                                  ;case, we fake it as if all bytes have been written. If the return count
 34162                                  ;does not match either count, then we had some other disk error (such as
 34163                                  ;insufficient disk space) and we pass it through
 34164                                  
 34165                                  chk_count:
 34166 000051A4 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34167 000051A6 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34168 000051A8 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34169 000051AA F8                      	clc				;no error either way ;M007
 34170 000051AB 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34171 000051AD 89C8                    	mov	ax,cx			;return old count ;M007
 34172                                  m_cnt_ok:				; M007
 34173 000051AF 5D                      	pop	bp			; M007
 34174                                  $MEN128:
 34175 000051B0 1F                      	pop	ds			;;AN000;;
 34176                                  ;$MIF127: ; 08/04/2023
 34177 000051B1 C3                      	retn
 34178                                  
 34179                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34180                                  ;;
 34181                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34182                                  ;;
 34183                                  ;;	FUNCTION:  Will set registers for extended error #39
 34184                                  ;;	INPUTS:    None
 34185                                  ;;	OUPUTS:    AX,BX,CX set
 34186                                  ;;	REGS USED:
 34187                                  ;;
 34188                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34189                                  
 34190                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34191                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34192                                  $M_GET_EXT_ERR_39:
 34193 000051B2 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34194                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34195 000051B5 BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34196                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34197 000051B8 B501                    	mov	ch,1			;AN001;
 34198 000051BA C3                      	retn				;AN001;
 34199                                  
 34200                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34201                                  ;;
 34202                                  ;;	PROC NAME: $M_ADD_CRLF
 34203                                  ;;
 34204                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34205                                  ;;	INPUTS:    DX contains the Input/Class requested
 34206                                  ;;	OUTPUTS:   None
 34207                                  ;;	REGS Revised: CX,ES,DI
 34208                                  ;;
 34209                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34210                                  
 34211                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34212                                  
 34213                                  $M_ADD_CRLF:
 34214                                  	;cmp	dh,0FFh
 34215 000051BB 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34216 000051BE 7411                    	je	short $MIF134		;;AN004;; Yes
 34217 000051C0 F6C680                  	test	dh,80h ; $M_NO_CRLF_MASK ;;AN004;; Are we to supress the CR LF?
 34218 000051C3 750C                    	jnz	short $MIF135
 34219                                  					;;AN004;; No	
 34220 000051C5 1E                      	push	ds			;;AN004;;
 34221 000051C6 07                      	pop	es			;;AN004;; Set ES to data segment
 34222 000051C7 8D3E[0F87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34223                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34224 000051CB B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34225 000051CE E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34226                                  $MIF135:
 34227                                  $MIF134:
 34228 000051D1 C3                      	retn				;;AN004;; Return
 34229                                  
 34230                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34231                                  ;;
 34232                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34233                                  ;;
 34234                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34235                                  ;;	INPUTS:    AL contains the byte to be checked
 34236                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34237                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34238                                  ;;	REGS USED: All restored
 34239                                  ;;
 34240                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34241                                  
 34242                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34243                                  
 34244                                  $M_IS_IT_DBCS:
 34245 000051D2 06                      	push	es			;;AN000;; Save Extra Segment register
 34246 000051D3 57                      	push	di			;;AN000;; Save DI register
 34247                                  
 34248 000051D4 C43E[0887]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34249                                  	;les	di,[$M_RT+60]		;;AN000;;
 34250 000051D8 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34251 000051DA 7417                    	jz	short $MIF138		;;AN000;; No
 34252                                  $MDO139:
 34253 000051DC 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34254                                  					;;AN000;; Is this the terminating flag?
 34255 000051E0 F8                      	clc				;;AN000;;
 34256 000051E1 7410                    	jz	short $MEN139
 34257                                  					;;AN000;; No
 34258 000051E3 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34259 000051E6 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34260 000051E8 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34261 000051EC 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34262                                  					;;AN000;; Yes
 34263 000051EE F9                      	stc				;;AN000;; Set carry flag
 34264                                  $MIF141:
 34265 000051EF 47                      	inc	di			;;AN000;;
 34266 000051F0 47                      	inc	di			;;AN000;;
 34267 000051F1 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34268                                  $MEN139:
 34269                                  $MIF138:
 34270 000051F3 5F                      	pop	di			;;AN000;; Restore DI register
 34271 000051F4 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34272 000051F5 C3                      	retn				;;AN000;; Return
 34273                                  
 34274                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34275                                  ;;
 34276                                  ;;	PROC NAME: $M_CONVERT2ASC
 34277                                  ;;
 34278                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34279                                  ;;	INPUTS: DX:AX contains the number to be converted
 34280                                  ;;		$M_RT_DIVISOR contains the divisor
 34281                                  ;;	OUTPUTS: CX contains the number of characters
 34282                                  ;;		Top of stack  --> Last character
 34283                                  ;;				     . . .
 34284                                  ;;		Bot of stack  --> First character
 34285                                  ;;	REGS USED:
 34286                                  ;;
 34287                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34288                                  
 34289                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34290                                  	; 15/06/2023
 34291                                  $M_CONVERT2ASC:
 34292 000051F6 8F06[1287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34293                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34294                                  	
 34295 000051FA 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34296 000051FC 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34297 000051FD 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34298                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34299 000051FE F736[1687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34300                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34301 00005202 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34302                                  						;;AN000;;  and save reduced High Word in BX
 34303 00005203 F736[1687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34304                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34305                                  
 34306 00005207 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34307 0000520A 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34308 0000520C 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34309 0000520F EB03                    	jmp	short $MEN146
 34310                                  $MIF146:
 34311 00005211 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34312                                  $MEN146:
 34313 00005214 52                      	push	dx				;;AN000;; Save the digit on the stack
 34314 00005215 41                      	inc	cx				;;AN000;; Count that digit
 34315 00005216 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34316 00005218 7504                    	jnz	short $MLL149			;;AN000;; No
 34317 0000521A 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34318 0000521C 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34319                                  $MLL149:
 34320 0000521E 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34321                                  ; 28/04/2023
 34322 00005221 740A                    	je	short $MIF153
 34323                                  ;	jne	short $MIF150			;;AN000;; No
 34324                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34325                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34326                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34327                                  ;	;jne	short $MIF151
 34328                                  ;	; 09/04/2023
 34329                                  ;	jne	short $MEN150
 34330                                  ;						;;AN000;; Yes
 34331                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34332                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34333                                  ;	inc	cx				;;AN000;;
 34334                                  ;$MIF151:
 34335                                  ;	jmp	short $MEN150
 34336                                  
 34337                                  $MIF150:
 34338                                  	; 15/06/2023 (6)
 34339                                  	; MSDOS 6.0
 34340                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34341                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34342                                  	; 15/06/2023 (7)
 34343                                  	; MSDOS 6.22
 34344                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34345 00005223 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34346                                  
 34347                                  ; 28/04/2023
 34348 00005226 7405                    	je	short $MIF153
 34349                                  ;	jne	short $MIF154			;;AN000;; No
 34350                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34351                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34352                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34353                                  ;	;jne	short $MIF155			;;AN000;; No
 34354                                  ;	; 09/04/2023
 34355                                  ;	jne	short $MEN154
 34356                                  ;						;;AN000;; Yes
 34357                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34358                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34359                                  ;	inc	cx				;;AN000;;
 34360                                  ;$MIF155:
 34361                                  ;	jmp	short $MEN154
 34362                                  
 34363                                  $MIF154:
 34364                                  	; 15/06/2023 (9)
 34365                                  	; MSDOS 6.0
 34366                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh
 34367                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34368                                  	; 15/06/2023 (11)
 34369                                  	; MSDOS 6.22
 34370                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah 
 34371 00005228 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34372 0000522B 750B                    	jne	short $MIF158			;;AN000;; No
 34373                                  ; 28/04/2023
 34374                                  $MIF153:
 34375                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34376 0000522D 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34377                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34378 00005231 7505                    	jne	short $MIF159			;;AN000;; No
 34379                                  						;;AN000;; Yes
 34380 00005233 FF36[1F87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34381                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34382 00005237 41                      	inc	cx				;;AN000;;
 34383                                  $MIF159:
 34384                                  $MIF158:
 34385                                  $MEN154:
 34386                                  $MEN150:					;;AN000;;
 34387 00005238 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34388                                  						;;AN000;;  and Revised Low Word
 34389 00005239 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34390                                  	; 28/04/2023
 34391 0000523B EBC1                    	jmp	short $MDO145
 34392                                  ;$MEN145:
 34393                                  	; 28/04/2023
 34394                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34395                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34396 0000523D 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34397 0000523F FF36[1287]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34398                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34399 00005243 C3                      	retn					;;AN000;; Return
 34400                                  
 34401                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34402                                  ;;
 34403                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34404                                  ;;
 34405                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34406                                  ;;	INPUTS:    ES:DI points to beginning of message
 34407                                  ;;		   DS:SI points to first sublist structure in chain
 34408                                  ;;		   BX contains the handle to write to (if applicable)
 34409                                  ;;		   CX contains the length of string to write (before substitutions)
 34410                                  ;;		   BP contains the count of replacables
 34411                                  ;;
 34412                                  ;;	OUTPUTS:
 34413                                  ;;	REGS USED: All
 34414                                  ;;
 34415                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34416                                  
 34417                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34418                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34419                                  
 34420                                  $M_DISPLAY_MESSAGE:
 34421                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34422                                  $MDO165:
 34423 00005244 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34424 00005246 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34425                                  ;; $IF NZ					;;AN000;; No
 34426 00005248 741F                    	jz	short $MIF166			;;AN000;; Yes
 34427                                  	;mov	ah,"%"				;;AN000;; Prepare to scan for %
 34428                                  	;mov	al,0				;;AN004;;
 34429                                  	; 12/08/2024
 34430 0000524A B80025                  	mov	ax,2500h
 34431                                  ;; $DO						;;AN000;; Scan through string until %
 34432                                  $MDO167:
 34433 0000524D 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34434                                  ;; $LEAVE E,AND					;;AN000;; No
 34435 00005250 750A                    	jne	short $MLL168
 34436 00005252 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34437                                  ;; $LEAVE NE,AND				;;AN000;; No
 34438 00005256 7404                    	je	short $MLL168
 34439                                  
 34440 00005258 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34441                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34442 0000525A 750D                    	jne	short $MEN167 ; 12/08/2024
 34443                                  $MLL168:
 34444 0000525C 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34445 0000525F E870FF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34446                                  ;;; $IF C					;;AN004;; Yes
 34447 00005262 7301                    	jnc	short $MIF169
 34448 00005264 47                      	inc	di				;;AN004;; Increment past second part
 34449                                  ;;; $ENDIF					;;AN004;;
 34450                                  $MIF169:
 34451 00005265 47                      	inc	di				;;AN000;; Next character in string
 34452 00005266 42                      	inc	dx				;;AN000;; Size = Size + 1
 34453                                  	;dec	cx				;;AN000;; Decrement total size
 34454                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34455                                  	;jnz	short $MDO167
 34456                                  	; 12/08/2024
 34457 00005267 E2E4                    	loop	$MDO167
 34458                                  $MEN167:
 34459                                  ;; $ENDIF					;;AN000;;
 34460                                  $MIF166:
 34461 00005269 56                      	push	si				;;AN000;; Save beginning of sublists
 34462 0000526A 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34463 0000526C 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34464                                  ;; $IF NZ					;;AN000;; Yes
 34465 0000526E 7431                    	jz	short $MIF173
 34466 00005270 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34467                                  
 34468                                  ;; Search through sublists to find applicable one
 34469                                  
 34470 00005271 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34471                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34472                                  ;;; $IF E					;;AN000;; No
 34473 00005276 7529                    	jne	short $MIF174
 34474                                  ;;; $SEARCH					;;AN000;;
 34475                                  $MDO175:
 34476                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34477 00005278 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34478                                  	;mov	al,[si+6]
 34479 0000527B 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34480                                  	; 28/04/2023					
 34481 0000527D 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34482                                  ;;; $EXITIF E					;;AN000;;
 34483                                  	;jne	short $MIF175
 34484                                  ;;; $ORELSE					;;AN000;; No
 34485                                  	;jmp	short $MSR175
 34486                                  	; 28/04/2023
 34487 00005281 741E                    	je	short $MSR175
 34488                                  $MIF175:
 34489 00005283 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34490                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34491 00005285 7504                    	jne	short $MLL178
 34492 00005287 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34493                                  ;;; $LEAVE Z					;;AN000;; No
 34494 00005289 7404                    	jz	short $MEN175
 34495                                  $MLL178:
 34496                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34497                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34498                                  	;;add	si,[si+0]
 34499 0000528B 0334                    	add	si,[si]
 34500                                  ;;; ENDLOOP					;;AN000;; Yes
 34501 0000528D EBE9                    	jmp	short $MDO175
 34502                                  $MEN175:
 34503 0000528F 803E[1187]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34504                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34505                                  ;;;; $IF E					;;AN004;; Yes
 34506 00005294 7508                    	jne	short $MIF180
 34507 00005296 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34508 00005297 42                      	inc	dx				;;AN000;;  at the end of the message
 34509 00005298 49                      	dec	cx				;;AN000;; Adjust message length
 34510 00005299 49                      	dec	cx				;;AN000;;
 34511 0000529A 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34512 0000529B 4F                      	dec	di				;;AN000;;
 34513                                  ;;;; $ELSE					;;AN004;; No
 34514 0000529C EB03                    	jmp	short $MEN180
 34515                                  $MIF180:
 34516 0000529E BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34517                                  ;;;; $ENDIF					;;AN004;;
 34518                                  $MEN180:
 34519                                  ;;; $ENDSRCH					;;AN000;;
 34520                                  $MSR175:
 34521                                  ;; $ENDIF					;;AN000;;
 34522                                  $MIF174:
 34523                                  ; $ENDIF					;;AN000;;
 34524                                  $MIF173:
 34525                                  ;; Prepare and display this part of message
 34526                                  
 34527 000052A1 57                      	push	di				;;AN000;; Save pointer to replace number
 34528 000052A2 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34529 000052A4 E835FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34530 000052A7 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34531 000052A8 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34532                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34533                                  	;jnc	short $MXL3
 34534                                  	;jmp	$MEN165
 34535                                  	; 02/05/2023
 34536 000052A9 7214                    	jc	short $MEN165
 34537                                  $MXL3:
 34538 000052AB 51                      	push	cx				;;AN000;;
 34539                                  
 34540                                  ;; Save and reset pointer registers
 34541                                  
 34542 000052AC 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34543                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34544 000052AE 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34545                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34546                                  ; $IF NE					;;AN000;; No
 34547 000052B2 7412                    	je	short $MIF187			;;AN000;; Yes			
 34548 000052B4 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34549                                  ;; $IF NZ					;;AN000;; No
 34550 000052B6 7406                    	jz	short $MIF188			;;AN000;; Yes
 34551 000052B8 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34552 000052B9 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34553 000052BA 47                      	inc	di				;;AN000;; Go past %
 34554 000052BB 47                      	inc	di				;;AN000;; Go past replace number
 34555                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34556                                  	;jmp	short $MEN188
 34557                                  	; 28/04/2023
 34558 000052BC EB15                    	jmp	short $MEN187
 34559                                  $MIF188:
 34560 000052BE 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34561                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34562                                  $MEN188:
 34563                                  ; $ELSE 					;;AN000;;
 34564                                  	;jmp	short $MEN187
 34565                                  	; 28/04/2023
 34566                                  	; zf = 1
 34567                                  	;jmp	short $MEN165 
 34568                                  
 34569                                  ; 28/04/2023
 34570                                  $MXL4:
 34571                                  $MLL214:
 34572                                  $MEN165:
 34573 000052BF C706[1487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34574                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34575                                  						;;AN000;; Reset message number to null
 34576 000052C5 C3                      	retn					;;AN000;; Return
 34577                                  
 34578                                  $MIF187:
 34579 000052C6 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34580                                  ;; $IF Z					;;AN004;; No
 34581                                  	;jnz	short $MIF192
 34582                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34583                                  ;; $ELSE					;;AN000;; No
 34584                                  	;jmp	short $MEN192
 34585                                  	; 28/04/2023
 34586 000052C8 74F4                    	jz	short $MIF188
 34587                                  $MIF192:
 34588 000052CA 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34589                                  ;;; $IF Z					;;AN004;; No
 34590 000052CD 7502                    	jnz	short $MIF194
 34591 000052CF 31C9                    	xor	cx,cx				;;AN004;;
 34592                                  ;;; $ENDIF					;;AN000;;
 34593                                  $MIF194:
 34594 000052D1 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34595                                  ;; $ENDIF					;;AN000;;
 34596                                  $MEN192:
 34597                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34598                                  $MEN187:
 34599                                  ; $LEAVE Z					;;AN000;;
 34600 000052D3 74EA                    	jz	short $MEN165
 34601                                  	;
 34602 000052D5 55                      	push	bp				;;AN000;; Save the replace count
 34603 000052D6 57                      	push	di				;;AN000;; Save location to complete message
 34604 000052D7 06                      	push	es				;;AN000;;
 34605 000052D8 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34606 000052D9 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34607                                  
 34608                                  ;; Determine what action is required on parameter
 34609                                  
 34610 000052DB 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34611                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34612                                  ; $IF E						;;AN000;;
 34613 000052E0 753B                    	jne	short $MIF199
 34614                                  
 34615                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34616 000052E2 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34617                                  	;test	byte [si+7],0Fh			;;AN000;;
 34618                                  ;; $IF Z					;;AN000;;
 34619 000052E6 7508                    	jnz	short $MIF200
 34620                                  
 34621                                  ;; Character type requested
 34622                                  
 34623                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34624 000052E8 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34625                                  	;les	di,[si+2]
 34626 000052EB E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34627                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34628 000052EE EB28                    	jmp	short $MEN200
 34629                                  $MIF200:
 34630                                  ;; ENDIF					;;AN000;;
 34631                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34632 000052F0 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34633                                  	;test	byte [si+7],0Dh			;;AN000;;
 34634                                  ;; $IF Z,OR					;;AN000;;
 34635 000052F4 740C                    	jz	short $MLL202
 34636                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34637 000052F6 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34638                                  	;test	byte [si+7],0Eh			;;AN000;;
 34639                                  ;;; $IF Z,OR					;;AN000;;
 34640 000052FA 7406                    	jz	short $MLL202
 34641                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34642 000052FC F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34643                                  	;test	byte [si+7],0Ch			;;AN000;;
 34644                                  ;;;; $IF Z 					;;AN000;;
 34645 00005300 7508                    	jnz	short $MIF202
 34646                                  $MLL202:
 34647                                  
 34648                                  ;; Numeric type requested
 34649                                  
 34650                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34651 00005302 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34652 00005305 E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34653                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34654 00005308 EB0E                    	jmp	short $MEN202
 34655                                  $MIF202:
 34656                                  ;;;; ENDIF					;;AN000;;
 34657                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34658 0000530A F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34659                                  	;test	byte [si+7],0Bh			;;AN000;;
 34660                                  ;;;; $IF E					;;AN000;;
 34661 0000530E 7505                    	jnz	short $MIF204
 34662                                  
 34663                                  ;; Date type requested
 34664                                  
 34665 00005310 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34666                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34667 00005313 EB03                    	jmp	short $MEN204
 34668                                  $MIF204:					;;AN000;;
 34669                                  
 34670                                  ;; Time type requested (Default if we have not matched until here)
 34671                                  
 34672 00005315 E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34673                                  
 34674                                  ;;;; $ENDIF					;;AN000;;
 34675                                  $MEN204:
 34676                                  ;;; $ENDIF					;;AN000;;
 34677                                  $MEN202:
 34678                                  ;; $ENDIF					;;AN000;;
 34679                                  $MEN200:
 34680                                  
 34681                                  ;; With the replace information of the Stack, display the replaceable field
 34682                                  
 34683 00005318 E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34684                                  
 34685                                  ;; None of the above - Extended/Parse replace
 34686                                  ; $ELSE 					;;AN000;;
 34687 0000531B EB03                    	jmp	short $MEN199
 34688                                  $MIF199:
 34689 0000531D E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34690                                  ; $ENDIF					;;AN000;;
 34691                                  $MEN199:
 34692                                  
 34693                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34694                                  
 34695                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34696 00005320 7207                    	jc	short $MIF211
 34697                                  	;
 34698 00005322 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34699 00005323 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34700 00005324 5F                      	pop	di				;;AN000;;
 34701 00005325 5D                      	pop	bp				;;AN000;; Get replacment count
 34702 00005326 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34703                                  ; $ELSE						;;AN000;;
 34704 00005327 EB03                    	jmp	short $MEN211
 34705                                  $MIF211:
 34706 00005329 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34707                                  	; 28/04/2023
 34708                                  	;stc					;;AN000;;
 34709                                  ; $ENDIF					;;AN000;;
 34710                                  $MEN211:
 34711 0000532C 833E[1487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34712                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34713                                  ; $ENDDO NE,OR					;;AN000;;
 34714 00005331 758C                    	jne	short $MLL214
 34715                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34716                                  	; 10/04/2023
 34717                                  	;jc	short $MXL4
 34718 00005333 E90EFF                  	jmp	$MDO165
 34719                                  
 34720                                  ; 28/04/2023
 34721                                  ;$MXL4:
 34722                                  ;$MLL214:
 34723                                  ;$MEN165:
 34724                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34725                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34726                                  ;						;;AN000;; Reset message number to null
 34727                                  ;	retn					;;AN000;; Return
 34728                                  
 34729                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34730                                  ;;
 34731                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34732                                  ;;
 34733                                  ;;	FUNCTION:
 34734                                  ;;	INPUTS:
 34735                                  ;;	OUPUTS:
 34736                                  ;;
 34737                                  ;;	REGS USED:
 34738                                  ;;
 34739                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34740                                  
 34741                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34742                                  
 34743                                  $M_EXT_PAR_REPLACE:
 34744 00005336 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34745 00005338 A1[1487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34746                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34747 0000533B C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34748                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34749 00005341 E8B2FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34750                                  $MDO215:
 34751 00005344 58                      	pop	ax				;;AN000;; Get character in register
 34752 00005345 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34753                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34754 00005349 43                      	inc	bx				;;AN000;; Increase buffer count
 34755 0000534A 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34756 0000534D 7503                    	jne	short $MIF216			;;AN000;; No
 34757 0000534F E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34758                                  $MIF216:
 34759 00005352 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34760 00005354 75EE                    	jnz	short $MDO215
 34761                                  
 34762 00005356 B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34763 00005359 8987[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34764                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34765 0000535D 43                      	inc	bx				;;AN000;; Increase buffer count
 34766 0000535E 43                      	inc	bx				;;AN000;; Increase buffer count
 34767                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34768                                  	;retn					;;AN000::
 34769                                  	; 11/04/2023
 34770                                  	;jmp	$M_FLUSH_BUF
 34771                                  
 34772                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34773                                  ;;
 34774                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34775                                  ;;
 34776                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34777                                  ;;	INPUTS: DI contains the number of bytes to display
 34778                                  ;;	OUTPUTS: BX reset to zero
 34779                                  ;;
 34780                                  ;;	REGS USED:
 34781                                  ;;
 34782                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34783                                  	
 34784                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34785                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34786                                  
 34787                                  $M_FLUSH_BUF:
 34788 0000535F 51                      	push	cx				;;AN000;; Save changed regs
 34789 00005360 06                      	push	es				;;AN000;;
 34790 00005361 57                      	push	di				;;AN000;;
 34791 00005362 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34792 00005363 07                      	pop	es				;;AN000;;
 34793 00005364 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34794 00005366 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34795 00005368 8D3E[1887]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34796                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34797 0000536C E86DFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34798 0000536F 7204                    	jc	short $MIF314
 34799 00005371 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34800 00005372 07                      	pop	es				;;AN000;;
 34801 00005373 59                      	pop	cx				;;AN000;;
 34802                                  	;jmp	short $MEN314
 34803                                  	; 11/04/2023
 34804 00005374 C3                      	retn
 34805                                  $MIF314:
 34806 00005375 83C406                  	add	sp,6				;;AN000;; Fix stack
 34807 00005378 F9                      	stc					;;AN000;;
 34808                                  $MEN314:
 34809 00005379 C3                      	retn					;;AN000;; Return
 34810                                  
 34811                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34812                                  ;;
 34813                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34814                                  
 34815                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34816                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34817                                  
 34818                                  $M_DISPLAY_REPLACE:
 34819 0000537A 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34820                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34821 0000537C 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34822                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34823 00005380 7511                    	jne	short $MIF276
 34824                                  	
 34825 00005382 C787[1887]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34826                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34827                                  	
 34828 00005388 43                      	inc	bx				;;AN000;; Increment count
 34829 00005389 43                      	inc	bx				;;AN000;; Increment count
 34830                                  	
 34831 0000538A C687[1887]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34832                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34833                                  	
 34834 0000538F 43                      	inc	bx				;;AN000;; Increment count
 34835 00005390 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34836                                  $MIF276:
 34837 00005393 5D                      	pop	bp				;;AN000;; Remember the return address
 34838 00005394 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34839 00005396 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34840                                  
 34841 00005398 880E[0E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34842                                  	;mov	[$M_RT+66],cl
 34843                                  	
 34844                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34845 0000539C 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34846                                  	;mov	al,[si+9]
 34847                                  	
 34848 0000539F 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34849 000053A1 761E                    	jna	short $MIF278
 34850 000053A3 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34851 000053A5 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34852                                  	
 34853                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34854 000053A7 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34855                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34856 000053AB 7414                    	jz	short $MIF279			;;AN000;; No
 34857                                  $MDO280:
 34858                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34859 000053AD 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34860                                  	;mov	al,[si+0Ah]
 34861 000053B0 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34862                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34863                                  	
 34864 000053B4 43                      	inc	bx				;;AN000;;
 34865 000053B5 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34866 000053B8 7503                    	jne	short $MIF281
 34867 000053BA E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34868                                  $MIF281:
 34869 000053BD FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34870 000053BF 75EC                    	jnz	short $MDO280
 34871                                  $MIF279:
 34872                                  $MIF278:
 34873                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34874 000053C1 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34875                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34876 000053C5 740C                    	je	short $MIF286
 34877                                  	
 34878                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34879 000053C7 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34880                                  	;;cmp	byte [si+8],cl
 34881 000053CA 7307                    	jnb	short $MIF287
 34882                                  
 34883                                  	; 03/05/2023
 34884                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34885                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34886                                  	;;sub	cl,[si+8]
 34887 000053CC 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34888                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34889                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34890                                  	;;mov	cl,[si+8]
 34891                                  	; 03/05/2023
 34892 000053CE 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34893 000053D1 28CA                    	sub	dl,cl
 34894                                  $MIF287:
 34895                                  $MIF286:
 34896 000053D3 09C9                    	or	cx,cx				;;AN000;;
 34897 000053D5 7424                    	jz	short $MIF290			;;AN000;;
 34898                                  $MDO291:
 34899                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34900 000053D7 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34901                                  	;test	byte [si+7],0Fh			;;AN000;;
 34902 000053DB 750C                    	jnz	short $MIF292
 34903                                  
 34904                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34905 000053DD F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34906                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34907 000053E1 7406                    	jz	short $MIF292			;;AN000;; No
 34908                                  
 34909 000053E3 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34910 000053E6 47                      	inc	di				;;AN000;; Next character in string
 34911 000053E7 EB01                    	jmp	short $MEN292
 34912                                  $MIF292:
 34913 000053E9 58                      	pop	ax				;;AN000;; Get character in register
 34914                                  $MEN292:
 34915                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34916 000053EA 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34917                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34918                                  	; 03/05/2023
 34919 000053EE 43                      	inc	bx				;;AN000;; Increase buffer count
 34920 000053EF 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34921 000053F2 7503                    	jne	short $MIF295			;;AN000;;
 34922 000053F4 E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34923                                  $MIF295:
 34924 000053F7 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34925 000053F9 75DC                    	jnz	short $MDO291
 34926                                  $MIF290:
 34927                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34928 000053FB F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34929                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34930 000053FF 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34931 00005401 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34932 00005403 7414                    	jz	short $MIF300
 34933                                  $MDO301:
 34934                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34935 00005405 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34936                                  	;mov	al,[si+0Ah]
 34937                                  
 34938                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34939 00005408 8887[1887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34940                                  	; 03/05/2023
 34941                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34942                                  
 34943 0000540C 43                      	inc	bx				;;AN000;;
 34944 0000540D 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34945 00005410 7503                    	jne	short $MIF302			;;AN000;; No
 34946                                  						;;AN000;; Yes
 34947 00005412 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34948                                  $MIF302:
 34949 00005415 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34950 00005417 75EC                    	jnz	short $MDO301			;;AN000;;
 34951                                  $MIF300:
 34952                                  $MIF299:
 34953                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34954 00005419 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34955                                  	;test	byte [si+7],0Fh			;;AN000;;
 34956 0000541D 7506                    	jnz	short $MIF307
 34957                                  	
 34958                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34959 0000541F F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34960                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34961                                  	; 11/04/2023
 34962                                  	;jz	short $MIF307			;;AN000;;
 34963                                  	;jmp	short $MEN307			;;AN000;;
 34964 00005423 750C                    	jnz	short $MEN307
 34965                                  $MIF307:
 34966 00005425 08D2                    	or	dl,dl				;;AN000;;
 34967 00005427 7408                    	jz	short $MIF309			;;AN000;;
 34968                                  $MDO310:
 34969 00005429 8F06[1287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34970                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34971 0000542D FECA                    	dec	dl				;;AN000;; Are we done?
 34972 0000542F 75F8                    	jnz	short $MDO310
 34973                                  $MIF309:
 34974                                  $MEN307:
 34975 00005431 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34976 00005434 55                      	push	bp				;;AN000;; Restore the return address
 34977 00005435 C3                      	retn					;;AN000;;
 34978                                  
 34979                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34980                                  ;;
 34981                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34982                                  ;;
 34983                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34984                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34985                                  ;;		ES:DI contains the VALUE from SUBLIST
 34986                                  ;;	OUTPUTS: CX contains number of characters on stack
 34987                                  ;;		 Top of stack  --> Last character
 34988                                  ;;					. . .
 34989                                  ;;		 Bot of stack  --> First character
 34990                                  ;;
 34991                                  ;;	OTHER REGS Revised: AX
 34992                                  ;;
 34993                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34994                                  
 34995                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34996                                  
 34997                                  $M_CHAR_REPLACE:
 34998 00005436 5D                      	pop	bp				;;AN000;; Save return address
 34999                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 35000 00005437 F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 35001                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 35002 0000543B 7512                    	jnz	short $MIF317			;;AN000;; No
 35003 0000543D 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35004 00005440 50                      	push	ax				;;AN000;; Put it on the stack
 35005 00005441 41                      	inc	cx				;;AN000;; Increase the count
 35006 00005442 E88DFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 35007 00005445 7306                    	jnc	short $MIF318
 35008 00005447 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 35009 0000544B 50                      	push	ax				;;AN000;; Put it on the stack
 35010 0000544C F8                      	clc					;;AN000;; Clear the carry
 35011                                  $MIF318:
 35012 0000544D EB0D                    	jmp	short $MEN317
 35013                                  $MIF317:
 35014                                  $MDO321:
 35015 0000544F 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35016 00005452 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 35017 00005454 7404                    	jz	short $MEN321			;;AN000;; Yes
 35018 00005456 47                      	inc	di				;;AN000;; Next character
 35019 00005457 41                      	inc	cx				;;AN000;; Increment the count
 35020 00005458 EBF5                    	jmp	short $MDO321
 35021                                  $MEN321:
 35022 0000545A 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 35023                                  $MEN317:
 35024 0000545C 55                      	push	bp				;;AN000;; Restore return address
 35025 0000545D C3                      	retn					;;AN000;;	
 35026                                  
 35027                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35028                                  ;;
 35029                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 35030                                  ;;
 35031                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 35032                                  ;;		  and prepare to display
 35033                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35034                                  ;;		ES:DI contains the VALUE from SUBLIST
 35035                                  ;;	OUTPUTS: CX contains number of characters on stack
 35036                                  ;;		 Top of stack  --> Last character
 35037                                  ;;					. . .
 35038                                  ;;		 Bot of stack  --> First character
 35039                                  ;;	OTHER REGS Revised: BX,DX,AX
 35040                                  ;;
 35041                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35042                                  
 35043                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35044                                  
 35045                                  $M_BIN2ASC_REPLACE:
 35046 0000545E 5D                      	pop	bp				;;AN000;; Save return address
 35047 0000545F 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35048 00005461 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 35049 00005463 C706[1687]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 35050                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 35051                                  
 35052 00005469 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 35053                                  
 35054                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 35055 0000546B F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35056                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 35057 0000546F 7511                    	jnz	short $MIF325			;;AN000;; No
 35058                                  	
 35059 00005471 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 35060                                  
 35061                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35062 00005474 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35063                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 35064 00005478 753D                    	jnz	short $MIF326			;;AN000;; No
 35065                                  			 
 35066 0000547A A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 35067 0000547C 7433                    	jz	short $MIF327			;;AN000;; No
 35068                                  						;;AN000;; Yes				
 35069                                  	; 12/04/2023
 35070                                  	;inc	bx				;;AN000;; Remember that it was negative
 35071 0000547E 247F                    	and	al,01111111b			;;AN000;; Make it positive
 35072                                  
 35073                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 35074                                  	;jmp	short $MIF327
 35075 00005480 EB2E                    	jmp	short $MIF350 ; inc bx
 35076                                  
 35077                                  ; 12/04/2023
 35078                                  %if 0
 35079                                  
 35080                                  $MIF327:
 35081                                  $MIF335:	; 12/04/2023
 35082                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35083                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35084                                  $MIF326:
 35085                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35086                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35087                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35088                                  	jnz	short $MIF330			;;AN000;; No
 35089                                  						;;AN000;; Yes
 35090                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35091                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35092                                  $MIF330:
 35093                                  	jmp	short $MEN325
 35094                                  
 35095                                  %endif
 35096                                  
 35097                                  $MIF325:
 35098                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 35099 00005482 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35100                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 35101 00005486 7513                    	jnz	short $MIF333			;;AN000;; No
 35102                                  						;;AN000;; Yes
 35103 00005488 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 35104                                  
 35105                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35106 0000548B F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35107                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35108 0000548F 7526                    	jnz	short $MIF334			;;AN000;; No
 35109                                  						;;AN000;; Yes
 35110 00005491 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 35111 00005494 741B                    	jz	short $MIF335			;;AN000;; No
 35112                                  						;;AN000;; Yes
 35113                                  	; 12/04/2023
 35114                                  	;inc	bx				;;AN000;; Remember that it was negative
 35115 00005496 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 35116                                  
 35117                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35118                                  	;jmp	short $MIF335
 35119 00005499 EB15                    	jmp	short $MIF350 ; inc bx
 35120                                  
 35121                                  ; 12/04/2023
 35122                                  %if 0
 35123                                  
 35124                                  $MIF335:
 35125                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35126                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35127                                  $MIF334:
 35128                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 35129                                  	jnz	short $MIF338
 35130                                  
 35131                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35132                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35133                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35134                                  	jnz	short $MIF338			;;AN000;; No
 35135                                  						;;AN000;; Yes
 35136                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35137                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35138                                  $MIF338:
 35139                                  	jmp	short $MEN333			;;AN000;;
 35140                                  %endif
 35141                                  
 35142                                  $MIF333:
 35143 0000549B 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35144 0000549E 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35145                                  
 35146                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35147 000054A2 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35148                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35149 000054A6 750F                    	jnz	short $MIF341			;;AN000;; No
 35150                                  						;;AN000;; Yes
 35151 000054A8 F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35152 000054AB 7404                    	jz	short $MIF342			;;AN000;; No
 35153                                  						;;AN000;; Yes
 35154                                  	; 12/04/2023
 35155                                  	;inc	bx				;;AN000;; Remember that it was negative
 35156 000054AD 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35157                                  	
 35158                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35159                                  $MIF350:
 35160 000054B0 43                      	inc	bx
 35161                                  $MIF342:
 35162                                  	; 12/04/2023
 35163                                  $MIF327:
 35164                                  $MIF335:
 35165 000054B1 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35166                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35167                                  $MIF341:
 35168                                  $MIF326:
 35169                                  	; 18/04/2023
 35170                                  $MIF334:
 35171                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35172 000054B7 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35173                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35174 000054BB 7506                    	jnz	short $MIF345			;;AN000;; No
 35175                                  						;;AN000;; Yes
 35176 000054BD C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35177                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35178                                  $MIF345:
 35179                                  $MEN333:
 35180                                  $MEN325:
 35181 000054C3 E830FD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35182                                  
 35183 000054C6 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35184 000054C8 7405                    	jz	short $MIF349			;;AN000;; No
 35185                                  						;;AN000;; Yes
 35186 000054CA 31D2                    	xor	dx,dx				;;AN000;;
 35187 000054CC B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35188 000054CE 52                      	push	dx				;;AN000;;
 35189                                  $MIF349:
 35190 000054CF 55                      	push	bp				;;AN000;; Restore return address
 35191 000054D0 C3                      	retn					;;AN000;; Return
 35192                                  
 35193                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35194                                  ;;
 35195                                  ;;	PROC NAME: $M_DATE_REPLACE
 35196                                  ;;
 35197                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35198                                  ;;		  country format and prepare to display
 35199                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35200                                  ;;		ES:DI points at VALUE from SUBLIST
 35201                                  ;;	OUTPUTS: CX contains number of characters on stack
 35202                                  ;;		 Top of stack  --> Last character
 35203                                  ;;					. . .
 35204                                  ;;		 Bot of stack  --> First character
 35205                                  ;;	OTHER REGS Revised: DX,AX
 35206                                  ;;
 35207                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35208                                  
 35209                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35210                                  $M_DATE_REPLACE:
 35211 000054D1 5D                      	pop	bp				;;AN000;; Save return address
 35212                                  
 35213 000054D2 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35214                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35215                                  	
 35216 000054D8 E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35217                                  						;;AN000;; All O.K.?
 35218 000054DB 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35219                                  	; 12/04/2023
 35220                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35221                                  	
 35222                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35223                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35224                                  	;jne	short $MIF351
 35225                                  	; 12/04/2023
 35226 000054DD A1[1887]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35227 000054E0 09C0                    	or	ax,ax
 35228 000054E2 751D                    	jnz	short $MIF351
 35229                                  
 35230 000054E4 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35231 000054E7 E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35232                                  
 35233 000054EA FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35234                                  	;push	word [$M_RT+87]			;;AN000;;
 35235                                  	
 35236 000054EE 41                      	inc	cx				;;AN000;; Increment count
 35237 000054EF 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35238                                  
 35239 000054F1 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35240                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35241 000054F4 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35242                                  	
 35243 000054F7 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35244                                  	;push	word [$M_RT+87]			;;AN000;;
 35245                                  
 35246 000054FB 41                      	inc	cx				;;AN000;; Increment count
 35247 000054FC 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35248                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35249                                  	; 12/04/2023
 35250                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35251 000054FF EB3C                    	jmp	short $MIF354 ; **
 35252                                  $MIF351:
 35253                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35254                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35255                                  	;jne	short $MIF353
 35256                                  	; 12/04/2023
 35257                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35258 00005501 48                      	dec	ax 
 35259 00005502 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35260                                  
 35261 00005504 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35262 00005507 E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35263                                  
 35264 0000550A FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35265                                  	;push	word [$M_RT+87]			;;AN000;;
 35266                                  	
 35267 0000550E 41                      	inc	cx				;;AN000;; Increment count
 35268 0000550F 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35269                                  
 35270 00005511 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35271                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35272 00005514 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35273                                  
 35274 00005517 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35275                                  	;push	word [$M_RT+87]			;;AN000;;
 35276                                  
 35277 0000551B 41                      	inc	cx				;;AN000;;
 35278                                  	      
 35279 0000551C 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35280                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35281                                  
 35282                                  	; 12/04/2023
 35283                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35284 0000551F EB1C                    	jmp	short $MIF354 ; **
 35285                                  	; 12/04/2023
 35286                                  $MIF352:
 35287                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35288 00005521 48                      	dec	ax
 35289                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35290                                  	;xor	ax,ax
 35291                                  	;jmp	short $MIF355
 35292                                  	; 12/04/2023
 35293 00005522 751C                    	jnz	short $MIF355
 35294                                  $MIF353:
 35295                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35296                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35297                                  	;jne	short $MIF355
 35298                                  
 35299 00005524 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35300                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35301 00005527 E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35302                                  	
 35303 0000552A FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35304                                  	;push	word [$M_RT+87]			;;AN000;;
 35305                                  
 35306 0000552E 41                      	inc	cx				;;AN000;;
 35307                                  
 35308 0000552F 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35309                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35310 00005532 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35311                                  	
 35312 00005535 FF36[2387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35313                                  	;push	word [$M_RT+87]			;;AN000;;
 35314                                  	
 35315 00005539 41                      	inc	cx				;;AN000;;
 35316                                  
 35317 0000553A E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35318                                  	; 12/04/2023
 35319                                  $MIF354:
 35320 0000553D E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35321                                  $MIF355:
 35322 00005540 55                      	push	bp				;;AN000;; Restore return address
 35323 00005541 C3                      	retn					;;AN000;; Return
 35324                                  
 35325                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35326                                  ;;
 35327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35328                                  
 35329                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35330                                  $M_GET_DATE:
 35331                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35332                                  	;mov	al,0 				;;AN000;; Get current country info
 35333                                  	; 12/04/2023
 35334 00005542 B80038                  	mov	ax,3800h
 35335                                  	;
 35336 00005545 8D16[1887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35337                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35338 00005549 CD21                    	int	21h				;;AN000;;
 35339 0000554B 730B                    	jnc	short $MIF357
 35340                                  	;
 35341 0000554D C706[1887]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35342                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35343 00005553 C606[2387]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35344                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35345                                  $MIF357:
 35346 00005558 C3                      	retn					;;AN000;;
 35347                                  
 35348                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35349                                  ;;
 35350                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35351                                  
 35352                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35353                                  $M_YEAR:
 35354 00005559 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35355                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35356                                  
 35357                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35358 0000555C F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35359                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35360 00005560 7508                    	jnz	short $MIF359			;;AN000;; No
 35361                                  						;;AN000;; Yes
 35362 00005562 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35363 00005565 7603                    	jna	short $MIF360			;;AN000;;
 35364 00005567 B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35365                                  $MIF360:
 35366                                  $MIF359:
 35367 0000556A C3                      	retn					;;AN000;;
 35368                                  
 35369                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35370                                  ;;
 35371                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35372                                  
 35373                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35374                                  $M_CONVERTDATE:
 35375                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35376 0000556B 8F06[1887]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35377                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35378 0000556F 880E[0E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35379                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35380 00005573 E880FC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35381 00005576 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35382 00005577 3A0E[0E87]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35383 0000557B 7505                    	jne	short $MIF363			;;AN000;; No
 35384 0000557D B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35385 00005580 50                      	push	ax				;;AN000;; Save it
 35386 00005581 41                      	inc	cx				;;AN000;; Count it
 35387                                  $MIF363:
 35388 00005582 41                      	inc	cx				;;AN000;; Restore CX
 35389 00005583 FF36[1887]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35390                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35391 00005587 C3                      	retn
 35392                                  
 35393                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35394                                  ;;
 35395                                  ;;	PROC NAME: $M_TIME_REPLACE
 35396                                  ;;
 35397                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35398                                  ;;		  and prepare to display
 35399                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35400                                  ;;		ES:DI points at VALUE from SUBLIST
 35401                                  ;;	OUTPUTS: CX contains number of characters on stack
 35402                                  ;;		 Top of stack  --> Last character
 35403                                  ;;					. . .
 35404                                  ;;		 Bot of stack  --> First character
 35405                                  ;;	REGS USED: BP,CX,AX
 35406                                  ;;
 35407                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35408                                  
 35409                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35410                                  	; 13/08/2024							     ;;
 35411                                  $M_TIME_REPLACE:
 35412 00005588 5D                      	pop	bp				;;AN000;; Save return address
 35413                                  
 35414 00005589 C706[1687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35415                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35416                                  
 35417 0000558F E87700                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35418                                  
 35419                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35420 00005592 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35421                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35422 00005596 741A                    	jz	short $MIF365			;;AN000;; No
 35423                                  						;;AN000;; Yes
 35424 00005598 803E[2987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35425                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35426 0000559D 7513                    	jne	short $MIF366			;;AN000;; No
 35427                                  						;;AN000;; Yes
 35428 0000559F 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35429                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35430 000055A2 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35431 000055A4 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35432 000055A6 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35433 000055A8 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35434                                  $MLL367:
 35435 000055AA B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35436                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35437                                  	;inc	cx				;;AN000;;
 35438                                  	;jmp	short $MEN367			;;AN000;;
 35439                                  	; 12/04/2023
 35440 000055AC EB02                    	jmp	short $MEN367 ; *
 35441                                  $MIF367:
 35442 000055AE B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35443                                  $MEN367:	; * ; 12/04/2023
 35444 000055B0 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35445 000055B1 41                      	inc	cx				;;AN000;;
 35446                                  ;$MEN367:
 35447                                  $MIF366:
 35448                                  $MIF365:					;;AN000;;
 35449 000055B2 31C0                    	xor	ax,ax				;;AN000;;
 35450                                  	;xor	dx,dx				;;AN000;;
 35451                                  	; 13/08/2024
 35452 000055B4 99                      	cwd	; PCDOS 7.1 COMMAND.COM
 35453                                  	
 35454                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35455 000055B5 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35456                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35457 000055B9 740B                    	jz	short $MIF372			;;AN000;;
 35458                                  
 35459 000055BB 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35460                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35461 000055BE E8AAFF                  	call	$M_CONVERTTIME			;;AN000;;
 35462                                  
 35463 000055C1 FF36[2187]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35464                                  	;push	word [$M_RT+85]			;;AN000;;
 35465 000055C5 41                      	inc	cx				;;AN000;;
 35466                                  $MIF372:
 35467                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35468 000055C6 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35469                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35470 000055CA 7506                    	jnz	short $MLL374			;;AN000;; No
 35471                                  
 35472                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35473 000055CC F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35474                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35475 000055D0 740B                    	jz	short $MIF374			;;AN000;; No
 35476                                  $MLL374:
 35477 000055D2 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35478                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35479 000055D5 E893FF                  	call	$M_CONVERTTIME			;;AN000;;
 35480                                  
 35481 000055D8 FF36[2587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35482                                  	;push	word [$M_RT+89]			;;AN000;;
 35483 000055DC 41                      	inc	cx				;;AN000;;
 35484                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35485 000055DD 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35486                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35487 000055E0 E888FF                  	call	$M_CONVERTTIME			;;AN000;;
 35488                                  
 35489 000055E3 FF36[2587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35490                                  	;push	word [$M_RT+89]			;;AN000;;
 35491 000055E7 41                      	inc	cx				;;AN000;;
 35492                                  
 35493 000055E8 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35494                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35495                                  
 35496                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35497 000055EB F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35498                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35499 000055EF 7413                    	jz	short $MIF376			;;AN000;; No
 35500                                  
 35501 000055F1 803E[2987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35502                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35503 000055F6 750C                    	jne	short $MIF377			;;AN000;; No
 35504                                  
 35505 000055F8 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35506 000055FA 7C02                    	jnge	short $MIF378 ; jl
 35507 000055FC 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35508                                  $MIF378:
 35509                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35510                                  	;jne	short $MIF380			;;AN000;; No
 35511                                  	; 12/04/2023
 35512 000055FE 20C0                    	and	al,al
 35513 00005600 7502                    	jnz	short $MIF380	
 35514 00005602 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35515                                  $MIF380:
 35516                                  $MIF377:
 35517                                  $MIF376:
 35518 00005604 E8EFFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35519 00005607 55                      	push	bp				;;AN000;; Restore return address
 35520 00005608 C3                      	retn					;;AN000;; Return
 35521                                  
 35522                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35523                                  ;;
 35524                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35525                                  
 35526                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35527                                  $M_GET_TIME:
 35528                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35529                                  	;mov	al,0 				;;AN000;; Get current country info
 35530                                  	; 12/04/2023
 35531 00005609 B80038                  	mov	ax,3800h
 35532                                  	;
 35533 0000560C 8D16[1887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35534                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35535 00005610 CD21                    	int	21h				;;AN000;;
 35536 00005612 7310                    	jnc	short $MIF384
 35537                                  
 35538 00005614 C706[2987]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35539                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35540 0000561A C606[2587]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35541                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35542 0000561F C606[2187]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35543                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35544                                  $MIF384:
 35545 00005624 C3                      	retn					;;AN000;;
 35546                                  
 35547                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35548                                  ;;
 35549                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35550                                  
 35551                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35552                                  
 35553                                  ; 12/04/2023 
 35554                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35555                                  %if 0
 35556                                  $M_CONVERTTIME:
 35557                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35558                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35559                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35560                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35561                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35562                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35563                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35564                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35565                                  	jne	short $MIF386			;;AN000;; No
 35566                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35567                                  	push	ax				;;AN000;; Save it
 35568                                  	inc	cx				;;AN000;; Count itount it
 35569                                  $MIF386:
 35570                                  	inc	cx				;;AN000;; Restore CX
 35571                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35572                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35573                                  	retn
 35574                                  %endif
 35575                                  
 35576                                  ; ----------------------------
 35577                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35578                                  ; ----------------------------
 35579                                  ; include msgdcl.inc
 35580                                  ; ----------------------------
 35581                                  
 35582                                  ;============================================================================
 35583                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 35584                                  ;============================================================================
 35585                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35586                                  
 35587                                  ; This is a new module added to support loading programs into UMBs provided
 35588                                  ; by DOS 5.0. 
 35589                                  ; ---------------------------------------------------------------------------
 35590                                  ; Usage:
 35591                                  ;
 35592                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 35593                                  ;
 35594                                  ; <filespec> has to be a filename that is not wildcarded.
 35595                                  
 35596                                  ; ---------------------------------------------------------------------------
 35597                                  ;
 35598                                  ;	Revision History
 35599                                  ;	================
 35600                                  ;
 35601                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35602                                  ;				loading and high and also remember
 35603                                  ;				current UMB state.
 35604                                  ;
 35605                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35606                                  ;				to loadhigh batch files and invalid
 35607                                  ;				filename on Loadhigh command line.
 35608                                  ;
 35609                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35610                                  ;				after the program name also as part
 35611                                  ;				of the command line being passed to
 35612                                  ;				the program to be invoked.
 35613                                  ;
 35614                                  ; ---------------------------------------------------------------------------
 35615                                  
 35616                                  ; ---------------------------------------------------------------------------
 35617                                  ;
 35618                                  ;	include highload.inc		; Grab code for ParseVar and such
 35619                                  
 35620                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35621                                  
 35622                                  ;
 35623                                  ; ---------------------------------------------------------------------------
 35624                                  
 35625                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35626                                  ;
 35627                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35628                                  ;		CS = DS = SS = TRANGROUP
 35629                                  ;
 35630                                  ;	EXIT	None
 35631                                  ;
 35632                                  ;	USED	ax, bx, cx, dx, si, di, es
 35633                                  ;
 35634                                  ;	ERROR EXITS
 35635                                  ;		Message pointers are setup at the error locations and then
 35636                                  ;	we jump back to CERROR which is the transient error recycle point.
 35637                                  ;	Apart from parse errors, the other errors handled are too many
 35638                                  ;	switches anf invalid filenames.
 35639                                  ;
 35640                                  ;	EFFECTS
 35641                                  ;		The allocation strategy and the state of the arena chain are
 35642                                  ;	put in the requested state according to the given options. If a 
 35643                                  ;	filename is also given, it is executed as well.
 35644                                  ; ---------------------------------------------------------------------------
 35645                                  
 35646                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35647                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35648                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35649                                  LoadHigh:
 35650 00005625 1E                      	push	ds
 35651 00005626 07                      	pop	es
 35652                                  
 35653 00005627 E86700                  	call	SkipLhDelims
 35654                                  
 35655                                  ;Get command tail to be passed to the program. This includes any whitespace
 35656                                  ;chars between the program name and its parameters as well.
 35657                                  ;On return, ds:si points at the start of the command tail.
 35658                                  
 35659 0000562A 56                      	push	si
 35660 0000562B E81400                  	call	ParseLhCmd
 35661 0000562E 5E                      	pop	si
 35662 0000562F 720E                    	jc	short LhErr
 35663                                  	
 35664 00005631 E87500                  	call	SetupCmdLine		;setup pgm's command line
 35665                                  
 35666 00005634 E8C800                  	call	SetupPath		;setup path for file
 35667 00005637 7206                    	jc	short LhErr		;file not found
 35668                                  
 35669                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35670                                  ;be reset after return from the Exec
 35671                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35672                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35673                                  
 35674 00005639 E8A600                  	call	HideUMBs		;prepare upper-memory for load
 35675                                  
 35676 0000563C E9BED2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35677                                  
 35678                                  LhErr:
 35679                                  ;The error message has been setup at this stage
 35680                                  
 35681 0000563F E90ED3                  	jmp	cerror			;print error message and recycle 
 35682                                  
 35683                                  ; ---------------------------------------------------------------------------
 35684                                  					
 35685                                  ;*** 	ParseLhCmd - parses any command-line options
 35686                                  ;
 35687                                  ;	ENTRY	None
 35688                                  ;
 35689                                  ;	EXIT	Carry clear -- command line parsed successfully
 35690                                  ;		Carry set -- appropriate error message setup
 35691                                  ;
 35692                                  ;	USED	ax, si
 35693                                  ;
 35694                                  ;	EFFECTS
 35695                                  ;		Options set up (see highvar.inc)
 35696                                  ;		Filename to be executed setup
 35697                                  ;
 35698                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35699                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35700                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35701                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35702                                  ;	prepare the command-line for that program.
 35703                                  ; ---------------------------------------------------------------------------
 35704                                  
 35705                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35706                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35707                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35708                                  	; 11/06/2023
 35709                                  ParseLhCmd:
 35710                                  	;mov	si,81h
 35711 00005642 BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35712                                  
 35713 00005645 C706[BA8A]0000          	mov	word [COMSW],0
 35714 0000564B BF[B085]                	mov	di,Parse_LoadHi
 35715 0000564E 31C9                    	xor	cx,cx
 35716 00005650 E864CB                  	call	Parse_With_Msg
 35717                                  
 35718                                  	; 11/06/2023
 35719                                  	;cmp	ax,0FFFFh ; -1
 35720                                  	;jz	short PLhCmd2
 35721                                  	;cmp	ax,0
 35722                                  	;jnz	short PLhCmd1
 35723                                  	; 11/06/2023
 35724 00005653 40                      	inc	ax ; cmp ax,-1
 35725 00005654 7408                    	jz	short PLhCmd2 ; 0FFFFh -> 0
 35726 00005656 48                      	dec	ax ; cmp ax,0
 35727 00005657 7504                    	jnz	short PLhCmd1 ; 1 -> 0
 35728                                  	; ax = 0
 35729                                  
 35730 00005659 89D3                    	mov	bx,dx
 35731                                  	; 14/04/2023
 35732                                  	;call	LhCopyFilename
 35733                                  	;; 13/04/2023
 35734                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35735                                  	;;jmp	short PLhCmd2
 35736                                  	;retn
 35737                                  	; 14/04/2023
 35738 0000565B EB02                    	jmp	short LhCopyFilename
 35739                                  PLhCmd1:
 35740 0000565D F9                      	stc
 35741                                  PLhCmd2:
 35742 0000565E C3                      	retn
 35743                                  
 35744                                  ; ---------------------------------------------------------------------------
 35745                                  
 35746                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35747                                  
 35748                                  ; ---------------------------------------------------------------------------
 35749                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35750                                  ; ---------------------------------------------------------------------------
 35751                                  
 35752                                  	; 13/04/2023
 35753                                  	; MSDOS 5.0 COMMAND.COM only !
 35754                                  	; (Procedure names are not from original Microsoft source code!)
 35755                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35756                                  ;set_strategy:
 35757                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35758                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35759                                  	;		; AL = function code: get allocation strategy
 35760                                  	;mov	bx,ax
 35761                                  	;or	bx,80h
 35762                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35763                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35764                                  	;		; AL = function code: set allocation strategy
 35765                                  	;retn
 35766                                  
 35767                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35768                                  ;set_umblink:
 35769                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35770                                  	;mov	bx,1
 35771                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35772                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35773                                  	;retn
 35774                                  
 35775                                  ; ---------------------------------------------------------------------------
 35776                                  
 35777                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35778                                  ;
 35779                                  ;	ENTRY	ds:si points at primary argument (filename)
 35780                                  ;
 35781                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35782                                  ;				already contain an appropriate error number.
 35783                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35784                                  ;				points to first character (most likely space)
 35785                                  ;				after filename.
 35786                                  ;
 35787                                  ;	USED	ax, si
 35788                                  ;
 35789                                  ;	EFFECTS
 35790                                  ;		ExecPath contains the filename
 35791                                  ;
 35792                                  ; If there are any wildcards in the filename, then we have an error
 35793                                  ; ---------------------------------------------------------------------------
 35794                                  
 35795                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35796                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35797                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35798                                  LhCopyFilename:
 35799 0000565F 1E                      	push	ds
 35800 00005660 56                      	push	si
 35801 00005661 57                      	push	di
 35802 00005662 C57704                  	lds	si,[bx+4]
 35803 00005665 BF[CD89]                	mov	di,EXECPATH
 35804                                  lhcpfn1:
 35805 00005668 AC                      	lodsb
 35806 00005669 3C2A                    	cmp	al,2Ah ; '*'
 35807 0000566B 740D                    	jz	short lhfilerr
 35808 0000566D 3C3F                    	cmp	al,3Fh ; '?'
 35809 0000566F 7409                    	jz	short lhfilerr
 35810 00005671 AA                      	stosb
 35811 00005672 08C0                    	or	al,al
 35812 00005674 75F2                    	jnz	short lhcpfn1
 35813                                  	; 14/04/2023
 35814                                  	; cf = 0
 35815                                  	;clc
 35816                                  lhfilerr2:
 35817 00005676 5F                      	pop	di
 35818 00005677 5E                      	pop	si
 35819 00005678 1F                      	pop	ds
 35820 00005679 C3                      	retn
 35821                                  lhfilerr:
 35822 0000567A BA[6681]                	mov	dx,LhInvFil_Ptr
 35823 0000567D F9                      	stc
 35824 0000567E EBF6                    	jmp	short lhfilerr2
 35825                                  
 35826                                  ; ---------------------------------------------------------------------------
 35827                                  	
 35828                                  	; 14/04/2023
 35829                                  	; 13/04/2023
 35830                                  	; MSDOS 5.0 COMMAND.COM only !
 35831                                  	; (Procedure name is not from original Microsoft source code!)
 35832                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35833                                  set_strategy:
 35834 00005680 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35835 00005683 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35836                                  			; AL = function code: get allocation strategy
 35837 00005685 89C3                    	mov	bx,ax
 35838 00005687 81CB8000                	or	bx,80h
 35839 0000568B B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35840 0000568E CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35841                                  			; AL = function code: set allocation strategy
 35842 00005690 C3                      	retn
 35843                                  
 35844                                  ; ---------------------------------------------------------------------------
 35845                                  
 35846                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35847                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35848                                  	; MSDOS 5.0 COMMAND.COM only !
 35849                                  	; (Procedure name is not from original Microsoft source code!)
 35850                                  SkipLhDelims:
 35851 00005691 BE8100                  	mov	si,81h
 35852 00005694 E845CF                  	call	scanoff
 35853                                  stfn1:
 35854 00005697 AC                      	lodsb
 35855 00005698 E849CF                  	call	DELIM
 35856 0000569B 740A                    	jz	short stfn2
 35857 0000569D 3C0D                    	cmp	al,0Dh
 35858 0000569F 7406                    	jz	short stfn2
 35859 000056A1 3A06[A98A]              	cmp	al,[SWITCHAR]
 35860 000056A5 75F0                    	jnz	short stfn1
 35861                                  stfn2:
 35862 000056A7 4E                      	dec	si
 35863 000056A8 C3                      	retn
 35864                                  
 35865                                  ; ---------------------------------------------------------------------------
 35866                                  
 35867                                  ;***	SetupCmdLine -- prepare command line for the program
 35868                                  ;
 35869                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35870                                  ;
 35871                                  ;	EXIT	None
 35872                                  ;
 35873                                  ;	USED
 35874                                  ;
 35875                                  ;	EFFECTS		
 35876                                  ;		The rest of the command line following the pgm name is 
 35877                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35878                                  ;	and a new command line length is put in
 35879                                  ; ---------------------------------------------------------------------------
 35880                                  
 35881                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35882                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35883                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35884                                  SetupCmdLine:
 35885                                  	;mov	di,81h
 35886 000056A9 BF8100                  	mov	di,iCmdLine
 35887 000056AC 30C9                    	xor	cl,cl
 35888 000056AE FEC9                    	dec	cl			;just CR means count = 0
 35889                                  SetCmdL1:
 35890 000056B0 AC                      	lodsb
 35891 000056B1 AA                      	stosb
 35892 000056B2 FEC1                    	inc	cl			;update count
 35893                                  	; 14/04/2023
 35894                                  	; * ; MSDOS 6.0 only !
 35895                                  	;or	al,al	; *
 35896                                  	;jz	short SetCmdL2 ; *
 35897 000056B4 3C0D                    	cmp	al,0Dh			;carriage return?
 35898 000056B6 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35899                                  SetCmdL2:
 35900 000056B8 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35901 000056BD C3                      	retn
 35902                                  
 35903                                  ; ---------------------------------------------------------------------------
 35904                                  
 35905                                  ;***	LhSetupErrMsg -- Sets up error messages
 35906                                  ;
 35907                                  ;	ENTRY	ax = error message number
 35908                                  ;
 35909                                  ;	EXIT	None
 35910                                  ;
 35911                                  ;	USED	dx
 35912                                  ;
 35913                                  ;	EFFECTS
 35914                                  ;		Everything setup to display error message
 35915                                  ; ---------------------------------------------------------------------------
 35916                                  	
 35917                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35918                                  LhSetupErrMsg:
 35919 000056BE C606[FA7E]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35920 000056C3 BA[FC7E]                	mov	dx,extend_buf_ptr
 35921 000056C6 A3[FC7E]                	mov	[extend_buf_ptr],ax
 35922 000056C9 C3                      	retn
 35923                                  
 35924                                  ; ---------------------------------------------------------------------------
 35925                                  
 35926                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35927                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35928                                  	; MSDOS 5.0 COMMAND.COM only !
 35929                                  	; (Procedure name is not from original Microsoft source code!)
 35930                                  check_umblink:
 35931 000056CA B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35932 000056CD CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35933                                  			 ; AL = function code: get allocation strategy
 35934 000056CF 88C3                    	mov	bl,al
 35935 000056D1 B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35936 000056D4 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35937                                  			; AL = function code: (DOS 5beta) get UMB link state
 35938 000056D6 88C7                    	mov	bh,al
 35939 000056D8 93                      	xchg	ax,bx
 35940 000056D9 D0C0                    	rol	al,1
 35941 000056DB 2401                    	and	al,1
 35942 000056DD D0E4                    	shl	ah,1
 35943 000056DF 08E0                    	or	al,ah
 35944 000056E1 C3                      	retn
 35945                                  
 35946                                  ; ---------------------------------------------------------------------------
 35947                                  
 35948                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35949                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35950                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35951                                  HideUMBs:
 35952 000056E2 1E                      	push	ds
 35953 000056E3 E8E4FF                  	call	check_umblink
 35954 000056E6 8E1E[A58A]              	mov	ds,[RESSEG]
 35955 000056EA A2[2004]                	mov	[fInHigh],al
 35956 000056ED 800E[2004]80            	or	byte [fInHigh],80h
 35957 000056F2 1F                      	pop	ds
 35958 000056F3 E88AFF                  	call	set_strategy
 35959                                  	;call	set_umblink
 35960                                  	;retn
 35961                                  	; 14/04/023
 35962                                  	;jmp	short set_umblink
 35963                                  
 35964                                  ; ---------------------------------------------------------------------------
 35965                                  
 35966                                  	; 14/04/2023
 35967                                  	; 13/04/2023
 35968                                  	; MSDOS 5.0 COMMAND.COM only !
 35969                                  	; (Procedure name is not from original Microsoft source code!)
 35970                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35971                                  set_umblink:
 35972 000056F6 B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35973 000056F9 BB0100                  	mov	bx,1
 35974 000056FC CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35975                                  			; AL = function code: (DOS 5beta) set UMB link state
 35976 000056FE C3                      	retn
 35977                                  
 35978                                  ; ---------------------------------------------------------------------------
 35979                                  
 35980                                  ;***	SetupPath -- Do path search for the file to be executed
 35981                                  ;
 35982                                  ;	ENTRY	None
 35983                                  ;
 35984                                  ;	EXIT	Carry set if file not found or not executable file
 35985                                  ;
 35986                                  ;	EFFECTS
 35987                                  ;		ExecPath contains the full path of the file to be executed
 35988                                  ; ---------------------------------------------------------------------------
 35989                                  
 35990                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35991                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35992                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35993                                  SetupPath:
 35994                                  
 35995                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35996                                  ;because the path search routine that we are about to invoke expects the
 35997                                  ;filename to search for to be argv[0].
 35998                                  ;
 35999                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 36000                                  ;over it by doing the whole move again (smaller, of course, this time).
 36001                                  
 36002                                  	;mov	ax,arg.argvcnt		;total number of arguments
 36003                                  	; 14/04/2023
 36004                                  	;mov	ax,[ARG_ARGVCNT]
 36005 000056FF A1[7090]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 36006                                  
 36007 00005702 48                      	dec	ax			;less one - skip "LoadHigh"
 36008                                  	;mov	bx,SIZE Argv_ele
 36009 00005703 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 36010                                  	;mov	bx,11
 36011 00005706 F7E3                    	mul	bx			;dx:ax = size of argument lists
 36012                                  
 36013                                  	; 14/04/2023
 36014 00005708 89C1                    	mov	cx,ax			;size to move
 36015                                  
 36016                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 36017                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 36018 0000570A BF[B08D]                	mov	di,ARG	
 36019 0000570D 89FE                    	mov	si,di			;
 36020                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 36021 0000570F 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 36022                                  	
 36023                                  	; 14/04/2023
 36024                                  	;mov	cx,ax
 36025                                  
 36026 00005712 FC                      	cld
 36027 00005713 F3A4                    	rep	movsb			;Move the argument list
 36028                                  	
 36029                                  	;dec	arg.argvcnt		;Fake one less argument, and
 36030                                  	;dec	word [ARG_ARGVCNT]
 36031 00005715 FF0E[7090]              	dec	word [ARG+ARG_UNIT.argvcnt]
 36032                                  	
 36033                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 36034                                  
 36035 00005719 E844DA                  	call	path_search		;look in the path
 36036                                  
 36037                                  ;ax = 0, no file found
 36038                                  ;ax < 4, batch file found -- cant be executed
 36039                                  ;ax = 4,8 => .com or .exe file found
 36040                                  
 36041 0000571C 09C0                    	or	ax,ax			;any file found?
 36042 0000571E 740B                    	jz	short no_exec_file	;no, error
 36043                                  
 36044 00005720 83F804                  	cmp	ax,4			;executable file?
 36045                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 36046                                  	;clc
 36047                                  	;retn
 36048                                  	; 14/04/2023
 36049 00005723 7201                    	jb	short no_exec_bat
 36050 00005725 C3                      	retn 
 36051                                  
 36052                                  no_exec_bat:
 36053 00005726 BA[6381]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 36054 00005729 EB06                    	jmp	short lhsp_errret	;return error; M016
 36055                                  
 36056                                  no_exec_file:
 36057 0000572B B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 36058 0000572E E88DFF                  	call	LhSetupErrMsg		;setup error message
 36059                                  lhsp_errret:				; M016
 36060 00005731 F9                      	stc
 36061 00005732 C3                      	retn
 36062                                  
 36063                                  ;============================================================================
 36064                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 36065                                  ;============================================================================
 36066                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36067                                  
 36068                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 36069                                  
 36070                                  ; ---------------------------------------------------------------------------
 36071                                  ; Class 3 message table/structure
 36072                                  ; ---------------------------------------------------------------------------
 36073                                  
 36074                                  $M_CLASS_3_STRUC:
 36075 00005733 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 36076 00005734 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 36077 00005736 A2                      	db 162			; Total number of messages
 36078                                  $M_ID_3_1:
 36079                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 36080 00005737 FC03                    	dw 1020			; Message Number = 1020
 36081 00005739 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 36082                                  $M_ID_3_2:
 36083 0000573B F703                    	dw 1015			; Message Number = 1015
 36084 0000573D 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 36085                                  $M_ID_3_3:	; 26/04/2023
 36086 0000573F EC03B402                	dw 1004,MSG_1004-$ ; 692
 36087 00005743 0204CA02                	dw 1026,MSG_1026-$ ; 714
 36088 00005747 0704DA02                	dw 1031,MSG_1031-$ ; 730
 36089 0000574B 0B04E502                	dw 1035,MSG_1035-$ ; 741
 36090 0000574F 2604F002                	dw 1062,MSG_1062-$ ; 752
 36091 00005753 0404FB02                	dw 1028,MSG_1028-$ ; 763
 36092 00005757 15041903                	dw 1045,MSG_1045-$ ; 793
 36093 0000575B 11043203                	dw 1041,MSG_1041-$ ; 818
 36094 0000575F 12045003                	dw 1042,MSG_1042-$ ; 848
 36095                                  $M_ID_3_12:
 36096 00005763 13046703                	dw 1043,MSG_1043-$ ; 871
 36097 00005767 EA038303                	dw 1002,MSG_1002-$ ; 899
 36098 0000576B EB03A703                	dw 1003,MSG_1003-$ ; 935
 36099 0000576F EF03BF03                	dw 1007,MSG_1007-$ ; 959
 36100 00005773 F003D603                	dw 1008,MSG_1008-$ ; 982
 36101 00005777 F103E803                	dw 1009,MSG_1009-$ ; 1000
 36102 0000577B F203F903                	dw 1010,MSG_1010-$ ; 1017
 36103 0000577F F3031504                	dw 1011,MSG_1011-$ ; 1045
 36104 00005783 F6032C04                	dw 1014,MSG_1014-$ ; 1068
 36105 00005787 F8033904                	dw 1016,MSG_1016-$ ; 1081
 36106 0000578B F9035F04                	dw 1017,MSG_1017-$ ; 1119
 36107 0000578F FA038004                	dw 1018,MSG_1018-$ ; 1152
 36108                                  $M_ID_3_24:
 36109 00005793 FB039004                	dw 1019,MSG_1019-$ ; 1168
 36110 00005797 FD039804                	dw 1021,MSG_1021-$ ; 1176
 36111 0000579B FE03B204                	dw 1022,MSG_1022-$ ; 1202
 36112 0000579F FF03D504                	dw 1023,MSG_1023-$ ; 1237
 36113 000057A3 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 36114 000057A7 01041005                	dw 1025,MSG_1025-$ ; 1296
 36115 000057AB 03042405                	dw 1027,MSG_1027-$ ; 1316
 36116 000057AF 05044105                	dw 1029,MSG_1029-$ ; 1345
 36117 000057B3 06044F05                	dw 1030,MSG_1030-$ ; 1359
 36118 000057B7 08045A05                	dw 1032,MSG_1032-$ ; 1370
 36119 000057BB 09046E05                	dw 1033,MSG_1033-$ ; 1390
 36120 000057BF 0A048005                	dw 1034,MSG_1034-$ ; 1408
 36121 000057C3 0C049205                	dw 1036,MSG_1036-$ ; 1426
 36122 000057C7 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 36123 000057CB 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 36124 000057CF 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 36125                                  $M_ID_3_40:
 36126 000057D3 1004F805                	dw 1040,MSG_1040-$ ; 1528
 36127 000057D7 14040906                	dw 1044,MSG_1044-$ ; 1545
 36128 000057DB 16041906                	dw 1046,MSG_1046-$ ; 1561
 36129 000057DF 17044C06                	dw 1047,MSG_1047-$ ; 1612
 36130 000057E3 18046106                	dw 1048,MSG_1048-$ ; 1633
 36131 000057E7 19046F06                	dw 1049,MSG_1049-$ ; 1647
 36132 000057EB 1A047506                	dw 1050,MSG_1050-$ ; 1653
 36133 000057EF 1B049006                	dw 1051,MSG_1051-$ ; 1680
 36134 000057F3 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 36135 000057F7 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 36136 000057FB 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 36137                                  $M_ID_3_51:
 36138 000057FF 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 36139 00005803 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 36140 00005807 21040A07                	dw 1057,MSG_1057-$ ; 1802
 36141 0000580B 23041307                	dw 1059,MSG_1059-$ ; 1811
 36142 0000580F 24041407                	dw 1060,MSG_1060-$ ; 1812
 36143 00005813 25041407                	dw 1061,MSG_1061-$ ; 1812
 36144 00005817 27042A07                	dw 1063,MSG_1063-$ ; 1834
 36145 0000581B 28042907                	dw 1064,MSG_1064-$ ; 1833
 36146 0000581F 29042807                	dw 1065,MSG_1065-$ ; 1832
 36147 00005823 2A042707                	dw 1066,MSG_1066-$ ; 1831
 36148 00005827 2B042607                	dw 1067,MSG_1067-$ ; 1830
 36149 0000582B 2C042407                	dw 1068,MSG_1068-$ ; 1828
 36150 0000582F 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 36151 00005833 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 36152 00005837 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 36153 0000583B 30042907                	dw 1072,MSG_1072-$ ; 1833
 36154                                  $M_ID_3_67:
 36155 0000583F 31042E07                	dw 1073,MSG_1073-$ ; 1838
 36156 00005843 32043307                	dw 1074,MSG_1074-$ ; 1843
 36157 00005847 33043807                	dw 1075,MSG_1075-$ ; 1848
 36158 0000584B 34043A07                	dw 1076,MSG_1076-$ ; 1850
 36159 0000584F 35043907                	dw 1077,MSG_1077-$ ; 1849
 36160 00005853 36043D07                	dw 1078,MSG_1078-$ ; 1853
 36161 00005857 37045407                	dw 1079,MSG_1079-$ ; 1876
 36162 0000585B 38045B07                	dw 1080,MSG_1080-$ ; 1883
 36163 0000585F 39046D07                	dw 1081,MSG_1081-$ ; 1901
 36164 00005863 3C049407                	dw 1084,MSG_1084-$ ; 1940
 36165 00005867 4204A007                	dw 1090,MSG_1090-$ ; 1952
 36166 0000586B 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 36167 0000586F 4404B407                	dw 1092,MSG_1092-$ ; 1972
 36168 00005873 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 36169 00005877 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 36170 0000587B 4704E807                	dw 1095,MSG_1095-$ ; 2024
 36171 0000587F 48040108                	dw 1096,MSG_1096-$ ; 2049
 36172                                  $M_ID_3_84:
 36173 00005883 B0042E08                	dw 1200,MSG_1200-$ ; 2094
 36174 00005887 14052B08                	dw 1300,MSG_1300-$ ; 2091
 36175 0000588B 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 36176 0000588F 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 36177 00005893 3C055709                	dw 1340,MSG_1340-$ ; 2391
 36178 00005897 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 36179 0000589B 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 36180 0000589F 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 36181 000058A3 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 36182 000058A7 7905420B                	dw 1401,MSG_1401-$ ; 2882
 36183 000058AB 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 36184 000058AF 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 36185 000058B3 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 36186 000058B7 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 36187 000058BB A005630D                	dw 1440,MSG_1440-$ ; 3427
 36188 000058BF A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 36189                                  $M_ID_3_100:
 36190 000058C3 B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 36191 000058C7 B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 36192 000058CB B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 36193 000058CF C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 36194 000058D3 C905D90F                	dw 1481,MSG_1481-$ ; 4057
 36195 000058D7 CA053310                	dw 1482,MSG_1482-$ ; 4147
 36196 000058DB CB059110                	dw 1483,MSG_1483-$ ; 4241
 36197 000058DF CC050811                	dw 1484,MSG_1484-$ ; 4360
 36198 000058E3 CD05C411                	dw 1485,MSG_1485-$ ; 4548
 36199 000058E7 CE055C12                	dw 1486,MSG_1486-$ ; 4700
 36200 000058EB CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 36201 000058EF D0055213                	dw 1488,MSG_1488-$ ; 4946
 36202                                  $M_ID_3_112:
 36203 000058F3 DC05E113                	dw 1500,MSG_1500-$ ; 5089
 36204 000058F7 F0051C14                	dw 1520,MSG_1520-$ ; 5148
 36205 000058FB 04065614                	dw 1540,MSG_1540-$ ; 5206
 36206 000058FF 0506B014                	dw 1541,MSG_1541-$ ; 5296
 36207 00005903 06061815                	dw 1542,MSG_1542-$ ; 5400
 36208 00005907 18065015                	dw 1560,MSG_1560-$ ; 5456
 36209 0000590B 19068415                	dw 1561,MSG_1561-$ ; 5508
 36210 0000590F 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 36211 00005913 1B062916                	dw 1563,MSG_1563-$ ; 5673
 36212 00005917 1C065016                	dw 1564,MSG_1564-$ ; 5712
 36213 0000591B 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 36214 0000591F 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 36215 00005923 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 36216 00005927 20065A17                	dw 1568,MSG_1568-$ ; 5978
 36217 0000592B 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 36218                                  $M_ID_3_127:
 36219 0000592F 4006E717                	dw 1600,MSG_1600-$ ; 6119
 36220 00005933 41060018                	dw 1601,MSG_1601-$ ; 6144
 36221 00005937 42065018                	dw 1602,MSG_1602-$ ; 6224
 36222 0000593B 54069A18                	dw 1620,MSG_1620-$ ; 6298
 36223 0000593F 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 36224 00005943 56066C19                	dw 1622,MSG_1622-$ ; 6508
 36225 00005947 6806B419                	dw 1640,MSG_1640-$ ; 6580
 36226 0000594B 6906E519                	dw 1641,MSG_1641-$ ; 6629
 36227 0000594F 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 36228 00005953 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 36229 00005957 A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 36230 0000595B B806781B                	dw 1720,MSG_1720-$ ; 7032
 36231 0000595F CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 36232 00005963 CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 36233 00005967 E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 36234 0000596B F406D71C                	dw 1780,MSG_1780-$ ; 7383
 36235                                  $M_ID_3_143:
 36236 0000596F 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 36237 00005973 0907891D                	dw 1801,MSG_1801-$ ; 7561
 36238 00005977 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 36239 0000597B 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 36240 0000597F 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 36241 00005983 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 36242 00005987 4507461F                	dw 1861,MSG_1861-$ ; 8006
 36243 0000598B 4607891F                	dw 1862,MSG_1862-$ ; 8073
 36244 0000598F 47070320                	dw 1863,MSG_1863-$ ; 8195
 36245 00005993 4807A220                	dw 1864,MSG_1864-$ ; 8354
 36246 00005997 49070521                	dw 1865,MSG_1865-$ ; 8453
 36247 0000599B 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 36248 0000599F 5807D021                	dw 1880,MSG_1880-$ ; 8656
 36249 000059A3 59074422                	dw 1881,MSG_1881-$ ; 8772
 36250 000059A7 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 36251 000059AB 5B071123                	dw 1883,MSG_1883-$ ; 8977
 36252 000059AF 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 36253 000059B3 8007C423                	dw 1920,MSG_1920-$ ; 9156
 36254 000059B7 8107F023                	dw 1921,MSG_1921-$ ; 9200
 36255                                  $M_ID_3_162:
 36256 000059BB 8207                    	dw 1922			; Message Number = 1922
 36257 000059BD 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 36258                                  
 36259                                  ; ---------------------------------------------------------------------------
 36260                                  ; Class 3 messages
 36261                                  ; ---------------------------------------------------------------------------
 36262                                  	
 36263                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36264                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 36265                                  
 36266                                  MSG_1020:	; COMMON4
 36267 000059BF 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 36268 000059C0 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 36268 000059C9 667265650D0A       
 36269                                  MSG_1015:	; COMMON18
 36270 000059CF 23                      	db 35
 36271 000059D0 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 36271 000059D9 6F7420626520636F70-
 36271 000059E2 696564206F6E746F20-
 36271 000059EB 697473656C660D0A   
 36272                                  MSG_1004:	; COMMON20
 36273 000059F3 19                      	db 25
 36274 000059F4 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 36274 000059FD 656E74206469736B20-
 36274 00005A06 73706163650D0A     
 36275                                  MSG_1026:	; COMMON22
 36276 00005A0D 13                      	db 19
 36277 00005A0E 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 36277 00005A17 6F646520706167650D-
 36277 00005A20 0A                 
 36278                                  MSG_1031:	; COMMON23
 36279 00005A21 0E                      	db 14
 36280 00005A22 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 36280 00005A2B 6174650D0A         
 36281                                  MSG_1035:	; COMMON24
 36282 00005A30 0E                      	db 14
 36283 00005A31 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 36283 00005A3A 696D650D0A         
 36284                                  MSG_1062:	; COMMON25
 36285 00005A3F 0E                      	db 14
 36286 00005A40 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 36286 00005A49 6174680D0A         
 36287                                  MSG_1028:	; COMMON28
 36288 00005A4E 21                      	db 33
 36289 00005A4F 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 36289 00005A58 206B657920746F2063-
 36289 00005A61 6F6E74696E7565202E-
 36289 00005A6A 202E202E0D0A       
 36290                                  MSG_1045:	; COMMON32
 36291 00005A70 1C                      	db 28
 36292 00005A71 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 36292 00005A7A 206372656174652064-
 36292 00005A83 69726563746F72790D-
 36292 00005A8C 0A                 
 36293                                  MSG_1041:	; COMMON33
 36294 00005A8D 21                      	db 33
 36295 00005A8E 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 36295 00005A97 206472697665202531-
 36295 00005AA0 20686173206E6F206C-
 36295 00005AA9 6162656C0D0A       
 36296                                  MSG_1042:	; COMMON34
 36297 00005AAF 1A                      	db 26
 36298 00005AB0 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 36298 00005AB9 206472697665202531-
 36298 00005AC2 2069732025320D0A   
 36299                                  MSG_1043:	; COMMON36
 36300 00005ACA 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 36301 00005ACB 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 36301 00005AD4 7269616C204E756D62-
 36301 00005ADD 65722069732025312D-
 36301 00005AE6 25320D0A           
 36302                                  MSG_1002:
 36303 00005AEA 27                              db 39
 36304 00005AEB 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 36304 00005AF4 2066696C65206E616D-
 36304 00005AFD 65206F722066696C65-
 36304 00005B06 206E6F7420666F756E-
 36304 00005B0F 640D0A             
 36305                                  MSG_1003:
 36306 00005B12 1B                      	db 27
 36307 00005B13 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 36307 00005B1C 617468206F72206669-
 36307 00005B25 6C65206E616D650D0A 
 36308                                  MSG_1007:
 36309 00005B2E 1A                      	db 26
 36310 00005B2F 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 36310 00005B38 7669726F6E6D656E74-
 36310 00005B41 2073706163650D0A   
 36311                                  MSG_1008:
 36312 00005B49 15                      	db 21
 36313 00005B4A 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 36313 00005B53 74696F6E206572726F-
 36313 00005B5C 720D0A             
 36314                                  MSG_1009:
 36315 00005B5F 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 36316 00005B60 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 36316 00005B69 65206D697373696E67-
 36316 00005B72 0D0A               
 36317                                  MSG_1010:
 36318 00005B74 1F                      	db 31
 36319 00005B75 0D0A                    	db 0Dh,0Ah
 36320 00005B77 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 36320 00005B80 736B20776974682062-
 36320 00005B89 617463682066696C65-
 36320 00005B92 0D0A               
 36321                                  MSG_1011:
 36322 00005B94 1A                      	db 26
 36323 00005B95 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 36323 00005B9E 6E64206F722066696C-
 36323 00005BA7 65206E616D650D0A   
 36324                                  MSG_1014:	; EXTEND5
 36325 00005BAF 10                      	db 16
 36326 00005BB0 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 36326 00005BB9 6E696564200D0A     
 36327                                  MSG_1016:
 36328 00005BC0 29                      	db 41
 36329 00005BC1 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 36329 00005BCA 662064657374696E61-
 36329 00005BD3 74696F6E206C6F7374-
 36329 00005BDC 206265666F72652063-
 36329 00005BE5 6F70790D0A         
 36330                                  MSG_1017:
 36331 00005BEA 24                      	db 36
 36332 00005BEB 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 36332 00005BF4 696C656E616D65206F-
 36332 00005BFD 722066696C65206E6F-
 36332 00005C06 7420666F756E640D0A 
 36333                                  MSG_1018:
 36334 00005C0F 13                      	db 19
 36335 00005C10 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 36335 00005C19 2920636F706965640D-
 36335 00005C22 0A                 
 36336                                  MSG_1019:
 36337 00005C23 0B                      	db 11
 36338 00005C24 25312066696C652873-     	db '%1 file(s) '
 36338 00005C2D 2920               
 36339                                  MSG_1021:	; EXTEND15
 36340 00005C2F 1D                      	db 29
 36341 00005C30 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 36341 00005C39 726976652073706563-
 36341 00005C42 696669636174696F6E-
 36341 00005C4B 0D0A               
 36342                                  MSG_1022:
 36343 00005C4D 26                      	db 38
 36344 00005C4E 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 36344 00005C57 202531206E6F742070-
 36344 00005C60 726570617265642066-
 36344 00005C69 6F722073797374656D-
 36344 00005C72 0D0A               
 36345                                  MSG_1023:
 36346 00005C74 2B                      	db 43
 36347 00005C75 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 36347 00005C7E 202531206E6F742070-
 36347 00005C87 726570617265642066-
 36347 00005C90 6F7220616C6C206465-
 36347 00005C99 76696365730D0A     
 36348                                  MSG_1024:
 36349 00005CA0 16                      	db 22
 36350 00005CA1 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 36350 00005CAA 646520706167653A20-
 36350 00005CB3 25310D0A           
 36351                                  MSG_1025:
 36352 00005CB7 17                      	db 23
 36353 00005CB8 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 36353 00005CC1 6F7420696E7374616C-
 36353 00005CCA 6C65640D0A         
 36354                                  MSG_1027:
 36355 00005CCF 20                      	db 32
 36356 00005CD0 43757272656E742064-     	db 'Current drive is no longer valid'
 36356 00005CD9 72697665206973206E-
 36356 00005CE2 6F206C6F6E67657220-
 36356 00005CEB 76616C6964         
 36357                                  MSG_1029:
 36358 00005CF0 11                      	db 17
 36359 00005CF1 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 36359 00005CFA 20666F756E640D0A   
 36360                                  MSG_1030:
 36361 00005D02 0E                      	db 14
 36362 00005D03 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 36362 00005D0C 726F720D0A         
 36363                                  MSG_1032:
 36364 00005D11 17                      	db 23
 36365 00005D12 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 36365 00005D1B 617465206973202531-
 36365 00005D24 2025320D0A         
 36366                                  MSG_1033:
 36367 00005D29 15                      	db 21
 36368 00005D2A 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 36368 00005D33 576564546875467269-
 36368 00005D3C 536174             
 36369                                  MSG_1034:
 36370 00005D3F 15                      	db 21
 36371 00005D40 456E746572206E6577-     	db 'Enter new date (%1): '
 36371 00005D49 206461746520282531-
 36371 00005D52 293A20             
 36372                                  MSG_1036:
 36373 00005D55 14                      	db 20
 36374 00005D56 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 36374 00005D5F 696D65206973202531-
 36374 00005D68 0D0A               
 36375                                  MSG_1037:
 36376 00005D6A 10                      	db 16
 36377 00005D6B 456E746572206E6577-     	db 'Enter new time: '
 36377 00005D74 2074696D653A20     
 36378                                  MSG_1038:
 36379 00005D7B 12                              db 18
 36380 00005D7C 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 36380 00005D85 74652028592F4E293F 
 36381                                  MSG_1039:
 36382 00005D8E 3C                              db 60
 36383 00005D8F 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 36383 00005D98 20696E206469726563-
 36383 00005DA1 746F72792077696C6C-
 36383 00005DAA 2062652064656C6574-
 36383 00005DB3 6564210D0A         
 36384 00005DB8 41726520796F752073-     	db 'Are you sure (Y/N)?'
 36384 00005DC1 7572652028592F4E29-
 36384 00005DCA 3F                 
 36385                                  MSG_1040:
 36386 00005DCB 14                      	db 20
 36387 00005DCC 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 36387 00005DD5 7273696F6E2025312E-
 36387 00005DDE 2532               
 36388                                  MSG_1044:
 36389 00005DE0 13                      	db 19
 36390 00005DE1 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 36390 00005DEA 69726563746F72790D-
 36390 00005DF3 0A                 
 36391                                  MSG_1046:
 36392 00005DF4 36                      	db 54
 36393 00005DF5 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 36393 00005DFE 6174682C206E6F7420-
 36393 00005E07 6469726563746F7279-
 36393 00005E10 2C0D0A             
 36394 00005E13 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 36394 00005E1C 6F7279206E6F742065-
 36394 00005E25 6D7074790D0A       
 36395                                  MSG_1047:
 36396 00005E2B 18                      	db 24
 36397 00005E2C 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 36397 00005E35 696679204F4E206F72-
 36397 00005E3E 204F46460D0A       
 36398                                  MSG_1048:
 36399 00005E44 11                      	db 17
 36400 00005E45 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 36400 00005E4E 206F662025310D0A   
 36401                                  MSG_1049:
 36402 00005E56 09                      	db 9
 36403 00005E57 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 36404                                  MSG_1050:
 36405 00005E60 1E                      	db 30
 36406 00005E61 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 36406 00005E6A 7269766520696E2073-
 36406 00005E73 656172636820706174-
 36406 00005E7C 680D0A             
 36407                                  MSG_1051:
 36408 00005E7F 10                      	db 16
 36409 00005E80 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 36409 00005E89 65766963650D0A     
 36410                                  MSG_1052:
 36411 00005E90 16                      	db 22
 36412 00005E91 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 36412 00005E9A 74206265206E657374-
 36412 00005EA3 65640D0A           
 36413                                  MSG_1053:
 36414 00005EA7 25                      	db 37
 36415 00005EA8 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 36415 00005EB1 6174652066696C6520-
 36415 00005EBA 6572726F7220647572-
 36415 00005EC3 696E6720706970650D-
 36415 00005ECC 0A                 
 36416                                  MSG_1054:
 36417 00005ECD 26                      	db 38
 36418 00005ECE 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 36418 00005ED7 2062696E6172792072-
 36418 00005EE0 656164732066726F6D-
 36418 00005EE9 206120646576696365-
 36418 00005EF2 0D0A               
 36419                                  
 36420                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 36421                                  MSG_1055:
 36422 00005EF4 0D                      	db 13
 36423 00005EF5 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 36423 00005EFE 25310D0A           
 36424                                  MSG_1056:
 36425 00005F02 0E                      	db 14
 36426 00005F03 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 36426 00005F0C 2025310D0A         
 36427                                  MSG_1057:
 36428 00005F11 0C                      	db 12
 36429 00005F12 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 36429 00005F1B 310D0A             
 36430                                  MSG_1059:
 36431 00005F1E 04                      	db 4
 36432 00005F1F 6F666600                	db 'off',0
 36433                                  MSG_1060:
 36434 00005F23 03                      	db 3
 36435 00005F24 6F6E00                  	db 'on',0
 36436                                  MSG_1061:
 36437 00005F27 19                      	db 25
 36438 00005F28 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 36438 00005F31 74696E6720746F2064-
 36438 00005F3A 65766963650D0A     
 36439                                  MSG_1063:
 36440 00005F41 02                      	db 2
 36441 00005F42 2531                    	db '%1'
 36442                                  MSG_1064:
 36443 00005F44 02                      	db 2
 36444 00005F45 2531                    	db '%1'
 36445                                  MSG_1065:
 36446 00005F47 02                      	db 2
 36447 00005F48 2531                    	db '%1'
 36448                                  MSG_1066:
 36449 00005F4A 02                      	db 2
 36450 00005F4B 2531                    	db '%1'
 36451                                  MSG_1067:
 36452 00005F4D 01                      	db 1
 36453 00005F4E 09                      	db 9
 36454                                  MSG_1068:
 36455 00005F4F 0A                      	db 10
 36456 00005F50 203C4449523E202020-     	db ' <DIR>    '
 36456 00005F59 20                 
 36457                                  MSG_1069:
 36458 00005F5A 03                      	db 3
 36459 00005F5B 082008                  	db 8, 20h, 8
 36460                                  MSG_1070:	; CRLF
 36461 00005F5E 02                      	db 2
 36462 00005F5F 0D                      	db 0Dh
 36463 00005F60 0A                      	db 0Ah
 36464                                  MSG_1071:
 36465 00005F61 02                      	db 2
 36466 00005F62 2531                    	db '%1'
 36467                                  MSG_1072:
 36468 00005F64 08                      	db 8
 36469 00005F65 6D6D2D64642D7979        	db 'mm-dd-yy'
 36470                                  MSG_1073:
 36471 00005F6D 08                      	db 8
 36472 00005F6E 64642D6D6D2D7979        	db 'dd-mm-yy'
 36473                                  MSG_1074:
 36474 00005F76 08                      	db 8
 36475 00005F77 79792D6D6D2D6464        	db 'yy-mm-dd'
 36476                                  MSG_1075:
 36477 00005F7F 05                      	db 5
 36478 00005F80 2531202532              	db '%1 %2'
 36479                                  MSG_1076:
 36480 00005F85 02                      	db 2
 36481 00005F86 2531                    	db '%1'
 36482                                  MSG_1077:
 36483 00005F88 07                      	db 7
 36484 00005F89 20253120202532          	db ' %1  %2'
 36485                                  MSG_1078:
 36486 00005F90 1A                      	db 26
 36487 00005F91 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 36487 00005F9A 20616C726561647920-
 36487 00005FA3 6578697374730D0A   
 36488                                  MSG_1079:
 36489 00005FAB 0A                      	db 10
 36490 00005FAC 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 36490 00005FB5 0A                 
 36491                                  MSG_1080:
 36492 00005FB6 15                      	db 21
 36493 00005FB7 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 36493 00005FC0 6573206C6973746564-
 36493 00005FC9 3A0D0A             
 36494                                  MSG_1081:
 36495 00005FCC 2A                      	db 42
 36496 00005FCD 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 36496 00005FD6 63757272656420696E-
 36496 00005FDF 20656E7669726F6E6D-
 36496 00005FE8 656E74207661726961-
 36496 00005FF1 626C65290D0A       
 36497                                  MSG_1084:
 36498 00005FF7 0F                      	db 15
 36499 00005FF8 28636F6E74696E7569-     	db '(continuing %1)'
 36499 00006001 6E6720253129       
 36500                                  MSG_1090:
 36501 00006007 0D                      	db 13
 36502 00006008 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 36502 00006011 25310D0A           
 36503                                  MSG_1091:
 36504 00006015 0D                      	db 13
 36505 00006016 444F5320697320696E-     	db 'DOS is in ROM'
 36505 0000601F 20524F4D           
 36506                                  MSG_1092:
 36507 00006023 0D                      	db 13
 36508 00006024 444F5320697320696E-     	db 'DOS is in HMA'
 36508 0000602D 20484D41           
 36509                                  MSG_1093:
 36510 00006031 14                      	db 20
 36511 00006032 444F5320697320696E-     	db 'DOS is in low memory'
 36511 0000603B 206C6F77206D656D6F-
 36511 00006044 7279               
 36512                                  MSG_1094:
 36513 00006046 1C                      	db 28
 36514 00006047 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 36514 00006050 616468696768206261-
 36514 00006059 7463682066696C650D-
 36514 00006062 0A                 
 36515                                  MSG_1095:
 36516 00006063 1C                      	db 28
 36517 00006064 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 36517 0000606D 20496E76616C696420-
 36517 00006076 66696C656E616D650D-
 36517 0000607F 0A                 
 36518                                  MSG_1096:
 36519 00006080 30                      	db 48
 36520 00006081 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 36520 0000608A 656E20737065636966-
 36520 00006093 69656420636F756E74-
 36520 0000609C 727920696E666F726D-
 36520 000060A5 6174696F6E2066696C-
 36520 000060AE 650D0A             
 36521                                  
 36522                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 36523                                  MSG_1200:
 36524 000060B1 00                      	db 0	; /? unimplemented
 36525                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 36526                                  MSG_1300:
 36527 000060B2 86                      	db 134
 36528 000060B3 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 36528 000060BC 6C6561727320657874-
 36528 000060C5 656E64656420435452-
 36528 000060CE 4C2B4320636865636B-
 36528 000060D7 696E672E0D0A       
 36529 000060DD 0D0A                    	db 0Dh,0Ah
 36530 000060DF 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 36530 000060E8 207C204F46465D0D0A 
 36531 000060F1 0D0A                    	db 0Dh,0Ah
 36532 000060F3 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 36532 000060FC 4B20776974686F7574-
 36532 00006105 206120706172616D65-
 36532 0000610E 74657220746F206469-
 36532 00006117 73706C617920746865-
 36532 00006120 2063757272656E7420-
 36532 00006129 425245414B20736574-
 36532 00006132 74696E672E0D0A     
 36533                                  MSG_1320:
 36534 00006139 3F                      	db 63
 36535 0000613A 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 36535 00006143 6F7220736574732074-
 36535 0000614C 686520616374697665-
 36535 00006155 20636F646520706167-
 36535 0000615E 65206E756D6265722E-
 36535 00006167 0D0A               
 36536 00006169 0D0A                    	db 0Dh,0Ah
 36537 0000616B 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 36537 00006174 5D0D0A             
 36538 00006177 0D0A                    	db 0Dh,0Ah
 36539                                  MSG_1321:
 36540 00006179 70                      	db 112
 36541 0000617A 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 36541 00006183 706563696669657320-
 36541 0000618C 6120636F6465207061-
 36541 00006195 6765206E756D626572-
 36541 0000619E 2E0D0A             
 36542 000061A1 0D0A                    	db 0Dh,0Ah
 36543 000061A3 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 36543 000061AC 20776974686F757420-
 36543 000061B5 6120706172616D6574-
 36543 000061BE 657220746F20646973-
 36543 000061C7 706C61792074686520-
 36543 000061D0 61637469766520636F-
 36543 000061D9 64652070616765206E-
 36543 000061E2 756D6265722E0D0A   
 36544                                  MSG_1340:
 36545 000061EA 5B                      	db 91
 36546 000061EB 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 36546 000061F4 746865206E616D6520-
 36546 000061FD 6F66206F7220636861-
 36546 00006206 6E6765732074686520-
 36546 0000620F 63757272656E742064-
 36546 00006218 69726563746F72792E-
 36546 00006221 0D0A               
 36547 00006223 0D0A                    	db 0Dh,0Ah
 36548 00006225 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 36548 0000622E 6976653A5D5B706174-
 36548 00006237 685D0D0A           
 36549 0000623B 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 36549 00006244 0D0A               
 36550                                  MSG_1341:
 36551 00006246 62                      	db 98
 36552 00006247 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 36552 00006250 3A5D5B706174685D0D-
 36552 00006259 0A                 
 36553 0000625A 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 36554 00006262 0D0A                    	db 0Dh,0Ah
 36555 00006264 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 36555 0000626D 656369666965732074-
 36555 00006276 68617420796F752077-
 36555 0000627F 616E7420746F206368-
 36555 00006288 616E676520746F2074-
 36555 00006291 686520706172656E74-
 36555 0000629A 206469726563746F72-
 36555 000062A3 792E               
 36556 000062A5 0D0A                    	db 0Dh,0Ah
 36557 000062A7 0D0A                    	db 0Dh,0Ah
 36558                                  MSG_1342:
 36559 000062A9 91                      	db 145
 36560 000062AA 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 36560 000062B3 726976653A20746F20-
 36560 000062BC 646973706C61792074-
 36560 000062C5 68652063757272656E-
 36560 000062CE 74206469726563746F-
 36560 000062D7 727920696E20746865-
 36560 000062E0 207370656369666965-
 36560 000062E9 6420               
 36561 000062EB 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 36562 000062F3 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 36562 000062FC 6974686F7574207061-
 36562 00006305 72616D657465727320-
 36562 0000630E 746F20646973706C61-
 36562 00006317 792074686520637572-
 36562 00006320 72656E742064726976-
 36562 00006329 6520616E6420646972-
 36562 00006332 6563746F72792E0D0A 
 36563                                  MSG_1360:
 36564 0000633B 1B                      	db 27
 36565 0000633C 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 36565 00006345 652073637265656E2E-
 36565 0000634E 0D0A               
 36566 00006350 0D0A                    	db 0Dh,0Ah
 36567 00006352 434C530D0A              	db 'CLS',0Dh,0Ah
 36568                                  MSG_1400:
 36569 00006357 91                      	db 145
 36570 00006358 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 36570 00006361 65206F72206D6F7265-
 36570 0000636A 2066696C657320746F-
 36570 00006373 20616E6F7468657220-
 36570 0000637C 6C6F636174696F6E2E-
 36570 00006385 0D0A               
 36571 00006387 0D0A                    	db 0Dh,0Ah
 36572 00006389 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 36572 00006392 7C202F425D20736F75-
 36572 0000639B 726365205B2F41207C-
 36572 000063A4 202F425D205B2B2073-
 36572 000063AD 6F75726365205B2F41-
 36572 000063B6 207C202F425D205B2B-
 36572 000063BF 202E2E2E5D5D205B64-
 36572 000063C8 657374696E6174696F-
 36572 000063D1 6E0D0A             
 36573 000063D4 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 36573 000063DD 425D5D205B2F565D0D-
 36573 000063E6 0A                 
 36574 000063E7 0D0A                    	db 0Dh,0Ah
 36575                                  MSG_1401:
 36576 000063E9 68                      	db 104
 36577 000063EA 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 36577 000063F3 202020202020537065-
 36577 000063FC 636966696573207468-
 36577 00006405 652066696C65206F72-
 36577 0000640E 2066696C657320746F-
 36577 00006417 20626520636F706965-
 36577 00006420 642E0D0A           
 36578 00006424 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 36578 0000642D 202020202020496E64-
 36578 00006436 69636174657320616E-
 36578 0000643F 204153434949207465-
 36578 00006448 78742066696C652E0D-
 36578 00006451 0A                 
 36579                                  MSG_1402:
 36580 00006452 76                      	db 118
 36581 00006453 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 36581 0000645C 202020202020496E64-
 36581 00006465 696361746573206120-
 36581 0000646E 62696E617279206669-
 36581 00006477 6C652E0D0A         
 36582 0000647C 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 36582 00006485 74696F6E2020537065-
 36582 0000648E 636966696573207468-
 36582 00006497 65206469726563746F-
 36582 000064A0 727920616E642F6F72-
 36582 000064A9 2066696C656E616D65-
 36582 000064B2 20666F722074686520-
 36582 000064BB 6E65772066696C6528-
 36582 000064C4 73292E0D0A         
 36583                                  MSG_1403:	
 36584 000064C9 41                      	db 65
 36585 000064CA 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 36585 000064D3 202020202020566572-
 36585 000064DC 696669657320746861-
 36585 000064E5 74206E65772066696C-
 36585 000064EE 657320617265207772-
 36585 000064F7 697474656E20636F72-
 36585 00006500 726563746C792E0D0A 
 36586 00006509 0D0A                    	db 0Dh,0Ah
 36587                                  MSG_1404:
 36588 0000650B 87                      	db 135
 36589 0000650C 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 36589 00006515 2066696C65732C2073-
 36589 0000651E 706563696679206120-
 36589 00006527 73696E676C65206669-
 36589 00006530 6C6520666F72206465-
 36589 00006539 7374696E6174696F6E-
 36589 00006542 2C20627574206D756C-
 36589 0000654B 7469706C652066696C-
 36589 00006554 65730D0A           
 36590 00006558 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 36590 00006561 6520287573696E6720-
 36590 0000656A 77696C646361726473-
 36590 00006573 206F722066696C6531-
 36590 0000657C 2B66696C65322B6669-
 36590 00006585 6C653320666F726D61-
 36590 0000658E 74292E0D0A         
 36591                                  MSG_1420:
 36592 00006593 8A                      	db 138
 36593 00006594 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 36593 0000659D 6865207465726D696E-
 36593 000065A6 616C20646576696365-
 36593 000065AF 207573656420746F20-
 36593 000065B8 636F6E74726F6C2079-
 36593 000065C1 6F7572207379737465-
 36593 000065CA 6D2E0D0A           
 36594 000065CE 0D0A                    	db 0Dh,0Ah
 36595 000065D0 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 36595 000065D9 63650D0A           
 36596 000065DD 0D0A                    	db 0Dh,0Ah
 36597 000065DF 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 36597 000065E8 202054686520746572-
 36597 000065F1 6D696E616C20646576-
 36597 000065FA 69636520796F752077-
 36597 00006603 616E7420746F207573-
 36597 0000660C 652C20737563682061-
 36597 00006615 7320434F4D312E0D0A 
 36598                                  MSG_1440:
 36599 0000661E 2D                      	db 45
 36600 0000661F 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 36600 00006628 6F7220736574732074-
 36600 00006631 686520646174652E0D-
 36600 0000663A 0A                 
 36601 0000663B 0D0A                    	db 0Dh,0Ah
 36602 0000663D 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 36602 00006646 655D0D0A           
 36603 0000664A 0D0A                    	db 0Dh,0Ah
 36604                                  MSG_1441:
 36605 0000664C 83                      	db 131
 36606 0000664D 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 36606 00006656 20776974686F757420-
 36606 0000665F 706172616D65746572-
 36606 00006668 7320746F2064697370-
 36606 00006671 6C6179207468652063-
 36606 0000667A 757272656E74206461-
 36606 00006683 74652073657474696E-
 36606 0000668C 6720616E640D0A     
 36607 00006693 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 36607 0000669C 666F722061206E6577-
 36607 000066A5 206F6E652E20205072-
 36607 000066AE 65737320454E544552-
 36607 000066B7 20746F206B65657020-
 36607 000066C0 7468652073616D6520-
 36607 000066C9 646174652E0D0A     
 36608                                  MSG_1460:	
 36609 000066D0 64                      	db 100
 36610 000066D1 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36610 000066DA 6E65206F72206D6F72-
 36610 000066E3 652066696C65732E0D-
 36610 000066EC 0A                 
 36611 000066ED 0D0A                    	db 0Dh,0Ah
 36612 000066EF 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36612 000066F8 653A5D5B706174685D-
 36612 00006701 66696C656E616D6520-
 36612 0000670A 5B2F505D0D0A       
 36613 00006710 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36613 00006719 6976653A5D5B706174-
 36613 00006722 685D66696C656E616D-
 36613 0000672B 65205B2F505D0D0A   
 36614 00006733 0D0A                    	db 0Dh,0Ah
 36615                                  MSG_1461:
 36616 00006735 83                      	db 131
 36617 00006736 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36617 0000673F 5D5B706174685D6669-
 36617 00006748 6C656E616D65202053-
 36617 00006751 706563696669657320-
 36617 0000675A 7468652066696C6528-
 36617 00006763 732920746F2064656C-
 36617 0000676C 6574652E2020537065-
 36617 00006775 63696679206D756C74-
 36617 0000677E 69706C650D0A       
 36618 00006784 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36618 0000678D 202020202020202020-
 36618 00006796 202020202020202066-
 36618 0000679F 696C65732062792075-
 36618 000067A8 73696E672077696C64-
 36618 000067B1 63617264732E0D0A   
 36619                                  MSG_1462:
 36620 000067B9 4F                      	db 79
 36621 000067BA 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36621 000067C3 202020202020202020-
 36621 000067CC 202020202020202050-
 36621 000067D5 726F6D70747320666F-
 36621 000067DE 7220636F6E6669726D-
 36621 000067E7 6174696F6E20626566-
 36621 000067F0 6F72652064656C6574-
 36621 000067F9 696E67206561636820-
 36621 00006802 66696C652E0D0A     
 36622                                  MSG_1480:
 36623 00006809 A2                      	db 162
 36624 0000680A 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36624 00006813 61206C697374206F66-
 36624 0000681C 2066696C657320616E-
 36624 00006825 642073756264697265-
 36624 0000682E 63746F726965732069-
 36624 00006837 6E2061206469726563-
 36624 00006840 746F72792E0D0A     
 36625 00006847 0D0A                    	db 0Dh,0Ah
 36626 00006849 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36626 00006852 653A5D5B706174685D-
 36626 0000685B 5B66696C656E616D65-
 36626 00006864 5D205B2F505D205B2F-
 36626 0000686D 575D205B2F415B5B3A-
 36626 00006876 5D6174747269627574-
 36626 0000687F 65735D5D0D0A       
 36627 00006885 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36627 0000688E 736F72746F72646572-
 36627 00006897 5D5D205B2F535D205B-
 36627 000068A0 2F425D205B2F4C5D0D-
 36627 000068A9 0A                 
 36628 000068AA 0D0A                    	db 0Dh,0Ah
 36629                                  MSG_1481:
 36630 000068AC 5D                      	db 93
 36631 000068AD 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36631 000068B6 5D5B706174685D5B66-
 36631 000068BF 696C656E616D655D0D-
 36631 000068C8 0A                 
 36632 000068C9 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36632 000068D2 202020202053706563-
 36632 000068DB 696669657320647269-
 36632 000068E4 76652C206469726563-
 36632 000068ED 746F72792C20616E64-
 36632 000068F6 2F6F722066696C6573-
 36632 000068FF 20746F206C6973742E-
 36632 00006908 0D0A               
 36633                                  MSG_1482:
 36634 0000690A 61                      	db 97
 36635 0000690B 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36635 00006914 202020202050617573-
 36635 0000691D 657320616674657220-
 36635 00006926 656163682073637265-
 36635 0000692F 656E66756C206F6620-
 36635 00006938 696E666F726D617469-
 36635 00006941 6F6E2E0D0A         
 36636 00006946 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36636 0000694F 202020202055736573-
 36636 00006958 2077696465206C6973-
 36636 00006961 7420666F726D61742E-
 36636 0000696A 0D0A               
 36637                                  MSG_1483:	
 36638 0000696C 7A                      	db 122
 36639 0000696D 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36639 00006976 202020202044697370-
 36639 0000697F 6C6179732066696C65-
 36639 00006988 732077697468207370-
 36639 00006991 656369666965642061-
 36639 0000699A 747472696275746573-
 36639 000069A3 2E0D0A             
 36640 000069A6 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36640 000069AF 746573202020442020-
 36640 000069B8 4469726563746F7269-
 36640 000069C1 657320202020202020-
 36640 000069CA 202020202020202020-
 36640 000069D3 522020526561642D6F-
 36640 000069DC 6E6C792066696C6573-
 36640 000069E5 0D0A               
 36641                                  MSG_1484:
 36642 000069E7 BF                      	db 191
 36643 000069E8 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36643 000069F1 202020202020482020-
 36643 000069FA 48696464656E206669-
 36643 00006A03 6C6573202020202020-
 36643 00006A0C 202020202020202020-
 36643 00006A15 41202046696C657320-
 36643 00006A1E 726561647920666F72-
 36643 00006A27 20617263686976696E-
 36643 00006A30 670D0A             
 36644 00006A33 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36644 00006A3C 202020202020532020-
 36644 00006A45 53797374656D206669-
 36644 00006A4E 6C6573202020202020-
 36644 00006A57 202020202020202020-
 36644 00006A60 2D2020507265666978-
 36644 00006A69 206D65616E696E6720-
 36644 00006A72 226E6F74220D0A     
 36645 00006A79 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36645 00006A82 20202020204C697374-
 36645 00006A8B 2062792066696C6573-
 36645 00006A94 20696E20736F727465-
 36645 00006A9D 64206F726465722E0D-
 36645 00006AA6 0A                 
 36646                                  MSG_1485:
 36647 00006AA7 9B                      	db 155
 36648 00006AA8 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36648 00006AB1 6572202020204E2020-
 36648 00006ABA 4279206E616D652028-
 36648 00006AC3 616C70686162657469-
 36648 00006ACC 632920202020202020-
 36648 00006AD5 53202042792073697A-
 36648 00006ADE 652028736D616C6C65-
 36648 00006AE7 737420666972737429-
 36648 00006AF0 0D0A               
 36649 00006AF2 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36649 00006AFB 202020202020452020-
 36649 00006B04 427920657874656E73-
 36649 00006B0D 696F6E2028616C7068-
 36649 00006B16 616265746963292020-
 36649 00006B1F 442020427920646174-
 36649 00006B28 6520262074696D6520-
 36649 00006B31 286561726C69657374-
 36649 00006B3A 206669727374290D0A 
 36650                                  MSG_1486:
 36651 00006B43 96                      	db 150
 36652 00006B44 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36652 00006B4D 202020202020472020-
 36652 00006B56 47726F757020646972-
 36652 00006B5F 6563746F7269657320-
 36652 00006B68 666972737420202020-
 36652 00006B71 2D2020507265666978-
 36652 00006B7A 20746F207265766572-
 36652 00006B83 7365206F726465720D-
 36652 00006B8C 0A                 
 36653 00006B8D 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36653 00006B96 202020202044697370-
 36653 00006B9F 6C6179732066696C65-
 36653 00006BA8 7320696E2073706563-
 36653 00006BB1 696669656420646972-
 36653 00006BBA 6563746F727920616E-
 36653 00006BC3 6420616C6C20737562-
 36653 00006BCC 6469726563746F7269-
 36653 00006BD5 65732E0D0A         
 36654                                  MSG_1487:
 36655 00006BDA 66                      	db 102
 36656 00006BDB 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36656 00006BE4 202020202055736573-
 36656 00006BED 206261726520666F72-
 36656 00006BF6 6D617420286E6F2068-
 36656 00006BFF 656164696E6720696E-
 36656 00006C08 666F726D6174696F6E-
 36656 00006C11 206F722073756D6D61-
 36656 00006C1A 7279292E0D0A       
 36657 00006C20 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36657 00006C29 202020202055736573-
 36657 00006C32 206C6F776572636173-
 36657 00006C3B 652E0D0A           
 36658 00006C3F 0D0A                    	db 0Dh,0Ah
 36659                                  MSG_1488:
 36660 00006C41 92                      	db 146
 36661 00006C42 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36661 00006C4B 6D6179206265207072-
 36661 00006C54 6573657420696E2074-
 36661 00006C5D 686520444952434D44-
 36661 00006C66 20656E7669726F6E6D-
 36661 00006C6F 656E74207661726961-
 36661 00006C78 626C652E20204F7665-
 36661 00006C81 72726964650D0A     
 36662 00006C88 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36662 00006C91 697463686573206279-
 36662 00006C9A 20707265666978696E-
 36662 00006CA3 6720616E7920737769-
 36662 00006CAC 746368207769746820-
 36662 00006CB5 2D202868797068656E-
 36662 00006CBE 292D2D666F72206578-
 36662 00006CC7 616D706C652C202F2D-
 36662 00006CD0 572E0D0A           
 36663                                  MSG_1500:
 36664 00006CD4 3E                      	db 62
 36665 00006CD5 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36665 00006CDE 20434F4D4D414E442E-
 36665 00006CE7 434F4D2070726F6772-
 36665 00006CF0 616D2028636F6D6D61-
 36665 00006CF9 6E6420696E74657270-
 36665 00006D02 7265746572292E0D0A 
 36666 00006D0B 0D0A                    	db 0Dh,0Ah
 36667 00006D0D 455849540D0A            	db 'EXIT',0Dh,0Ah
 36668                                  MSG_1520:
 36669 00006D13 3D                      	db 61
 36670 00006D14 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36670 00006D1D 206469726563746F72-
 36670 00006D26 792E0D0A           
 36671 00006D2A 0D0A                    	db 0Dh,0Ah
 36672 00006D2C 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36672 00006D35 6976653A5D70617468-
 36672 00006D3E 0D0A               
 36673 00006D40 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36673 00006D49 3A5D706174680D0A   
 36674                                  MSG_1540:
 36675 00006D51 5D                      	db 93
 36676 00006D52 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36676 00006D5B 6F7220736574732061-
 36676 00006D64 207365617263682070-
 36676 00006D6D 61746820666F722065-
 36676 00006D76 786563757461626C65-
 36676 00006D7F 2066696C65732E0D0A 
 36677 00006D88 0D0A                    	db 0Dh,0Ah
 36678 00006D8A 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36678 00006D93 6976653A5D70617468-
 36678 00006D9C 5B3B2E2E2E5D5D0D0A 
 36679 00006DA5 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36680 00006DAD 0D0A                    	db 0Dh,0Ah
 36681                                  MSG_1541:
 36682 00006DAF 6B                      	db 107
 36683 00006DB0 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36683 00006DB9 203B20746F20636C65-
 36683 00006DC2 617220616C6C207365-
 36683 00006DCB 617263682D70617468-
 36683 00006DD4 2073657474696E6773-
 36683 00006DDD 20616E642064697265-
 36683 00006DE6 6374204D532D444F53-
 36683 00006DEF 20746F207365617263-
 36683 00006DF8 680D0A             
 36684 00006DFB 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36684 00006E04 68652063757272656E-
 36684 00006E0D 74206469726563746F-
 36684 00006E16 72792E0D0A         
 36685                                  MSG_1542:
 36686 00006E1B 3B                      	db 59
 36687 00006E1C 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36687 00006E25 20776974686F757420-
 36687 00006E2E 706172616D65746572-
 36687 00006E37 7320746F2064697370-
 36687 00006E40 6C6179207468652063-
 36687 00006E49 757272656E74207061-
 36687 00006E52 74682E0D0A         
 36688                                  MSG_1560:
 36689 00006E57 37                      	db 55
 36690 00006E58 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36690 00006E61 6865204D532D444F53-
 36690 00006E6A 20636F6D6D616E6420-
 36690 00006E73 70726F6D70742E0D0A 
 36691 00006E7C 0D0A                    	db 0Dh,0Ah
 36692 00006E7E 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36692 00006E87 6578745D0D0A       
 36693 00006E8D 0D0A                    	db 0Dh,0Ah
 36694                                  MSG_1561:
 36695 00006E8F 7C                      	db 124
 36696 00006E90 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36696 00006E99 205370656369666965-
 36696 00006EA2 732061206E65772063-
 36696 00006EAB 6F6D6D616E64207072-
 36696 00006EB4 6F6D70742E0D0A     
 36697 00006EBB 0D0A                    	db 0Dh,0Ah
 36698 00006EBD 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36698 00006EC6 6E206265206D616465-
 36698 00006ECF 207570206F66206E6F-
 36698 00006ED8 726D616C2063686172-
 36698 00006EE1 61637465727320616E-
 36698 00006EEA 642074686520666F6C-
 36698 00006EF3 6C6F77696E67207370-
 36698 00006EFC 656369616C20636F64-
 36698 00006F05 65733A0D0A         
 36699 00006F0A 0D0A                    	db 0Dh,0Ah
 36700                                  MSG_1562:
 36701 00006F0C 2F                      	db 47
 36702 00006F0D 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36702 00006F16 28657175616C207369-
 36702 00006F1F 676E290D0A         
 36703 00006F24 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36703 00006F2D 28646F6C6C61722073-
 36703 00006F36 69676E290D0A       
 36704                                  MSG_1563:
 36705 00006F3C 2A                      	db 42
 36706 00006F3D 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36706 00006F46 7272656E742074696D-
 36706 00006F4F 650D0A             
 36707 00006F52 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36707 00006F5B 7272656E7420646174-
 36707 00006F64 650D0A             
 36708                                  MSG_1564:
 36709 00006F67 3D                      	db 61
 36710 00006F68 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36710 00006F71 7272656E7420647269-
 36710 00006F7A 766520616E64207061-
 36710 00006F83 74680D0A           
 36711 00006F87 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36711 00006F90 2D444F532076657273-
 36711 00006F99 696F6E206E756D6265-
 36711 00006FA2 720D0A             
 36712                                  MSG_1565:
 36713 00006FA5 34                      	db 52
 36714 00006FA6 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36714 00006FAF 7272656E7420647269-
 36714 00006FB8 76650D0A           
 36715 00006FBC 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36715 00006FC5 28677265617465722D-
 36715 00006FCE 7468616E207369676E-
 36715 00006FD7 290D0A             
 36716                                  MSG_1566:
 36717 00006FDA 2C                      	db 44
 36718 00006FDB 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36718 00006FE4 286C6573732D746861-
 36718 00006FED 6E207369676E290D0A 
 36719 00006FF6 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36719 00006FFF 2870697065290D0A   
 36720                                  MSG_1567:
 36721 00007007 79                      	db 121
 36722 00007008 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36722 00007011 636B73706163652028-
 36722 0000701A 657261736573207072-
 36722 00007023 6576696F7573206368-
 36722 0000702C 61726163746572290D-
 36722 00007035 0A                 
 36723 00007036 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36723 0000703F 6361706520636F6465-
 36723 00007048 202841534349492063-
 36723 00007051 6F6465203237290D0A 
 36724 0000705A 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36724 00007063 727269616765207265-
 36724 0000706C 7475726E20616E6420-
 36724 00007075 6C696E65666565640D-
 36724 0000707E 0A                 
 36725 0000707F 0D0A                    	db 0Dh,0Ah
 36726                                  MSG_1568:
 36727 00007081 4C                      	db 76
 36728 00007082 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36728 0000708B 505420776974686F75-
 36728 00007094 7420706172616D6574-
 36728 0000709D 65727320746F207265-
 36728 000070A6 736574207468652070-
 36728 000070AF 726F6D707420746F20-
 36728 000070B8 746865206465666175-
 36728 000070C1 6C742073657474696E-
 36728 000070CA 672E0D0A           
 36729                                  MSG_1580:
 36730 000070CE 47                      	db 71
 36731 000070CF 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36731 000070D8 64656C657465732920-
 36731 000070E1 61206469726563746F-
 36731 000070EA 72792E0D0A         
 36732 000070EF 0D0A                    	db 0Dh,0Ah
 36733 000070F1 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36733 000070FA 6976653A5D70617468-
 36733 00007103 0D0A               
 36734 00007105 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36734 0000710E 3A5D706174680D0A   
 36735                                  MSG_1600:
 36736 00007116 1C                      	db 28
 36737 00007117 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36737 00007120 2066696C65206F7220-
 36737 00007129 66696C65732E0D0A   
 36738 00007131 0D0A                    	db 0Dh,0Ah
 36739                                  MSG_1601:
 36740 00007133 53                      	db 83
 36741 00007134 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36741 0000713D 726976653A5D5B7061-
 36741 00007146 74685D66696C656E61-
 36741 0000714F 6D65312066696C656E-
 36741 00007158 616D65320D0A       
 36742 0000715E 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36742 00007167 653A5D5B706174685D-
 36742 00007170 66696C656E616D6531-
 36742 00007179 2066696C656E616D65-
 36742 00007182 320D0A             
 36743 00007185 0D0A                    	db 0Dh,0Ah
 36744                                  MSG_1602:
 36745 00007187 4D                      	db 77
 36746 00007188 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36746 00007191 20796F752063616E6E-
 36746 0000719A 6F7420737065636966-
 36746 000071A3 792061206E65772064-
 36746 000071AC 72697665206F722070-
 36746 000071B5 61746820666F722079-
 36746 000071BE 6F7572206465737469-
 36746 000071C7 6E6174696F6E206669-
 36746 000071D0 6C652E0D0A         
 36747                                  MSG_1620:
 36748 000071D5 57                      	db 87
 36749 000071D6 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36749 000071DF 20736574732C206F72-
 36749 000071E8 2072656D6F76657320-
 36749 000071F1 4D532D444F5320656E-
 36749 000071FA 7669726F6E6D656E74-
 36749 00007203 207661726961626C65-
 36749 0000720C 732E0D0A           
 36750 00007210 0D0A                    	db 0Dh,0Ah
 36751 00007212 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36751 0000721B 61626C653D5B737472-
 36751 00007224 696E675D5D0D0A     
 36752 0000722B 0D0A                    	db 0Dh,0Ah
 36753                                  MSG_1621:
 36754 0000722D 81                      	db 129
 36755 0000722E 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36755 00007237 652020537065636966-
 36755 00007240 696573207468652065-
 36755 00007249 6E7669726F6E6D656E-
 36755 00007252 742D7661726961626C-
 36755 0000725B 65206E616D652E0D0A 
 36756 00007264 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36756 0000726D 202020537065636966-
 36756 00007276 696573206120736572-
 36756 0000727F 696573206F66206368-
 36756 00007288 617261637465727320-
 36756 00007291 746F2061737369676E-
 36756 0000729A 20746F207468652076-
 36756 000072A3 61726961626C652E0D-
 36756 000072AC 0A                 
 36757 000072AD 0D0A                    	db 0Dh,0Ah
 36758                                  MSG_1622:
 36759 000072AF 4B                      	db 75
 36760 000072B0 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36760 000072B9 776974686F75742070-
 36760 000072C2 6172616D6574657273-
 36760 000072CB 20746F20646973706C-
 36760 000072D4 617920746865206375-
 36760 000072DD 7272656E7420656E76-
 36760 000072E6 69726F6E6D656E7420-
 36760 000072EF 7661726961626C6573-
 36760 000072F8 2E0D0A             
 36761                                  MSG_1640:
 36762 000072FB 34                      	db 52
 36763 000072FC 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36763 00007305 6F7220736574732074-
 36763 0000730E 68652073797374656D-
 36763 00007317 2074696D652E0D0A   
 36764 0000731F 0D0A                    	db 0Dh,0Ah
 36765 00007321 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36765 0000732A 655D0D0A           
 36766 0000732E 0D0A                    	db 0Dh,0Ah
 36767                                  MSG_1641:
 36768 00007330 83                      	db 131
 36769 00007331 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36769 0000733A 2077697468206E6F20-
 36769 00007343 706172616D65746572-
 36769 0000734C 7320746F2064697370-
 36769 00007355 6C6179207468652063-
 36769 0000735E 757272656E74207469-
 36769 00007367 6D652073657474696E-
 36769 00007370 6720616E6420612070-
 36769 00007379 726F6D70740D0A     
 36770 00007380 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36770 00007389 206F6E652E20205072-
 36770 00007392 65737320454E544552-
 36770 0000739B 20746F206B65657020-
 36770 000073A4 7468652073616D6520-
 36770 000073AD 74696D652E0D0A     
 36771                                  MSG_1660:
 36772 000073B4 46                      	db 70
 36773 000073B5 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36773 000073BE 74686520636F6E7465-
 36773 000073C7 6E7473206F66206120-
 36773 000073D0 746578742066696C65-
 36773 000073D9 2E0D0A             
 36774 000073DC 0D0A                    	db 0Dh,0Ah
 36775 000073DE 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36775 000073E7 76653A5D5B70617468-
 36775 000073F0 5D66696C656E616D65-
 36775 000073F9 0D0A               
 36776                                  MSG_1680:
 36777 000073FB 25                      	db 37
 36778 000073FC 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36778 00007405 746865204D532D444F-
 36778 0000740E 532076657273696F6E-
 36778 00007417 2E0D0A             
 36779 0000741A 0D0A                    	db 0Dh,0Ah
 36780 0000741C 5645520D0A              	db 'VER',0Dh,0Ah
 36781                                  MSG_1700:
 36782 00007421 B1                      	db 177
 36783 00007422 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36783 0000742B 444F53207768657468-
 36783 00007434 657220746F20766572-
 36783 0000743D 696679207468617420-
 36783 00007446 796F75722066696C65-
 36783 0000744F 732061726520777269-
 36783 00007458 7474656E20636F7272-
 36783 00007461 6563746C7920746F20-
 36783 0000746A 610D0A             
 36784 0000746D 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36785 00007474 0D0A                    	db 0Dh,0Ah
 36786 00007476 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36786 0000747F 4E207C204F46465D0D-
 36786 00007488 0A                 
 36787 00007489 0D0A                    	db 0Dh,0Ah
 36788 0000748B 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36788 00007494 465920776974686F75-
 36788 0000749D 74206120706172616D-
 36788 000074A6 6574657220746F2064-
 36788 000074AF 6973706C6179207468-
 36788 000074B8 652063757272656E74-
 36788 000074C1 205645524946592073-
 36788 000074CA 657474696E672E0D0A 
 36789                                  MSG_1720:
 36790 000074D3 52                      	db 82
 36791 000074D4 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36791 000074DD 746865206469736B20-
 36791 000074E6 766F6C756D65206C61-
 36791 000074EF 62656C20616E642073-
 36791 000074F8 657269616C206E756D-
 36791 00007501 6265722C2069662074-
 36791 0000750A 686579206578697374-
 36791 00007513 2E0D0A             
 36792 00007516 0D0A                    	db 0Dh,0Ah
 36793 00007518 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36793 00007521 653A5D0D0A         
 36794                                  MSG_1740:
 36795 00007526 5B                      	db 91
 36796 00007527 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36796 00007530 206261746368207072-
 36796 00007539 6F6772616D2066726F-
 36796 00007542 6D20616E6F74686572-
 36796 0000754B 2E0D0A             
 36797 0000754E 0D0A                    	db 0Dh,0Ah
 36798 00007550 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36798 00007559 76653A5D5B70617468-
 36798 00007562 5D66696C656E616D65-
 36798 0000756B 205B62617463682D70-
 36798 00007574 6172616D6574657273-
 36798 0000757D 5D0D0A             
 36799 00007580 0D0A                    	db 0Dh,0Ah
 36800                                  MSG_1741:
 36801 00007582 72                      	db 114
 36802 00007583 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36802 0000758C 6172616D6574657273-
 36802 00007595 202020537065636966-
 36802 0000759E 69657320616E792063-
 36802 000075A7 6F6D6D616E642D6C69-
 36802 000075B0 6E6520696E666F726D-
 36802 000075B9 6174696F6E20726571-
 36802 000075C2 756972656420627920-
 36802 000075CB 7468650D0A         
 36803 000075D0 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36803 000075D9 202020202020202020-
 36803 000075E2 202020626174636820-
 36803 000075EB 70726F6772616D2E0D-
 36803 000075F4 0A                 
 36804                                  MSG_1760:
 36805 000075F5 4C                      	db 76
 36806 000075F6 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36806 000075FF 6F6D6D656E74732028-
 36806 00007608 72656D61726B732920-
 36806 00007611 696E20612062617463-
 36806 0000761A 682066696C65206F72-
 36806 00007623 20434F4E4649472E53-
 36806 0000762C 59532E0D0A         
 36807 00007631 0D0A                    	db 0Dh,0Ah
 36808 00007633 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36808 0000763C 656E745D0D0A       
 36809                                  MSG_1780:
 36810 00007642 6B                      	db 107
 36811 00007643 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36811 0000764C 70726F63657373696E-
 36811 00007655 67206F662061206261-
 36811 0000765E 7463682070726F6772-
 36811 00007667 616D20616E64206469-
 36811 00007670 73706C617973207468-
 36811 00007679 65206D657373616765-
 36811 00007682 2022               
 36812 00007684 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36812 0000768D 0D0A               
 36813 0000768F 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36813 00007698 6E74696E75652E2E2E-
 36813 000076A1 2E220D0A           
 36814 000076A5 0D0A                    	db 0Dh,0Ah
 36815 000076A7 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36816                                  MSG_1800:
 36817 000076AE 4D                      	db 77
 36818 000076AF 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36818 000076B8 6D657373616765732C-
 36818 000076C1 206F72207475726E73-
 36818 000076CA 20636F6D6D616E642D-
 36818 000076D3 6563686F696E67206F-
 36818 000076DC 6E206F72206F66662E-
 36818 000076E5 0D0A               
 36819 000076E7 0D0A                    	db 0Dh,0Ah
 36820 000076E9 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36820 000076F2 4E207C204F46465D0D-
 36820 000076FB 0A                 
 36821                                  MSG_1801:
 36822 000076FC 57                      	db 87
 36823 000076FD 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36823 00007706 6573736167655D0D0A 
 36824 0000770F 0D0A                    	db 0Dh,0Ah
 36825 00007711 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36825 0000771A 20776974686F757420-
 36825 00007723 706172616D65746572-
 36825 0000772C 7320746F2064697370-
 36825 00007735 6C6179207468652063-
 36825 0000773E 757272656E74206563-
 36825 00007747 686F2073657474696E-
 36825 00007750 672E               
 36826 00007752 0D0A                    	db 0Dh,0Ah
 36827                                  MSG_1820:
 36828 00007754 47                      	db 71
 36829 00007755 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36829 0000775E 532D444F5320746F20-
 36829 00007767 61206C6162656C6C65-
 36829 00007770 64206C696E6520696E-
 36829 00007779 206120626174636820-
 36829 00007782 70726F6772616D2E0D-
 36829 0000778B 0A                 
 36830 0000778C 0D0A                    	db 0Dh,0Ah
 36831 0000778E 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36831 00007797 6C0D0A             
 36832 0000779A 0D0A                    	db 0Dh,0Ah
 36833                                  MSG_1821:
 36834 0000779C 8A                      	db 138
 36835 0000779D 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36835 000077A6 205370656369666965-
 36835 000077AF 732061207465787420-
 36835 000077B8 737472696E67207573-
 36835 000077C1 656420696E20746865-
 36835 000077CA 206261746368207072-
 36835 000077D3 6F6772616D20617320-
 36835 000077DC 61206C6162656C2E0D-
 36835 000077E5 0A                 
 36836 000077E6 0D0A                    	db 0Dh,0Ah
 36837 000077E8 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36837 000077F1 61206C6162656C206F-
 36837 000077FA 6E2061206C696E6520-
 36837 00007803 627920697473656C66-
 36837 0000780C 2C20626567696E6E69-
 36837 00007815 6E6720776974682061-
 36837 0000781E 20636F6C6F6E2E0D0A 
 36838                                  MSG_1840:
 36839 00007827 4A                      	db 74
 36840 00007828 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36840 00007831 686520706F73697469-
 36840 0000783A 6F6E206F6620726570-
 36840 00007843 6C61636561626C6520-
 36840 0000784C 706172616D65746572-
 36840 00007855 7320696E2061206261-
 36840 0000785E 7463682066696C652E-
 36840 00007867 0D0A               
 36841 00007869 0D0A                    	db 0Dh,0Ah
 36842 0000786B 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36843                                  MSG_1860:
 36844 00007872 5A                      	db 90
 36845 00007873 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36845 0000787C 636F6E646974696F6E-
 36845 00007885 616C2070726F636573-
 36845 0000788E 73696E6720696E2062-
 36845 00007897 617463682070726F67-
 36845 000078A0 72616D732E0D0A     
 36846 000078A7 0D0A                    	db 0Dh,0Ah
 36847 000078A9 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36847 000078B2 4552524F524C455645-
 36847 000078BB 4C206E756D62657220-
 36847 000078C4 636F6D6D616E640D0A 
 36848                                  MSG_1861:
 36849 000078CD 46                      	db 70
 36850 000078CE 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36850 000078D7 737472696E67313D3D-
 36850 000078E0 737472696E67322063-
 36850 000078E9 6F6D6D616E640D0A   
 36851 000078F1 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36851 000078FA 45584953542066696C-
 36851 00007903 656E616D6520636F6D-
 36851 0000790C 6D616E640D0A       
 36852 00007912 0D0A                    	db 0Dh,0Ah
 36853                                  MSG_1862:
 36854 00007914 7D                      	db 125
 36855 00007915 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36855 0000791E 202020202020202020-
 36855 00007927 202053706563696669-
 36855 00007930 65732074686174204D-
 36855 00007939 532D444F532073686F-
 36855 00007942 756C64206361727279-
 36855 0000794B 206F75742074686520-
 36855 00007954 636F6D6D616E64206F-
 36855 0000795D 6E6C790D0A         
 36856 00007962 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36856 0000796B 202020202020202020-
 36856 00007974 202069662074686520-
 36856 0000797D 636F6E646974696F6E-
 36856 00007986 2069732066616C7365-
 36856 0000798F 2E0D0A             
 36857                                  MSG_1863:
 36858 00007992 A2                      	db 162
 36859 00007993 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36859 0000799C 56454C206E756D6265-
 36859 000079A5 722053706563696669-
 36859 000079AE 657320612074727565-
 36859 000079B7 20636F6E646974696F-
 36859 000079C0 6E2069662074686520-
 36859 000079C9 6C6173742070726F67-
 36859 000079D2 72616D2072756E2072-
 36859 000079DB 657475726E65640D0A 
 36860 000079E4 202020202020202020-     	db '                    '
 36860 000079ED 202020202020202020-
 36860 000079F6 2020               
 36861 000079F8 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36861 00007A01 6F646520657175616C-
 36861 00007A0A 20746F206F72206772-
 36861 00007A13 656174657220746861-
 36861 00007A1C 6E20746865206E756D-
 36861 00007A25 626572207370656369-
 36861 00007A2E 666965642E0D0A     
 36862                                  MSG_1864:
 36863 00007A35 66                      	db 102
 36864 00007A36 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36864 00007A3F 202020202020202020-
 36864 00007A48 202053706563696669-
 36864 00007A51 65732074686520636F-
 36864 00007A5A 6D6D616E6420746F20-
 36864 00007A63 6361727279206F7574-
 36864 00007A6C 206966207468652063-
 36864 00007A75 6F6E646974696F6E20-
 36864 00007A7E 69730D0A           
 36865 00007A82 202020202020202020-     	db '                    met.',0Dh,0Ah
 36865 00007A8B 202020202020202020-
 36865 00007A94 20206D65742E0D0A   
 36866                                  MSG_1865:
 36867 00007A9C 6A                      	db 106
 36868 00007A9D 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36868 00007AA6 3D3D737472696E6732-
 36868 00007AAF 202053706563696669-
 36868 00007AB8 657320612074727565-
 36868 00007AC1 20636F6E646974696F-
 36868 00007ACA 6E2069662074686520-
 36868 00007AD3 737065636966696564-
 36868 00007ADC 207465787420737472-
 36868 00007AE5 696E67730D0A       
 36869 00007AEB 202020202020202020-     	db '                    match.',0Dh,0Ah
 36869 00007AF4 202020202020202020-
 36869 00007AFD 20206D617463682E0D-
 36869 00007B06 0A                 
 36870                                  MSG_1866:
 36871 00007B07 67                      	db 103
 36872 00007B08 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36872 00007B11 696C656E616D652020-
 36872 00007B1A 202053706563696669-
 36872 00007B23 657320612074727565-
 36872 00007B2C 20636F6E646974696F-
 36872 00007B35 6E2069662074686520-
 36872 00007B3E 737065636966696564-
 36872 00007B47 2066696C656E616D65-
 36872 00007B50 0D0A               
 36873 00007B52 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36873 00007B5B 202020202020202020-
 36873 00007B64 20206578697374732E-
 36873 00007B6D 0D0A               
 36874                                  MSG_1880:
 36875 00007B6F 77                      	db 119
 36876 00007B70 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36876 00007B79 656369666965642063-
 36876 00007B82 6F6D6D616E6420666F-
 36876 00007B8B 722065616368206669-
 36876 00007B94 6C6520696E20612073-
 36876 00007B9D 6574206F662066696C-
 36876 00007BA6 65732E0D0A         
 36877 00007BAB 0D0A                    	db 0Dh,0Ah
 36878 00007BAD 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36878 00007BB6 61626C6520494E2028-
 36878 00007BBF 7365742920444F2063-
 36878 00007BC8 6F6D6D616E64205B63-
 36878 00007BD1 6F6D6D616E642D7061-
 36878 00007BDA 72616D65746572735D-
 36878 00007BE3 0D0A               
 36879 00007BE5 0D0A                    	db 0Dh,0Ah
 36880                                  MSG_1881:
 36881 00007BE7 7D                      	db 125
 36882 00007BE8 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36882 00007BF1 6C6520205370656369-
 36882 00007BFA 666965732061207265-
 36882 00007C03 706C61636561626C65-
 36882 00007C0C 20706172616D657465-
 36882 00007C15 722E0D0A           
 36883 00007C19 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36883 00007C22 202020205370656369-
 36883 00007C2B 666965732061207365-
 36883 00007C34 74206F66206F6E6520-
 36883 00007C3D 6F72206D6F72652066-
 36883 00007C46 696C65732E20205769-
 36883 00007C4F 6C646361726473206D-
 36883 00007C58 617920626520757365-
 36883 00007C61 642E0D0A           
 36884                                  MSG_1882:
 36885 00007C65 56                      	db 86
 36886 00007C66 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36886 00007C6F 202020205370656369-
 36886 00007C78 666965732074686520-
 36886 00007C81 636F6D6D616E642074-
 36886 00007C8A 6F206361727279206F-
 36886 00007C93 757420666F72206561-
 36886 00007C9C 63682066696C652E0D-
 36886 00007CA5 0A                 
 36887 00007CA6 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36887 00007CAF 2D706172616D657465-
 36887 00007CB8 72730D0A           
 36888                                  MSG_1883:
 36889 00007CBC A2                      	db 162
 36890 00007CBD 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36890 00007CC6 202020205370656369-
 36890 00007CCF 666965732070617261-
 36890 00007CD8 6D6574657273206F72-
 36890 00007CE1 207377697463686573-
 36890 00007CEA 20666F722074686520-
 36890 00007CF3 737065636966696564-
 36890 00007CFC 20636F6D6D616E642E-
 36890 00007D05 0D0A               
 36891 00007D07 0D0A                    	db 0Dh,0Ah
 36892 00007D09 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36892 00007D12 6520464F5220636F6D-
 36892 00007D1B 6D616E6420696E2061-
 36892 00007D24 206261746368207072-
 36892 00007D2D 6F6772616D2C207370-
 36892 00007D36 656369667920252576-
 36892 00007D3F 61726961626C652069-
 36892 00007D48 6E7374656164206F66-
 36892 00007D51 0D0A               
 36893 00007D53 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36893 00007D5C 2E0D0A             
 36894                                  MSG_1900:
 36895 00007D5F 17                      	db 23
 36896 00007D60 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36896 00007D69 636F6D6D616E64206E-
 36896 00007D72 616D650D0A         
 36897                                  MSG_1920:
 36898 00007D77 2F                      	db 47
 36899 00007D78 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36899 00007D81 726F6772616D20696E-
 36899 00007D8A 746F20746865207570-
 36899 00007D93 706572206D656D6F72-
 36899 00007D9C 7920617265612E0D0A 
 36900 00007DA5 0D0A                    	db 0Dh,0Ah
 36901                                  MSG_1921:
 36902 00007DA7 58                      	db 88
 36903 00007DA8 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36903 00007DB1 5B64726976653A5D5B-
 36903 00007DBA 706174685D66696C65-
 36903 00007DC3 6E616D65205B706172-
 36903 00007DCC 616D65746572735D0D-
 36903 00007DD5 0A                 
 36904 00007DD6 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36904 00007DDF 3A5D5B706174685D66-
 36904 00007DE8 696C656E616D65205B-
 36904 00007DF1 706172616D65746572-
 36904 00007DFA 735D0D0A           
 36905 00007DFE 0D0A                    	db 0Dh,0Ah
 36906                                  MSG_1922:
 36907 00007E00 71                      	db 113
 36908 00007E01 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36908 00007E0A 657273202020537065-
 36908 00007E13 63696669657320616E-
 36908 00007E1C 7920636F6D6D616E64-
 36908 00007E25 2D6C696E6520696E66-
 36908 00007E2E 6F726D6174696F6E20-
 36908 00007E37 726571756972656420-
 36908 00007E40 6279207468650D0A   
 36909 00007E48 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36909 00007E51 20202020202070726F-
 36909 00007E5A 6772616D20796F7520-
 36909 00007E63 77616E7420746F206C-
 36909 00007E6C 6F61642E0D0A       
 36910                                  
 36911                                  ; ---------------------------------------------------------------------------
 36912                                  
 36913                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36914                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36915                                  
 36916                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36917                                  
 36918                                  $M_CLS_3:
 36919 00007E72 0E                      	push	cs		; CLASS_F
 36920 00007E73 07                      	pop	es
 36921 00007E74 8D3E[3357]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36922                                  	; 15/04/2023
 36923                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36924                                  	; 06/08/2024
 36925 00007E78 81C14527                	add	cx,$-$M_CLASS_3_STRUC
 36926 00007E7C C3                      	retn
 36927                                  
 36928                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36929                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36930                                  
 36931                                  ; ---------------------------------------------------------------------------
 36932                                  ; Class 1 messages
 36933                                  ; ---------------------------------------------------------------------------
 36934                                  	
 36935                                  $M_CLASS_1_STRUC:
 36936 00007E7D 01                      	db 1			; $M_CLASS_ID
 36937 00007E7E 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36938 00007E80 04                      	db 4			; Class_1_MessageCount
 36939                                  $M_ID_1_1:
 36940 00007E81 0200                    	dw 2			; Message Number = 2
 36941 00007E83 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36942                                  $M_ID_1_2:
 36943 00007E85 0300                    	dw 3			; Message Number = 3
 36944 00007E87 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36945                                  $M_ID_1_3:
 36946 00007E89 0800                    	dw 8			; Message Number = 8
 36947 00007E8B 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36948                                  $M_ID_1_4:
 36949 00007E8D FFFF                    	dw 0FFFFh		; Message Number = -1
 36950 00007E8F 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36951                                  
 36952                                  ; ---------------------------------------------------------------------------
 36953                                  
 36954                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36955                                  EXTEND2:
 36956 00007E91 0E                      	db 14
 36957 00007E92 46696C65206E6F7420-     	db 'File not found'
 36957 00007E9B 666F756E64         
 36958                                  EXTEND3:
 36959 00007EA0 0E                      	db 14
 36960 00007EA1 50617468206E6F7420-     	db 'Path not found'
 36960 00007EAA 666F756E64         
 36961                                  EXTEND8:
 36962 00007EAF 13                      	db 19
 36963 00007EB0 496E73756666696369-     	db 'Insufficient memory'
 36963 00007EB9 656E74206D656D6F72-
 36963 00007EC2 79                 
 36964                                  EXTEND999:
 36965 00007EC3 11                      	db 17
 36966 00007EC4 457874656E64656420-     	db 'Extended Error %1'
 36966 00007ECD 4572726F72202531   
 36967                                  
 36968                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36969                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36970                                  
 36971                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36972                                  $M_MSGSERV_1:
 36973 00007ED5 0E                      	push	cs
 36974 00007ED6 07                      	pop	es
 36975 00007ED7 8D3E[7D7E]              	lea	di,$M_CLASS_1_STRUC
 36976                                  	; 15/04/2023
 36977                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36978 00007EDB C3                      	retn
 36979                                  
 36980                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36981                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36982                                  
 36983                                  ; ---------------------------------------------------------------------------
 36984                                  ; Class 2 messages
 36985                                  ; ---------------------------------------------------------------------------
 36986                                  	
 36987                                  $M_CLASS_2_STRUC:
 36988 00007EDC 02                      	db 2			; $M_CLASS_ID
 36989 00007EDD 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36990 00007EDF 01                      	db 1			; Class_2_MessageCount
 36991                                  $M_ID_2_1:
 36992 00007EE0 FFFF                    	dw 0FFFFh		; Message Number = -1
 36993 00007EE2 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36994                                  ; ---------------------------------------------------------------------------
 36995                                  
 36996                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36997                                  PARSE999:
 36998 00007EE4 0E                      	db 14
 36999 00007EE5 506172736520457272-     	db 'Parse Error %1'
 36999 00007EEE 6F72202531         
 37000                                  
 37001                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37002                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 37003                                  
 37004                                  ; --------------- S U B R O U T I N E ---------------------------------------
 37005                                  $M_MSGSERV_2:
 37006 00007EF3 0E                      	push	cs
 37007 00007EF4 07                      	pop	es
 37008 00007EF5 8D3E[DC7E]              	lea	di,$M_CLASS_2_STRUC
 37009                                  	; 15/04/2023
 37010                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 37011 00007EF9 C3                      	retn
 37012                                  
 37013                                  ;============================================================================
 37014                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 37015                                  ;============================================================================
 37016                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37017                                  
 37018                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 37019                                  
 37020                                  ;****************************************************
 37021                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 37022                                  ;****************************************************
 37023                                  
 37024                                  msg_disp_class:
 37025 00007EFA FF                      	db	util_msg_class ; 0FFh
 37026                                  msg_cont_flag:
 37027 00007EFB 00                      	db	no_cont_flag ; 0
 37028                                  
 37029                                  ;  extended error string output
 37030                                  extend_buf_ptr:
 37031 00007EFC 0000                    	dw	0			;AN000;set to no message
 37032                                  extend_buf_sub:
 37033 00007EFE 00                      	db	0			;AN000;set to no substitutions
 37034 00007EFF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37035 00007F00 00                      	db	0			;AN000;reserved
 37036                                  extend_buf_off:
 37037 00007F01 [118C]                  	dw	string_ptr_2		;AN000;offset of arg
 37038                                  extend_buf_seg:
 37039 00007F03 0000                    	dw	0			;AN000;segment of arg
 37040 00007F05 00                      	db	0			;AN000;first subst
 37041 00007F06 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37042 00007F07 80                      	db	128			;AN000;maximum width
 37043 00007F08 00                      	db	0			;AN000;minimum width
 37044 00007F09 20                      	db	blank ; 20h		;AN000;pad character
 37045                                  
 37046                                  ;  "Duplicate file name or file not found"
 37047                                  RENERR_PTR:
 37048 00007F0A EA03                    	dw	1002			;AN000;message number
 37049 00007F0C 00                      	db	no_subst ; 0		;AN000;number of subst
 37050                                  
 37051                                  ;  "Invalid path or file name"
 37052                                  BADCPMES_PTR:
 37053 00007F0D EB03                    	dw	1003			;AN000;message number
 37054 00007F0F 00                      	db	no_subst ; 0		;AN000;number of subst
 37055                                  
 37056                                  ;  "Insufficient disk space"
 37057                                  NOSPACE_PTR:
 37058 00007F10 EC03                    	dw	1004			;AN000;message number
 37059 00007F12 00                      	db	no_subst ; 0		;AN000;number of subst
 37060                                  
 37061                                  ;  "Out of environment space"
 37062                                  ENVERR_PTR:
 37063 00007F13 EF03                    	dw	1007			;AN000;message number
 37064 00007F15 00                      	db	no_subst ; 0		;AN000;number of subst
 37065                                  
 37066                                  ;  "File creation error"
 37067                                  FULLDIR_PTR:
 37068 00007F16 F003                    	dw	1008			;AN000;message number
 37069 00007F18 00                      	db	no_subst ; 0		;AN000;number of subst
 37070                                  
 37071                                  ;  "Batch file missing",13,10
 37072                                  BADBAT_PTR:
 37073 00007F19 F103                    	dw	1009			;AN000;message number
 37074 00007F1B 00                      	db	no_subst ; 0		;AN000;number of subst
 37075                                  
 37076                                  ;  "Insert disk with batch file",13,10
 37077                                  NEEDBAT_PTR:
 37078 00007F1C F203                    	dw	1010			;AN000;message number
 37079 00007F1E 00                      	db	no_subst ; 0		;AN000;number of subst
 37080                                  
 37081                                  ;  "Bad command or file name",13,10
 37082                                  BADNAM_PTR:
 37083 00007F1F F303                    	dw	1011			;AN000;message number
 37084 00007F21 00                      	db	no_subst ; 0		;AN000;number of subst
 37085                                  
 37086                                  ;  "Access denied",13,10
 37087                                  ACCDEN_PTR:
 37088 00007F22 F603                    	dw	1014			;AN000;message number
 37089 00007F24 00                      	db	no_subst ; 0		;AN000;number of subst
 37090                                  
 37091                                  ;  "File cannot be copied onto itself",13,10
 37092                                  OVERWR_PTR:
 37093 00007F25 F703                    	dw	1015			;AN000;message number
 37094 00007F27 00                      	db	no_subst ; 0		;AN000;number of subst
 37095                                  
 37096                                  ;  "Content of destination lost before copy",13,10
 37097                                  LOSTERR_PTR:
 37098 00007F28 F803                    	dw	1016			;AN000;message number
 37099 00007F2A 00                      	db	no_subst ; 0		;AN000;number of subst
 37100                                  
 37101                                  ;  "Invalid filename or file not found",13,10
 37102                                  INORNOT_PTR:
 37103 00007F2B F903                    	dw	1017			;AN000;message number
 37104 00007F2D 00                      	db	no_subst		;AN000;number of subst
 37105                                  
 37106                                  ;  "%1 File(s) copied",13,10
 37107                                  copied_ptr:
 37108 00007F2E FA03                    	dw	1018			;AN000;message number
 37109 00007F30 01                      	db	1			;AN000;number of subst
 37110 00007F31 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37111 00007F32 00                      	db	0			;AN000;reserved
 37112 00007F33 [138C]                  	dw	Copy_num		;AN000;offset of arg
 37113 00007F35 0000                    	dw	0			;AN000;segment of arg
 37114 00007F37 01                      	db	1			;AN000;first subst
 37115 00007F38 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37116                                  					;AN000;binary to decimal
 37117 00007F39 09                      	db	9			;AN000;maximum width
 37118 00007F3A 09                      	db	9			;AN000;minimum width
 37119 00007F3B 20                      	db	blank ; 20h		;AN000;pad character
 37120                                  
 37121                                  ;  "%1 File(s) "
 37122                                  dirmes_ptr:
 37123 00007F3C FB03                    	dw	1019			;AN000;message number
 37124 00007F3E 01                      	db	1			;AN000;number of subst
 37125 00007F3F 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37126 00007F40 00                      	db	0			;AN000;reserved
 37127 00007F41 [168C]                  	dw	Dir_Num			;AN000;offset of arg
 37128 00007F43 0000                    	dw	0			;AN000;segment of arg
 37129 00007F45 01                      	db	1			;AN000;first subst
 37130 00007F46 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37131                                  					;AN000;binary to decimal
 37132 00007F47 09                      	db	9			;AN000;maximum width
 37133 00007F48 09                      	db	9			;AN000;minimum width
 37134 00007F49 20                      	db	blank ; 20h		;AN000;pad character
 37135                                  
 37136                                  ;  "%1 bytes free",13,10
 37137                                  bytmes_ptr:
 37138 00007F4A FC03                    	dw	1020			;AN000;message number
 37139 00007F4C 01                      	db	1			;AN000;number of subst
 37140 00007F4D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37141 00007F4E 00                      	db	0			;AN000;reserved
 37142 00007F4F [188C]                  	dw	Bytes_Free		;AN000;offset of arg
 37143 00007F51 0000                    	dw	0			;AN000;segment of arg
 37144 00007F53 01                      	db	1			;AN000;first subst
 37145 00007F54 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37146                                  					;AN000;long binary to decimal
 37147 00007F55 1C                      	db	28			;AN000;maximum width
 37148 00007F56 1C                      	db	28			;AN000;minimum width
 37149 00007F57 20                      	db	blank ; 20h		;AN000;pad character
 37150                                  
 37151                                  ;  "Invalid drive specification",13,10
 37152                                  baddrv_ptr:
 37153 00007F58 FD03                    	dw	1021			;AN000;message number
 37154 00007F5A 00                      	db	no_subst ; 0		;AN000;number of subst
 37155                                  
 37156                                  ;  "Code page %1 not prepared for system",13,10
 37157                                  cp_not_set_ptr:
 37158 00007F5B FE03                    	dw	1022			;AN000;message number
 37159 00007F5D 01                      	db	1			;AN000;number of subst
 37160 00007F5E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37161 00007F5F 00                      	db	0			;AN000;reserved
 37162 00007F60 [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37163 00007F62 0000                    	dw	0			;AN000;segment of arg
 37164 00007F64 01                      	db	1			;AN000;first subst
 37165 00007F65 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37166                                  					;AN000;binary to decimal
 37167 00007F66 05                      	db	5			;AN000;maximum width
 37168 00007F67 01                      	db	1			;AN000;minimum width
 37169 00007F68 20                      	db	blank ; 20h		;AN000;pad character
 37170                                  
 37171                                  ;  "Code page %1 not prepared for all devices",13,10
 37172                                  cp_not_all_ptr:
 37173 00007F69 FF03                    	dw	1023			;AN000;message number
 37174 00007F6B 01                      	db	1			;AN000;number of subst
 37175 00007F6C 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37176 00007F6D 00                      	db	0			;AN000;reserved
 37177 00007F6E [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37178 00007F70 0000                    	dw	0			;AN000;segment of arg
 37179 00007F72 01                      	db	1			;AN000;first subst
 37180 00007F73 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37181                                  					;AN000;binary to decimal
 37182 00007F74 05                      	db	5			;AN000;maximum width
 37183 00007F75 01                      	db	1			;AN000;minimum width
 37184 00007F76 20                      	db	blank ; 20h		;AN000;pad character
 37185                                  
 37186                                  ;  "Active code page: %1",13,10
 37187                                  cp_active_ptr:
 37188 00007F77 0004                    	dw	1024			;AN000;message number
 37189 00007F79 01                      	db	1			;AN000;number of subst
 37190 00007F7A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37191 00007F7B 00                      	db	0			;AN000;reserved
 37192 00007F7C [0B8C]                  	dw	system_cpage		;AN000;offset of arg
 37193 00007F7E 0000                    	dw	0			;AN000;segment of arg
 37194 00007F80 01                      	db	1			;AN000;first subst
 37195 00007F81 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37196                                  					;AN000;binary to decimal
 37197 00007F82 05                      	db	5			;AN000;maximum width
 37198 00007F83 01                      	db	1			;AN000;minimum width
 37199 00007F84 20                      	db	blank ; 20h		;AN000;pad character
 37200                                  
 37201                                  ;  "NLSFUNC not installed",13,10
 37202                                  NLSFUNC_PTR:
 37203 00007F85 0104                    	dw	1025			;AN000;message number
 37204 00007F87 00                      	db	no_subst ; 0		;AN000;number of subst
 37205                                  
 37206                                  ;  "Invalid code page",13,10
 37207                                  INV_CODE_PAGE:
 37208 00007F88 0204                    	dw	1026			;AN000;message number
 37209 00007F8A 00                      	db	no_subst ; 0		;AN000;number of subst
 37210                                  
 37211                                  ;  "Current drive is no longer valid"
 37212                                  BADCURDRV:
 37213 00007F8B 0304                    	dw	1027			;AN000;message number
 37214 00007F8D 00                      	db	no_subst ; 0		;AN000;number of subst
 37215                                  
 37216                                  ;  "Press any key to continue"
 37217                                  PAUSEMES_PTR:
 37218 00007F8E 0404                    	dw	1028			;AN000;message number
 37219 00007F90 00                      	db	no_subst ; 0		;AN000;number of subst
 37220                                  
 37221                                  ;  "Label not found",13,10
 37222                                  BADLAB_PTR:
 37223 00007F91 0504                    	dw	1029			;AN000;message number
 37224 00007F93 00                      	db	no_subst ; 0		;AN000;number of subst
 37225                                  
 37226                                  ;  "Syntax error",13,10
 37227                                  SYNTMES_PTR:
 37228 00007F94 0604                    	dw	1030			;AN000;message number
 37229 00007F96 00                      	db	no_subst ; 0		;AN000;number of subst
 37230                                  
 37231                                  ;  "Invalid date",13,10
 37232                                  BADDAT_PTR:
 37233 00007F97 0704                    	dw	1031			;AN000;message number
 37234 00007F99 00                      	db	no_subst ; 0		;AN000;number of subst
 37235                                  
 37236                                  ;  "Current date is %1 %2",13,10
 37237                                  CurDat_Ptr:
 37238 00007F9A 0804                    	dw	1032			;AN000;message number
 37239 00007F9C 02                      	db	2			;AN000;number of subst
 37240 00007F9D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37241 00007F9E 00                      	db	0			;AN000;reserved
 37242 00007F9F [F692]                  	dw	Arg_Buf			;AN000;offset of arg
 37243 00007FA1 0000                    	dw	0			;AN000;segment of arg
 37244 00007FA3 01                      	db	1			;AN000;first subst
 37245 00007FA4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37246 00007FA5 03                      	db	3			;AN000;maximum width
 37247 00007FA6 03                      	db	3			;AN000;minimum width
 37248 00007FA7 20                       	db	blank ; 20h		;AN000;pad character
 37249 00007FA8 0B                      	db	parm_block_size 	;AN000;size of sublist
 37250 00007FA9 00                      	db	0			;AN000;reserved
 37251                                  CurDat_yr:
 37252 00007FAA 0000                    	dw	0			;AN000;year
 37253                                  CurDat_mo_day:
 37254 00007FAC 0000                    	dw	0			;AN000;month,day
 37255 00007FAE 02                      	db	2			;AN000;second subst
 37256 00007FAF 34                      	db	34h ; DATE_MDY_4	;AN000;date
 37257 00007FB0 0A                      	db	10			;AN000;maximum width
 37258 00007FB1 0A                      	db	10			;AN000;minimum width
 37259 00007FB2 20                      	db	blank ; 20h		;AN000;pad character
 37260                                  
 37261                                  ;  "SunMonTueWedThuFriSat"
 37262                                  WeekTab:
 37263 00007FB3 0904                    	dw	1033			;AN000;message number
 37264 00007FB5 00                      	db	no_subst ; 0		;AN000;number of subst
 37265                                  
 37266                                  ;  "Enter new date (%1):"
 37267                                  
 37268                                  NewDat_Ptr:
 37269 00007FB6 0A04                    	dw	1034			;AN000;message number
 37270 00007FB8 01                      	db	1			;AN000;number of subst
 37271 00007FB9 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37272 00007FBA 00                      	db	0			;AN000;reserved
 37273                                  NewDat_Format:
 37274 00007FBB 0000                    	dw	0			;AN000;offset of replacement
 37275 00007FBD 0000                    	dw	0			;AN000;segment of arg
 37276 00007FBF 01                      	db	1			;AN000;first subst
 37277 00007FC0 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37278 00007FC1 08                      	db	8			;AN000;maximum width
 37279 00007FC2 08                      	db	8			;AN000;minimum width
 37280 00007FC3 20                      	db	blank ; 20h		;AN000;pad character
 37281                                  
 37282                                  ;  "Invalid time",13,10
 37283                                  
 37284                                  BadTim_Ptr:
 37285 00007FC4 0B04                    	dw	1035			;AN000;message number
 37286 00007FC6 00                      	db	no_subst ; 0		;AN000;number of subst
 37287                                  
 37288                                  ;  "Current time is %1",13,10
 37289                                  CurTim_Ptr:
 37290 00007FC7 0C04                    	dw	1036			;AN000;message number
 37291 00007FC9 01                      	db	1			;AN000;number of subst
 37292 00007FCA 0B                      	db	parm_block_size 	;AN000;size of sublist
 37293 00007FCB 00                      	db	0			;AN000;reserved
 37294                                  CurTim_hr_min:
 37295 00007FCC 0000                    	dw	0			;AN000;hours,minutes
 37296                                  CurTim_Sec_hn:
 37297 00007FCE 0000                    	dw	0			;AN000;seconds,hundredths
 37298 00007FD0 01                      	db	1			;AN000;first subst
 37299 00007FD1 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 37300                                  					;AC059;time
 37301 00007FD2 0C                      	db	12			;AC059;maximum width
 37302 00007FD3 0C                      	db	12			;AC059;minimum width
 37303 00007FD4 20                      	db	blank ; 20h		;AN000;pad character
 37304                                  
 37305                                  ;  "Enter new time:"
 37306                                  NewTim_Ptr:
 37307 00007FD5 0D04                    	dw	1037			;AN000;message number
 37308 00007FD7 00                      	db	no_subst ; 0		;AN000;number of subst
 37309                                  
 37310                                  ;  ",    Delete (Y/N)?",13,10
 37311                                  Del_Y_N_Ptr:
 37312 00007FD8 0E04                    	dw	1038			;AN000;message number
 37313 00007FDA 00                      	db	no_subst ; 0		;AN000;number of subst
 37314                                  
 37315                                  ;  "All files in directory will be deleted!",13,10
 37316                                  ;  "Are you sure (Y/N)?",13,10
 37317                                  SureMes_Ptr:
 37318 00007FDB 0F04                    	dw	1039			;AN000;message number
 37319 00007FDD 00                      	db	no_subst ; 0		;AN000;number of subst
 37320                                  
 37321                                  ;  "Microsoft DOS Version %1.%2",13,10
 37322                                  VerMes_Ptr:
 37323 00007FDE 1004                    	dw	1040			;AN000;message number
 37324 00007FE0 02                      	db	2			;AN000;number of subst
 37325 00007FE1 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37326 00007FE2 00                      	db	0			;AN000;reserved
 37327 00007FE3 [1C8C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 37328 00007FE5 0000                    	dw	0			;AN000;segment of arg
 37329 00007FE7 01                      	db	1			;AN000;first subst
 37330 00007FE8 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37331                                  					;AN000;binary to decimal
 37332 00007FE9 01                      	db	1			;AN000;maximum width
 37333 00007FEA 01                      	db	1			;AN000;minimum width
 37334 00007FEB 20                      	db	blank ; 20h		;AN000;pad character
 37335 00007FEC 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37336 00007FED 00                      	db	0			;AN000;reserved
 37337 00007FEE [1E8C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 37338 00007FF0 0000                    	dw	0			;AN000;segment of arg
 37339 00007FF2 02                      	db	2			;AN000;second subst
 37340 00007FF3 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37341                                  					;AN000;binary to decimal
 37342 00007FF4 02                      	db	2			;AN000;maximum width
 37343 00007FF5 02                      	db	2			;AN000;minimum width
 37344 00007FF6 30                      	db	'0' ; 30h		;AN000;pad character
 37345                                  
 37346                                  ;  "Volume in drive %1 has no label",13,10
 37347                                  VolMes_Ptr_2:
 37348 00007FF7 1104                    	dw	1041			;AN000;message number
 37349 00007FF9 01                      	db	1			;AN000;number of subst
 37350 00007FFA 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37351 00007FFB 00                      	db	0			;AN000;reserved
 37352 00007FFC [228C]                  	dw	vol_drv			;AN000;offset of drive
 37353 00007FFE 0000                    	dw	0			;AN000;segment of arg
 37354 00008000 01                      	db	1			;AN000;first subst
 37355 00008001 00                      	db	0 ; Char_field_Char 	;AN000;character
 37356 00008002 80                      	db	128			;AN000;maximum width
 37357 00008003 01                      	db	1			;AN000;minimum width
 37358 00008004 20                      	db	blank ; 20h		;AN000;pad character
 37359                                  
 37360                                  ;  "Volume in drive %1 is %2",13,10
 37361                                  VolMes_Ptr:
 37362 00008005 1204                    	dw	1042			;AN000;message number
 37363 00008007 02                      	db	2			;AN000;number of subst
 37364 00008008 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37365 00008009 00                      	db	0			;AN000;reserved
 37366 0000800A [228C]                  	dw	vol_drv			;AN000;offset of drive
 37367 0000800C 0000                    	dw	0			;AN000;segment of arg
 37368 0000800E 01                      	db	1			;AN000;first subst
 37369 0000800F 00                      	db	00000000b		;AN000;character
 37370 00008010 80                      	db	128			;AN000;maximum width
 37371 00008011 01                      	db	1			;AN000;minimum width
 37372 00008012 20                      	db	blank ; 20h		;AN000;pad character
 37373 00008013 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37374 00008014 00                      	db	0			;AN000;reserved
 37375 00008015 [DB8A]                  	dw	CHARBUF			;AN000;offset of string
 37376 00008017 0000                    	dw	0			;AN000;segment of arg
 37377 00008019 02                      	db	2			;AN000;second subst
 37378 0000801A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37379 0000801B 80                      	db	128			;AN000;maximum width
 37380 0000801C 01                      	db	1			;AN000;minimum width
 37381 0000801D 20                      	db	blank ; 20h		;AN000;pad character
 37382                                  
 37383                                  ;  "Volume Serial Number is %1-%2",13,10
 37384                                  VolSerMes_Ptr:
 37385 0000801E 1304                    	dw	1043			;AN000;message number
 37386 00008020 02                      	db	2			;AN000;number of subst
 37387 00008021 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37388 00008022 00                      	db	0			;AN000;reserved
 37389 00008023 [7D8D]                  	dw	vol_serial+2		;AN000;offset of serial
 37390 00008025 0000                    	dw	0			;AN000;segment of arg
 37391 00008027 01                      	db	1			;AN000;first subst
 37392 00008028 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 37393                                  					;AN000;binary to hex
 37394 00008029 04                      	db	4			;AN000;maximum width
 37395 0000802A 04                      	db	4			;AN000;minimum width
 37396 0000802B 30                      	db	'0' ; 30h		;AN000;pad character
 37397 0000802C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37398 0000802D 00                      	db	0			;AN000;reserved
 37399 0000802E [7B8D]                  	dw	vol_serial		;AN000;offset of serial
 37400 00008030 0000                    	dw	0			;AN000;segment of arg
 37401 00008032 02                      	db	2			;AN000;second subst
 37402 00008033 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 37403                                  					;AN000;binary to hex
 37404 00008034 04                      	db	4			;AN000;maximum width
 37405 00008035 04                      	db	4			;AN000;minimum width
 37406 00008036 30                      	db	'0' ; 30h		;AN000;pad character
 37407                                  
 37408                                  ;  "Invalid directory",13,10
 37409                                  badcd_ptr:
 37410 00008037 1404                    	dw	1044			;AN000;message number
 37411 00008039 00                      	db	no_subst ; 0		;AN000;number of subst
 37412                                  
 37413                                  ;  "Unable to create directory",13,10
 37414                                  badmkd_ptr:
 37415 0000803A 1504                    	dw	1045			;AN000;message number
 37416 0000803C 00                      	db	no_subst ; 0		;AN000;number of subst
 37417                                  
 37418                                  ;  "Invalid path, not directory,",13,10
 37419                                  ;  "or directory not empty",13,10
 37420                                  badrmd_ptr:
 37421 0000803D 1604                    	dw	1046			;AN000;message number
 37422 0000803F 00                      	db	no_subst ; 0		;AN000;number of subst
 37423                                  
 37424                                  ;  "Must specify ON or OFF",13,10
 37425                                  bad_on_off_ptr:
 37426 00008040 1704                    	dw	1047			;AN000;message number
 37427 00008042 00                      	db	no_subst ; 0		;AN000;number of subst
 37428                                  
 37429                                  ;  "Directory of %1",13,10
 37430                                  dirhead_ptr:
 37431 00008043 1804                    	dw	1048			;AN000;message number
 37432 00008045 01                      	db	1			;AN000;number of subst
 37433 00008046 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37434 00008047 00                      	db	0			;AN000;reserved
 37435 00008048 [AA8B]                  	dw	BWDBUF			;AN000;offset of arg
 37436 0000804A 0000                    	dw	0			;AN000;segment of arg
 37437 0000804C 01                      	db	1			;AN000;first subst
 37438 0000804D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37439 0000804E 80                      	db	128			;AN000;maximum width
 37440 0000804F 00                      	db	0			;AN000;minimum width
 37441 00008050 20                      	db	blank ; 20h		;AN000;pad character
 37442                                  
 37443                                  ;  "No Path",13,10
 37444                                  NULLPATH_PTR:
 37445 00008051 1904                    	dw	1049			;AN000;message number
 37446 00008053 00                      	db	no_subst ; 0		;AN000;number of subst
 37447                                  
 37448                                  ;  "Invalid drive in search path",13,10
 37449                                  BADPMES_PTR:
 37450 00008054 1A04                    	dw	1050			;AN000;message number
 37451 00008056 00                      	db	no_subst ; 0		;AN000;number of subst
 37452                                  
 37453                                  ;  "Invalid device",13,10
 37454                                  BADDEV_PTR:
 37455 00008057 1B04                    	dw	1051			;AN000;message number
 37456 00008059 00                      	db	no_subst ; 0		;AN000;number of subst
 37457                                  
 37458                                  ;  "FOR cannot be nested",13,10
 37459                                  FORNESTMES_PTR:
 37460 0000805A 1C04                    	dw	1052			;AN000;message number
 37461 0000805C 00                      	db	no_subst ; 0		;AN000;number of subst
 37462                                  
 37463                                  ;  "Intermediate file error during pipe",13,10
 37464                                  PIPEEMES_PTR:
 37465 0000805D 1D04                    	dw	1053			;AN000;message number
 37466 0000805F 00                      	db	no_subst ; 0		;AN000;number of subst
 37467                                  
 37468                                  ;  "Cannot do binary reads from a device",13,10
 37469                                  INBDEV_PTR:
 37470 00008060 1E04                    	dw	1054			;AN000;message number
 37471 00008062 00                      	db	no_subst ; 0		;AN000;number of subst
 37472                                  
 37473                                  ;  "BREAK is %1",13,10
 37474                                  CtrlcMes_Ptr:
 37475 00008063 1F04                    	dw	1055			;AN000;message number
 37476 00008065 01                      	db	1			;AN000;number of subst
 37477 00008066 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37478 00008067 00                      	db	0			;AN000;reserved
 37479 00008068 0000                    	dw	0			;AN000;offset of on/off (new)
 37480 0000806A 0000                    	dw	0			;AN000;segment of arg
 37481 0000806C 01                      	db	1			;AN000;first subst
 37482 0000806D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37483 0000806E 80                      	db	128			;AN000;maximum width
 37484 0000806F 01                      	db	1			;AN000;minimum width
 37485 00008070 20                      	db	blank ; 20h		;AN000;pad character
 37486                                  
 37487                                  ;  "VERIFY is %1",13,10
 37488                                  VeriMes_Ptr:
 37489 00008071 2004                    	dw	1056			;AN000;message number
 37490 00008073 01                      	db	1			;AN000;number of subst
 37491 00008074 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37492 00008075 00                      	db	0			;AN000;reserved
 37493 00008076 0000                    	dw	0			;AN000;offset of on/off (new)
 37494 00008078 0000                    	dw	0			;AN000;segment of arg
 37495 0000807A 01                      	db	1			;AN000;first subst
 37496 0000807B 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37497 0000807C 80                      	db	128			;AN000;maximum width
 37498 0000807D 01                      	db	1			;AN000;minimum width
 37499 0000807E 20                      	db	blank ; 20h		;AN000;pad character
 37500                                  
 37501                                  ;  "ECHO is %1",13,10
 37502                                  EchoMes_Ptr:
 37503 0000807F 2104                    	dw	1057			;AN000;message number
 37504 00008081 01                      	db	1			;AN000;number of subst
 37505 00008082 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37506 00008083 00                      	db	0			;AN000;reserved
 37507 00008084 0000                    	dw	0			;AN000;offset of on/off (new)
 37508 00008086 0000                    	dw	0			;AN000;segment of arg
 37509 00008088 01                      	db	1			;AN000;first subst
 37510 00008089 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37511 0000808A 80                      	db	128			;AN000;maximum width
 37512 0000808B 01                      	db	1			;AN000;minimum width
 37513 0000808C 20                      	db	blank ; 20h		;AN000;pad character
 37514                                  
 37515                                  ;  "off"
 37516                                  OFFMES_PTR:
 37517 0000808D 2304                    	dw	1059			;AN000;message number
 37518 0000808F 00                      	db	no_subst		;AN000;number of subst
 37519                                  
 37520                                  ;  "on"
 37521                                  ONMES_PTR:
 37522 00008090 2404                    	dw	1060			;AN000;message number
 37523 00008092 00                      	db	no_subst ; 0		;AN000;number of subst
 37524                                  
 37525                                  ;  "Error writing to device",13,10
 37526                                  DEVWMES_PTR:
 37527 00008093 2504                    	dw	1061			;AN000;message number
 37528 00008095 00                      	db	no_subst ; 0		;AN000;number of subst
 37529                                  
 37530                                  ;  "Invalid path",13,10
 37531                                  INVAL_PATH_PTR:
 37532 00008096 2604                    	dw	1062			;AN000;message number
 37533 00008098 00                      	db	no_subst ; 0		;AN000;number of subst
 37534                                  
 37535                                  ;  unformatted string output
 37536                                  arg_buf_ptr:
 37537 00008099 2704                    	dw	1063			;AN000;message number
 37538 0000809B 01                      	db	1			;AN000;number of subst
 37539 0000809C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37540 0000809D 00                      	db	0			;AN000;reserved
 37541 0000809E [F692]                  	dw	Arg_Buf 		;AN000;offset of arg
 37542 000080A0 0000                    	dw	0			;AN000;segment of arg
 37543 000080A2 01                      	db	1			;AN000;first subst
 37544 000080A3 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37545 000080A4 80                      	db	128			;AN000;maximum width
 37546 000080A5 00                      	db	0			;AN000;minimum width
 37547 000080A6 20                      	db	blank ; 20h		;AN000;pad character
 37548                                  
 37549                                  ;  file name output
 37550                                  file_name_ptr:
 37551 000080A7 2804                    	dw	1064			;AN000;message number
 37552 000080A9 01                      	db	1			;AN000;number of subst
 37553 000080AA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37554 000080AB 00                      	db	0			;AN000;reserved
 37555 000080AC [908C]                  	dw	SrcBuf			;AN000;offset of arg
 37556 000080AE 0000                    	dw	0			;AN000;segment of arg
 37557 000080B0 01                      	db	1			;AN000;first subst
 37558 000080B1 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37559 000080B2 80                      	db	128			;AN000;maximum width
 37560 000080B3 00                      	db	0			;AN000;minimum width
 37561 000080B4 20                      	db	blank ; 20h		;AN000;pad character
 37562                                  
 37563                                  ;  file size output for dir
 37564                                  disp_file_size_ptr:
 37565 000080B5 2904                    	dw	1065			;AN000;message number
 37566 000080B7 01                      	db	1			;AN000;number of subst
 37567 000080B8 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37568 000080B9 00                      	db	0			;AN000;reserved
 37569 000080BA [0D8C]                  	dw	File_Size_Low		;AN000;offset of arg
 37570 000080BC 0000                    	dw	0			;AN000;segment of arg
 37571 000080BE 01                      	db	1			;AN000;first subst
 37572 000080BF B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37573                                  					;AN000;long binary to decimal
 37574 000080C0 0A                      	db	10			;AN000;maximum width
 37575 000080C1 0A                      	db	10			;AN000;minimum width
 37576 000080C2 20                      	db	blank ; 20h		;AN000;pad character
 37577                                  
 37578                                  ;  unformatted string output
 37579                                  ; %s
 37580                                  string_buf_ptr:
 37581 000080C3 2A04                    	dw	1066			;AN000;message number
 37582 000080C5 01                      	db	1			;AN000;number of subst
 37583 000080C6 0B                      	db	parm_block_size 	;AN000;size of sublist
 37584 000080C7 00                      	db	0			;AN000;reserved
 37585 000080C8 [118C]                  	dw	string_ptr_2		;AN000;offset of arg
 37586 000080CA 0000                    	dw	0			;AN000;segment of arg
 37587 000080CC 01                      	db	1			;AN000;first subst
 37588 000080CD 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37589 000080CE 80                      	db	128			;AN000;maximum width
 37590 000080CF 00                      	db	0			;AN000;minimum width
 37591 000080D0 20                      	db	blank ; 20h		;AN000;pad character
 37592 000080D1 00                      	db	0			;AN000;
 37593                                  
 37594                                  ;  tab character
 37595                                  tab_ptr:
 37596 000080D2 2B04                    	dw	1067			;AN000;message number
 37597 000080D4 00                      	db	no_subst ; 0		;AN000;number of subst
 37598                                  
 37599                                  ;  " <DIR>   "
 37600                                  dmes_ptr:
 37601 000080D5 2C04                    	dw	1068			;AN000;message number
 37602 000080D7 00                      	db	no_subst ; 0		;AN000;number of subst
 37603                                  
 37604                                  ;  destructive back space
 37605                                  dback_ptr:
 37606 000080D8 2D04                    	dw	1069			;AN000;message number
 37607 000080DA 00                      	db	no_subst ; 0		;AN000;number of subst
 37608                                  
 37609                                  ;  carriage return / line feed
 37610                                  acrlf_ptr:
 37611 000080DB 2E04                    	dw	1070			;AN000;message number
 37612 000080DD 00                      	db	no_subst ; 0		;AN000;number of subst
 37613                                  
 37614                                  ;  "mm-dd-yy"
 37615                                  usadat_ptr:
 37616 000080DE 3004                    	dw	1072			;AN000;message number
 37617 000080E0 00                      	db	no_subst ; 0		;AN000;number of subst
 37618                                  
 37619                                  ;  "dd-mm-yy"
 37620                                  eurdat_ptr:
 37621 000080E1 3104                    	dw	1073			;AN000;message number
 37622 000080E3 00                      	db	no_subst ; 0		;AN000;number of subst
 37623                                  
 37624                                  ;  "yy-mm-dd"
 37625                                  japdat_ptr:
 37626 000080E4 3204                    	dw	1074			;AN000;message number
 37627 000080E6 00                      	db	no_subst ; 0		;AN000;number of subst
 37628                                  
 37629                                  ;  date string for prompt
 37630                                  promptdat_ptr:
 37631 000080E7 3304                    	dw	1075			;AN000;message number
 37632 000080E9 02                      	db	2			;AN000;number of subst
 37633 000080EA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37634 000080EB 00                      	db	0			;AN000;reserved
 37635 000080EC [F692]                  	dw	Arg_Buf			;AN000;offset of arg
 37636 000080EE 0000                    	dw	0			;AN000;segment of arg
 37637 000080F0 01                      	db	1			;AN000;first subst
 37638 000080F1 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37639 000080F2 03                      	db	3			;AN000;maximum width
 37640 000080F3 03                      	db	3			;AN000;minimum width
 37641 000080F4 20                       	db	blank ; 20h		;AN000;pad character
 37642 000080F5 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37643 000080F6 00                      	db	0			;AN000;reserved
 37644                                  promptDat_yr:
 37645 000080F7 0000                    	dw	0			;AN000;year
 37646                                  promptDat_moday:
 37647 000080F9 0000                    	dw	0			;AN000;month,day
 37648 000080FB 02                      	db	2			;AN000;second subst
 37649 000080FC 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37650 000080FD 0A                      	db	10			;AN000;maximum width
 37651 000080FE 08                      	db	8			;AN000;minimum width
 37652 000080FF 20                      	db	blank ; 20h		;AN000;pad character
 37653                                  
 37654                                  ;  Time for prompt
 37655                                  promtim_ptr:
 37656 00008100 3404                    	dw	1076			;AN000;message number
 37657 00008102 01                      	db	1			;AN000;number of subst
 37658 00008103 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37659 00008104 00                      	db	0			;AN000;reserved
 37660                                  PromTim_hr_min:
 37661 00008105 0000                    	dw	0			;AN000;hours,minutes
 37662                                  PromTim_Sec_hn:
 37663 00008107 0000                    	dw	0			;AN000;seconds,hundredths
 37664 00008109 01                      	db	1			;AN000;first subst
 37665 0000810A A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37666                                  					;AC013;time
 37667 0000810B 0B                      	db	11			;AN000;maximum width
 37668 0000810C 0B                      	db	11			;AC013;minimum width
 37669 0000810D 20                      	db	blank ; 20h		;AN000;pad character
 37670                                  
 37671                                  ;  Date and time for DIR
 37672                                  dirdattim_ptr:
 37673 0000810E 3504                    	dw	1077			;AN000;message number
 37674 00008110 02                      	db	2			;AN000;number of subst
 37675 00008111 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37676 00008112 00                      	db	0			;AN000;reserved
 37677                                  DirDat_Yr:
 37678 00008113 0000                    	dw	0			;AN000;year
 37679                                  DirDat_Mo_Day:
 37680 00008115 0000                    	dw	0			;AN000;month,day
 37681 00008117 01                      	db	1			;AN000;first subst
 37682 00008118 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37683                                  					;AN000;date
 37684 00008119 0A                      	db	10			;AN000;maximum width
 37685 0000811A 08                      	db	8			;AN000;minimum width
 37686 0000811B 20                      	db	blank ; 20h		;AN000;pad character
 37687 0000811C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37688 0000811D 00                      	db	0			;AN000;reserved
 37689                                  DirTim_Hr_Min:
 37690 0000811E 0000                    	dw	0			;AN000;hours,minutes
 37691                                  DirTim_Sec_hn:
 37692 00008120 0000                    	dw	0			;AN000;seconds,hundredths
 37693 00008122 02                      	db	2			;AN000;second subst
 37694 00008123 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37695                                  					;AN000;time
 37696 00008124 06                      	db	6			;AN000;maximum width
 37697 00008125 06                      	db	6			;AN000;minimum width
 37698 00008126 20                      	db	blank ; 20h		;AN000;pad character
 37699                                  
 37700                                  ;  "Directory already exists"
 37701                                  MD_EXISTS_PTR:
 37702 00008127 3604                    	dw	1078			;AN000;message number
 37703 00008129 00                      	db	no_subst		;AN000;number of subst
 37704                                  
 37705                                  ;  "%1 bytes",13,10
 37706                                  bytes_ptr:
 37707 0000812A 3704                    	dw	1079			; message number
 37708 0000812C 01                      	db	1			; number of subst
 37709 0000812D 0B                              db	parm_block_size ; 11	; size of sublist
 37710 0000812E 00                              db	0			; reserved
 37711 0000812F [CF8A]                          dw	FileSiz			; offset of arg
 37712 00008131 0000                            dw	0			; segment of arg
 37713 00008133 01                              db	1			; first subst
 37714 00008134 B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37715                                  					; long binary to decimal
 37716 00008135 0A                              db	10			; maximum width
 37717 00008136 0A                              db	10			; minimum width
 37718 00008137 20                              db	blank ; 20h		; pad character
 37719                                  
 37720                                  ;  "Total:",13,10
 37721                                  total_ptr:
 37722 00008138 3804                    	dw	1080			; message number
 37723 0000813A 00                      	db	no_subst ; 0		; number of subst
 37724                                  
 37725                                  ;  "Error parsing environment variable:",13,10
 37726                                  errparsenv_ptr:
 37727 0000813B 3904                    	dw	1081			; message number
 37728 0000813D 00                      	db	no_subst ; 0		; number of subst
 37729                                  
 37730                                  ;  "(continuing %1)",13,10
 37731                                  dircont_ptr:
 37732 0000813E 3C04                    	dw	1084			;AN000;message number
 37733 00008140 01                      	db	1			;AN000;number of subst
 37734 00008141 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37735 00008142 00                      	db	0			;AN000;reserved
 37736 00008143 [AA8B]                  	dw	BWDBUF			;AN000;offset of arg
 37737 00008145 0000                    	dw	0			;AN000;segment of arg
 37738 00008147 01                      	db	1			;AN000;first subst
 37739 00008148 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37740 00008149 80                      	db	128			;AN000;maximum width
 37741 0000814A 00                      	db	0			;AN000;minimum width
 37742 0000814B 20                      	db	blank ; 20h		;AN000;pad character
 37743                                  
 37744                                  ;  "Revision %1",CR,LF
 37745                                  dosrev_ptr:
 37746 0000814C 4204                    	dw	1090
 37747 0000814E 01                      	db	1			; one substitution
 37748 0000814F 0B                      	db	parm_block_size ; 11
 37749 00008150 00                      	db	0
 37750 00008151 [208C]                  	dw	One_Char_Val		; ptr to char
 37751 00008153 0000                    	dw	0			; segment addr?
 37752 00008155 01                      	db	1			; 1st substitution
 37753 00008156 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37754 00008157 01                      	db	1			; max width
 37755 00008158 01                      	db	1			; min width
 37756 00008159 20                      	db	blank ; 20h		; pad char
 37757                                  
 37758                                  ;  "DOS is in ROM"
 37759                                  DosRom_Ptr:
 37760 0000815A 4304                    	dw	1091
 37761 0000815C 00                      	db	no_subst ; 0		
 37762                                  
 37763                                  ;  "DOS is in HMA"
 37764                                  DosHma_Ptr:
 37765 0000815D 4404                    	dw	1092
 37766 0000815F 00                      	db	no_subst ; 0		
 37767                                  
 37768                                  ;  "DOS is in low memory"
 37769                                  DosLow_Ptr:
 37770 00008160 4504                    	dw	1093
 37771 00008162 00                      	db	no_subst ; 0		
 37772                                  
 37773                                  ;  "Cannot Loadhigh batch file" ;M016
 37774                                  NoExecBat_Ptr:
 37775 00008163 4604                    	dw	1094			; M016
 37776 00008165 00                      	db	no_subst ; 0		; M016
 37777                                  
 37778                                  ;  "LoadHigh: Invalid filename" ; M016
 37779                                  LhInvFil_Ptr:
 37780 00008166 4704                    	dw	1095			; M016
 37781 00008168 00                      	db	no_subst ; 0		; M016
 37782                                  
 37783                                  ;  "Could not open specified country information file" ; M045
 37784                                  NoCntry_Ptr:
 37785 00008169 4804                    	dw	1096			; M045
 37786 0000816B 00                      	db	no_subst ; 0		; M045
 37787                                  
 37788                                  ; 15/04/2023
 37789                                  ; MSDOS 6.0 COMMAND.COM only !
 37790                                  %if 0
 37791                                  
 37792                                  ;* The next four errors emulate those reported by the normal parse
 37793                                  ;  mechanism, with a little more accurate wording; that parser has been
 37794                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37795                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37796                                  ;  parser, so they've been added here.
 37797                                  
 37798                                  ;  "LoadHigh: Invalid argument"
 37799                                  LhInvArg_Ptr:
 37800                                  	dw	1097
 37801                                  	db	no_subst ; 0		
 37802                                  
 37803                                  ;  "Required parameter missing"
 37804                                  ReqParmMiss:
 37805                                  	dw	1098
 37806                                  	db	no_subst ; 0		
 37807                                  
 37808                                  ;  "Unrecognized switch"
 37809                                  LhInvSwt_Ptr:
 37810                                  	dw	1099
 37811                                  	db	no_subst ; 0		
 37812                                  
 37813                                  ;  "A bad UMB number has been specified"
 37814                                  LhBadUMB_Ptr:
 37815                                  	dw	1100
 37816                                  	db	no_subst ; 0
 37817                                  %endif		
 37818                                  
 37819                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37820                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37821                                  ; ---------------------------------------------------------------------------
 37822                                  
 37823                                  PATH_TEXT:
 37824 0000816C 504154483D              	db	"PATH="
 37825                                  PROMPT_TEXT:
 37826 00008171 50524F4D50543D          	db	"PROMPT="
 37827                                  COMSPECSTR:
 37828 00008178 434F4D535045433D        	db	"COMSPEC="
 37829                                  DirEnvVar:
 37830 00008180 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37831                                  
 37832                                  ; 15/04/2023
 37833                                  %if 0
 37834                                  
 37835                                  ;============================================================================
 37836                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37837                                  ;============================================================================
 37838                                  ; 30/09/2018 - Retro DOS v3.0
 37839                                  
 37840                                  ; TITLE	COMMAND Transient Initialized DATA
 37841                                  
 37842                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37843                                  ;initial values at the beginning of each command cycle. It is
 37844                                  ;included in the transient checksum area. If values in TRANDATA
 37845                                  ;change, the transient will be reloaded for the next command cycle.
 37846                                  
 37847                                  align 16
 37848                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37849                                  
 37850                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37851                                  _3740h:		db '%S',0
 37852                                  ARG_BUF_PTR:	dw _3740h
 37853                                  		dw _3747h
 37854                                  _3747h:		dw ARG_BUF ; _43E8h
 37855                                  _3749h:		db '%S ',0
 37856                                  STRINGBUF1PTR:	dw _3749h
 37857                                  		dw STRING_PTR_1 ; _4468h
 37858                                  _3751h:		db '%9ld',0
 37859                                  FSIZEMESPTR:	dw _3751h
 37860                                  		dw FILESIZE_L ; _446Ah
 37861                                  		dw FILESIZE_H ; _446Ch
 37862                                  _375Ch:		db '%S',0
 37863                                  STRINGBUF2PTR:	dw _375Ch
 37864                                  		dw STRING_PTR_2 ; _446Eh
 37865                                  _3763h:		db 9,0
 37866                                  TABPTR:		dw _3763h
 37867                                  _3767h:		db 0Dh,0Ah
 37868                                  		db 'Batch file missing',0Dh,0Ah,0
 37869                                  BADPATHPTR:	dw _3767h
 37870                                  _3780h:		db 0Dh,0Ah
 37871                                  		db 'Insert disk with batch file',0Dh,0Ah
 37872                                  		db 'and press any key when ready',0Dh,0Ah,0
 37873                                  INSERTDSKPTR:	dw _3780h
 37874                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37875                                  BADNAMPTR:	dw _37C0h
 37876                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37877                                  RENERRPTR:	dw _37DDh
 37878                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37879                                  FNOTFOUNDPTR:	dw _3807h
 37880                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37881                                  PNOTFOUNDPTR:	dw _381Ah
 37882                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37883                                  ACCDENPTR:	dw _382Dh
 37884                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37885                                  NOSPACEPTR:	dw _383Fh
 37886                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37887                                  ENVERRPTR:	dw _385Bh
 37888                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37889                                  FULDIRPTR:	dw 3878h
 37890                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37891                                  OVERWRPTR:	dw _3890h
 37892                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37893                                  LOSTERRPTR:	dw _38B6h
 37894                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37895                                  INORNOTPTR:	dw _38E2h
 37896                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37897                                  COPIEDPTR:	dw _3909h
 37898                                  		dw COPY_NUM ; _4470h
 37899                                  _3922h:		db '%9d File(s) ',0
 37900                                  DIRMESPTR:	dw _3922h
 37901                                  		dw DIR_NUM  ; _4477h
 37902                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37903                                  BYTEMESPTR:	dw _3933h
 37904                                  		dw BYTES_FREE   ; _4479h
 37905                                  		dw BYTES_FREE+2 ; _447Bh
 37906                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37907                                  BADDRVPTR:	dw _394Bh
 37908                                  _396Bh:		db 0Dh,0Ah
 37909                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37910                                  CPNOTSETPTR:	dw _396Bh
 37911                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37912                                  _3999h:		db 0Dh,0Ah
 37913                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37914                                  CPNOTALLPTR:	dw _3999h
 37915                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37916                                  _39CCh:		db 0Dh,0Ah
 37917                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37918                                  CPACTIVEPTR:	dw _39CCh
 37919                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37920                                  _39EAh:		db 'Current drive is no longer valid',0
 37921                                  BADCURDRVPTR:	dw _39EAh
 37922                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37923                                  PAUSEMESPTR:	dw _3A0Dh
 37924                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37925                                  BADPARMPTR:	dw _3A2Eh
 37926                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37927                                  _3A59h:		db 0Dh,0Ah
 37928                                  		db 'Invalid date',0
 37929                                  BADDATPTR:	dw _3A59h
 37930                                  _3A6Ah:		db 'Current date is ',0
 37931                                  CURDATPTR:	dw _3A6Ah
 37932                                  _3A7Dh:		db 0Dh,0Ah
 37933                                  		db 'Enter new date ',0
 37934                                  NEWDATPTR:	dw _3A7Dh
 37935                                  _3A91h:		db '(mm-dd-yy): ',0
 37936                                  USADATPTR:	dw _3A91h
 37937                                  _3AA0h:		db '(dd-mm-yy): ',0
 37938                                  EURDATPTR:	dw _3AA0h
 37939                                  _3AAFh:		db '(yy-mm-dd): ',0
 37940                                  JAPDATPTR:	dw _3AAFh
 37941                                  _3ABEh:		db 0Dh,0Ah
 37942                                  		db 'Invalid time ',0
 37943                                  BADTIMPTR:	dw _3ABEh
 37944                                  _3AD0h:		db 'Current time is ',0
 37945                                  CURTIMPTR:	dw _3AD0h
 37946                                  _3AE3h:		db 0Dh,0Ah
 37947                                  		db 'Enter new time: ',0
 37948                                  NEWTIMPTR:	dw _3AE3h
 37949                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37950                                  SUREMESPTR:	dw _3AF8h
 37951                                  _3B0Eh:		db ' <DIR>   ',0
 37952                                  DMESPTR:	dw _3B0Eh
 37953                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37954                                  VERMESPTR:	dw _3B1Ah
 37955                                  		dw MAJOR_VER_NUM ; _447Dh
 37956                                  		dw MINOR_VER_NUM ; _447Fh
 37957                                  _3B4Dh:		db '%C',0
 37958                                  ONECHRVALPTR:	dw _3B4Dh
 37959                                  		dw ONE_CHAR_VAL	; _4481h
 37960                                  _3B54h:		db ' Volume in drive %c %s',0
 37961                                  VOLMESPTR:	dw _3B54h
 37962                                  		dw VOL_DRV ; _4484h
 37963                                  		dw VOLNAME_ADDR ; _4482h
 37964                                  IS:		db 'is ',0
 37965                                  NOVOL:		db 'has no label',0
 37966                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37967                                  BADCDPTR:	dw _3B82h
 37968                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37969                                  BADMKDPTR:	dw _3B98h
 37970                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37971                                  		db 'or directory not empty',0Dh,0Ah,0
 37972                                  BADRMDPTR:	dw _3BB7h
 37973                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37974                                  BADONOFFPTR:	dw _3BF0h
 37975                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37976                                  DIRHEADPTR:	dw _3C0Bh
 37977                                  		dw VOL_DIR ; _4485h
 37978                                  _3C23h:		db 'No Path',0
 37979                                  NULLPATHPTR:	dw _3C23h
 37980                                  PATH_TEXT:	db 'PATH='
 37981                                  PROMPT_TEXT:	db 'PROMPT='
 37982                                  COMSPEC_TEXT:	db 'COMSPEC='
 37983                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37984                                  BADPMESPTR:	dw _3C41h
 37985                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37986                                  BADDEVPTR:	dw _3C62h
 37987                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37988                                  BADLABPTR:	dw _3C75h
 37989                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37990                                  SYNTMESPTR:	dw _3C89h
 37991                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37992                                  FORNESTMESTR:	dw _3C9Ah
 37993                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37994                                  INSFMEMMESPTR:	dw _3CB4h
 37995                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37996                                  PIPEEMESPTR:	dw _3CCCh
 37997                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37998                                  INBDEVPTR:	dw _3CF4h
 37999                                  _3D1Dh:		db 'BREAK is ',0
 38000                                  CTRLMESPTR:	dw _3D1Dh
 38001                                  _3D29h:		db 'VERIFY is ',0
 38002                                  VERIMESPTR:	dw _3D29h
 38003                                  _3D36h:		db 'ECHO is ',0
 38004                                  ECHOMESPTR:	dw _3D36h
 38005                                  _3D41h:		db 'off',0Dh,0Ah,0
 38006                                  OFFMESPTR:	dw _3D41h
 38007                                  _3D49h:		db 'on',0Dh,0Ah,0
 38008                                  ONMESPTR:	dw _3D49h
 38009                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 38010                                  BADCPMESPTR:	dw _3D50h
 38011                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 38012                                  BADARGSPTR:	dw _3D6Eh
 38013                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 38014                                  DEVWMESPTR:	dw _3D8Fh
 38015                                  _3DABh:		db 0Dh,0Ah,0
 38016                                  ACRLFPTR:	dw _3DABh
 38017                                  _3DB0h:		db 8
 38018                                  		db 20h
 38019                                  		db 8
 38020                                  		db 0
 38021                                  DBACKPTR:	dw _3DB0h
 38022                                  small_y:	db 'y'
 38023                                  small_n:	db 'n'
 38024                                  CAPITAL_Y:	db 'Y'
 38025                                  CAPITAL_N:	db 'N'
 38026                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 38027                                  PROMPT_TABLE:
 38028                                  		db 'B' ; 42h
 38029                                  		dw PRINT_B
 38030                                  		db 'D' ; 44h
 38031                                  		dw PRINT_DATE
 38032                                  		db 'E' ; 45h
 38033                                  		dw PRINT_ESC
 38034                                  		db 'G' ; 47h
 38035                                  		dw PRINT_G
 38036                                  		db 'H' ; 48h
 38037                                  		dw PRINT_BACK
 38038                                  		db 'L' ; 4Ch
 38039                                  		dw PRINT_L
 38040                                  		db 'N' ; 4Eh
 38041                                  		dw PRINT_DRIVE
 38042                                  		db 'P' ; 50h
 38043                                  		dw BUILD_DIR_FOR_PROMPT
 38044                                  		db 'Q' ; 51h
 38045                                  		dw PRINT_EQ
 38046                                  		db 'T' ; 54h
 38047                                  		dw PRINT_TIME
 38048                                  		db 'V' ; 56h
 38049                                  		dw PRINT_VERSION
 38050                                  		db '_' ; 5Fh
 38051                                  		dw CRLF2
 38052                                  		db '$' ; 24h
 38053                                  		dw PRINT_CHAR
 38054                                  		db 0
 38055                                  
 38056                                  		; Table of IF conditionals
 38057                                  IFTAB:
 38058                                  		db 3	; First byte is count
 38059                                  		db 'NOT'
 38060                                  		dw IFNOT
 38061                                  		db 10
 38062                                  		db 'ERRORLEVEL'
 38063                                  		dw IFERLEV
 38064                                  		db 5
 38065                                  		db 'EXIST'
 38066                                  		dw IFEXISTS
 38067                                  		db 0
 38068                                  
 38069                                  		; Table for internal command names
 38070                                  
 38071                                  COMTAB:		db 3
 38072                                  		db 'DIR'
 38073                                  		db 3
 38074                                  		dw CATALOG
 38075                                  		db 4
 38076                                  		db 'CALL'
 38077                                  		db 2
 38078                                  		dw _$CALL
 38079                                  		db 4
 38080                                  		db 'CHCP'
 38081                                  		db 2
 38082                                  		dw CHCP
 38083                                  		db 6
 38084                                  		db 'RENAME'
 38085                                  		db 1
 38086                                  		dw CRENAME
 38087                                  		db 3
 38088                                  		db 'REN'
 38089                                  		db 1
 38090                                  		dw CRENAME
 38091                                  		db 5
 38092                                  		db 'ERASE'
 38093                                  		db 1
 38094                                  		dw ERASE
 38095                                  		db 3
 38096                                  		db 'DEL'
 38097                                  		db 1
 38098                                  		dw ERASE
 38099                                  		db 4
 38100                                  		db 'TYPE'
 38101                                  		db 1
 38102                                  		dw TYPEFIL
 38103                                  		db 3
 38104                                  		db 'REM'
 38105                                  		db 2
 38106                                  		dw TCOMMAND
 38107                                  		db 4
 38108                                  		db 'COPY'
 38109                                  		db 3
 38110                                  		dw COPY
 38111                                  		db 5
 38112                                  		db 'PAUSE'
 38113                                  		db 2
 38114                                  		dw PAUSE
 38115                                  		db 4
 38116                                  		db 'DATE'
 38117                                  		db 2
 38118                                  		dw DATE
 38119                                  		db 4
 38120                                  		db 'TIME'
 38121                                  		db 0
 38122                                  		dw CTIME
 38123                                  		db 3
 38124                                  		db 'VER'
 38125                                  		db 0
 38126                                  		dw VERSION
 38127                                  		db 3
 38128                                  		db 'VOL'
 38129                                  		db 1
 38130                                  		dw VOLUME
 38131                                  		db 2
 38132                                  		db 'CD'
 38133                                  		db 1
 38134                                  		dw _$CHDIR
 38135                                  		db 5
 38136                                  		db 'CHDIR'
 38137                                  		db 1
 38138                                  		dw _$CHDIR
 38139                                  		db 2
 38140                                  		db 'MD'
 38141                                  		db 1
 38142                                  		dw _$MKDIR
 38143                                  		db 5
 38144                                  		db 'MKDIR'
 38145                                  		db 1
 38146                                  		dw _$MKDIR
 38147                                  		db 2
 38148                                  		db 'RD'
 38149                                  		db 1
 38150                                  		dw _$RMDIR
 38151                                  		db 5
 38152                                  		db 'RMDIR'
 38153                                  		db 1
 38154                                  		dw _$RMDIR
 38155                                  		db 5
 38156                                  		db 'BREAK'
 38157                                  		db 0
 38158                                  		dw CNTRLC
 38159                                  		db 6
 38160                                  		db 'VERIFY'
 38161                                  		db 0
 38162                                  		dw VERIFY
 38163                                  		db 3
 38164                                  		db 'SET'
 38165                                  		db 2
 38166                                  		dw ADD_NAME_TO_ENVIRONMENT
 38167                                  		db 6
 38168                                  		db 'PROMPT'
 38169                                  		db 2
 38170                                  		dw ADD_PROMPT
 38171                                  		db 4
 38172                                  		db 'PATH'
 38173                                  		db 2
 38174                                  		dw PATH
 38175                                  		db 4
 38176                                  		db 'EXIT'
 38177                                  		db 0
 38178                                  		dw _$EXIT
 38179                                  		db 4
 38180                                  		db 'CTTY'
 38181                                  		db 3
 38182                                  		dw CTTY
 38183                                  		db 4
 38184                                  		db 'ECHO'
 38185                                  		db 2
 38186                                  		dw _ECHO
 38187                                  		db 4
 38188                                  		db 'GOTO'
 38189                                  		db 2
 38190                                  		dw _GOTO
 38191                                  		db 5
 38192                                  		db 'SHIFT'
 38193                                  		db 2
 38194                                  		dw _SHIFT
 38195                                  		db 2
 38196                                  		db 'IF'
 38197                                  		db 2
 38198                                  		dw _$IF
 38199                                  		db 3
 38200                                  		db 'FOR'
 38201                                  		db 2
 38202                                  		dw _$FOR
 38203                                  		db 3
 38204                                  		db 'CLS'
 38205                                  		db 0
 38206                                  		dw CLS
 38207                                  		db 0
 38208                                  
 38209                                  CAPITAL_A:	db 'A'
 38210                                  VBAR:		db '|'
 38211                                  LABRACKET:	db '<' ; 3Ch
 38212                                  RABRACKET:	db '>' ; 3Eh
 38213                                  DOLLAR:		db '$'
 38214                                  LPAREN:		db '('
 38215                                  RPAREN:		db ')'
 38216                                  NULLRPAREN:	db ')' ; 29h
 38217                                  		db 0
 38218                                  IN_WORD:	db 'I','N'
 38219                                  DO_WORD	:	db 'D','O'
 38220                                  STAR:		db '*'
 38221                                  CHAR_SUB:	db '-' 
 38222                                  PLUS_CHR:	db '+'
 38223                                  CHAR_L:		db 'L'
 38224                                  char_l:		db 'l'
 38225                                  small_a:	db 'a'
 38226                                  small_z:	db 'z'
 38227                                  CHAR_D:		db 'D'
 38228                                  CHAR_C:		db 'C'
 38229                                  CHAR_S:		db 'S'
 38230                                  CHAR_X:		db 'X'
 38231                                  DOT_CHR:	db '.' 
 38232                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 38233                                  		db ','
 38234                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 38235                                  MNCHR:		db 'p'
 38236                                  SYSTEM_CPAGE:	db 0
 38237                                  		db 0
 38238                                  
 38239                                  COMEXT:		db '.COM'
 38240                                  EXEEXT:		db '.EXE'
 38241                                  BATEXT:		db '.BAT'
 38242                                  SWITCH_LIST:	db 'VBAPW'
 38243                                  BATBUFLEN:	dw BATLEN ; 32
 38244                                  
 38245                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 38246                                  
 38247                                  TRANDATAEND:
 38248                                  
 38249                                  %endif
 38250                                  
 38251                                  ;============================================================================
 38252                                  ; TDATA.ASM, MSDOS 6.0, 1991
 38253                                  ;============================================================================
 38254                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38255                                  
 38256                                  	; 15/04/2023
 38257 00008187 00                      	db	0
 38258                                  align 2
 38259                                  
 38260                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 38261                                  ; ---------------------------------------------------------------------------
 38262 00008188 00                      	db 0
 38263                                  ; Lists of help message numbers for internal commands and /?
 38264                                  
 38265                                  ;;NoHelpMsgs:
 38266 00008189 B0040000                	dw	1200,0		;M014
 38267                                  BreakHelpMsgs:
 38268 0000818D 14050000                	dw	1300,0
 38269                                  ChcpHelpMsgs:
 38270 00008191 280529050000            	dw	1320,1321,0
 38271                                  CdHelpMsgs:
 38272 00008197 3C053D053E050000        	dw	1340,1341,1342,0
 38273                                  ClsHelpMsgs:
 38274 0000819F 50050000                	dw	1360,0
 38275                                  CopyHelpMsgs:
 38276 000081A3 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 38276 000081AC 050000             
 38277                                  CttyHelpMsgs:
 38278 000081AF 8C050000                	dw	1420,0
 38279                                  DateHelpMsgs:
 38280 000081B3 A005A1050000            	dw	1440,1441,0
 38281                                  DelHelpMsgs:
 38282 000081B9 B405B505B6050000        	dw	1460,1461,1462,0
 38283                                  DirHelpMsgs:
 38284 000081C1 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 38284 000081CA 05CD05CE05CF05D005 
 38285                                  	; MSDOS 6.0 COMMAND.COM
 38286                                  	;dw	1489,1490,1491,1492
 38287 000081D3 0000                    	dw	0
 38288                                  ExitHelpMsgs:
 38289 000081D5 DC050000                	dw	1500,0
 38290                                  MdHelpMsgs:
 38291 000081D9 F0050000                	dw	1520,0
 38292                                  PathHelpMsgs:
 38293 000081DD 0406050606060000        	dw	1540,1541,1542,0
 38294                                  PromptHelpMsgs:
 38295 000081E5 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 38295 000081EE 061D061E061F062006-
 38295 000081F7 0000               
 38296                                  RdHelpMsgs:
 38297 000081F9 2C060000                	dw	1580,0
 38298                                  RenHelpMsgs:
 38299 000081FD 4006410642060000        	dw	1600,1601,1602,0
 38300                                  SetHelpMsgs:
 38301 00008205 5406550656060000        	dw	1620,1621,1622,0
 38302                                  TimeHelpMsgs:
 38303 0000820D 680669060000            	dw	1640,1641,0
 38304                                  TypeHelpMsgs:
 38305 00008213 7C060000                	dw	1660,0
 38306                                  VerHelpMsgs:
 38307 00008217 90060000                	dw	1680,0
 38308                                  VerifyHelpMsgs:
 38309 0000821B A4060000                	dw	1700,0
 38310                                  VolHelpMsgs:
 38311 0000821F B8060000                	dw	1720,0
 38312                                  CallHelpMsgs:
 38313 00008223 CC06CD060000            	dw	1740,1741,0	;M014
 38314                                  RemHelpMsgs:
 38315 00008229 E0060000                	dw	1760,0		;M014
 38316                                  PauseHelpMsgs:
 38317 0000822D F4060000                	dw	1780,0		;M014
 38318                                  EchoHelpMsgs:
 38319 00008231 080709070000            	dw	1800,1801,0	;M014
 38320                                  GotoHelpMsgs:
 38321 00008237 1C071D070000            	dw	1820,1821,0	;M014
 38322                                  ShiftHelpMsgs:
 38323 0000823D 30070000                	dw	1840,0		;M014
 38324                                  IfHelpMsgs:
 38325 00008241 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 38325 0000824A 0749074A070000     
 38326                                  ForHelpMsgs:
 38327 00008251 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 38327 0000825A 00                 
 38328                                  TruenameHelpMsgs:
 38329 0000825B 6C070000                	 dw	1900,0		;M014
 38330                                  LoadhighHelpMsgs:
 38331 0000825F 800781078207            	dw	1920,1921,1922
 38332                                  	; MSDOS 6.0 COMMAND.COM
 38333                                  	;dw	1923,1924,1925,1926,1927 ;M014
 38334 00008265 0000                    	dw	0
 38335                                  
 38336                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 38337                                  CLSSTRING:
 38338 00008267 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 38339                                  
 38340                                  PROMPT_TABLE:
 38341 0000826C 42                      	db	"B"
 38342 0000826D [F91D]                  	dw	Print_B
 38343 0000826F 44                      	db	"D"
 38344 00008270 [C936]                  	dw	PRINT_DATE
 38345 00008272 45                      	db	"E"
 38346 00008273 [ED1D]                  	dw	PRINT_ESC
 38347 00008275 47                      	db	"G"
 38348 00008276 [F11D]                  	dw	PRINT_G
 38349 00008278 48                      	db	"H"
 38350 00008279 [E31D]                  	dw	PRINT_BACK
 38351 0000827B 4C                      	db	"L"
 38352 0000827C [F51D]                  	dw	PRINT_L
 38353 0000827E 4E                      	db	"N"
 38354 0000827F [0A1E]                  	dw	PRINT_DRIVE
 38355 00008281 50                      	db	"P"
 38356 00008282 [121E]                  	dw	build_dir_for_prompt
 38357 00008284 51                      	db	"Q"
 38358 00008285 [E91D]                  	dw	PRINT_EQ
 38359 00008287 54                      	db	"T"
 38360 00008288 [7E2F]                  	dw	PRINT_TIME
 38361 0000828A 56                      	db	"V"
 38362 0000828B [791D]                  	dw	PRINT_VERSION
 38363 0000828D 5F                      	db	"_"
 38364 0000828E [CF25]                  	dw	CRLF2
 38365 00008290 24                      	db	"$"
 38366 00008291 [FB1D]                  	dw	PRINT_CHAR
 38367 00008293 00                      	db	0			; NUL TERMINATED
 38368                                  
 38369                                  ; Table of IF conditionals
 38370                                  IFTAB:
 38371 00008294 034E4F54                	db	3,"NOT"			; First byte is count
 38372 00008298 [E00A]                  	dw	IFNOT
 38373 0000829A 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 38373 000082A3 454C               
 38374 000082A5 [9F0B]                  	dw	IFERLEV
 38375 000082A7 054558495354            	db	5,"EXIST"
 38376 000082AD [340B]                  	dw	IFEXISTS
 38377 000082AF 00                      	db	0
 38378                                  
 38379                                  ; Table for internal command names
 38380                                  COMTAB:
 38381 000082B0 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 38382 000082B5 [6410]                  	dw	CATALOG			; In TCMD1.ASM
 38383 000082B7 [C181]                  	dw	DirHelpMsgs
 38384                                  
 38385 000082B9 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 38386 000082BF [140C]                  	dw	_$CALL			; In TBATCH2.ASM
 38387 000082C1 [2382]                  	dw	CallHelpMsgs
 38388                                  
 38389 000082C3 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 38390 000082C9 [5520]                  	dw	CHCP			; In TCMD2B.ASM
 38391 000082CB [9181]                  	dw	ChcpHelpMsgs
 38392                                  
 38393 000082CD 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38394 000082D5 [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38395 000082D7 [FD81]                  	dw	RenHelpMsgs
 38396                                  
 38397 000082D9 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38398 000082DE [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38399 000082E0 [FD81]                  	dw	RenHelpMsgs
 38400                                  	
 38401 000082E2 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 38402 000082E9 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38403 000082EB [B981]                  	dw	DelHelpMsgs
 38404                                  	
 38405 000082ED 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 38406 000082F2 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38407 000082F4 [B981]                  	dw	DelHelpMsgs
 38408                                  	
 38409 000082F6 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38410 000082FC [E81A]                  	dw	TYPEFIL			; In TCMD1.ASM
 38411 000082FE [1382]                  	dw	TypeHelpMsgs
 38412                                  	
 38413 00008300 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 38414 00008305 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 38415 00008307 [2982]                  	dw	RemHelpMsgs
 38416                                  	
 38417 00008309 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 38418 0000830F [1637]                  	dw	COPY			; In COPY.ASM
 38419 00008311 [A381]                  	dw	CopyHelpMsgs
 38420                                  	
 38421 00008313 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 38422 0000831A [B319]                  	dw	PAUSE			; In TCMD1.ASM
 38423 0000831C [2D82]                  	dw	PauseHelpMsgs
 38424                                  	
 38425 0000831E 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 38426 00008324 [912E]                  	dw	DATE			; In TPIPE.ASM
 38427 00008326 [B381]                  	dw	DateHelpMsgs
 38428                                  	
 38429 00008328 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 38430 0000832E [F02E]                  	dw	CTIME			; In TPIPE.ASM
 38431 00008330 [0D82]                  	dw	TimeHelpMsgs
 38432                                  	
 38433 00008332 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 38434 00008337 [071D]                  	dw	VERSION			; In TCMD2.ASM
 38435 00008339 [1782]                  	dw	VerHelpMsgs
 38436                                  	
 38437 0000833B 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38438 00008340 [0F1C]                  	dw	VOLUME			; In TCMD1.ASM
 38439 00008342 [1F82]                  	dw	VolHelpMsgs
 38440                                  	
 38441 00008344 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38442 00008348 [9824]                  	dw	_$CHDIR			; In TENV.ASM
 38443 0000834A [9781]                  	dw	CdHelpMsgs
 38444                                  	
 38445 0000834C 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38446 00008353 [9824]                  	dw	_$CHDIR			; In TENV.ASM
 38447 00008355 [9781]                  	dw	CdHelpMsgs
 38448                                  	
 38449 00008357 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38450 0000835B [FD24]                  	dw	_$MKDIR			; In TENV.ASM
 38451 0000835D [D981]                  	dw	MdHelpMsgs
 38452                                  	
 38453 0000835F 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38454 00008366 [FD24]                  	dw	_$MKDIR			; In TENV.ASM
 38455 00008368 [D981]                  	dw	MdHelpMsgs
 38456                                  	
 38457 0000836A 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38458 0000836E [3F25]                  	dw	_$RMDIR			; In TENV.ASM
 38459 00008370 [F981]                  	dw	RdHelpMsgs
 38460                                  	
 38461 00008372 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38462 00008379 [3F25]                  	dw	_$RMDIR			; In TENV.ASM
 38463 0000837B [F981]                  	dw	RdHelpMsgs
 38464                                  	
 38465 0000837D 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 38466 00008384 [1336]                  	dw	CNTRLC			; In TUCODE.ASM
 38467 00008386 [8D81]                  	dw	BreakHelpMsgs
 38468                                  	
 38469 00008388 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 38470 00008390 [5536]                  	dw	VERIFY			; In TUCODE.ASM
 38471 00008392 [1B82]                  	dw	VerifyHelpMsgs
 38472                                  	
 38473 00008394 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 38474 00008399 [0222]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 38475 0000839B [0582]                  	dw	SetHelpMsgs
 38476                                  	
 38477 0000839D 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 38478 000083A5 [E821]                  	dw	ADD_PROMPT		; In TENV.ASM
 38479 000083A7 [E581]                  	dw	PromptHelpMsgs
 38480                                  	
 38481 000083A9 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 38482 000083AF [791E]                  	dw	PATH			; In TCMD2.ASM
 38483 000083B1 [DD81]                  	dw	PathHelpMsgs
 38484                                  	
 38485 000083B3 044558495400            	db	4,"EXIT",0
 38486 000083B9 [4A21]                  	dw	_$EXIT			; In TCMD2.ASM
 38487 000083BB [D581]                  	dw	ExitHelpMsgs
 38488                                  	
 38489 000083BD 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 38490 000083C3 [B71F]                  	dw	CTTY			; In TCMD2.ASM
 38491 000083C5 [AF81]                  	dw	CttyHelpMsgs
 38492                                  	
 38493 000083C7 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 38494 000083CD [DA35]                  	dw	_ECHO			; In TUCODE.ASM
 38495 000083CF [3182]                  	dw	EchoHelpMsgs
 38496                                  	
 38497 000083D1 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 38498 000083D7 [480C]                  	dw	_GOTO			; In TBATCH.ASM
 38499 000083D9 [3782]                  	dw	GotoHelpMsgs
 38500                                  	
 38501 000083DB 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 38502 000083E2 [CD0B]                  	dw	_SHIFT			; In TBATCH.ASM
 38503 000083E4 [3D82]                  	dw	ShiftHelpMsgs
 38504                                  	
 38505 000083E6 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 38506 000083EA [790A]                  	dw	_$IF			; In TBATCH.ASM
 38507 000083EC [4182]                  	dw	IfHelpMsgs
 38508                                  	
 38509 000083EE 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 38510 000083F3 [FD0E]                  	dw	_$FOR			; In TBATCH.ASM
 38511 000083F5 [5182]                  	dw	ForHelpMsgs
 38512                                  	
 38513 000083F7 03434C5300              	db	3,"CLS",0
 38514 000083FC [1E1F]                  	dw	CLS			; In TCMD2.ASM
 38515 000083FE [9F81]                  	dw	ClsHelpMsgs
 38516                                  	
 38517 00008400 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 38517 00008409 03                 
 38518 0000840A [D320]                  	dw	TRUENAME		;AN000;
 38519 0000840C [5B82]                  	dw	TruenameHelpMsgs
 38520                                  	
 38521 0000840E 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 38521 00008417 02                 
 38522 00008418 [2556]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38523 0000841A [5F82]                  	dw	LoadhighHelpMsgs	; M003
 38524                                  	
 38525 0000841C 024C4802                	db	2,"LH",fSwitchAllowed ; 2 ; Short form; M003
 38526 00008420 [2556]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38527 00008422 [5F82]                  	dw	LoadhighHelpMsgs	; M003
 38528                                  	
 38529 00008424 00                      	db	0			; Terminate command table
 38530                                  
 38531                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 38532                                  
 38533 00008425 2E434F4D                comext:	db	".COM"
 38534 00008429 2E455845                exeext:	db	".EXE"
 38535 0000842D 2E424154                batext:	db	".BAT"
 38536                                  
 38537                                  switch_list:
 38538 00008431 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 38539                                  
 38540                                  AttrLtrs:
 38541 00008437 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 38542                                  
 38543                                  ;	Attribute letters in AttrLtrs must appear in the order that
 38544                                  ;	attribute bits occur in the attribute byte returned by
 38545                                  ;	directory searches, starting with bit 0.
 38546                                  ;	The volume label attribute is lowercased to keep it from
 38547                                  ;	being matched (by an uppercase comparison).
 38548                                  
 38549                                  OrderLtrs:
 38550 0000843D 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 38551                                  	; MSDOS 6.0 COMMAND.COM
 38552                                  	;db	"NEDSGC"		; sort order letters for DIR
 38553                                  
 38554                                  ;	Sort order letters stand for file name, extension,
 38555                                  ;	date/time, size, grouped (directory files before others),
 38556                                  ;	and compression ratio. DIR routines rely on the specific
 38557                                  ;	order of the letters in this list.
 38558                                  
 38559                                  comspec_flag:
 38560 00008442 00                      	db	0                       ;AN071;
 38561                                  
 38562                                  BATBUFLEN:
 38563 00008443 2000                    	dw	BatLen ; 32
 38564                                  
 38565                                  ; *****************************************************
 38566                                  ; EMG 4.00
 38567                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 38568                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 38569                                  ; *****************************************************
 38570                                  
 38571                                  ; COMMON PARSE BLOCKS
 38572                                  
 38573                                  ; Indicates no value list for PARSE.
 38574                                  
 38575                                  NO_VALUES:
 38576 00008445 0000                    	dw	0			;AN000;  no values
 38577                                  
 38578                                  NULL_VALUE_LIST:  ; for unvalidated value
 38579 00008447 00                       	db	0                       ; no value lists
 38580                                  
 38581                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38582                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 38583                                  
 38584                                  ; PARSE control block for a required file specification (upper cased)
 38585                                  
 38586                                  FILE_REQUIRED:
 38587 00008448 0002                    	dw	0200h			;AN000;  filespec - required
 38588 0000844A 0100                    	dw	1			;AN000;  capitalize - file table
 38589 0000844C [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38590 0000844E [4584]                  	dw	NO_VALUES		;AN000;
 38591 00008450 00                      	db	0			;AN000;  no keywords
 38592                                  
 38593                                  ; PARSE control block for an optional file specification (upper cased)
 38594                                  ; or drive number
 38595                                  
 38596                                  FILE_OPTIONAL:
 38597 00008451 0103                    	dw	0301h			;AN000;  filespec or drive number
 38598                                  					;	 optional
 38599 00008453 0100                    	dw	1			;AN000;  capitalize - file table
 38600 00008455 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38601 00008457 [4584]                  	dw	NO_VALUES		;AN000;
 38602 00008459 00                      	db	0			;AN000;  no keywords
 38603                                  
 38604                                  ; PARSE control block for an optional file specification (upper cased)
 38605                                  
 38606                                  FILE_OPTIONAL2:
 38607 0000845A 0102                    	dw	0201h                   ;AN000;  filespec optional
 38608 0000845C 0100                    	dw	1                       ;AN000;  capitalize - file table
 38609 0000845E [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38610 00008460 [4584]                  	dw	NO_VALUES		;AN000;
 38611 00008462 00                      	db	0			;AN000;  no keywords
 38612                                  
 38613                                  ; PARSE control block for an optional /P switch
 38614                                  
 38615                                  SLASH_P_SWITCH:
 38616 00008463 0000                    	dw	0			;AN000;  no match flags
 38617 00008465 0200                    	dw	2			;AN000;  capitalize - char table
 38618 00008467 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38619 00008469 [4584]                  	dw	NO_VALUES		;AN000;
 38620 0000846B 01                      	db	1			;AN000;  1 keyword
 38621                                  SLASH_P_SYN:
 38622 0000846C 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38623                                  
 38624                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38625                                  
 38626                                  ; The following parse control block can be used for any command which
 38627                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38628                                  ; the equal sign as an additional delimiter. Returns verified result
 38629                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38630                                  ; internal commands.
 38631                                  
 38632                                  PARSE_BREAK:
 38633 0000846F [7284]                  	dw	BREAK_PARMS		;AN000;
 38634 00008471 00                      	db	0			;AN032; no extra delimiter
 38635                                  
 38636                                  BREAK_PARMS:
 38637 00008472 0001                    	db	0,1			;AN000;  1 positional parm
 38638 00008474 [7884]                  	dw	BREAK_CONTROL1		;AN000;
 38639 00008476 00                      	db	0			;AN000;  no switches
 38640 00008477 00                      	db	0			;AN000;  no keywords
 38641                                  
 38642                                  BREAK_CONTROL1:
 38643 00008478 0120                    	dw	2001h			;AN000;  string value - optional
 38644 0000847A 0200                    	dw	2			;AN000;  capitalize - char table
 38645 0000847C [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38646 0000847E [8184]                  	dw	BREAK_VALUES		;AN000;
 38647 00008480 00                      	db	0			;AN000;  no keywords
 38648                                  
 38649                                  BREAK_VALUES:
 38650 00008481 03                      	db	3			;AN000;
 38651 00008482 00                      	db	0			;AN000;  no ranges
 38652 00008483 00                      	db	0			;AN000;  no numeric values
 38653 00008484 02                      	db	2			;AN000;  2 string values
 38654 00008485 00                      	db	0			;AN000;  returned if ON
 38655 00008486 [8B84]                  	dw	BREAK_ON		;AN000;  point to ON string
 38656 00008488 66                      	db	'f'                     ;AN000;  returned if OFF
 38657 00008489 [8E84]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38658                                  
 38659                                  BREAK_ON:
 38660 0000848B 4F4E00                  	db	"ON",0                  ;AN000;
 38661                                  BREAK_OFF:
 38662 0000848E 4F464600                	db	"OFF",0                 ;AN000;
 38663                                  
 38664                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38665                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38666                                  
 38667                                  ; PARSE BLOCK FOR CHCP
 38668                                  
 38669                                  ; The following parse control block can be used for any command which
 38670                                  ; needs only one optional three digit decimal parameter for operands.
 38671                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38672                                  ; CHCP internal command.
 38673                                  
 38674                                  CHCP_MINVAL	EQU	100			;AN000;
 38675                                  CHCP_MAXVAL	EQU	999			;AN000;
 38676                                  
 38677                                  PARSE_CHCP:
 38678 00008492 [9584]                  	dw	CHCP_PARMS			;AN000;
 38679 00008494 00                      	db	0				;AN000;  no extra delimiter
 38680                                  CHCP_PARMS:
 38681 00008495 0001                    	db	0,1				;AN000;  1 positional parm
 38682 00008497 [9B84]                  	dw	CHCP_CONTROL1			;AN000;
 38683 00008499 00                      	db	0				;AN000;  no switches
 38684 0000849A 00                      	db	0				;AN000;  no keywords
 38685                                  
 38686                                  CHCP_CONTROL1:
 38687 0000849B 0180                    	dw	8001h				;AN000;  numeric value - optional
 38688 0000849D 0000                    	dw	0				;AN000;  no function flags
 38689 0000849F [4F95]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38690 000084A1 [A484]                  	dw	CHCP_VALUES			;AN000;
 38691 000084A3 00                      	db	0				;AN000;  no keywords
 38692                                  
 38693                                  CHCP_VALUES:
 38694 000084A4 01                      	db	1				;AN000;
 38695 000084A5 01                      	db	1				;AN000;  1 range
 38696 000084A6 01                      	db	1				;AN000;  returned if result
 38697 000084A7 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38698 000084AF 00                      	db	0				;AN000;  no numeric values
 38699 000084B0 00                      	db	0				;AN000;  no string values
 38700                                  
 38701                                  ; PARSE BLOCK FOR DATE
 38702                                  
 38703                                  ; The following parse control block can be used for any command which
 38704                                  ; needs only an optional date string as an operand. Returns unverified
 38705                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38706                                  
 38707                                  PARSE_DATE:
 38708 000084B1 [B484]                  	dw	DATE_PARMS			;AN000;
 38709 000084B3 00                      	db	0				;AN000;  no extra delimiter
 38710                                  DATE_PARMS:
 38711 000084B4 0001                    	db	0,1				;AN000;  1 positional parm
 38712 000084B6 [BA84]                  	dw	DATE_CONTROL1			;AN000;
 38713 000084B8 00                      	db	0				;AN000;  no switches
 38714 000084B9 00                      	db	0				;AN000;  no keywords
 38715                                  
 38716                                  DATE_CONTROL1:
 38717 000084BA 0110                    	dw	1001h				;AN000;  date - optional
 38718 000084BC 0000                    	dw	0				;AN000;  no function flags
 38719 000084BE [5795]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38720 000084C0 [4584]                  	dw	NO_VALUES			;AN000;
 38721 000084C2 00                      	db	0				;AN000;  no keywords
 38722                                  
 38723                                  ; PARSE BLOCK FOR TIME
 38724                                  
 38725                                  ; The following parse control block can be used for any command which
 38726                                  ; needs only an optional time string as an operand. Returns unverified
 38727                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38728                                  
 38729                                  PARSE_TIME:
 38730 000084C3 [C684]                  	dw	TIME_PARMS			;AN000;
 38731 000084C5 00                      	db	0				;AN000;  no extra delimiter
 38732                                  TIME_PARMS:
 38733 000084C6 0001                    	db	0,1				;AN000;  1 positional parm
 38734 000084C8 [CC84]                  	dw	TIME_CONTROL1			;AN000;
 38735 000084CA 00                      	db	0				;AN000;  no switches
 38736 000084CB 00                      	db	0				;AN000;  no keywords
 38737                                  
 38738                                  TIME_CONTROL1:
 38739 000084CC 0108                    	dw	0801h				;AN000;  TIME - optional
 38740 000084CE 0000                    	dw	0				;AN000;  no function flags
 38741 000084D0 [5F95]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38742 000084D2 [4584]                  	dw	NO_VALUES			;AN000;
 38743 000084D4 00                      	db	0				;AN000;  no keywords
 38744                                  
 38745                                  ; PARSE BLOCK FOR VOL
 38746                                  
 38747                                  ; The following parse control block can be used for any command which
 38748                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38749                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38750                                  ; internal command.
 38751                                  
 38752                                  PARSE_VOL:
 38753 000084D5 [D884]                  	dw	VOL_PARMS			;AN000;
 38754 000084D7 00                      	db	0				;AN000;  no extra delimiter
 38755                                  VOL_PARMS:
 38756 000084D8 0001                    	db	0,1				;AN000;  1 positional parm
 38757 000084DA [DE84]                  	dw	DRIVE_CONTROL1			;AN000;
 38758 000084DC 00                      	db	0				;AN000;  no switches
 38759 000084DD 00                      	db	0				;AN000;  no keywords
 38760                                  
 38761                                  DRIVE_CONTROL1:
 38762 000084DE 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38763 000084E0 0100                    	dw	1				;AN000;  capitalize - file table
 38764 000084E2 [6795]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38765 000084E4 [4584]                  	dw	NO_VALUES			;AN000;
 38766 000084E6 00                      	db	0				;AN000;  no keywords
 38767                                  
 38768                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38769                                  
 38770                                  ; The following parse control block can be used for any command which
 38771                                  ; needs only one required file specification as an operand. Returns a
 38772                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38773                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38774                                  
 38775                                  PARSE_MRDIR:
 38776 000084E7 [EA84]                  	dw	MRDIR_PARMS			;AN000;
 38777 000084E9 00                      	db	0				;AN000;  no extra delimiter
 38778                                  MRDIR_PARMS:
 38779 000084EA 0101                    	db	1,1				;AN000;  1 positional parm
 38780 000084EC [4884]                  	dw	FILE_REQUIRED			;AN000;
 38781 000084EE 00                      	db	0				;AN000;  no switches
 38782 000084EF 00                      	db	0				;AN000;  no keywords
 38783                                  
 38784                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38785                                  
 38786                                  ; The following parse control block can be used for any command which
 38787                                  ; needs only one optional file specification an operand. Returns a
 38788                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38789                                  ; for the CHDIR and TRUENAME internal commands.
 38790                                  
 38791                                  PARSE_CHDIR:
 38792 000084F0 [F384]                  	dw	CHDIR_PARMS			;AN000;
 38793 000084F2 00                      	db	0				;AN000;  no extra delimiter
 38794                                  CHDIR_PARMS:
 38795 000084F3 0001                    	db	0,1				;AN000;  1 positional parm
 38796 000084F5 [5184]                  	dw	FILE_OPTIONAL			;AN000;
 38797 000084F7 00                      	db	0				;AN000;  no switches
 38798 000084F8 00                      	db	0				;AN000;  no keywords
 38799                                  
 38800                                  ; PARSE BLOCK FOR ERASE
 38801                                  
 38802                                  ; The following parse control block is used for the DEL/ERASE internal
 38803                                  ; commands. This command has one required file specification and an
 38804                                  ; optional switch (/p) as operands. The verified switch or unverified
 38805                                  ; file specification is returned in PARSE1_OUTPUT.
 38806                                  
 38807                                  PARSE_ERASE:
 38808 000084F9 [FC84]                  	dw	ERASE_PARMS			;AN000;
 38809 000084FB 00                      	db	0				;AN000;  no extra delimiter
 38810                                  
 38811                                  ERASE_PARMS:
 38812 000084FC 0101                    	db	1,1				;AN000;  1 positional parm
 38813 000084FE [4884]                  	dw	FILE_REQUIRED			;AN000;
 38814 00008500 01                      	db	1				;AN000;  1 switch
 38815 00008501 [6384]                  	dw	SLASH_P_SWITCH			;AN000;
 38816 00008503 00                      	db	0				;AN000;  no keywords
 38817                                  
 38818                                  ; PARSE BLOCK FOR DIR
 38819                                  
 38820                                  ; The following parse control block is used for the DIR internal command.
 38821                                  ; This command has one optional file specification and several optional
 38822                                  ; switches. Switches, switch values, and the filespec are returned in 
 38823                                  ; PARSE1_OUTPUT.
 38824                                  ;
 38825                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38826                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38827                                  ; do not require colons, and are not checked against a value list.
 38828                                  ;
 38829                                  ; Switch /h has been removed from the DIR command	;M008
 38830                                  ; Switch /? is no longer handled internally		;M008
 38831                                  ;
 38832                                  ; A list of pointers to all the switch synonyms is provided here to
 38833                                  ; help identify which switch has been matched.
 38834                                  
 38835                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38836                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38837                                  
 38838                                  PARSE_DIR:
 38839 00008504 [0785]                  	dw	DIR_PARMS
 38840 00008506 00                      	db	0			; no extra delimiters
 38841                                  DIR_PARMS:
 38842 00008507 0001                    	db	0,1			; 1 optional positional param
 38843 00008509 [5A84]                  	dw	FILE_OPTIONAL2
 38844 0000850B 02                      	db	2			; 2 kinds of switches
 38845 0000850C [1185]                  	dw	DIR_SW_VALUED
 38846 0000850E [2085]                  	dw	DIR_SW_UNVALUED
 38847 00008510 00                      	db	0			; no keywords
 38848                                  
 38849                                  DIR_SW_VALUED:
 38850 00008511 0120                    	dw	2001h			; optional string value
 38851 00008513 2100                    	dw	21h			; optional colon; capitalize 
 38852 00008515 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 38853 00008517 [4784]                  	dw	NULL_VALUE_LIST		; don't validate value
 38854                                  
 38855 00008519 02                      	db	2
 38856                                  
 38857                                  ; MSDOS 6.0 COMMAND.COM
 38858                                  ;ifdef DBLSPACE_HOOKS
 38859                                  ;	db	3		; 3 'synonyms'
 38860                                  ;else
 38861                                  ;	db	2		; 2 'synonyms'
 38862                                  ;endif
 38863                                  
 38864                                  DIR_SW_A:
 38865 0000851A 2F4100                  	db	"/A",0
 38866                                  DIR_SW_O:
 38867 0000851D 2F4F00                  	db	"/O",0
 38868                                  
 38869                                  ; MSDOS 6.0 COMMAND.COM
 38870                                  ;ifdef DBLSPACE_HOOKS
 38871                                  ;DIR_SW_C	db	"/C",0
 38872                                  ;endif
 38873                                  
 38874                                  DIR_SW_UNVALUED:
 38875 00008520 0000                    	dw	0			; no value
 38876 00008522 0000                    	dw	0			; no format functions
 38877 00008524 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 38878 00008526 [4584]                  	dw	NO_VALUES
 38879                                  
 38880                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38881                                  	;db	12
 38882                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38883 00008528 0E                      	db	14		; 14 'synonyms' !?
 38884                                  
 38885                                  ; MSDOS 6.0 COMMAND.COM
 38886                                  ;ifdef DBLSPACE_HOOKS
 38887                                  ;	db	13		; 13 'synonyms'
 38888                                  ;else
 38889                                  ;	db	12		; 12 'synonyms'
 38890                                  ;endif
 38891                                  
 38892                                  DIR_SW_NEG_A:
 38893 00008529 2F2D4100                	db	"/-A",0
 38894                                  DIR_SW_NEG_O:
 38895 0000852D 2F2D4F00                	db	"/-O",0
 38896                                  DIR_SW_S:
 38897 00008531 2F5300                  	db	"/S",0
 38898                                  DIR_SW_NEG_S:
 38899 00008534 2F2D5300                	db	"/-S",0
 38900                                  DIR_SW_B:
 38901 00008538 2F4200                  	db	"/B",0
 38902                                  DIR_SW_NEG_B:
 38903 0000853B 2F2D4200                	db	"/-B",0
 38904                                  DIR_SW_W:
 38905 0000853F 2F5700                  	db	"/W",0
 38906                                  DIR_SW_NEG_W:
 38907 00008542 2F2D5700                	db	"/-W",0
 38908                                  DIR_SW_P:
 38909 00008546 2F5000                  	db	"/P",0
 38910                                  DIR_SW_NEG_P:
 38911 00008549 2F2D5000                	db	"/-P",0
 38912                                  DIR_SW_L:
 38913 0000854D 2F4C00                  	db	"/L",0		;M010
 38914                                  DIR_SW_NEG_L:
 38915 00008550 2F2D4C00                	db	"/-L",0 	;M010
 38916                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38917                                  ;DIR_SW_NEG_C:
 38918                                  ;	db	"/-C",0
 38919                                  
 38920                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38921                                  ; identification. Order is critical - DIR routines rely on the
 38922                                  ; specific order in this list. Negated options appear at odd 
 38923                                  ; positions in the list, and simple on/off options appear first.
 38924                                  
 38925                                  Dir_Sw_Ptrs:
 38926                                  	; MSDOS 5.0 COMMAND.COM
 38927 00008554 [4285]                  	dw	DIR_SW_NEG_W 
 38928                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38929                                  	; MSDOS 6.0 COMMAND.COM
 38930                                  	;dw	DIR_SW_NEG_C
 38931                                  	;dw	DIR_SW_C
 38932                                  	;dw	DIR_SW_NEG_W
 38933                                  	
 38934 00008556 [3F85]                  	dw	DIR_SW_W
 38935 00008558 [4985]                  	dw	DIR_SW_NEG_P
 38936 0000855A [4685]                  	dw	DIR_SW_P
 38937 0000855C [3485]                  	dw	DIR_SW_NEG_S
 38938 0000855E [3185]                  	dw	DIR_SW_S
 38939 00008560 [3B85]                  	dw	DIR_SW_NEG_B
 38940 00008562 [3885]                  	dw	DIR_SW_B
 38941 00008564 [5085]                  	dw	DIR_SW_NEG_L	;M010
 38942 00008566 [4D85]                  	dw	DIR_SW_L	;M010
 38943 00008568 [2D85]                  	dw	DIR_SW_NEG_O
 38944 0000856A [1D85]                  	dw	DIR_SW_O
 38945 0000856C [2985]                  	dw	DIR_SW_NEG_A
 38946 0000856E [1A85]                  	dw	DIR_SW_A
 38947                                  
 38948                                  ; PARSE BLOCK FOR RENAME
 38949                                  
 38950                                  ; The following parse control block can be used for any command which
 38951                                  ; needs only two required file specifications as operands. Returns
 38952                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38953                                  ; Currently used for the RENAME internal command.
 38954                                  
 38955                                  PARSE_RENAME:
 38956 00008570 [7385]                  	dw	RENAME_PARMS		;AN000;
 38957 00008572 00                      	db	0			;AN000;  no extra delimiter
 38958                                  RENAME_PARMS:
 38959 00008573 0202                    	db	2,2			;AN000;  2 positional parms
 38960 00008575 [4884]                  	dw	FILE_REQUIRED		;AN000;
 38961 00008577 [4884]                  	dw	FILE_REQUIRED		;AN000;
 38962 00008579 00                      	db	0			;AN000;  no switches
 38963 0000857A 00                      	db	0			;AN000;  no keywords
 38964                                  
 38965                                  ; PARSE BLOCK FOR CTTY
 38966                                  
 38967                                  ; The following parse control block can be used for any command which
 38968                                  ; needs one required device name as an operand. Returns a pointer to
 38969                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38970                                  ; internal command.
 38971                                  
 38972                                  PARSE_CTTY:
 38973 0000857B [7E85]                  	dw	CTTY_PARMS		;AN000;
 38974 0000857D 00                      	db	0			;AN000;  no extra delimiter
 38975                                  CTTY_PARMS:
 38976 0000857E 0101                    	db	1,1			;AN000;  1 positional parm
 38977 00008580 [8485]                  	dw	CTTY_CONTROL1		;AN000;
 38978 00008582 00                      	db	0			;AN000;  no switches
 38979 00008583 00                      	db	0			;AN000;  no keywords
 38980                                  CTTY_CONTROL1:
 38981 00008584 0020                    	dw	2000h			;AN000;  string value - required
 38982 00008586 1100                    	dw	11h			;AN000;  capitalize - file table
 38983                                  					;AN000;  remove colon at end
 38984 00008588 [4F95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38985 0000858A [4584]                  	dw	NO_VALUES		;AN000;
 38986 0000858C 00                      	db	0			;AN000;  no keywords
 38987                                  
 38988                                  ; PARSE BLOCK FOR VER
 38989                                  
 38990                                  ; The following parse control block can be used for any command which
 38991                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38992                                  
 38993                                  PARSE_VER:
 38994 0000858D [9085]                  	dw	VER_PARMS
 38995 0000858F 00                      	db	0			; no extra delimiters
 38996                                  VER_PARMS:
 38997 00008590 0000                    	db	0,0			; no positional parameters
 38998                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 38999                                  %if 0	; PCDOS 7.1 (& MSDOS 5.0-6.22) COMMAND.COM 
 39000                                  	db	1			; one switch
 39001                                  	dw	SLASH_R
 39002                                  %else
 39003                                  	; 20/07/2024 - Retro DOS v4-v5 COMMAND.COM
 39004 00008592 02                      	db	2			; two switches
 39005 00008593 [9885]                  	dw	SLASH_R
 39006 00008595 [A485]                  	dw	SLASH_T ; Retro DOS v4-v5 COMMAND.COM switch
 39007                                  %endif
 39008 00008597 00                      	db	0			; no keywords
 39009                                  SLASH_R:
 39010 00008598 0000                    	dw	0			; no values
 39011 0000859A 0200                    	dw	2			; capitalize by filename table
 39012 0000859C [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 39013 0000859E [4584]                  	dw	NO_VALUES		; no values
 39014 000085A0 01                      	db	1			; one synonym
 39015                                  SLASH_R_SYN:
 39016 000085A1 2F5200                  	db	"/R",0
 39017                                  
 39018                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 39019                                  %if 1
 39020                                  SLASH_T:
 39021 000085A4 0000                    	dw	0			; no values
 39022 000085A6 0200                    	dw	2			; capitalize by filename table
 39023 000085A8 [4F95]                  	dw	PARSE1_OUTPUT		; result buffer
 39024 000085AA [4584]                  	dw	NO_VALUES		; no values
 39025 000085AC 01                      	db	1			; one synonym
 39026                                  SLASH_T_SYN:
 39027 000085AD 2F5400                  	db	"/T",0
 39028                                  %endif
 39029                                  
 39030                                  ; M003 ; Start of changes for LoadHigh support
 39031                                  
 39032                                  ;Parse Control Block for LOADHIGH command
 39033                                  
 39034                                  Parse_LoadHi:
 39035 000085B0 [B385]                  	dw	LoadHi_Parms		;extended parm table
 39036 000085B2 00                      	db	0			;no extra delimiters
 39037                                  
 39038                                  LoadHi_Parms:
 39039 000085B3 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 39040 000085B5 [4884]                  	dw	FILE_REQUIRED		;control struc for filename
 39041 000085B7 00                      	db	0			;no switches
 39042 000085B8 00                      	db	0			;no keywords
 39043                                  
 39044                                  ; M003 ; End of changes for LoadHigh support
 39045                                  
 39046                                  TempVarName:
 39047 000085B9 54454D503D00            	db	"TEMP=",0
 39048                                  
 39049                                  ; ---------------------------------------------------------------------------
 39050                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 39051                                  %if 1
 39052 000085BF 0D0A                    RD4CMD_VER_MSG:	db 0Dh,0Ah
 39053 000085C1 526574726F20444F53-     		db 'Retro DOS v4 COMMAND.COM'
 39053 000085CA 20763420434F4D4D41-
 39053 000085D3 4E442E434F4D       
 39054 000085D9 0D0A                    		db 0Dh,0Ah 
 39055 000085DB 32303234202D204572-     		db '2024 - Erdogan Tan'
 39055 000085E4 646F67616E2054616E 
 39056 000085ED 0D0A                    		db 0Dh,0Ah
 39057 000085EF 24                      		db '$'
 39058                                  %endif
 39059                                  ; ---------------------------------------------------------------------------
 39060                                  
 39061                                  	; 16/04/2023
 39062                                  TRANDATAEND:		; TRANGROUP:88C2h
 39063                                  
 39064                                  ;============================================================================
 39065                                  ; PSDATA.INC, MSDOS 6.0, 1991
 39066                                  ;============================================================================
 39067                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39068                                  
 39069                                  ; 18/04/2023
 39070                                  TRANSPACESTART:
 39071                                  
 39072                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 39073                                  
 39074                                  ;********************** Local Data *************************************
 39075                                  
 39076                                  $P_ORDINAL:
 39077 000085F0 0000                    	dw	0		;AN000; Operand ordinal save area
 39078                                  $P_RC:
 39079 000085F2 0000                    	dw	0		;AN000; Return code from parser
 39080                                  $P_SI_Save:
 39081 000085F4 0000                    	dw	0		;AN000; Pointer of command buffer
 39082                                  $P_DX:
 39083 000085F6 0000                    	dw	0		;AN000; Return result buffer address
 39084                                  $P_Terminator:
 39085 000085F8 00                      	db	0		;AN000; Terminator code (ASCII)
 39086                                  $P_DBCSEV_OFF:
 39087 000085F9 0000                    	dw	0		;AN000; Offset of DBCS EV
 39088                                  $P_DBCSEV_SEG:
 39089 000085FB 0000                    	dw	0		;AN000; Segment of DBCS EV
 39090                                  $P_Flags:			;AN000; Parser internal flags
 39091                                  $P_Flags1:
 39092 000085FD 00                      	db	0		;AN038; to reference first byte flags
 39093                                  $P_Flags2:
 39094 000085FE 00                      	db	0		;AN038; to reference second byte flags only
 39095                                  $P_SaveSI_Cmpx:
 39096 000085FF 0000                    	dw	0		;AN000; save si for later use by complex
 39097                                  $P_KEYorSW_Ptr:
 39098 00008601 0000                    	dw	0		;AN000; points next to "=" or ":" code
 39099                                  $P_Save_EOB:
 39100 00008603 0000                    	dw	0		;AN000; save pointer to EOB
 39101                                  $P_Found_SYNONYM:
 39102 00008605 0000                    	dw	0		;AN000; es:@ points to found synonym
 39103                                  $P_STRING_BUF:
 39104 00008607 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 39105                                  $P_ORIG_ORD:
 39106 00008687 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 39107                                  $P_ORIG_STACK:
 39108 00008689 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 39109                                  $P_ORIG_SI:
 39110 0000868B 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 39111                                  $P_Got_Time:
 39112 0000868D 00                      	db	0		;AN023; if 1, use Time delimiters
 39113                                  $P_Country_Info:
 39114 0000868E FFFF                    	dw	-1 ; 0FFFFh
 39115 00008690 00<rep 20h>             	times	32 db 0	
 39116                                  $P_1st_Val:
 39117 000086B0 0000                    	dw	0		;AN000; used when process date or time
 39118                                  $P_2nd_Val:
 39119 000086B2 0000                    	dw	0		;AN000; used when process date or time
 39120                                  $P_3rd_Val:
 39121 000086B4 0000                    	dw	0		;AN000; used when process date or time
 39122                                  $P_4th_Val:
 39123 000086B6 0000                    	dw	0		;AN000; used when process date or time
 39124                                  $P_Char_CAP_Ptr:
 39125 000086B8 FF                      	db	0FFh		;AN000; info id
 39126 000086B9 0000                    	dw	0		;AN000; offset	of char case map table
 39127 000086BB 0000                    	dw	0		;AN000; segment of char case map table
 39128                                  $P_File_CAP_Ptr:
 39129 000086BD FF                      	db	0FFh		;AN000; info id
 39130 000086BE 0000                    	dw	0		;AN000; offset	of file case map table
 39131 000086C0 0000                    	dw	0		;AN000; segment of file case map table
 39132                                  
 39133                                  	; 18/04/2023
 39134                                  ;M029
 39135                                  ;!!!WARNING!!!
 39136                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 39137                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 39138                                  ;changes need to be made in SYSPARSE
 39139                                  
 39140                                  $P_FileSp_Char:
 39141 000086C2 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 39142                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 39143                                  
 39144                                  ;filespec error flag
 39145                                  $P_err_flag:
 39146 000086CB 00                      	db	0		;AN033; flag set if filespec parsing error
 39147                                  				;AN033;  was detected.
 39148                                  
 39149                                  ;============================================================================
 39150                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 39151                                  ;============================================================================
 39152                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39153                                  
 39154                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 39155                                  
 39156                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39157                                  ;;
 39158                                  ;; STRUCTURE: $M_RES_ADDRS
 39159                                  ;;
 39160                                  ;; Resident data area definition of variables
 39161                                  ;;
 39162                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39163                                  
 39164                                  $M_RT:
 39165 000086CC 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 39166                                  
 39167                                  ;============================================================================
 39168                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 39169                                  ;============================================================================
 39170                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39171                                  
 39172                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 39173                                  ; ---------------------------------------------------------------------------
 39174                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 39175                                  ;;M031 - changed copyright to 1991
 39176                                  ;;9/16 - changed version to 6.0 and copyright to 1992
 39177                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 39178                                  ;;B49,50 - changed version to 6 and copyright to 1993
 39179                                  ; ---------------------------------------------------------------------------
 39180                                  
 39181                                  ;;ifdef USA
 39182                                  ;MsDosVer6_CCopy:
 39183                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 39184                                  ;	db	"Licensed Material - Property of Microsoft "
 39185                                  ;	db	"All rights reserved "
 39186                                  ;endif
 39187                                  
 39188                                  ; 15/04/2023
 39189                                  MsDosVer5_CCopy:
 39190 00008759 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 39190 00008762 7273696F6E20352E30-
 39190 0000876B 3020284329436F7079-
 39190 00008774 726967687420313938-
 39190 0000877D 312D31393931204D69-
 39190 00008786 63726F736F66742043-
 39190 0000878F 6F727020           
 39191 00008793 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 39191 0000879C 4D6174657269616C20-
 39191 000087A5 2D2050726F70657274-
 39191 000087AE 79206F66204D696372-
 39191 000087B7 6F736F667420       
 39192 000087BD 416C6C207269676874-     	db	"All rights reserved "
 39192 000087C6 732072657365727665-
 39192 000087CF 6420               
 39193                                  ; ---------------------------------------------------------------------------
 39194                                  ; 15/04/2023
 39195                                  	; 16/04/2023 - 21/04/2023
 39196                                  	;db 	0
 39197                                  	;db	0Dh,0Ah
 39198                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 39199                                  	;db	0
 39200                                  	;db	'by Erdogan Tan - 05/05/2023'
 39201                                  	;db	0
 39202                                  
 39203                                  ;============================================================================
 39204                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 39205                                  ;============================================================================
 39206                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39207                                  
 39208                                  PRINTF_HANDLE:
 39209 000087D1 0000                    	dw	0		;AC000;
 39210                                  
 39211                                  ; 15/047/2023
 39212                                  %if 0
 39213                                  
 39214                                  ;============================================================================
 39215                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39216                                  ;============================================================================
 39217                                  ; 29/09/2018 - Retro DOS v3.0
 39218                                  
 39219                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39220                                  
 39221                                  ;The TRANSPACE segment contains variable data that is considered
 39222                                  ;volatile between command cycles, and therefore is not included in the
 39223                                  ;transient checksum area. Contents of these variables MUST be
 39224                                  ;initialized before use, and must not be relied upon from command
 39225                                  ;cycle to command cycle.
 39226                                  ;
 39227                                  ;No constant data values should be stored here.
 39228                                  
 39229                                  ; ---------------------------------------------------------------------------
 39230                                  ; START OF UNITIALIZED DATA
 39231                                  ; ---------------------------------------------------------------------------
 39232                                  
 39233                                  ;	times 12 db 0
 39234                                  
 39235                                  align 16
 39236                                  
 39237                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 39238                                  
 39239                                  PRINTF_LEFT:	db 0
 39240                                  PRINTF_LONG:	db 0
 39241                                  PRINTF_HEX:	db 0
 39242                                  TABLE_INDEX:	db 0
 39243                                  PRINTF_WIDTH:	dw 0
 39244                                  PRINTF_BASE:	dw 0
 39245                                  PAD_CHAR:	db 0
 39246                                  PRINTF_HANDLE:	dw 0
 39247                                  PRINTF_BUF: times 100 db 0
 39248                                  PRINTF_BUF_END: ; 30/09/2018
 39249                                  
 39250                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 39251                                  
 39252                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39253                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39254                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39255                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39256                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39257                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39258                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39259                                  
 39260                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39261                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 39262                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 39263                                  TPA:		dw 0			; LTPA	    (dw 0)	
 39264                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 39265                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 39266                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 39267                                  					; MYSEG1    (dw 0)	
 39268                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 39269                                  					; MYSEG2    (dw 0)	
 39270                                  		dw 0			; RESTEST   (dw 0)	
 39271                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 39272                                  
 39273                                  CHKDRV:		db 0
 39274                                  IFNOTFLAG:
 39275                                  FILTYP:
 39276                                  RDEOF:		db 0			; Misc flags
 39277                                  CURDRV:		db 0
 39278                                  PARM1:
 39279                                  Concat:		db 0
 39280                                  PARM2:
 39281                                  ArgC:		db 0
 39282                                  COMSW:		dw 0			; Switches between command and 1st arg
 39283                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 39284                                  ARG2S:					; Switches after 2nd arg		
 39285                                  DestSwitch:	dw 0
 39286                                  ARGTS:
 39287                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 39288                                  CFLAG:		db 0
 39289                                  DestClosed:
 39290                                  SPECDRV:	db 0
 39291                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 39292                                  NXTADD:		dw 0
 39293                                  FRSTSRCH:	db 0
 39294                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 39295                                  ;PerLine:	db 0			; entries/line u.b. DIR
 39296                                  LINCNT:		db 0
 39297                                  LINLEN:		db 0
 39298                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 39299                                  FILECNT:	dw 0			; file count u.b. DIR
 39300                                  ;FileSiz:	dd 0			; file size u.b. DIR
 39301                                  
 39302                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 39303                                  ;
 39304                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 39305                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 39306                                  
 39307                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 39308                                  
 39309                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 39310                                  DESTFCB2:
 39311                                  IDLEN:		db 0
 39312                                  ID:	  times	8  db 0
 39313                                  COM:	  times	3  db 0 
 39314                                  DEST:	  times 37 db 0
 39315                                  DESTNAME: times 11 db 0
 39316                                  DESTDIR:
 39317                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 39318                                  GOTOLEN:	; word
 39319                                  BWDBUF: 	; byte
 39320                                  EXEFCB: 	; word
 39321                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39322                                  
 39323                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39324                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39325                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39326                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39327                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39328                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39329                                  
 39330                                  SDIRBUF:  times 12 db 0	
 39331                                  _BITS:		dw 0
 39332                                  PATHCNT:	dw 0
 39333                                  PATHPOS:	dw 0
 39334                                  PATHSW:		dw 0
 39335                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 39336                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 39337                                  LINPERPAG:	db 0
 39338                                  		db 0
 39339                                  COMMA:		db 0			; flag set if +,, occurs
 39340                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 39341                                  
 39342                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 39343                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 39344                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 39345                                  
 39346                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 39347                                  STRING_PTR_1:	dw 0	   ; _4468h	
 39348                                  FILESIZE_L:	dw 0	   ; _446Ah		
 39349                                  FILESIZE_H:	dw 0	   ; _446Ch	
 39350                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 39351                                  
 39352                                  COPY_NUM:	dw 0
 39353                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 39354                                  CPYFLAG:	db 0
 39355                                  DIR_NUM:	dw 0
 39356                                  BYTES_FREE:	dw 0
 39357                                  		dw 0
 39358                                  MAJOR_VER_NUM:	dw 0
 39359                                  MINOR_VER_NUM:	dw 0
 39360                                  ONE_CHAR_VAL:	db 0
 39361                                  		;db 0
 39362                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 39363                                  VOL_DRV:	db 0
 39364                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 39365                                  
 39366                                  ROM_CALL:	db 0			; flag for rom function
 39367                                  ROM_IP:		dw 0
 39368                                  ROM_CS:		dw 0
 39369                                  
 39370                                  DestVars:
 39371                                  DestIsDir:	db 0
 39372                                  DestSiz:	db 0
 39373                                  DestTail:	dw 0
 39374                                  DestInfo:	db 0
 39375                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 39376                                  ENDDESTBUF:
 39377                                  
 39378                                  DESTHAND:	dw 0
 39379                                  DESTISDEV:	db 0
 39380                                  FIRSTDEST:	db 0
 39381                                  MELCOPY:	db 0
 39382                                  MELSTART:	dw 0
 39383                                  
 39384                                  SrcVars:
 39385                                  SrcIsDir:	db 0
 39386                                  SrcSiz:		db 0
 39387                                  SrcTail:	dw 0
 39388                                  SrcInfo:	db 0
 39389                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 39390                                  
 39391                                  SRCHAND:	dw 0
 39392                                  SRCISDEV:	db 0
 39393                                  
 39394                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 39395                                  
 39396                                  SRCPT:		dw 0
 39397                                  INEXACT:	db 0
 39398                                  		db 0 ; MSDOS 3.3 
 39399                                  NOWRITE:	db 0
 39400                                  BINARY:		db 0
 39401                                  WRITTEN:	dw 0
 39402                                  TERMREAD:	db 0
 39403                                  ASCII:		db 0
 39404                                  PLUS:		db 0
 39405                                  OBJCNT:		db 0			; Used in copy
 39406                                  CPDATE:		dw 0
 39407                                  CPTIME:		dw 0
 39408                                  
 39409                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 39410                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 39411                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39412                                  
 39413                                  BATHAND:	dw 0			; Batch handle
 39414                                  STARTEL:	dw 0
 39415                                  ELCNT:		db 0
 39416                                  ELPOS:		db 0
 39417                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39418                                  MSDOS 5.0
 39419                                  SKPDEL:
 39420                                  SOURCE:   times	11 db 0
 39421                                  
 39422                                  ext_entered:	db 0			;AN005;
 39423                                  
 39424                                  ;display_ioctl	db 0			;AN000; info level
 39425                                  ;		db 0			;AN000; reserved
 39426                                  ;		dw crt_ioctl_ln		;AN000; length of data
 39427                                  ;		dw 0			;AN000; control flags
 39428                                  ;display_mode:	db 0			;AN000; display mode, colors
 39429                                  ;		db 0			;AN000; reserved
 39430                                  ;		dw 0			;AN023; colors
 39431                                  ;		dw 0			;AN000; display width (PELS)
 39432                                  ;		dw 0			;AN000; display length (PELS)
 39433                                  ;display_width:	dw 0			;AN000; display width
 39434                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 39435                                  ;
 39436                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 39437                                  ;		dw 0			;AN000; info level
 39438                                  ;vol_serial:	dd 0			;AN000; volume serial number
 39439                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39440                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 39441                                  
 39442                                  EXPAND_STAR:	db 0
 39443                                  
 39444                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 39445                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 39446                                  ;append_exec:	db 0			;AN041; set if internal append executed
 39447                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 39448                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 39449                                  
 39450                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 39451                                  
 39452                                  ; Data declarations taken out of parse.asm
 39453                                  
 39454                                  ; MSDOS 6.0
 39455                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39456                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39457                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 39458                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39459                                  ;comptr		dw	?		; ptr into combuf
 39460                                  
 39461                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 39462                                  ARG:
 39463                                  ARG_ARGV:
 39464                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 39465                                  ARGV0_ARG_FLAGS:  db 0
 39466                                  ARGV0_ARGSTARTEL: dw 0
 39467                                  ARGV0_ARGLEN:	  dw 0
 39468                                  ARGV0_ARGSW_WORD: dw 0
 39469                                  ARGV0_OCOMPTR:	  dw 0
 39470                                  
 39471                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 39472                                  	  times 5 db 0
 39473                                  ARGV1_ARGSW_WORD: dw 0
 39474                                  		  dw 0
 39475                                  
 39476                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 39477                                  	  times 5 db 0
 39478                                  ARGV2_ARGSW_WORD: dw 0
 39479                                  		  dw 0
 39480                                  
 39481                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 39482                                  	
 39483                                  ARG_ARGVCNT:	dw 0
 39484                                  ARG_ARGSWINFO:	dw 0
 39485                                  
 39486                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 39487                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 39488                                  
 39489                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 39490                                  
 39491                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 39492                                  TPBUF:	times 128 db 0			; temporary buffer
 39493                                  LASTARG:	dw 0			; point at which to accumulate switch info
 39494                                  COMPTR:		dw 0			; ptr into combuf
 39495                                  
 39496                                  ; Data declarations taken out of path.asm
 39497                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 39498                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 39499                                  ;psep_char	DB	?			; '/' or '\'
 39500                                  ;search_best	DB	(?)			; best code, best filename so far
 39501                                  ;fname_max_len	equ	13
 39502                                  ;search_best_buf DB	fname_max_len DUP (?)
 39503                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 39504                                  ;search_error	DW	(?)			; address of error message to be printed
 39505                                  
 39506                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39507                                  
 39508                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 39509                                  
 39510                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 39511                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 39512                                  PATHINFO:
 39513                                  PATHINFO_0:	dw 0
 39514                                  PATHINFO_2:	dw 0
 39515                                  PATHINFO_4:	dw 0
 39516                                  PSEP_CHAR:	db 0
 39517                                  SEARCH_BEST:	db 0
 39518                                  ;FNAME_MAX_LEN equ 13
 39519                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 39520                                  SEARCH_CURDIR_BUF: times 64 db 0
 39521                                  SEARCH_ERROR:	dw 0
 39522                                  
 39523                                  ; Data declarations taken out of tbatch.asm
 39524                                  
 39525                                  ;if_not_count	DW	?
 39526                                  ;
 39527                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39528                                  ;
 39529                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39530                                  
 39531                                  ; 31/03/2023
 39532                                  STACK:		;LABEL	WORD
 39533                                  
 39534                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 39535                                  
 39536                                  IF_NOT_COUNT:	dw 0
 39537                                  ZFLAG:		db 0
 39538                                  	  times 256 db 0 	
 39539                                  STACK:
 39540                                  
 39541                                  ;INTERNATVARS	internat_block <>
 39542                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39543                                  ;
 39544                                  ;;		Buffer for DOS function 64h (Get extended country information)
 39545                                  ;;		subfunctions 2, 4, 6, or 7:
 39546                                  ;
 39547                                  ;CountryPtrInfo	label	byte
 39548                                  ;CountryPtrId	db	?
 39549                                  ;CountryPtr	dd	?
 39550                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39551                                  
 39552                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 39553                                  
 39554                                  INTERNATVARS:	
 39555                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 39556                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39557                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 39558                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 39559                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 39560                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 39561                                  BIT_FIELD:	db 0			; Bit values
 39562                                  					;   Bit 0 = 0 if currency symbol first
 39563                                  					;	  = 1 if currency symbol last
 39564                                  					;   Bit 1 = 0 if No space after currency symbol
 39565                                  					;	  = 1 if space after currency symbol
 39566                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 39567                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39568                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39569                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39570                                  					;  in pieces.
 39571                                  DATA_SEP:	db 0,0			; Data list separator character		
 39572                                  
 39573                                  		times 8 db 0
 39574                                  ;
 39575                                  ; Max size of the block returned by the INTERNATIONAL call
 39576                                  ;
 39577                                  INTERNAT_BLOCK_SIZE EQU	32
 39578                                  
 39579                                  BATLEN equ 32
 39580                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 39581                                  
 39582                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 39583                                  
 39584                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 39585                                  
 39586                                  BATBUFEND:	dw 0
 39587                                  
 39588                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 39589                                  
 39590                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 39591                                  
 39592                                  ; 18/04/2023
 39593                                  ; ----------------------------------------------------------------------------
 39594                                  ; 09/01/2023
 39595                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 39596                                  
 39597                                  %endif
 39598                                  
 39599                                  ;============================================================================
 39600                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39601                                  ;============================================================================
 39602                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39603                                  
 39604                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39605                                  
 39606                                  ;The TRANSPACE segment contains variable data that is considered
 39607                                  ;volatile between command cycles, and therefore is not included in the
 39608                                  ;transient checksum area. Contents of these variables MUST be
 39609                                  ;initialized before use, and must not be relied upon from command
 39610                                  ;cycle to command cycle.
 39611                                  ;
 39612                                  ;No constant data values should be stored here.
 39613                                  
 39614                                  ; ---------------------------------------------------------------------------
 39615                                  ; START OF UNITIALIZED DATA
 39616                                  ; ---------------------------------------------------------------------------
 39617                                  
 39618                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 39619                                  
 39620 000087D3 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39621 0000882A 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39622 00008881 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39623 00008904 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39624 00008987 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39625 000089CD 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39626 00008A50 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39627                                  
 39628                                  ; Variables passed up from resident	; in the Resident portion: (initial values)
 39629                                  HEADCALL:
 39630 00008AA3 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 39631 00008AA5 0000                    RESSEG:	dw 0			; MYSEG     (dw 0)
 39632 00008AA7 0000                    TPA:	dw 0			; LTPA	    (dw 0)
 39633                                  SWITCHAR:
 39634 00008AA9 00                      	db 0			; RSWITCHAR (db '-')
 39635                                  DIRCHAR:
 39636 00008AAA 00                      	db 0			; RDIRCHAR  (db '/')
 39637                                  EXEC_ADDR:
 39638 00008AAB 00000000                	dd 0			; 	    (dw EXT_EXEC)
 39639                                  				; MYSEG1    (dw 0)
 39640                                  RCH_ADDR:
 39641 00008AAF 00000000                	dd 0			;	    (dw TREMCHECK)
 39642                                  				; MYSEG2    (dw 0)
 39643                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
 39644                                  %if 0
 39645                                  	dw 0			; RESTEST   (dw 0)
 39646                                  %endif
 39647                                  
 39648                                  TRAN_TPA:
 39649 00008AB3 0000                    	dw 0			; RES_TPA   (dw 0)
 39650                                  
 39651 00008AB5 00                      CHKDRV:	db 0
 39652                                  IFNOTFLAG:
 39653                                  FILTYP:
 39654 00008AB6 00                      RDEOF:	db 0			; Misc flags
 39655 00008AB7 00                      CURDRV:	db 0
 39656                                  PARM1:
 39657 00008AB8 00                      Concat:	db 0
 39658                                  PARM2:
 39659 00008AB9 00                      ArgC:	db 0
 39660 00008ABA 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39661 00008ABC 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39662                                  ARG2S:				; Switches after 2nd arg
 39663                                  DestSwitch:
 39664 00008ABE 0000                    	dw 0
 39665                                  ARGTS:
 39666                                  AllSwitch:
 39667 00008AC0 0000                    	dw 0			; ALL switches except for COMSW
 39668 00008AC2 00                      CFLAG:	db 0
 39669                                  DestClosed:
 39670                                  SPECDRV:
 39671 00008AC3 00                      	db 0
 39672 00008AC4 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39673 00008AC6 0000                    NXTADD:	dw 0
 39674                                  FRSTSRCH:
 39675 00008AC8 00                      	db 0
 39676                                  ; 15/04/2023
 39677                                  LeftOnLine:
 39678 00008AC9 00                      	db 0			; entries left on line u.b. DIR
 39679                                  PerLine:
 39680 00008ACA 00                      	db 0			; entries/line u.b. DIR
 39681                                  
 39682                                  ; 14/08/2024
 39683                                  %if 0
 39684                                  LINCNT:	db 0
 39685                                  LINLEN:	db 0
 39686                                  %endif
 39687                                  
 39688                                  LeftOnPage:
 39689 00008ACB 0000                    	dw 0			; lines left on page u.b. DIR
 39690                                  FileCnt:
 39691 00008ACD 0000                    	dw 0			; file count u.b. DIR
 39692                                  FileSiz:
 39693 00008ACF 00000000                	dd 0			; file size u.b. DIR
 39694                                  
 39695                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39696                                  
 39697                                  FileCntTotal:
 39698 00008AD3 00000000                	dd 0			; total file count u.b. DIR
 39699                                  FileSizTotal:
 39700 00008AD7 00000000                	dd 0			; total file size u.b. DIR
 39701                                  
 39702                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39703                                  CHARBUF:
 39704 00008ADB 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39705                                  DESTFCB2:
 39706 00008B2B 00                      IDLEN:	db 0
 39707 00008B2C 00<rep 8h>              ID:	times	8  db 0
 39708 00008B34 00<rep 3h>              COM:	times	3  db 0
 39709 00008B37 00<rep 25h>             DEST:	times	37 db 0
 39710                                  DESTNAME:
 39711 00008B5C 00<rep Bh>              	times	11 db 0
 39712                                  DESTDIR:
 39713                                  DestFcb:
 39714 00008B67 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39715                                  GOTOLEN: ; word
 39716                                  BWDBUF:  ; byte
 39717                                  EXEFCB:  ; word
 39718 00008BAA 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39719                                  
 39720                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39721                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39722                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39723                                  DIRBUF_FDATE   equ DIRBUF+32  ; word
 39724                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39725                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39726                                  
 39727                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39728                                  SDIRBUF:
 39729 00008BF0 00<rep Ch>              	times 12 db 0	
 39730                                  _Bits:
 39731 00008BFC 0000                    	dw 0
 39732                                  PathCnt:
 39733 00008BFE 0000                    	dw 0
 39734                                  PathPos:
 39735 00008C00 0000                    	dw 0
 39736 00008C02 0000                    PathSw:	dw 0
 39737                                  AttrSpecified:
 39738 00008C04 00                      	db 0			; attribute bits u.b. DIR
 39739                                  AttrSelect:
 39740 00008C05 00                      	db 0			; attribute bits u.b. DIR
 39741 00008C06 00                      comma:	db 0			; flag set if +,, occurs
 39742                                  plus_comma:
 39743 00008C07 00                      	db 0			; flag set if +,, occurs
 39744                                  DirFlag:
 39745 00008C08 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39746                                  parse_last:
 39747 00008C09 0000                    	dw 0			;AN018; used to hold parsing position
 39748                                  system_cpage:
 39749 00008C0B 0000                    	dw 0			;AC001; used for CHCP variable
 39750                                  ; 03/08/2024
 39751                                  ;Arg_Buf:
 39752                                  ;	times 128 db 0
 39753                                  File_Size_Low:
 39754 00008C0D 0000                    	dw 0
 39755                                  File_Size_High:
 39756 00008C0F 0000                    	dw 0
 39757                                  string_ptr_2:
 39758 00008C11 0000                    	dw 0
 39759                                  Copy_num:
 39760 00008C13 0000                    	dw 0
 39761                                  cpyflag:
 39762 00008C15 00                      	db 0
 39763                                  Dir_Num:
 39764 00008C16 0000                    	dw 0
 39765                                  Bytes_Free:
 39766 00008C18 00000000                	dd 0
 39767                                  
 39768                                  Major_Ver_Num:
 39769 00008C1C 0000                    	dw 0
 39770                                  Minor_Ver_Num:
 39771 00008C1E 0000                    	dw 0
 39772                                  
 39773                                  One_Char_Val:
 39774 00008C20 00                      	db 0
 39775 00008C21 00                      	db 0
 39776                                  vol_drv:
 39777 00008C22 00                      	db 0
 39778                                  ROM_CALL:
 39779 00008C23 00                      	db 0			; flag for rom function
 39780 00008C24 0000                    ROM_IP:	dw 0
 39781 00008C26 0000                    ROM_CS:	dw 0
 39782                                  
 39783                                  DestVars:
 39784                                  DestIsDir:
 39785 00008C28 00                      	db 0
 39786                                  DestSiz:
 39787 00008C29 00                      	db 0
 39788                                  DestTail:
 39789 00008C2A 0000                    	dw 0
 39790                                  DestInfo:
 39791 00008C2C 00                      	db 0
 39792                                  DestBuf:
 39793 00008C2D 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39794                                  EndDestBuf:
 39795                                  DESTHAND:
 39796 00008C84 0000                    	dw 0
 39797                                  DESTISDEV:
 39798 00008C86 00                      	db 0
 39799                                  FIRSTDEST:
 39800 00008C87 00                      	db 0
 39801                                  MELCOPY:
 39802 00008C88 00                      	db 0
 39803                                  MELSTART:
 39804 00008C89 0000                    	dw 0
 39805                                  SrcVars:
 39806                                  SrcIsDir:
 39807 00008C8B 00                      	db 0
 39808 00008C8C 00                      SrcSiz:	db 0
 39809                                  SrcTail:
 39810 00008C8D 0000                    	dw 0
 39811                                  SrcInfo:
 39812 00008C8F 00                      	db 0
 39813                                  SrcBuf:
 39814 00008C90 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39815                                  SRCHAND:
 39816 00008CE7 0000                    	dw 0
 39817                                  SRCISDEV:
 39818 00008CE9 00                      	db 0
 39819                                  ScanBuf:
 39820 00008CEA 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39821                                  
 39822 00008D41 0000                    SRCPT:	dw 0
 39823                                  INEXACT:
 39824 00008D43 00                      	db 0
 39825                                  NOWRITE:
 39826 00008D44 00                      	db 0
 39827                                  BINARY:
 39828 00008D45 00                      	db 0
 39829                                  WRITTEN:
 39830 00008D46 0000                    	dw 0
 39831                                  TERMREAD:
 39832 00008D48 00                      	db 0
 39833 00008D49 00                      ASCII:	db 0
 39834 00008D4A 00                      PLUS:	db 0
 39835 00008D4B 00                      objcnt:	db 0			; Used in copy
 39836 00008D4C 0000                    CPDATE:	dw 0
 39837 00008D4E 0000                    CPTIME:	dw 0
 39838                                  
 39839                                  OFilePtr_Lo:
 39840 00008D50 0000                    	dw 0			; original file ptr for COPY when
 39841                                  OFilePtr_Hi:
 39842 00008D52 0000                    	dw 0			; 1st source is also destination
 39843                                  zflag:	; 10/08/2024 - PCDOS 7.1 COMMAND.COM
 39844 00008D54 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39845                                  BATHAND:
 39846 00008D55 0000                    	dw 0			; Batch handle
 39847                                  STARTEL:
 39848 00008D57 0000                    	dw 0
 39849 00008D59 00                      ELCNT:	db 0
 39850 00008D5A 00                      ELPOS:	db 0
 39851                                  
 39852                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39853                                  ; MSDOS 5.0
 39854                                  SKPDEL:
 39855 00008D5B 00<rep Bh>              SOURCE:	times 11 db 0
 39856                                  
 39857                                  ext_entered:
 39858 00008D66 00                      	db 0			;AN005;
 39859                                  
 39860                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39861                                  
 39862                                  Display_Ioctl:
 39863 00008D67 00                      	db 0			;AN000; info level
 39864 00008D68 00                      	db 0			;AN000; reserved
 39865 00008D69 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39866 00008D6B 0000                    	dw 0			;AN000; control flags
 39867                                  display_mode:
 39868 00008D6D 00                      	db 0			;AN000; display mode, colors
 39869 00008D6E 00                      	db 0			;AN000; reserved
 39870 00008D6F 0000                    	dw 0			;AN023; colors
 39871 00008D71 0000                    	dw 0			;AN000; display width (PELS)
 39872 00008D73 0000                    	dw 0			;AN000; display length (PELS)
 39873                                  display_width:
 39874 00008D75 0000                    	dw 0			;AN000; display width
 39875                                  LinPerPag:
 39876 00008D77 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39877                                  
 39878                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39879 00008D79 0000                    	dw 0			;AN000; info level
 39880                                  vol_serial:
 39881 00008D7B 00000000                	dd 0			;AN000; volume serial number
 39882                                  vol_label:
 39883 00008D7F 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39884 00008D8A 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39885                                  
 39886                                  expand_star:
 39887 00008D92 00                      	db 0
 39888                                  
 39889                                  msg_flag:
 39890 00008D93 00                      	db 0			;AN022; flag set if non-utility message issued
 39891                                  Msg_Numb:
 39892 00008D94 0000                    	dw 0			;AN022; set with extended error message issued
 39893                                  append_exec:
 39894 00008D96 00                      	db 0			;AN041; set if internal append executed
 39895                                  print_err_flag:
 39896 00008D97 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39897                                  subst_buffer:
 39898 00008D99 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39899                                  				;AN061;
 39900                                  ; 15/04/2023
 39901 00008DAF 00                      KPARSE:	db 0	; 3/3/KK	
 39902                                  
 39903                                  ; Data declarations taken out of parse.asm
 39904                                  
 39905                                  ; MSDOS 6.0
 39906                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39907                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39908                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39909                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39910                                  ;comptr		dw	?		; ptr into combuf
 39911                                  
 39912                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39913                                  ARG:
 39914                                  ARG_ARGV:
 39915                                  ARGV0_ARGPOINTER:
 39916 00008DB0 0000                    	dw 0	; ARGV[0]
 39917                                  ARGV0_ARG_FLAGS:
 39918 00008DB2 00                      	db 0
 39919                                  ARGV0_ARGSTARTEL:
 39920 00008DB3 0000                    	dw 0
 39921                                  ARGV0_ARGLEN:
 39922 00008DB5 0000                    	dw 0
 39923                                  ARGV0_ARGSW_WORD:
 39924 00008DB7 0000                    	dw 0
 39925                                  ARGV0_OCOMPTR:
 39926 00008DB9 0000                    	dw 0
 39927                                  ARGV1_ARGPOINTER:
 39928 00008DBB 0000                    	dw 0	; ARGV[1]	
 39929 00008DBD 00<rep 5h>              	times 5 db 0
 39930                                  ARGV1_ARGSW_WORD:
 39931 00008DC2 0000                    	dw 0
 39932 00008DC4 0000                    	dw 0
 39933                                  ARGV2_ARGPOINTER:
 39934 00008DC6 0000                    	dw 0	; ARGV[2]
 39935 00008DC8 00<rep 5h>              	times 5 db 0
 39936                                  ARGV2_ARGSW_WORD:
 39937 00008DCD 0000                    	dw 0
 39938 00008DCF 0000                    	dw 0
 39939 00008DD1 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39940                                  ARG_ARGVCNT:
 39941 00009070 0000                    	dw 0
 39942                                  ARG_ARGSWINFO:
 39943 00009072 0000                    	dw 0
 39944                                  ARG_ARGBUF:
 39945 00009074 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39946                                  ARG_ARGFORCOMBUF:
 39947 00009274 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39948                                  
 39949                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39950                                  ARGBUF_PTR:
 39951 000092F4 0000                    	dw 0			; index for argv[].argpointer
 39952                                  TPBUF:	;times 128 db 0		; temporary buffer
 39953                                  Arg_Buf:
 39954 000092F6 00<rep 80h>             	times 128 db 0	; 03/08/2024 (PCDOS 7.1 COMMAND.COM)
 39955                                  LASTARG:
 39956 00009376 0000                    	dw 0			; point at which to accumulate switch info
 39957 00009378 0000                    COMPTR:	dw 0			; ptr into combuf
 39958                                  
 39959                                  ; Data declarations taken out of path.asm
 39960                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39961                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39962                                  ;psep_char	DB	?		; '/' or '\'
 39963                                  ;search_best	DB	(?)		; best code, best filename so far
 39964                                  ;fname_max_len	equ	13
 39965                                  ;search_best_buf DB	fname_max_len DUP (?)
 39966                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39967                                  ;search_error	DW	(?)		; address of error message to be printed
 39968                                  
 39969                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39970                                  
 39971                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39972                                  
 39973 0000937A 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39974                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39975                                  pathinfo:
 39976                                  ;pathinfo_0:
 39977 000093A5 0000                    	dw 0
 39978                                  ;pathinfo_2:
 39979 000093A7 0000                    	dw 0
 39980                                  ;pathinfo_4:
 39981 000093A9 0000                    	dw 0
 39982                                  psep_char:
 39983 000093AB 00                      	db 0
 39984                                  search_best:
 39985 000093AC 00                      	db 0
 39986                                  FNAME_MAX_LEN equ 13
 39987                                  search_best_buf:
 39988 000093AD 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39989                                  search_curdir_buf:
 39990 000093BA 00<rep 40h>             	times 64 db 0
 39991                                  search_error:
 39992 000093FA 0000                    	dw 0
 39993                                  
 39994                                  ; Data declarations taken out of tbatch.asm
 39995                                  
 39996                                  ;if_not_count	DW	?
 39997                                  ;
 39998                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39999                                  ;
 40000                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 40001                                  
 40002                                  ; 31/03/2023
 40003                                  ;STACK:	;LABEL	WORD
 40004                                  
 40005                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 40006                                  
 40007                                  IF_NOT_COUNT:
 40008 000093FC 0000                    	dw 0
 40009                                  ; 10/08/2024
 40010                                  ;zflag:	db 0
 40011                                  align 2
 40012 000093FE 00<rep 100h>            	times 256 db 0 
 40013                                  	; 16/04/2023
 40014                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 40015                                  STACK:
 40016                                  
 40017                                  ;INTERNATVARS	internat_block <>
 40018                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 40019                                  
 40020                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 40021                                  INTERNATVARS:
 40022                                  		; (24+8 = 32 bytes)
 40023                                  DATE_TIME_FORMAT:
 40024 000094FE 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 40025                                  CURRENCY_SYM:
 40026 00009500 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 40027                                  THOUS_SEP:
 40028 00009505 0000                    	db 0,0			; Thousands separator 2 bytes
 40029                                  DECIMAL_SEP:
 40030 00009507 0000                    	db 0,0			; Decimal separator 2 bytes
 40031                                  DATE_SEP:
 40032 00009509 0000                    	db 0,0			; Date separator 2 bytes
 40033                                  TIME_SEP:
 40034 0000950B 0000                    	db 0,0			; Time separator 2 bytes
 40035                                  BIT_FIELD:
 40036 0000950D 00                      	db 0			; Bit values
 40037                                  				;   Bit 0 = 0 if currency symbol first
 40038                                  				;	  = 1 if currency symbol last
 40039                                  				;   Bit 1 = 0 if No space after currency symbol
 40040                                  				;	  = 1 if space after currency symbol
 40041                                  CURRENCY_CENTS:
 40042 0000950E 00                      	db 0			; Number of places after currency dec point
 40043                                  TIME_24:
 40044 0000950F 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 40045                                  MAP_CALL:
 40046 00009510 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 40047                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 40048                                  				;  in pieces.
 40049                                  DATA_SEP:
 40050 00009514 0000                    	db 0,0			; Data list separator character
 40051                                  
 40052 00009516 00<rep 8h>              	times 8 db 0
 40053                                  
 40054                                  ; Max size of the block returned by the INTERNATIONAL call
 40055                                  
 40056                                  INTERNAT_BLOCK_SIZE EQU	32
 40057                                  
 40058                                  ;;	Buffer for DOS function 64h (Get extended country information)
 40059                                  ;;	subfunctions 2, 4, 6, or 7:
 40060                                  ;
 40061                                  ;CountryPtrInfo	label	byte
 40062                                  ;CountryPtrId	db	?
 40063                                  ;CountryPtr	dd	?
 40064                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 40065                                  	
 40066                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 40067                                  CountryPtrInfo:
 40068                                  CountryPtrId:	
 40069 0000951E 00                      	db 0
 40070                                  CountryPtr:
 40071 0000951F 00000000                	dd 0
 40072                                  
 40073                                  OldCtrlCHandler:
 40074 00009523 00000000                	dd 0			; previous int 23 vector
 40075                                  
 40076                                  BATLEN equ 32
 40077                                  
 40078                                  BATBUFPOS:
 40079 00009527 0000                    	dw 0			; integer position in buffer of next byte
 40080                                  
 40081 00009529 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 40082                                  BATBUFEND:
 40083 00009549 0000                    	dw 0
 40084                                  TypeFilSiz:
 40085 0000954B 00000000                	dd 0			; stores size of file to be typed
 40086                                  
 40087                                  ; *****************************************************
 40088                                  ; EMG 4.00
 40089                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 40090                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 40091                                  ; *****************************************************
 40092                                  ;
 40093                                  ; COMMON PARSE OUTPUT BLOCKS
 40094                                  
 40095                                  ; Common output blocks for PARSE number, complex, or string values.
 40096                                  
 40097                                  PARSE1_OUTPUT:
 40098                                  PARSE1_TYPE:
 40099 0000954F 00                      	db 0			;AN000;  type
 40100                                  PARSE1_CODE:
 40101 00009550 00                      	db 0			;AN000;  return value
 40102                                  PARSE1_SYN:
 40103 00009551 0000                    	dw 0			;AN000;  es offset of synonym
 40104                                  PARSE1_ADDR:
 40105 00009553 00000000                	dd 0			;AN000;  numeric value / address
 40106                                  				;	 of string value
 40107                                  
 40108                                  ;  Common output block for PARSE date strings.
 40109                                  
 40110                                  DATE_OUTPUT:
 40111                                  DATE_TYPE:
 40112 00009557 00                      	db 0			;AN000;  type
 40113 00009558 00                      	db 0			;AN000;  return value
 40114 00009559 0000                    	dw 0			;AN000;  es offset of synonym
 40115                                  DATE_YEAR:
 40116 0000955B 0000                    	dw 0			;AN000;  year
 40117                                  DATE_MONTH:
 40118 0000955D 00                      	db 0			;AN000;  month
 40119                                  DATE_DAY:
 40120 0000955E 00                      	db 0			;AN000;  day
 40121                                  
 40122                                  ;  Common output block for PARSE time strings.
 40123                                  
 40124                                  TIME_OUTPUT:
 40125                                  TIME_TYPE:
 40126 0000955F 00                      	db 0			;AN000;  type
 40127 00009560 00                      	db 0			;AN000;  return value
 40128 00009561 0000                    	dw 0			;AN000;  es offset of synonym
 40129                                  TIME_HOUR:
 40130 00009563 00                      	db 0			;AN000;  hour
 40131                                  TIME_MINUTES:
 40132 00009564 00                      	db 0			;AN000;  minutes
 40133                                  TIME_SECONDS:
 40134 00009565 00                      	db 0			;AN000;  seconds
 40135                                  TIME_FRACTION:
 40136 00009566 00                      	db 0			;AN000;  hundredths
 40137                                  
 40138                                  ;  Common output block for PARSE drive specifier (one based drive number).
 40139                                  
 40140                                  DRIVE_OUTPUT:
 40141                                  DRIVE_TYPE:
 40142 00009567 00                      	db 0			;AN000;  type
 40143                                  DRIVE_VALUE:
 40144 00009568 00                      	db 0			;AN000;  return value
 40145 00009569 0000                    	dw 0			;AN000;  es offset of synonym
 40146                                  DRIVE_NUMBER:
 40147 0000956B 00                      	db 0			;AN000;  drive number
 40148 0000956C 000000                  	db 0,0,0		;AN000;  reserved
 40149                                  
 40150                                  	; 18/04/2023
 40151                                  	; 16/04/2023
 40152                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 40153                                  
 40154                                  ; ----------------------------------------------------------------------------
 40155                                  ; 20/04/2023
 40156                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
