

;
; ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
; º	This file is generated by The Interactive Disassembler (IDA)	    º
; º	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    º
; º			 Licensed to: Freeware version			    º
; ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
;
; Input	MD5   :	C2EA62CA46CEA5463CF1DDA84A239CC1

; File Name   :	C:\Users\Erdoğan\Desktop\COMMAND.COM
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-BBE5h Loaded length: BAE5h

		.386
		.model tiny

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure code
RESGROUP	segment	byte public 'CODE' use16
		assume cs:RESGROUP
		org 100h
		assume es:nothing, ss:nothing, ds:RESGROUP, fs:nothing,	gs:nothing

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; Attributes: thunk

		public StartCode
StartCode	proc near
		jmp	ConProc
StartCode	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
VersionByte	db 0
Int2f_Entry	dd MsgInt2fHandler	; ...
Int2e_Entry	dd Int_2e		; ...
Ctrlc_Entry	dd ContC		; ...
CritErr_Entry	dd DskErr		; ...
Exec_Entry	dd 0			; ...
RemCheck_Entry	dd 0			; ...
TrnLodCom1_Entry dd 0			; ...
LodCom_Entry	dd 0			; ...
MsgRetrv_Entry	dd 0			; ...
HeadFix_Entry	dd 0			; ...
UMBOff_Entry	dd 0			; ...
XMMCallAddr	dd 0			; ...
ComInHMA	db 0			; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int2f_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Int2f_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int2e_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Int2e_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ctrlc_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Ctrlc_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CritErr_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:CritErr_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Exec_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RemCheck_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:RemCheck_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TrnLodCom1_Trap:			; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:TrnLodCom1_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR ConProc

LodCom_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:LodCom_Entry
; END OF FUNCTION CHUNK	FOR ConProc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgRetrv_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:MsgRetrv_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HeadFix_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:HeadFix_Entry

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckA20	proc near		; ...
		pushf
		cmp	cs:ComInHMA, 0
		jz	short A20_on
		call	QueryA20
		jnb	short A20_on
		call	EnableA20

A20_on:					; ...
		popf
		retn
CheckA20	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Carousel_i2f_Hook:			; ...
		jmp	far ptr	Int2f_Trap

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


QueryA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 7
		call	cs:XMMCallAddr
		or	ax, ax
		pop	ax
		pop	bx
		jnz	short QA20_ON
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

QA20_ON:				; ...
		clc
		retn
QueryA20	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


EnableA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 5
		call	cs:XMMCallAddr
		or	ax, ax
		jz	short XMMerror
		pop	ax
		pop	bx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

XMMerror:				; ...
		jmp	short XMMerror
EnableA20	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Issue_Exec_Call:			; ...
		int	21h		; DOS -
		cli
		push	cs
		pop	ss
		assume ss:RESGROUP
		mov	sp, offset RStack ; 53Eh
		sti
		push	cs
		pop	ds
		pushf
		mov	al, cs:fInHigh
		test	al, 80h
		jz	short uhu10
		and	al, 7Fh
		call	cs:UMBOff_Entry

uhu10:					; ...
		and	cs:fInHigh, 7Fh
		popf
		jmp	Exec_Trap
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
BlkDevErrSubst	db 2			; ...
BlkDevErrRw	dw 0			; ...
		db 1
		dw offset DrvLet
DrvLet		db 'A'                  ; ...
CharDevErrSubst	db 2			; ...
CharDevErrRw	dw 0			; ...
		db 2
CharDevErrDev	dw offset DevName
DevName		db 8 dup(0)		; ...
		db 0
NeedVolSubst	db 2			; ...
		dw offset VolName
		db 3
		dw offset VolSer+2
		db 3
		dw offset VolSer
VolName		db 11 dup(0)		; ...
		db 0
VolSer		dd 0			; ...
CDevAt		db 0			; ...
BadFatSubst	db 1			; ...
		dw offset DrvLet
PutBackSubst	db 2			; ...
PutBackComSpec	dw 0			; ...
		db 1
		dw offset PutBackDrv
PutBackDrv	db 20h			; ...
ExecErrSubst	db 2			; ...
		dw offset SafePathBuffer
NeedVol		dd 0			; ...
ErrType		db 0			; ...
Int_2e_Ret	dd 0			; ...
Save_Pdb	dw 0			; ...
Parent		dw 0			; ...
OldTerm		dw 2 dup(0)		; ...
ErrCd_24	dw 0			; ...
Handle01	dw 0			; ...
Loading		db 0			; ...
Batch		dw 0			; ...
ComSpec		db 64 dup(0)		; ...
ComSpec_End	dw 0			; ...
Trans		dw offset COMMAND	; ...
TrnSeg		dw 0			; ...
TrnMvFlg	db 0			; ...
In_Batch	db 0			; ...
Batch_Abort	db 0			; ...
ComDrv		db 0			; ...
MemSiz		dw 0			; ...
Sum		dw 0			; ...
ExtCom		db 1			; ...
RetCode		dw 0			; ...
Crit_Err_Info	db 0			; ...
EchoFlag	db 1			; ...
Suppress	db 1			; ...
Io_Save		dw 0			; ...
RestDir		db 0			; ...
PermCom		db 0			; ...
SingleCom	dw 0			; ...
VerVal		dw 0FFFFh		; ...
fFail		db 0			; ...
IfFlag		db 0			; ...
ForFlag		db 0			; ...
ForPtr		dw 0			; ...
Nest		dw 0			; ...
Call_Flag	db 0			; ...
Call_Batch_Flag	db 0			; ...
Next_Batch	dw 0			; ...
NullFlag	db 0			; ...
FUCase_Addr	db 5 dup(0)		; ...
Crit_Msg_Off	dw 0			; ...
Crit_Msg_Seg	dw 0			; ...
Dbcs_Vector_Addr dw 2 dup(0)		; ...
Append_State	dw 0			; ...
Append_Flag	db 0			; ...
Re_Out_App	db 0			; ...
Re_OutStr	db 80 dup(0)		; ...
InitFlag	db 1			; ...
PipeFlag	db 0			; ...
PipeFiles	db 0			; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR ConProc

EndInit:				; ...
		push	ds
		push	es
		push	cs
		pop	ds
		mov	dx, TrnSize
		mov	ax, OldEnv
		mov	bx, EnvSiz
		mov	cx, UsedEnv
		push	ax
		push	bx
		push	cx
		mov	bx, ds
		mov	es, bx
		assume es:RESGROUP
		mov	bx, ResSize
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		cmp	PermCom, 1
		jnz	short adjust_env
		cmp	Batch, 0
		jz	short adjust_env
		mov	bx, 4
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short adjust_env
		mov	es, ax
		assume es:nothing
		xor	di, di
		xor	si, si
		push	ds
		mov	ds, Batch
		mov	cx, 33
		add	cx, 16
		cld
		rep movsb
		pop	ds
		mov	cx, es
		mov	es, Batch
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	Batch, cx

adjust_env:				; ...
		pop	cx
		pop	bx
		pop	bp
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		mov	EnvirSeg, ax
		mov	ds:2Ch,	ax	; [PDB.ENVIRON]
		mov	es, ax
		push	ds
		mov	ds, bp
		xor	si, si
		mov	di, si
		cld
		rep movsb
		pop	ds
		cmp	AllocedEnv, 0
		jnz	short no_free
		mov	es, bp
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

no_free:				; ...
		mov	TrnMvFlg, 1
		push	es
		mov	si, 2320h	; mov si,TRANSTART (2320h)
		mov	di, 0
		mov	cx, 98C5h	; TRANSIENT portion size
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		cmp	bx, dx
		jb	short nomem_err
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		push	ax
		add	ax, bx
		sub	ax, dx
		mov	TrnSeg,	ax
		mov	es, ax
		pop	ax
		add	si, cx
		dec	si
		add	di, cx
		dec	di
		std
		rep movsb
		cld
		mov	es, ax
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	InitFlag, 0
		pop	es
		pop	ds
		jmp	LodCom_Trap
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nomem_err:				; ...
		jmp	Alloc_error
; END OF FUNCTION CHUNK	FOR ConProc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EndCodeInit	db 84 dup(0)		; db (EndPipe-EndCodeInit) dup(0)
InPipePtr	dw 320h			; ...
					; offset Pipe1 (= EndInit)
OutPipePtr	dw 36Fh			; ...
					; offset Pipe2 (= EndInit+79)
EnvirSeg	dw 0			; ...
Com_Ptr		dw 80h,	0		; ...
Com_Fcb1	dw 5Ch,	0		; ...
Com_Fcb2	dw 6Ch,	0		; ...
TranVars	dw offset HeadFix_Trap	; ...
MySeg		dw 0			; ...
LTpa		dw 0			; ...
RSwitChar	db '/'                  ; ...
RDirChar	db '\'                  ; ...
		dw offset Issue_Exec_Call
MySeg1		dw 0			; ...
		dw offset RemCheck_Trap
MySeg2		dw 0			; ...
ResTest		dw 0
Res_Tpa		dw 0			; ...
OldErrNo	dw 0			; ...
SafePathBuffer	db 80 dup(0)		; ...
Int2fHandler	dw 2 dup(0)		; ...
ResMsgEnd	dw 0			; ...
ResSize		dw 0			; ...
		db 125 dup(0)
RStack		dw 0			; ...
fInHigh		db 0			; ...
ABORT_CHAR	db 'A'                  ; ...
RETRY_CHAR	db 'R'                  ; ...
IGNORE_CHAR	db 'I'                  ; ...
FAIL_CHAR	db 'F'                  ; ...
YES_CHAR	db 'Y'                  ; ...
NO_CHAR		db 'N'                  ; ...
REQ_ABORT	db 5			; ...
		db 'Abort'
REQ_RETRY	db 7			; ...
		db ', Retry'
REQ_IGNORE	db 8			; ...
		db ', Ignore'
REQ_FAIL	db 6			; ...
		db ', Fail'
REQ_END		db 1			; ...
		db '?'
MREAD		db 8			; ...
		db 'reading'
		db 0
MWRITE		db 8			; ...
		db 'writing'
		db 0
MDRIVE		db 14			; ...
		db ' %1 drive %2',0Dh,0Ah
MDEVICE		db 15			; ...
		db ' %1 device %2',0Dh,0Ah
MVOLSERIAL	db 38			; ...
		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
BADFATMSG	db 37			; ...
		db 'File allocation table bad, drive %1',0Dh,0Ah
COMBAD		db 21			; ...
		db 'Invalid COMMAND.COM',0Dh,0Ah
PUTBACKMSG	db 33			; ...
		db 'Insert disk with %1 in drive %2',0Dh,0Ah
PROMPT		db 33			; ...
		db 'Press any key to continue . . .',0Dh,0Ah
ENDBATMES	db 28			; ...
		db 0Dh,0Ah
		db 'Terminate batch job (Y/N)?'
EXECEMES	db 19			; ...
		db 'Cannot execute %1',0Dh,0Ah
EXEBAD		db 19			; ...
		db 'Error in EXE file',0Dh,0Ah
TOOBIG		db 34			; ...
		db 'Program too big to fit in memory',0Dh,0Ah
NOHANDMES	db 22			; ...
		db 0Dh,0Ah
		db 'No free file handles'
RBADNAM		db 26			; ...
		db 'Bad Command or file name',0Dh,0Ah
ACCDEN		db 14			; ...
		db 'Access denied '
BMEMMES		db 25			; ...
		db 0Dh,0Ah
		db 'Memory allocation error'
HALTMES		db 38			; ...
		db 0Dh,0Ah
		db 'Cannot load COMMAND, system halted',0Dh,0Ah
FRETMES		db 33			; ...
		db 0Dh,0Ah
		db 'Cannot start COMMAND, exiting',0Dh,0Ah
PATRICIDE	db 46			; ...
		db 0Dh,0Ah
		db 'Top level process aborted, cannot continue',0Dh,0Ah
NEWLINE		db 2			; ...
		db 0Dh,	0Ah
MsgPtrLists	dd 10C8Ch		; ...
		dw offset PARSMSGPTRS	; parse	error messages
		dw 1
		dw offset EXTMSGPTRS	; extended/critical error messages
		dw 1
		dw 0			; File system error messages
		dw 0			; are not supported.
		dw offset MsgRetrv_Trap
MySeg3		dw 0			; ...
CRMSG0		db 19			; ...
		db 'Write protect error'
CRMSG1		db 12			; ...
		db 'Invalid unit'
CRMSG2		db 9			; ...
		db 'Not ready'
CRMSG3		db 22			; ...
		db 'Invalid device request'
CRMSG4		db 10			; ...
		db 'Data error'
CRMSG5		db 33			; ...
		db 'Invalid device request parameters'
CRMSG6		db 10			; ...
		db 'Seek error'
CRMSG7		db 18			; ...
		db 'Invalid media type'
CRMSG8		db 16			; ...
		db 'Sector not found'
CRMSG9		db 26			; ...
		db 'Printer out of paper error'
CRMSG10		db 17			; ...
		db 'Write fault error'
CRMSG11		db 16			; ...
		db 'Read fault error'
CRMSG12		db 15			; ...
		db 'General failure'
CRMSG13		db 17			; ...
		db 'Sharing violation'
CRMSG14		db 14			; ...
		db 'Lock violation'
CRMSG15		db 19			; ...
		db 'Invalid disk change'
CRMSG16		db 15			; ...
		db 'FCB unavailable'
CRMSG17		db 25			; ...
		db 'System resource exhausted'
CRMSG18		db 18			; ...
		db 'Code page mismatch'
CRMSG19		db 12			; ...
		db 'Out of input'
CRMSG20		db 23			; ...
		db 'Insufficient disk space'
CRITMSGPTRS	dw offset CRMSG0	; ...
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
PAERRMSG0	db 19			; ...
		db 'Too many parameters'
PAERRMSG1	db 26			; ...
		db 'Required parameter missing'
PAERRMSG2	db 14			; ...
		db 'Invalid switch'
PAERRMSG3	db 15			; ...
		db 'Invalid keyword'
PAERRMSG4	db 1			; ...
		db 20h
PAERRMSG5	db 36			; ...
		db 'Parameter value not in allowed range'
PAERRMSG6	db 27			; ...
		db 'Parameter value not allowed'
PAERRMSG7	db 27			; ...
		db 'Parameter value not allowed'
PAERRMSG8	db 28			; ...
		db 'Parameter format not correct'
PAERRMSG9	db 17			; ...
		db 'Invalid parameter'
PAERRMSG10	db 29			; ...
		db 'Invalid parameter combination'
PARSMSGPTRS	dw offset PAERRMSG0	; ...
		dw offset PAERRMSG1
		dw offset PAERRMSG2
		dw offset PAERRMSG3
		dw offset PAERRMSG4
		dw offset PAERRMSG5
		dw offset PAERRMSG6
		dw offset PAERRMSG7
		dw offset PAERRMSG8
		dw offset PAERRMSG9
		dw offset PAERRMSG10
INVLFUNCT	db 16			; ...
		db 'Invalid function'
FNOTFOUND	db 14			; ...
		db 'File not found'
PNOTFOUND	db 14			; ...
		db 'Path not found'
TOOMANYOF	db 19			; ...
		db 'Too many open files'
ACCDENIED	db 14			; ...
		db 'Access denied '
INVHANDLE	db 14			; ...
		db 'Invalid handle'
MEMCBDEST	db 31			; ...
		db 'Memory control blocks destroyed'
INSUFFMEM	db 19			; ...
		db 'Insufficient memory'
INVMEMBLA	db 28			; ...
		db 'Invalid memory block address'
INVENVIRO	db 19			; ...
		db 'Invalid Environment'
INVFORMAT	db 14			; ...
		db 'Invalid format'
INVFNPARM	db 26			; ...
		db 'Invalid function parameter'
INVLDDATA	db 12			; ...
		db 'Invalid data'
INVDRVSPC	db 27			; ...
		db 'Invalid drive specification'
ATRCURDIR	db 35			; ...
		db 'Attempt to remove current directory'
NOTSAMDEV	db 15			; ...
		db 'Not same device'
NOMOREFIL	db 13			; ...
		db 'No more files'
FILEXISTS	db 11			; ...
		db 'File exists'
CANTMKDIR	db 27			; ...
		db 'Cannot make directory entry'
FAILINT24	db 14			; ...
		db 'Fail on INT 24'
TOOMANYRD	db 21			; ...
		db 'Too many redirections'
DUPLREDIR	db 21			; ...
		db 'Duplicate redirection'
INVPASSWD	db 16			; ...
		db 'Invalid password'
INVLDPARM	db 17			; ...
		db 'Invalid parameter'
NETDATFAU	db 18			; ...
		db 'Network data fault'
FNOSUPNET	db 33			; ...
		db 'Function not supported by network'
RSCNOTINS	db 39			; ...
		db 'Required system component not installed'
EXTMSGPTRS	dw offset INVLFUNCT	; ...
		dw offset FNOTFOUND
		dw offset PNOTFOUND
		dw offset TOOMANYOF
		dw offset ACCDENIED
		dw offset INVHANDLE
		dw offset MEMCBDEST
		dw offset INSUFFMEM
		dw offset INVMEMBLA
		dw offset INVENVIRO
		dw offset INVFORMAT
		dw offset INVFNPARM
		dw offset INVLDDATA
		dw 0
		dw offset INVDRVSPC
		dw offset ATRCURDIR
		dw offset NOTSAMDEV
		dw offset NOMOREFIL
		dw offset CRMSG0
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
		db 80 dup(0)
		dw offset FILEXISTS
		dw 0
		dw offset CANTMKDIR
		dw offset FAILINT24
		dw offset TOOMANYRD
		dw offset DUPLREDIR
		dw offset INVPASSWD
		dw offset INVLDPARM
		dw offset NETDATFAU
		dw offset FNOSUPNET
		dw offset RSCNOTINS
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Err:				; ...
		mov	bx, offset RBADNAM
		cmp	al, 2
		jz	short GotExecEMes
		mov	bx, offset TOOBIG
		cmp	al, 8
		jz	short GotExecEMes
		mov	bx, offset EXEBAD
		cmp	al, 0Bh
		jz	short GotExecEMes
		mov	bx, offset ACCDEN
		cmp	al, 5
		jz	short GotExecEMes
		mov	bx, offset EXECEMES
		mov	si, offset ExecErrSubst

GotExecEMes:				; ...
		mov	dx, bx
		call	RPrint
		jmp	short NoExec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Ret:
		jb	short Exec_Err

Exec_Wait:				; ...
		mov	ah, 4Dh
		int	21h		; DOS -	2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
		mov	RetCode, ax

NoExec:					; ...
		jmp	LodCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ContC:					; ...
		pop	ds
		test	InitFlag, 1
		jz	short NotAtInit
		test	InitFlag, 2
		jz	short CmdIret
		pop	ds
		jmp	init_contc_specialcase
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmdIret:				; ...
		pop	ds
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotAtInit:				; ...
		test	InitFlag, 4
		jz	short NotInit
		cmp	ah, 1
		jb	short CmdIret
		cmp	ah, 12
		ja	short CmdIret
		pop	ds
		add	sp, 6
		stc
		retf	2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotInit:				; ...
		or	InitFlag, 4
		sti
		pop	ax
		mov	ax, SingleCom
		or	ax, ax
		jnz	short NoReset
		push	ax
		mov	ah, 0Dh
		int	21h		; DOS -	DISK RESET
		pop	ax

NoReset:				; ...
		test	Batch, 0FFFFh
		jz	short ContCTerm
		or	ax, ax
		jnz	short ContCTerm
		call	SavHand
		call	AskEnd
		jnb	short ContBatch
		mov	cl, EchoFlag
		push	bx

ClearBatch:				; ...
		mov	es, Batch
		mov	di, 20h
		mov	bx, es:5
		cmp	bx, 0
		jz	short No_Bat_For
		push	es
		mov	es, bx
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

No_Bat_For:				; ...
		mov	cl, es:1
		mov	bx, es:3
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	Batch, bx
		dec	Nest
		jnz	short ClearBatch
		pop	bx
		mov	EchoFlag, cl
		mov	PipeFlag, 0

ContBatch:				; ...
		call	crlf
		call	RestHand

ContCTerm:				; ...
		xor	ax, ax
		mov	bp, ax
		mov	IfFlag,	al
		mov	ForFlag, al
		call	ResPipeOff
		cmp	SingleCom, ax
		jz	short NoSetSing
		mov	SingleCom, 0FFFFh

NoSetSing:				; ...
		and	InitFlag, 0FBh
		cmp	ExtCom,	al
		jnz	short DoDAb
		jmp	LodCom1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoDAb:					; ...
		stc
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ResPipeOff	proc near		; ...
		push	ax
		xor	ax, ax
		xchg	al, PipeFlag
		or	al, al
		jz	short NoPipePop
		shr	EchoFlag, 1

NoPipePop:				; ...
		pop	ax
		retn
ResPipeOff	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR alloc_env

BadMemErr:				; ...
		mov	dx, offset BMEMMES

FatalC:					; ...
		call	RPrint
		cmp	PermCom, 0
		jz	short FatalRet
		cmp	SingleCom, 0
		jnz	short FatalRet
		mov	dx, offset HALTMES
		call	RPrint
		sti

Stall:					; ...
		jmp	short Stall
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FatalRet:				; ...
		mov	dx, offset FRETMES
		call	RPrint

FatalRet2:				; ...
		cmp	PermCom, 0
		jnz	short Ret_2e
		mov	ax, Parent
		mov	ds:16h,	ax	; [PDB.PARENT_PID]
		mov	ax, OldTerm
		mov	ds:0Ah,	ax	; [PDB.EXIT]
		mov	ax, OldTerm+2
		mov	ds:0Ch,	ax	; [PDB.EXIT+2]
		mov	ax, 4C00h
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ret_2e:					; ...
		mov	SingleCom, 0
		mov	es, Res_Tpa
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	bx, Save_Pdb
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ax, RetCode
		cmp	ExtCom,	0
		jnz	short GotECode
		xor	ax, ax

GotECode:				; ...
		mov	ExtCom,	1
		jmp	Int_2e_Ret
; END OF FUNCTION CHUNK	FOR alloc_env
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int_2e:					; ...
		pop	ds
		pop	ax
		pop	word ptr Int_2e_Ret
		pop	word ptr Int_2e_Ret+2
		add	sp, 2
		push	ds
		pop	es
		assume es:RESGROUP
		mov	ds, ax
		mov	di, 80h
		mov	cx, 64
		rep movsw
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	es:Save_Pdb, bx
		mov	ah, 50h
		push	es
		pop	ds
		mov	bx, ds
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	SingleCom, 81h ; ''
		mov	ExtCom,	1
		push	ds
		push	ds

LodCom:					; ...
		pop	ds
		add	sp, 2
		cmp	ExtCom,	0
		jnz	short LodCom0
		jmp	LodCom1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LodCom0:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		call	SetSize
		add	ax, 20h
		cmp	bx, ax
		jnb	short MemOk

BadMemErrJ:				; ...
		jmp	BadMemErr

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetSize		proc near		; ...
		mov	ax, 98D4h	; TRANSPACEEND+15
		mov	cl, 4
		shr	ax, cl
		retn
SetSize		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MemOk:					; ...
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short BadMemErrJ
		mov	ExtCom,	0
		mov	Res_Tpa, ax
		and	ax, 0F000h
		add	ax, 1000h
		jb	short Bad_Tpa
		mov	dx, Res_Tpa
		add	dx, bx
		cmp	dx, ax
		jbe	short Bad_Tpa
		sub	dx, ax
		cmp	dx, 1000h
		jnb	short LTpaSet

Bad_Tpa:				; ...
		mov	ax, Res_Tpa

LTpaSet:				; ...
		mov	LTpa, ax
		mov	ax, Res_Tpa
		add	bx, ax
		mov	MemSiz,	bx
		call	SetSize
		sub	bx, ax
		cmp	bx, TrnSeg
		jz	short LodCom1
		mov	cx, 98C5h
		ja	short mov_down
		xor	si, si
		mov	di, si
		cld
		jmp	short copy_trans
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mov_down:				; ...
		mov	si, cx
		dec	si
		mov	di, si
		std

copy_trans:				; ...
		push	ds
		push	es
		mov	es, bx
		assume es:nothing
		mov	ds, TrnSeg
		rep movsb
		cld
		pop	es
		pop	ds
		mov	TrnSeg,	bx

LodCom1:				; ...
		mov	ax, ds
		mov	ss, ax
		mov	sp, offset RStack ; mov	sp,offset DATARES:RStack
		call	HeadFix
		xor	bp, bp
		mov	ax, 0FFFFh
		xchg	ax, VerVal
		cmp	ax, 0FFFFh
		jz	short NoSetVer
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NoSetVer:				; ...
		cmp	SingleCom, 0FFFFh
		jnz	short NoSng
		jmp	FatalRet2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoSng:					; ...
		call	ChkSum
		cmp	dx, Sum
		jz	short HavCom

Bogus_Com:
		mov	Loading, 1
		call	LoadCom

ChkSame:				; ...
		call	ChkSum
		cmp	dx, Sum
		jz	short HavCom

Also_Bogus:
		call	WrongCom
		jmp	short ChkSame
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HavCom:					; ...
		mov	Loading, 0
		mov	si, offset TranVars ; offset DATARES:TranVars
		mov	di, offset HEADCALL ; offset TRANGROUP:HeadCall
		mov	es, TrnSeg
		cld
		mov	cx, offset OldErrNo ; offset TranVarEnd
		sub	cx, si
		rep movsb
		mov	ax, MemSiz
		mov	ds:2, ax	; [PDB.BLOCK_LEN]

TJmp:
		jmp	dword ptr Trans
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRemCheck:
		pop	ds
		add	sp, 2
		call	RemCheck
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RemCheck	proc near		; ...
		push	ax
		push	bx
		mov	bx, ax
		mov	ax, 4408h
		int	21h		; DOS -	2+ - IOCTL -
		jnb	short rcCont
		or	ax, ax
		jmp	short ResRegs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rcCont:					; ...
		and	ax, 1
		not	ax

ResRegs:				; ...
		pop	bx
		pop	ax
		retn
RemCheck	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

THeadFix:
		pop	ds
		add	sp, 2
		call	HeadFix
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


HeadFix		proc near		; ...
		call	SetVect
		xor	bx, bx
		mov	cx, Io_Save
		mov	dx, ds:18h	; [PDB.JFN_TABLE]
		cmp	cl, dl
		jz	short Chk1
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ds:18h,	cl

Chk1:					; ...
		inc	bx
		cmp	ch, dh
		jz	short ChkOtherHand
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ds:19h,	ch

ChkOtherHand:				; ...
		add	bx, 4
		mov	cx, 15		; FILPERPROC-5

CloseLoop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	CloseLoop
		cmp	Append_Flag, 0FFh
		jnz	short Append_Fix_End
		mov	ax, 0B707h
		mov	bx, Append_State
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		mov	Append_Flag, 0

Append_Fix_End:				; ...
		retn
HeadFix		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SavHand		proc near		; ...
		push	bx
		push	ax
		push	es
		push	ds
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	ds, bx
		lds	bx, ds:34h	; [PDB.JFN_Pointer]
		mov	ax, [bx]
		pop	es
		push	es
		mov	es:Handle01, ax
		mov	al, es:1Ah	; [es:PDB.JFN_TABLE+2]
		mov	ah, al
		mov	[bx], ax
		pop	ds
		pop	es
		pop	ax
		pop	bx
		retn
SavHand		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GetComDsk2:				; ...
		call	GetComDsk
		jmp	LodCom1

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RestHand	proc near		; ...
		push	ds
		push	bx
		push	ax
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	ax, Handle01
		mov	ds, bx
		lds	bx, ds:34h	; [PDB.JFN_Pointer]
		mov	[bx], ax
		pop	ax
		pop	bx
		pop	ds
		retn
RestHand	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR GetComDsk

Hopeless:				; ...
		mov	dx, offset COMBAD ; offset DATARES:ComBad
		jmp	FatalC
; END OF FUNCTION CHUNK	FOR GetComDsk

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetComDsk	proc near		; ...

; FUNCTION CHUNK AT 1092 SIZE 00000006 BYTES

		mov	al, ComDrv
		call	RemCheck
		jnz	short Hopeless

GetComDsk3:
		cmp	dx, offset COMBAD
		jnz	short GetComDsk4
		mov	dx, offset COMBAD
		call	RPrint

GetComDsk4:				; ...
		cmp	PutBackDrv, 0
		jnz	short Users_Drive
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'
		mov	PutBackDrv, al

Users_Drive:				; ...
		mov	dx, offset PUTBACKMSG
		mov	si, offset PutBackSubst
		call	RPrint
		mov	dx, offset PROMPT ; "Press any key to continue"
		call	RPrint
		call	GetRawFlushedByte
		retn
GetComDsk	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetRawFlushedByte proc near		; ...
		mov	ax, 0C07h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.

LoadCom_retn:				; ...
		retn
GetRawFlushedByte endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadCom		proc near		; ...
		inc	bp
		mov	dx, offset ComSpec
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnb	short ReadCom
		cmp	ax, 4
		jnz	short TryDoOpen
		mov	dx, offset NOHANDMES
		jmp	FatalC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TryDoOpen:				; ...
		call	GetComDsk
		jmp	short LoadCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ReadCom:				; ...
		mov	bx, ax
		mov	dx, 2320h	; mov dx,offset	RESGROUP:TranStart
		xor	cx, cx
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short WrongCom1
		mov	cx, 97C5h	; mov cx,offset	TRANGROUP:TranSpaceEnd - 100h
		push	ds
		mov	ds, TrnSeg
		mov	dx, 100h
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds

WrongCom1:				; ...
		pushf
		push	ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		popf
		jb	short WrongCom
		cmp	ax, cx
		jz	short LoadCom_retn
LoadCom		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


WrongCom	proc near		; ...
		mov	dx, offset COMBAD
		call	GetComDsk
		jmp	short LoadCom
WrongCom	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ChkSum		proc near		; ...
		push	ds
		mov	ds, TrnSeg
		mov	si, 100h
		mov	cx, 87C2h	; offset TRANGROUP:TranDataEnd - 100h
		cld
		shr	cx, 1
		xor	dx, dx

Chk:					; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Chk
		pop	ds
		retn
ChkSum		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetVect		proc near		; ...
		mov	dx, offset LodCom_Trap
		mov	ax, 2522h
		mov	ds:0Ah,	dx	; [PDB.EXIT]
		mov	word ptr ds:0Ch, ds ; [PDB.EXIT+2]
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, offset Ctrlc_Trap
		inc	al
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, offset CritErr_Trap
		inc	al
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		retn
SetVect		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TrnLodCom1:
		pop	ds
		add	sp, 2
		jmp	LodCom1

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


AskEnd		proc near		; ...
		mov	dx, offset ENDBATMES
		call	RPrint
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	CharToUpper
		cmp	al, NO_CHAR
		jz	short aeRet
		cmp	al, YES_CHAR
		jnz	short AskEnd
		stc

aeRet:					; ...
		retn
AskEnd		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DskErr:					; ...
		pop	ds
		pop	RStack		; pop word [OldDS]
		sti
		push	es
		push	si
		push	cx
		push	di
		push	cx
		push	ax
		push	ds
		pop	es
		assume es:RESGROUP
		mov	ds, bp
		mov	ax, [si+4]
		mov	es:CDevAt, ah
		mov	di, offset DevName
		mov	cx, 8
		add	si, 10
		cld
		rep movsb
		pop	ax
		pop	cx
		pop	di
		push	es
		pop	ds
		call	SavHand
		push	dx
		call	crlf
		pop	dx
		mov	Crit_Err_Info, ah
		add	al, 'A'
		mov	DrvLet,	al
		test	ah, 80h
		jz	short NoHardE
		test	CDevAt,	80h
		jnz	short NoHardE
		jmp	FatErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoHardE:				; ...
		mov	si, offset MREAD
		test	ah, 1
		jz	short SavMes
		mov	si, offset MWRITE

SavMes:					; ...
		mov	OldErrNo, di
		push	es
		push	ds
		push	bp
		push	si
		push	dx
		push	cx
		push	bx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	bp
		pop	ds
		mov	word ptr NeedVol, di
		mov	word ptr NeedVol+2, es
		pop	es
		assume es:nothing
		xor	ah, ah
		mov	di, ax
		sub	di, 13h		; ERROR_WRITE_PROTECT
		jnb	short HavCod
		mov	di, 0Ch		; ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT

HavCod:					; ...
		mov	ErrType, 0
		cmp	di, 10h		; ERROR_FCB_UNAVAILABLE	- ERROR_WRITE_PROTECT
		jz	short SetStyle
		cmp	di, 11h		; ERROR_SHARING_BUFFER_EXCEEDED	- ERROR_WRITE_PROTECT
		jnz	short GotStyle

SetStyle:				; ...
		mov	ErrType, 1

GotStyle:				; ...
		mov	ErrCd_24, di
		cmp	di, 14h		; ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
		jbe	short NormalError
		mov	di, ax
		mov	ax, 500h
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh
		jnz	short NoHandler
		push	bx
		mov	bx, di
		mov	ax, 501h
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		pop	bx
		jb	short NoHandler
		mov	ErrType, al
		push	ds
		push	es
		pop	ds
		mov	dx, di
		mov	cx, 0FFFFh
		xor	al, al
		cld
		repne scasb
		mov	byte ptr [di-1], '$'
		mov	ah, 9
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		mov	byte ptr [di-1], 0
		pop	ds
		jmp	short CheckErrType
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoHandler:				; ...
		mov	ErrType, 0
		mov	di, OldErrNo
		mov	ErrCd_24, di

NormalError:				; ...
		add	di, 13h		; ERROR_WRITE_PROTECT
		xchg	di, dx
		call	RPrintCrit

CheckErrType:				; ...
		cmp	ErrType, 0
		jz	short ContOld
		call	crlf
		jmp	short Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ContOld:				; ...
		inc	si
		test	CDevAt,	80h	; test byte [CDevAt],DEVTYP>>8
		jz	short BlkErr
		mov	dx, offset MDEVICE ; offset DATARES:CharDevErr
		mov	CharDevErrRw, si ; CharDevErrRw.SubstPtr
		mov	si, offset CharDevErrSubst
		call	RPrint
		jmp	short Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BlkErr:					; ...
		mov	dx, offset MDRIVE ; mov	dx,offset DATARES:BlkDevErr
		mov	BlkDevErrRw, si	; BlkDevErrRw.SubstPtr
		mov	si, offset BlkDevErrSubst
		call	RPrint
		cmp	Loading, 0
		jz	short Ask
		call	RestHand
		jmp	GetComDsk2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ask:					; ...
		cmp	ErrCd_24, 0Fh
		jnz	short Not15
		push	cx
		push	ds
		pop	es
		assume es:RESGROUP
		lds	si, NeedVol
		push	di
		mov	di, offset VolName
		mov	cx, 16
		cld
		rep movsb
		pop	di
		push	es
		pop	ds
		pop	cx
		mov	dx, offset MVOLSERIAL
		mov	si, offset NeedVolSubst
		call	RPrint

Not15:					; ...
		mov	dx, offset REQ_ABORT
		call	RPrint
		test	Crit_Err_Info, 10h
		jz	short Try_Ignore
		mov	dx, offset REQ_RETRY
		call	RPrint

Try_Ignore:				; ...
		test	Crit_Err_Info, 20h
		jz	short Try_Fail
		mov	dx, offset REQ_IGNORE
		call	RPrint

Try_Fail:				; ...
		test	Crit_Err_Info, 8
		jz	short Term_Question
		mov	dx, offset REQ_FAIL
		call	RPrint

Term_Question:				; ...
		mov	dx, offset REQ_END
		call	RPrint
		test	fFail, 0FFh
		jz	short DoPrompt
		mov	ah, 3
		jmp	EExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoPrompt:				; ...
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	crlf
		call	CharToUpper
		mov	ah, 0
		test	Crit_Err_Info, 20h
		jz	short User_Retry
		cmp	al, IGNORE_CHAR
		jz	short EExitJ

User_Retry:				; ...
		inc	ah
		test	Crit_Err_Info, 10h
		jz	short User_Abort
		cmp	al, RETRY_CHAR
		jz	short EExitJ

User_Abort:				; ...
		inc	ah
		cmp	al, ABORT_CHAR
		jz	short Abort_Process
		inc	ah
		test	Crit_Err_Info, 8
		jz	short AskJ
		cmp	al, FAIL_CHAR
		jz	short EExitJ

AskJ:					; ...
		jmp	Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EExitJ:					; ...
		jmp	short EExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Abort_Process:				; ...
		test	InitFlag, 1
		jz	short AbortCont
		cmp	PermCom, 0
		jz	short JustExit
		mov	dx, offset PATRICIDE
		call	RPrint

DeadInTheWater:				; ...
		jmp	short DeadInTheWater
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

JustExit:				; ...
		mov	ax, Parent
		mov	ds:16h,	ax	; [PDB.PARENT_PID]
		mov	ax, 4CFFh
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

AbortCont:				; ...
		test	In_Batch, 0FFh
		jz	short Not_Batch_Abort
		mov	Batch_Abort, 1

Not_Batch_Abort:			; ...
		mov	dl, PipeFlag
		call	ResPipeOff
		or	dl, dl
		jz	short CheckForA
		cmp	SingleCom, 0
		jz	short CheckForA
		mov	SingleCom, 0FFFFh ; -1

CheckForA:				; ...
		cmp	ErrCd_24, 0
		jz	short abortfor
		cmp	ErrCd_24, 2
		jnz	short EExit

abortfor:				; ...
		mov	ForFlag, 0
		cmp	SingleCom, 0
		jz	short EExit
		mov	SingleCom, 0FFFFh

EExit:					; ...
		mov	al, ah
		mov	dx, di

RestHd:					; ...
		call	RestHand
		pop	cx
		pop	si
		pop	es
		assume es:nothing
		mov	ds, RStack	; mov ds,[OldDS]
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FatErr:					; ...
		mov	dx, offset BADFATMSG
		mov	si, offset BadFatSubst
		call	RPrint
		mov	al, 2
		jmp	short RestHd

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


crlf		proc near		; ...
		mov	dx, offset NEWLINE
crlf		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrint		proc near		; ...
		push	si
		push	ax
		push	bx
		push	cx
		push	dx
		mov	bx, si
		mov	si, dx
		lodsb
		xor	cx, cx
		mov	cl, al
		jcxz	short rpRet
		call	RDispMsg

rpRet:					; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	si
		retn
RPrint		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrintCrit	proc near		; ...
		push	dx
		xchg	bx, dx
		sub	bx, 19
		shl	bx, 1
		mov	bx, CRITMSGPTRS[bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
RPrintCrit	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RDispMsg	proc near		; ...
		lodsb
		cmp	al, '%'
		jnz	short rdOutChar
		mov	dl, [si]
		sub	dl, '1'
		cmp	dl, 9
		jnb	short rdOutChar
		call	SubstMsg
		inc	si
		dec	cx
		jmp	short rdCharDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rdOutChar:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output

rdCharDone:				; ...
		loop	RDispMsg
		retn
RDispMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SubstMsg	proc near		; ...
		push	bx
		push	cx
		mov	al, 3
		mul	dl
		add	bx, ax
		mov	al, [bx]
		mov	bx, [bx+1]
		dec	al
		jz	short smChar
		dec	al
		jz	short smStr
		mov	ax, [bx]
		mov	cx, 4

smDigit:				; ...
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		push	ax
		and	al, 0Fh
		add	al, '0'
		cmp	al, '9'
		jbe	short smDigit09
		add	al, 7		; 'A' - '0' - 10

smDigit09:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ax
		loop	smDigit
		jmp	short smRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smChar:					; ...
		mov	dl, [bx]
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		jmp	short smRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smStr:					; ...
		mov	dl, [bx]
		or	dl, dl
		jz	short smRet
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	bx
		jmp	short smStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smRet:					; ...
		pop	cx
		pop	bx
		retn
SubstMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CharToUpper	proc near		; ...
		push	ax
		mov	ax, 1213h
		int	2Fh		; Multiplex - DOS 3+ internal -	UPPERCASE CHARACTER
					; STACK: WORD character	to convert to uppercase
					; Return: AL = uppercase character
					; STACK	unchanged
		inc	sp
		inc	sp
		retn
CharToUpper	endp ; sp = -2

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgInt2fHandler:			; ...
		pop	ds
		cmp	ax, 122Eh
		jz	short miOurs
		cmp	ax, 5500h
		jz	short fcOurs
		push	ax
		push	ax
		push	bp
		push	ax
		mov	bp, sp
		mov	ax, [bp+8]
		mov	[bp+4],	ax
		mov	ax, Int2fHandler+2
		mov	[bp+8],	ax
		mov	ax, Int2fHandler
		mov	[bp+6],	ax
		pop	ax
		pop	bp
		pop	ds
		retf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcOurs:					; ...
		pop	ax
		push	ds
		mov	si, offset Int2f_Entry
		xor	ax, ax
		jmp	short miRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

miOurs:					; ...
		test	dl, 1
		jnz	short miRet
		push	bx
		mov	bx, dx
		xor	bh, bh
		shl	bx, 1
		les	di, MsgPtrLists[bx]
		pop	bx

miRet:					; ...
		pop	ds
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgRetriever:
		pop	ds
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	ds
		pop	es
		assume es:RESGROUP
		mov	bx, 11		; NUMPARSMSGS
		cmp	di, offset PARSMSGPTRS
		jz	short chkmsgnum
		mov	bx, 90		; NUMEXTMSGS

chkmsgnum:				; ...
		cmp	bx, ax
		jb	short mrRet
		dec	ax
		shl	ax, 1
		add	di, ax
		cmp	di, ResMsgEnd
		jb	short mrInMem
		mov	si, offset ComSpec
		mov	dx, 1		; EXT_EXISTS_OPEN
		mov	bx, 2000h	; INT_24_ERROR
		mov	ax, 6C00h
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jb	short mrRet
		mov	bx, ax
		mov	dx, di
		xor	si, si

mrRead:					; ...
		sub	dx, 100h
		xor	cx, cx
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short mrCloseFile
		mov	dx, offset SafePathBuffer ; offset DATARES:MsgBuffer
		mov	cx, 64
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short mrCloseFile
		or	si, si
		jnz	short mrCloseFile
		inc	si
		mov	dx, word ptr SafePathBuffer
		or	dx, dx
		jnz	short mrRead
		stc

mrCloseFile:				; ...
		pushf
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		popf
		mov	di, dx
		jmp	short mrRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mrInMem:				; ...
		mov	di, es:[di]
		or	di, di
		jnz	short mrRet
		stc

mrRet:					; ...
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	ds
		retf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Lh_OffUnlink:
		mov	ch, al
		mov	cl, al
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bx, ax
		ror	cl, 1
		and	cl, 80h
		and	bl, 7Fh
		or	bl, cl
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	bl, ch
		shr	bl, 1
		xor	bh, bh
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EndCode		db 6 dup(0)

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ConProc		proc near		; ...

; FUNCTION CHUNK AT 017F SIZE 0000000A BYTES
; FUNCTION CHUNK AT 0320 SIZE 000000CD BYTES

		mov	sp, offset RStack
		mov	ah, 50h
		mov	bx, es
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		cmp	ax, 5
		jz	short okdos
		mov	dx, offset BADVERMSG
		call	RPrint
		mov	ax, es
		cmp	es:16h,	ax	; [es:PDB.PARENT_PID]

Here:					; ...
		jz	short Here
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

okdos:					; ...
		mov	dx, 232Fh	; TRANSTART+15
		mov	cl, 4
		shr	dx, cl
		mov	ax, cs
		add	ax, dx
		mov	initend, ax
		call	CheckHelp
		call	patch_segs
		mov	ax, 0B700h
		int	2Fh		; - Multiplex -	APPEND - INSTALLATION CHECK
					; Return: AL = 00h not installed
					; AL = FFh if installed
		cmp	al, 0
		jz	short set_msg_addr
		mov	ax, 0B702h
		int	2Fh		; - Multiplex -	APPEND - VERSION CHECK
					; Return: AX = FFFFh if	not DOS	4.0 APPEND
					; AL = major version number
					; AH = minor version number, otherwise
		cmp	ax, 0FFFFh
		jnz	short set_msg_addr
		mov	ax, 0B706h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - GET APPEND FUNCTION STATE
					; Return: BX = APPEND state
		mov	Append_State, bx
		xor	bx, bx
		mov	ax, 0B707h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits

set_msg_addr:				; ...
		mov	di, offset PAERRMSG0 ; offset resgroup:DataresEnd
		mov	ResMsgEnd, di
		call	get_XMMAddr
		mov	ax, 5500h
		int	2Fh
		or	ax, ax
		jnz	short first_com
		mov	es:ResJmpTable,	si
		mov	es:ResJmpTable+2, ds
		jmp	short init_cntry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

first_com:				; ...
		mov	es:FirstCom, 1

init_cntry:				; ...
		push	es
		pop	ds
		mov	ah, 65h
		mov	al, 4
		mov	dx, 0FFFFh
		mov	bx, 0FFFFh
		mov	cx, 5
		mov	di, offset FUCase_Addr
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		push	ds
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		pop	ds
		mov	Dbcs_Vector_Addr, si
		mov	Dbcs_Vector_Addr+2, bx
		mov	ax, ds:16h	; [PDB.PARENT_PID]
		mov	Parent,	ax
		mov	ax, ds:0Ah	; [PDB.EXIT]
		mov	OldTerm, ax
		mov	ax, ds:0Ch	; [PDB.EXIT+2]
		mov	OldTerm+2, ax
		mov	ax, 1569h	; EndCode+15
		mov	cl, 4
		shr	ax, cl
		mov	cx, cs
		add	ax, cx
		mov	Res_Tpa, ax
		and	ax, 0F000h
		add	ax, 1000h
		jnb	short TpaSet
		mov	ax, Res_Tpa

TpaSet:					; ...
		mov	LTpa, ax
		mov	ax, ds:2	; [PDB.BLOCK_LEN]
		mov	MySeg1,	ds
		mov	MySeg2,	ds
		mov	MySeg, ds
		mov	MySeg3,	ds	; segment of msg retriever routine
		mov	MemSiz,	ax
		push	ax
		mov	bx, 2320h	; mov bx,offset	RESGROUP:TranStart
		add	bx, 98C5h	; add bx,offset	TRANGROUP:TranSpaceEnd
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	ax
		mov	EnvMax,	81
		mov	EnvSiz,	16
		mov	dx, 98D4h	; TRANSPACEEND+15
		mov	cl, 4
		shr	dx, cl
		mov	TrnSize, dx
		sub	ax, dx
		mov	TrnSeg,	ax
		mov	ax, ds:2Ch	; [PDB.ENVIRON]
		or	ax, ax
		jz	short buildenv
		inc	AllocedEnv
		jmp	short environpassed
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

buildenv:				; ...
		call	alloc_env

environpassed:				; ...
		mov	EnvirSeg, ax
		mov	es, ax
		assume es:nothing

gottheenvir:
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		inc	al
		mov	ComDrv,	al
		mov	al, ds:5Ch	; [FCB]
		or	al, al
		jz	short nocomdrv
		mov	ah, ':'
		mov	ComDrv,	al
		add	al, 40h
		std
		cmp	AllocedEnv, 0
		jnz	short notwidenv
		push	ds
		push	es
		pop	ds
		mov	di, 9Fh		; ENVIRONSIZ-1
		mov	si, 9Dh		; ENVIRONSIZ-3
		mov	cx, 144		; MAX_COMSPEC-2
		rep movsb
		pop	ds
		mov	es:0Eh,	ax	; [es:ECOMSPEC]

notwidenv:				; ...
		cld
		mov	word ptr AUTOBAT, ax
		mov	word ptr KAUTOBAT, ax

nocomdrv:				; ...
		call	SetVect
		push	cs
		push	cs
		pop	ds
		pop	es
		mov	si, 80h
		lodsb
		mov	di, si
		xor	ah, ah
		add	di, ax
		mov	byte ptr [di], 0Dh
		xor	cx, cx
		mov	num_positionals, cx

Parse_command_line:			; ...
		mov	di, offset INTERNAT_INFO ; offset ResGroup:Parse_Command
		mov	cx, num_positionals
		xor	dx, dx
		mov	old_parse_ptr, si
		call	dword ptr Init_Parse
		mov	num_positionals, cx
		cmp	ax, 0FFFFh
		jz	short ArgsDoneJ

t1:
		cmp	ax, 0
		jz	short parse_cont

parse_line_error:			; ...
		push	si
		push	ax
		cmp	ax, 3
		jnz	short parse_line_error_disp
		mov	di, si
		mov	si, old_parse_ptr

init_chk_delim:				; ...
		cmp	si, di
		jz	short parse_line_error_disp
		lodsb
		cmp	al, space
		jz	short init_chk_delim
		cmp	al, 9
		jz	short init_chk_delim
		cmp	al, RSwitChar
		jnz	short parse_line_error_disp
		lodsb
		call	iupconv
		cmp	al, scswitch
		jnz	short parse_line_error_disp
		pop	dx
		pop	dx
		jmp	SetSSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_line_error_disp:			; ...
		pop	ax
		pop	si
		mov	dx, ax
		call	RPrintParse
		call	crlf
		jmp	short Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_cont:				; ...
		cmp	COMND1_SYN, offset COMMAND_F_SYN ; "/F"
		jz	short SetFSwitch
		cmp	COMND1_SYN, offset COMMAND_P_SYN ; "/P"
		jz	short SetPSwitch
		cmp	COMND1_SYN, offset COMMAND_D_SYN ; "/D"
		jz	short SetDSwitch
		cmp	COMND1_SYN, offset COMMAND_C_SYN ; "/C"
		jz	short SetSSwitch
		cmp	COMND1_SYN, offset COMMAND_E_SYN ; "/E"
		jz	short SetESwitch
		cmp	COMND1_SYN, offset COMMAND_M_SYN ; "/MSG"
		jz	short SetMSwitchjmp
		jmp	ChkOtherArgs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetMSwitchjmp:				; ...
		jmp	SetMSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ArgsDoneJ:				; ...
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetFSwitch:				; ...
		cmp	fFail, 0FFh
		jnz	short failok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

failok:					; ...
		mov	fFail, 0FFh
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetPSwitch:				; ...
		cmp	PermCom, 0
		jz	short permcomok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

permcomok:				; ...
		inc	PermCom
		mov	OldTerm, offset	LodCom_Trap
		mov	OldTerm+2, ds
		cmp	PRDATTM, 0FFh
		jnz	short Parse_command_line_jmp
		mov	PRDATTM, 0

Parse_command_line_jmp:			; ...
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetDSwitch:				; ...
		cmp	dswitch, 0
		jz	short setdateok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setdateok:				; ...
		inc	dswitch
		mov	PRDATTM, 1
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetSSwitch:				; ...
		mov	SingleCom, si
		mov	PermCom, 0
		mov	PRDATTM, 1
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetESwitch:				; ...
		cmp	eswitch, 0
		jz	short eswitchok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

eswitchok:				; ...
		inc	eswitch
		mov	di, offset COMND1_ADDR
		mov	bx, [di]
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl
		mov	EnvSiz,	bx
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetMSwitch:				; ...
		cmp	ext_msg, 1
		jnz	short setMswitchok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setMswitchok:				; ...
		mov	ext_msg, 1
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ChkOtherArgs:				; ...
		push	ds
		push	si
		lds	si, COMND1_ADDR
		mov	dx, si
		mov	ax, 3D02h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short ChkSrchSpec
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short IsaDevice

BadSetCon:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short ChkSrchSpec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IsaDevice:				; ...
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jb	short BadSetCon
		mov	dx, bx
		cmp	es:DevFlag, 1
		jz	short DevErr
		push	cx
		mov	cx, 3
		xor	bx, bx

rcclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	rcclloop
		mov	bx, dx
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	cx
		pop	si
		pop	ds
		inc	es:DevFlag
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DevErr:					; ...
		pop	si
		pop	ds
		mov	dx, 1
		call	RPrintParse
		call	crlf
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ChkSrchSpec:				; ...
		cmp	es:PathFlag, 1
		jz	short DevErr
		inc	es:PathFlag
		mov	ax, ss:EnvirSeg
		cmp	ss:AllocedEnv, 1
		mov	ss:AllocedEnv, 0
		jnz	short env_alloced
		call	alloc_env
		mov	ss:EnvirSeg, ax

env_alloced:				; ...
		mov	es, ax
		push	si
		xor	cx, cx

countloop:				; ...
		lodsb
		inc	cx
		cmp	al, 0
		jnz	short countloop
		mov	al, ss:space
		dec	si
		mov	[si], al
		pop	si
		mov	di, 0Eh		; ComspOffset (ECOMSPEC)

ComtrLoop:				; ...
		lodsb
		dec	cx
		cmp	al, ss:space
		jz	short SetComsr
		stosb
		jcxz	short SetComsr
		jmp	short ComtrLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetComsr:				; ...
		push	cx
		push	cs
		pop	ds
		push	ds
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	cx, 14
		mov	al, es:[di-1]
		cmp	al, RDirChar
		jnz	short iNotRoot
		inc	si
		dec	cx

iNotRoot:				; ...
		rep movsb
		mov	dx, 0Eh		; ComspOffset (ECOMSPEC)
		push	es
		pop	ds
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		pop	ds
		jb	short SetComsrBad
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

SetComsrRet:				; ...
		pop	cx
		pop	si
		pop	ds
		push	cs
		pop	es
		assume es:RESGROUP
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetComsrBad:				; ...
		mov	dx, offset BADCOMLKMES
		call	50B2h		; call TriageError (in TRANSCODE)
					; 2320h+2D92h
		cmp	ax, 65
		jnz	short doprt
		mov	dx, offset BADCOMACCMSG

doprt:					; ...
		call	RPrint
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	di, 0Eh		; ComspOffset
		mov	cx, 14
		rep movsb
		jmp	short SetComsrRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ArgsDone:				; ...
		mov	es, EnvirSeg
		assume es:nothing
		cmp	PermCom, 0
		jz	short ComReturns
		push	es
		mov	ah, 50h
		mov	bx, ds
		mov	es, bx
		assume es:RESGROUP
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	di, 0Ah		; PDB.EXIT
		mov	ax, offset LodCom_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset Ctrlc_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset CritErr_Trap
		stosw
		mov	ax, ds
		stosw
		mov	word ptr ds:16h, ds ; PDB.Parent_Pid
		mov	dx, offset Int2e_Trap
		mov	ax, 252Eh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	es
		assume es:nothing

ComReturns:				; ...
		mov	ax, ds:16h
		mov	Parent,	ax
		mov	word ptr ds:16h, ds
		mov	ax, ds:18h	; PDB.Jfn_Table
		mov	Io_Save, ax
		mov	Com_Ptr+2, ds
		mov	Com_Fcb1+2, ds
		mov	Com_Fcb2+2, ds
		mov	di, offset ComSpec
		mov	si, 0Eh		; [ComspOffset]	= ECOMSPEC = 14
		cmp	AllocedEnv, 0
		mov	ax, ds
		push	es
		pop	ds
		mov	es, ax
		assume es:RESGROUP
		jz	short CopyComsp
		push	cs
		pop	ds
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		push	es
		push	di
		call	IfindE
		mov	si, di
		push	es
		pop	ds
		pop	di
		pop	es
		assume es:nothing
		jnb	short CopyComsp

ComSpecNofnd:
		mov	si, 0Eh
		push	cs
		pop	ds

CopyComsp:				; ...
		mov	es:PutBackComSpec, di ;	PutBackComSpec.SubstPtr
		cmp	byte ptr [si+1], ':'
		jnz	short CopyComspLoop
		add	es:PutBackComSpec, 2

CopyComspLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short CopyComspLoop
		mov	es:ComSpec_End,	di
		dec	es:ComSpec_End
		mov	ah, es:ComDrv
		add	ah, 40h		; 'A' - 1
		mov	es:PutBackDrv, ah
		call	setup_for_messages
		call	Setup_res_end
		push	cs
		pop	ds

EnvMaximum:				;
		mov	si, 2320h	; offset RESGROUP:TranStart
		add	si, 100h
		mov	cx, 87C2h	; offset TRANGROUP:TranDataEnd - 100h
		cld
		shr	cx, 1
		xor	dx, dx

Ichksum:				; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Ichksum
		mov	Sum, dx
		cmp	PRDATTM, 0
		jnz	short NoBatchSeg
		mov	bx, 4
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short NoBatchSeg
		mov	Batch, ax

NoBatchSeg:				; ...
		mov	bx, EnvirSeg
		mov	OldEnv,	bx
		mov	UsedEnv, 0
		mov	ds, bx
		xor	si, si
		mov	di, si
		mov	bx, 0FFFh	; 4096 - 1
		mov	ss:EnvMax, bx
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		mov	ss:EnvMax, bx
		dec	bx
		xor	dx, dx

NxtStr:					; ...
		call	GetStrLen
		push	ds
		push	cs
		pop	ds
		add	UsedEnv, cx
		pop	ds
		cmp	cx, 1
		jz	short EnvExit
		sub	bx, cx
		jnb	short OkCpyStr
		inc	dx
		jmp	short EnvExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OkCpyStr:				; ...
		jmp	short NxtStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EnvExit:				; ...
		push	cs
		pop	ds
		or	dx, dx
		jz	short EnvNoErr
		mov	dx, offset OUTENVMSG
		call	RPrint

EnvNoErr:				; ...
		mov	ax, EnvSiz
		mov	cl, 4
		shl	ax, cl
		cmp	ax, UsedEnv
		ja	short st_envsize
		mov	ax, UsedEnv
		add	ax, 15

st_envsize:				; ...
		shr	ax, cl
		mov	EnvSiz,	ax
		cmp	Batch, 0
		jnz	short DoDate
		jmp	NoDttm
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoDate:					; ...
		mov	ax, Batch
		mov	EchoFlag, 3
		mov	Nest, 1
		mov	es, ax
		xor	di, di
		mov	al, 0
		stosb
		mov	al, 1
		stosb
		xor	ax, ax
		stosb
		stosw
		stosw
		stosb
		stosw
		stosw
		mov	ax, 0FFFFh
		mov	cx, 10
		rep stosw
		cmp	AUTOBAT, 0
		jnz	short NoAutSet
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, ucasea
		mov	AUTOBAT, al
		mov	KAUTOBAT, al

NoAutSet:				; ...
		mov	si, offset AUTOBAT
		mov	cx, 8
		rep movsw
		movsb
		mov	dx, offset AUTOBAT
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short noabat
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	Drv0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

noabat:					; ...
		push	ax
		call	Setup_Seg
		mov	triage_add_seg,	ax ; [triage_add+2]
		pop	ax
		call	dword ptr triage_add
		cmp	ax, 65
		jz	short AccDenErr
		mov	dx, offset INTERNAT_INFO
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jb	short NoKabat
		cmp	bx, 52h		; KOREA_COUNTRY_CODE
		jnz	short OpenErr
		mov	di, 20h		; BatFile
		mov	si, offset KAUTOBAT
		mov	cx, 8
		rep movsw
		movsb
		mov	dx, offset KAUTOBAT
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short NoKabat
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short Drv0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoKabat:				; ...
		call	dword ptr triage_add
		cmp	ax, 65
		jnz	short OpenErr

AccDenErr:				; ...
		mov	dx, offset ACCDEN
		call	RPrint

OpenErr:				; ...
		mov	es, Batch
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	Batch, 0
		mov	EchoFlag, 1
		mov	Nest, 0
		mov	ax, offset DATINIT ; offset TranGroup:Datinit
		mov	word ptr INITADD, ax
		mov	ax, 2320h	; offset RESGROUP:TranStart
		mov	cl, 4
		shr	ax, cl
		mov	cx, cs
		add	ax, cx
		mov	word ptr INITADD+2, ax
		call	INITADD

NoDttm:					; ...
		cmp	SingleCom, 0	; Copyright
		jnz	short Drv0
		mov	dx, offset COPYRIGHTMSG
		call	RPrint

Drv0:					; ...
		push	ds
		push	cs
		pop	ds
		mov	ax, 0B707h
		mov	bx, Append_State
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		pop	ds
		cmp	FirstCom, 1
		jz	short move_code
		push	es
		push	ds
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, offset Int2f_Entry
		mov	ds, es:ResJmpTable+2
		mov	si, es:ResJmpTable
		mov	cx, 11
		shl	cx, 1
		shl	cx, 1
		cld
		rep movsb
		cmp	word ptr es:[di-2], 0F000h
		jb	short res_low
		mov	es:ComInHMA, 1

res_low:				; ...
		pop	ds
		pop	es
		assume es:nothing
		jmp	short finish_init
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

move_code:				; ...
		call	Move_res_code

finish_init:				; ...
		jmp	EndInit		; RESGROUP:EndInit
ConProc		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetStrLen	proc near		; ...
		xor	cx, cx

NxtChar:				; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short NxtChar
		retn
GetStrLen	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Setup_Seg	proc near		; ...
		mov	ax, TrnSeg
		cmp	TrnMvFlg, 1
		jz	short setup_end
		push	bx
		mov	bx, cs
		mov	ax, 2320h	; offset ResGroup:TranStart
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		add	ax, bx
		pop	bx

setup_end:				; ...
		retn
Setup_Seg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrintParse	proc near		; ...
		push	dx
		xchg	bx, dx
		dec	bx
		shl	bx, 1
		mov	bx, PARSMSGPTRS[bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
RPrintParse	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


IfindE		proc near		; ...
		call	ifind
		jb	short ifind2
		jmp	short Iscasb1
IfindE		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ifind		proc near		; ...
		cld
		call	Icount0
		mov	es, EnvirSeg
		xor	di, di

ifind1:					; ...
		push	cx
		push	si
		push	di

ifind11:				; ...
		lodsb
		call	iupconv
		inc	di
		cmp	al, es:[di-1]
		jnz	short ifind12
		loop	ifind11

ifind12:				; ...
		pop	di
		pop	si
		pop	cx
		jz	short ifind2
		push	cx
		call	Iscasb2
		pop	cx
		cmp	byte ptr es:[di], 0
		jnz	short ifind1
		stc

ifind2:					; ...
		retn
ifind		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Icount0		proc near		; ...
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, si
		push	di
		call	Iscasb1
		jmp	short Icountx
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		push	di
		call	Iscasb2

Icountx:				; ...
		pop	cx
		sub	di, cx
		xchg	di, cx
		retn
Icount0		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Iscasb1		proc near		; ...
		mov	al, equalsign
		jmp	short Iscasbx
Iscasb1		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Iscasb2		proc near		; ...
		xor	al, al

Iscasbx:				; ...
		mov	cx, 256
		repne scasb
		retn
Iscasb2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


iupconv		proc near		; ...
		cmp	al, 80h
		jb	short other_fucase
		sub	al, 80h
		push	ds
		push	bx
		lds	bx, dword ptr FUCase_Addr+1
		add	bx, 2
		xlat
		pop	bx
		pop	ds
		jmp	short iupconv_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

other_fucase:				; ...
		cmp	al, lcasea
		jb	short iupconv_end
		cmp	al, lcasez
		ja	short iupconv_end
		sub	al, 20h

iupconv_end:				; ...
		retn
iupconv		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

init_contc_specialcase:			; ...
		add	sp, 6
		push	si
		mov	si, dx
		mov	word ptr [si+1], 0D00h
		pop	si
		iret

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


setup_for_messages proc	near		; ...
		push	bx
		push	ds
		push	es
		push	ax
		push	dx
		push	di
		mov	ax, cs
		mov	ds, ax
		mov	es, ax
		cmp	PermCom, 0
		jz	short no_permcom
		push	es
		mov	ax, 352Fh
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	Int2fHandler, bx
		mov	Int2fHandler+2,	es
		pop	es
		assume es:nothing
		cmp	FirstCom, 0
		jz	short no_msg_hook
		push	ds
		mov	dx, offset Carousel_i2f_Hook
		sub	dx, 10h
		mov	ax, ds
		inc	ax
		mov	ds, ax
		assume ds:nothing
		mov	ax, 252Fh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		assume ds:RESGROUP
		mov	word ptr Carousel_i2f_Hook+3, ds

no_msg_hook:				; ...
		cmp	ext_msg, 1
		jnz	short permcom_end
		mov	di, offset Exec_Err ; offset ResGroup:ExtMsgEnd
		mov	ResMsgEnd, di
		jmp	short permcom_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_permcom:				; ...
		cmp	ext_msg, 1
		jnz	short permcom_end
		mov	dx, 2
		call	RPrintParse

permcom_end:				; ...
		pop	di
		pop	dx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn
setup_for_messages endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckHelp	proc near		; ...
		mov	si, 81h		; command-line tail
		mov	di, offset INTERNAT_INFO ; RESGROUP:Parse_Command
		xor	cx, cx
		xor	dx, dx

chParse:				; ...
		call	dword ptr Init_Parse
		cmp	ax, 0FFFFh	; END_OF_LINE (-1)
		jz	short chRet
		cmp	ax, 0
		jz	short chWhich
		jmp	short chParse
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chWhich:				; ...
		cmp	COMND1_SYN, offset COMMAND_?_SYN ; "/?"
		jz	short chHelp
		cmp	COMND1_SYN, offset COMMAND_C_SYN ; "/C"
		jz	short chRet
		jmp	short chParse
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chHelp:					; ...
		mov	si, offset HelpMsgs

chHelpNext:				; ...
		lodsw
		or	ax, ax
		jz	short chHelpDone
		mov	dx, ax
		call	RPrint
		jmp	short chHelpNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chHelpDone:				; ...
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chRet:					; ...
		retn
CheckHelp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Setup_res_end	proc near		; ...
		push	ds
		mov	ax, cs
		mov	ds, ax
		mov	cx, ResMsgEnd
		cmp	cx, offset Exec_Err ; cmp cx,ExtMsgEnd
		jnz	short calc_res
		add	cx, 0Fh
		and	cx, 0FFF0h

calc_res:				; ...
		xor	ax, ax
		cmp	FirstCom, 1
		jnz	short not_first
		push	bx
		push	cx
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		pop	cx
		cmp	bl, 5
		jb	short oldver
		xor	ax, ax
		and	dh, 10h
		pop	bx
		jnz	short not_first
		mov	ax, 81Ah	; offset CODERES:EndCode

not_first:				; ...
		add	cx, ax
		add	cx, 15
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	ResSize, cx
		pop	ds
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oldver:					; ...
		pop	bx
		mov	ax, 81Ah	; size of code in bytes
		jmp	short not_first
Setup_res_end	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Move_res_code	proc near		; ...
		push	ds
		push	es
		mov	ax, cs
		mov	ds, ax
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		and	dh, 10h
		jnz	short move_high

load_low:				; ...
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, ResMsgEnd
		mov	bx, offset Exec_Err ; offset RESGROUP: ExtMsgEnd
		cmp	di, bx
		jz	short no_move
		jmp	short setup_move
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

move_high:				; ...
		mov	bx, 81Ah	; offset CODERES: EndCode
		mov	di, 0FFFFh
		mov	ax, 4A02h
		int	2Fh
		cmp	di, 0FFFFh
		mov	ComInHMA, 1
		jnz	short setup_move
		mov	ComInHMA, 0
		mov	cx, ResMsgEnd
		mov	ax, 81Ah
		add	cx, ax
		add	cx, 0Fh
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	ResSize, cx
		jmp	short load_low
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_move:				; ...
		mov	cl, 4
		add	di, 0Fh
		and	di, 0FFF0h
		jmp	short patch_up
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setup_move:				; ...
		mov	si, offset Exec_Err ; offset RESGROUP: StartCode
		mov	cx, 81Ah	; offset CODERES: EndCode
		cld
		push	di
		rep movsb
		pop	di

patch_up:				; ...
		call	patch_stub
		pop	es
		assume es:nothing
		pop	ds
		retn
Move_res_code	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


alloc_env	proc near		; ...

; FUNCTION CHUNK AT 0E4B SIZE 0000006C BYTES

		push	ds
		push	es
		push	si
		push	di
		mov	bx, 10		; ENVIRONSIZ>>4
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short init_nomem

init_ok:
		mov	es, ax
		xor	di, di
		mov	ax, di
		mov	cx, 160		; ENVIRONSIZ
					; size of Environment Struc (SIZE Environment)
		rep stosb		; clear

init_pathstr:
		push	ss
		pop	ds
		mov	si, offset PathString ;	"PATH="
		mov	di, 0

init_cp_pathstr:			; ...
		lodsb
		stosb
		or	al, al
		jnz	short init_cp_pathstr

init_comspec:				; "COMSPEC=\\COMMAND.COM"
		mov	si, offset ComspString
		mov	di, 6

init_cp_compstr:			; ...
		lodsb
		stosb
		or	al, al
		jnz	short init_cp_compstr

init_done:
		mov	ax, es

alloc_done:
		pop	di
		pop	si
		pop	es
		pop	ds
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

init_nomem:				; ...
		call	$+3		; call Alloc_error

Alloc_error:				; ...
		jmp	BadMemErr	; RESGROUP:BadMemErr
alloc_env	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


patch_stub	proc near		; ...
		push	es
		mov	bx, es
		mov	dx, di
		mov	di, offset Int2f_Entry ; offset	DATARES:Int2f_Entry
		mov	si, offset Reloc_Table ; offset	RESGROUP:Reloc_Table
		push	ds
		pop	es
		assume es:RESGROUP
		mov	cx, 11		; NUM_RELOC_ENTRIES

patchlp:				; ...
		lodsw
		add	ax, dx
		stosw
		mov	ax, bx
		stosw
		loop	patchlp
		pop	es
		assume es:nothing
		retn
patch_stub	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


patch_segs	proc near		; ...
		mov	di, offset Int2f_Entry
		mov	cx, 4
		add	di, 2
		mov	ax, es

pseglp:					; ...
		stosw
		add	di, 2
		loop	pseglp
		retn
patch_segs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_XMMAddr	proc near		; ...
		push	es
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h	; ''
		jnz	short cXMMexit
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	word ptr XMMCallAddr, bx
		mov	word ptr XMMCallAddr+2,	es

cXMMexit:				; ...
		pop	es
		retn
get_XMMAddr	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		db 11 dup(0)
ICONDEV		db '/DEV/CON',0,0,0,0,0,0
		db 0
COMSPECT	db '\COMMAND.COM',0     ; ...
		db 0
AUTOBAT		db 0			; ...
		db ':\AUTOEXEC.BAT',0
		db 0Dh
KAUTOBAT	db 0			; ...
		db ':\KAUTOEXE.BAT',0
		db 0Dh
PRDATTM		db 0FFh			; ...
INITADD		dd 0			; ...
print_add	dw offset Printf_Init
print_add_seg	dw 0
triage_add	dw offset Triage_Init	; ...
triage_add_seg	dw 0			; ...
AllocedEnv	db 0			; ...
PathString	db 'PATH=',0            ; ...
ComspString	db 'COMSPEC=\COMMAND.COM',0 ; ...
equalsign	db '='                  ; ...
lcasea		db 'a'                  ; ...
lcasez		db 'z'                  ; ...
space		db ' '                  ; ...
scswitch	db 'C'                  ; ...
ucasea		db 'A'                  ; ...
EnvSiz		dw 0			; ...
EnvMax		dw 0			; ...
OldEnv		dw 0			; ...
UsedEnv		dw 0			; ...
PARS_MSG_OFF	dw 0
PARS_MSG_SEG	dw 0
Init_Parse	dw offset append_parse	; ...
					; TRANGROUP:APPEND_PARSE
initend		dw 0			; ...
TrnSize		dw 0			; ...
resetenv	db 0
ext_msg		db 0			; ...
eswitch		db 0			; ...
dswitch		db 0			; ...
parsemes_ptr	dw 0
INTERNAT_INFO	dw offset COMMAND_PARMS	; ...
		db 0
COMMAND_PARMS	db 0			; ...
		db 2
		dw offset COMMAND_FILE
		dw offset COMMAND_FILE
		db 7
		dw offset COMMAND_SWITCH1
		dw offset COMMAND_SWITCH2
		dw offset COMMAND_SWITCH3
		dw offset COMMAND_SWITCH4
		dw offset COMMAND_SWITCH5
		dw offset COMMAND_SWITCH6
		dw offset COMMAND_SWITCH7
		db 0
COMMAND_FILE	dw 201h			; ...
		dw 1
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 0
COMMAND_SWITCH1	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_P_SYN	db '/P',0               ; ...
COMMAND_SWITCH2	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_F_SYN	db '/F',0               ; ...
COMMAND_SWITCH3	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_D_SYN	db '/D',0               ; ...
COMMAND_SWITCH4	dw 8000h		; ...
		dw 0
		dw offset COMND1_OUTPUT
		dw offset COMMAND_E_VAL
		db 1
COMMAND_E_SYN	db '/E',0               ; ...
COMMAND_E_VAL	db 1			; ...
		db 1
		db 1
		dd 160
		dd 32768
		db 0
		db 0
COMMAND_SWITCH5	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_C_SYN	db '/C',0               ; ...
COMMAND_SWITCH6	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_M_SYN	db '/MSG',0             ; ...
COMMAND_SWITCH7	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_?_SYN	db '/?',0               ; ...
COMND1_OUTPUT	db 0			; ...
		db 0
COMND1_SYN	dw 0			; ...
COMND1_ADDR	dd 0			; ...
NO_VAL		db 0			; ...
num_positionals	dw 0			; ...
old_parse_ptr	dw 0			; ...
BADVERMSG	db 23			; ...
		db 'Incorrect DOS version',0Dh,0Ah
OUTENVMSG	db 26			; ...
		db 'Out of environment space',0Dh,0Ah
COPYRIGHTMSG	db 94			; ...
		db 0Dh,0Ah
		db 0Dh,0Ah
		db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
		db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
BADCOMLKMES	db 40			; ...
		db 'Specified COMMAND search directory bad',0Dh,0Ah
BADCOMACCMSG	db 54			; ...
		db 'Specified COMMAND search directory bad '
		db 'access denied',0Dh,0Ah
HELPMSG1	db 60			; ...
		db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG2	db 70			; ...
		db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG'
		db ']',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG3	db 72			; ...
		db '  [drive:]path    Specifies the directory containing COMMAND.COM '
		db 'file.',0Dh,0Ah
HELPMSG4	db 77			; ...
		db '  device          Specifies the device to use for command input a'
		db 'nd output.',0Dh,0Ah
HELPMSG5	db 69			; ...
		db '  /E:nnnnn        Sets the initial environment size to nnnnn byte'
		db 's.',0Dh,0Ah
HELPMSG6	db 77			; ...
		db '  /P              Makes the new command interpreter permanent (ca'
		db 'n',27h,'t exit).',0Dh,0Ah
HELPMSG7	db 80			; ...
		db '  /C string       Carries out the command specified by string, an'
		db 'd then stops.',0Dh,0Ah
HELPMSG8	db 78			; ...
		db '  /MSG            Specifies that all error messages be stored in '
		db 'memory. You',0Dh,0Ah
HELPMSG9	db 56			; ...
		db '                  need to specify /P with this switch.',0Dh,0Ah
HelpMsgs	dw offset HELPMSG1	; ...
		dw offset HELPMSG2
		dw offset HELPMSG3
		dw offset HELPMSG4
		dw offset HELPMSG5
		dw offset HELPMSG6
		dw offset HELPMSG7
		dw offset HELPMSG8
		dw offset HELPMSG9
		dw 0
Reloc_Table	dw 738h			; ...
					; 738h+0D40h = MsgInt2fHandler
		dw 177h			; 177h+0D40h = Int_2e
		dw 35h			; 035h+0D40h = ContC
		dw 445h			; 445h+0D40h = DskErr
		dw 29h			; 029h+0D40h = Exec_Ret
		dw 2A3h			; 2A3h+0D40h = TRemCheck
		dw 422h			; 422h+0D40h = TrnLodCom1
		dw 1AEh			; 1AEh+0D40h = LodCom
		dw 77Bh			; 77Bh+0D40h = MsgRetriever
		dw 2C2h			; 2C2h+0D40h = THeadFix
		dw 7F4h			; 7F4h+0D40h = Lh_OffUnlink
ResJmpTable	dw 2 dup(0)		; ...
FirstCom	db 0			; ...
DevFlag		db 0			; ...
PathFlag	db 0			; ...
		db 13 dup(0)
RESGROUP	ends

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure code
TRANGROUP	segment	byte public 'CODE' use16
		assume cs:TRANGROUP
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
TRANSTART	db 256 dup(0)		; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

SETDRV:					; ...
		mov	ah, 0Eh
		int	21h		; DOS -	SELECT DISK
					; DL = new default drive number	(0 = A,	1 = B, etc.)
					; Return: AL = number of logical drives

TCOMMAND:				; ...
		mov	ds, cs:RESSEG
		mov	ax, 0FFFFh
		xchg	ax, ds:VerVal
		cmp	ax, 0FFFFh
		jz	short NOSETVER2
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOSETVER2:				; ...
		call	dword ptr cs:HEADCALL
		xor	bp, bp
		cmp	ds:SingleCom, 0FFFFh
		jnz	short COMMAND

_$EXITPREP:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	_$EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COMMAND:				; ...
		cld
		mov	ax, cs
		cli
		mov	ss, ax
		assume ss:TRANGROUP
		mov	sp, offset STACK
		sti
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		call	TSYSLOADMSG
		mov	append_exec, 0
		mov	ds, RESSEG
		assume ds:nothing
		mov	ss:UCOMBUF, 128
		mov	ss:COMBUF, 128
		or	bp, bp
		jz	short TESTRDIR
		mov	word ptr ss:UCOMBUF+1, 0D01h
		jmp	short NOSETBUF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTRDIR:				; ...
		cmp	ds:RestDir, 0
		jz	short NOSETBUF
		push	ds
		mov	ds:RestDir, 0
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
		assume ds:nothing

NOSETBUF:				; ...
		cmp	ds:PipeFiles, 0
		jz	short NOPCLOSE
		cmp	ds:PipeFlag, 0
		jnz	short NOPCLOSE
		call	PIPEDEL

NOPCLOSE:				; ...
		mov	ds:ExtCom, 0
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		push	ax
		mov	dx, offset STACK ; offset INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		sub	ax, TPA
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ
		mov	ax, 0FFFFh

SAVSIZ:					; ...
		cmp	ax, 512
		jbe	short GOTSIZE
		and	ax, 0FE00h

GOTSIZE:				; ...
		mov	BYTCNT,	ax
		mov	ds, RESSEG
		assume ds:nothing
		test	ds:EchoFlag, 1
		jz	short GETCOM
		call	SINGLETEST
		jb	short GETCOM
		test	ds:PipeFlag, 0FFh
		jnz	short GETCOM
		test	ds:ForFlag, 0FFh
		jnz	short GETCOM
		test	ds:Batch, 0FFFFh
		jnz	short GETCOM
		call	CRLF2

GETCOM:					; ...
		mov	ds:Call_Flag, 0
		mov	ds:Call_Batch_Flag, 0
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		mov	ss:CURDRV, al
		test	ds:PipeFlag, 0FFh
		jz	short NOPIPE
		jmp	PIPEPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPIPE:					; ...
		test	ds:EchoFlag, 1
		jz	short NOPDRV
		call	SINGLETEST
		jb	short NOPDRV
		test	ds:ForFlag, 0FFh
		jnz	short NOPDRV
		test	ds:Batch, 0FFFFh
		jnz	short TESTFORBAT
		call	PRINT_PROMPT

NOPDRV:					; ...
		test	ds:ForFlag, 0FFh
		jz	short TESTFORBAT
		jmp	FORPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTFORBAT:				; ...
		mov	ss:RE_INSTR, 0
		mov	ds:Re_OutStr, 0
		mov	ds:Re_Out_App, 0
		mov	ds:IfFlag, 0
		test	ds:Batch, 0FFFFh
		jz	short ISNOBAT
		push	es
		push	ds
		mov	ax, 1902h
		mov	es, ds:Batch
		assume es:nothing
		mov	di, 20h
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset COMBUF
		int	2Fh		; - Multiplex -	DOS 4.x	only SHELLB.COM	- COMMAND.COM INTERFACE
					; ES:DI	-> ASCIZ full filename of current batch	file, with at least the
					; final	filename element uppercased
					; DS:DX	-> buffer for results
		cmp	al, 0FFh
		pop	ds
		assume ds:nothing
		pop	es
		jz	short JDOCOM1
		push	ds
		call	READBAT
		pop	ds
		mov	ds:NullFlag, 0
		test	ds:Batch, 0FFFFh
		jnz	short JDOCOM1
		mov	bx, ds:Next_Batch
		cmp	bx, 0
		jz	short JDOCOM1
		mov	ds:Batch, bx
		mov	ds:Next_Batch, 0

JDOCOM1:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	short DOCOM1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISNOBAT:				; ...
		cmp	ds:SingleCom, 0
		jz	short REGCOM
		mov	si, 0FFFFh
		xchg	si, ds:SingleCom
		mov	di, (offset COMBUF+2)
		xor	cx, cx

SINGLELOOP:				; ...
		lodsb
		stosb
		inc	cx
		cmp	al, 0Dh
		jnz	short SINGLELOOP
		dec	cx
		push	cs
		pop	ds
		mov	COMBUF+1, cl
		jmp	short DOCOM1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REGCOM:					; ...
		mov	ax, 5D09h
		int	21h		; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
; END OF FUNCTION CHUNK	FOR PROMPTBAT
		mov	ax, 5D08h
		mov	dl, 1
		int	21h		; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
					; DL = 00h redirected output is	combined
					;      01h redirected output placed in separate	jobs
					; start	new print job now
		push	cs
		pop	ds
		mov	dx, offset UCOMBUF
		mov	ax, 4810h
		int	2Fh
		or	ax, ax
		jz	short GOTCOM
		mov	ah, 0Ah
		int	21h		; DOS -	BUFFERED KEYBOARD INPUT
					; DS:DX	-> buffer

GOTCOM:					; ...
		mov	cl, UCOMBUF
		xor	ch, ch
		add	cx, 3
		mov	si, offset UCOMBUF
		mov	di, offset COMBUF
		rep movsb
; START	OF FUNCTION CHUNK FOR PROMPTBAT

DOCOM:					; ...
		call	CRLF2

DOCOM1:					; ...
		call	PRESCAN
		jz	short NOPIPEPROC
		jmp	PIPEPROCSTRT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NULLCOMJ:				; ...
		jmp	NULLCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPIPEPROC:				; ...
		call	PARSELINE
		jnb	short OKPARSE

BADPARSE:				; ...
		push	cs
		pop	ds
		mov	dx, offset BADNAM_PTR
		call	std_eprintf
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OKPARSE:				; ...
		test	ARGV0_ARG_FLAGS, 2 ; [ARG+ARGV_ELE.argflags],wildcard
		jnz	short BADPARSE
		cmp	ARG_ARGVCNT, 0	; [ARG+ARG_UNIT.argvcnt]
		jz	short NULLCOMJ
		cmp	ARGV0_ARGLEN, 0	; [ARG+ARGV_ELE.arglen]
		jz	short NULLCOMJ
		mov	si, (offset COMBUF+2)
		mov	di, offset IDLEN
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, ARG_ARGV	; [ARG+ARG_UNIT.argv]
		cmp	byte ptr [bx+1], ':'
		jnz	short DRVGD
		mov	dl, [bx]
		and	dl, 0DFh
		sub	dl, 'A'
		cmp	al, 0FFh
		jz	short DRVBADJ
		mov	di, ARGV0_ARGSTARTEL ; [ARG+ARGV_ELE.argstartel]
		cmp	byte ptr [di], 0
		jnz	short DRVGD
		jmp	SETDRV
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRVBADJ:				; ...
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRVGD:					; ...
		mov	al, [di]
		mov	SPECDRV, al
		mov	al, 20h	; ' '
		mov	cx, 9
		inc	di
		repne scasb
		mov	al, 8
		sub	al, cl
		mov	IDLEN, al
		mov	di, 81h
		push	si
		mov	si, (offset COMBUF+2)
		call	scanoff
		inc	si

DO_SKIPCOM:				; ...
		lodsb
		call	DELIM
		jz	short DO_SKIPPED
		cmp	al, 0Dh
		jz	short DO_SKIPPED
		cmp	al, SWITCHAR
		jnz	short DO_SKIPCOM

DO_SKIPPED:				; ...
		dec	si
		xor	cx, cx

COMTAIL:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		loopne	COMTAIL
		dec	di
		mov	bp, di
		not	cl
		mov	TRANSTART+80h, cl ; mov	[80h],cl
		pop	si
		mov	di, ARGV0_ARGSW_WORD ; [ARG+ARGV_ELE.argsw_word]
		mov	COMSW, di
		mov	si, ARGV1_ARGPOINTER ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
		or	si, si
		jnz	short DOPARSE
		mov	si, bp

DOPARSE:				; ...
		mov	di, 5Ch		; mov di,FCB ; 5Ch
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	PARM1, al
		mov	di, ARGV1_ARGSW_WORD ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
		mov	ARG1S, di
		mov	si, ARGV2_ARGPOINTER ; [ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
		or	si, si
		jnz	short DOPARSE2
		mov	si, bp

DOPARSE2:				; ...
		mov	di, 6Ch		; mov di,FCB+10h ; 6Ch
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	PARM2, al
		mov	di, ARGV2_ARGSW_WORD ; [ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
		mov	ARG2S, di
		mov	di, ARGV0_ARGSW_WORD ; [ARG+ARGV_ELE.argsw_word]
		not	di
		and	di, ARG_ARGSWINFO ; [ARG+ARG_UNIT.argswinfo]
		mov	ARGTS, di
		mov	al, IDLEN
		mov	dl, SPECDRV
		or	dl, dl
		jnz	short EXTERNALJ1
		dec	al
		jmp	FNDCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXTERNALJ1:				; ...
		jmp	EXTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NULLCOM:				; ...
		mov	ds, RESSEG
		assume ds:nothing
		test	ds:Batch, 0FFFFh ; -1
		jz	short NOSETFLAG
		mov	ds:NullFlag, 1	; mov byte [NullFlag],nullcommand

NOSETFLAG:				; ...
		cmp	ds:SingleCom, 0FFFFh ; -1
		jz	short EXITJ
		jmp	GETCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXITJ:					; ...
		jmp	_$EXITPREP
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ROM_SCAN	proc near		; ...
		push	es
		push	si
		push	di
		push	cx
		push	ax
		push	bx
		mov	ax, 0F000h
		mov	es, ax
		assume es:nothing
		cmp	byte ptr es:0FFFEh, 0FDh
		jz	short SCAN_IT

NO_ROM:					; ...
		clc

ROM_RET:				; ...
		pop	bx
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	es
		assume es:nothing
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_IT:				; ...
		mov	ax, 0C000h

SCAN_ONE:				; ...
		mov	es, ax
		assume es:nothing
		xor	di, di
		cmp	word ptr es:[di], 0AA55h
		jz	short SCAN_LIST
		add	ax, 80h

SCAN_END:				; ...
		cmp	ax, 0F000h
		jb	short SCAN_ONE
		jmp	short NO_ROM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_LIST:				; ...
		mov	bl, es:[di+2]	; [es:di+ROM_HEADER.rom_length]
		xor	bh, bh
		shl	bx, 1
		shl	bx, 1
		add	bx, 7Fh
		and	bx, 0FF80h	; round	to 2k
		mov	di, 6		; mov di,ROM_HEADER.rom_length

SCAN_NAME:				; ...
		mov	cl, es:[di]
		inc	di
		xor	ch, ch
		or	cx, cx
		jnz	short SCAN_TEST
		add	ax, bx
		jmp	short SCAN_END
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_TEST:				; ...
		mov	si, dx
		inc	si
		repe cmpsb
		jz	short SCAN_FOUND

SCAN_NEXT:				; ...
		add	di, cx
		add	di, 3
		jmp	short SCAN_NAME
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_FOUND:				; ...
		cmp	byte ptr [si], 3Fh ; '?'
		jz	short SCAN_SAVE
		cmp	byte ptr [si], 20h ; ' '
		jnz	short SCAN_NEXT

SCAN_SAVE:				; ...
		mov	cs:ROM_CS, es
		mov	cs:ROM_IP, di
		stc
		jmp	short ROM_RET
ROM_SCAN	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

ROM_EXEC:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		push	bx
		push	ax
		mov	ax, 2522h
		push	ds
		mov	ds, cs:RESSEG
		mov	dx, offset Exec_Wait
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, ds
		mov	es, dx
		assume es:nothing
		pop	ds
		pop	dx
		mov	ah, 55h
		int	21h		; DOS -	2+ internal - CREATE PSP
					; DX = segment number at which to set up PSP
					; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		mov	ds, dx
		mov	dx, 80h
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ax, es:EnvirSeg
		mov	ds:2Ch,	ax	; [PDB.ENVIRON]
		pop	bx
		mov	dx, ds
		add	dx, bx
		mov	ds:2, dx	; [PDB.BLOCK_LEN]
		mov	dx, ds
		dec	dx
		mov	ds, dx
		assume ds:nothing
		inc	dx
		mov	ds:1, dx	; [ARENA.owner]
		mov	ds, dx
		assume ds:nothing
		cmp	bx, 1000h
		jb	short GOT_STACK
		xor	bx, bx

GOT_STACK:				; ...
		mov	cl, 4
		shl	bx, cl
		mov	dx, ds
		mov	ss, dx
		assume ss:nothing
		mov	sp, bx
		xor	ax, ax
		push	ax
		not	ax
		push	cs:ROM_CS
		push	cs:ROM_IP
		mov	es, dx
		retf
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PROMPTBAT	proc near		; ...

; FUNCTION CHUNK AT 0100 SIZE 000001AB BYTES
; FUNCTION CHUNK AT 02D5 SIZE 00000126 BYTES
; FUNCTION CHUNK AT 0474 SIZE 0000006E BYTES
; FUNCTION CHUNK AT 078E SIZE 00000178 BYTES
; FUNCTION CHUNK AT 0DBF SIZE 0000015C BYTES
; FUNCTION CHUNK AT 2219 SIZE 00000057 BYTES
; FUNCTION CHUNK AT 289B SIZE 000000F5 BYTES
; FUNCTION CHUNK AT 29A6 SIZE 000000AB BYTES
; FUNCTION CHUNK AT 2E25 SIZE 0000016D BYTES

		call	BATOPEN
		jb	short PROMPTBAT1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PROMPTBAT1:				; ...
		cmp	dx, 2
		jz	short BAT_REMCHECK
		cmp	dx, 3
		jz	short BAT_REMCHECK
		call	output_batch_name
		jmp	short BATDIE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BAT_REMCHECK:				; ...
		call	cs:RCH_ADDR
		jz	short ASKFORBAT
		call	FOROFF
		call	PipeOff
		mov	ds:IfFlag, al
		mov	dx, offset BADBAT_PTR

BATDIE:					; ...
		call	BATCHOFF
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	std_eprintf
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ASKFORBAT:				; ...
		push	ds
		push	cs
		pop	ds
		mov	dx, offset NEEDBAT_PTR
		call	std_eprintf
		mov	dx, offset PAUSEMES_PTR
		call	std_eprintf
		call	GETKEYSTROKE
		pop	ds
		assume ds:nothing
		jmp	short PROMPTBAT
PROMPTBAT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


output_batch_name proc near		; ...
		push	ds
		mov	ds, ds:Batch
		mov	si, 20h		; BATCHSEGMENT.BatFile
		call	dstrlen
		mov	di, offset BWDBUF
		rep movsb
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	extend_buf_ptr,	dx
		mov	msg_disp_class,	1
		mov	dx, offset extend_buf_ptr
		mov	string_ptr_2, offset BWDBUF
		mov	extend_buf_sub,	1
		pop	ds
		assume ds:nothing
		retn
output_batch_name endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETKEYSTROKE	proc near		; ...
		push	dx
		mov	ax, 6302h
		int	21h		; DOS -	3.2+ only - GET	KOREAN (HONGEUL) INPUT MODE
		push	dx
		mov	ax, 6301h
		mov	dl, 1
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		mov	ax, 0C08h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 6301h
		pop	dx
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		pop	dx
		retn
GETKEYSTROKE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


READBAT		proc near		; ...

var_7428	= byte ptr -7428h

		mov	ds:Suppress, 1
		test	ds:Batch_Abort,	0FFh
		jnz	short TRYING_TO_ABORT
		mov	ds:In_Batch, 1
		push	ds
		mov	ds, ds:Batch
		cmp	byte ptr ds:2, 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		jz	short CONTBAT
		call	GETBATBYT
		mov	es:COMBUF+2, al
		call	CRLF2
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONTBAT:				; ...
		call	PROMPTBAT

TRYING_TO_ABORT:			; ...
		mov	di, (offset COMBUF+2)

TESTNOP:				; ...
		mov	ax, ds
		mov	ds, ds:Batch
		push	word ptr ds:8	; [BATCHSEGMENT.BatSeek]
		push	word ptr ds:10	; [BATCHSEGMENT.BatSeek+2]
		mov	ds, ax
		call	SKIPDELIM
		cmp	al, ':'
		pop	cx
		pop	dx
		jz	short NOPLINE
		test	ds:Batch, 0FFFFh
		jz	short RDBAT
		cmp	al, '@'         ; No_Echo_Char
		jnz	short SET_BAT_POS
		mov	ds:Suppress, 0
		jmp	short RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SET_BAT_POS:				; ...
		push	ds
		mov	ds, ds:Batch
		mov	ds:8, dx	; [BATCHSEGMENT.BatSeek]
		mov	ds:10, cx	; [BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	es:BATBUFPOS, 0FFFFh
		xor	cx, cx
		jmp	short RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPLINE:				; ...
		call	SKIPTOEOL
		call	GETBATBYT
		test	ds:Batch, 0FFFFh
		jnz	short TESTNOP

READBAT_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RDBAT:					; ...
		call	GETBATBYT
		inc	cx
		call	testkanj
		jz	short RDBAT1
		cmp	cx, 127
		jnb	short TOOLONG
		stosb
		call	GETBATBYT
		inc	cx
		jmp	short SAVBATBYT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RDBAT1:					; ...
		cmp	cx, 128
		jnb	short TOOLONG
		cmp	al, '%'
		jz	short NEEDPARM

SAVBATBYT:				; ...
		stosb
		cmp	al, 0Dh
		jnz	short RDBAT

FOUND_EOL:				; ...
		sub	di, (offset COMBUF+3)
		mov	ax, di
		mov	es:COMBUF+1, al
		call	GETBATBYT
		call	BATCLOSE
		cmp	ds:Suppress, 0
		jz	short RESET
		test	ds:EchoFlag, 1
		jnz	short TRY_NEXTFLAG

RESET:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jz	short READBAT_RETN

TRY_NEXTFLAG:				; ...
		cmp	ds:NullFlag, 1
		jz	short NO_CRLF_PRINT
		call	CRLF2

NO_CRLF_PRINT:				; ...
		call	PRINT_PROMPT
		push	cs
		pop	ds
		mov	dx, (offset COMBUF+2)
		call	CRPRINT
		call	CRLF2
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TOOLONG:				; ...
		cmp	al, 0Dh
		jz	short LTLCONT
		call	SKIPTOEOL

LTLCONT:				; ...
		stosb
		jmp	short FOUND_EOL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEEDPARM:				; ...
		call	GETBATBYT
		cmp	al, '%'
		jz	short SAVBATBYT
		cmp	al, 0Dh
		jz	short SAVBATBYT

PAROK:
		sub	al, '0'
		jb	short NEEDENV
		cmp	al, 9
		ja	short NEEDENV
		cbw
		mov	bx, ax
		shl	bx, 1
		push	es
		mov	es, ds:Batch
		mov	si, es:[bx+0Ch]	; [es:bx+BATCHSEGMENT.BatParm]
		pop	es
		cmp	si, 0FFFFh	; -1
		jnz	short YES_THERE_IS
		jmp	RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

YES_THERE_IS:				; ...
		push	ds
		mov	ds, ds:Batch
		assume ds:nothing
		dec	cx

COPYPARM:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short ENDPARAM
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jnb	short LINETOOL
		stosb
		jmp	short COPYPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LINETOOL:				; ...
		xor	al, al
		pop	ds
		jmp	short TOOLONG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENDPARAM:				; ...
		pop	ds
		jmp	RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEEDENV:				; ...
		dec	cx
		push	ds
		push	di
		mov	di, offset ID
		add	al, '0'
		stosb

GETENV1:				; ...
		call	GETBATBYT
		stosb
		cmp	al, 0Dh
		jnz	short GETENV15
		mov	byte ptr es:[di-1], 0
		mov	si, offset ID
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	STRCPY
		jb	short LINETOOL
		pop	ds
		assume ds:nothing
		jmp	SAVBATBYT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GETENV15:				; ...
		cmp	al, '%'
		jnz	short GETENV1
		mov	al, '='
		mov	es:[di-1], al
		mov	si, offset ID
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cx
		call	find_name_in_environment
		pop	cx
		push	es
		pop	ds
		assume ds:nothing
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	si, di
		pop	di
		jb	short GETENV6
		call	STRCPY

GETENV6:				; ...
		pop	ds
		jmp	RDBAT
READBAT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SKIPTOEOL	proc near		; ...
		test	ds:Batch, 0FFFFh
		jnz	short SKIPTOEOL1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SKIPTOEOL1:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short SKIPTOEOL
		retn
SKIPTOEOL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FREE_TPA	proc near		; ...
		push	es
		mov	es, ds:RESSEG
		assume es:nothing
		mov	es, es:Res_Tpa
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		retn
FREE_TPA	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ALLOC_TPA	proc near		; ...
		push	es
		mov	es, ds:RESSEG
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		push	bx
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		pop	bx
		mov	es:Res_Tpa, ax
		mov	ds:TRAN_TPA, ax
		mov	dx, ax
		and	ax, 0FFFh
		jnz	short CALC_TPA
		mov	ax, dx
		and	ax, 0F000h
		jnz	short NOROUND

CALC_TPA:				; ...
		mov	ax, dx
		and	ax, 0F000h
		add	ax, 1000h
		jb	short NOROUND
		mov	dx, es:Res_Tpa
		add	dx, bx
		cmp	dx, ax
		jb	short NOROUND
		mov	bx, cs
		cmp	bx, ax
		jb	short NOROUND
		sub	bx, ax
		cmp	bx, 1000h
		jnb	short ROUNDDONE

NOROUND:				; ...
		mov	ax, es:Res_Tpa

ROUNDDONE:				; ...
		mov	es:LTpa, ax
		mov	ds:TPA,	ax
		mov	bx, ax
		mov	ax, cs
		sub	ax, bx
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ2
		mov	ax, 0FFFFh	; -1

SAVSIZ2:				; ...
		cmp	ax, 512
		jbe	short GOTSIZE2
		and	ax, 0FE00h	; NOT 511 = NOT	1FFh

GOTSIZE2:				; ...
		mov	ds:BYTCNT, ax
		pop	es
		retn
ALLOC_TPA	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

BATCOM:					; ...
		mov	es, ds:RESSEG
		cmp	es:Call_Batch_Flag, 1
		jz	short skip_ioset
		call	IOSET

skip_ioset:				; ...
		call	FREE_TPA
		cmp	es:Call_Batch_Flag, 1
		jz	short GETECHO
		call	FOROFF

GETECHO:				; ...
		call	PipeOff
		mov	al, es:EchoFlag
		and	al, 1
		push	ax
		xor	ax, ax
		test	es:Batch, 0FFFFh ; -1
		jz	short LEAVEBAT
		mov	ax, es:Batch
		cmp	es:Call_Batch_Flag, 1
		jz	short LEAVEBAT
		push	es
		mov	es, ax
		mov	ax, es:3	; [es:BATCHSEGMENT.BatLast]
		pop	es

LEAVEBAT:				; ...
		push	ax
		cmp	es:Call_Batch_Flag, 1
		jz	short STARTBAT
		call	BATCHOFF

STARTBAT:				; ...
		mov	es:Call_Batch_Flag, 0
		mov	si, offset EXECPATH
		mov	ax, 0B711h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET RETURN FOUND NAME STATE
		mov	ah, 4Eh
		mov	dx, si
		mov	cx, 13h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		call	dstrlen
		mov	bx, cx
		add	bx, 191		; 15+BATCHSEGMENT.SIZE+COMBUFLEN+15
		push	cx
		mov	cl, 4
		shr	bx, cl
		push	bx
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		pop	bx
		jb	short MEM_ERROR
		push	ax
		add	ax, bx
		add	ax, 20h
		mov	bx, cs
		mov	dx, 98C5h	; mov dx,offset	TRANGROUP:TranSpaceEnd
		add	dx, 15
		shr	dx, cl
		add	dx, bx
		cmp	ax, bx
		jb	short ENOUGH_MEM
		cmp	ax, dx
		ja	short ENOUGH_MEM
		pop	ax
		push	es
		mov	es, ax
		mov	ax, 4900h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

MEM_ERROR:				; ...
		jmp	NO_MEMORY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENOUGH_MEM:				; ...
		pop	ax
		mov	es:Batch, ax
		call	ALLOC_TPA
		pop	dx
		pop	ax
		inc	es:Nest
		push	es
		mov	es, es:Batch
		mov	byte ptr es:0, 0 ; [es:BATCHSEGMENT.BatType]
		mov	es:3, ax	; [es:BATCHSEGMENT.BatLast]
		push	ds
		mov	ds, ds:RESSEG
		xor	ax, ax
		mov	bl, ds:ForFlag
		mov	es:7, bl	; [es:BATCHSEGMENT.BatForFlag]
		test	bl, 0FFh	; -1
		jz	short FOR_NOT_ON
		mov	ax, ds:ForPtr
		mov	ds:ForFlag, 0

FOR_NOT_ON:				; ...
		mov	es:5, ax	; [es:BATCHSEGMENT.BatForPtr]
		xor	ax, ax
		mov	ds:ForPtr, ax
		mov	bl, ds:EchoFlag
		pop	ds
		mov	es:1, bl	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	byte ptr es:2, 0 ; [es:BATCHSEGMENT.BatchEOF]
		mov	es:8, ax	; [es:BATCHSEGMENT.BatSeek]
		mov	es:0Ah,	ax	; [es:BATCHSEGMENT.BatSeek+2]
		dec	ax
		mov	di, 0Ch		; BATCHSEGMENT.BatParm
		mov	bx, di
		mov	cx, 10
		rep stosw
		mov	cx, dx
		rep movsb
		mov	si, (offset COMBUF+2)
		mov	cx, 10

EACHPARM:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short HAVPARM
		jcxz	short MOVPARM
		mov	es:[bx], di
		add	bx, 2

MOVPARM:				; ...
		lodsb
		call	DELIM
		jz	short ENDPARM
		stosb
		cmp	al, 0Dh
		jz	short HAVPARM
		jmp	short MOVPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENDPARM:				; ...
		mov	al, 0Dh
		stosb
		jcxz	short EACHPARM
		dec	cx
		jmp	short EACHPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HAVPARM:				; ...
		xor	al, al
		stosb
		lea	bx, [di+15]
		mov	cl, 4
		shr	bx, cl
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	es
		push	es
		pop	ds
		cmp	ds:SingleCom, 0FFFFh
		jnz	short NOBATSING
		mov	ds:SingleCom, 0FFF0h

NOBATSING:				; ...
		pop	ax
		mov	ds:EchoFlag, al
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_MEMORY:				; ...
		pop	dx
		pop	ax
		pop	ax
		call	ALLOC_TPA
		mov	ds:msg_disp_class, 1
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATCHOFF	proc near		; ...
		push	ax
		push	es
		push	ds
		push	bx
		mov	es, cs:RESSEG
		mov	ds, cs:RESSEG
		mov	ax, ds:Batch
		or	ax, ax
		jz	short NOTFREE
		push	es
		mov	es, ax
		test	ds:EchoFlag, 1
		jnz	short ECHO_LAST_LINE
		mov	ds:Suppress, 0

ECHO_LAST_LINE:				; ...
		mov	bl, es:1
		mov	ds:EchoFlag, bl
		mov	bx, es:5
		mov	ds:ForPtr, bx
		mov	bl, es:7
		mov	ds:ForFlag, bl
		mov	bx, es:3
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	ds:Next_Batch, bx
		dec	es:Nest
		xor	ax, ax
		mov	ds:Batch, ax

NOTFREE:				; ...
		pop	bx
		pop	ds
		pop	es
		pop	ax
		retn
BATCHOFF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRCPY		proc near		; ...
		push	ax

ccycle:					; ...
		lodsb
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jb	short ccopy
		stc
		jmp	short ccend
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccopy:					; ...
		stosb
		or	al, al
		jnz	short ccycle

ccend:					; ...
		dec	cx
		dec	di
		pop	ax
		retn
STRCPY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETBATBYT	proc near		; ...
		push	bx
		push	cx
		push	ds
		test	ds:Batch_Abort,	0FFh ; -1
		jz	short getbatbyt1
		jmp	BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getbatbyt1:				; ...
		test	ds:Batch, 0FFFFh
		jnz	short getbatbyt2
		jmp	BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getbatbyt2:				; ...
		push	es
		mov	es, ds:Batch
		cmp	byte ptr es:2, 0 ; [es:BATCHSEGMENT.BatchEOF]
		jz	short not_eof
		jmp	At_EOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_eof:				; ...
		add	word ptr es:8, 1 ; [es:BATCHSEGMENT.BatSeek]
		adc	word ptr es:10,	0 ; [es:BATCHSEGMENT.BatSeek+2]
		pop	es
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		mov	bx, BATBUFPOS
		cmp	bx, 0FFFFh	; -1
		jnz	short UNBUF
		mov	dx, offset BATBUF
		mov	cx, BATBUFLEN
		mov	bx, BATHAND
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jnb	short bat_read_ok
		call	get_ext_error_number
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		mov	dx, ax
		call	output_batch_name
		pop	ds
		call	std_eprintf
		mov	ds:COMBUF+2, 0Dh
		mov	ds:COMBUF+3, 0
		mov	ds, ds:RESSEG
		jmp	short BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

bat_read_ok:				; ...
		mov	cx, ax
		jcxz	short BATEOFDS
		mov	ds:BATBUFEND, cx
		xor	bx, bx
		mov	ds:BATBUFPOS, bx

UNBUF:					; ...
		mov	al, ds:BATBUF[bx]
		inc	bx
		cmp	bx, ds:BATBUFEND
		jb	short SETBUFPOS
		mov	bx, 0FFFFh	; -1

SETBUFPOS:				; ...
		mov	ds:BATBUFPOS, bx
		cmp	al, 1Ah
		jnz	short GETBYTEDONE

BATEOFDS:				; ...
		push	es
		mov	es, ds:RESSEG
		mov	es, es:Batch
		cmp	byte ptr es:2, 0
		jnz	short crpresent
		inc	byte ptr es:2	; [es:BATCHSEGMENT.BatchEOF]
		mov	bx, ds:BATBUFEND
		cmp	byte ptr ds:(BATBUFPOS+1)[bx], 0Ah ; [bx+BATBUF-1]
		jz	short crpresent
		add	byte ptr es:2, 3

crpresent:				; ...
		mov	ds, ds:RESSEG

At_EOF:					; ...
		shr	byte ptr es:2, 1
		jz	short turn_off
		cmp	byte ptr es:2, 1
		jz	short ret_lf
		mov	al, 0Dh
		pop	es
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ret_lf:					; ...
		mov	al, 0Ah
		pop	es
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

turn_off:				; ...
		pop	es

BATEOF:					; ...
		call	BATCHOFF
		call	BATCLOSE
		mov	al, 0Dh
		test	ds:Batch_Abort,	0FFh
		mov	ds:Batch_Abort,	0
		jz	short CONT_GET_BYT
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONT_GET_BYT:				; ...
		cmp	ds:SingleCom, 0FFF0h
		jnz	short GETBYTEDONE
		cmp	ds:Nest, 0
		jnz	short GETBYTEDONE
		mov	ds:SingleCom, 0FFFFh

GETBYTEDONE:				; ...
		pop	ds
		pop	cx
		pop	bx
		retn
GETBATBYT	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERRORP:				; ...
		pop	ax

IFFORERROR:				; ...
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$IF:					; ...
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:PipeFiles, 0
		jz	short IFNoPipe
		call	PIPEDEL

IFNoPipe:				; ...
		pop	ds
		mov	ds:IFNOTFLAG, 0
		mov	ds:IF_NOT_COUNT, 0
		mov	si, 81h

IFREENT:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short IFFORERROR
		mov	bp, si
		mov	di, offset IFTAB
		mov	ch, 0

IFINDCOM:				; ...
		mov	si, bp
		mov	cl, [di]
		inc	di
		jcxz	short IFSTRING
		jmp	short FIRSTCOMP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFCOMP:					; ...
		jnz	short IF_DIF

FIRSTCOMP:				; ...
		lodsb
		mov	ah, es:[di]
		inc	di
		cmp	al, ah
		jz	short IFLP
		or	ah, 20h
		cmp	al, ah

IFLP:					; ...
		loop	IFCOMP

IF_DIF:					; ...
		lahf
		add	di, cx
		mov	bx, [di]
		inc	di
		inc	di
		sahf
		jnz	short IFINDCOM
		lodsb
		cmp	al, 0Dh

IFERRJ:					; ...
		jz	short IFFORERROR ; IFERROR
		call	DELIM
		jnz	short IFINDCOM
		call	scanoff
		jmp	bx
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFNOT:					; ...
		not	ds:IFNOTFLAG
		inc	ds:IF_NOT_COUNT
		jmp	short IFREENT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFSTRING:				; ...
		push	si
		xor	cx, cx

FIRST_STRING:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORP
		call	DELIM
		jz	short EQUAL_CHECK
		inc	cx
		jmp	short FIRST_STRING
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EQUAL_CHECK:				; ...
		cmp	al, '='
		jz	short EQUAL_CHECK2
		cmp	al, 0Dh
		jz	short IFERRPJ
		lodsb
		jmp	short EQUAL_CHECK
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EQUAL_CHECK2:				; ...
		lodsb
		cmp	al, '='
		jnz	short IFERRPJ
		call	scanoff
		cmp	al, 0Dh
		jz	short IFERRPJ
		pop	di
		repe cmpsb
		jz	short MATCH
		dec	si
		cmp	byte ptr [si], 0Dh
		jz	short IFERRJ

SKIPSTRINGEND:				; ...
		lodsb

NOTMATCH:				; ...
		cmp	al, 0Dh

IFERRORJ2:				; ...
		jz	short IFERRJ
		call	DELIM
		jnz	short SKIPSTRINGEND
		mov	al, 0FFh	; -1
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERRPJ:				; ...
		jmp	IFERRORP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MATCH:					; ...
		lodsb
		call	DELIM
		jnz	short NOTMATCH
		xor	al, al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFEXISTS:				; ...
		lodsb
		call	DELIM
		jnz	short IFEXISTS
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	bx, 2
		add	bx, ds:IF_NOT_COUNT
		mov	ax, offset ARG_ARGV ; mov ax,ARG
		call	argv_calc
		mov	dx, [bx]
		mov	cx, 6
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short IF_EX_C
		xor	al, al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IF_EX_C:				; ...
		mov	al, 0FFh

IFRET:					; ...
		test	ds:IFNOTFLAG, 0FFh
		jz	short REALTEST
		not	al

REALTEST:				; ...
		or	al, al
		jz	short IFTRUE
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFTRUE:					; ...
		call	scanoff
		mov	cx, si
		sub	cx, 81h
		sub	ds:80h,	cl
		mov	cl, ds:80h
		mov	ds:COMBUF+1, cl
		mov	di, (offset COMBUF+2)
		cld
		rep movsb
		mov	al, 0Dh
		stosb
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:IfFlag, 0FFh
		pop	ds
		jmp	DOCOM1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERRORJ3:				; ...
		jmp	IFERRORJ2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERLEV:				; ...
		mov	bh, 10
		xor	bl, bl

GETNUMLP:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORJ3
		call	DELIM
		jz	short GOTNUM
		sub	al, '0'
		xchg	al, bl
		mul	bh
		add	al, bl
		xchg	al, bl
		jmp	short GETNUMLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTNUM:					; ...
		push	ds
		mov	ds, ds:RESSEG
		mov	ah, byte ptr ds:RetCode
		pop	ds
		xor	al, al
		cmp	ah, bl
		jnb	short IFRET
		dec	al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SHIFT:					; ...
		mov	ds, ds:RESSEG
		mov	ax, ds:Batch
		or	ax, ax
		jnz	short SHIFT1

SHIFT_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SHIFT1:					; ...
		mov	es, ax
		mov	ds, ax
		mov	di, 0Ch		; BATCHSEGMENT.BatParm
		lea	si, [di+2]
		mov	cx, 9
		rep movsw
		cmp	word ptr [di], 0FFFFh
		jz	short SHIFT_RETN
		mov	si, [di]
		mov	word ptr [di], 0FFFFh ;	-1

SKIPCRLP:				; ...
		lodsb
		cmp	al, 0Dh
		jnz	short SKIPCRLP
		cmp	byte ptr [si], 0
		jz	short SHIFT_RETN
		mov	[di], si
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SKIPDELIM	proc near		; ...
		test	ds:Batch, 0FFFFh ; -1
		jz	short SKIPERR
		call	GETBATBYT
		call	DELIM
		jz	short SKIPDELIM
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SKIPERR:				; ...
		stc

GOTO_RETN:				; ...
		retn
SKIPDELIM	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$CALL:					; ...
		push	si
		push	di
		push	ax
		push	cx
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, 4		; length_call
		mov	di, (offset COMBUF+2)
		mov	cx, 124		; COMBUFLEN-length_call
		rep movsb
		pop	cx
		pop	ax
		pop	di
		pop	si
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:Call_Flag, 1
		mov	ds:Call_Batch_Flag, 1
		cmp	ds:PipeFiles, 0
		jz	short _NOPIPE
		call	PIPEDEL

_NOPIPE:				; ...
		pop	ds
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTO:					; ...
		mov	ds, ds:RESSEG
		test	ds:Batch, 0FFFFh
		jz	short GOTO_RETN
		xor	dx, dx
		push	ds
		mov	ds, ds:Batch
		mov	ds:8, dx	; [BATCHSEGMENT.BatSeek]
		mov	ds:10, dx	; [BATCHSEGMENT.BatSeek+2]
		mov	byte ptr ds:2, 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		call	PROMPTBAT
		mov	di, 5Dh		; FCB+1
		mov	cx, 11
		mov	al, 20h	; ' '
		repne scasb
		jnz	short NOINC
		inc	cx

NOINC:					; ...
		sub	cx, 11
		neg	cx
		mov	es:BWDBUF, cx
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, ':'
		jz	short CHKLABEL

LABLKLP:				; ...
		call	GETBATBYT
		cmp	al, 0Ah
		jnz	short LABLKTST
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, ':'
		jz	short CHKLABEL

LABLKTST:				; ...
		test	ds:Batch, 0FFFFh ; -1
		jnz	short LABLKLP

BADGOTO:				; ...
		call	BATCLOSE
		call	free_batch
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADLAB_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHKLABEL:				; ...
		call	SKIPDELIM
		jb	short BADGOTO
		mov	di, 5Dh		; FCB+1
		mov	cx, es:BWDBUF	; GOTOLEN
		jmp	short GOTBYTE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTCHRLP:				; ...
		push	cx
		call	GETBATBYT
		pop	cx

GOTBYTE:				; ...
		call	testkanj
		jz	short NOTKANJ1
		cmp	al, es:[di]
		jnz	short LABLKTST
		inc	di
		dec	cx
		jcxz	short LABLKTST
		push	cx
		call	GETBATBYT
		pop	cx
		cmp	al, es:[di]
		jmp	short KNEXTLABCHR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ1:				; ...
		or	al, 20h
		cmp	al, es:[di]
		jnz	short TRYUPPER
		jmp	short NEXTLABCHR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRYUPPER:				; ...
		sub	al, 20h	; ' '
		cmp	al, es:[di]

KNEXTLABCHR:				; ...
		jnz	short LABLKTST

NEXTLABCHR:				; ...
		inc	di
		loop	NEXTCHRLP
		call	GETBATBYT
		cmp	es:BWDBUF, 8	; [es:GOTOLEN],8
		jge	short GOTOCONT
		cmp	al, 20h	; ' '
		ja	short LABLKTST

GOTOCONT:				; ...
		cmp	al, 0Dh
		jz	short SKIPLFEED

TONEXTBATLIN:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short TONEXTBATLIN

SKIPLFEED:				; ...
		call	GETBATBYT
		push	es
		mov	es, ds:Batch
		mov	byte ptr es:2, 0 ; BATCHSEGMENT.BatchEOF
		pop	es
		call	BATCLOSE
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATCLOSE	proc near		; ...
		mov	bx, cs:BATHAND
		cmp	bx, 5
		jb	short CLOSERETURN
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

CLOSERETURN:				; ...
		mov	ds:In_Batch, 0
		retn
BATCLOSE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATOPEN		proc near		; ...
		push	ds
		mov	ds, ds:Batch
		assume ds:nothing
		mov	dx, 20h		; BATCHSEGMENT.BatFile
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short SETERRDL
		mov	dx, ds:8	; [BATCHSEGMENT.BatSeek]
		mov	cx, ds:10	; [BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	es:BATHAND, ax
		mov	bx, ax
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	es:BATBUFPOS, 0FFFFh
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SETERRDL:				; ...
		mov	bx, dx
		call	get_ext_error_number
		mov	dx, ax
		mov	al, [bx]
		sub	al, '@'
		pop	ds
		stc
		retn
BATOPEN		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


free_batch	proc near		; ...
		push	es
		mov	bx, ds:Next_Batch
		or	bx, bx
		jz	short fb_ret

_ClearBatch:				; ...
		mov	es, bx
		mov	bx, es:5	; [es:BATCHSEGMENT.BatForPtr]
		cmp	bx, 0
		jz	short no_bat_for
		push	es
		mov	es, bx
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

no_bat_for:				; ...
		mov	cl, es:1	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	bx, es:3	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ds:Batch, bx
		dec	ds:Nest
		jnz	short _ClearBatch
		mov	ds:EchoFlag, cl
		mov	ds:Batch, 0

fb_ret:					; ...
		pop	es
		retn
free_batch	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

FORTERM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cs
		pop	es
		assume es:TRANGROUP
		call	FOROFF
		mov	ds, es:RESSEG
		assume ds:nothing
		cmp	ds:SingleCom, 0FF00h
		jnz	short BAT_CRLF
		cmp	ds:Nest, 0
		jnz	short BAT_CRLF
		mov	ds:SingleCom, 0FFFFh
		jmp	short NOFORP2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BAT_CRLF:				; ...
		test	ds:EchoFlag, 1
		jz	short NOFORP2
		test	ds:Batch, 0FFFFh
		jz	short NOFORP2
		call	CRLF2

NOFORP2:				; ...
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$FOR_EXIT:				; ...
		jmp	short FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORPROC:				; ...
		mov	ax, ds:ForPtr
		mov	ds, ax
		mov	es, ax
		assume es:nothing
		mov	dx, 5CBh	; FOR_INFO.FORDMA
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer

FOR_BEGIN:				; ...
		cmp	word ptr ds:545h, 0 ; FOR_INFO.FOR_EXPAND
		jz	short FOR_BEGIN1
		inc	word ptr ds:547h ; FOR_INFO.FOR_MINARG

FOR_BEGIN1:				; ...
		mov	bx, ds:547h
		cmp	bx, ds:549h	; FOR_INFO.FOR_MAXARG
		jg	short _$FOR_EXIT
		mov	ax, 0
		call	argv_calc
		mov	cx, [bx+3]	; [bx+ARGV_ELE.argstartel]
		mov	dx, [bx]	; [bx+ARGV_ELE.argpointer]
		test	byte ptr [bx+2], 4 ; [bx+ARGV_ELE.argflags]
		jnz	short FORSUB
		mov	si, [bx]
		mov	al, '('
		cmp	[si-1],	al
		jnz	short FORSUB
		inc	cx
		mov	al, ':'
		cmp	[si+1],	al
		jnz	short FORSUB
		add	cx, 2

FORSUB:					; ...
		sub	cx, dx
		cmp	word ptr ds:545h, 0 ; [FOR_INFO.FOR_EXPAND]
		jz	short FOR_FIND_NEXT
		test	byte ptr [bx+2], 2
		jnz	short FOR_FIND_FIRST
		mov	cx, [bx+5]	; [bx+ARGV_ELE.arglen]
		jmp	short FOR_SMOOSH
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_FIND_FIRST:				; ...
		push	cx
		xor	cx, cx
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		pop	cx
		jmp	short FOR_RESULT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_FIND_NEXT:				; ...
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call

FOR_RESULT:				; ...
		mov	ax, 0FFFFh
		jb	short FOR_CHECK
		mov	ax, 0

FOR_CHECK:				; ...
		mov	ds:545h, ax	; [FOR_INFO.FOR_EXPAND]
		or	ax, ax
		jnz	short FOR_BEGIN

FOR_SMOOSH:				; ...
		mov	si, [bx]
		mov	di, 54Bh	; FOR_INFO.FORBUF
		rep movsb
		cmp	word ptr ds:545h, 0 ; [FOR_INFO.FOR_EXPAND]
		jnz	short FOR_MAKE_COM
		mov	si, 5E9h	; FOR_INFO.FORDMA+FIND_BUF.PNAME

FOR_MORE:				; ...
		cmp	byte ptr [si], 0
		jz	short FOR_MAKE_COM
		movsb
		jnz	short FOR_MORE

FOR_MAKE_COM:				; ...
		xor	al, al
		stosb
		xor	cx, cx
		not	cx
		xor	bx, bx
		mov	di, (offset COMBUF+2)
		mov	bl, ds:544h	; [FOR_INFO.FOR_COM_START]
		mov	dh, ds:64Bh	; [FOR_INFO.FOR_VAR]
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	ax, 0		; FOR_INFO.FOR_ARGS = 0
		call	argv_calc
		mov	si, [bx+9]	; [bx+ARGV_ELE.arg_ocomptr]
		inc	si

FOR_MAKE_LOOP:				; ...
		mov	al, [si]
		inc	si
		cmp	al, '%'
		jnz	short FOR_STOSB
		cmp	[si], dh
		jnz	short FOR_STOSB
		inc	si
		push	si
		mov	si, 54Bh	; FOR_INFO.FORBUF

SLOOP:					; ...
		lodsb
		stosb
		or	al, al
		loopne	SLOOP
		dec	di
		inc	cx
		pop	si
		jmp	short FOR_MAKE_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_STOSB:				; ...
		stosb
		dec	cx
		cmp	al, 0Dh
		jnz	short FOR_MAKE_LOOP
		not	cl
		mov	es:COMBUF+1, cl
		mov	ds, es:RESSEG
		test	ds:EchoFlag, 1
		jz	short NOECHO3
		cmp	ds:NullFlag, 1
		jz	short NO_CRLF_PR
		call	CRLF2

NO_CRLF_PR:				; ...
		mov	ds:NullFlag, 0
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	di
		call	PRINT_PROMPT
		pop	di
		mov	byte ptr es:[di-1], 0
		mov	string_ptr_2, (offset COMBUF+2)
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	byte ptr es:[di-1], 0Dh
		jmp	DOCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOECHO3:				; ...
		mov	ds:NullFlag, 0
		push	cs
		pop	ds
		jmp	DOCOM1
; END OF FUNCTION CHUNK	FOR PROMPTBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORNESTERRJ:				; ...
		call	FOROFF
		jmp	FORNESTERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORERRORJ:				; ...
		jmp	IFFORERROR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$FOR:					; ...
		mov	es, RESSEG
		assume es:nothing
		cmp	es:ForFlag, 0
		jnz	short FORNESTERRJ
		cmp	es:PipeFiles, 0
		jz	short NO_PIPE
		call	PIPEDEL

NO_PIPE:				; ...
		xor	dx, dx
		call	NEXTARG
		jb	short FORERRORJ
		cmp	al, '%'
		jnz	short FORERRORJ
		mov	bp, ax
		lodsb
		or	al, al
		jnz	short FORERRORJ
		call	NEXTARG
		jb	short FORERRORJ
		and	ax, 0DFDFh	; ~2020h (not 2020h)
		cmp	ax, 'NI'        ; "IN"
		jnz	short FORERRORJ
		lodsb
		or	al, al
		jnz	short FORERRORJ

CHECKLPAREN:
		call	NEXTARG
		jb	short FORERRORJ

LPCHECK:
		cmp	al, '('
		jnz	short FORERRORJ
		cmp	ah, 0
		jz	short FOR_PAREN_TOKEN
		cmp	ah, ')'
		jnz	short FOR_LIST_NOT_EMPTY
		jmp	FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_LIST_NOT_EMPTY:			; ...
		inc	word ptr [bx]	; [bx+ARGV_ELE.argpointer] ; [bx+0]
		dec	word ptr [bx+5]	; [bx+ARGV_ELE.arglen]
		inc	si
		jmp	short FOR_LIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_PAREN_TOKEN:			; ...
		call	NEXTARG
		jb	short FORERRORJ
		cmp	ax, 29h		; db 29h,0 ; db	')',0
		jnz	short FOR_LIST
		jmp	FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORERORJJ:				; ...
		jmp	IFFORERROR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_LIST:				; ...
		mov	cx, dx

SKIP_LIST:				; ...
		add	si, [bx+5]	; [bx+ARGV_ELE.arglen]
		sub	si, 3
		mov	al, ')'
		cmp	[si], al
		jz	short FOR_END_LIST
		call	NEXTARG
		jb	short FORERORJJ
		jmp	short SKIP_LIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_END_LIST:				; ...
		mov	di, dx
		mov	byte ptr [si], 0
		cmp	ax, 29h		; db 29h,0 ; db	')',0
		jz	short FOR_DO
		inc	di

FOR_DO:					; ...
		call	NEXTARG
		jb	short FORERORJJ
		and	ax, 0DFDFh	; and ax,~2020h
		cmp	ax, 'OD'        ; "DO" ; 4F44h
		jnz	short FORERORJJ
		lodsb
		or	al, al
		jnz	short FORERORJJ
		call	NEXTARG
		jb	short FORERORJJ
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		call	FREE_TPA
		call	FOROFF
		mov	bx, 264		; FOR_INFO.size-ARG_UNIT.SIZE
		call	SAVE_ARGS
		pushf
		mov	es:ForPtr, ax
		call	ALLOC_TPA
		popf
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short FOR_ALLOC_ERR
		push	es
		push	es:ForPtr
		pop	es
		dec	cx
		dec	di
		mov	es:547h, cx	; [es:FOR_INFO.FOR_MINARG]
		mov	es:549h, di	; [es:FOR_INFO.FOR_MAXARG]
		mov	es:544h, dl	; [es:FOR_INFO.FOR_COM_START]
		mov	word ptr es:545h, 0FFFFh ; [es:FOR_INFO.FOR_EXPAND]
		mov	ax, bp
		mov	es:64Bh, ah	; [es:FOR_INFO.FOR_VAR]
		pop	es
		inc	es:ForFlag
		cmp	es:SingleCom, 0FFFFh
		jnz	short FOR_RET
		mov	es:SingleCom, 0FF00h

FOR_RET:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_ALLOC_ERR:				; ...
		mov	msg_disp_class,	1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


NEXTARG		proc near		; ...
		inc	dx
		cmp	dx, ARG_ARGVCNT	; [ARG+ARG_UNIT.argvcnt]
		jge	short NEXTARG_ERR
		mov	bx, dx
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv
		call	argv_calc
		mov	si, [bx]	; [bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
		lodsw
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTARG_ERR:				; ...
		stc
		retn
NEXTARG		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORNESTERR:				; ...
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		mov	dx, offset FORNESTMES_PTR
		cmp	ds:SingleCom, 0FF00h
		jnz	short NOFORP3
		mov	ds:SingleCom, 0FFFFh

NOFORP3:				; ...
		pop	ds
		jmp	cerror

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FOROFF		proc near		; ...
		push	ax
		push	es
		mov	es, cs:RESSEG
		mov	ax, es:ForPtr
		or	ax, ax
		jz	short FREEDONE
		push	es
		mov	es, ax
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

FREEDONE:				; ...
		mov	es:ForPtr, 0
		mov	es:ForFlag, 0
		pop	es
		pop	ax
		retn
FOROFF		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CATALOG:				; ...
		call	SetDefaults
		call	ParseEnvironment
		call	ParseCmdLine
		jnb	short catalog1
		jmp	catErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catalog1:				; ...
		call	SetOptions
		call	SetCollatingTable
		test	ds:_Bits, 8	; mask.bare
		jnz	short catalog2
		call	OkVolArg
		sub	ds:LeftOnPage, 2
		jmp	short catCrunch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catalog2:				; ...
		call	DisAppend
		mov	dx, offset BWDBUF ; offset TRANGROUP:DirBuf
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	di, 5Ch		; FCB
		inc	di
		mov	al, '?'
		mov	cx, 11
		rep stosb

catCrunch:				; ...
		call	CrunchPath
		jb	short catRecErr
		cmp	ds:COMSW, 0
		jnz	short catRecErr
		call	InstallCtrlC
		call	ZeroTotals
		call	ListDir
		jb	short catExtErr
		test	ds:_Bits, 4	; mask.subd
		jz	short catalog3
		call	ListSubds
		jb	short catExtErr

catalog3:				; ...
		test	ds:_Bits, 8
		jnz	short catRet
		mov	ax, word ptr ds:FileCntTotal
		or	ax, ax
		jz	short catNoFiles
		call	DisplayTotals
		jmp	short catRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catRecErr:				; ...
		test	ds:COMSW, 1	; mask.dev
		jnz	short catNoFiles
		test	ds:COMSW, 2	; mask.baddir
		jz	short catExtErr
		mov	dx, offset badcd_ptr
		jmp	short catErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catNoFiles:				; ...
		call	DisplayHeader
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		jmp	short catErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catExtErr:				; ...
		call	Set_Ext_Error_Msg
		cmp	ds:extend_buf_ptr, 18 ;	ERROR_NO_MORE_FILES
		jnz	short catErr
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND

catErr:					; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catRet:					; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetDefaults	proc near		; ...
		mov	di, offset SrcBuf
		mov	ds:PathPos, di
		mov	al, '*'
		stosb
		mov	al, 0Dh
		stosb
		mov	ds:PathCnt, 1
		xor	ax, ax
		mov	ds:COMSW, ax
		mov	ds:_Bits, ax
		mov	ds:DestBuf, al
		mov	ds:AttrSpecified, 6 ; ATTR_HIDDEN+ATTR_SYSTEM
		mov	ds:AttrSelect, al
		retn
SetDefaults	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ParseEnvironment:			; ...
		call	GetEnvValue
		jb	short peRet
		call	Parse_Line
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short peRet
		call	std_eprintf
		mov	ds:msg_disp_class, 0FFh
		mov	dx, offset errparsenv_ptr
		call	Printf_Crlf

peRet:					; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseCmdLine	proc near		; ...
		mov	si, 81h
		call	Parse_Line
		cmp	ax, 0FFFFh
		jz	short pcOk
		stc
		jmp	short pcRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pcOk:					; ...
		clc

pcRet:					; ...
		retn
ParseCmdLine	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetCollatingTable proc near		; ...
		mov	dx, offset STACK ; offset TRANGROUP:InternatVars
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jb	short scNoTable
		cmp	bx, 1
		jz	short scNoTable
		mov	ax, 6506h
		mov	bx, 0FFFFh
		mov	cx, 5
		mov	dx, bx
		mov	di, offset CountryPtrInfo
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		jnb	short scRet

scNoTable:				; ...
		mov	ds:CountryPtrInfo, 0 ; CountryPtrId

scRet:					; ...
		retn
SetCollatingTable endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetOptions	proc near		; ...
		test	ds:_Bits, 8	; mask.bare
		jz	short setopts1
		and	ds:_Bits, 0FFFEh ; ~mask.wide ;	not mask.wide

setopts1:				; ...
		push	ds
		mov	ax, 40h		; ROMBIOS_DATA
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:84h	; CRT_Rows
		pop	ds
		assume ds:nothing
		or	al, al
		jnz	short setopts2
		mov	al, 25

setopts2:				; ...
		xor	ah, ah

setopts3:
		inc	al
		mov	ds:LinPerPag, ax
		mov	ax, 440Ch
		mov	bx, 1
		mov	ch, 3
		mov	cl, 7Fh
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		mov	ax, ds:LinPerPag
		mov	ds:LeftOnPage, ax
		mov	ds:PerLine, 1	; NORMPERLIN
		test	ds:_Bits, 1	; mask.wide
		jz	short setopts4
		mov	ds:PerLine, 5	; WIDEPERLIN

setopts4:				; ...
		cmp	ds:SrcBuf+1, ':'
		jnz	short soRet
		mov	al, ds:SrcBuf
		and	al, 0DFh
		sub	al, '@'
		mov	ds:5Ch,	al	; [FCB]

soRet:					; ...
		retn
SetOptions	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CrunchPath:				; ...
		call	FileIsDevice
		jnz	short crpath1
		or	ds:COMSW, 1	; mask.dev
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

crpath1:				; ...
		push	ds:PathPos
		mov	ds:DirFlag, 0FFh ; -1
		call	PathCrunch
		mov	ds:DirFlag, 0
		pop	si
		jb	short cpNoDir
		jz	short cpRet
		mov	si, ds:DestTail
		jmp	short cpFile
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpNoDir:				; ...
		mov	ax, ds:Msg_Numb
		or	ax, ax
		jnz	short cpErr
		cmp	ds:DestIsDir, 0
		jz	short cpMaybe
		or	ds:COMSW, 2	; mask.baddir
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpMaybe:				; ...
		cmp	byte ptr [si+1], ':'
		jnz	short crpath2
		lodsw

crpath2:				; ...
		cmp	word ptr [si], '..'
		jnz	short cpFile
		cmp	byte ptr [si+2], 0
		jnz	short cpFile
		or	ds:COMSW, 2
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpFile:					; ...
		mov	di, 5Ch		; FCB
		mov	ax, 290Eh
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		clc
		jmp	short cpRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpErr:					; ...
		stc

cpRet:					; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


InstallCtrlC	proc near		; ...
		push	es
		mov	ax, 3523h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr ds:OldCtrlCHandler, bx
		mov	word ptr ds:OldCtrlCHandler+2, es
		pop	es
		mov	dx, offset CtrlCHandler
		mov	ax, 2523h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		retn
InstallCtrlC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ListSubds	proc near		; ...
		call	SetRest1
		mov	bx, offset ScanBuf

lsNode:					; ...
		mov	byte ptr [bx], 0

lsLoop:					; ...
		call	FindNextChild
		jb	short lsErr
		mov	dx, bx
		call	ChangeDir
		jnb	short lstsd1
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short lsLoop
		jmp	short lsRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lstsd1:					; ...
		push	bx
		call	ListDir
		pop	bx
		mov	di, bx
		mov	cx, 13
		xor	al, al
		repne scasb
		push	bx
		mov	bx, di
		call	lsNode
		pop	bx
		pushf
		mov	ax, 0
		push	ax
		mov	ax, '..'
		push	ax
		mov	dx, sp
		call	ChangeDir
		pop	ax
		pop	ax
		popf
		jb	short lsRet
		jmp	short lsLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lsErr:					; ...
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short lsRet
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short lsRet
		stc

lsRet:					; ...
		retn
ListSubds	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckChild	proc near		; ...
		test	ds:DIRBUF_find_buf_attr, 10h ; [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY
		jz	short ccRet
		cmp	ds:DIRBUF_find_buf_pname, '.' ; [DIRBUF+FIND_BUF.PNAME],'.'
		jz	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bx
		call	CmpAscz
		jbe	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bp
		call	CmpAscz
		jnb	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bp
		mov	cx, 13
		rep movsb

ccRet:					; ...
		retn
CheckChild	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CmpEntry	proc near		; ...
		mov	si, offset DestBuf

ceLoop:					; ...
		xor	ax, ax
		mov	al, [si]
		or	al, al
		jz	short ceDone
		inc	si
		push	si
		dec	al
		shl	al, 1
		mov	si, ax
		mov	ax, cs:FieldCmps[si]
		jb	short ceDn
		call	ax
		jmp	short ceNs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ceDn:					; ...
		xchg	bx, bp
		call	ax
		xchg	bx, bp

ceNs:					; ...
		pop	si
		jz	short ceLoop

ceDone:					; ...
		retn
CmpEntry	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
FieldCmps	dw offset CmpName	; ...
		dw offset CmpExt
		dw offset CmpTime
		dw offset CmpSize
		dw offset CmpType
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpName:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 1		; entry.filename
		add	di, 1		; entry.filename
		mov	cx, 8		; size entry.filename
		jmp	short CmpStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpExt:					; ...
		mov	si, bx
		mov	di, bp
		add	si, 9		; entry.fileext
		add	di, 9		; entry.fileext
		mov	cx, 3		; size entry.fileext

CmpStr:					; ...
		cmp	ds:CountryPtrInfo, 6 ; CountryPtrId
		jnz	short cnNoCollTable
		push	bp
		push	bx
		push	ds
		lds	bx, ds:CountryPtr
		mov	bp, [bx]
		inc	bx
		inc	bx
		xor	ax, ax

cnNextChar:				; ...
		mov	al, es:[di]
		inc	di
		cmp	ax, bp
		jnb	short cn1
		xlat

cn1:					; ...
		mov	dx, ax
		lods	byte ptr es:[si]
		cmp	ax, bp
		jnb	short cn2
		xlat

cn2:					; ...
		cmp	ax, dx
		loope	cnNextChar
		pop	ds
		pop	bx
		pop	bp
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cnNoCollTable:				; ...
		repe cmps byte ptr es:[si], byte ptr es:[di]
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpTime:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 16		; entry.filedate + size	entry.filedate - 1
		add	di, 16		; entry.filedate + size	entry.filedate - 1
		mov	cx, 4		; size entry.filetime +	size entry.filedate
		std
		repe cmps byte ptr es:[si], byte ptr es:[di]
		cld
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpSize:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 20
		add	di, 20
		mov	cx, 4
		std
		repe cmps byte ptr es:[si], byte ptr es:[di]
		cld
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpType:				; ...
		mov	al, es:[bx+12]	; entry.fileattr
		mov	ah, es:[bp+12]
		and	ax, 1010h	; (ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
		cmp	ah, al
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DefaultAttr	proc near		; ...
		mov	ds:AttrSpecified, 6 ; ATTR_HIDDEN+ATTR_SYSTEM
		mov	ds:AttrSelect, 0
		clc
		retn
DefaultAttr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTotals	proc near		; ...
		test	ds:_Bits, 4	; mask.subd
		jz	short dtFree
		call	CRLF2
		call	UseLine
		mov	dx, offset total_ptr
		call	std_printf
		call	UseLine
		mov	ax, word ptr ds:FileCntTotal
		mov	si, offset FileSizTotal
		mov	di, offset FileSiz
		movsw
		movsw
		call	DisplayCntSiz

dtFree:					; ...
		mov	ah, 36h
		mov	dl, ds:5Ch
		int	21h		; DOS -	2+ - GET DISK SPACE
					; DL = drive code (0 = default,	1 = A, 2 = B, etc.)
		cmp	ax, 0FFFFh	; -1
		jz	short dtRet
		mul	cx
		mul	bx
		mov	word ptr ds:Bytes_Free,	ax
		mov	word ptr ds:Bytes_Free+2, dx
		mov	dx, offset bytmes_ptr
		call	std_printf
		call	UseLine

dtRet:					; ...
		retn
DisplayTotals	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FileIsDevice	proc near		; ...
		mov	dx, ds:PathPos
		mov	di, dx
		add	di, ds:PathCnt
		xor	bl, bl
		xchg	bl, [di]
		xor	cx, cx
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		xchg	bl, [di]
		jb	short piCol
		test	ds:DIRBUF_find_buf_attr, 40h ; ATTR_DEVICE
		jz	short piCol
		xor	cx, cx
		jmp	short piRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

piCol:					; ...
		dec	di
		mov	al, ':'         ; COLON_CHAR
		mov	cx, ds:PathCnt
		dec	cx
		dec	cx
		or	cx, cx
		js	short piRet
		or	di, di
		std
		repne scasb
		cld

piRet:					; ...
		retn
FileIsDevice	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindFirst	proc near		; ...
		mov	ax, offset GetFirst
		jmp	short ffFindEntry
FindFirst	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNext	proc near		; ...
		mov	ax, offset GetNext

ffFindEntry:				; ...
		push	es
		test	ds:_Bits, 20h	; mask.inmem
		jz	short ffDisk
		call	FindInMem
		jmp	short ffRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ffDisk:					; ...
		call	ax
		jb	short ffGetErr
		mov	es, ds:TPA
		xor	di, di
		mov	bx, di
		call	LoadEntry
		clc
		jmp	short ffRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ffGetErr:				; ...
		call	get_ext_error_number
		stc

ffRet:					; ...
		pop	es
		retn
FindNext	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindInMem	proc near		; ...
		mov	es, ds:TPA
		xor	bx, bx
		cld
		call	FindOneInMem
		jb	short fiNoMore

fiBest:					; ...
		mov	bp, bx

fiNext:					; ...
		call	FindNextInMem
		jb	short fiFound
		call	CmpEntry
		jnb	short fiNext
		jmp	short fiBest
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fiNoMore:				; ...
		mov	ax, 18		; ERROR_NO_MORE_FILES
		stc
		jmp	short fiRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fiFound:				; ...
		mov	bx, bp
		mov	byte ptr es:[bx], 1 ; used entry
		clc

fiRet:					; ...
		retn
FindInMem	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNextChild	proc near		; ...
		sub	sp, 12
		mov	ax, 0FFh
		push	ax
		mov	bp, sp
		mov	ax, '*'         ; 002Ah
		push	ax
		mov	ax, 2E2Ah	; '*.'
		push	ax
		call	GetDriveLtr
		push	ax
		mov	dx, sp
		mov	cx, 10h		; ATTR_DIRECTORY
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short fcRet
		call	CheckChild

fcNext:					; ...
		mov	cx, 10h
		mov	ah, 4Fh
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jb	short fcErr
		call	CheckChild
		jmp	short fcNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcErr:					; ...
		call	get_ext_error_number
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jnz	short fcNope
		cmp	byte ptr [bp+0], 0FFh
		jz	short fcNope
		mov	si, bp
		mov	di, bx

fcMove:					; ...
		lodsb
		stosb
		or	al, al
		jz	short fcRet
		jmp	short fcMove
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcNope:					; ...
		stc

fcRet:					; ...
		lahf
		add	sp, 20
		sahf
		retn
FindNextChild	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindOneInMem	proc near		; ...

; FUNCTION CHUNK AT 1509 SIZE 00000002 BYTES

		mov	al, es:[bx]
		cmp	al, 1
		jz	short FindNextInMem
		cmp	al, 0FFh
		jz	short foNoMore
		clc
		retn
FindOneInMem	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNextInMem	proc near		; ...
		add	bx, 21		; size EntryStruc
		jmp	short FindOneInMem
FindNextInMem	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR FindOneInMem

foNoMore:				; ...
		stc
		retn
; END OF FUNCTION CHUNK	FOR FindOneInMem

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetEnvValue	proc near		; ...
		push	es
		mov	si, offset DirEnvVar ; "DIRCMD="
		call	find_name_in_environment
		jb	short geRet
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		mov	di, offset ScanBuf

geLoop:					; ...
		lodsb
		or	al, al
		stosb
		loopne	geLoop
		push	es
		pop	ds
		mov	si, offset ScanBuf

geRet:					; ...
		pop	es
		retn
GetEnvValue	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetFirst	proc near		; ...
		mov	byte ptr ds:55h, 0FFh ;	[FCB-7]
		mov	byte ptr ds:5Bh, 16h ; mov byte	[FCB-1],ATTR_ALL
		mov	dx, 55h		; FCB-7
		mov	ah, 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		shl	al, 1
		jb	short gfRet
		jmp	short gfFound
GetFirst	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetNext		proc near		; ...
		mov	dx, 55h
		mov	ah, 12h
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		shl	al, 1
		jb	short gfRet

gfFound:				; ...
		mov	al, byte ptr ds:DIRBUF_8_DIR_ATTR ;
					; [DIRBUF+8+DIR_ENTRY.DIR_ATTR]
		mov	ah, ds:AttrSpecified
		and	al, ah
		and	ah, ds:AttrSelect
		cmp	al, ah
		jnz	short GetNext

gfRet:					; ...
		retn
GetNext		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ListDir		proc near		; ...
		xor	ax, ax
		mov	ds:FileCnt, ax
		mov	word ptr ds:FileSiz, ax
		mov	word ptr ds:FileSiz+2, ax
		cmp	ds:DestBuf, 0
		jz	short ld1
		call	LoadEntries
		jnb	short ld1
		call	get_ext_error_number
		stc
		jmp	short ldErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ld1:					; ...
		call	FindFirst
		jb	short ldErr
		call	DisplayHeader
		call	DisplayFile

ldNext:					; ...
		call	FindNext
		jb	short ldErr
		call	DisplayFile
		jmp	short ldNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ldErr:					; ...
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short ldDone
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short ldDone
		stc
		jmp	short ldRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ldDone:					; ...
		cmp	ds:FileCnt, 0
		jz	short ld2
		call	DisplayTrailer

ld2:					; ...
		clc

ldRet:					; ...
		retn
ListDir		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadEntries	proc near		; ...
		push	es
		mov	es, ds:TPA
		xor	di, di
		and	ds:_Bits, 0FFDFh ; ~mask.inmem ; not mask.inmem
		call	GetFirst
		jb	short leRet
		call	LoadEntry

leNext:					; ...
		call	GetNext
		jb	short leLoaded
		mov	ax, ds:BYTCNT
		sub	ax, di
		cmp	ax, 23		; size EntryStruc+2
		jb	short leOk
		call	LoadEntry
		jmp	short leNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

leLoaded:				; ...
		mov	byte ptr es:[di], 0FFh
		or	ds:_Bits, 20h	; mask.inmem

leOk:					; ...
		clc

leRet:					; ...
		pop	es
		retn
LoadEntries	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadEntry	proc near		; ...
		mov	si, offset DIRBUF_8 ; DIRBUF+8
		xor	al, al
		stosb
		mov	cx, 11
		rep movsb
		lodsb
		stosb
		add	si, 10		; (DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
		movsw
		movsw
		inc	si
		inc	si
		and	al, 10h		; ATTR_DIRECTORY
		jnz	short leSetDirSize
		movsw
		movsw
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

leSetDirSize:				; ...
		xor	ax, ax
		stosw
		stosw
		retn
LoadEntry	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


NoOrder		proc near		; ...
		mov	ds:DestBuf, 0
		clc
		retn
NoOrder		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


OnOffSw		proc near		; ...
		mov	cx, di
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1
		shl	ax, cl
		test	di, 2
		jz	short oo1
		or	ds:_Bits, ax
		jmp	short ooRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oo1:					; ...
		not	ax
		and	ds:_Bits, ax

ooRet:					; ...
		clc
		retn
OnOffSw		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseAttr	proc near		; ...
		push	si
		mov	ds:AttrSpecified, 0
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]

paLoop:					; ...
		mov	dx, 1
		lodsb
		or	al, al
		jz	short paOk
		cmp	al, '-'
		jnz	short pa1
		dec	dx
		lodsb

pa1:					; ...
		mov	di, offset AttrLtrs ; "RHSvDA"
		mov	cx, 6		; NUM_ATTR_LTRS
		repne scasb
		jnz	short paErr
		not	cx
		add	cx, 6
		mov	al, 1
		shl	al, cl
		or	ds:AttrSpecified, al
		not	al
		and	ds:AttrSelect, al
		shl	dl, cl
		or	ds:AttrSelect, dl
		jmp	short paLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

paErr:					; ...
		call	SetupParamError
		stc
		jmp	short paRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

paOk:					; ...
		clc

paRet:					; ...
		pop	si
		retn
ParseAttr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Parse_Line	proc near		; ...
		mov	di, offset PARSE_DIR
		xor	cx, cx

plPars:					; ...
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short plRet
		cmp	ax, 0
		jnz	short plRet
		mov	bx, dx
		cmp	byte ptr [bx], 5 ; RESULT_FILESPEC
		jz	short plFil
		call	ParseSwitch
		jb	short plRet
		jmp	short plPars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plFil:					; ...
		call	CopyPathname
		jmp	short plPars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plRet:					; ...
		retn
Parse_Line	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseOrder	proc near		; ...
		push	si
		push	bx
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	bx, offset DestBuf
		mov	al, [si]
		or	al, al
		jnz	short poLtr
		mov	byte ptr [bx], 5 ; sort	1st by group
		inc	bx
		mov	byte ptr [bx], 1 ; then	by name
		inc	bx
		mov	byte ptr [bx], 2 ; then	by extension
		inc	bx
		jmp	short poOk
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poLtr:					; ...
		xor	dl, dl
		lodsb
		or	al, al
		jz	short poOk
		cmp	al, '-'
		jnz	short po1
		mov	dl, 80h
		lodsb

po1:					; ...
		mov	di, offset OrderLtrs ; "NEDSG"
		mov	cx, 5		; NUM_ORDER_LTRS
		repne scasb
		jnz	short poErr
		neg	cx
		add	cx, 5		; NUM_ORDER_LTRS
		or	cl, dl
		mov	[bx], cl
		inc	bx
		cmp	bx, offset EndDestBuf
		jnb	short poErr
		jmp	short poLtr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poErr:					; ...
		pop	bx
		call	SetupParamError
		stc
		jmp	short poRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poOk:					; ...
		mov	byte ptr [bx], 0
		pop	bx
		clc

poRet:					; ...
		pop	si
		retn
ParseOrder	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseSwitch	proc near		; ...
		push	cx
		push	di
		mov	ax, [bx+2]	; [bx+ResultBuffer.SynPtr]
		mov	di, offset Dir_Sw_Ptrs
		mov	cx, 14		; NUM_DIR_SWS
		cld
		repne scasw
		sub	di, offset Dir_Sw_Ptrs_2 ; Dir_Sw_Ptrs+2
		call	cs:SwHandler[di]
		pop	di
		pop	cx
		retn
ParseSwitch	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SwHandler	dw offset OnOffSw	; ...
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset NoOrder
		dw offset ParseOrder
		dw offset DefaultAttr
		dw offset ParseAttr

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ChangeDir	proc near		; ...
		mov	di, offset BWDBUF ; DIRBUF
		call	GetDriveLtr
		stosw
		mov	si, dx

cdLoop:					; ...
		lodsb
		stosb
		or	al, al
		jnz	short cdLoop
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		retn
ChangeDir	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CmpAscz		proc near		; ...
		push	di
		mov	di, si
		xor	al, al
		mov	cx, 0FFFFh
		repne scasb
		not	cx
		pop	di
		repe cmpsb
		retn
CmpAscz		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CopyPathname	proc near		; ...
		push	si
		lds	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		call	Move_To_SrcBuf
		pop	si
		retn
CopyPathname	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CountFile	proc near		; ...
		push	es
		mov	es, ds:TPA
		inc	ds:FileCnt
		inc	word ptr ds:FileCntTotal
		jnz	short cntf1
		inc	word ptr ds:FileCntTotal+2

cntf1:					; ...
		mov	ax, es:[bx+17]	; EntryStruc.filesize
		mov	dx, es:[bx+19]	; EntryStruc.filesize +	2
		add	word ptr ds:FileSiz, ax
		adc	word ptr ds:FileSiz+2, dx
		add	word ptr ds:FileSizTotal, ax
		adc	word ptr ds:FileSizTotal+2, dx
		pop	es
		retn
CountFile	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayBare	proc near		; ...
		mov	cx, ds
		mov	ds, ds:TPA
		cmp	byte ptr [bx+1], '.' ; [bx+EntrStruc.filename]
		mov	ds, cx
		jz	short dbRet
		test	ds:_Bits, 4	; mask.subd
		jz	short dbNameExt
		call	build_dir_string
		mov	di, offset BWDBUF
		test	ds:_Bits, 10h
		jz	short dbare1
		mov	si, di
		call	LowercaseString

dbare1:					; ...
		xor	al, al
		mov	cx, 0FFFFh
		cld
		repne scasb
		dec	di
		cmp	byte ptr es:[di-1], '\'
		jz	short dbare2
		mov	ax, '\'
		stosw

dbare2:					; ...
		mov	ds:string_ptr_2, offset	BWDBUF
		mov	dx, offset string_buf_ptr
		call	std_printf

dbNameExt:				; ...
		call	DisplayDotForm
		call	CRLF2
		call	UseLine

dbRet:					; ...
		retn
DisplayBare	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayDotForm	proc near		; ...
		push	ds
		push	es
		mov	ax, cs:TPA
		mov	ds, ax
		assume ds:RESGROUP
		mov	es, ax
		assume es:RESGROUP
		mov	di, bx
		add	di, 8		; filename + size filename - 1
		mov	cx, 8		; size filename	= 8 ; size of EntryStruc.filename
		mov	al, 20h	; ' '
		std
		repe scasb
		inc	cx
		mov	dx, cx
		mov	si, bx
		add	si, 1		; add si,EntryStruc.filename

NextNameChar:				; ...
		cld
		lodsb
		test	ss:_Bits, 10h	; mask.lcase
		jz	short ddf1
		call	LowerCase

ddf1:					; ...
		call	PRINT_CHAR
		loop	NextNameChar
		mov	di, bx
		add	di, 11		; fileext + size fileext - 1
		mov	cx, 3		; size fileext
		mov	al, 20h	; ' '
		std
		repe scasb
		jz	short ddDone
		inc	cx
		add	dx, cx
		inc	dx
		mov	al, '.'
		call	PRINT_CHAR
		mov	si, bx
		add	si, 9		; EntryStruc.fileext

NextExtChar:				; ...
		cld
		lodsb
		test	cs:_Bits, 10h
		jz	short ddf2
		call	LowerCase

ddf2:					; ...
		call	PRINT_CHAR
		loop	NextExtChar

ddDone:					; ...
		pop	es
		assume es:nothing
		pop	ds
		assume ds:nothing
		cld
		retn
DisplayDotForm	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayFile	proc near		; ...
		test	ds:_Bits, 8	; mask.bare
		jz	short dfNorm
		call	DisplayBare
		jmp	short dfRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dfNorm:					; ...
		call	DisplayNext
		test	ds:_Bits, 1	; mask.wide
		jz	short dfFul
		call	DisplayWide
		jmp	short dfCnt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dfFul:					; ...
		call	DisplayName
		call	DisplayTheRest

dfCnt:					; ...
		call	CountFile

dfRet:					; ...
		retn
DisplayFile	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayHeader	proc near		; ...
		test	ds:_Bits, 8	; mask.bare
		jnz	short dhRet
		test	ds:_Bits, 4	; mask.subd
		jz	short dhNorm
		call	CRLF2
		call	UseLine
		jmp	short dhCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dhNorm:					; ...
		mov	al, 20h	; ' '
		call	PRINT_CHAR

dhCom:					; ...
		call	build_dir_string
		mov	dx, offset dirhead_ptr
		call	std_printf
		call	UseLine
		call	CRLF2
		call	UseLine

dhRet:					; ...
		retn
DisplayHeader	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayName	proc near		; ...
		push	ds
		mov	ds, ds:TPA
		mov	si, bx
		add	si, 1		; EntryStruc.filename
		mov	di, offset CHARBUF
		mov	cx, 8
		cld
		rep movsb
		mov	al, 20h	; ' '
		stosb
		mov	cx, 3
		rep movsb
		xor	al, al
		stosb
		pop	ds
		test	ds:_Bits, 10h	; mask.lcase
		jz	short dn1
		mov	si, offset CHARBUF
		call	LowercaseString

dn1:					; ...
		mov	ds:string_ptr_2, offset	CHARBUF
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
DisplayName	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayNext	proc near		; ...
		cmp	ds:FileCnt, 0
		jz	short dn1st
		cmp	ds:LeftOnLine, 0
		jle	short dnEol
		mov	dx, offset tab_ptr
		call	std_printf
		jmp	short dnDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dnEol:					; ...
		call	CRLF2
		call	UseLine

dn1st:					; ...
		mov	al, ds:PerLine
		mov	ds:LeftOnLine, al

dnDone:					; ...
		dec	ds:LeftOnLine
		retn
DisplayNext	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTheRest	proc near		; ...
		push	es
		mov	es, ds:TPA
		mov	bp, bx
		test	byte ptr es:[bp+12], 10h ; [es:bp+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short drNonDir
		mov	dx, offset dmes_ptr
		call	std_printf
		jmp	short drCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

drNonDir:				; ...
		mov	dx, es:[bp+17]	; [es:bp+EntryStruc.filesize]
		mov	ds:File_Size_Low, dx
		mov	dx, es:[bp+19]	; [es:bp+EntryStruc.filesize+2]
		mov	ds:File_Size_High, dx
		mov	dx, offset disp_file_size_ptr
		call	std_printf

drCom:					; ...
		mov	ax, es:[bp+15]	; [es:bp+EntryStruc.filedate]
		or	ax, ax
		jz	short drDone
		mov	bx, ax
		and	ax, 1Fh
		mov	dl, al
		mov	ax, bx
		mov	cl, 5
		shr	ax, cl
		and	al, 0Fh
		mov	dh, al
		mov	cl, bh
		shr	cl, 1
		xor	ch, ch
		add	cx, 80
		cmp	cl, 100
		jb	short dr_1
		sub	cl, 100

dr_1:					; ...
		xchg	dh, dl
		mov	ds:DirDat_Yr, cx
		mov	ds:DirDat_Mo_Day, dx
		mov	cx, es:[bp+13]
		jcxz	short drPrint
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cl, 1
		shr	cl, 1
		xchg	ch, cl
		mov	ds:DirTim_Hr_Min, cx

drPrint:				; ...
		mov	dx, offset dirdattim_ptr
		call	std_printf

drDone:					; ...
		pop	es
		mov	bx, bp
		retn
DisplayTheRest	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTrailer	proc near		; ...
		test	ds:_Bits, 8	; mask.bare
		jnz	short dtrRet
		call	CRLF2
		call	UseLine
		mov	ax, ds:FileCnt

DisplayCntSiz:				; ...
		mov	ds:Dir_Num, ax
		mov	dx, offset dirmes_ptr
		call	std_printf
		mov	dx, offset bytes_ptr
		call	std_printf
		call	UseLine

dtrRet:					; ...
		retn
DisplayTrailer	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayWide	proc near		; ...
		push	ds
		mov	ds, ds:TPA
		test	byte ptr [bx+12], 10h ;	[bx+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short dw1
		mov	al, '['
		call	PRINT_CHAR

dw1:					; ...
		call	DisplayDotForm
		test	byte ptr [bx+12], 10h
		jz	short dw2
		mov	al, ']'
		call	PRINT_CHAR

dw2:					; ...
		mov	cx, 12		; size filename	+ size fileext + 1 ; (8+3+1)
		sub	cx, dx
		jcxz	short dwDone
		mov	al, 20h	; ' '

dw3:					; ...
		call	PRINT_CHAR
		loop	dw3

dwDone:					; ...
		pop	ds
		retn
DisplayWide	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


EndPage		proc near		; ...
		test	ds:_Bits, 2	; mask.pagd
		jz	short epNew
		push	bx
		push	cx
		call	PAUSE
		call	build_dir_string
		mov	dx, offset dircont_ptr
		call	Printf_Crlf
		pop	cx
		pop	bx

epNew:					; ...
		mov	ax, ds:LinPerPag
		dec	ax
		mov	ds:LeftOnPage, ax
		retn
EndPage		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetDriveLtr	proc near		; ...
		mov	al, ds:5Ch	; [FCB]
		or	al, al
		jnz	short gdl1
		mov	al, ds:CURDRV
		inc	al

gdl1:					; ...
		add	al, 40h		; 'A'-1
		mov	ah, ':'
		retn
GetDriveLtr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupParamError	proc near		; ...
		mov	ax, 9
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	ds:extend_buf_ptr, ax
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	ds:string_ptr_2, si
		mov	ds:extend_buf_sub, 1
		mov	dx, offset extend_buf_ptr
		retn
SetupParamError	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UseLine		proc near		; ...
		dec	ds:LeftOnPage
		cmp	ds:LeftOnPage, 2
		ja	short ulRet
		call	EndPage

ulRet:					; ...
		retn
UseLine		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ZeroTotals	proc near		; ...
		mov	di, offset FileCntTotal
		mov	cx, 8		; size FileCntTotal+size FileSizTotal
		xor	al, al
		rep stosb
		retn
ZeroTotals	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CtrlCHandler:				; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	ax
		push	dx
		call	RestUDir
		pop	dx
		pop	ax
		pop	ds
		assume ds:nothing
		jmp	cs:OldCtrlCHandler

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LowerCase	proc near		; ...
		cmp	al, 'A'
		jb	short lcRet
		cmp	al, 'Z'
		ja	short lcRet
		or	al, 20h

lcRet:					; ...
		retn
LowerCase	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LowercaseString	proc near		; ...
		push	di
		mov	di, si
		cld

NextChar:				; ...
		lodsb
		or	al, al
		jz	short EndOfString
		call	LowerCase
		stosb
		jmp	short NextChar
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EndOfString:				; ...
		pop	di
		retn
LowercaseString	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PAUSE		proc near		; ...
		mov	dx, offset PAUSEMES_PTR
		call	std_printf
		call	GETKEYSTROKE
		call	CRLF2
		retn
PAUSE		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ERASE:					; ...
		mov	si, 81h
		mov	ds:COMSW, 0
		mov	di, offset PARSE_ERASE
		xor	cx, cx

erase_scan:				; ...
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; -1 ; END_OF_LINE
		jz	short good_line
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short errj2
		cmp	ds:PARSE1_SYN, offset SLASH_P_SYN ; "/P"
		jz	short set_erase_prompt
		push	si
		lds	si, ds:PARSE1_ADDR
		cmp	byte ptr [si+1], ':' ; colon_char
		jnz	short erase_drive_ok
		cmp	byte ptr [si+2], 0 ; end_of_line_out
		jnz	short erase_drive_ok
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		jmp	short extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

erase_drive_ok:				; ...
		call	Move_To_SrcBuf
		pop	si
		jmp	short erase_scan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

set_erase_prompt:			; ...
		cmp	ds:COMSW, 0
		jz	short ok_to_set_erase_prompt
		mov	ax, 1		; MoreArgs_Ptr
		call	setup_parse_error_msg
		jmp	short errj2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ok_to_set_erase_prompt:			; ...
		inc	ds:COMSW
		jmp	short erase_scan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_line:				; ...
		call	PathCrunch
		jnb	short checkdr
		mov	ax, ds:Msg_Numb
		cmp	ax, 0
		jnz	short extend_setup
		cmp	ds:DestIsDir, 0
		jnz	short badpath_err

checkdr:				; ...
		cmp	ds:COMSW, 0
		jz	short notest2j
		jmp	slashp_erase
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notest2j:				; ...
		jmp	notest2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR BUILDPATH

badpath_err:				; ...
		mov	ax, 3		; ERROR_PATH_NOT_FOUND

extend_setup:				; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax

errj2:					; ...
		jmp	cerror
; END OF FUNCTION CHUNK	FOR BUILDPATH
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CRENAME:				; ...
		mov	si, 81h
		mov	di, offset PARSE_RENAME
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0		; result_no_error
		jnz	short crename_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0		; result_no_error
		jnz	short crename_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		mov	al, ':'
		cmp	[si+1],	al
		jnz	short ren_no_drive
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 0Ah ; BadParm_ptr
		pop	si

crename_parse_error:			; ...
		jmp	short errj
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ren_no_drive:				; ...
		mov	di, 6Ch		; FCB+10h
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		lodsb
		mov	ds:One_Char_Val, al
		pop	si
		mov	di, offset PARSE_RENAME
		call	parse_check_eol
		jnz	short crename_parse_error
		call	PathCrunch
		mov	dx, offset BADCPMES_PTR
		jz	short errj2
		jnb	short notest3
		mov	ax, ds:Msg_Numb
		cmp	ax, 0
		jnz	short extend_setup
		cmp	ds:DestIsDir, 0
		jz	short notest3
		jmp	badpath_err
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notest3:				; ...
		mov	al, ds:One_Char_Val
		mov	dx, offset INORNOT_PTR
		call	pathchrcmp
		jz	short errj
		mov	ah, 17h
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	RENAME FILE via	FCB
					; DS:DX	-> FCB
					; FCB contains new name	starting at byte 17h.
		cmp	al, 0FFh
		jnz	short renameok
		call	get_ext_error_number
		push	ax
		mov	al, 0FFh

renameok:				; ...
		push	ax
		call	RestUDir
		pop	ax
		inc	al
		jz	short rn1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rn1:					; ...
		pop	ax
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short use_renerr
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short use_renerr
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

use_renerr:				; ...
		mov	dx, offset RENERR_PTR

errj:					; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TYPEFIL:				; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short typefil_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		jz	short gottarg

typefil_parse_error:			; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gottarg:				; ...
		call	SETPATH
		test	ds:DestInfo, 2	; 00000010b
		jz	short nowilds
		mov	dx, offset INORNOT_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nowilds:				; ...
		mov	ax, 6C00h
		mov	bx, 0
		xor	cx, cx
		mov	dx, 101h
		mov	si, offset SrcBuf
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short typecont

typerr:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	Set_Ext_Error_Msg
		mov	string_ptr_2, offset SrcBuf
		mov	extend_buf_sub,	1 ; one_subst
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

typecont:				; ...
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jz	short not_device
		mov	TypeFilSiz+2, 0FFFFh ; -1
		jmp	short dotype
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_device:				; ...
		mov	ax, 4202h
		xor	dx, dx
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	TypeFilSiz, ax
		mov	TypeFilSiz+2, dx
		mov	ax, 4200h
		xor	dx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file

dotype:					; ...
		mov	zflag, 0
		mov	ds, TPA
		assume ds:nothing
		xor	dx, dx

typelp:					; ...
		cmp	cs:zflag, 0
		jz	short tf1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf1:					; ...
		mov	cx, cs:BYTCNT
		cmp	cs:TypeFilSiz+2, 0FFFFh	; -1
		jz	short typ_read
		cmp	cs:TypeFilSiz+2, 0
		jz	short lt64k
		sub	cs:TypeFilSiz, cx
		sbb	cs:TypeFilSiz+2, 0
		jmp	short typ_read
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lt64k:					; ...
		cmp	cx, cs:TypeFilSiz
		jbe	short gtbuf
		mov	cx, cs:TypeFilSiz
		jcxz	short typelp_ret
		mov	cs:TypeFilSiz, 0
		jmp	short typ_read
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gtbuf:					; ...
		sub	cs:TypeFilSiz, cx

typ_read:				; ...
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jnb	short tf2
		jmp	typerr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf2:					; ...
		mov	cx, ax
		jcxz	short typelp_ret
		push	ds
		pop	es
		xor	di, di
		push	ax
		mov	al, 1Ah
		repne scasb
		pop	ax
		xchg	ax, cx
		cmp	ax, 0
		jnz	short foundz
		cmp	byte ptr [di-1], 1Ah
		jnz	short typecont2

foundz:					; ...
		sub	cx, ax
		dec	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		not	es:zflag

typecont2:				; ...
		push	bx
		mov	bx, 1
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		jb	short Error_outputj
		cmp	ax, cx
		jnz	short tf3
		jmp	typelp
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf3:					; ...
		dec	cx
		cmp	ax, cx
		jnz	short Error_outputj

tf4:					; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Error_outputj:				; ...
		mov	bx, 1
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short tf4
		jmp	error_output
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

typelp_ret:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VOLUME:					; ...
		mov	si, 81h
		mov	di, offset PARSE_VOL
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; END_OF_LINE ;	-1
		jz	short OkVolArg
		cmp	ax, 0
		jnz	short badvolarg
		mov	di, offset PARSE_VOL
		xor	dx, dx
		call	parse_check_eol
		jz	short OkVolArg

badvolarg:				; ...
		jmp	cerror

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisAppend	proc near		; ...
		push	ds
		push	es
		push	di
		mov	ax, 0B700h
		int	2Fh		; - Multiplex -	APPEND - INSTALLATION CHECK
					; Return: AL = 00h not installed
					; AL = FFh if installed
		or	al, al
		jz	short daRet
		mov	ax, 0B702h
		int	2Fh		; - Multiplex -	APPEND - VERSION CHECK
					; Return: AX = FFFFh if	not DOS	4.0 APPEND
					; AL = major version number
					; AH = minor version number, otherwise
		cmp	ax, 0FFFFh
		jnz	short daRet
		mov	ax, 0B706h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - GET APPEND FUNCTION STATE
					; Return: BX = APPEND state
		mov	ds, ds:RESSEG
		mov	ds:Append_State, bx
		mov	ds:Append_Flag,	0FFh
		xor	bx, bx
		mov	ax, 0B707h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits

daRet:					; ...
		pop	di
		pop	es
		assume es:nothing
		pop	ds
		retn
DisAppend	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


OkVolArg	proc near		; ...
		call	DisAppend
		call	CRLF2
		mov	al, 20h	; ' '   ; blank
		call	PRINT_CHAR
		push	ds
		pop	es
		mov	di, 55h		; FCB-7
		mov	al, 0FFh	; -1
		stosb
		xor	ax, ax
		stosw
		stosw
		stosb
		mov	al, 8		; ATTR_VOLUME_ID
		stosb
		inc	di
		mov	cx, 11
		mov	al, '?'
		rep stosb
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	dx, 55h		; FCB-7
		mov	ah, 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		push	ax
		mov	al, ds:5Ch
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short drvok
		mov	al, ds:CURDRV
		add	al, 'A'

drvok:					; ...
		mov	ds:vol_drv, al
		pop	ax
		or	al, al
		jz	short Get_vol_name
		mov	dx, offset VolMes_Ptr_2
		jmp	short print_serial
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Get_vol_name:				; ...
		mov	di, offset CHARBUF
		mov	dx, di
		mov	si, offset DIRBUF_8 ; DIRBUF+8
		mov	cx, 11
		rep movsb
		xor	al, al
		stosb
		mov	dx, offset VolMes_Ptr

print_serial:				; ...
		push	dx
		mov	ax, 6900h
		mov	bl, ds:5Ch	; [FCB]
		mov	dx, offset vol_ioctl_buf
		int	21h		; DOS -	4.0 internal - GET/SET DISK SERIAL NUMBER
					; AL = 00h get serial number / 01h set serial number
					; BL = drive (0=default, 1=A, 2=B, etc)
					; DS:DX	-> disk	info
		pop	dx
		jb	short printvol_end
		call	std_printf
		mov	al, 20h	; ' '
		call	PRINT_CHAR
		mov	dx, offset VolSerMes_Ptr

printvol_end:				; ...
		jmp	std_printf
OkVolArg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Set_Ext_Error_Msg proc near		; ...
		call	get_ext_error_number
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		stc
		retn
Set_Ext_Error_Msg endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_ext_error_number proc near		; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	ds
		pop	es
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
get_ext_error_number endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VERSION:				; ...
		mov	si, 81h
		mov	di, offset PARSE_VER
		xor	cx, cx
		call	Parse_With_Msg
		mov	bl, 1
		cmp	ax, 0		; RESULT_NO_ERROR
		jz	short verPrintVer
		dec	bl
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short verPrintVer
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verPrintVer:				; ...
		push	bx
		call	CRLF2
		call	PRINT_VERSION
		call	CRLF2
		pop	bx
		or	bl, bl
		jz	short verDone
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		mov	al, dl
		mov	bh, dh
		cmp	al, 25		; 'Z'-'A'
		jbe	short ver1
		mov	al, -23		; '*'-'A'

ver1:					; ...
		add	al, 'A'         ; 41h
		mov	ds:One_Char_Val, al
		mov	dx, offset dosrev_ptr
		call	std_printf
		mov	cl, 4
		shr	bh, cl
		jb	short verRom
		shr	bh, 1
		jb	short verHma
		mov	dx, offset DosLow_Ptr
		jmp	short verPrintLoc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verRom:					; ...
		mov	dx, offset DosRom_Ptr
		jmp	short verPrintLoc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verHma:					; ...
		mov	dx, offset DosHma_Ptr

verPrintLoc:				; ...
		call	std_printf

verDone:				; ...
		jmp	CRLF2

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_VERSION	proc near		; ...
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		push	ax
		xor	ah, ah
		mov	ds:Major_Ver_Num, ax
		pop	ax
		xchg	ah, al
		xor	ah, ah
		mov	ds:Minor_Ver_Num, ax
		mov	dx, offset VerMes_Ptr
		jmp	std_printf
PRINT_VERSION	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_PROMPT	proc near		; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	es
		call	FIND_PROMPT
		jb	short PP0
		cmp	byte ptr es:[di], 0
		jnz	short PP1

PP0:					; ...
		call	PRINT_DRIVE
		mov	al, '>'         ; SYM
		call	PRINT_CHAR
		jmp	short PP5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP1:					; ...
		mov	al, es:[di]
		inc	di
		or	al, al
		jz	short PP5
		cmp	al, '$'         ; 24h
		jz	short PP2
		call	PRINT_CHAR
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP2:					; ...
		mov	al, es:[di]
		inc	di
		mov	bx, offset clsstring_2 ; PROMPT_TABLE-3	(db '[2J')
		or	al, al
		jz	short PP5

PP3:					; ...
		add	bx, 3
		call	UPCONV
		cmp	al, [bx]
		jz	short PP4
		cmp	byte ptr [bx], 0
		jnz	short PP3
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP4:					; ...
		push	es
		push	di
		push	cs
		pop	es
		assume es:TRANGROUP
		call	word ptr [bx+1]
		pop	di
		pop	es
		assume es:nothing
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP5:					; ...
		pop	es
		pop	ds
		assume ds:nothing
		retn
PRINT_PROMPT	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_BACK:				; ...
		mov	dx, offset dback_ptr
		jmp	std_printf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_EQ:				; ...
		mov	al, '='
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_ESC:				; ...
		mov	al, 1Bh		; ESC
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_G:				; ...
		mov	al, '>'         ; 3Eh
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_L:				; ...
		mov	al, '<'         ; 3Ch
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Print_B:				; ...
		mov	al, '|'         ; 7Ch

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_CHAR	proc near		; ...
		push	es
		push	ds
		pop	es
		push	di
		push	dx
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	dx
		pop	di
		pop	es
		retn
PRINT_CHAR	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_DRIVE	proc near		; ...
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'
		call	PRINT_CHAR
		retn
PRINT_DRIVE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


build_dir_for_prompt proc near		; ...
		xor	dl, dl
		mov	si, offset BWDBUF
		mov	di, si
		mov	al, ds:CURDRV
		add	al, 'A'
		mov	ah, ':'
		stosw
		mov	al, ds:DIRCHAR
		stosb
		xchg	si, di
		mov	ds:string_ptr_2, di
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		mov	dx, offset string_buf_ptr
		jnb	short doprint
		mov	dx, offset BADCURDRV

doprint:				; ...
		call	std_printf
		retn
build_dir_for_prompt endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


build_dir_for_chdir proc near		; ...
		call	build_dir_string
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
build_dir_for_chdir endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


build_dir_string proc near		; ...
		mov	dl, ds:5Ch	; [FCB]
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short gotdrive
		add	al, ds:CURDRV
		inc	al

gotdrive:				; ...
		push	ax
		mov	si, (offset BWDBUF+3)
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		jnb	short dpbisok
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dpbisok:				; ...
		mov	di, offset BWDBUF
		mov	dx, di
		pop	ax
		mov	ah, ':'
		stosw
		mov	al, DIRCHAR
		stosb
		retn
build_dir_string endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PATH:					; ...
		xor	al, al
		mov	di, offset SRCXNAME
		stosb
		dec	di
		call	PGETARG
		jz	short disppath
		cmp	al, ';'         ; 3Bh
		jnz	short pathslp
		inc	si
		jmp	short scan_white
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pathslp:				; ...
		lodsb
		cmp	al, 0Dh		; END_OF_LINE_IN
		jz	short path_eol
		call	testkanj
		jz	short notkanj2
		stosb
		lodsb

path_hold:				; ...
		stosb
		jmp	short pathslp
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj2:				; ...
		call	UPCONV
		cmp	al, ';'         ; 3Bh ; semicolon
		jz	short path_hold
		call	DELIM
		jnz	short path_hold

scan_white:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short path_eol
		cmp	al, 20h	; ' '
		jz	short scan_white
		cmp	al, 9
		jz	short scan_white
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	1 ; MoreArgs_Ptr
		mov	msg_disp_class,	2 ; parse_msg_class
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_eol:				; ...
		xor	al, al
		stosb
		call	find_path
		call	delete_path
		call	scan_double_null
		call	move_name
		mov	si, offset SRCXNAME

store_path:				; ...
		lodsb
		cmp	al, 0
		jz	short got_paths
		call	store_char
		jmp	short store_path
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_paths:				; ...
		xor	ax, ax
		stosw
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

disppath:				; ...
		call	find_path
		call	print_path
		call	CRLF2
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


print_path	proc near		; ...
		cmp	byte ptr es:[di], 0
		jnz	short path1

path0:					; ...
		mov	dx, offset NULLPATH_PTR
		push	cs
		pop	es
		assume es:TRANGROUP
		push	cs
		pop	ds
		jmp	std_printf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path1:					; ...
		push	es
		pop	ds
		sub	di, 5
		mov	si, di
		call	SCASB2
		cmp	cx, 0FFh	; 255
		jz	short path0
		push	cs
		pop	es
		mov	di, offset Arg_Buf
		mov	dx, 100h	; 256
		sub	dx, cx
		xchg	dx, cx
		rep movsb
		mov	dx, offset arg_buf_ptr
		push	cs
		pop	ds
		jmp	std_printf
print_path	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CLS:					; ...
		mov	ah, 1Ah
		mov	al, 0
		int	2Fh		; - Multiplex -	DOS 4+ ANSI.SYS	internal - INSTALLATION	CHECK
					; Return: AL = FFh if installed
		cmp	al, 0FFh	; ANSI_installed
		jz	short ansicls
		mov	ax, 440Ch
		mov	bx, 1
		mov	ch, 3
		mov	cl, 7Fh
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		jb	short no_variable
		mov	ax, LinPerPag
		mov	dh, al
		mov	ax, display_width
		mov	dl, al
		jmp	short regcls
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_variable:				; ...
		mov	bx, 1
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jz	short ansicls
		test	dl, 10h
		jnz	short cls_normal

ansicls:				; ...
		call	ansi_cls
		jmp	short cls_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cls_normal:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		cmp	al, 3
		jbe	short DoAlpha
		cmp	al, 7
		jz	short DoAlpha
		mov	ah, 0
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode
		jmp	short cls_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoAlpha:				; ...
		push	ds
		mov	ax, 40h		; ROMBIOS_DATA
		mov	ds, ax
		assume ds:nothing
		mov	dx, ds:4Ah	; [CRT_Cols]
		mov	dh, ds:84h	; [CRT_Rows]
		pop	ds
		assume ds:nothing
		or	dh, dh
		jnz	short regcls
		mov	dh, 25

regcls:					; ...
		inc	dh
		call	reg_cls

cls_ret:				; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


reg_cls		proc near		; ...
		dec	dh
		dec	dl
		push	dx
		mov	ah, 0Bh
		xor	bx, bx
		int	10h		; - VIDEO - SET	COLOR PALETTE
					; BH = 00h, BL = border	color
					; BH = 01h, BL = palette (0-3)
		pop	dx
		xor	ax, ax
		mov	cx, ax
		mov	ah, 6
		mov	bh, 7
		xor	bl, bl
		int	10h		; - VIDEO - SCROLL PAGE	UP
					; AL = number of lines to scroll window	(0 = blank whole window)
					; BH = attributes to be	used on	blanked	lines
					; CH,CL	= row,column of	upper left corner of window to scroll
					; DH,DL	= row,column of	lower right corner of window
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		mov	ah, 2
		xor	dx, dx
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		retn
reg_cls		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ansi_cls	proc near		; ...
		mov	si, offset CLSSTRING
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	ah, 6

clrloop:				; ...
		lodsb
		mov	dl, al
		int	21h		; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
					; DL = character <> FFh
					;  Return: ZF set = no character
					;   ZF clear = character recieved, AL =	character
		loop	clrloop
		retn
ansi_cls	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CTTY		proc near		; ...
		push	ds
		pop	es
		assume es:nothing
		mov	si, 81h
		mov	di, offset PARSE_CTTY
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short ctty_error
		cmp	ax, 0
		jnz	short ctty_error
		push	si
		lds	si, ds:PARSE1_ADDR
		mov	di, offset SrcBuf

ctty_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short ctty_move_filename
		pop	si
		mov	di, offset PARSE_CTTY
		call	parse_check_eol
		jz	short nocolon

ctty_error:				; ...
		jmp	short isbaddev
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nocolon:				; ...
		mov	dx, offset SrcBuf
		mov	ax, 3D02h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short isbaddev
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short devisok

closedev:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

isbaddev:				; ...
		mov	dx, offset BADDEV_PTR
		call	std_printf
		jmp	short resret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

devisok:				; ...
		push	dx
		mov	ax, ds:acrlf_ptr
		mov	dh, 0FFh	; -1
		push	bx
		call	TSYSGETMSG
		mov	dx, si
		mov	ax, 4000h
		mov	cx, 2
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		pop	dx
		jb	short closedev
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		push	bx
		mov	cx, 3
		xor	bx, bx

iclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	iclloop
		pop	bx
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

resret:					; ...
		mov	ds, ds:RESSEG
		push	ds
		mov	ax, ds:18h	; [PDB.JFN_TABLE]
		mov	ds:Io_Save, ax
		mov	ax, offset TrnLodCom1_Trap
		push	ax
		retf
CTTY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CHCP		proc near		; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHCP
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short getcp
		cmp	ax, 0
		jnz	short cp_error
		push	cx
		mov	bx, offset PARSE1_ADDR
		mov	cx, [bx]
		mov	ds:system_cpage, cx
		pop	cx
		mov	di, offset PARSE_CHCP
		call	parse_check_eol
		jnz	short cp_error
		mov	ah, 14h
		mov	al, 0
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh	; NLSFUNC_installed
		jz	short got_NLS
		mov	dx, offset NLSFUNC_PTR
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_NLS:				; ...
		mov	bx, ds:system_cpage
		mov	ah, 66h
		mov	al, 2
		int	21h		; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
					; BX = active code page
					; DX = system code page	(active	page at	boot time)
		jnb	short chcp_return
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jnz	short chcp_other_error
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 0Dh		; ERROR_INVALID_DATA
		jnz	short no_countrysys
		mov	dx, offset INV_CODE_PAGE
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_countrysys:				; ...
		mov	dx, offset NoCntry_Ptr
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chcp_other_error:			; ...
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 65
		jnz	short none_set
		mov	dx, offset cp_not_all_ptr
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

none_set:				; ...
		mov	dx, offset cp_not_set_ptr

cp_error:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getcp:					; ...
		mov	ah, 66h
		mov	al, 1
		int	21h		; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
		mov	ds:system_cpage, bx
		mov	dx, offset cp_active_ptr
		call	std_printf

chcp_return:				; ...
		retn
CHCP		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRUENAME:				; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		mov	di, offset SRCXNAME
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short tn_eol
		cmp	ax, 0
		jnz	short tn_parse_error
		cmp	ds:PARSE1_OUTPUT, 6 ; PARSE1_TYPE
		jz	short tn_drive
		jmp	short tn_filespec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_eol:					; ...
		mov	ah, 0
		mov	al, '.'
		stosw
		jmp	short tn_doit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_drive:				; ...
		push	si
		mov	si, offset PARSE1_ADDR
		lodsb
		add	al, 40h		; "A"-1
		stosb
		mov	ax, '.:'        ; 2E3Ah ; ah=".", al=":"
		stosw
		mov	al, 0		; END_OF_LINE_OUT
		stosb
		pop	si
		jmp	short tn_check_eol
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_filespec:				; ...
		push	si
		lds	si, ds:PARSE1_ADDR

tn_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short tn_move_filename
		pop	si

tn_check_eol:				; ...
		mov	di, offset PARSE_CHDIR
		call	parse_check_eol
		jz	short tn_doit

tn_parse_error:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_doit:				; ...
		mov	si, offset SRCXNAME
		mov	di, offset COMBUF
		mov	ah, 60h
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		jnb	short tn_print_xname
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	SRCXNAME
		mov	ds:extend_buf_sub, 1 ; one_subst
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_print_xname:				; ...
		mov	ds:string_ptr_2, offset	COMBUF
		mov	dx, offset string_buf_ptr
		call	CRLF2
		call	Printf_Crlf
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

_$EXIT:					; ...
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:PermCom, 0
		jz	short free_com
		cmp	ds:SingleCom, 0FFFFh ; -1
		jz	short no_reset
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

free_com:				; ...
		mov	ax, 122Eh
		mov	dl, 5
		mov	di, ds:Crit_Msg_Off
		mov	es, ds:Crit_Msg_Seg
		assume es:RESGROUP
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - set critical/SHARE	error table
					; ES:DI	-> error table

no_reset:				; ...
		pop	ds
		call	RestUDir1
		mov	es, ds:RESSEG
		assume es:nothing
		mov	ax, es:Parent
		mov	es:16h,	ax	; [es:PDB.PARENT_PID]
		mov	ax, es:OldTerm
		mov	es:0Ah,	ax	; [es:PDB.EXIT]
		mov	ax, es:OldTerm+2
		mov	es:0Ch,	ax	; [es:PDB.EXIT+2]
		push	es
		mov	es, ds:TRAN_TPA
		mov	ah, 49h		; DEALLOC
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	ah, 4Ch		; EXIT
		mov	al, byte ptr es:RetCode
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
; END OF FUNCTION CHUNK	FOR PROMPTBAT	; AL = exit code

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


parse_check_eol	proc near		; ...
		xor	dx, dx
		mov	ds:parse_last, si
		call	cmd_parse
		cmp	al, 0FFh	; END_OF_LINE
		jz	short parse_good_eol
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short ok_to_setup_pmsg
		inc	ax

ok_to_setup_pmsg:			; ...
		call	setup_parse_error_msg

parse_good_eol:				; ...
		retn
parse_check_eol	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Parse_With_Msg	proc near		; ...
		mov	ds:parse_last, si
		call	cmd_parse
		cmp	al, 0FFh
		jz	short parse_msg_good
		cmp	ax, 0
		jz	short parse_msg_good
		call	setup_parse_error_msg

parse_msg_good:				; ...
		retn
Parse_With_Msg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


setup_parse_error_msg proc near		; ...
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	byte ptr [si], 0 ; END_OF_LINE_OUT
		mov	ds:extend_buf_ptr, ax
		cmp	ax, 2
		jz	short setup_parse_msg_ret
		mov	si, ds:parse_last
		mov	ds:string_ptr_2, si
		mov	ds:extend_buf_sub, 1 ; one_subst

setup_parse_msg_ret:			; ...
		inc	si
		retn
setup_parse_error_msg endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_PROMPT:				; ...
		call	delete_prompt
		call	scan_double_null
		push	si
		call	GETARG
		pop	si
		jnz	short ADD_PROMPT3

ADD_PROMPT_RETN:			; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_PROMPT3:				; ...
		call	move_name
		call	GETARG
		push	si
		jmp	short ADD_NAME
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DISP_ENVJ:				; ...
		jmp	DISP_ENV
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_NAME_TO_ENVIRONMENT:		; ...
		call	GETARG
		jz	short DISP_ENVJ
		xor	bx, bx
		push	si

EQLP:					; ...
		lodsb
		cmp	al, 13		; 0Dh
		jz	short QUEQ
		cmp	al, '='
		jnz	short EQLP
		inc	bl
		cmp	byte ptr [si], 13 ; 0Dh
		jnz	short EQLP
		inc	bh
		jmp	short EQLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

QUEQ:					; ...
		pop	si
		dec	bl
		jz	short ONEQ
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ONEQ:					; ...
		push	bx
		call	delete_name_in_environment
		pop	bx
		dec	bh
		jz	short ADD_PROMPT_RETN
		call	scan_double_null
		mov	bx, di
		call	move_name
		push	si
		xchg	bx, di
		mov	ds:comspec_flag, 0
		mov	si, offset COMSPECSTR ;	"COMSPEC="
		mov	cx, 4
		repe cmpsw
		jnz	short NOT_COMSPEC
		inc	ds:comspec_flag

NOT_COMSPEC:				; ...
		mov	di, bx

ADD_NAME:				; ...
		pop	si
		push	si

ADD_NAME1:				; ...
		lodsb
		cmp	al, 0Dh		; 13
		jz	short ADD_NAME_RET
		call	store_char
		jmp	short ADD_NAME1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_NAME_RET:				; ...
		pop	si
		cmp	ds:comspec_flag, 0

ADD_NAME_JZ_RET:			; ...
		jz	short ADD_PROMPT_RETN
		call	scanoff
		mov	es, ds:RESSEG
		mov	di, offset ComSpec
		mov	bx, di
		xor	ax, ax
		mov	es:ComDrv, al
		push	ax
		mov	al, [si]
		call	testkanj
		pop	ax
		jnz	short _GOTDRIVE
		cmp	byte ptr [si+1], ':'
		jnz	short _GOTDRIVE
		mov	al, [si]
		call	UPCONV
		sub	al, 'A'
		add	di, 2
		inc	al
		mov	es:ComDrv, al
		add	al, 40h	; '@'   ; 'A'-1

_GOTDRIVE:				; ...
		mov	es:PutBackComSpec, di
		mov	es:PutBackDrv, al
		mov	di, bx

COPY_COMSPEC:				; ...
		lodsb
		call	DELIM
		jz	short COPYDONE
		cmp	al, 0Dh		; 13
		jz	short COPYDONE
		stosb
		jmp	short COPY_COMSPEC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPYDONE:				; ...
		xor	al, al
		stosb
		mov	ds:comspec_flag, 0
		dec	di
		mov	es:ComSpec_End,	di
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DISP_ENV:				; ...
		mov	ds, ds:RESSEG
		mov	ds, ds:EnvirSeg
		xor	si, si

PENVLP:					; ...
		cmp	byte ptr [si], 0
		jz	short ADD_NAME_JZ_RET
		mov	di, offset Arg_Buf

PENVLP2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short PENVLP2
		mov	dx, offset arg_buf_ptr
		push	ds
		push	es
		pop	ds
		call	Printf_Crlf
		pop	ds
		jmp	short PENVLP

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


delete_path	proc near		; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short delete_name_in_environment
delete_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


delete_prompt	proc near		; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="
delete_prompt	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


delete_name_in_environment proc	near	; ...
		push	si
		push	ds
		call	FIND
		jb	short del1
		mov	si, di
		call	SCASB2
		xchg	si, di
		cmp	byte ptr es:[si], 0
		jnz	short not_dnull
		dec	si

not_dnull:				; ...
		call	GETENVSIZ
		sub	cx, si
		push	es
		pop	ds
		rep movsb

del1:					; ...
		pop	ds
		pop	si

find_retn:				; ...
		retn
delete_name_in_environment endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


find_path	proc near		; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short find_name_in_environment
find_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FIND_PROMPT	proc near		; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="
FIND_PROMPT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


find_name_in_environment proc near	; ...
		call	FIND
		jb	short find_retn
		jmp	SCASB1
find_name_in_environment endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FIND		proc near		; ...
		cld
		call	COUNT0
		mov	es, ds:RESSEG
		mov	es, es:EnvirSeg
		xor	di, di

find1:					; ...
		push	cx
		push	si
		push	di

find11:					; ...
		lodsb
		call	testkanj
		jz	short notkanj3
		dec	si
		lodsw
		inc	di
		inc	di
		cmp	ax, es:[di-2]
		jnz	short find12
		dec	cx
		loop	find11
		jmp	short find12
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj3:				; ...
		call	UPCONV
		inc	di
		cmp	al, es:[di-1]
		jnz	short find12
		loop	find11

find12:					; ...
		pop	di
		pop	si
		pop	cx
		jz	short find_retn
		push	cx
		call	SCASB2
		pop	cx
		cmp	byte ptr es:[di], 0
		jnz	short find1
		stc
		retn
FIND		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


COUNT0		proc near		; ...
		push	ds
		pop	es
		mov	di, si
		push	di
		call	SCASB1
		jmp	short COUNTX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		push	di
		call	SCASB2

COUNTX:					; ...
		pop	cx
		sub	di, cx
		xchg	di, cx

move_name_retn:				; ...
		retn
COUNT0		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


move_name	proc near		; ...
		cmp	byte ptr [si], 13 ; 0Dh
		jz	short move_name_retn
		lodsb
		call	testkanj
		jz	short notkanj1
		call	store_char
		lodsb
		call	store_char
		jmp	short move_name
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj1:				; ...
		call	UPCONV
		call	store_char
		cmp	al, '='
		jnz	short move_name

getarg_retn:				; ...
		retn
move_name	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETARG		proc near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short getarg_retn
		call	scanoff
		cmp	al, 0Dh		; 13

sdn_retn:				; ...
		retn
GETARG		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scan_double_null proc near		; ...
		mov	es, ds:RESSEG
		mov	es, es:EnvirSeg
		xor	di, di

sdn1:					; ...
		cmp	byte ptr es:[di], 0
		jz	short sdn_retn
		call	SCASB2
		jmp	short sdn1
scan_double_null endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SCASB1		proc near		; ...
		mov	al, '='
		jmp	short SCASBX
SCASB1		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SCASB2		proc near		; ...
		xor	al, al		; null

SCASBX:					; ...
		mov	cx, 256
		repne scasb
		retn
SCASB2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


testkanj	proc near		; ...
		push	ds
		push	si
		push	ax
		mov	ds, cs:RESSEG
		lds	si, dword ptr ds:Dbcs_Vector_Addr

ktlop:					; ...
		cmp	word ptr [si], 0
		jz	short notlead
		pop	ax
		push	ax
		cmp	al, [si]
		jb	short notlead
		inc	si
		cmp	al, [si]
		jbe	short islead
		inc	si
		jmp	short ktlop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notlead:				; ...
		xor	ax, ax
		jmp	short ktret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

islead:					; ...
		xor	ax, ax
		inc	ax

ktret:					; ...
		pop	ax
		pop	si
		pop	ds
		retn
testkanj	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UPCONV		proc near		; ...
		cmp	al, 80h
		jb	short oth_fucase
		sub	al, 80h
		push	ds
		push	bx
		mov	ds, ds:RESSEG
		lds	bx, dword ptr ds:FUCase_Addr+1
		add	bx, 2
		xlat
		pop	bx
		pop	ds
		jmp	short upconv_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oth_fucase:				; ...
		cmp	al, 61h	; 'a'   ; small_a
		jb	short upconv_end
		cmp	al, 7Ah	; 'z'   ; small_z
		ja	short upconv_end
		sub	al, 20h

upconv_end:				; ...
		retn
UPCONV		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


store_char	proc near		; ...
		push	cx
		push	bx
		push	es
		push	ds
		mov	ds, ds:RESSEG
		mov	es, ds:EnvirSeg
		pop	ds
		call	GETENVSIZ
		mov	bx, cx
		sub	bx, 2
		cmp	di, bx
		jb	short store1
		push	ax
		push	cx
		push	bx
		call	FREE_TPA
		pop	bx
		add	bx, 2
		cmp	bx, 8000h
		jb	short envsiz_ok

bad_env_size:				; ...
		stc
		jmp	short envnoset
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

envsiz_ok:				; ...
		mov	cl, 4
		shr	bx, cl
		inc	bx
		mov	cx, es
		add	cx, bx
		add	cx, 20h	; ' '
		mov	ax, cs
		cmp	cx, ax
		jnb	short bad_env_size
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs

envnoset:				; ...
		pushf
		push	es
		mov	es, ds:RESSEG
		call	ALLOC_TPA
		pop	es
		popf
		pop	cx
		pop	ax
		jnb	short store1
		pop	es
		mov	dx, offset ENVERR_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

store1:					; ...
		stosb
		mov	word ptr es:[di], 0
		pop	es
		pop	bx
		pop	cx
		retn
store_char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETENVSIZ	proc near		; ...
		push	es
		push	ax
		mov	ax, es
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ax, es:3	; [es:ARENA.size]
		mov	cl, 4
		shl	ax, cl
		mov	cx, ax
		pop	ax
		pop	es
		assume es:nothing

getenvsiz_retn:				; ...
		retn
GETENVSIZ	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RestUDir1	proc near		; ...
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:RestDir, 0
		pop	ds
		jz	short getenvsiz_retn

RestUDir:				; ...
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xor	al, al
		call	SETREST
		retn
RestUDir1	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$CHDIR:				; ...
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short bwdj
		cmp	ax, 0
		jnz	short ChDirErr
		cmp	ds:PARSE1_OUTPUT, 6 ; [PARSE1_TYPE],result_drive
		jnz	short REALCD
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr

bwdj:					; ...
		call	build_dir_for_chdir
		call	CRLF2

chdir_retn:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REALCD:					; ...
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr
		call	SETPATH
		test	ds:DestInfo, 2
		jnz	short BadChDir
		mov	ah, 3Bh		; CHDIR
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short chdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short BadChDir
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short BadChDir
		call	set_ext_error_subst
		jmp	short ChDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BadChDir:				; ...
		mov	dx, offset badcd_ptr

ChDirErr:				; ...
		call	std_eprintf

mkdir_retn:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$MKDIR:				; ...
		call	SETRMMK
		jb	short MkDirErr
		mov	ah, 39h
		int	21h		; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
					; DS:DX	-> ASCIZ pathname (may include drive)
		jnb	short mkdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short MD_other_err
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badmderr
		call	set_ext_error_subst
		jmp	short MkDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badmderr:				; ...
		mov	dx, offset SRCXNAME
		mov	ah, 1Ah		; Set_DMA
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 4Eh		; Find_First
		mov	cx, 10h		; ATTR_DIRECTORY
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short MD_other_err
		mov	dl, ds:SRCXNAME+15h ; [SRCXNAME+FIND_BUF.ATTR] ; [SRCXNAME+21]
		test	dl, 10h
		jz	short MD_other_err
		mov	dx, offset MD_EXISTS_PTR
		jmp	short MkDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MD_other_err:				; ...
		mov	dx, offset badmkd_ptr

MkDirErr:				; ...
		call	std_eprintf

setrmmk_retn:				; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETRMMK		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short noargerr
		mov	di, offset SRCXNAME
		push	di
		push	si
		lds	si, ds:PARSE1_ADDR

mrdir_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0		; END_OF_LINE_OUT
		jnz	short mrdir_move_filename
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		pop	dx
		jz	short setrmmk_retn

noargerr:				; ...
		mov	dx, offset extend_buf_ptr
		xor	ax, ax
		stc

rmdir_retn:				; ...
		retn
SETRMMK		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_$RMDIR:				; ...
		call	SETRMMK
		jb	short RmDirErr
		jnz	short badrderr
		mov	ah, 3Ah		; RMDIR
		int	21h		; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
					; DS:DX	-> ASCIZ pathname (may include drive)
		jnb	short rmdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short badrderr
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badrderr
		call	set_ext_error_subst
		jmp	short RmDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badrderr:				; ...
		mov	dx, offset badrmd_ptr

RmDirErr:				; ...
		call	std_eprintf

savudir_err_retn:			; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


set_ext_error_subst proc near		; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	ds:string_ptr_2, dx
		mov	ds:extend_buf_sub, 1 ; one_subst
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		retn
set_ext_error_subst endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SAVUDIR		proc near		; ...
		mov	di, offset USERDIR1

SAVUDIR1:				; ...
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short GOTUDRV
		add	al, ds:CURDRV
		inc	al

GOTUDRV:				; ...
		stosb
		mov	ah, ds:DIRCHAR
		mov	al, ':'         ; 3Ah
		stosw
		push	es
		pop	ds
		mov	si, di
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		jb	short savudir_err_retn
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
SAVUDIR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CRLF2		proc near		; ...
		push	dx
		mov	dx, offset acrlf_ptr
		push	ds
		push	cs
		pop	ds
		call	std_printf
		pop	ds
		assume ds:nothing
		pop	dx
		retn
CRLF2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scanoff		proc near		; ...
		lodsb
		call	DELIM
		jz	short scanoff
		dec	si

scanoff_retn:				; ...
		retn
scanoff		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DELIM		proc near		; ...
		cmp	al, 20h	; ' '
		jz	short scanoff_retn
		cmp	al, '='
		jz	short scanoff_retn
		cmp	al, ','
		jz	short scanoff_retn
		cmp	al, ';'
		jz	short scanoff_retn
		cmp	al, 9
		jz	short scanoff_retn
		cmp	al, 0Ah
		retn
DELIM		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FCB_TO_ASCZ	proc near		; ...
		mov	cx, 8

MAINNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short SKIPSPC
		stosb

SKIPSPC:				; ...
		loop	MAINNAME
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		mov	ah, al
		mov	al, 2Eh	; '.'
		stosb
		xchg	al, ah
		stosb
		mov	cl, 2

EXTNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		stosb
		loop	EXTNAME

GOTNAME:				; ...
		xor	al, al
		stosb

STRCOMP_RETN:				; ...
		retn
FCB_TO_ASCZ	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRCOMP		proc near		; ...
		cmpsb
		jnz	short STRCOMP_RETN
		cmp	byte ptr [si-1], 0
		jz	short STRCOMP_RETN
		jmp	short STRCOMP
STRCOMP		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CRPRINT		proc near		; ...
		push	ax
		mov	al, 0Dh		; 13
		push	cx
		push	di
		mov	di, dx
		mov	cx, 65535	; 0FFFFh
		push	es
		push	ds
		pop	es
		repne scasb
		mov	byte ptr [di-1], 0
		pop	es
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	byte ptr [di-1], 0Dh ; 13
		jb	short error_output
		pop	di
		pop	cx
		pop	ax
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

error_output:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	es, RESSEG
		mov	dx, offset NOSPACE_PTR
		cmp	es:PipeFlag, 0
		jz	short go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR

go_to_error:				; ...
		jmp	cerror
CRPRINT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


pathchrcmp	proc near		; ...
		push	ax
		mov	ah, '/'         ; 2Fh
		cmp	SWITCHAR, ah
		jz	short noslasht
		cmp	al, '/'         ; 2Fh
		jz	short pccont

noslasht:				; ...
		cmp	al, '\'         ; 5Ch

pccont:					; ...
		pop	ax
		retn
pathchrcmp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PathCrunch	proc near		; ...
		mov	Msg_Numb, 0
		mov	dl, ds:5Ch	; [FCB]
		call	SAVUDIR
		jb	short pcrunch_cderrj
		call	SETPATH
		test	DestInfo, 2
		jnz	short trypeel
		mov	ah, 3Bh		; CHDIR
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short chdir_worked
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short trypeel
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short trypeel
		mov	Msg_Numb, ax
		jmp	peelfail
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chdir_worked:				; ...
		call	SetRest1
		mov	al, '?'
		mov	di, 5Dh
		mov	cx, 11
		rep stosb
		xor	al, al
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pcrunch_cderrj:				; ...
		jmp	pcrunch_cderr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

trypeel:				; ...
		mov	si, PathPos
		dec	si
		mov	al, [si-1]
		cmp	KPARSE,	0
		jnz	short delstrt
		call	pathchrcmp
		jz	short peelfail

delstrt:				; ...
		mov	cx, si
		mov	si, dx
		push	dx

delloop:				; ...
		cmp	si, cx
		jz	short gotdele
		lodsb
		call	testkanj
		jz	short notkanj8
		inc	si
		jmp	short delloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj8:				; ...
		call	pathchrcmp
		jnz	short delloop
		mov	dx, si
		dec	dx
		jmp	short delloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gotdele:				; ...
		mov	si, dx
		pop	dx
		cmp	si, dx
		jz	short badret
		mov	cx, si
		mov	si, dx

delloop2:				; ...
		cmp	si, cx
		jz	short trycd
		mov	KPARSE,	0
		lodsb
		call	testkanj
		jz	short delloop2
		inc	si
		inc	KPARSE
		jmp	short delloop2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

trycd:					; ...
		push	ax
		mov	al, 2Eh	; '.'
		cmp	[si+1],	al
		jnz	short trycd1
		cmp	[si+2],	al
		jz	short trycd1
		cmp	byte ptr [si+2], 0

trycd1:					; ...
		pop	ax
		jz	short peelfail
		mov	al, [si-1]
		cmp	al, 3Ah	; ':'
		jz	short badret
		cmp	KPARSE,	0
		jnz	short notdoublesl
		call	pathchrcmp
		jnz	short notdoublesl

peelfail:				; ...
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notdoublesl:				; ...
		mov	byte ptr [si], 0
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short cdsucc

pcrunch_cderr:				; ...
		call	get_ext_error_number
		mov	Msg_Numb, ax
		or	si, si
		stc

pcrunch_retn:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badret:					; ...
		mov	al, [si]
		call	pathchrcmp
		stc
		jnz	short pcrunch_retn
		xor	bl, bl
		xchg	bl, [si+1]
		mov	ah, 3Bh		; CHDIR
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short pcrunch_cderr
		mov	[si+1],	bl

cdsucc:					; ...
		call	SetRest1
		inc	si
		mov	DestTail, si
		pushf
		cmp	DirFlag, 0FFh	; -1
		jz	short pcrunch_end
		mov	di, 5Ch		; FCB
		mov	ax, 2902h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing

pcrunch_end:				; ...
		popf
		retn
PathCrunch	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR SWITCH

RETSW:					; ...
		xchg	ax, bx
		retn
; END OF FUNCTION CHUNK	FOR SWITCH

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SWITCH		proc near		; ...

; FUNCTION CHUNK AT 2869 SIZE 00000002 BYTES

		xor	bx, bx

SWLOOP:					; ...
		call	scanoff
		cmp	al, SWITCHAR
		jnz	short RETSW
		or	bx, 8000h
		inc	si
		call	scanoff
		cmp	al, 0Dh
		jz	short RETSW
		inc	si
		call	UPCONV
		mov	di, offset switch_list ; "?VBAPW"
		mov	cx, 6
		repne scasb
		jnz	short BADSW
		mov	ax, 1
		shl	ax, cl
		or	bx, ax
		jmp	short SWLOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADSW:					; ...
		jmp	short SWLOOP
SWITCH		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

DRVBAD:					; ...
		mov	dx, offset baddrv_ptr
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXTERNALJ:				; ...
		jmp	EXTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FNDCOM:					; ...
		or	al, al
		jz	short EXTERNALJ
		call	test_append
		jz	short CONTCOM

APPEND_INTERNAL:			; ...
		mov	cl, IDLEN
		mov	ch, 0
		mov	PathPos, cx
		inc	append_exec
		call	IOSET
		mov	si, offset IDLEN
		mov	dx, 0FFFFh	; -1
		mov	di, offset append_parse
		mov	ax, 0AE01h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- EXECUTE
					; DX = FFFFh, DS:SI -> buffer
					; Return: buffer at DS:SI filled with a	length byte followed by	the uppercase
					; internal command to execute (if length not 0)
		cmp	IDLEN, 0
		jnz	short CONTCOM
		jmp	CMD_DONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONTCOM:				; ...
		mov	di, offset COMTAB
		xor	cx, cx

FINDCOM:				; ...
		mov	si, offset ID
		mov	cl, [di]
		inc	di
		jcxz	short EXTERNALJ
		cmp	cl, IDLEN
		jnz	short ABCD
		mov	PathPos, cx
		repe cmpsb

ABCD:					; ...
		lahf
		add	di, cx
		mov	al, [di]
		mov	CHKDRV,	al
		inc	di
		mov	bx, [di]
		inc	di
		inc	di
		mov	dx, [di]
		inc	di
		inc	di
		sahf
		jnz	short FINDCOM
		cmp	append_exec, 0
		jnz	short DONT_SET_IO
		call	IOSET

DONT_SET_IO:				; ...
		mov	ax, COMSW
		or	ax, ARGTS
		and	ax, 20h
		jz	short DRIVE_CHECK
		test	CHKDRV,	4
		jz	short DO_HELP
		cmp	ARG_ARGVCNT, 2
		jnz	short DRIVE_CHECK

DO_HELP:				; ...
		mov	si, dx
		mov	ax, 0
		push	ax

NEXT_HELP_MSG:				; ...
		lodsw
		or	ax, ax
		jz	short HELP_DONE
		push	ax
		mov	dx, sp
		call	std_printf
		pop	ax
		jmp	short NEXT_HELP_MSG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HELP_DONE:				; ...
		pop	ax
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRIVE_CHECK:				; ...
		test	CHKDRV,	1
		jz	short NOCHECK
		mov	al, PARM1
		or	al, PARM2
		cmp	al, 0FFh
		jnz	short NOCHECK
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOCHECK:				; ...
		call	cmd_copy
		test	CHKDRV,	2
		jnz	short REALWORK
		call	noswit
		jnz	short REALWORK
		mov	msg_disp_class,	2
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	3
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REALWORK:				; ...
		call	bx

CMD_DONE:				; ...
		push	cs
		pop	ds
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		cmp	ds:Call_Flag, 1	; call_in_progress
		mov	ds:Call_Flag, 0
		pop	ds
		jz	short INCALL
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

INCALL:					; ...
		jmp	DOCOM1
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


noswit		proc near		; ...
		push	di
		mov	di, 81h
		mov	si, 80h
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	al, cs:SWITCHAR
		cmp	al, 0
		repne scasb
		pop	di
		retn
noswit		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

EXTERNAL:				; ...
		call	test_append
		jz	short NOT_BARRYF
		jmp	APPEND_INTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOT_BARRYF:				; ...
		mov	cs:IFNOTFLAG, 0	; [cs:FILTYP]
		mov	dl, cs:SPECDRV
		mov	cs:IDLEN, dl
		mov	cs:ROM_CALL, 0
		push	dx
		mov	dx, offset IDLEN
		call	ROM_SCAN
		pop	dx
		jnb	short DO_SCAN
		inc	cs:ROM_CALL
		jmp	short $+2

DO_SCAN:				; ...
		mov	di, offset EXECPATH
		mov	byte ptr [di], 0
		cmp	cs:ROM_CALL, 0
		jnz	short EXECUTE	; NEOEXECUTE

RESEARCH:
		call	path_search
		or	ax, ax
		jz	short badcomj45
		cmp	ax, 4
		jge	short EXECUTE
		jmp	BATCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badcomj45:				; ...
		jmp	short BADCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXECUTE:				; ...
		call	IOSET

LH_EXECUTE:				; ...
		mov	es, ds:TRAN_TPA
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	es, ds:RESSEG
		inc	es:ExtCom
		mov	es:RestDir, 0
		mov	si, offset EXECPATH
		mov	di, offset SafePathBuffer ; RESGROUP
		mov	cx, 80
		cld
		rep movsb
		mov	di, 5Ch		; FCB
		mov	si, di
		mov	cx, 82
		rep movsw
		mov	dx, offset SafePathBuffer
		push	es
		pop	ds
		mov	bx, offset EnvirSeg ; offset Exec_Block	= offset EnvirSeg
		mov	ax, 4B00h	; EXEC*256
		test	cs:ROM_CALL, 0FFh
		jz	short OK_EXEC
		jmp	ROM_EXEC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OK_EXEC:				; ...
		mov	cx, es
		mov	ss, cx
		mov	sp, offset RStack
		jmp	cs:EXEC_ADDR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADCOM:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADNAM_PTR

cerror:					; ...
		call	std_eprintf
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRESCAN		proc near		; ...
		xor	cx, cx
		mov	es, RESSEG
		mov	si, (offset COMBUF+2)
		mov	di, si

COUNTQUOTES:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short COUNTEND
		inc	ch
		jmp	short COUNTQUOTES
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COUNTEND:				; ...
		cmp	al, 0Dh		; 13
		jnz	short COUNTQUOTES
		push	cx
		mov	si, di

KanjiScan:				; ...
		lodsb
		call	testkanj
		jz	short KanjiQuote
		mov	ah, al
		lodsb
		cmp	ax, 2020h	; DB_SPACE
		jnz	short KanjiScan
		mov	word ptr [si-2], 2020h
		jmp	short KanjiScan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KanjiQuote:				; ...
		cmp	al, 22h	; '"'
		jnz	short KanjiEnd
		dec	ch
		jz	short KanjiScan

KanjiQuoteLoop:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short KanjiQuoteLoop
		dec	ch
		jmp	short KanjiScan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KanjiEnd:				; ...
		cmp	al, 0Dh
		jnz	short KanjiScan
		pop	cx
		mov	si, di

PRESCANLP:				; ...
		lodsb
		call	testkanj
		jz	short NOTKANJ6
		mov	[di], al
		inc	di
		lodsb
		mov	[di], al
		inc	di
		inc	cl
		inc	cl
		jmp	short PRESCANLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ6:				; ...
		cmp	al, 22h	; '"'
		jnz	short TRYGREATER
		dec	ch
		jz	short TRYGREATER

QLOOP:					; ...
		mov	[di], al
		inc	di
		inc	cl
		lodsb
		cmp	al, 22h	; '"'
		jnz	short QLOOP
		dec	ch

TRYGREATER:				; ...
		cmp	al, 3Eh	; '>'   ; rabracket
		jnz	short NOOUT
		cmp	[si], al
		jnz	short NOAPPND
		lodsb
		inc	es:Re_Out_App

NOAPPND:				; ...
		call	scanoff
		cmp	al, 3Ch	; '<'   ; labracket
		jz	short REOUT_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREOFIL

REOUT_ERRSET:				; ...
		mov	byte ptr [di], 0Dh
		mov	word ptr es:Re_OutStr, 9
		jmp	PRESCANEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTREOFIL:				; ...
		push	di
		mov	di, offset Re_OutStr
		mov	bx, di
		push	es

SETREOUTSTR:				; ...
		push	cx
		mov	cx, 77		; 64+13

SETREOUTSTR_LOOP:			; ...
		lodsb
		cmp	al, 0Dh
		jz	short GOTRESTR_J
		call	DELIM
		jz	short GOTRESTR_J
		cmp	al, SWITCHAR
		jz	short GOTRESTR_J
		cmp	al, 22h	; '"'   ; quote
		jz	short PIPEERRSYNJ5_J
		cmp	al, 3Ch	; '<'   ; labracket
		jz	short ABRACKET_TERM
		cmp	al, 3Eh	; '>'   ; rabracket
		jnz	short NO_ABRACKET

ABRACKET_TERM:				; ...
		dec	si
		mov	al, 20h	; ' '   ; BLANK

GOTRESTR_J:				; ...
		pop	cx
		jmp	short GOTRESTR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_ABRACKET:				; ...
		stosb
		loop	SETREOUTSTR_LOOP
		jmp	short GOTRESTR_J
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEERRSYNJ5_J:				; ...
		pop	cx
		jmp	short PIPEERRSYNJ5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOOUT:					; ...
		cmp	al, 3Ch	; '<'   ; labracket
		jnz	short CHKPIPE
		mov	bx, si
		call	scanoff
		cmp	al, 3Eh	; '>'   ; rabracket
		jz	short REIN_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREIFIL

REIN_ERRSET:				; ...
		mov	byte ptr [di], 0Dh
		mov	word ptr RE_INSTR, 9
		jmp	short PRESCANEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTREIFIL:				; ...
		push	di
		mov	di, offset RE_INSTR
		mov	bx, di
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	short SETREOUTSTR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHKPIPE:				; ...
		mov	ah, al
		cmp	ah, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE3
		cmp	ah, 7Ch	; '|'   ; vbar
		jnz	short CONTPRESCAN

ISPIPE3:				; ...
		cmp	es:PipeFlag, 0
		jnz	short NOECHOPUSH
		shl	es:EchoFlag, 1	; shl byte [es:EchoFlag],1

NOECHOPUSH:				; ...
		inc	es:PipeFlag
		call	scanoff
		cmp	al, 0Dh
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; vbar
		jnz	short CONTPRESCAN

PIPEERRSYNJ5:				; ...
		push	es
		pop	ds
		jmp	PIPEERRSYN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTRESTR:				; ...
		xchg	ah, al
		mov	al, 3Ah	; ':'
		sub	bx, di
		cmp	bx, 0FFFFh	; -1
		jz	short NOTRAILCOL
		cmp	es:[di-1], al
		jnz	short NOTRAILCOL
		dec	di

NOTRAILCOL:				; ...
		xor	al, al
		stosb
		pop	es
		assume es:nothing
		pop	di

CONTPRESCAN:				; ...
		mov	[di], ah
		inc	di
		cmp	ah, 0Dh
		jz	short PRESCANEND
		inc	cl
		jmp	PRESCANLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRESCANEND:				; ...
		cmp	es:PipeFlag, 0
		jz	short ISNOPIPE
		mov	di, 3C0h	; PipeStr ; RESGROUP:EndInit+160
		mov	es:3BEh, di	; [es:PIPEPTR],di
					; (RESGROUP:EndInit+158)
		mov	si, (offset COMBUF+2)
		call	scanoff

PIPESETLP:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jnz	short PIPESETLP

ISNOPIPE:				; ...
		mov	COMBUF+1, cl
		cmp	es:PipeFlag, 0
		push	cs
		pop	es
		assume es:TRANGROUP
		retn
PRESCAN		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cmd_copy	proc near		; ...
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, PathPos
		mov	di, 81h
		xor	cx, cx

cmdcopy:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jz	short copy_done
		inc	cx
		jmp	short cmdcopy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

copy_done:				; ...
		mov	ds:80h,	cl
		retn
cmd_copy	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


test_append	proc near		; ...
		mov	bx, offset COMBUF
		mov	si, offset IDLEN
		mov	dx, 0FFFFh	; -1
		mov	ax, 0AE00h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- INSTALL CHECK
					; DX = FFFFh, DS:BX -> command line
					; Return: AL = FFh if this command is a	TSR extension to COMMAND.COM
					; AL = 00h if the command should be executed as	usual
		cmp	al, 0
		retn
test_append	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETPATH		proc near		; ...
		mov	ax, PathCnt
		mov	si, PathPos

GETPATH:
		mov	DestInfo, 0
		mov	DestIsDir, 0
		mov	si, PathPos
		mov	cx, PathCnt
		mov	dx, si
		jcxz	short PATHDONE
		push	cx
		push	si
		call	SWITCH
		mov	PathSw,	ax
		pop	bx
		sub	bx, si
		pop	cx
		add	cx, bx
		mov	dx, si

SKIPPATH:				; ...
		mov	KPARSE,	0

SKIPPATH2:				; ...
		jcxz	short PATHDONE
		dec	cx
		lodsb
		call	testkanj
		jz	short TESTPPSEP
		dec	cx
		inc	si
		inc	KPARSE
		jmp	short SKIPPATH2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTPPSEP:				; ...
		call	pathchrcmp
		jnz	short TESTPMETA
		inc	DestIsDir

TESTPMETA:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short TESTPSTAR
		or	DestInfo, 2

TESTPSTAR:				; ...
		cmp	al, 2Ah	; '*'
		jnz	short TESTPDELIM
		or	DestInfo, 2

TESTPDELIM:				; ...
		call	DELIM
		jz	short PATHDONEDEC
		cmp	al, SWITCHAR
		jnz	short SKIPPATH

PATHDONEDEC:				; ...
		dec	si

PATHDONE:				; ...
		xor	al, al
		xchg	al, [si]
		inc	si
		cmp	al, 0Dh
		jnz	short NOPSTORE
		mov	[si], al

NOPSTORE:				; ...
		mov	PathPos, si
		mov	PathCnt, cx

SETPATH_RETN:				; ...
		retn
SETPATH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PGETARG		proc near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short SETPATH_RETN
		call	PSCANOFF
		cmp	al, 0Dh
		retn
PGETARG		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PSCANOFF	proc near		; ...
		lodsb
		call	DELIM
		jnz	short PSCANOFFD
		cmp	al, ';'         ; 3Bh
		jnz	short PSCANOFF

PSCANOFFD:				; ...
		dec	si
		retn
PSCANOFF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


IOSET		proc near		; ...
		push	ds
		push	dx
		push	ax
		push	bx
		push	cx
		mov	ds, cs:RESSEG
		assume ds:nothing
		cmp	ds:PipeFlag, 0
		jnz	short NOREDIR
		test	ds:IfFlag, 0FFh
		jnz	short NOREDIR
		call	TESTDOREIN
		call	TESTDOREOUT

NOREDIR:				; ...
		pop	cx
		pop	bx
		pop	ax
		pop	dx
		pop	ds

IOSET_RETN:				; ...
		retn
IOSET		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TESTDOREIN	proc near		; ...
		cmp	cs:RE_INSTR, 0
		jz	short IOSET_RETN
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset RE_INSTR
		mov	ax, 3D00h	; OPEN*256
		mov	bx, ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		pop	ds
		assume ds:nothing
		jb	short REDIRERR
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:18h,	al	; [PDB.JFN_TABLE]
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REDIRERR:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	TriageError
		cmp	ax, 65
		jz	short _CERRORJ
		cmp	bh, 3Dh		; OPEN
		jz	short OpenError
		mov	dx, offset FULLDIR_PTR

_CERRORJ:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OpenError:				; ...
		mov	cs:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	cs:extend_buf_ptr, ax
		jmp	cerror
TESTDOREIN	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TESTDOREOUT	proc near		; ...
		cmp	ds:Re_OutStr, 0
		jnz	short REOUTEXISTS
		jmp	NOREOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REOUTEXISTS:				; ...
		cmp	ds:Re_Out_App, 0
		jz	short REOUTCRT
		mov	dx, offset Re_OutStr
		mov	ax, 3D02h
		push	ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		pop	bx
		jb	short OpenWriteError
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short SET_REOUT
		mov	ax, 4202h
		mov	cx, 0FFFFh	; -1
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		push	cs
		pop	ds
		mov	ax, 3F00h
		mov	cx, 1
		mov	dx, offset One_Char_Val
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short OpenWriteError
		cmp	ax, cx
		jnz	short reout_0_length
		cmp	One_Char_Val, 1Ah
		mov	ds, RESSEG
		assume ds:nothing
		jnz	short SET_REOUT
		mov	ax, 4201h
		mov	cx, 0FFFFh	; -1
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		jmp	short SET_REOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

reout_0_length:				; ...
		mov	ds, cs:RESSEG
		mov	ax, 4200h
		xor	cx, cx
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jmp	short SET_REOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OpenWriteError:				; ...
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		stc
		jnz	short REOUTCRT
		jmp	REDIRERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REOUTCRT:				; ...
		mov	dx, offset Re_OutStr
		xor	cx, cx
		mov	ah, 3Ch
		push	ax
		int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
					; CX = attributes for file
					; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	bx
		jnb	short NOREDIRERR
		jmp	REDIRERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOREDIRERR:				; ...
		mov	bx, ax

SET_REOUT:				; ...
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:19h,	al	; [PDB.JFN_TABLE+1],al

NOREOUT:				; ...
		retn
TESTDOREOUT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


dstrlen		proc near		; ...
		push	ax
		xor	cx, cx
		cld

dloop:					; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short dloop
		sub	si, cx
		pop	ax

TRIAGEERR_RETN:				; ...
		retn
dstrlen		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TriageError	proc near		; ...
		jnb	short TRIAGEERR_RETN
		pushf
		push	bx
		push	cx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		push	ax
		push	dx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	cx
		pop	bx
		mov	dx, offset ACCDEN_PTR
		cmp	ax, 65
		jz	short NoMove
		mov	ax, bx
		mov	dx, cx

NoMove:					; ...
		pop	ds
		pop	es
		assume es:nothing
		pop	bp
		pop	di
		pop	si
		pop	cx
		pop	bx
		popf
		retn
TriageError	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Triage_Init:				; ...
		call	TriageError
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Move_To_SrcBuf	proc near		; ...
		push	si
		push	di
		push	cx
		mov	di, offset SrcBuf
		xor	cx, cx
		mov	ax, cx
		push	di
		lodsb

mts_get_chars:				; ...
		cmp	al, 0
		jz	short mts_end_string
		stosb
		inc	cx
		lodsb
		jmp	short mts_get_chars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mts_end_string:				; ...
		mov	al, 0Dh
		stosb
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	PathCnt, cx
		mov	PathPos, di
		pop	cx
		pop	di
		pop	si
		retn
Move_To_SrcBuf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SINGLETEST	proc near		; ...
		push	ds
		mov	ds, cs:RESSEG
		assume ds:nothing
		cmp	ds:SingleCom, 0
		jz	short TESTDONE
		cmp	ds:SingleCom, 0EFFFh

TESTDONE:				; ...
		pop	ds
		retn
SINGLETEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetRest1	proc near		; ...
		mov	al, 1
SetRest1	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETREST		proc near		; ...
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:RestDir, al
		pop	ds
		retn
SETREST		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PIPEDEL		proc near		; ...
		push	ds
		push	dx
		mov	ds, cs:RESSEG
		mov	dx, 320h	; offset Pipe1 = offset	RESGROUP:EndInit
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	dx, 36Fh	; offset Pipe2 = offset	RESGROUP:EndInit+79
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		pop	dx
		call	PipeOff
		mov	ds:PipeFiles, 0
		pop	ds
		retn
PIPEDEL		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR PROMPTBAT

PIPEERRSYN:				; ...
		mov	dx, offset SYNTMES_PTR
		call	PIPEDEL
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPERR:					; ...
		pushf
		call	TriageError
		push	ax
		push	dx
		mov	dx, offset PIPEEMES_PTR
		call	PIPEDEL
		push	cs
		pop	ds
		call	std_eprintf
		pop	dx
		pop	ax
		popf
		cmp	ax, 65
		jnz	short TCOMMANDJ
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TCOMMANDJ:				; ...
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEPROCSTRT:				; ...
		mov	ds, RESSEG
		assume ds:nothing
		inc	ds:PipeFiles
		push	es
		push	di
		push	ds
		push	si
		push	ds
		push	es
		pop	ds
		mov	si, offset TempVarName ; "TEMP="
		call	find_name_in_environment
		pop	ds
		jb	short no_temp_path
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		call	skip_white
		call	copy_pipe_path
		push	es
		pop	ds
		mov	dx, offset EndInit ; offset DATARES:Pipe1 = RESGROUP:EndInit
		mov	ax, 4300h
		int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
					; DS:DX	-> ASCIZ file name or directory
					; name without trailing	slash
		jb	short no_temp_path
		test	cx, 10h
		jnz	short no_temp_path
		stc

no_temp_path:				; ...
		pop	si
		pop	ds
		pop	di
		pop	es
		jnb	short crt_temp
		mov	ah, '.'
		mov	ds:320h, ah	; offset DATARES:Pipe1 = RESGROUP:EndInit
		mov	ds:36Fh, ah	; offset DATARES:Pipe2 = RESGROUP:EndInit+79
		xor	ah, ah
		mov	ds:321h, ah	; offset DATARES:Pipe1+1 = RESGROUP:EndInit+1
		mov	ds:370h, ah	; offset DATARES:Pipe2+1 = RESGROUP:EndInit+80

crt_temp:				; ...
		mov	dx, 320h	; offset DATARES:Pipe1 = offset	RESGROUP:EndInit
		xor	cx, cx
		mov	ah, 5Ah
		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
					; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
					; receive generated filename
					; CX = file attributes (only bits 0,1,2,5 may be set)
		jnb	short pps0
		jmp	short PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pps0:					; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	dx, 36Fh	; offset DATARES:Pipe2 = offset	RESGROUP:EndInit+79
		mov	ah, 5Ah
		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
					; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
					; receive generated filename
					; CX = file attributes (only bits 0,1,2,5 may be set)
		jnb	short pps1
		jmp	PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pps1:					; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		call	TESTDOREIN
		mov	si, ds:3BEh	; offset DATARES:PipePtr = offset RESGROUP:EndInit+158
		cmp	ds:SingleCom, 0FFFFh
		jnz	short NOSINGP
		mov	ds:SingleCom, 0F000h

NOSINGP:				; ...
		jmp	short FIRSTPIPE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEPROC:				; ...
		and	ds:EchoFlag, 0FEh
		mov	si, ds:3BEh	; offset DATARES:PipePtr = offset RESGROUP:EndInit+158
		lodsb
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE1
		cmp	al, 7Ch	; '|'   ; VBAR
		jz	short ISPIPE1
		jmp	PIPEEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISPIPE1:				; ...
		mov	dx, ds:InPipePtr
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read

PIPEERRJ:				; ...
		jnb	short NO_PIPEERR
		jmp	PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_PIPEERR:				; ...
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:18h,	al	; [PDB.JFN_TABLE],al  ;	Redirect

FIRSTPIPE:				; ...
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		cmp	byte ptr [si], 0Dh ; '|<CR>'
		jnz	short PIPEOK1

PIPEERRSYNJ:				; ...
		jmp	PIPEERRSYN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEOK1:				; ...
		mov	al, 7Ch	; '|'
		cmp	[si], al
		jz	short PIPEERRSYNJ
		cmp	byte ptr [si], 7Ch ; '|'
		jz	short PIPEERRSYNJ

PIPECOMLP:				; ...
		lodsb
		stosb
		call	testkanj
		jz	short NOTKANJ5
		movsb
		inc	cx
		inc	cx
		jmp	short PIPECOMLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ5:				; ...
		cmp	al, 0Dh
		jz	short LASTPIPE
		inc	cx
		cmp	al, 7Ch	; '|'
		jz	short ISPIPE2
		cmp	al, 7Ch	; '|'
		jnz	short PIPECOMLP

ISPIPE2:				; ...
		mov	byte ptr es:[di-1], 0Dh
		dec	cx
		mov	es:COMBUF+1, cl
		dec	si
		mov	ds:3BEh, si	; [PipePtr] = [EndInit+158]
		mov	dx, ds:OutPipePtr
		push	cx
		xor	cx, cx
		mov	ax, 3C00h
		int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
					; CX = attributes for file
					; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	cx
		jb	short PIPEERRJ
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:19h,	al	; [PDB.JFN_TABLE+1]
		xchg	dx, ds:InPipePtr
		mov	ds:OutPipePtr, dx
		jmp	short PIPECOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LASTPIPE:				; ...
		mov	es:COMBUF+1, cl
		dec	si
		mov	ds:3BEh, si	; [PipePtr] = [EndInit+158]
		call	TESTDOREOUT

PIPECOM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	NOPIPEPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEEND:				; ...
		call	PIPEDEL
		cmp	ds:SingleCom, 0F000h
		jnz	short NOSINGP2
		mov	ds:SingleCom, 0FFFFh ; -1

NOSINGP2:				; ...
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR PROMPTBAT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DATINIT		proc far		; ...
		mov	cs:RESSEG, ds
		push	es
		push	ds
		mov	ax, cs
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		call	TSYSLOADMSG
		mov	dx, offset STACK ; mov dx, offset INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		mov	word ptr TRANSTART+81h,	0Dh
		mov	COMBUF,	128
		mov	word ptr COMBUF+1, 0D01h
		call	DATE
		call	CTIME
		pop	ds
		assume ds:nothing
		pop	es
		assume es:nothing
		retf
DATINIT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DATE		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short PRMTDAT
		cmp	ax, 0
		jnz	short DATERR
		jmp	short COMDAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRMTDAT:				; ...
		call	GetDate
		xchg	dh, dl
		mov	ds:CurDat_yr, cx
		mov	ds:CurDat_mo_day, dx
		mov	dx, offset CurDat_Ptr
		call	std_printf

GET_NEW_DATE:				; ...
		call	GETDAT
		cmp	ax, 0FFFFh	; END_OF_LINE (-1)
		jz	short date_end
		cmp	ax, 0
		jnz	short DATERR

COMDAT:					; ...
		mov	cx, ds:DATE_YEAR
		mov	dh, ds:DATE_MONTH
		mov	dl, ds:DATE_DAY
		push	cx
		push	dx
		mov	cx, 1
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh	; END_OF_LINE (-1)
		pop	dx
		pop	cx
		jnz	short DATERR
		mov	ah, 2Bh
		int	21h		; DOS -	SET CURRENT DATE
					; DL = day, DH = month,	CX = year
					; Return: AL = 00h if no error /= FFh if bad value sent	to routine
		or	al, al
		jnz	short DATERR

date_end:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DATERR:					; ...
		call	CRLF2
		mov	dx, offset BADDAT_PTR
		call	std_printf
		jmp	short GET_NEW_DATE
DATE		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CTIME		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short PRMTTIM
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short TIMERR
		jmp	short COMTIM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRMTTIM:				; ...
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		xchg	ch, cl
		xchg	dh, dl
		mov	ds:CurTim_hr_min, cx
		mov	ds:CurTim_Sec_hn, dx
		mov	dx, offset CurTim_Ptr
		call	std_printf

GET_NEW_TIME:				; ...
		call	GETTIM
		cmp	ax, 0FFFFh	; -1 ; END_OF_LINE
		jz	short time_end
		cmp	ax, 0		; 0 ; RESULT_NO_ERROR
		jnz	short TIMERR

COMTIM:					; ...
		mov	ch, ds:TIME_HOUR
		mov	cl, ds:TIME_MINUTES
		mov	dh, ds:TIME_SECONDS
		mov	dl, ds:TIME_FRACTION
		push	cx
		push	dx
		mov	cx, 1
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh	; -1 ; END_OF_LINE
		pop	dx
		pop	cx
		jnz	short TIMERR
		mov	ah, 2Dh
		int	21h		; DOS -	SET CURRENT TIME
					; CH = hours, CL = minutes, DH = seconds, DL = hundredths of seconds
					; Return: AL = 00h if no error / = FFh if bad value sent to routine
		or	al, al
		jnz	short TIMERR

time_end:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TIMERR:					; ...
		call	CRLF2
		mov	dx, offset BadTim_Ptr
		call	std_printf
		jmp	short GET_NEW_TIME
CTIME		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetInitFlag	proc near		; ...
		mov	ds, ds:RESSEG
		and	ds:InitFlag, 0FDh ; ~INITSPECIAL ; NOT INITSPECIAL
		or	ds:InitFlag, cl
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
SetInitFlag	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PipeOff		proc near		; ...
		push	ds
		push	ax
		mov	ds, cs:RESSEG
		assume ds:nothing
		xor	al, al
		xchg	al, ds:PipeFlag
		or	al, al
		jz	short PipeOffDone
		shr	ds:EchoFlag, 1

PipeOffDone:				; ...
		pop	ax
		pop	ds
		retn
PipeOff		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_TIME:				; ...
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		xchg	ch, cl
		xchg	dh, dl
		mov	cs:PromTim_hr_min, cx
		mov	cs:PromTim_Sec_hn, dx
		mov	dx, offset promtim_ptr
		call	std_printf
		pop	es
		assume es:nothing
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETDAT		proc near		; ...
		mov	ax, 3800h
		mov	dx, 5Ch
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		mov	si, dx
		lodsw
		mov	dx, cs:usadat_Ptr
		dec	ax
		js	short printformat
		mov	dx, cs:eurdat_ptr
		jz	short printformat
		mov	dx, cs:japdat_ptr

printformat:				; ...
		mov	ax, dx
		mov	dh, 0FFh	; util_msg_class
		call	TSYSGETMSG
		mov	cs:NewDat_Format, si
		mov	dx, offset NewDat_Ptr
		call	std_printf
		mov	cs:NewDat_Format, 0
		mov	ah, 0Ah		; STD_CON_STRING_INPUT
		mov	dx, offset COMBUF
		mov	cx, 2		; INITSPECIAL
		call	SetInitFlag
		int	21h		; DOS -
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
GETDAT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETTIM		proc near		; ...
		xor	cx, cx
		mov	dx, offset NewTim_Ptr
		call	std_printf
		mov	ah, 0Ah		; STD_CON_STRING_INPUT
		mov	dx, offset COMBUF
		mov	cx, 2		; INITSPECIAL
		call	SetInitFlag
		int	21h		; DOS -
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
GETTIM		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


skip_white	proc near		; ...
		cld

skw_lp:					; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short skw_lp
		cmp	al, 9
		jz	short skw_lp
		dec	si
		retn
skip_white	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


copy_pipe_path	proc near		; ...
		mov	cx, 0FFFFh	; 65535
		xor	al, al
		mov	di, si
		push	es
		push	ds
		pop	es
		cld
		push	di
		repne scasb
		pop	di
		pop	es
		not	cx
		mov	di, 320h	; offset DATARES:Pipe1
					; (offset RESGROUP:EndINit)
		push	di
		push	cx
		rep movsb
		pop	cx
		pop	di
		push	ds
		push	es
		pop	ds
		mov	si, di
		mov	di, 36Fh	; offset DATARES:Pipe2
					; (offset RESGROUP:EndINit+79)
		rep movsb
		pop	ds
		retn
copy_pipe_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PARSELINE	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	ds:cpyflag, 0
		mov	ds:LASTARG, 0FFFFh
		xor	ax, ax
		mov	cx, 1348	; ARG_UNIT.SIZE
		mov	di, offset ARG_ARGV ; offset ARG
		rep stosb
		mov	ds:ARGBUF_PTR, offset ARG_ARGBUF ; ARG+ARG_UNIT.argbuf
		mov	ds:ARG_ARGSWINFO, 0 ; [ARG+ARG_UNIT.argswinfo]
		mov	ds:ARG_ARGVCNT,	0 ; [ARG+ARG_UNIT.argvcnt]
		mov	si, (offset COMBUF+2)
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:ForFlag, 0
		pop	ds
		jnz	short PCONT
		mov	di, offset ARG_ARGFORCOMBUF ; ARG+ARG_UNIT.argforcombuf
		xor	ch, ch
		mov	cl, ds:COMBUF+1
		inc	cl
		rep movsb
		mov	si, offset ARG_ARGFORCOMBUF

PCONT:					; ...
		mov	di, offset TPBUF
		mov	bl, 20h	; ' '

PARSELOOP:				; ...
		mov	ds:COMPTR, si
		xor	bp, bp
		mov	ds:expand_star,	0
		call	scanoff
		call	cparse
		jnb	short MORE_PRSE
		or	bp, bp
		jz	short PARSEDONE
		call	newarg
		jmp	short PARSEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MORE_PRSE:				; ...
		mov	ds:cpyflag, 2
		call	newarg
		jnb	short PARSELOOP
		jmp	short PARSE_ERROR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PARSEDONE:				; ...
		popf
		clc
		jmp	short PARSE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PARSE_ERROR:				; ...
		popf
		stc

PARSE_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
PARSELINE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


newarg		proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	arg_switch
		cmp	ds:ARG_ARGVCNT,	64 ; [ARG+ARG_UNIT.argvcnt],ARGMAX
		jge	short to_many_args
		mov	dh, bh
		mov	bx, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		inc	ds:ARG_ARGVCNT
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv
		call	argv_calc
		mov	word ptr [bx+7], 0 ; [bx+ARGV_ELE.argsw_word]
		mov	[bx+5],	cx	; [bx+ARGV_ELE.arglen]
		mov	[bx+2],	dh	; [bx+ARGV_ELE.argflags]
		mov	si, ds:ARGBUF_PTR
		mov	[bx], si	; [bx+ARGV_ELE.argpointer]
		add	si, ds:STARTEL
		sub	si, di
		mov	[bx+3],	si	; [bx+ARGV_ELE.argstartel]
		mov	si, ds:COMPTR
		mov	[bx+9],	si	; [bx+ARGV_ELE.arg_ocomptr]
		mov	si, di
		mov	di, ds:ARGBUF_PTR
		add	di, cx
		cmp	di, (offset ARG_ARGBUF+0FFh) ; ARG+ARG_UNIT.argbuf+ARGBLEN-1
		jge	short buf_oflow
		sub	di, cx
		cld
		rep movsb
		mov	al, 0		; ANULL
		stosb
		mov	ds:ARGBUF_PTR, di

newarg_done:
		popf
		clc
		jmp	short newarg_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

to_many_args:				; ...
		mov	ax, 1
		jmp	short newarg_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

buf_oflow:				; ...
		mov	ax, 2

newarg_error:				; ...
		popf
		stc

newarg_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
newarg		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


arg_switch	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	di
		pushf
		test	bh, 1
		jz	short arg_no_switch0
		cmp	ds:LASTARG, 0FFFFh ; -1
		jz	short arg_no_switch1
		mov	bx, ds:LASTARG
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv	; ARG+0
		call	argv_calc
		or	[bx+7],	bp	; [bx+ARGV_ELE.argsw_word]
		or	ds:ARG_ARGSWINFO, bp ; [ARG+ARG_UNIT.argswinfo]

arg_yes_switch:
		popf
		stc
		jmp	short arg_switch_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

arg_no_switch0:				; ...
		mov	ax, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		mov	ds:LASTARG, ax

arg_no_switch1:				; ...
		popf
		clc

arg_switch_exit:			; ...
		pop	di
		pop	cx
		pop	bx
		pop	ax
		retn
arg_switch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


argv_calc	proc near		; ...
		push	ax
		mov	al, bl
		mov	bl, 11		; ARGV_ELE.SIZE
		mul	bl
		pop	bx
		add	ax, bx
		xchg	ax, bx
		retn
argv_calc	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


path_search	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		pushf
		test	ds:ARGV0_ARG_FLAGS, 3 ;	[ARG+ARGV_ELE.argflags],wildcard+sw_flag
		jz	short path_search_ok

path_failure_jmp:			; ...
		jmp	path_failure
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_search_ok:				; ...
		call	STORE_PCHAR
		mov	dx, offset FBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		push	es
		call	find_path
		mov	ds:pathinfo, es	; [pathinfo+0]
		mov	ds:pathinfo+2, di
		mov	ds:pathinfo+4, di
		pop	es
		mov	bx, 128		; PBUFLEN
		mov	si, offset EXECPATH
		call	STRIP
		jb	short path_failure_jmp
		mov	dx, si
		mov	ds:search_error, offset	baddrv_ptr
		call	PSEARCH
		or	ax, ax
		jz	short path_noinit
		mov	bp, ax
		mov	di, offset EXECPATH
		mov	si, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		mov	cx, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		sub	cx, si
		mov	ah, ':'
		cmp	cx, 2
		jb	short adddrive
		cmp	[si+1],	ah
		jz	short movedrive

adddrive:				; ...
		mov	al, ds:CURDRV
		add	al, 'A'
		stosw
		jmp	short checkpath
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

movedrive:				; ...
		lodsw
		stosw
		sub	cx, 2

checkpath:				; ...
		or	al, 20h
		mov	dl, al
		sub	dl, 60h		; 'a'-1
		mov	al, ds:psep_char
		stosb
		cmp	cx, 1
		jb	short addpath
		lodsb
		dec	cx
		cmp	al, ds:psep_char
		jz	short movepath
		inc	cx
		dec	si

addpath:				; ...
		push	si
		mov	si, di
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		mov	di, si
		pop	si
		mov	al, ds:psep_char
		cmp	byte ptr [di], 0
		jz	short movepath

scanend:				; ...
		cmp	byte ptr [di], 0
		jz	short foundend
		inc	di
		jmp	short scanend
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

foundend:				; ...
		stosb

movepath:				; ...
		cmp	[si], al
		jnz	short copypath
		inc	si
		dec	cx

copypath:				; ...
		jcxz	short _copydone
		rep movsb

_copydone:				; ...
		jmp	path_success
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_noinit:				; ...
		test	ds:ARGV0_ARG_FLAGS, 4 ;	[ARG+ARGV_ELE.argflags],path_sep
		jnz	short path_failure
		mov	bh, ';'
		mov	dx, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		sub	dx, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		add	dx, offset EXECPATH

path_loop:				; ...
		call	path_crunch
		mov	bp, ax
		lahf
		or	bp, bp
		jnz	short path_found
		sahf
		jnb	short path_loop

path_failure:				; ...
		xor	ax, ax
		jmp	path_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_found:				; ...
		mov	di, offset EXECPATH
		mov	cx, ds:pathinfo+4
		mov	si, ds:pathinfo+2
		push	es
		push	ds:pathinfo	; [pathinfo+0]
		pop	es
		cmp	byte ptr es:[si+2], '.' ; 2Eh
		jnz	short path_cpy
		cmp	byte ptr es:[si+1], ':' ; 3Ah
		jnz	short path_cpy
		push	cx
		mov	al, es:[si]
		mov	[di], al
		mov	al, es:[si+1]
		mov	[di+1],	al
		mov	al, ds:psep_char
		mov	[di+2],	al
		push	si
		mov	dl, es:[si]
		or	dl, 20h
		sub	dl, 60h		; 'a'-1
		mov	si, di
		add	si, 3
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		call	dstrlen
		add	si, cx
		dec	si
		mov	di, si
		pop	si
		add	si, 3
		pop	cx

path_cpy:				; ...
		pop	es
		sub	cx, si
		push	ds
		push	ds:pathinfo	; [pathinfo+0]
		pop	ds
		cld

kloop:					; ...
		lodsb
		stosb
		call	testkanj
		jz	short notkanj1
		dec	cx
		jcxz	short popdone
		movsb
		dec	cx
		cmp	cx, 1
		ja	short kloop

popdone:				; ...
		pop	ds
		mov	al, ds:psep_char
		jmp	short path_store
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj1:				; ...
		loop	kloop
		pop	ds
		dec	di
		mov	al, ds:psep_char
		cmp	al, [di-1]
		jz	short path_success

path_store:				; ...
		stosb

path_success:				; ...
		mov	si, offset search_best_buf
		xor	cx, cx

path_succ_loop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short path_succ_loop
		mov	ax, bp

path_exit:				; ...
		popf
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
path_search	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STORE_PCHAR	proc near		; ...
		push	ax
		mov	al, 2Fh	; '/'
		call	pathchrcmp
		jz	short STORE_SLASH
		mov	al, 5Ch	; '\'
		mov	ds:psep_char, al
		pop	ax
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

STORE_SLASH:				; ...
		mov	ds:psep_char, al
		pop	ax
		retn
STORE_PCHAR	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


path_crunch	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	STORE_PCHAR
		mov	di, offset TPBUF
		mov	si, ds:pathinfo+4
		mov	ds:pathinfo+2, si
		push	ds
		push	ds:pathinfo	;  [pathinfo+0]
		pop	ds
		xor	cl, cl

path_cr_copy:				; ...
		lodsb
		or	al, al
		jz	short path_seg
		cmp	al, bh
		jz	short path_seg
		call	testkanj
		jz	short _notkanj2
		stosb
		movsb
		mov	cl, 1
		jmp	short path_cr_copy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_notkanj2:				; ...
		xor	cl, cl
		stosb
		jmp	short path_cr_copy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_seg:				; ...
		pop	ds
		mov	ds:pathinfo+4, si
		mov	bl, al
		xor	ax, ax
		cmp	di, offset TPBUF
		jz	short path_cr_leave

path_cr_look:
		mov	al, ds:psep_char
		or	cl, cl
		jnz	short path_cr_store
		cmp	al, [di-1]
		jz	short path_cr_l1

path_cr_store:				; ...
		stosb

path_cr_l1:				; ...
		mov	si, dx

path_cr_l2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short path_cr_l2
		mov	dx, offset TPBUF
		mov	ds:search_error, offset	BADPMES_PTR
		call	PSEARCH

path_cr_leave:				; ...
		or	bl, bl
		jz	short path_cr_empty
		popf
		clc
		jmp	short path_cr_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_cr_empty:				; ...
		popf
		stc

path_cr_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
path_crunch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PSEARCH		proc near		; ...
		push	cx
		push	dx
		push	di
		push	si
		pushf
		push	dx
		mov	di, dx
		mov	si, offset search_curdir_buf
		xor	dx, dx
		cmp	byte ptr [di+1], 3Ah ; ':'
		jnz	short SEARCH_DIR_CHECK
		mov	dl, [di]
		and	dl, 0DFh	; ~20h	; uppercase
		sub	dl, 40h	; '@'   ; convert to drive number

SEARCH_DIR_CHECK:			; ...
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		pop	dx
		jb	short SEARCH_INVALID_DRIVE
		mov	cx, 13h		; search_attr
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short SEARCH_NO_FILE
		mov	ds:search_best,	0 ; SEARCH_FILE_NOT_FOUND ; 0
		mov	ds:search_best_buf, 0 ;	ANULL ;	0

SEARCH_LOOP:				; ...
		call	SEARCH_FTYPE
		cmp	al, ds:search_best
		jle	short SEARCH_NEXT
		mov	ds:search_best,	al
		mov	si, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME
		mov	di, offset search_best_buf
		mov	cx, 13		; FNAME_MAX_LEN
		cld
		rep movsb
		cmp	al, 8		; SEARCH_COM
		jz	short SEARCH_DONE

SEARCH_NEXT:				; ...
		mov	cx, 13h		; SEARCH_ATTR
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jnb	short SEARCH_LOOP

SEARCH_DONE:				; ...
		mov	al, ds:search_best
		cmp	ds:ext_entered,	1
		jz	short SEARCH_EXIT
		mov	al, ds:ext_entered
		mov	ds:search_best,	al
		jmp	short SEARCH_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SEARCH_INVALID_DRIVE:			; ...
		mov	dx, ds:search_error
		call	std_printf

SEARCH_NO_FILE:				; ...
		mov	ax, 0		; SEARCH_FILE_NOT_FOUND

SEARCH_EXIT:				; ...
		popf
		pop	si
		pop	di
		pop	dx
		pop	cx
		retn
PSEARCH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCH_FTYPE	proc near		; ...
		push	di
		push	si
		mov	ax, 0
		mov	di, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME
		mov	cx, 13		; FNAME_MAX_LEN
		cld
		repne scasb
		jnz	short FTYPE_EXIT
		sub	di, 5
		mov	si, offset comext ; ".COM"
		mov	ax, di
		cmpsw
		jnz	short FTYPE_EXE
		cmpsw
		jnz	short FTYPE_EXE
		mov	ax, 8		; SEARCH_COM
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_EXE:				; ...
		mov	di, ax
		mov	si, offset exeext ; ".EXE"
		cmpsw
		jnz	short FTYPE_BAT
		cmpsw
		jnz	short FTYPE_BAT
		mov	ax, 4		; SEARCH_EXE
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_BAT:				; ...
		mov	di, ax
		mov	si, offset batext ; ".BAT"
		cmpsw
		jnz	short FTYPE_FAIL
		cmpsw
		jnz	short FTYPE_FAIL
		mov	ax, 2		; SEARCH_BAT
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_FAIL:				; ...
		mov	ax, 0

FTYPE_EXIT:				; ...
		cmp	ds:ext_entered,	1
		jz	short FTYPE_DONE
		cmp	ax, 0		; ANULL
		jz	short FTYPE_DONE
		mov	ds:ext_entered,	al
		mov	ax, 8		; SEARCH_COM

FTYPE_DONE:				; ...
		pop	si
		pop	di
		retn
SEARCH_FTYPE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRIP		proc near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	ds:ext_entered,	1
		mov	dx, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		mov	di, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		cmp	byte ptr [di], 0
		jz	short STRIP_ERROR
		mov	cx, dx
		add	cx, ds:ARGV0_ARGLEN ; [ARG+ARGV_ELE.arglen]
		sub	cx, di
		inc	cx
		mov	al, 2Eh	; '.'
		cld
		repne scasb
		jcxz	short PROCESS_EXT
		mov	ds:ext_entered,	0
		mov	al, 0
		repne scasb

PROCESS_EXT:				; ...
		mov	cx, di
		sub	cx, dx
		sub	bx, 4
		cmp	cx, bx
		jg	short STRIP_ERROR
		mov	di, si
		mov	si, dx
		cld
		rep movsb
		cmp	ds:ext_entered,	1
		jnz	short SKIP_WILDS
		dec	di
		stosb
		mov	al, 3Fh	; '?'
		stosb
		stosb
		stosb
		mov	al, 0
		stosb

SKIP_WILDS:				; ...
		popf
		clc
		jmp	short STRIP_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

STRIP_ERROR:				; ...
		popf
		stc

STRIP_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
STRIP		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SAVE_ARGS	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		pushf
		add	bx, 1363	; ARG_UNIT.SIZE+15
		mov	cl, 4
		shr	bx, cl
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short SAVE_ERROR
		mov	bp, ax
		push	es
		mov	es, ax
		assume es:nothing
		mov	cx, 1348	; ARG_UNIT.SIZE
		xor	di, di
		mov	si, offset ARG_ARGV ; offset ARG
		rep movsb
		mov	cx, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		xor	ax, ax
		mov	si, offset ARG_ARGV ; offset ARG

SAVE_PTR_LOOP:				; ...
		dec	cx
		jl	short SAVE_DONE
		mov	bx, cx
		call	argv_calc
		mov	dx, ds:ARG_ARGV[bx] ; [ARG+ARGV_ELE.argpointer+bx]
		sub	dx, si
		mov	es:[bx], dx
		mov	dx, ds:ARGV0_ARGSTARTEL[bx] ; [ARG+ARGV_ELE.argstartel+bx]
		sub	dx, si
		mov	es:[bx+3], dx	; [es:bx+ARGV_ELE.argstartel]
		mov	dx, ds:ARGV0_OCOMPTR[bx] ; [ARG+ARGV_ELE.arg_ocomptr+bx]
		sub	dx, si
		mov	es:[bx+9], dx	; [es:bx+ARGV_ELE.arg_ocomptr]
		jmp	short SAVE_PTR_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_DONE:				; ...
		pop	es
		assume es:nothing
		mov	ax, bp
		jmp	short SAVE_OK
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_ERROR:				; ...
		popf
		stc
		jmp	short SAVE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_OK:				; ...
		popf
		clc

SAVE_EXIT:				; ...
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
SAVE_ARGS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


notest2		proc near		; ...
		mov	cx, 11
		mov	si, 5Dh		; FCB+1

ambspec:				; ...
		lodsb
		cmp	al, '?'
		jnz	short allfil
		loop	ambspec

allfil:					; ...
		cmp	cx, 0
		jnz	short noprmpt

askagn:					; ...
		mov	dx, offset SureMes_Ptr
		call	std_printf
		mov	si, 80h
		mov	dx, si
		mov	word ptr [si], 120
		mov	ax, 0C0Ah
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		lodsw
		or	ah, ah
		jz	short askagn
		call	scanoff
		call	char_in_xlat
		jnb	short check_yn

answ_no:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

check_yn:				; ...
		cmp	al, 0		; NO character
		jz	short answ_no
		cmp	al, 1		; YES character
		pushf
		call	CRLF2
		popf
		jnz	short askagn

noprmpt:				; ...
		mov	ah, 13h
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jz	short eraerr
		call	RestUDir
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

eraerr:					; ...
		call	Set_Ext_Error_Msg
		push	dx
		call	RestUDir
		pop	dx
		cmp	ds:extend_buf_ptr, 18 ;	ERROR_NO_MORE_FILES
		jnz	short cerrorj2
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND

cerrorj2:				; ...
		jmp	cerror
notest2		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slashp_erase:				; ...
		call	build_dir_string
		mov	ah, 1Ah
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 11h
		mov	dx, 5Ch
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		inc	al
		jz	short eraerr

delete_prompt_loop:			; ...
		mov	si, (offset DESTDIR+1)
		mov	di, offset DEST
		mov	al, ds:DIRCHAR
		stosb
		call	FCB_TO_ASCZ

slashp_askagn:				; ...
		call	CRLF2
		mov	dx, offset BWDBUF
		mov	bx, dx
		cmp	byte ptr [bx+3], 0 ; END_OF_LINE_OUT
		jnz	short not_del_root
		mov	byte ptr [bx+2], 0

not_del_root:				; ...
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset DEST
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset Del_Y_N_Ptr
		call	std_printf
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	char_in_xlat
		jnb	short slashp_check_yn
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slashp_check_yn:			; ...
		cmp	al, 0		; NO character
		jz	short next_del_file
		cmp	al, 1		; YES character
		jz	short delete_this_file
		jmp	short slashp_askagn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

delete_this_file:			; ...
		mov	ah, 13h
		mov	dx, offset DESTDIR
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jnz	short next_del_file
		call	get_ext_error_number
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short stop_del
		call	CRLF2
		call	Set_Ext_Error_Msg
		call	std_eprintf
		jmp	short next_del_file
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

stop_del:				; ...
		jmp	eraerr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

next_del_file:				; ...
		mov	ah, 1Ah
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 12h
		mov	dx, 5Ch
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		inc	al
		jz	short slash_p_exit
		jmp	delete_prompt_loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slash_p_exit:				; ...
		call	get_ext_error_number
		cmp	ax, 12h		; ERROR_NO_MORE_FILES
		jz	short good_erase_exit
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_erase_exit:			; ...
		call	RestUDir
		call	CRLF2
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ECHO:					; ...
		call	ON_OFF
		jb	short DOEMES
		mov	ds, ds:RESSEG
		jnz	short ECH_OFF
		or	ds:EchoFlag, 1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ECH_OFF:				; ...
		and	ds:EchoFlag, 0FEh
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CERRORJ:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOEMES:					; ...
		cmp	cl, 0
		jz	short PECHO
		mov	dx, 82h
		call	CRPRINT
		jmp	CRLF2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PECHO:					; ...
		mov	ds, ds:RESSEG
		mov	bl, ds:EchoFlag
		push	cs
		pop	ds
		assume ds:TRANGROUP
		and	bl, 1
		mov	dx, offset EchoMes_Ptr
		jmp	short PYN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CNTRLC:					; ...
		call	ON_OFF
		mov	ax, 3301h	; (SET_CTRL_C_TRAPPING<<8)|1
		jb	short PCNTRLC
		jnz	short CNTRLC_OFF
		mov	dl, 1
		int	21h		; DOS -	EXTENDED CONTROL-BREAK CHECKING
					; AL = 00h get state / 01h set state / 02h set AND get
					; DL = 00h for OFF or 01h for ON
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CNTRLC_OFF:				; ...
		xor	dl, dl
		int	21h		; DOS -
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PCNTRLC:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		xor	al, al
		int	21h		; DOS -
		mov	bl, dl
		mov	dx, offset CtrlcMes_Ptr

PYN:					; ...
		mov	si, offset ONMES_PTR
		or	bl, bl
		jnz	short PRINTVAL
		mov	si, offset OFFMES_PTR

PRINTVAL:				; ...
		push	dx
		mov	bx, dx
		lodsw
		mov	dh, 0FFh	; util_msg_class ; -1
		call	TSYSGETMSG
		add	bx, 5		; Ptr_off_pos
		mov	[bx], si
		pop	dx
		call	std_printf
		mov	word ptr [bx], 0
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VERIFY:					; ...
		call	ON_OFF
		mov	ax, 2E01h	; (SET_VERIFY_ON_WRITE<<8)|1
		jb	short PVERIFY
		jnz	short VER_OFF
		int	21h		; DOS -
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VER_OFF:				; ...
		dec	al
		int	21h		; DOS -
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PVERIFY:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		mov	ah, 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		mov	bl, al
		mov	dx, offset VeriMes_Ptr
		jmp	short PYN

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ON_OFF		proc near		; ...
		mov	si, 81h

scan_on_off:				; ...
		lodsb
		cmp	al, 20h	; ' '   ; blank
		jz	short scan_on_off
		cmp	al, 9		; tab_chr
		jz	short scan_on_off
		cmp	al, 3Dh	; '='   ; equal_chr
		jz	short parse_on_off
		dec	si

parse_on_off:				; ...
		mov	di, offset PARSE_BREAK
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE ;	-1
		jz	short BADONF
		cmp	ax, 0
		jz	short on_off_there
		mov	cx, ax
		jmp	short BADONF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

on_off_there:				; ...
		cmp	PARSE1_CODE, 0FFh ; -1
		jnz	short good_on_off
		mov	cx, 0Ah		; BadParm_Ptr
		jmp	short BADONF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_on_off:				; ...
		xor	ax, ax
		or	al, PARSE1_CODE
		pushf
		mov	di, offset PARSE_BREAK
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jnz	short BADONF_flag
		popf
		clc
		jmp	short on_off_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADONF_flag:				; ...
		mov	cx, ax
		popf

BADONF:					; ...
		mov	dx, offset bad_on_off_ptr
		stc

on_off_end:				; ...
		retn
ON_OFF		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_DATE:				; ...
		push	es
		push	di
		push	cs
		pop	es
		assume es:TRANGROUP
		call	GetDate
		xchg	dh, dl
		mov	promptDat_yr, cx
		mov	promptDat_moday, dx
		mov	dx, offset promptdat_ptr
		call	std_printf
		pop	di
		pop	es
		assume es:nothing
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetDate		proc near		; ...
		mov	di, offset Arg_Buf
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		cbw
		push	cx
		push	dx
		mov	si, ax
		shl	si, 1
		add	si, ax
		mov	cx, si
		mov	ax, WeekTab
		mov	dh, 0FFh
		push	di
		call	TSYSGETMSG
		pop	di
		add	si, cx
		mov	cx, 3
		rep movsb
		mov	al, 0
		stosb
		pop	dx
		pop	cx
		retn
GetDate		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


char_in_xlat	proc near		; ...
		mov	dl, al
		xor	dh, dh
		mov	ax, 6523h	; (GetExtCntry<<8)+35
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		retn
char_in_xlat	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPY:					; ...
		xor	ax, ax
		mov	Copy_num, ax
		mov	SRCPT, ax
		mov	SrcTail, ax
		mov	CFLAG, al
		mov	NXTADD,	ax
		mov	ARG2S, ax	; [DestSwitch]
		mov	STARTEL, ax
		mov	DestTail, ax
		mov	SPECDRV, al	; [DestClosed]
		mov	DestSiz, al
		mov	SrcSiz,	al
		mov	DestInfo, al
		mov	SrcInfo, al
		mov	INEXACT, al
		mov	DestIsDir, al	; [DestVars]
		mov	SrcIsDir, al	; [SrcVars]
		mov	USERDIR1, al
		mov	NOWRITE, al
		mov	IFNOTFLAG, al	; [RDEOF]
		mov	SRCHAND, ax
		mov	CPDATE,	ax
		mov	CPTIME,	ax
		mov	SRCISDEV, al
		mov	OCtrlZ,	al
		mov	OFilePtr_Lo, ax
		mov	OFilePtr_Hi, ax
		mov	TERMREAD, al
		mov	comma, al
		mov	plus_comma, al
		mov	msg_flag, al
		mov	ARGTS, ax	; [AllSwitch]
		mov	PARM2, al	; [ArgC]
		mov	PLUS, al
		mov	BINARY,	al
		mov	ASCII, al
		mov	FileCnt, ax
		mov	WRITTEN, ax
		mov	PARM1, al	; [Concat]
		mov	MELCOPY, al
		mov	MELSTART, ax
		mov	word ptr ScanBuf, ax
		mov	word ptr DestBuf, ax
		mov	word ptr SrcBuf, ax
		mov	word ptr SDIRBUF, ax
		mov	BWDBUF,	ax	; [DIRBUF]
		mov	word ptr DESTDIR, ax ; [DestFcb]
		mov	objcnt,	al
		dec	ax
		mov	EndDestBuf, ax	; [DESTHAND]
		mov	FRSTSRCH, al
		mov	FIRSTDEST, al
		mov	DestIsDir, al
		mov	si, 81h
		mov	bl, '+'
		inc	expand_star
		mov	cpyflag, 1

DESTSCAN:				; ...
		xor	bp, bp
		mov	di, offset ScanBuf
		mov	parse_last, si
		call	cparse
		pushf
		inc	objcnt
		test	bh, 80h
		jz	short NOCOPY
		mov	PLUS, 1

NOCOPY:					; ...
		test	bh, 1
		jz	short TESTP2
		test	bp, 10h		; SwitchV
		jz	short NOT_SLASHV
		test	ARGTS, 10h	; test word [AllSwitch],SwitchV
		jz	short NOT_SLASHV
		or	bp, 4000h	; FBadSwitch

NOT_SLASHV:				; ...
		or	ARG2S, bp	; [DestSwitch]
		or	ARGTS, bp	; [AllSwitch]
		test	bp, 7FE3h	; ~SwitchCopy ;	not SwitchCopy
		jz	short NOT_BAD_SWITCH
		popf
		mov	ax, 3		; BadSwt_Ptr
		call	setup_parse_error_msg
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOT_BAD_SWITCH:				; ...
		popf
		jb	short CHECKDONE
		jmp	short DESTSCAN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTP2:					; ...
		popf
		jb	short CHECKDONE
		test	bh, 80h
		jnz	short GOTPLUS
		inc	PARM2		; inc byte [ArgC]

GOTPLUS:				; ...
		push	si
		mov	ax, STARTEL
		mov	si, offset ScanBuf
		sub	ax, si
		mov	di, offset DestBuf
		add	ax, di
		mov	DestTail, ax
		mov	DestSiz, cl
		inc	cx
		rep movsb
		mov	DestInfo, bh
		mov	ARG2S, 0	; [DestSwitch]
		pop	si
		jmp	short DESTSCAN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKDONE:				; ...
		cmp	PLUS, 1
		jnz	short CDCONT
		cmp	PARM2, 1	; [ArgC]
		jnz	short CDCONT
		cmp	objcnt,	2
		jnz	short CDCONT
		mov	dx, offset OVERWR_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CDCONT:					; ...
		mov	al, PLUS
		mov	PARM1, al	; [Concat]
		shl	al, 1
		shl	al, 1
		mov	INEXACT, al
		mov	al, PARM2	; [ArgC]
		or	al, al
		jnz	short TRY_TOO_MANY
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	2 ; LessArgs_Ptr
		jmp	short CERROR_PARSEJ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRY_TOO_MANY:				; ...
		cmp	al, 2
		jbe	short ACOUNTOK
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	1 ; MoreArgs_Ptr

CERROR_PARSEJ:				; ...
		mov	msg_disp_class,	2 ; parse_msg_class

CERROR4J:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ACOUNTOK:				; ...
		mov	bp, offset DestIsDir ; offset DestVars
		cmp	al, 1
		jnz	short GOT2ARGS
		mov	al, CURDRV
		add	al, 'A'
		mov	ah, ':'
		mov	byte ptr [bp+1], 2 ; [bp+VARSTRUC.SIZ]
		mov	di, offset DestBuf
		stosw
		mov	ARG2S, 0	; [DestSwitch]
		mov	byte ptr [bp+4], 2 ; [bp+VARSTRUC.INFO]
		mov	byte ptr [bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		call	SETSTARS

GOT2ARGS:				; ...
		cmp	byte ptr [bp+1], 2
		jnz	short NOTSHORTDEST
		mov	al, ':'         ; 3Ah
		cmp	DestBuf+1, al
		jnz	short NOTSHORTDEST
		or	byte ptr [bp+4], 2
		mov	di, (offset DestBuf+2)
		mov	byte ptr [bp+0], 0
		call	SETSTARS

NOTSHORTDEST:				; ...
		mov	di, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	byte ptr [di], 0
		jnz	short CHKSWTCHES
		mov	dx, offset badcd_ptr
		mov	al, ':'
		cmp	[di-2],	al
		jnz	short CERROR4J
		mov	byte ptr [bp+0], 2
		or	byte ptr [bp+4], 6
		call	SETSTARS

CHKSWTCHES:				; ...
		mov	ax, ARGTS
		test	ax, 10h		; SwitchV
		jz	short NOVERIF
		mov	ah, 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		xor	ah, ah
		mov	ds:VerVal, ax
		pop	ds
		mov	ax, 2E01h
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOVERIF:				; ...
		xor	bp, bp
		mov	si, 81h
		mov	bl, '+'         ; plus_chr ; 2Bh

SCANFSRC:				; ...
		mov	di, offset ScanBuf
		call	cparse
		test	bh, 1
		jnz	short SCANFSRC
		or	ds:ARG2S, bp	; [DestSwitch]
		test	bp, 8
		jnz	short NOSETCASC
		cmp	ds:PARM1, 0	; [Concat]
		jz	short NOSETCASC
		mov	ds:ASCII, 4

NOSETCASC:				; ...
		call	SOURCE_SET
		call	FRSTSRC
		jmp	FIRSTENT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR FlshFil

ENDCOPY:				; ...
		call	CLOSEDEST

ENDCOPY2:				; ...
		mov	dx, offset copied_ptr
		mov	si, ds:FileCnt
		mov	ds:Copy_num, si
		call	std_printf
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR FlshFil
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SRCNONEXIST:				; ...
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short NEXTSRC
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND
		mov	ds:string_ptr_2, offset	SrcBuf
		mov	ds:extend_buf_sub, 1 ; one_subst
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SOURCEPROC:				; ...
		call	SOURCE_SET
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short LEAVECFLAG

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FRSTSRC		proc near		; ...
		xor	ax, ax
		mov	ds:CFLAG, al
		mov	ds:NXTADD, ax
		mov	ds:SPECDRV, al	; [DestClosed]

LEAVECFLAG:				; ...
		mov	ds:SRCPT, si
		mov	di, offset USERDIR1
		mov	bp, offset SrcIsDir ; offset SrcVars
		call	BUILDPATH
		mov	si, ds:SrcTail
		retn
FRSTSRC		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTSRC:				; ...
		cmp	ds:PLUS, 0
		jnz	short MORECP

ENDCOPYJ2:				; ...
		jmp	short ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MORECP:					; ...
		xor	bp, bp
		mov	si, ds:SRCPT
		mov	bl, '+'

SCANSRC:				; ...
		mov	di, offset ScanBuf
		call	cparse
		jb	short ENDCOPYJ2
		test	bh, 80h
		jz	short ENDCOPYJ2
		test	bh, 1
		jnz	short SCANSRC
		call	SOURCEPROC
		cmp	ds:comma, 1
		jnz	short NOSTAMP
		mov	ds:plus_comma, 1
		jmp	short SRCNONEXIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOSTAMP:				; ...
		mov	ds:plus_comma, 0

FIRSTENT:				; ...
		mov	di, 5Ch		; FCB
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte ptr [si], 0
		jnz	short SRCHDONE
		mov	ax, word ptr ds:SrcBuf
		cmp	ah, ':'
		jz	short DRVSPEC1
		mov	al, 40h		; @

DRVSPEC1:				; ...
		or	al, 20h
		sub	al, 60h
		mov	ds:5Ch,	al
		mov	ah, 11h		; DIR_SEARCH_FIRST
		call	SEARCH

SRCHDONE:				; ...
		pushf
		call	RestUDir1
		popf
		jz	short NEXTAMBIG0
		jmp	SRCNONEXIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTAMBIG0:				; ...
		xor	al, al
		xchg	al, ds:FRSTSRCH
		or	al, al
		jz	short NEXTAMBIG

SETNMEL:				; ...
		mov	cx, 12
		mov	di, offset SDIRBUF
		mov	si, offset BWDBUF ; offset DIRBUF
		rep movsb

NEXTAMBIG:				; ...
		xor	al, al
		mov	ds:NOWRITE, al
		mov	di, ds:SrcTail
		mov	si, (offset BWDBUF+1) ;	offset DIRBUF+1
		call	FCB_TO_ASCZ

MELDO:					; ...
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short SHOWCPNAM
		test	ds:SrcInfo, 2
		jz	short DOREAD

SHOWCPNAM:				; ...
		mov	dx, offset file_name_ptr
		call	std_printf
		call	CRLF2

DOREAD:					; ...
		call	DOCOPY
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short NODCLOSE
		call	CLOSEDEST
		jb	short NODCLOSE
		mov	ds:CFLAG, 0

NODCLOSE:				; ...
		cmp	ds:PARM1, 0	; [Concat]
		jz	short NOFLUSH
		call	FlshFil
		test	ds:MELCOPY, 0FFh
		jz	short NOFLUSH
		jmp	short DOMELCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOFLUSH:				; ...
		call	SEARCHNEXT
		jnz	short NEXTSRCJ
		mov	ds:SPECDRV, 0	; [DestClosed]
		jmp	short NEXTAMBIG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOMELCOPY:				; ...
		cmp	ds:MELCOPY, 0FFh
		jz	short CONTMEL
		mov	si, ds:SRCPT
		mov	ds:MELSTART, si
		mov	ds:MELCOPY, 0FFh

CONTMEL:				; ...
		xor	bp, bp
		mov	si, ds:SRCPT
		mov	bl, '+'         ; 2Bh

SCANSRC2:				; ...
		mov	di, offset ScanBuf
		call	cparse
		test	bh, 80h
		jz	short NEXTMEL
		test	bh, 1
		jnz	short SCANSRC2
		call	SOURCEPROC
		call	RestUDir1
		mov	di, offset IDLEN ; offset DESTFCB2
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, (offset SDIRBUF+1)
		mov	si, offset ID	; offset DESTFCB2+1
		mov	di, ds:SrcTail
		call	BUILDNAME
		cmp	ds:PARM1, 0	; [Concat]
		jz	short MELDOJ
		mov	ds:NOWRITE, 0

MELDOJ:					; ...
		jmp	MELDO
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTSRCJ:				; ...
		jmp	NEXTSRC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTMEL:				; ...
		call	CLOSEDEST
		xor	ax, ax
		mov	ds:CFLAG, al
		mov	ds:NXTADD, ax
		mov	ds:SPECDRV, al
		mov	si, ds:MELSTART
		mov	ds:SRCPT, si
		call	SEARCHNEXT
		jz	short SETNMELJ
		jmp	ENDCOPY2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SETNMELJ:				; ...
		jmp	SETNMEL

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCHNEXT	proc near		; ...
		mov	ah, 12h		; DIR_SEARCH_NEXT
		test	ds:SrcInfo, 2
		jnz	short SEARCH
		or	ah, ah
		retn
SEARCHNEXT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCH		proc near		; ...
		push	ax
		mov	ah, 1Ah		; SET_DMA
		mov	dx, offset BWDBUF ; offset DIRBUF
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		pop	ax
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -
		or	al, al
		retn
SEARCH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DOCOPY		proc near		; ...
		mov	si, offset SrcBuf
		mov	di, offset SRCXNAME
		mov	ah, 60h
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	ds:IFNOTFLAG, 0	; [RDEOF]
		mov	ax, 6C00h
		mov	bx, 40h
		xor	cx, cx
		mov	dx, 101h
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short OPENOK
		jmp	short Error_On_Source
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OPENOK:					; ...
		mov	bx, ax
		mov	ds:SRCHAND, bx
		mov	ax, 5700h
		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
					; BX = file handle
		jb	short Error_On_Source
		mov	ds:CPDATE, dx
		mov	ds:CPTIME, cx
		jmp	short No_Copy_Xa
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Error_On_Source:			; ...
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	SrcBuf
		mov	ds:extend_buf_sub, 1 ; one_subst
		call	std_eprintf
		cmp	ds:SRCHAND, 0
		jz	short No_Close_Src
		call	CLOSESRC

No_Close_Src:				; ...
		cmp	ds:CFLAG, 0
		jz	short EndCopyJ3
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EndCopyJ3:				; ...
		jmp	ENDCOPY2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

No_Copy_Xa:				; ...
		mov	bx, ds:SRCHAND
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		and	dl, 80h
		mov	ds:SRCISDEV, dl
		jz	short COPYLP
		cmp	ds:BINARY, 0
		jz	short COPYLP
		mov	dx, offset INBDEV_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPYLP:					; ...
		mov	bx, ds:SRCHAND
		mov	cx, ds:BYTCNT
		mov	dx, ds:NXTADD
		sub	cx, dx
		jnz	short GOTROOM
		call	FlshFil
		cmp	ds:TERMREAD, 0
		jnz	short CLOSESRC
		mov	cx, ds:BYTCNT

GOTROOM:				; ...
		push	ds
		mov	ds, ds:TPA
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		jb	short Error_On_Source
		mov	cx, ax
		jcxz	short CLOSESRC
		cmp	ds:SRCISDEV, 0
		jnz	short NOTESTA
		cmp	ds:ASCII, 0
		jz	short BINREAD

NOTESTA:				; ...
		mov	dx, cx
		mov	di, ds:NXTADD
		mov	al, 1Ah
		push	es
		mov	es, ds:TPA
		repne scasb
		pop	es
		jnz	short USEALL
		inc	ds:IFNOTFLAG	; inc byte [RDEOF]
		inc	cx

USEALL:					; ...
		sub	dx, cx
		mov	cx, dx

BINREAD:				; ...
		add	cx, ds:NXTADD
		mov	ds:NXTADD, cx
		cmp	cx, ds:BYTCNT
		jb	short TESTDEV
		call	FlshFil
		cmp	ds:TERMREAD, 0
		jnz	short CLOSESRC
		jmp	short COPYLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTDEV:				; ...
		cmp	ds:SRCISDEV, 0
		jz	short CLOSESRC
		cmp	ds:IFNOTFLAG, 0	; cmp byte [RDEOF],0
		jz	short COPYLP
DOCOPY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CLOSESRC	proc near		; ...
		mov	bx, ds:SRCHAND
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

CLOSESRCDEST_RETN:			; ...
		retn
CLOSESRC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CLOSEDEST	proc near		; ...
		cmp	ds:SPECDRV, 0	; byte [DestClosed]
		jnz	short CLOSESRCDEST_RETN
		mov	al, byte ptr ds:ARG2S ;	byte [DestSwitch]
		call	SETASC
		jz	short BINCLOS
		mov	bx, ds:NXTADD
		call	TRYFLUSH
		jz	short NOCONC

CONCHNG:				; ...
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOCONC:					; ...
		xor	bx, bx
		push	ds
		mov	ds, ds:TPA
		mov	word ptr [bx], 1Ah ; EOF mark (ctrl-Z)
		pop	ds
		inc	ds:NXTADD
		mov	ds:NOWRITE, 0
		mov	ax, ds:WRITTEN
		add	ax, ds:NXTADD
		jb	short BINCLOS
		cmp	ax, 1
		jz	short FORGETITJ

BINCLOS:				; ...
		call	TRYFLUSH
		jnz	short CONCHNG
		cmp	ds:WRITTEN, 0

FORGETITJ:				; ...
		jnz	short NO_FORGET
		jmp	FORGETIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_FORGET:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		mov	cx, ds:CPTIME
		mov	dx, ds:CPDATE
		cmp	ds:INEXACT, 0
		jz	short DODCLOSE
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		push	cx
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		sub	cx, 1980
		xchg	ch, cl
		shl	cx, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		adc	ch, 0
		or	dl, dh
		mov	dh, ch
		pop	cx

DODCLOSE:				; ...
		cmp	bx, 0
		jle	short CLOSEDONE
		mov	ax, 5701h
		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
					; BX = file handle, CX = time to be set
					; DX = date to be set
		jb	short Cleanup_Err
		mov	ax, 4202h
		xor	dx, dx
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		or	dx, ax
		pushf
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		push	dx
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	dx
		jnb	short Close_Cont
		popf

Cleanup_Err:				; ...
		call	CleanUpErr
		call	DestDelete
		jmp	short FILECLOSED
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Close_Cont:				; ...
		popf
		jnz	short CLOSEDONE
		test	dx, 80h
		jnz	short CLOSEDONE
		call	DestDelete
		jmp	short FILECLOSED
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CLOSEDONE:				; ...
		inc	ds:FileCnt

FILECLOSED:				; ...
		inc	ds:SPECDRV	; [DestClosed]

RET50:					; ...
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORGETIT:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		call	DODCLOSE
		call	DestDelete
		mov	ds:FileCnt, 0
		jmp	short RET50
CLOSEDEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DestDelete	proc near		; ...
		mov	dx, offset DestBuf
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		retn
DestDelete	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SOURCE_SET	proc near		; ...
		push	si
		mov	ax, ds:STARTEL
		mov	si, offset ScanBuf
		sub	ax, si
		mov	di, offset SrcBuf
		add	ax, di
		mov	ds:SrcTail, ax
		mov	ds:SrcSiz, cl
		inc	cx
		rep movsb
		mov	ds:SrcInfo, bh
		pop	si
		mov	ax, bp
		call	SETASC
		call	SWITCH
		call	SETASC
		retn
SOURCE_SET	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CleanUpErr	proc near		; ...
		cmp	ds:msg_flag, 0
		jnz	short CleanupErr_Cont
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	DestBuf
		mov	ds:extend_buf_sub, 1
		call	std_eprintf

CleanupErr_Cont:			; ...
		retn
CleanUpErr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TRYFLUSH	proc near		; ...
		mov	al, ds:PARM1	; [Concat]
		push	ax
		call	FlshFil
		pop	ax
		cmp	al, ds:PARM1	; [Concat]
		retn
TRYFLUSH	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FlshFil		proc near		; ...

; FUNCTION CHUNK AT 3AE9 SIZE 00000014 BYTES

		mov	ds:TERMREAD, 0
		cmp	ds:CFLAG, 0
		jz	short NotExists
		jmp	Exists
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotExists:				; ...
		call	BUILDDEST
		call	COMPNAME
		jnz	short ProcDest
		cmp	ds:SRCISDEV, 0
		jnz	short ProcDest
		cmp	ds:PARM1, 0	; [Concat]
		mov	dx, offset OVERWR_PTR
		jnz	short No_Concat_Err
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

No_Concat_Err:				; ...
		mov	ds:NOWRITE, 1

ProcDest:				; ...
		mov	ax, 6C00h
		mov	si, offset DestBuf
		mov	bx, 21h
		xor	cx, cx
		mov	dx, 101h
		cmp	ds:NOWRITE, 0
		jnz	short DoDestOpen
		mov	dx, 112h

DoDestOpen:				; ...
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short Dest_Open_Okay

Xa_Set_Error:				; ...
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	DestBuf
		mov	ds:extend_buf_sub, 1
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Dest_Open_Okay:				; ...
		mov	ds:EndDestBuf, ax ; [DESTHAND]
		mov	ds:CFLAG, 1
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ds:DESTISDEV, dl
		test	dl, 80h
		jz	short Exists
		mov	al, byte ptr ds:ARG2S ;	[DestSwitch]
		and	al, 0Ch		; SWITCHA+SWITCHB ; 4+8
		jnz	short TestBoth
		mov	al, ds:ASCII
		or	al, ds:BINARY
		jz	short ExSetA

TestBoth:				; ...
		jp	short Exists
		test	al, 8		; SWITCHB
		jz	short Exists
		mov	ax, 4401h
		xor	dh, dh
		or	dl, 20h
		mov	ds:DESTISDEV, dl
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jmp	short Exists
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CopErrJ:
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ExSetA:					; ...
		mov	ds:ASCII, 4	; SWITCHA
		or	ds:INEXACT, 4	; SWITCHA

Exists:					; ...
		cmp	ds:NOWRITE, 0
		jnz	short NoChecking
		cmp	ds:plus_comma, 1
		jz	short NoChecking
		call	COMPNAME
		jnz	short NoChecking
		cmp	ds:SRCISDEV, 0
		jnz	short NoChecking
		mov	dx, offset LOSTERR_PTR
		call	std_eprintf
		mov	ds:NXTADD, 0
		inc	ds:TERMREAD

Ret60:					; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoChecking:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		xor	cx, cx
		xchg	cx, ds:NXTADD
		jcxz	short Ret60
		inc	ds:WRITTEN
		cmp	ds:NOWRITE, 0
		jnz	short SeekEnd
		xor	dx, dx
		push	ds
		mov	ds, ds:TPA
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		mov	dx, offset NOSPACE_PTR
		jnb	short NoChecking2
		jmp	Xa_Set_Error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoChecking2:				; ...
		sub	cx, ax
		jz	short Ret60
		test	ds:DESTISDEV, 80h ; devid_ISDEV
		jz	short COPYERR
		test	ds:DESTISDEV, 20h ; devid_RAW
		jnz	short DevWrtErr
		cmp	ds:INEXACT, 0
		jnz	short Ret60
		dec	cx
		jz	short Ret60

DevWrtErr:				; ...
		mov	dx, offset DEVWMES_PTR
		jmp	short COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SeekEnd:				; ...
		xor	dx, dx
		xchg	dx, cx
		mov	ax, 4201h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		mov	ds:OFilePtr_Lo,	ax
		mov	ds:OFilePtr_Hi,	dx
		cmp	ds:IFNOTFLAG, 0	; cmp byte [RDEOF],0
		jz	short Ret60
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short Xa_Set_Error_Jmp
		mov	ds:OCtrlZ, 1Ah
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPYERR:				; ...
		call	std_eprintf

CopErrP:				;
		inc	ds:SPECDRV	; inc byte [DestClosed]
		cmp	ds:CFLAG, 0
		jz	short EndCopyJ
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		cmp	bx, 0
		jle	short NoClose
		mov	cx, ds:OFilePtr_Hi
		mov	dx, ds:OFilePtr_Lo
		mov	ax, cx
		or	ax, dx
		jz	short ceClose
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		xor	cx, cx
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		cmp	ds:OCtrlZ, 0
		jz	short ceClose0
		inc	cx
		mov	dx, offset OCtrlZ
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

ceClose0:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ceClose:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

NoClose:				; ...
		mov	dx, offset DestBuf
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	ds:CFLAG, 0

EndCopyJ:				; ...
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Xa_Set_Error_Jmp:			; ...
		jmp	Xa_Set_Error
FlshFil		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETASC		proc near		; ...
		and	al, 0Ch		; SWITCHA+SWITCHB
		jp	short LOADSW
		push	ax
		and	al, 8		; SWITCHB
		mov	ds:BINARY, al
		pop	ax
		and	al, 4		; SWITCHA
		mov	ds:ASCII, al
		or	ds:INEXACT, al

LOADSW:					; ...
		mov	al, ds:ASCII
		or	al, al
		retn
SETASC		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDDEST	proc near		; ...
		cmp	ds:DestIsDir, 0FFh ; -1
		jnz	short KNOWABOUTDEST
		mov	di, offset USERDIR1
		mov	bp, offset DestIsDir ; offset DestVars
		call	BUILDPATH
		call	RestUDir1

KNOWABOUTDEST:				; ...
		xor	al, al
		xchg	al, ds:FIRSTDEST
		or	al, al
		jnz	short FIRSTDST
		jmp	NOFIRSTDEST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FIRSTDST:				; ...
		mov	si, ds:DestTail
		mov	di, offset DESTDIR ; offset DestFcb
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte ptr [si], 0
		jz	short GOODPARSE
		mov	dx, offset FULLDIR_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOODPARSE:				; ...
		mov	ax, word ptr ds:DestBuf
		cmp	ah, ':'
		jz	short DRVSPEC4
		mov	al, 40h	; '@'

DRVSPEC4:				; ...
		mov	cl, ds:ASCII
		or	al, 20h
		sub	al, 60h
		mov	ds:DESTDIR, al	; [DestFcb]
		mov	al, ds:DestInfo
		mov	ah, ds:SrcInfo
		and	ax, 202h
		or	al, al
		jz	short NOTMELCOPY
		cmp	al, ah
		jnz	short NOTMELCOPY
		cmp	ds:PLUS, 0
		jz	short NOTMELCOPY
		inc	ds:MELCOPY
		xor	al, al
		jmp	short SETCONC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTMELCOPY:				; ...
		xor	al, 2
		and	al, ah
		shr	al, 1

SETCONC:				; ...
		or	al, ds:PLUS
		mov	ds:PARM1, al	; [Concat]
		shl	al, 1
		shl	al, 1
		mov	ds:INEXACT, al
		cmp	ds:BINARY, 0
		jnz	short NOFIRSTDEST
		mov	ds:ASCII, al
		or	cl, cl
		jnz	short NOFIRSTDEST
		or	al, al
		jz	short NOFIRSTDEST
		mov	cx, ds:NXTADD
		jcxz	short NOFIRSTDEST
		mov	al, 1Ah
		push	es
		xor	di, di
		mov	es, ds:TPA
		repne scasb
		pop	es
		jnz	short NOFIRSTDEST
		dec	di
		mov	ds:NXTADD, di

NOFIRSTDEST:				; ...
		mov	bx, (offset BWDBUF+1) ;	DIRBUF+1
		cmp	ds:PARM1, 0	; [Concat]
		jz	short GOTCHRSRC
		mov	bx, (offset SDIRBUF+1)

GOTCHRSRC:				; ...
		mov	si, (offset DESTDIR+1) ; DestFcb+1
		mov	di, ds:DestTail
BUILDDEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDNAME	proc near		; ...
		mov	cx, 8

BUILDMAIN:				; ...
		lodsb
		cmp	al, '?'
		jnz	short NOTAMBIG
		mov	al, [bx]

NOTAMBIG:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTORE
		stosb

NOSTORE:				; ...
		inc	bx
		loop	BUILDMAIN
		mov	cl, 3
		mov	al, 20h	; ' '
		cmp	[si], al
		jz	short ENDDEST
		mov	al, '.'         ; 2Eh ; dot_chr
		stosb

BUILDEXT:				; ...
		lodsb
		cmp	al, '?'         ; 3Fh
		jnz	short NOTAMBIGE
		mov	al, [bx]

NOTAMBIGE:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTOREE
		stosb

NOSTOREE:				; ...
		inc	bx
		loop	BUILDEXT

ENDDEST:				; ...
		xor	al, al
		stosb
		retn
BUILDNAME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDPATH	proc near		; ...

; FUNCTION CHUNK AT 1ACE SIZE 00000011 BYTES

		test	byte ptr [bp+4], 2 ; [bp+VARSTRUC.INFO]
		jnz	short NOTPFILE
		mov	dx, bp
		add	dx, 5		; add dx,VARSTRUC.BUF
		push	di
		mov	ax, 6C00h
		mov	bx, 40h		; deny_none or read_open_mode
		xor	cx, cx
		mov	si, dx
		mov	dx, 101h	; read_open_flag
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		jnb	short PURE_FILE
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short NOTPFILE
		cmp	ax, 3
		jz	short NOTPFILE
		cmp	ax, 5
		jz	short NOTPFILE
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PURE_FILE:				; ...
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		test	dl, 80h		; devid_ISDEV
		jnz	short ISADEV
		test	byte ptr [bp+4], 4 ; [bp+VARSTRUC.INFO]
		jz	short ISADEV

NOTPFILE:				; ...
		mov	dx, [bp+5]	; [bp+VARSTRUC.BUF]
		cmp	dl, 0
		jz	short SET_DRIVE_SPEC
		cmp	dh, ':'         ; 3Ah
		jz	short DRVSPEC5

SET_DRIVE_SPEC:				; ...
		mov	dl, 40h	; '@'

DRVSPEC5:				; ...
		or	dl, 20h
		sub	dl, 60h		; A = 1
		call	SAVUDIR1
		jnb	short CURDIR_OK
		call	get_ext_error_number
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CURDIR_OK:				; ...
		mov	dx, bp
		add	dx, 5		; add dx,VARSTRUC.BUF
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		and	bh, 6
		cmp	bh, 6
		jnz	short CHECKAMB
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		mov	bl, ':'         ; 3Ah
		cmp	[si-2],	bl
		jnz	short KNOWNOTSPEC
		mov	byte ptr [bp+0], 2 ; [bp+VARSTRUC.ISDIR]
		jmp	short DOPCDJ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KNOWNOTSPEC:				; ...
		mov	byte ptr [bp+0], 1
		dec	si

DOPCDJ:					; ...
		jmp	DOPCD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKAMB:				; ...
		cmp	bh, 2
		jnz	short CHECKCD

ISADEV:					; ...
		mov	byte ptr [bp+0], 0
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKCD:				; ...
		call	SetRest1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short NOTPDIR
		mov	di, dx
		xor	ax, ax
		mov	cx, ax
		dec	cx

Kloop:					; ...
		mov	al, es:[di]
		inc	di
		or	al, al
		jz	short DONE
		xor	ah, ah
		call	testkanj
		jz	short Kloop
		inc	di
		inc	ah
		jmp	short Kloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DONE:					; ...
		dec	di
		mov	al, ds:DIRCHAR
		mov	byte ptr [bp+0], 2 ; [bp+VARSTRUC.ISDIR]
		or	ah, ah
		jnz	short _STORE_PCHAR
		cmp	al, [di-1]
		jz	short GOTSRCSLSH

_STORE_PCHAR:				; ...
		stosb
		mov	byte ptr [bp+0], 1

GOTSRCSLSH:				; ...
		or	byte ptr [bp+4], 6 ; [bp+VARSTRUC.INFO]
		call	SETSTARS

NOTPDIR_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTPDIR:				; ...
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short NOTPDIR_TRY
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short EXTEND_SETUPJ

NOTPDIR_TRY:				; ...
		mov	byte ptr [bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		test	bh, 4
		jz	short NOTPDIR_RETN
		mov	byte ptr [bp+0], 2
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	byte ptr [si], 0
		jz	short BADCDERRJ2
		mov	bl, 2Eh	; '.'
		cmp	[si], bl
		jz	short BADCDERRJ2
		mov	bl, 3Ah	; ':'
		cmp	[si-2],	bl
		jz	short DOPCD
		mov	byte ptr [bp+0], 1
		dec	si

DOPCD:					; ...
		xor	bl, bl
		xchg	bl, [si]
		call	SetRest1
		cmp	dx, si
		jnb	short LookBack
		push	si
		push	cx
		mov	cx, si
		mov	si, dx

Kloop2:					; ...
		lodsb
		call	testkanj
		jz	short NotKanj4
		lodsb
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si
		jmp	short DoCdr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotKanj4:				; ...
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si

LookBack:				; ...
		cmp	bl, [si-1]
		jz	short BADCDERRJ2

DoCdr:					; ...
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	bl, [si]
		jnb	short NOTPDIR_RETN
		call	get_ext_error_number

EXTEND_SETUPJ:				; ...
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADCDERRJ2:				; ...
		jmp	badpath_err
BUILDPATH	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETSTARS	proc near		; ...
		mov	[bp+2],	di	; [bp+VARSTRUC.TTAIL]
		add	byte ptr [bp+1], 12 ; [bp+VARSTRUC.SIZ]
		mov	ax, '.?'        ; "?." ; dot_qmark ; 2E3Fh
		mov	cx, 8
		rep stosb
		xchg	al, ah
		stosb
		xchg	al, ah
		mov	cl, 3
		rep stosb
		xor	al, al
		stosb
		retn
SETSTARS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


COMPNAME	proc near		; ...
		mov	si, offset DestBuf
		mov	di, offset TRGXNAME
		mov	ah, 60h		; XNAMETRANS
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	si, offset SRCXNAME
		mov	di, offset TRGXNAME
		call	STRCOMP
		retn
COMPNAME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cparse		proc near		; ...
		xor	ax, ax
		mov	ds:STARTEL, di
		mov	ds:ELPOS, al
		mov	ds:SKPDEL, al
		mov	bh, al
		pushf
		push	di
		xor	cx, cx
		mov	ds:comma, cl

moredelim:				; ...
		lodsb
		call	DELIM
		jnz	short SCANCDONE
		cmp	al, 20h	; ' '
		jz	short moredelim
		cmp	al, 9
		jz	short moredelim
		xchg	al, ds:SKPDEL
		or	al, al
		jz	short moredelim
		test	bh, 80h
		jz	short no_comma
		mov	ds:comma, 1

no_comma:				; ...
		jmp	x_done
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCANCDONE:				; ...
		cmp	al, bl
		jnz	short nospec
		or	bh, 80h
		jmp	short moredelim
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nospec:					; ...
		cmp	al, 0Dh
		jnz	short ncperror
		jmp	cperror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ncperror:				; ...
		cmp	al, ds:SWITCHAR
		jnz	short na_switch
		jmp	a_switch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

na_switch:				; ...
		mov	dl, ':'
		cmp	[si], dl
		jnz	short anum_chard
		cmp	ds:cpyflag, 1
		jnz	short cpcont2
		call	UPCONV

cpcont2:				; ...
		call	move_char
		lodsb
		call	move_char
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0
		jmp	anum_test
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

anum_chard:				; ...
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0
		cmp	ds:cpyflag, 1
		jnz	short anum_char
		call	pathchrcmp
		jnz	short anum_char
		push	ax
		mov	al, ds:CURDRV
		add	al, 'A'         ; 41h
		call	move_char
		mov	al, ':'         ; 3Ah
		call	move_char
		pop	ax
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0

anum_char:				; ...
		call	testkanj
		jz	short NOTKANJ
		call	move_char
		lodsb
		jmp	short notspecial
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ:				; ...
		cmp	ds:cpyflag, 1
		jnz	short TESTDOT
		call	UPCONV

TESTDOT:				; ...
		cmp	al, 2Eh	; '.'   ; dot_chr
		jnz	short testquest
		inc	ds:ELPOS
		mov	ds:ELCNT, 0FFh

testquest:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short testsplat
		or	bh, 2

testsplat:				; ...
		cmp	al, 2Ah	; '*'   ; star
		jnz	short testpath
		or	bh, 2
		cmp	ds:expand_star,	0
		jnz	short expand_filename
		jmp	short testpath
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR2J:				; ...
		jmp	short BADPERR2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

expand_filename:			; ...
		mov	ah, 7
		cmp	ds:ELPOS, 0
		jz	short gotelcnt
		mov	ah, 2

gotelcnt:				; ...
		mov	al, 3Fh	; '?'
		sub	ah, ds:ELCNT
		jb	short BADPERR2J
		xchg	ah, cl
		jcxz	short testpathx

qmove:					; ...
		xchg	ah, cl
		call	move_char
		xchg	ah, cl
		loop	qmove

testpathx:				; ...
		xchg	ah, cl

testpath:				; ...
		call	pathchrcmp
		jnz	short notspecial
		or	bh, 4
		cmp	ds:expand_star,	0
		jz	short no_err_check
		test	bh, 2
		jnz	short BADPERR

no_err_check:				; ...
		mov	ds:STARTEL, di
		inc	ds:STARTEL
		mov	ds:ELCNT, 0FFh
		mov	ds:ELPOS, 0

notspecial:				; ...
		call	move_char

anum_test:				; ...
		lodsb
		call	DELIM
		jz	short x_done
		cmp	al, 0Dh
		jz	short x_done
		cmp	al, ds:SWITCHAR
		jz	short x_done
		cmp	al, bl
		jz	short x_done
		cmp	al, ':'
		jz	short FOO15
		jmp	anum_char
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOO15:					; ...
		cmp	ds:cpyflag, 2
		jnz	short cpcont4
		call	move_char
		jmp	short anum_test
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpcont4:				; ...
		inc	si
		jmp	short x_done
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	anum_char
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR2:				; ...
		mov	dx, offset BADCPMES_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR:				; ...
		mov	dx, offset badcd_ptr
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cperror:				; ...
		dec	si
		pop	di
		popf
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

x_done:					; ...
		dec	si
		jmp	short out_token
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

a_switch:				; ...
		or	bh, 1
		or	bp, 8000h	; FSWITCH
		call	scanoff
		inc	si
		call	testkanj
		jz	short a_switch_notkanj
		call	move_char
		lodsb
		call	move_char
		or	bp, 4000h	; FBADSWITCH
		jmp	short out_token
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

a_switch_notkanj:			; ...
		cmp	al, 0Dh
		jnz	short Store_swt
		mov	al, 0
		stosb
		or	bp, 4000h
		jmp	short cperror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Store_swt:				; ...
		call	move_char
		call	UPCONV
		push	es
		push	di
		push	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	di, offset switch_list ; "?VBAPW"
		mov	cx, 6		; SWCOUNT
		or	bp, 4000h	; FBADSWITCH
		repne scasb
		jnz	short out_tokenp
		and	bp, 0BFFFh	; ~FBADSWITCH ;	not FBADSWITCH
		mov	ax, 1
		shl	ax, cl
		or	bp, ax

out_tokenp:				; ...
		pop	cx
		pop	di
		pop	es
		assume es:nothing

out_token:				; ...
		mov	al, 0
		stosb
		pop	di
		popf
		clc
		retn
cparse		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


move_char	proc near		; ...
		stosb
		inc	cx
		inc	ds:ELCNT
		retn
move_char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sysparse	proc near		; ...
		mov	word ptr cs:$P_Flags, 0	; mov psdata_seg:$P_Flags,0
		mov	cs:$P_ORIG_ORD,	cx ; MOV PSDATA_SEG:$P_ORIG_ORD,CX
		mov	cs:$P_ORIG_STACK, sp
		mov	cs:$P_ORIG_SI, si

$P_Redo_Time:				; ...
		cld
		mov	cs:$P_ORDINAL, cx ; mov	psdata_seg:$P_ordinal,cx
		mov	cs:$P_RC, 0	; mov psdata_seg:$P_RC,$P_No_Error
		mov	cs:$P_Found_SYNONYM, 0 ; mov psdata_seg:$P_Found_SYNONYM,0
		mov	cs:$P_DX, 0	; mov word ptr psdata_seg:$P_DX,0
		mov	word ptr cs:$P_FileSp_Char, '][' ; "[]|<>+=;\""
		mov	word ptr cs:$P_FileSp_Char+2, '<|'
		mov	word ptr cs:$P_FileSp_Char+4, '+>'
		mov	word ptr cs:$P_FileSp_Char+6, ';='
		call	$P_Skip_Delim
		jnb	short $P_Start
		mov	ax, 0FFFFh	; $P_RC_EOL
		push	bx
		mov	bx, es:[di]	; es:[di].$P_PARMSX_Address
		cmp	cl, es:[bx]	; es:[bx].$P_MinP
		jnb	short $P_Fin
		mov	ax, 2		; $P_Op_Missing

$P_Fin:					; ...
		pop	bx
		jmp	$P_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Start:				; ...
		mov	cs:$P_SaveSI_Cmpx, si ;	mov psdata_seg:$P_SaveSI_Cmpx,si
		push	bx
		push	di
		push	bp
		lea	bx, $P_STRING_BUF
		test	cs:$P_Flags2, 20h ; $P_Extra
		jnz	short $P_Pack_End

$P_Pack_Loop:				; ...
		lodsb
		call	$P_Chk_Switch
		jb	short $P_Pack_End_BY_EOL
		call	$P_Chk_EOL
		jz	short $P_Pack_End_BY_EOL
		call	$P_Chk_Delim
		jnz	short $P_PL01
		test	cs:$P_Flags2, 20h ; test psdata_seg:$P_Flags2,$P_Extra
		jnz	short $P_Pack_End_backup_si
		call	$P_Skip_Delim
		jmp	short $P_Pack_End
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Pack_End_backup_si:			; ...
		test	cs:$P_Flags2, 41h ; test psdata_seg:$P_Flags2,$P_SW+$P_equ
		jz	short $P_Pack_End
		dec	si
		jmp	short $P_Pack_End
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_PL01:				; ...
		mov	cs:[bx], al	; mov psdata_seg:[bx],al
		cmp	al, '='         ; cmp al,$P_Keyword
		jnz	short $P_PL00
		or	cs:$P_Flags2, 1	; or psdata_seg:$P_Flags2,$P_equ

$P_PL00:				; ...
		inc	bx
		call	$P_Chk_DBCS
		jnb	short $P_Pack_Loop
		lodsb
		mov	cs:[bx], al	; mov psdata_seg:[bx],al
		inc	bx
		jmp	short $P_Pack_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Pack_End_BY_EOL:			; ...
		dec	si

$P_Pack_End:				; ...
		mov	cs:$P_SI_Save, si
		mov	byte ptr cs:[bx], 0 ; mov byte ptr psdata_seg:[bx],$P_NULL
		mov	cs:$P_Save_EOB,	bx
		mov	bx, es:[di]	; es:[di].$P_PARMSX_Address
		lea	si, $P_STRING_BUF ; lea	si,psdata_seg:$P_STRING_BUF
					; (lea si,ds:88D9h)
		cmp	byte ptr cs:[si], '/' ; psdata_seg:[si],$P_Switch
		jz	short $P_SW_Manager
		cmp	byte ptr cs:[si], '"' ; psdata_seg:[si],$P_DQuote
		jz	short $P_Positional_Manager
		test	cs:$P_Flags2, 1	; test psdata_seg:$P_Flags2,$P_equ
		jnz	short $P_Key_Manager

$P_Positional_Manager:			; ...
		mov	al, es:[bx+1]	; es:[bx].$P_MaxP
		xor	ah, ah
		cmp	cs:$P_ORDINAL, ax ; psdata_seg:$P_ORDINAL,ax
		jnb	short $P_Too_Many_Error
		mov	ax, cs:$P_ORDINAL ; psdata_seg:$P_ORDINAL
		shl	ax, 1
		inc	bx
		inc	bx
		add	bx, ax
		mov	bx, es:[bx]
		call	$P_Chk_Pos_Control
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Too_Many_Error:			; ...
		mov	cs:$P_RC, 1	; psdata_seg:$P_RC,$P_Too_Many
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SW_Manager:				; ...
		mov	al, es:[bx+1]	; mov al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short $P_SW_Not_Found
		inc	bx

$P_SW_Mgr_Loop:				; ...
		push	bx
		mov	bx, es:[bx]
		call	$P_Chk_SW_Control
		pop	bx
		jnb	short $P_Return_to_Caller
		inc	bx
		inc	bx
		loop	$P_SW_Mgr_Loop

$P_SW_Not_Found:			; ...
		mov	cs:$P_RC, 3	; psdata_seg:$P_RC,$P_Not_In_SW
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Key_Manager:				; ...
		mov	al, es:[bx+1]	; es:[bx].$P_MaxP
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	al, es:[bx]
		xor	ah, ah
		shl	ax, 1
		inc	ax
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short $P_Key_Not_Found
		inc	bx

$P_Key_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]
		call	$P_Chk_Key_Control
		pop	bx
		jnb	short $P_Return_to_Caller
		inc	bx
		inc	bx
		loop	$P_Key_Mgr_Loop

$P_Key_Not_Found:			; ...
		mov	cs:$P_RC, 4	; psdata_seg:$P_RC,$P_Not_In_Key

$P_Return_to_Caller:			; ...
		pop	bp
		pop	di
		pop	bx
		mov	cx, cs:$P_ORDINAL ; mov	cx,psdata_seg:$P_Ordinal
		mov	ax, cs:$P_RC
		mov	si, cs:$P_SI_Save ; mov	si,psdata_seg:$P_SI_Save
		mov	dx, cs:$P_DX
		mov	bl, cs:$P_Terminator

$P_Single_Exit:				; ...
		clc
		retn
sysparse	endp ; sp =  2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Pos_Control proc	near		; ...
		push	ax
		mov	ax, es:[bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		test	ax, 2		; $P_Repeat
		jnz	short $P_CPC00
		inc	cs:$P_ORDINAL

$P_CPC00:				; ...
		cmp	byte ptr cs:[si], 0 ; $P_NULL
		jnz	short $P_CPC01
		test	ax, 1		; $P_Optional
		jnz	short $P_CPC02
		mov	cs:$P_RC, 2	; $P_Op_Missing
		jmp	short $P_CPC_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CPC02:				; ...
		push	ax
		mov	al, 3		; $P_String
		mov	ah, 0FFh	; $P_No_Tag
		call	$P_Fill_Result
		pop	ax
		jmp	short $P_CPC_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CPC01:				; ...
		call	$P_Check_Match_Flags

$P_CPC_Exit:				; ...
		pop	ax
		retn
$P_Chk_Pos_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Key_Control proc	near		; ...
		stc
		retn
$P_Chk_Key_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Search_KEYorSW proc near		; ...
		push	bp
		push	cx
		mov	cl, es:[bx+8]	; [es:bx+$P_CONTROL_BLK.$P_nid]
		xor	ch, ch
		or	cx, cx
		jz	short $P_KEYorSW_Not_Found
		lea	bp, [bx+9]	; [es:bx+$P_CONTROL_BLK.$P_KEYorSW]

$P_KEYorSW_Loop:			; ...
		call	$P_String_Comp
		jnb	short $P_KEYorSW_Found
		call	$P_MoveBP_NUL
		loop	$P_KEYorSW_Loop

$P_KEYorSW_Not_Found:			; ...
		stc
		jmp	short $P_KEYorSW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_KEYorSW_Found:			; ...
		mov	cs:$P_Found_SYNONYM, bp
		clc

$P_KEYorSW_Exit:			; ...
		pop	cx
		pop	bp
		retn
$P_Search_KEYorSW endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_MoveBP_NUL	proc near		; ...
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jz	short $P_MBP_Exit
		inc	bp
		jmp	short $P_MoveBP_NUL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_MBP_Exit:				; ...
		inc	bp
		retn
$P_MoveBP_NUL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_SW_Control proc near		; ...
		or	cs:$P_Flags2, 10h ; or psdata_seg:$P_Flags2,$P_Sw_Cmp
		call	$P_Search_KEYorSW
		jb	short $P_Chk_SW_Err0
		and	cs:$P_Flags2, 0EFh ; and psdata_seg:$P_Flags2,0ffh-$P_Sw_Cmp
		push	ax
		mov	ax, cs:$P_KEYorSW_Ptr ;	psdata_seg:$P_KEYorSW_Ptr
		sub	ax, si
		add	cs:$P_SaveSI_Cmpx, ax
		pop	ax
		mov	si, cs:$P_KEYorSW_Ptr
		cmp	byte ptr cs:[si], 0 ; psdata_seg:[si],$P_NULL
		jnz	short $P_CSW00
		cmp	byte ptr cs:[si-1], ':' ; psdata_seg:[si-1],$P_Colon
		jnz	short $P_Chk_if_data_required
		mov	cs:$P_RC, 9	; psdata_seg:$P_RC,$P_Syntax
		jmp	short $P_Chk_SW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_if_data_required:		; ...
		cmp	word ptr es:[bx], 0 ; cmp es:[bx].$P_Match_Flag,0
		jz	short $P_Chk_SW_Exit
		test	word ptr es:[bx], 1 ; test es:[bx].$P_Match_Flag,$P_Optional
		jnz	short $P_Chk_SW_Exit
		mov	cs:$P_RC, 2	; mov psdata_seg:$P_RC,$P_Op_Missing
		jmp	short $P_Chk_SW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CSW00:				; ...
		call	$P_Check_Match_Flags
		clc
		jmp	short $P_Chk_SW_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_SW_Err0:				; ...
		stc
		jmp	short $P_Chk_SW_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_SW_Exit:				; ...
		push	ax
		mov	al, 3		; mov al,$P_String
		mov	ah, 0FFh	; mov ah,$P_No_Tag
		call	$P_Fill_Result
		pop	ax
		clc

$P_Chk_SW_Single_Exit:			; ...
		retn
$P_Chk_SW_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Fill_Result	proc near		; ...
		push	di
		mov	di, es:[bx+4]	; [es:bx+$P_CONTROL_BLK.$P_Result_Buf]
		mov	cs:$P_DX, di
		mov	es:[di], al	; [es:di+$P_RESULT_BLK.$P_Type]
		mov	es:[di+1], ah	; [es:di+$P_RESULT_BLK.$P_Item_Tag]
		push	ax
		mov	ax, cs:$P_Found_SYNONYM
		mov	es:[di+2], ax
		pop	ax
		cmp	al, 1		; $P_Number
		jnz	short $P_RLT00

$P_RLT02:				; ...
		mov	es:[di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	es:[di+6], cx	; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT00:				; ...
		cmp	al, 2		; $P_List_Idx
		jnz	short $P_RLT01
		mov	es:[di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT01:				; ...
		cmp	al, 7		; $P_Date_F
		jz	short $P_RLT02
		cmp	al, 8		; $P_Time_F
		jz	short $P_RLT02
		cmp	al, 6		; $P_Drive
		jnz	short $P_RLT03
		mov	es:[di+4], dl	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT03:				; ...
		cmp	al, 4		; $P_Complex
		jnz	short $P_RLT05
		mov	ax, cs:$P_SaveSI_Cmpx
		inc	ax
		mov	es:[di+4], ax	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	word ptr es:[di+6], ds ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT05:				; ...
		mov	es:[di+4], si	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	word ptr es:[di+6], cs ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		push	ax
		test	byte ptr es:[bx+2], 1 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
		jz	short $P_RLT_CAP00
		mov	al, 4		; $P_DOSTBL_File
		jmp	short $P_RLT_CAP02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT_CAP00:				; ...
		test	byte ptr es:[bx+2], 2 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
		jz	short $P_RLT_CAP01
		mov	al, 2		; $P_DOSTBL_Char

$P_RLT_CAP02:				; ...
		call	$P_Do_CAPS_String

$P_RLT_CAP01:				; ...
		pop	ax
		test	byte ptr es:[bx+2], 10h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
		jz	short $P_RLT_Exit
		call	$P_Remove_Colon

$P_RLT_Exit:				; ...
		pop	di
		retn
$P_Fill_Result	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Check_Match_Flags proc near		; ...
		mov	cs:$P_err_flag,	0 ; $P_NULL
		push	ax
		mov	ax, es:[bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		or	ax, ax
		jnz	short $P_Mat
		push	ax
		push	bx
		push	dx
		push	di
		mov	cs:$P_RC, 9	; $P_Syntax
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		jmp	short $P_Bridge
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Mat:					; ...
		test	ax, 1000h	; $P_Date_S
		jz	short $P_Match02
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Date_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Bridge

$P_Match02:				; ...
		test	ax, 800h	; $P_Time_S
		jz	short $P_Match03
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Time_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Bridge
		jmp	short $P_Match03
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Bridge:				; ...
		jmp	short $P_Match_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nop

$P_Match03:				; ...
		test	ax, 8000h	; $P_Num_Val
		jz	short $P_Match04
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Value
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match04:				; ...
		test	ax, 4000h	; $P_SNum_Val
		jz	short $P_Match05
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_SValue
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match05:				; ...
		test	ax, 100h	; $P_Drv_Only
		jz	short $P_Match06
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_File_Format
		call	$P_Drive_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match06:				; ...
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Match07
		mov	cs:$P_RC, 0
		call	$P_File_Format
		cmp	cs:$P_RC, 9
		jnz	short $P_Match_Exit

$P_Match07:				; ...
		test	ax, 2000h	; $P_Simple_S
		jz	short $P_Match_Exit
		mov	cs:$P_RC, 0
		call	$P_Simple_String

$P_Match_Exit:				; ...
		cmp	cs:$P_err_flag,	1 ; $P_error_filespec
		jnz	short $P_Match2_Exit
		cmp	cs:$P_RC, 0	; $P_No_Error
		jnz	short $P_Match2_Exit
		mov	cs:$P_RC, 9	; $P_Syntax

$P_Match2_Exit:				; ...
		pop	ax
		retn
$P_Check_Match_Flags endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Remove_Colon	proc near		; ...
		push	ax
		push	si

$P_RCOL_Loop:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_RCOL_Exit
		cmp	al, ':'         ; $P_Colon
		jnz	short $P_RCOL00
		cmp	byte ptr cs:[si+1], 0 ;	$P_NULL
		jnz	short $P_RCOL00
		mov	byte ptr cs:[si], 0
		jmp	short $P_RCOL_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RCOL00:				; ...
		call	$P_Chk_DBCS
		jnb	short $P_RCOL01
		inc	si

$P_RCOL01:				; ...
		inc	si
		jmp	short $P_RCOL_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RCOL_Exit:				; ...
		pop	si
		pop	ax
		retn
$P_Remove_Colon	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Do_CAPS_String proc near		; ...
		push	si
		push	dx
		mov	dl, al

$P_DCS_Loop:				; ...
		mov	al, cs:[si]
		call	$P_Chk_DBCS
		jb	short $P_DCS0
		or	al, al
		jz	short $P_DCS_Exit
		call	$P_Do_CAPS_Char
		mov	cs:[si], al
		jmp	short $P_DCS01
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCS0:				; ...
		inc	si

$P_DCS01:				; ...
		inc	si
		jmp	short $P_DCS_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCS_Exit:				; ...
		pop	dx
		pop	si
		retn
$P_Do_CAPS_String endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Do_CAPS_Char	proc near		; ...
		cmp	al, 80h		; $P_ASCII80
		jnb	short $P_DCC_Go
		cmp	al, 61h	; 'a'
		jb	short $P_CAPS_Ret
		cmp	al, 7Ah	; 'z'
		ja	short $P_CAPS_Ret
		and	al, 0DFh	; $P_Make_Upper
		jmp	short $P_CAPS_Ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCC_Go:				; ...
		push	bx
		push	es
		push	di
		lea	di, $P_File_CAP_Ptr
		cmp	dl, 4		; $P_DOSTBL_File
		jz	short $P_DCC00
		lea	di, $P_Char_CAP_Ptr

$P_DCC00:				; ...
		cmp	cs:[di], dl
		jz	short $P_DCC01
		push	ax
		push	cx
		push	dx
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	ah, 65h		; $P_DOS_Get_TBL
		mov	al, dl
		mov	bx, 0FFFFh	; -1
		mov	cx, 5
		mov	dx, 0FFFFh	; -1
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		pop	dx
		pop	cx
		pop	ax

$P_DCC01:				; ...
		mov	bx, cs:[di+1]	; [cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
		mov	es, word ptr cs:[di+3] ; [cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
		assume es:nothing
		inc	bx
		inc	bx
		sub	al, 80h		; $P_ASCII80
		xlat	byte ptr es:[bx]
		pop	di
		pop	es
		pop	bx

$P_CAPS_Ret:				; ...
		retn
$P_Do_CAPS_Char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_SValue	proc near		; ...
		push	ax
		or	cs:$P_Flags2, 80h ; $P_Signed
		and	cs:$P_Flags2, 0FDh ; 0FFh-$P_Neg
		mov	al, cs:[si]
		cmp	al, 2Bh	; '+'   ; $P_Plus
		jz	short $P_SVal00
		cmp	al, 2Dh	; '-'   ; $P_Minus
		jnz	short $P_Sval01
		or	cs:$P_Flags2, 2	; $P_Neg

$P_SVal00:				; ...
		inc	si

$P_Sval01:				; ...
		call	$P_Value
		pop	ax
		retn
$P_SValue	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Value	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		xor	cx, cx
		xor	dx, dx
		push	bx

$P_Value_Loop:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_Value00
		call	$P_0099
		jb	short $P_Value_Err0
		xor	ah, ah
		mov	bp, ax
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		mov	bx, dx
		mov	ax, cx
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		add	dx, bx
		adc	cx, ax
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		add	dx, bp
		adc	cx, 0
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		inc	si
		jmp	short $P_Value_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value_Err0:				; ...
		pop	bx
		jmp	$P_Value_Err
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value00:				; ...
		pop	bx
		test	cs:$P_Flags2, 2	; $P_Neg
		jz	short $P_Value01
		not	cx
		not	dx
		add	dx, 1
		adc	cx, 0

$P_Value01:				; ...
		mov	si, es:[bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, es:[si]
		cmp	al, 0		; $P_nval_None
		jnz	short $P_Value02
		mov	al, 1
		mov	ah, 0FFh
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nop

$P_Value02:				; ...
		inc	si
		mov	al, es:[si]
		cmp	al, 0
		jz	short $P_Value_Err ; $P_Value03
		inc	si

$P_Val02_Loop:				; ...
		test	cs:$P_Flags2, 80h ; $P_Signed
		jnz	short $P_Val02_Sign
		cmp	cx, es:[si+3]	; [es:si+$P_VAL_LIST.$P_Val_XH]
		jb	short $P_Val02_Next
		ja	short $P_Val_In
		cmp	dx, es:[si+1]	; [es:si+$P_VAL_LIST.$P_Val_XL]
		jb	short $P_Val02_Next

$P_Val_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+$P_VAL_LIST.$P_Val_YH]
		ja	short $P_Val02_Next
		jb	short $P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+$P_VAL_LIST.$P_Val_YL]
		ja	short $P_Val02_Next
		jmp	short $P_Val_Found
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val02_Sign:				; ...
		cmp	cx, es:[si+3]
		jl	short $P_Val02_Next
		jg	short $P_SVal_In
		cmp	dx, es:[si+1]
		jl	short $P_Val02_Next

$P_SVal_In:				; ...
		cmp	cx, es:[si+7]
		jg	short $P_Val02_Next
		jl	short $P_Val_Found
		cmp	dx, es:[si+5]
		jg	short $P_Val02_Next
		jmp	short $P_Val_Found
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val02_Next:				; ...
		add	si, 9		; $P_Len_Range
		dec	al
		jnz	short $P_Val02_Loop
		mov	cs:$P_RC, 6	; $P_Out_Of_Range
		mov	al, 1		; $P_Number
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val_Found:				; ...
		mov	al, 1
		mov	ah, es:[si]
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value_Err:				; ...
		mov	cs:$P_RC, 9	; $P_Syntax
		mov	al, 3		; $P_String
		mov	ah, 0FFh	; $P_No_Tag

$P_Value_Exit:				; ...
		call	$P_Fill_Result
		pop	si
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Value	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Check_OVF	proc near		; ...
		pushf
		test	cs:$P_Flags2, 2
		jnz	short $P_COVF
		popf
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_COVF:				; ...
		popf
		jo	short $P_COVF00
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_COVF00:				; ...
		stc
		retn
$P_Check_OVF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_0099		proc near		; ...
		cmp	al, 30h	; '0'
		jb	short $P_0099Err
		cmp	al, 39h	; '9'
		ja	short $P_0099Err
		sub	al, 30h	; '0'
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_0099Err:				; ...
		stc
		retn
$P_0099		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Simple_String proc near		; ...
		push	ax
		push	bx
		push	dx
		push	di
		mov	di, es:[bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, es:[di]
		or	al, al
		jnz	short $P_Sim00
		mov	ah, 0FFh
		jmp	short $P_Sim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim00:				; ...
		cmp	al, 3		; $P_nval_String
		jnz	short $P_Sim01
		inc	di
		mov	al, es:[di]
		mov	ah, 9		; $P_Len_Range
		mul	ah
		inc	ax
		add	di, ax
		mov	al, es:[di]
		mov	ah, 5		; $P_Len_Value
		mul	ah
		inc	ax
		add	di, ax
		mov	al, es:[di]
		inc	di
		inc	di

$P_Sim_Loop:				; ...
		mov	bp, es:[di]
		call	$P_String_Comp
		jnb	short $P_Sim_Found
		add	di, 3
		dec	al
		jnz	short $P_Sim_Loop
		mov	cs:$P_RC, 8
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Sim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim_Found:				; ...
		mov	ah, es:[di-1]
		mov	al, 2		; $P_List_Idx$P_List_Idx
		mov	dx, es:[di]
		jmp	short $P_Sim_Exit0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim01:				; ...
		mov	cs:$P_RC, 9
		mov	ah, 0FFh	; $P_No_Tag

$P_Sim_Exit:				; ...
		mov	al, 3		; $P_String

$P_Sim_Exit0:				; ...
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		retn
$P_Simple_String endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_String_Comp	proc near		; ...
		push	ax
		push	bp
		push	dx
		push	si
		mov	dl, 2		; $P_DOSTBL_Char

$P_SCOM_Loop:				; ...
		mov	al, cs:[si]	; 1st string
		call	$P_Chk_DBCS
		jb	short $P_SCOM00
		call	$P_Do_CAPS_Char
		test	cs:$P_Flags2, 8	; $P_Key_Cmp
		jz	short $P_SCOM04
		cmp	al, 3Dh	; '='   ; $P_Keyword
		jnz	short $P_SCOM03
		cmp	byte ptr es:[bp+1], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM05
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM04:				; ...
		test	cs:$P_Flags2, 10h ; $P_SW_Cmp
		jz	short $P_SCOM03
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_SCOM03
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ

$P_SCOM05:				; ...
		inc	si
		jmp	short $P_SCOM_Same
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM03:				; ...
		cmp	al, es:[bp+0]	; 2nd string (must be upper case)
		jnz	short $P_SCOM_Differ0
		or	al, al
		jz	short $P_SCOM_Same
		inc	si
		inc	bp
		jmp	short $P_SCOM01
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM00:				; ...
		cmp	al, es:[bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		mov	al, cs:[si]
		inc	bp
		cmp	al, es:[bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		inc	bp

$P_SCOM01:				; ...
		jmp	short $P_SCOM_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM_Differ0:			; ...
		test	cs:$P_Flags2, 40h ; $P_SW
		jz	short $P_not_applicable
		test	word ptr es:[bx+2], 20h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
		jz	short $P_not_applicable
		cmp	byte ptr es:[bp+0], 0
		jz	short $P_SCOM_Same

$P_not_applicable:			; ...
		test	word ptr es:[bx], 10h ;	[es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
		jz	short $P_SCOM_Differ
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_SCOM02
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM_Same
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM02:				; ...
		cmp	al, 0
		jnz	short $P_SCOM_Differ
		cmp	byte ptr es:[bp+0], 3Ah	; ':'
		jz	short $P_SCOM_Same

$P_SCOM_Differ:				; ...
		stc
		jmp	short $P_SCOM_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM_Same:				; ...
		mov	cs:$P_KEYorSW_Ptr, si
		clc

$P_SCOM_Exit:				; ...
		pop	si
		pop	dx
		pop	bp
		pop	ax
		retn
$P_String_Comp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Date_Format	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI
		pop	si
		mov	cs:$P_1st_Val, 0
		mov	cs:$P_2nd_Val, 0 ; mov psdata_seg:$P_2nd_Val,0
		mov	cs:$P_3rd_Val, 0
		call	$P_Get_DecNum
		jb	short $P_DateF_Err0
		mov	cs:$P_1st_Val, ax
		or	bl, bl
		jz	short $P_DateF_YMD
		call	$P_Get_DecNum
		jb	short $P_DateF_Error
		mov	cs:$P_2nd_Val, ax
		or	bl, bl
		jz	short $P_DateF_YMD
		call	$P_Get_DecNum

$P_DateF_Err0:				; ...
		jb	short $P_DateF_Error
		mov	cs:$P_3rd_Val, ax
		or	bl, bl
		jnz	short $P_DateF_Error

$P_DateF_YMD:				; ...
		mov	bx, cs:$P_Country_Info ; [cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
					; mov bx,psdata_seg:$P_Country_Info.$P_CDI_DateF
		cmp	bx, 2		; bx,$P_Date_YMD
		jz	short $P_DateF00
		mov	ax, cs:$P_1st_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	cl, al
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	ch, al
		mov	dx, cs:$P_3rd_Val
		cmp	bx, 1		; bx,$P_Date_DMY
		jnz	short $P_DateF01
		xchg	ch, cl

$P_DateF01:				; ...
		jmp	short $P_DateF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DateF00:				; ...
		mov	dx, cs:$P_1st_Val
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	cl, al
		mov	ax, cs:$P_3rd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	ch, al

$P_DateF02:				; ...
		cmp	dx, 100
		jnb	short $P_DateF03
		add	dx, 1900

$P_DateF03:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 7		; $P_Date_F
		call	$P_Fill_Result
		jmp	short $P_Date_Format_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DateF_Error:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		mov	cs:$P_RC, 9	; mov psdata_seg:$P_RC,$P_Syntax

$P_Date_Format_Exit:			; ...
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Date_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Set_CDI	proc near		; ...
		lea	si, $P_Country_Info ; (lea si,ds:8960h)
					; lea si,psdata_seg:$P_Country_Info
		cmp	word ptr cs:[si], 0FFFFh ;
					; cmp psdata_seg:[si].$P_CDI_DateF,$P_NeedToBeRead
		jz	short $P_Read_CDI
		jmp	short $P_Set_CDI_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Read_CDI:				; ...
		push	ds
		push	dx
		push	ax
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	ax, 3800h	; $P_DOS_Get_CDI
		mov	dx, si
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		pop	dx
		pop	ds
		assume ds:nothing

$P_Set_CDI_Exit:			; ...
		retn
$P_Set_CDI	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Get_DecNum	proc near		; ...
		push	cx
		push	dx
		xor	cx, cx

$P_GetNum_Loop:				; ...
		mov	al, cs:[si]	; mov al,psdata_seg:[si]
		or	al, al
		jz	short $P_GetNum00
		cmp	cs:$P_Got_Time,	0 ; cmp	psdata_seg:$P_Got_Time,0
		jz	short $P_Do_Date_Delims
		cmp	bl, 1		; cmp bl,$P_colon_period
		jnz	short $P_Do_Time_Delim1
		cmp	al, ':'         ; $P_Colon
		jz	short $P_GetNum01

$P_Do_Time_Delim1:			; ...
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01
		jmp	short $P_Neither_Delims
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Do_Date_Delims:			; ...
		cmp	al, '-'         ; $P_Minus
		jz	short $P_GetNum01
		cmp	al, '/'         ; $P_Slash
		jz	short $P_GetNum01
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01

$P_Neither_Delims:			; ...
		call	$P_0099
		jb	short $P_GetNum_Exit
		mov	ah, 0
		xchg	ax, cx
		mov	dx, 10
		mul	dx
		or	dx, dx
		jnz	short $P_GetNum02
		add	ax, cx
		jb	short $P_GetNum_Exit
		xchg	ax, cx
		inc	si
		jmp	short $P_GetNum_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum00:				; ...
		mov	bl, al
		clc
		jmp	short $P_GetNum_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum01:				; ...
		inc	si
		clc
		jmp	short $P_GetNum_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum02:				; ...
		stc

$P_GetNum_Exit:				; ...
		mov	ax, cx
		pop	dx
		pop	cx
		retn
$P_Get_DecNum	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Time_Format	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI
		test	byte ptr cs:[si+11h], 1	;
					; test byte ptr	psdata_seg:[si].$P_CDI_TimeF,1
		pop	si
		jnz	short $P_TimeF00
		call	$P_Time_2412

$P_TimeF00:				; ...
		mov	cs:$P_1st_Val, 0
		mov	cs:$P_2nd_Val, 0
		mov	cs:$P_3rd_Val, 0 ; mov psdata_seg:$P_3rd_Val,0
		mov	cs:$P_4th_Val, 0
		mov	cs:$P_Got_Time,	1 ; mov	psdata_seg:$P_Got_Time,1
		mov	bl, 1		; $P_colon_period
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_1st_Val, ax
		or	bl, bl
		jz	short $P_TimeF_Rlt
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_2nd_Val, ax
		or	bl, bl
		jz	short $P_TimeF_Rlt
		mov	bl, 2		; mov bl,$P_period_only
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_3rd_Val, ax
		or	bl, bl
		jnz	short $P_Time_4
		test	cs:$P_Flags, 2	; test psdata_seg:$P_Flags1,$P_Time_Again
		jnz	short $P_TimeF_Rlt
		mov	si, cs:$P_SI_Save ; mov	si,psdata_seg:$P_SI_Save
		cmp	byte ptr [si-1], ',' ; cmp byte ptr [si-1],$P_Comma
		jnz	short $P_TimeF_Rlt
		mov	byte ptr [si-1], '.' ; mov byte ptr [si-1],$P_Period
		mov	word ptr cs:$P_Flags, 0
		or	cs:$P_Flags, 2	; or psdata_seg:$P_Flags1,$P_Time_Again
		mov	cx, cs:$P_ORIG_ORD
		mov	sp, cs:$P_ORIG_STACK
		mov	si, cs:$P_ORIG_SI
		jmp	$P_Redo_Time
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Time_4:				; ...
		call	$P_Get_DecNum

$P_TimeF_Err0:				; ...
		jb	short $P_TimeF_Error
		mov	cs:$P_4th_Val, ax
		or	bl, bl
		jnz	short $P_TimeF_Error

$P_TimeF_Rlt:				; ...
		mov	ax, cs:$P_1st_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		test	cs:$P_Flags, 1	; test psdata_seg:$P_Flags1,$P_Time12am
		jz	short $P_Time_notAM
		cmp	al, 12
		ja	short $P_TimeF_Error
		jnz	short $P_Time_notAM
		xor	al, al

$P_Time_notAM:				; ...
		test	cs:$P_Flags2, 4	; test psdata_seg:$P_Flags2,$P_Time12
		jz	short $P_TimeSkip00
		cmp	al, 12
		jz	short $P_TimeSkip00
		add	al, 12
		jb	short $P_TimeF_Error
		cmp	al, 24
		ja	short $P_TimeF_Error

$P_TimeSkip00:				; ...
		mov	dl, al
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	dh, al
		mov	ax, cs:$P_3rd_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	cl, al
		mov	ax, cs:$P_4th_Val ; mov	ax,psdata_seg:$P_4th_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	ch, al
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 8		; $P_Time_F
		call	$P_Fill_Result
		jmp	short $P_Time_Format_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_TimeF_Error:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		mov	cs:$P_RC, 9	; mov psdata_seg:$P_RC,$P_Syntax

$P_Time_Format_Exit:			; ...
		mov	cs:$P_Got_Time,	0 ; mov	psdata_seg:$P_Got_Time,0
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Time_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Time_2412	proc near		; ...
		push	ax
		push	si

$P_T12_Loop:				; ...
		mov	al, cs:[si]	; mov al,psdata_seg:[si]
		inc	si
		or	al, al
		jnz	short $P_T12_Loop
		mov	al, cs:[si-2]	; mov al,psdata_seg:[si-word]
		or	al, 20h		; or al,$P_Make_Lower
		cmp	al, 'p'
		jz	short $P_T1200
		cmp	al, 'a'
		jz	short $P_T1201
		cmp	al, 'm'
		jnz	short $P_T12_Exit
		dec	si
		mov	al, cs:[si-2]
		or	al, 20h
		cmp	al, 'p'
		jz	short $P_T1200
		cmp	al, 'a'
		jz	short $P_T1201
		jmp	short $P_T12_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_T1200:				; ...
		or	cs:$P_Flags2, 4	; or psdata_seg:$P_Flags2,$P_Time12
		jmp	short $P_Tclr_chr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_T1201:				; ...
		or	cs:$P_Flags, 1	; or psdata_seg:$P_Flags1,$P_Time12AM

$P_Tclr_chr:				; ...
		mov	byte ptr cs:[si-2], 0 ;	psdata_seg:[si-2],$P_NULL

$P_T12_Exit:				; ...
		pop	si
		pop	ax
		retn
$P_Time_2412	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_File_Format	proc near		; ...
		push	ax
		push	di
		push	si
		mov	di, cs:$P_SaveSI_Cmpx
		mov	al, cs:[si]
		or	al, al
		jz	short $P_FileF_Err
		call	$P_FileSp_Chk
		jnz	short $P_FileF03
		mov	cs:$P_err_flag,	1 ; $P_error_filespec
		pop	si
		mov	byte ptr cs:[si], 0 ; $P_NULL
		pop	di
		jmp	short $P_FileF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF_Err:				; ...
		pop	si
		mov	byte ptr cs:[si], 0
		pop	di
		test	word ptr es:[bx], 1 ; [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
		jnz	short $P_FileF02
		mov	cs:$P_RC, 2	; $P_Op_Missing
		jmp	short $P_FileF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF03:				; ...
		pop	ax
		push	si

$P_FileF_Loop1:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_FileF_RLT
		call	$P_FileSp_Chk
		jz	short $P_FileF00
		call	$P_Chk_DBCS
		jnb	short $P_FileF01
		inc	di
		inc	si

$P_FileF01:				; ...
		inc	di
		inc	si
		jmp	short $P_FileF_Loop1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF00:				; ...
		mov	cs:$P_Terminator, al
		mov	byte ptr cs:[si], 0
		inc	di
		mov	cs:$P_SI_Save, di

$P_FileF_RLT:				; ...
		pop	si
		pop	di

$P_FileF02:				; ...
		pop	ax
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Drv_Only_Exit
		push	ax
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 5		; $P_File_Spec
		call	$P_Fill_Result
		pop	ax

$P_Drv_Only_Exit:			; ...
		retn
$P_File_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_FileSp_Chk	proc near		; ...
		push	bx
		push	cx
		lea	bx, $P_FileSp_Char ; "[]|<>+=;\""
		mov	cx, 9		; $P_FileSp_Len

$P_FileSp_Loop:				; ...
		cmp	al, cs:[bx]
		jz	short $P_FileSp_Exit
		inc	bx
		loop	$P_FileSp_Loop
		inc	cx

$P_FileSp_Exit:				; ...
		pop	cx
		pop	bx
		retn
$P_FileSp_Chk	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Drive_Format	proc near		; ...
		push	ax
		push	dx
		mov	al, cs:[si]
		or	al, al
		jz	short $P_Drv_Exit
		call	$P_Chk_DBCS
		jb	short $P_Drv_Err
		cmp	word ptr cs:[si+1], 3Ah	; ':' ; $P_Colon
		jz	short $P_DrvF00
		test	word ptr es:[bx], 10h ;	$P_Ig_Colon
		jz	short $P_Drv_Err
		cmp	byte ptr cs:[si+1], 0
		jnz	short $P_Drv_Err

$P_DrvF00:				; ...
		or	al, 20h		; $P_Make_Lower
		cmp	al, 61h	; 'a'
		jb	short $P_Drv_Err
		cmp	al, 7Ah	; 'z'
		ja	short $P_Drv_Err
		sub	al, 60h	; '`'
		mov	dl, al
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 6		; $P_Drive
		call	$P_Fill_Result
		jmp	short $P_Drv_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Drv_Err:				; ...
		mov	cs:$P_RC, 9	; $P_Syntax

$P_Drv_Exit:				; ...
		pop	dx
		pop	ax
		retn
$P_Drive_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Skip_Delim	proc near		; ...
		lodsb
		call	$P_Chk_EOL
		jz	short $P_Skip_Delim_CY
		call	$P_Chk_Delim
		jnz	short $P_Skip_Delim_NCY
		test	cs:$P_Flags2, 20h ; $P_Extra
		jz	short $P_Skip_Delim
		test	cs:$P_Flags2, 41h
		jz	short $P_Exit_At_Extra
		dec	si
		jmp	short $P_Exit_At_Extra
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Skip_Delim_CY:			; ...
		stc
		jmp	short $P_Skip_Delim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Skip_Delim_NCY:			; ...
		clc

$P_Skip_Delim_Exit:			; ...
		dec	si
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Exit_At_Extra:			; ...
		clc
		retn
$P_Skip_Delim	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_EOL	proc near		; ...
		push	bx
		push	cx
		cmp	al, 0Dh		; $P_CR
		jz	short $P_Chk_EOL_Exit
		cmp	al, 0		; $P_NULL
		jz	short $P_Chk_EOL_Exit
		cmp	byte ptr es:[di+2], 2 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
		jb	short $P_Chk_EOL_Exit
		xor	bx, bx
		mov	bl, es:[di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		add	bx, 4		; $P_Len_PARMS
		cmp	byte ptr es:[bx+di], 0 ; $P_I_Use_Default
		jz	short $P_Chk_EOL_NZ
		xor	cx, cx
		mov	cl, es:[bx+di]

$P_Chk_EOL_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short $P_Chk_EOL_Exit
		loop	$P_Chk_EOL_Loop

$P_Chk_EOL_NZ:				; ...
		cmp	al, 0Dh

$P_Chk_EOL_Exit:			; ...
		pop	cx
		pop	bx
		retn
$P_Chk_EOL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Delim	proc near		; ...
		push	bx
		push	cx
		mov	cs:$P_Terminator, 20h ;	' ' ; $P_Space
		and	cs:$P_Flags2, 0DFh ; 0FFh-$P_Extra
		cmp	al, 20h	; ' '   ; $P_Space
		jz	short $P_Chk_Delim_Exit
		cmp	al, 9		; $P_TAB
		jz	short $P_Chk_Delim_Exit
		cmp	al, 2Ch	; ','   ; $P_Comma
		jz	short $P_Chk_Delim_Exit0
		cmp	al, 20h	; ' '   ; $P_DBSP1
		jnz	short $P_Chk_Delim01
		cmp	byte ptr [si], 20h ; ' ' ; $P_DBSP2
		jnz	short $P_Chk_Delim01
		mov	al, 20h	; ' '
		inc	si
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_Delim01:				; ...
		cmp	byte ptr es:[di+2], 1 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
		jb	short $P_Chk_Delim_Exit
		xor	cx, cx
		mov	cl, es:[di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		or	cx, cx
		jz	short $P_Chk_Delim_NZ
		mov	bx, 3		; $P_Len_PARMS-1

$P_Chk_Delim_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short $P_Chk_Delim_Exit0
		loop	$P_Chk_Delim_Loop

$P_Chk_Delim_NZ:			; ...
		cmp	al, 20h	; ' '   ; $P_Space

$P_Chk_Delim_Exit:			; ...
		pop	cx
		pop	bx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_Delim_Exit0:			; ...
		mov	cs:$P_Terminator, al
		test	cs:$P_Flags2, 1	; $P_equ
		jnz	short $P_No_Set_Extra
		or	cs:$P_Flags2, 20h ; $P_Extra

$P_No_Set_Extra:			; ...
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
$P_Chk_Delim	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Switch	proc near		; ...
		lea	bp, $P_STRING_BUF
		cmp	bx, bp
		jz	short $P_STRUC_L2
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L5
		stc
		push	ax
		mov	al, cs:[bx-1]
		call	$P_0099
		jb	short $P_STRUC_L7
		mov	al, [si]
		call	$P_0099

$P_STRUC_L7:				; ...
		pop	ax
		jmp	short $P_STRUC_L1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_STRUC_L5:				; ...
		clc
		jmp	short $P_STRUC_L1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_STRUC_L2:				; ...
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L12
		or	cs:$P_Flags2, 40h ; $P_SW

$P_STRUC_L12:				; ...
		clc

$P_STRUC_L1:				; ...
		retn
$P_Chk_Switch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_DBCS	proc near		; ...
		push	ds
		push	si
		push	bx
		cmp	cs:$P_DBCSEV_SEG, 0 ; cmp psdata_seg:$P_DBCSEV_SEG
		jnz	short $P_DBCS00
		push	ax
		push	ds
		push	cx
		push	dx
		push	di
		push	bp
		push	es
		xor	si, si
		mov	ds, si
		assume ds:RESGROUP
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		or	bx, bx
		pop	es
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short $P_NON_DBCS
		mov	cs:$P_DBCSEV_OFF, si
		mov	cs:$P_DBCSEV_SEG, bx ; psdata_seg:$P_DBCSEV_SEG,bx

$P_DBCS00:				; ...
		mov	si, cs:$P_DBCSEV_OFF ; psdata_seg:$P_DBCSEV_OFF
		mov	ds, cs:$P_DBCSEV_SEG

$P_DBCS_LOOP:				; ...
		cmp	word ptr [si], 0
		jz	short $P_NON_DBCS
		cmp	al, [si]
		jb	short $P_DBCS01
		cmp	al, [si+1]
		ja	short $P_DBCS01
		stc
		jmp	short $P_DBCS_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DBCS01:				; ...
		inc	si
		inc	si
		jmp	short $P_DBCS_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_NON_DBCS:				; ...
		clc

$P_DBCS_EXIT:				; ...
		pop	bx
		pop	si
		pop	ds
		retn
$P_Chk_DBCS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cmd_parse	proc near		; ...
		call	sysparse
		retn
cmd_parse	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


append_parse	proc far		; ...
		call	sysparse
		retf
append_parse	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Printf_Init:				; ...
		call	std_printf
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Printf_Crlf	proc near		; ...
		call	std_printf
		call	CRLF2
		retn
Printf_Crlf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


std_eprintf	proc near		; ...
		mov	ds:PRINTF_HANDLE, 2
		jmp	short new_printf
std_eprintf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


std_printf	proc near		; ...
		mov	ds:PRINTF_HANDLE, 1

new_printf:				; ...
		push	ax
		push	bx
		push	cx
		push	es
		push	ds
		pop	es
		push	di
		push	si
		push	dx
		mov	ds:print_err_flag, 0 ; mov word	[print_err_flag],0
		mov	si, dx
		lodsw
		push	ax
		lodsb
		mov	cl, al
		xor	ch, ch
		pop	ax
		cmp	cx, 0
		jz	short ready_to_print
		mov	di, offset subst_buffer
		push	di
		push	cx

move_subst:				; ...
		push	cx
		mov	bx, si
		mov	cx, 11		; parm_block_size
		rep movsb
		test	byte ptr [bx+7], 4 ; [bx.$M_S_FLAG],date_type
		jz	short move_subst_cont
		mov	word ptr [bx+2], 0 ; [bx.$M_S_VALUE],0
		mov	word ptr [bx+4], 0 ; [bx.$M_S_VALUE+2],0

move_subst_cont:			; ...
		pop	cx
		loop	move_subst
		pop	cx		; (number of substitutions)
		push	ax		; (Message Number)
		cmp	ds:msg_disp_class, 0FFh	; Util_Msg_Class
		jz	short check_fix
		mov	ds:msg_flag, 1	; ext_msg_class
		mov	di, offset extend_buf_ptr
		xor	ax, ax
		stosw
		stosb

check_fix:				; ...
		pop	ax		; (Message Number)
		pop	di		; (subst_buffer)
		mov	si, di
		mov	bx, si
		push	cx

set_subst:				; ...
		cmp	word ptr [bx+4], 0 ; [bx.$M_S_VALUE+2],0
		jnz	short subst_seg_set
		test	byte ptr [bx+7], 4 ; [bx.$M_S_FLAG],date_type
		jnz	short subst_seg_set
		mov	word ptr [bx+4], cs ; [bx.$M_S_VALUE+2],cs

subst_seg_set:				; ...
		add	bx, 11		; parm_block_size
		loop	set_subst
		pop	cx
		mov	bx, si
		cmp	word ptr [bx+2], offset	string_ptr_2 ;
					; [bx.$M_S_VALUE],offset trangroup:string_ptr_2
		jnz	short ready_to_print
		mov	dx, ds:string_ptr_2
		mov	[bx+2],	dx	; [bx.$M_S_VALUE],dx

ready_to_print:				; ...
		mov	bx, ds:PRINTF_HANDLE
		mov	dl, ds:msg_cont_flag
		mov	dh, ds:msg_disp_class
		mov	ds:msg_cont_flag, 0 ; no_cont_flag
		mov	ds:msg_disp_class, 0FFh	; Util_Msg_Class
		push	ds
		push	es
		call	SYSDISPMSG
		pop	es
		pop	ds
		jnb	short print_success
		mov	ds:print_err_flag, ax

print_success:				; ...
		pop	dx
		pop	si
		pop	di
		pop	es
		pop	cx
		pop	bx
		pop	ax
		cmp	ds:print_err_flag, 0 ; cmp word	[print_err_flag],0
		jnz	short print_err
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

print_err:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		cmp	ds:PRINTF_HANDLE, 2
		jnz	short not_stderr
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_stderr:				; ...
		mov	ax, ds:print_err_flag
		mov	es, ds:RESSEG
		assume es:nothing
		test	es:PipeFlag, 0FFh ; -1
		jz	short _go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR
		jmp	short print_err_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_go_to_error:				; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax

print_err_exit:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	cerror
std_printf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TSYSLOADMSG	proc near		; ...
		push	bx
		call	SYSLOADMSG
		pop	bx
		retn
TSYSLOADMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TSYSGETMSG	proc near		; ...
		push	cx
		call	SYSGETMSG
		pop	cx
		retn
TSYSGETMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSLOADMSG	proc near		; ...
		push	ax
		push	bx
		push	dx
		push	es
		push	di
		xor	cx, cx
		mov	es, cx
		assume es:RESGROUP
		xor	di, di
		mov	ax, 122Eh	; DOS_GET_EXT_PARSE_ADD
		mov	dl, 0		; DOS_GET_EXTENDED
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
					; Return: ES:DI	-> error table
		mov	ds:$M_RT_$M_EXT_COMMAND+2, es ;	[$M_RT+10]
		mov	ds:$M_RT_$M_EXT_COMMAND, di ; [$M_RT+8]
		mov	ax, 122Eh
		mov	dl, 2		; DOS_GET_PARSE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get parameter error table (errors 00h-0Ah)
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_PARSE_COMMAND+2, es	; [$M_RT+18]
		mov	ds:$M_RT_$M_PARSE_COMMAND, di ;	[$M_RT+16]
		mov	ax, 122Eh
		mov	dl, 4		; DOS_GET_CRITICAL
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get critical/SHARE	error table (errors 13h-2Bh)
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_CRIT_COMMAND+2, es ; [$M_RT+34]
		mov	ds:$M_RT_$M_CRIT_COMMAND, di ; [$M_RT+32]
		mov	ax, 122Eh
		mov	dl, 6		; DOS_GET_FILE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_EXT_FILE+2,	es ; [$M_RT+6]
		mov	ds:$M_RT_$M_EXT_FILE, di ; [$M_RT+4]
		call	$M_MSGSERV_1
		mov	ds:$M_RT_$M_EXT_ERR_ADDRS+2, es	; [$M_RT+2]
		mov	ds:$M_RT_$M_EXT_ERR_ADDRS, di ;	[$M_RT+0]
		mov	ds:$M_RT_$M_CRIT_ADDRS+2, es ; [$M_RT+30]
		mov	ds:$M_RT_$M_CRIT_ADDRS,	di ; [$M_RT+28]
		call	$M_MSGSERV_2
		mov	ds:$M_RT_$M_PARSE_ADDRS+2, es ;	[$M_RT+22]
		mov	ds:$M_RT_$M_PARSE_ADDRS, di ; [$M_RT+20]
		mov	ax, 122Eh	; DOS_GET_EXT_PARSE_ADD
		mov	dl, 8		; DOS_GET_ADDR
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; Return: ES:DI	-> error table
		mov	word ptr ds:$M_RT_$M_DISK_PROC_ADDR+2, es ; [$M_RT+42]
		mov	word ptr ds:$M_RT_$M_DISK_PROC_ADDR, di	; [$M_RT+40]
		mov	ds:$M_RT_$M_CRLF, 0A0Dh	; CRLF
		mov	ds:$M_RT_$M_BUF_TERM, '$'
		mov	ds:$M_RT_$M_MSG_NUM, 0 ; $M_NULL
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_BASE10
		call	$M_CLS_3	; Get addressibilty to class F
		mov	ds:$M_RT_$M_CLASS_ADDRS, di ; $M_RT.$M_CLASS_ADDRS+$M_INDEX ; $M_INDEX = 0
					; [$M_RT+44]
		call	$M_GET_DBCS_VEC
		clc
		jb	short $MIF20
		pop	di
		pop	es
		assume es:nothing
		pop	dx
		pop	bx
		pop	ax
		jmp	short $MEN20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF20:					; ...
		add	sp, 10
		stc

$MEN20:					; ...
		retn
SYSLOADMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_DBCS_VEC	proc near		; ...
		push	ax
		push	si
		push	ds
		mov	ax, 6300h	; DOS_GET_DBCS_INFO
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		push	ds
		pop	es
		pop	ds
		jb	short $MIF23
		mov	word ptr ds:$M_RT_$M_DBCS_VEC, si ; $M_RT.$M_DBCS_VEC
					; [$M_RT+60]
		mov	word ptr ds:$M_RT_$M_DBCS_VEC+2, es ; [$M_RT+62]

$MIF23:					; ...
		pop	si
		pop	ax
		retn
$M_GET_DBCS_VEC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSGETMSG	proc near		; ...
		push	ax
		push	es
		push	di
		push	bp
		call	$M_GET_MSG_ADDRESS
		jb	short $MIF31
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		clc
		jz	short $MIF32
		push	es
		pop	ds
		jmp	short $MEN32
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF32:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP

$MEN32:					; ...
		mov	si, di

$MIF31:					; ...
		pop	bp
		pop	di
		pop	es
		pop	ax
		retn
SYSGETMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_MSG_ADDRESS proc	near		; ...

; FUNCTION CHUNK AT 5278 SIZE 00000007 BYTES

		push	si
		push	bx
		xor	si, si
		xor	cx, cx

$MDO36:					; ...
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jnz	short $MIF37
		mov	di, $M_RT_$M_CLASS_ADDRS[si] ;
					; DWORD	PTR $M_RT.$M_CLASS_ADDRS[SI]
		mov	bx, di
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF37:					; ...
		test	dh, 2		; PARSE_ERR_CLASS
		jz	short $MIF39
		les	di, dword ptr $M_RT_$M_PARSE_COMMAND[si] ;
					; DWORD	PTR $M_RT.$M_PARSE_COMMAND[SI]
		mov	bx, es
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF39:					; ...
		cmp	ax, 19		; $M_CRIT_LO
		jb	short $MIF41
		cmp	ax, 39		; $M_CRIT_HI
		ja	short $MIF41
		les	di, dword ptr $M_RT_$M_CRIT_ADDRS[si] ;
					; DWORD	PTR $M_RT.$M_CRIT_ADDRS[SI]
		mov	bx, es
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF41:					; ...
		les	di, dword ptr $M_RT_$M_EXT_ERR_ADDRS[si] ;
					; DWORD	PTR $M_RT.$M_EXT_ERR_ADDRS[SI]
		mov	bx, es

$MEN37:					; ...
		cmp	bx, 0FFFFh	; $M_TERMINATING_FLAG
		jnz	short $MIF46
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jnz	short $MIF47
		stc
		jmp	short $MEN47
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF47:					; ...
		mov	$M_RT_$M_MSG_NUM, ax ; $M_RT.$M_MSG_NUM
					; [$M_RT+72]
		mov	ax, 0FFFFh	; $M_SPECIAL_MSG_NUM
		mov	bp, 1		; $M_ONE_REPLACE
		xor	si, si
		clc

$MEN47:					; ...
		jmp	short $MEN46
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF46:					; ...
		cmp	bx, 0		; $M_CLASS_NOT_EXIST
		jz	short $MIF51
		call	$M_FIND_SPECIFIED_MSG

$MIF51:					; ...
		add	si, 4		; $M_ADDR_SZ_FAR
		clc

$MEN46:					; ...
		jb	short $MEN36
		or	cx, cx
		jnz	short $MEN36
		jmp	short $MDO36
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN36:					; ...
		pushf
		cmp	dh, 1		; EXT_ERR_CLASS
		jnz	short $MIF56
		push	dx
		push	bp
		push	cx
		push	es
		push	di
		push	ax
		mov	ax, 500h	; IFSFUNC_INSTALL_CHECK
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh	; IFSFUNC_INSTALLED
		pop	ax
		jnz	short $MIF57
		mov	bx, ax
		mov	ax, 502h	; IFS_GET_ERR_TEXT
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		jmp	short $MEN57
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF57:					; ...
		stc

$MEN57:					; ...
		jnb	short $MIF60
		pop	di
		pop	es
		pop	cx
		jmp	short $MEN60
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF60:					; ...
		add	sp, 6
		call	$M_SET_LEN_IN_CX

$MEN60:					; ...
		pop	bp
		pop	dx

$MIF56:					; ...
		jmp	short $M_POPF
$M_GET_MSG_ADDRESS endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

m_popf_iret:				; ...
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR $M_GET_MSG_ADDRESS

$M_POPF:				; ...
		push	cs		; $M_POPF (macro)
		call	m_popf_iret
		pop	bx
		pop	si
		retn
; END OF FUNCTION CHUNK	FOR $M_GET_MSG_ADDRESS

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_SET_LEN_IN_CX proc near		; ...
		push	di
		push	ax
		mov	cx, 0FFFFh	; -1 ; 65535
		xor	al, al
		repne scasb
		not	cx
		dec	cx
		pop	ax
		pop	di
		retn
$M_SET_LEN_IN_CX endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_FIND_SPECIFIED_MSG proc near		; ...
		cmp	bx, 1
		jnz	short $MIF64
		cmp	word ptr $M_RT_$M_DISK_PROC_ADDR, 0FFFFh ; [$M_RT+40],-1
		jz	short $MIF64
		cmp	ax, 0FFFFh
		jnz	short $MIF65
		push	ax
		mov	ax, $M_RT_$M_MSG_NUM ; $M_RT.$M_MSG_NUM
					; [$M_RT+72]
		call	$M_RT_$M_DISK_PROC_ADDR	; DWORD	PTR $M_RT.$M_DISK_PROC_ADDR
		pop	ax
		jmp	short $MEN65
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF65:					; ...
		call	$M_RT_$M_DISK_PROC_ADDR

$MEN65:					; ...
		jmp	short $MEN64
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF64:					; ...
		xor	cx, cx
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF69
		mov	cl, es:[di+3]	; BYTE PTR ES:[DI].$M_NUM_CLS_MSG
		jmp	short $MEN69
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF69:					; ...
		cmp	cs:[di], dh	; BYTE PTR CS:[DI].$M_CLASS_ID,DH
		jnz	short $MEN69
		mov	cl, cs:[di+3]	; BYTE PTR CS:[DI].$M_NUM_CLS_MSG

$MEN69:					; ...
		add	di, 4		; $M_CLASS_ID_SZ
		stc

$MEN64:					; ...
		jnb	short $MIF75
		clc

$MDO76:					; ...
		or	cx, cx
		jz	short $MEN76
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF78
		cmp	ax, es:[di]	; WORD PTR ES:[DI].$M_NUM
		jmp	short $MEN78
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF78:					; ...
		cmp	ax, cs:[di]	; WORD PTR CS:[DI].$M_NUM

$MEN78:					; ...
		jnz	short $MIF76
		jmp	short $MSR76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF76:					; ...
		dec	cx
		jz	short $MEN76
		add	di, 4		; $M_ID_SZ
		jmp	short $MDO76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN76:					; ...
		stc

$MSR76:					; ...
		jb	short $MIF75
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		clc
		jnz	short $MIF87
		push	cs
		pop	es
		assume es:TRANGROUP

$MIF87:					; ...
		add	di, es:[di+2]	; WORD PTR ES:[DI].$M_TXT_PTR

$MIF75:					; ...
		jb	short $MIF91
		xor	ch, ch
		mov	cl, es:[di]
		inc	di

$MIF91:					; ...
		mov	$M_RT_$M_SIZE, 0 ; $M_RT.$M_SIZE,$M_NULL
					; [$M_RT+66]
		retn
$M_FIND_SPECIFIED_MSG endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSDISPMSG	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	bp
		push	di
		push	es
		push	dx
		mov	bp, cx
		mov	$M_RT_$M_HANDLE, bx ; [$M_RT+$M_RES_ADDRS.$M_HANDLE]
					; [$M_RT+64],bx
		mov	$M_RT_$M_CLASS,	dh ; [$M_RT+$M_RES_ADDRS.$M_CLASS]
					; [$M_RT+69],dh
		call	$M_GET_MSG_ADDRESS
		or	cx, cx		; (message length)
		jz	short $MIF93
		or	bp, bp
		jnz	short $MIF94
		call	$M_DISPLAY_STRING ; (es:di = message/text address)
		jmp	short $MEN94
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF94:					; ...
		call	$M_DISPLAY_MESSAGE

$MEN94:					; ...
		jb	short $MIF97
		pop	dx
		call	$M_ADD_CRLF
		pop	es
		assume es:nothing
		pop	di
		jmp	short $MEN97
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF97:					; ...
		add	sp, 6
		stc

$MEN97:					; ...
		jmp	short $MEN93
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF93:					; ...
		pop	es		; (wrong pops ?)
					; correct order: pop dx, pop es, pop di
		pop	di
		pop	dx
		stc

$MEN93:					; ...
		jb	short $MIF104
		pop	bp
		pop	cx
		pop	bx
		pop	ax
		jmp	short $MEN104
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF104:				; ...
		add	sp, 8
		stc

$MEN104:				; ...
		retn
SYSDISPMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_STRING proc near		; ...
		push	ax
		push	bx
		push	dx
		mov	bx, $M_RT_$M_HANDLE ; $M_RT.$M_HANDLE
					; [$M_RT+64]
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jnz	short $MIF107
		call	$M_DISPLAY_$_STRING
		jmp	short $MEN107
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF107:				; ...
		call	$M_DISPLAY_H_STRING

$MEN107:				; ...
		jnb	short $MIF110
		mov	ah, 59h		; DOS_GET_EXT_ERROR
		mov	bx, 0
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		xor	ah, ah
		add	sp, 6
		stc
		jmp	short $MEN110
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF110:				; ...
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jz	short $MEN110
		cmp	ax, cx
		jz	short $MEN110
		call	$M_GET_EXT_ERR_39
		add	sp, 6
		stc

$MEN110:				; ...
		jb	short $MIF117
		pop	dx
		pop	bx
		pop	ax

$MIF117:				; ...
		retn
$M_DISPLAY_STRING endp ; sp =  6


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_$_STRING proc near		; ...
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF119
		mov	ah, 2		; DOS_DISP_CHAR
		mov	dl, es:[di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ds
		mov	al, dl
		call	$M_IS_IT_DBCS
		push	ds
		push	es
		pop	ds
		jnb	short $MIF120
		mov	dl, es:[di+1]
		int	21h		; DOS -
		clc

$MIF120:				; ...
		jmp	short $MEN119
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF119:				; ...
		mov	ah, 2		; DOS_DISP_CHAR

$MDO123:				; ...
		or	cx, cx
		jz	short $MEN119
		mov	dl, es:[di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	di
		dec	cx
		jnz	short $MDO123

$MEN119:				; ...
		clc
		pop	ds
		retn
$M_DISPLAY_$_STRING endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scan_ctrlz	proc near		; ...
		push	di
		push	ax
		push	es
		push	bx
		mov	di, dx
		push	ds
		pop	es
		mov	bx, cx
		mov	al, 1Ah		; Ctrl-Z
		cld
		repne scasb
		jnz	short noCtrlz
		sub	bx, cx
		dec	bx

noCtrlz:				; ...
		mov	cx, bx
		pop	bx
		pop	es
		pop	ax
		pop	di
		retn
scan_ctrlz	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_H_STRING proc near		; ...
		xor	ax, ax
		or	cx, cx
		jz	short $MIF127
		push	ds
		push	es
		pop	ds
		mov	ah, 40h
		mov	dx, di
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF128
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		push	ax
		mov	al, es:[di]
		call	$M_IS_IT_DBCS
		pop	ax
		push	ds
		push	es
		pop	ds
		jnb	short $MIF129
		clc
		mov	ah, 40h
		inc	dx
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

$MIF129:				; ...
		pushf
		cmp	byte ptr es:[di], 1Ah ;	Ctrl-Z?
		jnz	short m_popf_j	; @@:
		mov	ax, cx

m_popf_j:				; ...
		jmp	short m_popf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intret:					; ...
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

m_popf:					; ...
		push	cs		; $M_Popf (macro)
		call	intret
		jmp	short $MEN128
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF128:				; ...
		push	bp
		push	cx
		call	scan_ctrlz
		mov	bp, cx
		pop	cx
		int	21h		; DOS -
		jnb	short chk_count
		jmp	short m_cnt_ok
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chk_count:				; ...
		cmp	cx, ax
		jz	short m_cnt_ok
		cmp	bp, ax
		clc
		jnz	short m_cnt_ok
		mov	ax, cx

m_cnt_ok:				; ...
		pop	bp

$MEN128:				; ...
		pop	ds

$MIF127:				; ...
		retn
$M_DISPLAY_H_STRING endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_EXT_ERR_39 proc near		; ...
		mov	ax, 27h		; EXT_ERR_39
		mov	bx, 4		; (ERROR_CLASS_39 SHR 8) + ACTION_39
		mov	ch, 1		; LOCUS_39
		retn
$M_GET_EXT_ERR_39 endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_ADD_CRLF	proc near		; ...
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF134
		test	dh, 80h		; $M_NO_CRLF_MASK
		jnz	short $MIF134
		push	ds
		pop	es
		lea	di, $M_RT_$M_CRLF ; $M_RT.$M_CRLF
					; [$M_RT+67]
		mov	cx, 2		; $M_CRLF_SIZE
		call	$M_DISPLAY_STRING

$MIF134:				; ...
		retn
$M_ADD_CRLF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_IS_IT_DBCS	proc near		; ...
		push	es
		push	di
		les	di, ds:$M_RT_$M_DBCS_VEC ; $M_RT.$M_DBCS_VEC
					; [$M_RT+60]
		or	di, di
		jz	short $MIF138

$MDO139:				; ...
		cmp	word ptr es:[di], 0 ; $M_DBCS_TERM
		clc
		jz	short $MIF138
		cmp	al, es:[di]
		jb	short $MIF141
		cmp	al, es:[di+1]
		ja	short $MIF141
		stc

$MIF141:				; ...
		inc	di
		inc	di
		jmp	short $MDO139
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF138:				; ...
		pop	di
		pop	es
		retn
$M_IS_IT_DBCS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERT2ASC	proc near		; ...
		pop	ds:$M_RT_$M_RETURN_ADDR	; pop word [$M_RT+70]
		xor	bx, bx
		xchg	ax, bx
		xchg	ax, dx

$MDO145:				; ...
		div	ds:$M_RT_$M_DIVISOR ; div word [$M_RT+74]
		xchg	ax, bx
		div	ds:$M_RT_$M_DIVISOR ; [$M_RT+74]
		cmp	dx, 9
		jbe	short $MIF146
		add	dl, 55		; add dl,37h
		jmp	short $MEN146
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF146:				; ...
		add	dl, '0'

$MEN146:				; ...
		push	dx
		inc	cx
		or	ax, ax
		jnz	short $MLL149
		or	bx, bx
		jz	short $MEN145

$MLL149:				; ...
		cmp	cx, 3		; $M_FIRST_THOU
		jnz	short $MIF150
		cmp	byte ptr [si+0Ah], ',' ;
					; $M_SL.$M_S_PAD,$M_COMMA ($M_SL = [DS:SI])
		jnz	short $MIF151
		push	ds:$M_RT_$M_THOU_SEPARA	; word $M_RT.$M_THOU_SEPARA
		inc	cx

$MIF151:				; ...
		jmp	short $MEN154
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF150:				; ...
		cmp	cx, 6		; $M_SECOND_THOU
		jnz	short $MIF154
		cmp	byte ptr [si+0Ah], ',' ; $M_SL.$M_S_PAD,$M_COMMA
		jnz	short $MIF155
		push	ds:$M_RT_$M_THOU_SEPARA	; [$M_RT+83]
		inc	cx

$MIF155:				; ...
		jmp	short $MEN154
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF154:				; ...
		cmp	cx, 9		; $M_THIRD_THOU
		jnz	short $MEN154
		cmp	byte ptr [si+0Ah], ',' ; $M_SL.$M_S_PAD,$M_COMMA
		jnz	short $MEN154
		push	ds:$M_RT_$M_THOU_SEPARA	; [$M_RT+83]
		inc	cx

$MEN154:				; ...
		xchg	ax, bx
		xor	dx, dx
		jmp	short $MDO145
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN145:				; ...
		xor	dx, dx
		xor	ax, ax
		push	ds:$M_RT_$M_RETURN_ADDR	; [$M_RT+70]
		retn
$M_CONVERT2ASC	endp ; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_MESSAGE proc	near		; ...
		xor	dx, dx		; $MDO165
		or	cx, cx		; (byte	count of the message/text)
		jz	short $MIF166
		mov	ah, '%'
		mov	al, 0

$MDO167:				; ...
		cmp	es:[di], ah
		jnz	short $MLL168
		cmp	es:[di+1], ah
		jz	short $MLL168
		cmp	al, ah
		jnz	short $MIF166

$MLL168:				; ...
		mov	al, es:[di]
		call	$M_IS_IT_DBCS
		jnb	short $MIF169
		inc	di

$MIF169:				; ...
		inc	di
		inc	dx
		dec	cx
		jnz	short $MDO167

$MIF166:				; ...
		push	si
		xchg	cx, dx
		or	bp, bp
		jz	short $MIF173
		dec	bp
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NULL
					; [$M_RT+72]],0
		jnz	short $MIF173

$MDO175:				; ...
		mov	al, [si+6]	; $M_SL.$M_S_ID
		add	al, 30h
		cmp	al, es:[di+1]
		jnz	short $MIF175
		jmp	short $MIF173
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF175:				; ...
		cmp	al, 30h		; $M_SPECIAL_CASE
		jnz	short $MLL178
		or	dx, dx
		jz	short $MEN175

$MLL178:				; ...
		add	si, [si]	; add si,[si+$M_SUBLIST_STRUC.$M_S_SIZE]
					; add si,[si+0]
		jmp	short $MDO175
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN175:				; ...
		cmp	ds:$M_RT_$M_CLASS, 0FFh	; $M_RT.$M_CLASS,UTILITY_MSG_CLASS
					; cmp byte [$M_RT+69],0FFh
		jnz	short $MIF180
		inc	dx
		inc	dx
		dec	cx
		dec	cx
		dec	di
		dec	di
		jmp	short $MIF173
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF180:				; ...
		mov	dx, -1		; 0FFFFh

$MIF173:				; ...
		push	di
		sub	di, cx
		call	$M_DISPLAY_STRING
		pop	di
		pop	cx
		jnb	short $MXL3
		jmp	$MEN165
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MXL3:					; ...
		push	cx
		mov	cx, dx
		cmp	byte ptr [si+6], 0 ; $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
		jz	short $MIF187
		or	cx, cx
		jz	short $MIF188
		dec	cx
		dec	cx
		inc	di
		inc	di
		jmp	short $MEN188
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF188:				; ...
		pop	si

$MEN188:				; ...
		jmp	short $MEN187
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF187:				; ...
		or	cx, cx
		jnz	short $MIF192
		pop	si
		jmp	short $MEN187
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF192:				; ...
		cmp	cx, -1
		jnz	short $MIF194
		xor	cx, cx

$MIF194:				; ...
		or	di, di

$MEN187:				; ...
		jz	short $MEN165
		push	bp
		push	di
		push	es
		push	cx
		xor	cx, cx
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NULL
					; [$M_RT+72],0
		jnz	short $MIF199
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF200
		les	di, [si+2]	; $M_SL.$M_S_VALUE
		call	$M_CHAR_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF200:				; ...
		test	byte ptr [si+7], 0Dh ;
					; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
		jz	short $MLL202
		test	byte ptr [si+7], 0Eh ;
					; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jz	short $MLL202
		test	byte ptr [si+7], 0Ch ;
					; $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK
		jnz	short $MIF202

$MLL202:				; ...
		les	di, [si+2]
		call	$M_BIN2ASC_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF202:				; ...
		test	byte ptr [si+7], 0Bh ; $M_SL.$M_S_FLAG,NOT Date_Type AND $M_TYPE_MASK
					; ($M_SL = [ds:si])
		jnz	short $MIF204
		call	$M_DATE_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF204:				; ...
		call	$M_TIME_REPLACE

$MEN200:				; ...
		call	$M_DISPLAY_REPLACE
		jmp	short $MEN199
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF199:				; ...
		call	$M_EXT_PAR_REPLACE

$MEN199:				; ...
		jb	short $MIF211
		pop	cx
		pop	es
		pop	di
		pop	bp
		pop	si
		jmp	short $MEN211
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF211:				; ...
		add	sp, 10
		stc

$MEN211:				; ...
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NUL
					; cmp word [$M_RT+72],0
		jnz	short $MEN165
		jb	short $MEN165
		jmp	$M_DISPLAY_MESSAGE ; jmp $MDO165
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN165:				; ...
		mov	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,0
					; mov word [$M_RT+72],0
		retn
$M_DISPLAY_MESSAGE endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_EXT_PAR_REPLACE proc	near		; ...
		xor	dx, dx
		mov	ax, ds:$M_RT_$M_MSG_NUM	; $M_RT.$M_MSG_NUM
					; mov ax,[$M_RT+72]
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; [$M_RT+74],10
		call	$M_CONVERT2ASC

$MDO215:				; ...
		pop	ax
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al ;	[bx+$M_RT+76]
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF216
		call	$M_FLUSH_BUF

$MIF216:				; ...
		dec	cl
		jnz	short $MDO215
		mov	ax, 0A0Dh	; $M_CR_LF
		mov	ds:$M_RT_$M_TEMP_BUF[bx], ax ; $M_RT.$M_TEMP_BUF[BX],AX
		inc	bx
		inc	bx
		call	$M_FLUSH_BUF
		retn
$M_EXT_PAR_REPLACE endp	; sp =	2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_REPLACE proc	near		; ...
		xor	bx, bx
		cmp	byte ptr [si+6], 0 ; $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
		jnz	short $MIF276
		mov	ds:$M_RT_$M_TEMP_BUF[bx], 2D20h	;
					; $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP
		inc	bx
		inc	bx
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], 20h ;
					; $M_RT.$M_TEMP_BUF[BX],$M_SPACE
		inc	bx
		call	$M_FLUSH_BUF

$MIF276:				; ...
		pop	bp
		xor	bx, bx
		xor	dx, dx
		mov	ds:$M_RT_$M_SIZE, cl ; $M_RT.$M_SIZE
					; mov [$M_RT+66],cl
		mov	al, [si+9]	; $M_SL.$M_S_MINW
		cmp	al, cl
		jbe	short $MIF278
		sub	al, cl
		mov	dh, al
		test	byte ptr [si+7], 80h ; BYTE PTR	$M_SL.$M_S_FLAG,Right_Align
		jz	short $MIF278

$MDO280:				; ...
		mov	al, [si+0Ah]	;  $M_SL.$M_S_PAD
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF281
		call	$M_FLUSH_BUF

$MIF281:				; ...
		dec	dh
		jnz	short $MDO280

$MIF278:				; ...
		cmp	byte ptr [si+8], 0 ; $M_SL.$M_S_MAXW,$M_UNLIM_W
		jz	short $MIF286
		cmp	[si+8],	cl	; $M_SL.$M_S_MAXW
		jnb	short $MIF286
		sub	cl, [si+8]
		mov	dl, cl
		mov	cl, [si+8]

$MIF286:				; ...
		or	cx, cx
		jz	short $MIF290

$MDO291:				; ...
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF292
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND	$M_SIZE_MASK
		jz	short $MIF292
		mov	al, es:[di]
		inc	di
		jmp	short $MEN292
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF292:				; ...
		pop	ax

$MEN292:				; ...
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al ;
					; MOV BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL
					; mov [bx+$M_RT+76],al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF295
		call	$M_FLUSH_BUF

$MIF295:				; ...
		dec	cl
		jnz	short $MDO291

$MIF290:				; ...
		test	byte ptr [si+7], 80h ; $M_SL.$M_S_FLAG,Right_Align
		jnz	short $MIF299
		or	dh, dh
		jz	short $MIF299

$MDO301:				; ...
		mov	al, [si+0Ah]	; $M_SL.$M_S_PAD
					; (ds:si+$M_SUBLIST_STRUC.$M_S_PAD)
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF302
		call	$M_FLUSH_BUF

$MIF302:				; ...
		dec	dh
		jnz	short $MDO301

$MIF299:				; ...
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF307
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND	$M_SIZE_MASK
		jz	short $MIF307
		jmp	short $MEN307
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF307:				; ...
		or	dl, dl
		jz	short $MEN307

$MDO310:				; ...
		pop	ds:$M_RT_$M_RETURN_ADDR	; pop [$M_RT.$M_RETURN_ADDR]
					; pop word [$M_RT+70]
		dec	dl
		jnz	short $MDO310

$MEN307:				; ...
		call	$M_FLUSH_BUF
		push	bp
		retn
$M_DISPLAY_REPLACE endp	; sp =	4


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_FLUSH_BUF	proc near		; ...
		push	cx
		push	es
		push	di
		push	ds
		pop	es
		mov	cx, bx
		xor	bx, bx
		lea	di, $M_RT_$M_TEMP_BUF ;	$M_RT.$M_TEMP_BUF
					; lea di,[$M_RT+76]
		call	$M_DISPLAY_STRING
		jb	short $MIF314
		pop	di
		pop	es
		pop	cx
		jmp	short $MEN314
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF314:				; ...
		add	sp, 6
		stc

$MEN314:				; ...
		retn
$M_FLUSH_BUF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CHAR_REPLACE	proc near		; ...
		pop	bp
		test	byte ptr [si+7], 30h ;
					; $M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK
		jnz	short $MIF317
		mov	al, es:[di]
		push	ax
		inc	cx
		call	$M_IS_IT_DBCS
		jnb	short $MIF318
		mov	al, es:[di+1]
		push	ax
		clc

$MIF318:				; ...
		jmp	short $MEN317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF317:				; ...
		mov	al, es:[di]
		or	al, al
		jz	short $MEN321
		inc	di
		inc	cx
		jmp	short $MIF317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN321:				; ...
		sub	di, cx

$MEN317:				; ...
		push	bp
		retn
$M_CHAR_REPLACE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_BIN2ASC_REPLACE proc	near		; ...
		pop	bp
		xor	dx, dx
		xor	ax, ax
		mov	ds:$M_RT_$M_DIVISOR, 16	; $M_RT.$M_DIVISOR,$M_BASE16
					; mov word [$M_RT+74],16
		xor	bx, bx
		test	byte ptr [si+7], 20h ; $M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK
		jnz	short $MIF325
		mov	al, es:[di]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF326
		test	al, 80h		; test al,10000000b
		jz	short $MIF327
		inc	bx		; negative number
		and	al, 7Fh		; and al,01111111b

$MIF327:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10

$MIF326:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jnz	short $MIF330
		mov	ds:$M_RT_$M_DIVISOR, 10	; mov word [$M_RT+74],10

$MIF330:				; ...
		jmp	short $MEN333
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF325:				; ...
		test	byte ptr [si+7], 10h ; $M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK
		jnz	short $MIF333
		mov	ax, es:[di]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF334
		test	ah, 80h		; test ah,10000000b
		jz	short $MIF335
		inc	bx
		and	ah, 7Fh		; and ah,01111111b

$MIF335:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10

$MIF334:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jnz	short $MIF338
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10

$MIF338:				; ...
		jmp	short $MEN333
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF333:				; ...
		mov	ax, es:[di]
		mov	dx, es:[di+2]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF341
		test	dh, 80h		; test dh,10000000b
		jz	short $MIF342
		inc	bx
		and	dh, 7Fh		; and dh,01111111b

$MIF342:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10	; mov word [$M_RT+74],10

$MIF341:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
					; ($M_SL = [ds:si]) ($M_SUBLIST_STRUC.$M_S_FLAG	= 7)
		jnz	short $MEN333
		mov	ds:$M_RT_$M_DIVISOR, 10

$MEN333:				; ...
		call	$M_CONVERT2ASC
		or	bx, bx
		jz	short $MIF349
		xor	dx, dx
		mov	dl, '-'         ; $M_NEG_SIGN
		push	dx

$MIF349:				; ...
		push	bp
		retn
$M_BIN2ASC_REPLACE endp	; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DATE_REPLACE	proc near		; ...
		pop	bp
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10
		call	$M_GET_DATE
		xor	dx, dx
		xor	ax, ax
		cmp	ds:$M_RT_$M_TEMP_BUF, 0	; $M_RT.$M_DATE_FORMAT,0
					; cmp word [$M_RT+76],0
		jnz	short $MIF351
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; $M_RT.$M_DATE_SEPARA
					; push word [$M_RT+87]
		inc	cx
		xor	ax, ax
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTDATE

$MIF351:				; ...
		cmp	ds:$M_RT_$M_TEMP_BUF, 1	; $M_RT.$M_DATE_FORMAT,1
		jnz	short $MIF353
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; push word [$M_RT+87]
		inc	cx
		xor	ax, ax
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3
		call	$M_CONVERTDATE

$MIF353:				; ...
		cmp	ds:$M_RT_$M_TEMP_BUF, 2	; $M_RT.$M_DATE_FORMAT,2
		jnz	short $MIF355
		mov	al, [si+5]
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+4]
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; $M_RT.$M_DATE_SEPARA
		inc	cx
		call	$M_YEAR
		call	$M_CONVERTDATE

$MIF355:				; ...
		push	bp
		retn
$M_DATE_REPLACE	endp ; sp = -0Ch


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_DATE	proc near		; ...
		mov	ah, 38h		; DOS_GET_COUNTRY
		mov	al, 0
		lea	dx, $M_RT_$M_TEMP_BUF ;	lea dx,[$M_RT+76]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF357
		mov	ds:$M_RT_$M_TEMP_BUF, 0	; $M_RT.$M_DATE_FORMAT,$M_DEF_DATE_FORM
		mov	byte ptr ds:$M_RT_$M_DATE_SEPARA, '-' ; $M_RT.$M_DATE_SEPARA,$M_DEF_DATE_SEP
					; mov byte [$M_RT+87],'-'

$MIF357:				; ...
		retn
$M_GET_DATE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_YEAR		proc near		; ...
		mov	ax, [si+2]	; $M_SL.$M_S_VALUE
					; ($M_SUBLIST_STRUC.$M_S_VALUE = 2)
		test	byte ptr [si+7], 10h ; $M_SL.$M_S_FLAG,Date_MDY_4 AND $M_DATE_MASK
		jnz	short $MIF360
		cmp	ax, 99		; $M_MAX_2_YEAR
		jbe	short $MIF360
		mov	ax, 99

$MIF360:				; ...
		retn
$M_YEAR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERTDATE	proc near		; ...
		pop	ds:$M_RT_$M_TEMP_BUF ; $M_RT.$M_TEMP_BUF
					; pop word [$M_RT+76]
		mov	ds:$M_RT_$M_SIZE, cl ; $M_RT.$M_SIZE
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, ds:$M_RT_$M_SIZE
		jnz	short $MIF363
		mov	ax, '0'         ; $M_TIMEDATE_PAD
		push	ax
		inc	cx

$MIF363:				; ...
		inc	cx
		push	ds:$M_RT_$M_TEMP_BUF ; push word [$M_RT+76]
		retn
$M_CONVERTDATE	endp ; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_TIME_REPLACE	proc near		; ...
		pop	bp
		mov	ds:$M_RT_$M_DIVISOR, 10	; MOV $M_RT.$M_DIVISOR,$M_BASE10
		call	$M_GET_TIME
		test	byte ptr [si+7], 1 ; $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK
		jz	short $MIF365
		cmp	ds:$M_RT_$M_TIME_FORMAT, 0 ; $M_RT.$M_TIME_FORMAT
					; cmp byte [$M_RT+93],0
		jnz	short $MIF365
		mov	al, [si+2]	; $M_SL.$M_S_VALUE ($M_SL = [ds:si])
		cmp	al, 12
		jl	short $MLL367
		cmp	al, 23
		jle	short MIF367

$MLL367:				; ...
		mov	al, 'a'         ; $M_AM
		push	ax
		inc	cx
		jmp	short $MIF365
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MIF367:					; ...
		mov	al, 'p'         ; $M_PM
		push	ax
		inc	cx

$MIF365:				; ...
		xor	ax, ax
		xor	dx, dx
		test	byte ptr [si+7], 20h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND	$M_SIZE_MASK
		jz	short $MIF372
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3 ($M_SUBLIST_STRUC.$M_S_VALUE = 2)
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_DECI_SEPARA	; $M_RT.$M_DECI_SEPARA
					; push word [$M_RT+85]
		inc	cx

$MIF372:				; ...
		test	byte ptr [si+7], 20h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND	$M_SIZE_MASK
		jnz	short $MLL374
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
		jz	short $MIF374

$MLL374:				; ...
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_TIME_SEPARA	; $M_RT.$M_TIME_SEPARA
					; push word [$M_RT+89]
		inc	cx

$MIF374:				; ...
		mov	al, [si+3]	;  $M_SL.$M_S_VALUE+1
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_TIME_SEPARA
		inc	cx
		mov	al, [si+2]	; $M_SL.$M_S_VALUE
		test	byte ptr [si+7], 1 ;
					; $M_SL.$M_S_FLAG,Time_Cty_Type	AND $M_TIME_MASK
		jz	short $MIF376
		cmp	ds:$M_RT_$M_TIME_FORMAT, 0 ; $M_RT.$M_TIME_FORMAT
					; cmp byte [$M_RT+93],0
		jnz	short $MIF376
		cmp	al, 13
		jl	short $MIF378
		sub	al, 12

$MIF378:				; ...
		cmp	al, 0
		jnz	short $MIF376
		mov	al, 12

$MIF376:				; ...
		call	$M_CONVERT2ASC
		push	bp
		retn
$M_TIME_REPLACE	endp ; sp = -8


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_TIME	proc near		; ...
		mov	ah, 38h		; DOS_GET_COUNTRY
		mov	al, 0
		lea	dx, $M_RT_$M_TEMP_BUF ;	lea dx,[$M_RT+76]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF384
		mov	word ptr ds:$M_RT_$M_TIME_FORMAT, 1 ; $M_DEF_TIME_FORM
		mov	byte ptr ds:$M_RT_$M_TIME_SEPARA, ':' ; $M_DEF_TIME_SEP
		mov	byte ptr ds:$M_RT_$M_DECI_SEPARA, '.' ; $M_DEF_DECI_SEP

$MIF384:				; ...
		retn
$M_GET_TIME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERTTIME	proc near		; ...
		pop	ds:$M_RT_$M_TEMP_BUF ; $M_RT.$M_TEMP_BUF
					; pop word [$M_RT+76]
		mov	ds:$M_RT_$M_SIZE, cl
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, ds:$M_RT_$M_SIZE ; $M_RT.$M_SIZE
		jnz	short $MIF386
		mov	ax, '0'         ; $M_TIMEDATE_PAD
		push	ax
		inc	cx

$MIF386:				; ...
		inc	cx
		push	ds:$M_RT_$M_TEMP_BUF
		retn
$M_CONVERTTIME	endp ; sp = -2

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LoadHigh:				; ...
		push	ds
		pop	es
		call	SkipLhDelims	;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
		push	si
		call	ParseLhCmd
		pop	si
		jb	short LhErr
		call	SetupCmdLine
		call	SetupPath
		jb	short LhErr
		call	HideUMBs
		jmp	LH_EXECUTE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LhErr:					; ...
		jmp	cerror

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseLhCmd	proc near		; ...
		mov	si, 81h		;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
		mov	ds:COMSW, 0
		mov	di, offset Parse_LoadHi
		xor	cx, cx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short PLhCmd2
		cmp	ax, 0
		jnz	short PLhCmd1
		mov	bx, dx
		call	LhCopyFilename
		jb	short PLhCmd2
		jmp	short PLhCmd2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PLhCmd1:				; ...
		stc

PLhCmd2:				; ...
		retn
ParseLhCmd	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


set_strategy	proc near		; ...
		mov	ax, 5800h	;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
					; DOS_CHECK_STRATEGY
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bx, ax
		or	bx, 80h
		mov	ax, 5801h	; DOS_SET_STRATEGY
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		retn
set_strategy	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


set_umblink	proc near		; ...
		mov	ax, 5803h	;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
					; DOS_SET_UMBLINK
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
set_umblink	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LhCopyFilename	proc near		; ...
		push	ds		;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
		push	si
		push	di
		lds	si, [bx+4]
		mov	di, offset EXECPATH

lhcpfn1:				; ...
		lodsb
		cmp	al, 2Ah	; '*'
		jz	short lhfilerr
		cmp	al, 3Fh	; '?'
		jz	short lhfilerr
		stosb
		or	al, al
		jnz	short lhcpfn1
		clc

lhfilerr2:				; ...
		pop	di
		pop	si
		pop	ds
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lhfilerr:				; ...
		mov	dx, offset LhInvFil_Ptr
		stc
		jmp	short lhfilerr2
LhCopyFilename	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SkipLhDelims	proc near		; ...
		mov	si, 81h		;  MSDOS 5.0 COMMAND.COM only !
					; (MSDOS 6.0 COMMAND.COM code is different here)
		call	scanoff

stfn1:					; ...
		lodsb
		call	DELIM
		jz	short stfn2
		cmp	al, 0Dh
		jz	short stfn2
		cmp	al, ds:SWITCHAR
		jnz	short stfn1

stfn2:					; ...
		dec	si
		retn
SkipLhDelims	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupCmdLine	proc near		; ...
		mov	di, 81h
		xor	cl, cl
		dec	cl

SetCmdL1:				; ...
		lodsb
		stosb
		inc	cl
		cmp	al, 0Dh
		jnz	short SetCmdL1
		mov	es:80h,	cl
		retn
SetupCmdLine	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LhSetupErrMsg	proc near		; ...
		mov	ds:msg_disp_class, 1
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		retn
LhSetupErrMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


check_umblink	proc near		; ...
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bl, al
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		mov	bh, al
		xchg	ax, bx
		rol	al, 1
		and	al, 1
		shl	ah, 1
		or	al, ah
		retn
check_umblink	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


HideUMBs	proc near		; ...
		push	ds
		call	check_umblink
		mov	ds, ds:RESSEG
		mov	ds:fInHigh, al
		or	ds:fInHigh, 80h
		pop	ds
		call	set_strategy
		call	set_umblink
		retn
HideUMBs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupPath	proc near		; ...
		mov	ax, ds:ARG_ARGVCNT ; mov ax,[ARG+ARG_UNIT.argvcnt]
		dec	ax
		mov	bx, 11		; ARGV_ELE.SIZE
		mul	bx
		mov	di, offset ARG_ARGV ; mov di,offset TRANGROUP:Arg
					; Copy TO argv[0]
		mov	si, di
		add	si, 11		; ARGV_ELE.SIZE
		mov	cx, ax
		cld
		rep movsb
		dec	ds:ARG_ARGVCNT	; dec word [ARG+ARG_UNIT.argvcnt]
		call	path_search
		or	ax, ax
		jz	short no_exec_file
		cmp	ax, 4
		jl	short no_exec_bat
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_exec_bat:				; ...
		mov	dx, offset NoExecBat_Ptr
		jmp	short lhsp_errret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_exec_file:				; ...
		mov	ax, 2
		call	LhSetupErrMsg

lhsp_errret:				; ...
		stc
		retn
SetupPath	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_3_STRUC db 0FFh		; ...
					; $M_CLASS_ID (Class identifer)
		dw 5			; $M_COMMAND_VER (COMMAND.COM version)
		db 162			; Total	number of messages
$M_ID_3_1	dw 1020			; Message Number = 1020
		dw 288h			; Message offset from message number (5A48h+0288h=5CD0h)
$M_ID_3_2	dw 1015			; Message Number = 1015
		dw 294h			; Message offset from message number (5A4Ch+0294h=5CE0h)
$M_ID_3_3	dw 1004, 692,1026, 714,1031, 730,1035, 741,1062, 752
		dw 1028, 763,1045, 793,1041, 818,1042, 848,1043, 871
		dw 1002, 899,1003, 935,1007, 959,1008, 982,1009,1000
		dw 1010,1017,1011,1045,1014,1068,1016,1081,1017,1119
		dw 1018,1152,1019,1168,1021,1176,1022,1202,1023,1237
		dw 1024,1277,1025,1296,1027,1316,1029,1345,1030,1359
		dw 1032,1370,1033,1390,1034,1408,1036,1426,1037,1443
		dw 1038,1456,1039,1471,1040,1528,1044,1545,1046,1561
		dw 1047,1612,1048,1633,1049,1647,1050,1653,1051,1680
		dw 1052,1693,1053,1712,1054,1746,1055,1781,1056,1791
		dw 1057,1802,1059,1811,1060,1812,1061,1812,1063,1834
		dw 1064,1833,1065,1832,1066,1831,1067,1830,1068,1828
		dw 1069,1835,1070,1835,1071,1834,1072,1833,1073,1838
		dw 1074,1843,1075,1848,1076,1850,1077,1849,1078,1853
		dw 1079,1876,1080,1883,1081,1901,1084,1940,1090,1952
		dw 1091,1962,1092,1972,1093,1982,1094,1999,1095,2024
		dw 1096,2049,1200,2094,1300,2091,1320,2222,1321,2282
		dw 1340,2391,1341,2479,1342,2574,1360,2716,1400,2740
		dw 1401,2882,1402,2983,1403,3098,1404,3160,1420,3292
		dw 1440,3427,1441,3469,1460,3597,1461,3694,1462,3822
		dw 1480,3898,1481,4057,1482,4147,1483,4241,1484,4360
		dw 1485,4548,1486,4700,1487,4847,1488,4946,1500,5089
		dw 1520,5148,1540,5206,1541,5296,1542,5400,1560,5456
		dw 1561,5508,1562,5629,1563,5673,1564,5712,1565,5770
		dw 1566,5819,1567,5860,1568,5978,1580,6051,1600,6119
		dw 1601,6144,1602,6224,1620,6298,1621,6382,1622,6508
		dw 1640,6580,1641,6629,1660,6757,1680,6824,1700,6858
		dw 1720,7032,1740,7111,1741,7199,1760,7310,1780,7383
		dw 1800,7487,1801,7561,1820,7645,1821,7713,1840,7848
		dw 1860,7919,1861,8006,1862,8073,1863,8195,1864,8354
		dw 1865,8453,1866,8556,1880,8656,1881,8772,1882,8894
		dw 1883,8977,1900,9136,1920,9156,1921,9200
$M_ID_3_162	dw 1922			; Message Number = 1922
		dw 9285			; Message offset from message number (5CCCh+2445h=8111h)
MSG_1020	db 15
		db '%1 bytes free',0Dh,0Ah
MSG_1015	db 35
		db 'File cannot be copied onto itself',0Dh,0Ah
MSG_1004	db 25
		db 'Insufficient disk space',0Dh,0Ah
MSG_1026	db 19
		db 'Invalid code page',0Dh,0Ah
MSG_1031	db 14
		db 'Invalid date',0Dh,0Ah
MSG_1035	db 14
		db 'Invalid time',0Dh,0Ah
MSG_1062	db 14
		db 'Invalid path',0Dh,0Ah
MSG_1028	db 33
		db 'Press any key to continue . . .',0Dh,0Ah
MSG_1045	db 28
		db 'Unable to create directory',0Dh,0Ah
MSG_1041	db 33
		db 'Volume in drive %1 has no label',0Dh,0Ah
MSG_1042	db 26
		db 'Volume in drive %1 is %2',0Dh,0Ah
MSG_1043	db 31
		db 'Volume Serial Number is %1-%2',0Dh,0Ah
MSG_1002	db 39
		db 'Duplicate file name or file not found',0Dh,0Ah
MSG_1003	db 27
		db 'Invalid path or file name',0Dh,0Ah
MSG_1007	db 26
		db 'Out of environment space',0Dh,0Ah
MSG_1008	db 21
		db 'File creation error',0Dh,0Ah
MSG_1009	db 20
		db 'Batch file missing',0Dh,0Ah
MSG_1010	db 31
		db 0Dh,0Ah
		db 'Insert disk with batch file',0Dh,0Ah
		db 26
		db 'Bad command or file name',0Dh,0Ah
		db 16
		db 'Access denied ',0Dh,0Ah
		db 41
		db 'Content of destination lost before copy',0Dh,0Ah
		db 36
		db 'Invalid filename or file not found',0Dh,0Ah
		db 19
		db '%1 file(s) copied',0Dh,0Ah
MSG_1019	db 11
		db '%1 file(s) '
MSG_1021	db 29
		db 'Invalid drive specification',0Dh,0Ah
		db 38
		db 'Code page %1 not prepared for system',0Dh,0Ah
		db 43
		db 'Code page %1 not prepared for all devices',0Dh,0Ah
		db 22
		db 'Active code page: %1',0Dh,0Ah
		db 23
		db 'NLSFUNC not installed',0Dh,0Ah
		db 32
		db 'Current drive is no longer valid'
		db 17
		db 'Label not found',0Dh,0Ah
		db 14
MSG_1030	db 'Syntax error',0Dh,0Ah
		db 23
		db 'Current date is %1 %2',0Dh,0Ah
		db 21
		db 'SunMonTueWedThuFriSat'
		db 21
		db 'Enter new date (%1): '
		db 20
		db 'Current time is %1',0Dh,0Ah
		db 16
		db 'Enter new time: '
MSG_1038	db 18
		db ',    Delete (Y/N)?'
MSG_1039	db 60
		db 'All files in directory will be deleted!',0Dh,0Ah
		db 'Are you sure (Y/N)?'
MSG_1040	db 20
		db 'MS-DOS Version %1.%2'
		db 19
		db 'Invalid directory',0Dh,0Ah
		db 54
		db 'Invalid path, not directory,',0Dh,0Ah
		db 'or directory not empty',0Dh,0Ah
		db 24
		db 'Must specify ON or OFF',0Dh,0Ah
		db 17
		db 'Directory of %1',0Dh,0Ah
MSG_1049	db 9
		db 'No Path',0Dh,0Ah
		db 30
		db 'Invalid drive in search path',0Dh,0Ah
		db 16
		db 'Invalid device',0Dh,0Ah
		db 22
		db 'FOR cannot be nested',0Dh,0Ah
		db 37
		db 'Intermediate file error during pipe',0Dh,0Ah
		db 38
		db 'Cannot do binary reads from a device',0Dh,0Ah
MSG_1055	db 13
		db 'BREAK is %1',0Dh,0Ah
		db 14
		db 'VERIFY is %1',0Dh,0Ah
		db 12
		db 'ECHO is %1',0Dh,0Ah
		db 4
		db 'off',0
		db 3
		db 'on',0
MSG_1061	db 25
		db 'Error writing to device',0Dh,0Ah
MSG_1063	db 2
		db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
MSG_1067	db 1
		db 9
MSG_1068	db 10
		db ' <DIR>    '
		db 3
		db 8, 20h, 8
		db 2
		db 0Dh
		db 0Ah
		db 2
		db '%1'
		db 8
		db 'mm-dd-yy'
		db 8
		db 'dd-mm-yy'
		db 8
		db 'yy-mm-dd'
		db 5
		db '%1 %2'
		db 2
		db '%1'
		db 7
		db ' %1  %2'
MSG_1078	db 26
		db 'Directory already exists',0Dh,0Ah
		db 10
		db '%1 bytes',0Dh,0Ah
		db 21
		db 'Total files listed:',0Dh,0Ah
		db 42
		db '(Error occurred in environment variable)',0Dh,0Ah
		db 15
		db '(continuing %1)'
		db 13
		db 'Revision %1',0Dh,0Ah
		db 13
		db 'DOS is in ROM'
		db 13
		db 'DOS is in HMA'
		db 20
		db 'DOS is in low memory'
MSG_1094	db 28
		db 'Cannot Loadhigh batch file',0Dh,0Ah
		db 28
		db 'LoadHigh: Invalid filename',0Dh,0Ah
		db 48
		db 'Cannot open specified country information file',0Dh,0Ah
MSG_1200	db 0
MSG_1300	db 134
		db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
		db 0Dh,0Ah
		db 'BREAK [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type BREAK without a parameter to display the current BREAK setti'
		db 'ng.',0Dh,0Ah
		db 63
		db 'Displays or sets the active code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHCP [nnn]',0Dh,0Ah
		db 0Dh,0Ah
		db 112
		db '  nnn   Specifies a code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type CHCP without a parameter to display the active code page num'
		db 'ber.',0Dh,0Ah
MSG_1340	db 91
		db 'Displays the name of or changes the current directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHDIR [drive:][path]',0Dh,0Ah
		db 'CHDIR[..]',0Dh,0Ah
		db 98
		db 'CD [drive:][path]',0Dh,0Ah
		db 'CD[..]',0Dh,0Ah
		db 0Dh,0Ah
		db '  ..   Specifies that you want to change to the parent directory.'
		db 0Dh,0Ah
		db 0Dh,0Ah
MSG_1342	db 145
		db 'Type CD drive: to display the current directory in the specified '
		db 'drive.',0Dh,0Ah
		db 'Type CD without parameters to display the current drive and direc'
		db 'tory.',0Dh,0Ah
		db 27
		db 'Clears the screen.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CLS',0Dh,0Ah
		db 145
		db 'Copies one or more files to another location.',0Dh,0Ah
		db 0Dh,0Ah
		db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [des'
		db 'tination',0Dh,0Ah
		db '  [/A | /B]] [/V]',0Dh,0Ah
		db 0Dh,0Ah
		db 104
		db '  source       Specifies the file or files to be copied.',0Dh,0Ah
		db '  /A           Indicates an ASCII text file.',0Dh,0Ah
MSG_1402	db 118
		db '  /B           Indicates a binary file.',0Dh,0Ah
		db '  destination  Specifies the directory and/or filename for the ne'
		db 'w file(s).',0Dh,0Ah
		db 65
		db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
		db 0Dh,0Ah
		db 135
		db 'To append files, specify a single file for destination, but multi'
		db 'ple files',0Dh,0Ah
		db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
		db 138
		db 'Changes the terminal device used to control your system.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CTTY device',0Dh,0Ah
		db 0Dh,0Ah
		db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
MSG_1440	db 45
		db 'Displays or sets the date.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DATE [date]',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db 'Type DATE without parameters to display the current date setting '
		db 'and',0Dh,0Ah
		db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
MSG_1460	db 100
		db 'Deletes one or more files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
		db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db '  [drive:][path]filename  Specifies the file(s) to delete.  Speci'
		db 'fy multiple',0Dh,0Ah
		db '                          files by using wildcards.',0Dh,0Ah
		db 79
		db '  /P                      Prompts for confirmation before deletin'
		db 'g each file.',0Dh,0Ah
MSG_1480	db 162
		db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
		db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
		db 0Dh,0Ah
		db 93
		db '  [drive:][path][filename]',0Dh,0Ah
		db '              Specifies drive, directory, and/or files to list.',0Dh
		db 0Ah
		db 97
		db '  /P          Pauses after each screenful of information.',0Dh,0Ah
		db '  /W          Uses wide list format.',0Dh,0Ah
		db 122
		db '  /A          Displays files with specified attributes.',0Dh,0Ah
		db '  attributes   D  Directories                R  Read-only files',0Dh
		db 0Ah
		db 191
		db '               H  Hidden files               A  Files ready for a'
		db 'rchiving',0Dh,0Ah
		db '               S  System files               -  Prefix meaning "n'
		db 'ot"',0Dh,0Ah
		db '  /O          List by files in sorted order.',0Dh,0Ah
MSG_1485	db 155
		db '  sortorder    N  By name (alphabetic)       S  By size (smallest'
		db ' first)',0Dh,0Ah
		db '               E  By extension (alphabetic)  D  By date & time (e'
		db 'arliest first)',0Dh,0Ah
		db 150
		db '               G  Group directories first    -  Prefix to reverse'
		db ' order',0Dh,0Ah
		db '  /S          Displays files in specified directory and all subdi'
		db 'rectories.',0Dh,0Ah
		db 102
		db '  /B          Uses bare format (no heading information or summary'
		db ').',0Dh,0Ah
		db '  /L          Uses lowercase.',0Dh,0Ah
		db 0Dh,0Ah
		db 146
		db 'Switches may be preset in the DIRCMD environment variable.  Overr'
		db 'ide',0Dh,0Ah
		db 'preset switches by prefixing any switch with - (hyphen)--for exam'
		db 'ple, /-W.',0Dh,0Ah
MSG_1500	db 62
		db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
		db 0Dh,0Ah
		db 'EXIT',0Dh,0Ah
		db 61
		db 'Creates a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'MKDIR [drive:]path',0Dh,0Ah
		db 'MD [drive:]path',0Dh,0Ah
MSG_1540	db 93
		db 'Displays or sets a search path for executable files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PATH [[drive:]path[;...]]',0Dh,0Ah
		db 'PATH ;',0Dh,0Ah
		db 0Dh,0Ah
		db 107
		db 'Type PATH ; to clear all search-path settings and direct MS-DOS t'
		db 'o search',0Dh,0Ah
		db 'only in the current directory.',0Dh,0Ah
		db 59
		db 'Type PATH without parameters to display the current path.',0Dh,0Ah
MSG_1560	db 55
		db 'Changes the MS-DOS command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PROMPT [text]',0Dh,0Ah
		db 0Dh,0Ah
		db 124
		db '  text    Specifies a new command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Prompt can be made up of normal characters and the following spec'
		db 'ial codes:',0Dh,0Ah
		db 0Dh,0Ah
		db 47
		db '  $Q   = (equal sign)',0Dh,0Ah
		db '  $$   $ (dollar sign)',0Dh,0Ah
		db 42
		db '  $T   Current time',0Dh,0Ah
		db '  $D   Current date',0Dh,0Ah
MSG_1564	db 61
		db '  $P   Current drive and path',0Dh,0Ah
		db '  $V   MS-DOS version number',0Dh,0Ah
		db 52
		db '  $N   Current drive',0Dh,0Ah
		db '  $G   > (greater-than sign)',0Dh,0Ah
		db 44
		db '  $L   < (less-than sign)',0Dh,0Ah
		db '  $B   | (pipe)',0Dh,0Ah
		db 121
		db '  $H   Backspace (erases previous character)',0Dh,0Ah
		db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
		db '  $_   Carriage return and linefeed',0Dh,0Ah
		db 0Dh,0Ah
		db 76
		db 'Type PROMPT without parameters to reset the prompt to the default'
		db ' setting.',0Dh,0Ah
MSG_1580	db 71
		db 'Removes (deletes) a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'RMDIR [drive:]path',0Dh,0Ah
		db 'RD [drive:]path',0Dh,0Ah
		db 28
		db 'Renames a file or files.',0Dh,0Ah
		db 0Dh,0Ah
		db 83
		db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
		db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
		db 0Dh,0Ah
		db 77
		db 'Note that you cannot specify a new drive or path for your destina'
		db 'tion file.',0Dh,0Ah
MSG_1620	db 87
		db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
		db 0Dh,0Ah
		db 'SET [variable=[string]]',0Dh,0Ah
		db 0Dh,0Ah
		db 129
		db '  variable  Specifies the environment-variable name.',0Dh,0Ah
		db '  string    Specifies a series of characters to assign to the var'
		db 'iable.',0Dh,0Ah
		db 0Dh,0Ah
		db 75
		db 'Type SET without parameters to display the current environment va'
		db 'riables.',0Dh,0Ah
MSG_1640	db 52
		db 'Displays or sets the system time.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TIME [time]',0Dh,0Ah
		db 0Dh,0Ah
		db 131
		db 'Type TIME with no parameters to display the current time setting '
		db 'and a prompt',0Dh,0Ah
		db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
MSG_1660	db 70
		db 'Displays the contents of a text file.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TYPE [drive:][path]filename',0Dh,0Ah
MSG_1680	db 37
		db 'Displays the MS-DOS version.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VER',0Dh,0Ah
		db 177
		db 'Tells MS-DOS whether to verify that your files are written correc'
		db 'tly to a',0Dh,0Ah
		db 'disk.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VERIFY [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type VERIFY without a parameter to display the current VERIFY set'
		db 'ting.',0Dh,0Ah
MSG_1720	db 82
		db 'Displays the disk volume label and serial number, if they exist.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'VOL [drive:]',0Dh,0Ah
		db 91
		db 'Calls one batch program from another.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
		db 0Dh,0Ah
		db 114
		db '  batch-parameters   Specifies any command-line information requi'
		db 'red by the',0Dh,0Ah
		db '                     batch program.',0Dh,0Ah
MSG_1760	db 76
		db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
		db 0Dh,0Ah
		db 'REM [comment]',0Dh,0Ah
		db 107
		db 'Suspends processing of a batch program and displays the message "'
		db 'Press any',0Dh,0Ah
		db 'key to continue...."',0Dh,0Ah
		db 0Dh,0Ah
		db 'PAUSE',0Dh,0Ah
MSG_1800	db 77
		db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
		db 0Dh,0Ah
		db '  ECHO [ON | OFF]',0Dh,0Ah
		db 87
		db '  ECHO [message]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type ECHO without parameters to display the current echo setting.'
		db 0Dh,0Ah
MSG_1820	db 71
		db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
		db 0Dh,0Ah
		db 'GOTO label',0Dh,0Ah
		db 0Dh,0Ah
		db 138
		db '  label   Specifies a text string used in the batch program as a '
		db 'label.',0Dh,0Ah
		db 0Dh,0Ah
		db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
		db 74
		db 'Changes the position of replaceable parameters in a batch file.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'SHIFT',0Dh,0Ah
MSG_1860	db 90
		db 'Performs conditional processing in batch programs.',0Dh,0Ah
		db 0Dh,0Ah
		db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
		db 70
		db 'IF [NOT] string1==string2 command',0Dh,0Ah
		db 'IF [NOT] EXIST filename command',0Dh,0Ah
		db 0Dh,0Ah
		db 125
		db '  NOT               Specifies that MS-DOS should carry out the co'
		db 'mmand only',0Dh,0Ah
		db '                    if the condition is false.',0Dh,0Ah
MSG_1863	db 162
		db '  ERRORLEVEL number Specifies a true condition if the last progra'
		db 'm run returned',0Dh,0Ah
		db '                    '
		db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
		db 102
		db '  command           Specifies the command to carry out if the con'
		db 'dition is',0Dh,0Ah
		db '                    met.',0Dh,0Ah
		db 106
		db '  string1==string2  Specifies a true condition if the specified t'
		db 'ext strings',0Dh,0Ah
		db '                    match.',0Dh,0Ah
		db 103
		db '  EXIST filename    Specifies a true condition if the specified f'
		db 'ilename',0Dh,0Ah
		db '                    exists.',0Dh,0Ah
MSG_1880	db 119
		db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
		db 0Dh,0Ah
		db 125
		db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
		db '  (set)      Specifies a set of one or more files.  Wildcards may'
		db ' be used.',0Dh,0Ah
		db 86
		db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
		db '  command-parameters',0Dh,0Ah
		db 162
		db '             Specifies parameters or switches for the specified c'
		db 'ommand.',0Dh,0Ah
		db 0Dh,0Ah
		db 'To use the FOR command in a batch program, specify %%variable ins'
		db 'tead of',0Dh,0Ah
		db '%variable.',0Dh,0Ah
MSG_1900	db 23
		db 'Reserved command name',0Dh,0Ah
MSG_1920	db 47
		db 'Loads a program into the upper memory area.',0Dh,0Ah
		db 0Dh,0Ah
		db 88
		db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
		db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1922	db 113
		db '  parameters   Specifies any command-line information required by'
		db ' the',0Dh,0Ah
		db '               program you want to load.',0Dh,0Ah

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CLS_3	proc near		; ...
		push	cs		; CLASS_F
		pop	es
		assume es:TRANGROUP
		lea	di, $M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
		add	cx, 10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
		retn
$M_CLS_3	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_1_STRUC db 1			; ...
					; $M_CLASS_ID
		dw 5			; EXPECTED_VERSION (COMMAND.COM	version)
		db 4			; Class_1_MessageCount
$M_ID_1_1	dw 2			; Message Number = 2
		dw 10h			; Message offset from message number
$M_ID_1_2	dw 3			; Message Number = 3
		dw 1Bh			; Message offset from message number
$M_ID_1_3	dw 8			; Message Number = 8
		dw 26h			; Message offset from message number
$M_ID_1_4	dw 0FFFFh		; Message Number = -1
		dw 36h			; Message offset from message number
EXTEND2		db 14
		db 'File not found'
EXTEND3		db 14
		db 'Path not found'
EXTEND8		db 19
		db 'Insufficient memory'
EXTEND999	db 17
		db 'Extended Error %1'

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_MSGSERV_1	proc near		; ...
		push	cs
		pop	es
		lea	di, $M_CLASS_1_STRUC
		add	cx, 94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
		retn
$M_MSGSERV_1	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_2_STRUC db 2			; ...
					; $M_CLASS_ID
		dw 5			; EXPECTED_VERSION (COMMAND.COM	version)
		db 1			; Class_2_MessageCount
$M_ID_2_1	dw 0FFFFh		; Message Number = -1
		dw 4			; Message offset from message number
PARSE999	db 14
		db 'Parse Error %1'

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_MSGSERV_2	proc near		; ...
		push	cs
		pop	es
		lea	di, $M_CLASS_2_STRUC
		add	cx, 29		; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
		retn
$M_MSGSERV_2	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
msg_disp_class	db 0FFh			; ...
					; Util_msg_class
msg_cont_flag	db 0			; ...
					; No_cont_flag
extend_buf_ptr	dw 0			; ...
extend_buf_sub	db 0			; ...
		db 11			; parm_block_size
		db 0
extend_buf_off	dw offset string_ptr_2
extend_buf_seg	dw 0
		db 0
		db 10h			; Char_field_ASCIIZ
		db 128			; maximum width
		db 0			; minimum width
		db 20h			; blank
RENERR_PTR	dw 1002			; ...
		db 0			; no_subst
BADCPMES_PTR	dw 1003			; ...
					; message number
		db 0			; number of subst
NOSPACE_PTR	dw 1004			; ...
		db 0
ENVERR_PTR	dw 1007			; ...
		db 0
FULLDIR_PTR	dw 1008			; ...
		db 0
BADBAT_PTR	dw 1009			; ...
		db 0
NEEDBAT_PTR	dw 1010			; ...
		db 0
BADNAM_PTR	dw 1011			; ...
		db 0
ACCDEN_PTR	dw 1014			; ...
		db 0
OVERWR_PTR	dw 1015			; ...
		db 0
LOSTERR_PTR	dw 1016			; ...
		db 0
INORNOT_PTR	dw 1017			; ...
		db 0
copied_ptr	dw 1018			; ...
					; message number
		db 1			; number of subst
		db 11			; parm_block_size (size	of sublist)
		db 0
		dw offset Copy_num	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 0A1h			; Right_Align+Unsgn_Bin_Word (binary to	decimal)
		db 9			; maximum width
		db 9			; minimum width
		db 20h			; pad character
dirmes_ptr	dw 1019			; ...
		db 1
		db 11
		db 0
		dw offset Dir_Num
		dw 0
		db 1
		db 0A1h
		db 9
		db 9
		db 20h
bytmes_ptr	dw 1020			; ...
					; message number
		db 1			; number of subst
		db 11			; parm_block_size (size	of sublist)
		db 0			; reserved
		dw offset Bytes_Free	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 0B1h			; Right_Align+Unsgn_Bin_DWord (long binary to decimal)
		db 28			; maximum width
		db 28			; minimum width
		db 20h			; blank	(pad character)
baddrv_ptr	dw 1021			; ...
		db 0
cp_not_set_ptr	dw 1022			; ...
		db 1
		db 11
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
cp_not_all_ptr	dw 1023			; ...
		db 1
		db 11
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
cp_active_ptr	dw 1024			; ...
		db 1
		db 0Bh
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
NLSFUNC_PTR	dw 1025			; ...
		db 0
INV_CODE_PAGE	dw 1026			; ...
		db 0
BADCURDRV	dw 1027			; ...
		db 0
PAUSEMES_PTR	dw 1028			; ...
		db 0
BADLAB_PTR	dw 1029			; ...
		db 0
SYNTMES_PTR	dw 1030			; ...
		db 0
BADDAT_PTR	dw 1031			; ...
		db 0
CurDat_Ptr	dw 1032			; ...
					; message number
		db 2			; number of subst
		db 11			; size of sublist
		db 0			; reserved
		dw offset Arg_Buf	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 3			; maximum width
		db 3			; minimum width
		db 20h			; blank	(pad character)
		db 11			; size of sublist
		db 0			; reserved
CurDat_yr	dw 0			; ...
					; year
CurDat_mo_day	dw 0			; ...
					; month,day
		db 2			; second subst
		db 34h			; DATE_MDY_4 (date)
		db 10			; maximum width
		db 10			; maximum width
		db 20h			; pad character
WeekTab		dw 1033			; ...
		db 0
NewDat_Ptr	dw 1034			; ...
		db 1
		db 11
		db 0
NewDat_Format	dw 0			; ...
		dw 0
		db 1
		db 10h
		db 8
		db 8
		db 20h
BadTim_Ptr	dw 1035			; ...
		db 0
CurTim_Ptr	dw 1036			; ...
					; message number
		db 1			; number of subst
		db 11			; size of sublist
		db 0			; reserved
CurTim_hr_min	dw 0			; ...
					; hours,minutes
CurTim_Sec_hn	dw 0			; ...
					; seconds,hundredths
		db 1			; first	subst
		db 0A5h			; Right_Align+TIME_HHMMSSHH_Cty	(time)
		db 12			; maximum width
		db 12			; maximum width
		db 20h			; pad character
NewTim_Ptr	dw 1037			; ...
		db 0
Del_Y_N_Ptr	dw 1038			; ...
		db 0
SureMes_Ptr	dw 1039			; ...
		db 0
VerMes_Ptr	dw 1040			; ...
		db 2
		db 11
		db 0
		dw offset Major_Ver_Num
		dw 0
		db 1
		db 0A1h
		db 1
		db 1
		db 20h			; blank	(pad character)
		db 11
		db 0
		dw offset Minor_Ver_Num
		dw 0
		db 2
		db 0A1h
		db 2
		db 2
		db 30h			; "0" (pad character)
VolMes_Ptr_2	dw 1041			; ...
					; message number
		db 1
		db 11
		db 0
		dw offset vol_drv
		dw 0
		db 1
		db 0			; Char_field_Char (character)
		db 128
		db 1
		db 20h
VolMes_Ptr	dw 1042			; ...
					; "Volume in drive %1 is %2",13,10
		db 2			; number of subst
		db 11			; size of sublist
		db 0			; reserved
		dw offset vol_drv	; offset of drive
		dw 0			; segment of arg
		db 1			; first	subst
		db 0			; character (Char_field_Char)
		db 128			; maximum width
		db 1			; minimum width
		db 20h			; pad character	(blank)
		db 11			; size of sublist
		db 0			; reserved
		dw offset CHARBUF	; offset of string
		dw 0			; segment of arg
		db 2			; second subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 128			; maximum width
		db 1			; minimum width
		db 20h			; pad character	(blank)
VolSerMes_Ptr	dw 1043			; ...
					; "Volume Serial Number	is %1-%2",13,10
		db 2
		db 11
		db 0
		dw offset vol_serial+2
		dw 0
		db 1
		db 0A3h			; Right_Align+Bin_Hex_Word (binary to hex)
		db 4
		db 4
		db 30h			; "0"
		db 0Bh
		db 0
		dw offset vol_serial
		dw 0
		db 2
		db 0A3h
		db 4
		db 4
		db 30h
badcd_ptr	dw 1044			; ...
		db 0
badmkd_ptr	dw 1045			; ...
		db 0
badrmd_ptr	dw 1046			; ...
		db 0
bad_on_off_ptr	dw 1047			; ...
					; message number
		db 0			; no_subst (umber of subst)
dirhead_ptr	dw 1048			; ...
					; "Directory of	%1",13,10
		db 1			; number of subst
		db 11			; parm_block_size (size	of sublist)
		db 0			; reserved
		dw offset BWDBUF	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 128			; maximum width
		db 0			; minimum witdh
		db 20h			; pad character	(blank)
NULLPATH_PTR	dw 1049			; ...
		db 0
BADPMES_PTR	dw 1050			; ...
		db 0
BADDEV_PTR	dw 1051			; ...
		db 0
FORNESTMES_PTR	dw 1052			; ...
		db 0
PIPEEMES_PTR	dw 1053			; ...
		db 0
INBDEV_PTR	dw 1054			; ...
		db 0
CtrlcMes_Ptr	dw 1055			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
VeriMes_Ptr	dw 1056			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
EchoMes_Ptr	dw 1057			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
OFFMES_PTR	dw 1059			; ...
		db 0
ONMES_PTR	dw 1060			; ...
		db 0
DEVWMES_PTR	dw 1061			; ...
		db 0
INVAL_PATH_PTR	dw 1062
		db 0
arg_buf_ptr	dw 1063			; ...
		db 1
		db 11
		db 0
		dw offset Arg_Buf
		dw 0
		db 1
		db 10h
		db 128
		db 0
		db 20h
file_name_ptr	dw 1064			; ...
		db 1
		db 11
		db 0
		dw offset SrcBuf
		dw 0
		db 1
		db 10h
		db 128
		db 0
		db 20h
disp_file_size_ptr dw 1065		; ...
		db 1
		db 11
		db 0
		dw offset File_Size_Low
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord (long binary to decimal)
		db 10
		db 10
		db 20h
string_buf_ptr	dw 1066			; ...
		db 1			; number of subst
		db 11			; size of sublist
		db 0			; reserved
		dw offset string_ptr_2	; offset of arg
		dw 0			; segment of arg
		db 1			; first	subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 128			; maximum width
		db 0			; minimum width
		db 20h			; pad character
		db 0
tab_ptr		dw 1067			; ...
		db 0
dmes_ptr	dw 1068			; ...
		db 0
dback_ptr	dw 1069			; ...
		db 0
acrlf_ptr	dw 1070			; ...
		db 0
usadat_Ptr	dw 1072			; ...
					; "mm-dd-yy"
		db 0
eurdat_ptr	dw 1073			; ...
					; "dd-mm-yy"
		db 0
japdat_ptr	dw 1074			; ...
					; "yy-mm-dd"
		db 0
promptdat_ptr	dw 1075			; ...
					; message number
		db 2			; number of subst
		db 11
		db 0
		dw offset Arg_Buf
		dw 0
		db 1			; first	subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 3
		db 3
		db 20h
		db 11
		db 0
promptDat_yr	dw 0			; ...
promptDat_moday	dw 0			; ...
		db 2			; second subst
		db 34h			; DATE_MDY_4 (date)
		db 10			; maximum width
		db 8			; minimum width
		db 20h			; blank	(pad character)
promtim_ptr	dw 1076			; ...
		db 1
		db 11
		db 0
PromTim_hr_min	dw 0			; ...
PromTim_Sec_hn	dw 0			; ...
		db 1
		db 0A6h			; Right_Align+TIME_HHMMSSHH_24 (time)
		db 11
		db 11
		db 20h
dirdattim_ptr	dw 1077			; ...
		db 2			; number of subst
		db 11			; size of sublist
		db 0
DirDat_Yr	dw 0			; ...
DirDat_Mo_Day	dw 0			; ...
		db 1			; first	subst
		db 0A4h			; Right_Align+DATE_MDY_2 (date)
		db 10
		db 8
		db 20h
		db 11			; size of sublist
		db 0
DirTim_Hr_Min	dw 0			; ...
DirTim_Sec_hn	dw 0
		db 2			; second subst
		db 85h			; Right_align+TIME_HHMM_Cty (time)
		db 6
		db 6
		db 20h			; pad character
MD_EXISTS_PTR	dw 1078			; ...
		db 0
bytes_ptr	dw 1079			; ...
					; "%1 bytes",13,10
		db 1
		db 0Bh
		db 0
		dw offset FileSiz
		dw 0
		db 1
		db 0B1h			; Right_Align+Unsgn_Bin_DWord (long binary to decimal)
		db 10
		db 10
		db 20h
total_ptr	dw 1080			; ...
		db 0
errparsenv_ptr	dw 1081			; ...
		db 0
dircont_ptr	dw 1084			; ...
		db 1
		db 0Bh
		db 0
		dw offset BWDBUF
		dw 0
		db 1
		db 10h
		db 80h
		db 0
		db 20h
dosrev_ptr	dw 1090			; ...
					; message number
		db 1			; one substitution
		db 0Bh
		db 0
		dw offset One_Char_Val
		dw 0
		db 1
		db 0			; CHAR_FIELD_CHAR (character)
		db 1
		db 1
		db 20h
DosRom_Ptr	dw 1091			; ...
		db 0
DosHma_Ptr	dw 1092			; ...
		db 0
DosLow_Ptr	dw 1093			; ...
		db 0
NoExecBat_Ptr	dw 1094			; ...
		db 0
LhInvFil_Ptr	dw 1095			; ...
		db 0
NoCntry_Ptr	dw 1096			; ...
		db 0
PATH_TEXT	db 'PATH='              ; ...
PROMPT_TEXT	db 'PROMPT='            ; ...
COMSPECSTR	db 'COMSPEC='           ; ...
DirEnvVar	db 'DIRCMD='            ; ...
BreakHelpMsgs	dw 1300, 0		; ...
ChcpHelpMsgs	dw 1320, 1321, 0	; ...
CdHelpMsgs	dw 1340, 1341, 1342, 0	; ...
ClsHelpMsgs	dw 1360, 0		; ...
CopyHelpMsgs	dw 1400, 1401, 1402, 1403, 1404, 0 ; ...
CttyHelpMsgs	dw 1420, 0		; ...
DateHelpMsgs	dw 1440, 1441, 0	; ...
DelHelpMsgs	dw 1460, 1461, 1462, 0	; ...
DirHelpMsgs	dw 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488	; ...
		dw 0
ExitHelpMsgs	dw 1500, 0		; ...
MdHelpMsgs	dw 1520, 0		; ...
PathHelpMsgs	dw 1540, 1541, 1542, 0	; ...
PromptHelpMsgs	dw 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568	; ...
		dw 0
RdHelpMsgs	dw 1580, 0		; ...
RenHelpMsgs	dw 1600, 1601, 1602, 0	; ...
SetHelpMsgs	dw 1620, 1621, 1622, 0	; ...
TimeHelpMsgs	dw 1640, 1641, 0	; ...
TypeHelpMsgs	dw 1660, 0		; ...
VerHelpMsgs	dw 1680, 0		; ...
VerifyHelpMsgs	dw 1700, 0		; ...
VolHelpMsgs	dw 1720, 0		; ...
CallHelpMsgs	dw 1740, 1741, 0	; ...
RemHelpMsgs	dw 1760, 0		; ...
PauseHelpMsgs	dw 1780, 0		; ...
EchoHelpMsgs	dw 1800, 1801, 0	; ...
GotoHelpMsgs	dw 1820, 1821, 0	; ...
ShiftHelpMsgs	dw 1840, 0		; ...
IfHelpMsgs	dw 1860, 1861, 1862, 1863, 1864, 1865, 1866, 0 ; ...
ForHelpMsgs	dw 1880, 1881, 1882, 1883, 0 ; ...
TruenameHelpMsgs dw 1900, 0		; ...
LoadhighHelpMsgs dw 1920, 1921,	1922, 0	; ...
CLSSTRING	db 4			; ...
		db 1Bh			; ESC
clsstring_2	db '[2J'                ; ...
PROMPT_TABLE	db 'B'
		dw offset Print_B
		db 'D'
		dw offset PRINT_DATE
		db 'E'
		dw offset PRINT_ESC
		db 'G'
		dw offset PRINT_G
		db 'H'
		dw offset PRINT_BACK
		db 'L'
		dw offset PRINT_L
		db 'N'
		dw offset PRINT_DRIVE
		db 'P'
		dw offset build_dir_for_prompt
		db 'Q'
		dw offset PRINT_EQ
		db 'T'
		dw offset PRINT_TIME
		db 'V'
		dw offset PRINT_VERSION
		db '_'
		dw offset CRLF2
		db '$'
		dw offset PRINT_CHAR
		db 0
IFTAB		db 3			; ...
		db 'NOT'
		dw offset IFNOT
		db 10
		db 'ERRORLEVEL'
		dw offset IFERLEV
		db 5
		db 'EXIST'
		dw offset IFEXISTS
		db 0
COMTAB		db 3			; ...
		db 'DIR'
		db 3
		dw offset CATALOG
		dw offset DirHelpMsgs
		db 4
		db 'CALL'
		db 2
		dw offset _$CALL
		dw offset CallHelpMsgs
		db 4
		db 'CHCP'
		db 2
		dw offset CHCP
		dw offset ChcpHelpMsgs
		db 6
		db 'RENAME'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 3
		db 'REN'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 5
		db 'ERASE'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 3
		db 'DEL'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 4
		db 'TYPE'
		db 3
		dw offset TYPEFIL
		dw offset TypeHelpMsgs
		db 3
		db 'REM'
		db 6
		dw offset TCOMMAND
		dw offset RemHelpMsgs
		db 4
		db 'COPY'
		db 3
		dw offset COPY
		dw offset CopyHelpMsgs
		db 5
		db 'PAUSE'
		db 6
		dw offset PAUSE
		dw offset PauseHelpMsgs
		db 4
		db 'DATE'
		db 2
		dw offset DATE
		dw offset DateHelpMsgs
		db 4
		db 'TIME'
		db 2
		dw offset CTIME
		dw offset TimeHelpMsgs
		db 3
		db 'VER'
		db 2
		dw offset VERSION
		dw offset VerHelpMsgs
		db 3
		db 'VOL'
		db 3
		dw offset VOLUME
		dw offset VolHelpMsgs
		db 2
		db 'CD'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 5
		db 'CHDIR'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 2
		db 'MD'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 5
		db 'MKDIR'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 2
		db 'RD'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'RMDIR'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'BREAK'
		db 2
		dw offset CNTRLC
		dw offset BreakHelpMsgs
		db 6
		db 'VERIFY'
		db 2
		dw offset VERIFY
		dw offset VerifyHelpMsgs
		db 3
		db 'SET'
		db 6
		dw offset ADD_NAME_TO_ENVIRONMENT
		dw offset SetHelpMsgs
		db 6
		db 'PROMPT'
		db 6
		dw offset ADD_PROMPT
		dw offset PromptHelpMsgs
		db 4
		db 'PATH'
		db 2
		dw offset PATH
		dw offset PathHelpMsgs
		db 4
		db 'EXIT'
		db 0
		dw offset _$EXIT
		dw offset ExitHelpMsgs
		db 4
		db 'CTTY'
		db 3
		dw offset CTTY
		dw offset CttyHelpMsgs
		db 4
		db 'ECHO'
		db 6
		dw offset ECHO
		dw offset EchoHelpMsgs
		db 4
		db 'GOTO'
		db 6
		dw offset GOTO
		dw offset GotoHelpMsgs
		db 5
		db 'SHIFT'
		db 2
		dw offset SHIFT
		dw offset ShiftHelpMsgs
		db 2
		db 'IF'
		db 6
		dw offset _$IF
		dw offset IfHelpMsgs
		db 3
		db 'FOR'
		db 6
		dw offset _$FOR
		dw offset ForHelpMsgs
		db 3
		db 'CLS'
		db 0
		dw offset CLS
		dw offset ClsHelpMsgs
		db 8
		db 'TRUENAME'
		db 3
		dw offset TRUENAME
		dw offset TruenameHelpMsgs
		db 8
		db 'LOADHIGH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 2
		db 'LH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 0
comext		db '.COM'               ; ...
exeext		db '.EXE'               ; ...
batext		db '.BAT'               ; ...
switch_list	db '?VBAPW'             ; ...
AttrLtrs	db 'RHSvDA'             ; ...
OrderLtrs	db 'NEDSG'              ; ...
comspec_flag	db 0			; ...
BATBUFLEN	dw 32			; ...
NO_VALUES	dw 0			; ...
NULL_VALUE_LIST	db 0			; ...
FILE_REQUIRED	dw 200h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL	dw 301h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL2	dw 201h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
SLASH_P_SWITCH	dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
SLASH_P_SYN	db '/P',0               ; ...
PARSE_BREAK	dw offset BREAK_PARMS	; ...
		db 0
BREAK_PARMS	db 0			; ...
		db 1
		dw offset BREAK_CONTROL1
		db 0
		db 0
BREAK_CONTROL1	dw 2001h		; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset BREAK_VALUES
		db 0
BREAK_VALUES	db 3			; ...
		db 0
		db 0
		db 2
		db 0
		dw offset BREAK_ON	; "ON"
		db 'f'
		dw offset BREAK_OFF	; "OFF"
BREAK_ON	db 'ON',0               ; ...
BREAK_OFF	db 'OFF',0              ; ...
PARSE_CHCP	dw offset CHCP_PARMS	; ...
		db 0
CHCP_PARMS	db 0			; ...
		db 1
		dw offset CHCP_CONTROL1
		db 0
		db 0
CHCP_CONTROL1	dw 8001h		; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset CHCP_VALUES
		db 0
CHCP_VALUES	db 1			; ...
		db 1
		db 1
		dd 100			; CHCP_MINVAL
		dd 999			; CHCP_MAXVAL
		db 0
		db 0
PARSE_DATE	dw offset DATE_PARMS	; ...
		db 0
DATE_PARMS	db 0			; ...
		db 1
		dw offset DATE_CONTROL1
		db 0
		db 0
DATE_CONTROL1	dw 1001h		; ...
		dw 0
		dw offset DATE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_TIME	dw offset TIME_PARMS	; ...
		db 0
TIME_PARMS	db 0			; ...
		db 1
		dw offset TIME_CONTROL1
		db 0
		db 0
TIME_CONTROL1	dw 801h			; ...
		dw 0
		dw offset TIME_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VOL	dw offset VOL_PARMS	; ...
		db 0
VOL_PARMS	db 0			; ...
		db 1
		dw offset DRIVE_CONTROL1
		db 0
		db 0
DRIVE_CONTROL1	dw 101h			; ...
		dw 1
		dw offset DRIVE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_MRDIR	dw offset MRDIR_PARMS	; ...
		db 0
MRDIR_PARMS	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CHDIR	dw offset CHDIR_PARMS	; ...
		db 0
CHDIR_PARMS	db 0			; ...
		db 1
		dw offset FILE_OPTIONAL
		db 0
		db 0
PARSE_ERASE	dw offset ERASE_PARMS	; ...
		db 0
ERASE_PARMS	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 1
		dw offset SLASH_P_SWITCH
		db 0
PARSE_DIR	dw offset DIR_PARMS	; ...
		db 0
DIR_PARMS	db 0			; ...
		db 1
		dw offset FILE_OPTIONAL2
		db 2
		dw offset DIR_SW_VALUED
		dw offset DIR_SW_UNVALUED
		db 0
DIR_SW_VALUED	dw 2001h		; ...
		dw 21h
		dw offset PARSE1_OUTPUT
		dw offset NULL_VALUE_LIST
		db 2
DIR_SW_A	db '/A',0               ; ...
DIR_SW_O	db '/O',0               ; ...
DIR_SW_UNVALUED	dw 0			; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 14			; 14 'synonyms'
DIR_SW_NEG_A	db '/-A',0              ; ...
DIR_SW_NEG_O	db '/-O',0              ; ...
DIR_SW_S	db '/S',0               ; ...
DIR_SW_NEG_S	db '/-S',0              ; ...
DIR_SW_B	db '/B',0               ; ...
DIR_SW_NEG_B	db '/-B',0              ; ...
DIR_SW_W	db '/W',0               ; ...
DIR_SW_NEG_W	db '/-W',0              ; ...
DIR_SW_P	db '/P',0               ; ...
DIR_SW_NEG_P	db '/-P',0              ; ...
DIR_SW_L	db '/L',0               ; ...
DIR_SW_NEG_L	db '/-L',0              ; ...
Dir_Sw_Ptrs	dw offset DIR_SW_NEG_W	; ...
					; "/-W"
Dir_Sw_Ptrs_2	dw offset DIR_SW_W	; ...
					; "/W"
		dw offset DIR_SW_NEG_P	; "/-P"
		dw offset DIR_SW_P	; "/P"
		dw offset DIR_SW_NEG_S	; "/-S"
		dw offset DIR_SW_S	; "/S"
		dw offset DIR_SW_NEG_B	; "/-B"
		dw offset DIR_SW_B	; "/B"
		dw offset DIR_SW_NEG_L	; "/-L"
		dw offset DIR_SW_L	; "/L"
		dw offset DIR_SW_NEG_O	; "/-O"
		dw offset DIR_SW_O	; "/O"
		dw offset DIR_SW_NEG_A	; "/-A"
		dw offset DIR_SW_A	; "/A"
PARSE_RENAME	dw offset RENAME_PARMS	; ...
		db 0
RENAME_PARMS	db 2			; ...
		db 2
		dw offset FILE_REQUIRED
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CTTY	dw offset CTTY_PARMS	; ...
		db 0
CTTY_PARMS	db 1			; ...
		db 1
		dw offset CTTY_CONTROL1
		db 0
		db 0
CTTY_CONTROL1	dw 2000h		; ...
		dw 11h
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VER	dw offset VER_PARMS	; ...
		db 0
VER_PARMS	db 0			; ...
		db 0
		db 1
		dw offset SLASH_R
		db 0
SLASH_R		dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
SLASH_R_SYN	db '/R',0
Parse_LoadHi	dw offset LoadHi_Parms	; ...
		db 0
LoadHi_Parms	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 0
		db 0
TempVarName	db 'TEMP=',0            ; ...
$P_ORDINAL	dw 0			; ...
$P_RC		dw 0			; ...
$P_SI_Save	dw 0			; ...
$P_DX		dw 0			; ...
$P_Terminator	db 0			; ...
$P_DBCSEV_OFF	dw 0			; ...
$P_DBCSEV_SEG	dw 0			; ...
$P_Flags	db 0			; ...
$P_Flags2	db 0			; ...
$P_SaveSI_Cmpx	dw 0			; ...
$P_KEYorSW_Ptr	dw 0			; ...
$P_Save_EOB	dw 0			; ...
$P_Found_SYNONYM dw 0			; ...
$P_STRING_BUF	db 128 dup(0)		; ...
$P_ORIG_ORD	dw 0			; ...
$P_ORIG_STACK	dw 0			; ...
$P_ORIG_SI	dw 0			; ...
$P_Got_Time	db 0			; ...
$P_Country_Info	dw 0FFFFh		; ...
		db 32 dup(0)
$P_1st_Val	dw 0			; ...
$P_2nd_Val	dw 0			; ...
$P_3rd_Val	dw 0			; ...
$P_4th_Val	dw 0			; ...
$P_Char_CAP_Ptr	db 0FFh			; ...
		dd 0
$P_File_CAP_Ptr	db 0FFh			; ...
		dd 0
$P_FileSp_Char	db '[]|<>+=;"'          ; ...
$P_err_flag	db 0			; ...
$M_RT_$M_EXT_ERR_ADDRS dw 2 dup(0)	; ...
$M_RT_$M_EXT_FILE dw 2 dup(0)		; ...
$M_RT_$M_EXT_COMMAND dw	2 dup(0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_PARSE_COMMAND dw 2 dup(0)	; ...
$M_RT_$M_PARSE_ADDRS dw	2 dup(0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_CRIT_ADDRS dw 2 dup(0)		; ...
$M_RT_$M_CRIT_COMMAND dw 2 dup(0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_DISK_PROC_ADDR	dd 0FFFFFFFFh	; ...
$M_RT_$M_CLASS_ADDRS dw	6 dup(0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_DBCS_VEC dd 0			; ...
$M_RT_$M_HANDLE	dw 0			; ...
$M_RT_$M_SIZE	db 0			; ...
$M_RT_$M_CRLF	dw 0A0Dh		; ...
$M_RT_$M_CLASS	db 0			; ...
$M_RT_$M_RETURN_ADDR dw	0		; ...
$M_RT_$M_MSG_NUM dw 0			; ...
$M_RT_$M_DIVISOR dw 10			; ...
$M_RT_$M_TEMP_BUF dw 2424h		; ...
					; ($M_COUNTRY_INFO.$M_DATE_FORMAT)
					; $M_RT_$M_DATE_FORMAT
$M_RT_$M_CURR_SEPARA db	5 dup('$')
$M_RT_$M_THOU_SEPARA dw	2424h		; ...
$M_RT_$M_DECI_SEPARA dw	2424h		; ...
$M_RT_$M_DATE_SEPARA dw	2424h		; ...
$M_RT_$M_TIME_SEPARA dw	2424h		; ...
$M_RT_$M_CURR_FORMAT db	24h
$M_RT_$M_SIG_DIGS_CU db	24h
$M_RT_$M_TIME_FORMAT db	24h		; ...
		db '$'                  ; 24h
		db 2Dh dup('$')         ; '$'
$M_RT_$M_BUF_TERM db '$'                ; ...
MsDosVer5_CCopy	db 'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp License'
		db 'd Material - Property of Microsoft All rights reserved '
PRINTF_HANDLE	dw 0			; ...
SRCXNAME	db 87 dup(0)		; ...
TRGXNAME	db 87 dup(0)		; ...
UCOMBUF		db 131 dup(0)		; ...
COMBUF		db 131 dup(0)		; ...
USERDIR1	db 70 dup(0)		; ...
EXECPATH	db 131 dup(0)		; ...
RE_INSTR	db 83 dup(0)		; ...
HEADCALL	dw 0			; ...
RESSEG		dw 0			; ...
TPA		dw 0			; ...
SWITCHAR	db 0			; ...
DIRCHAR		db 0			; ...
EXEC_ADDR	dd 0			; ...
RCH_ADDR	dd 0			; ...
		dw 0
TRAN_TPA	dw 0			; ...
CHKDRV		db 0			; ...
IFNOTFLAG	db 0			; ...
CURDRV		db 0			; ...
PARM1		db 0			; ...
PARM2		db 0			; ...
COMSW		dw 0			; ...
ARG1S		dw 0			; ...
ARG2S		dw 0			; ...
ARGTS		dw 0			; ...
CFLAG		db 0			; ...
SPECDRV		db 0			; ...
BYTCNT		dw 0			; ...
NXTADD		dw 0			; ...
FRSTSRCH	db 0			; ...
LeftOnLine	db 0			; ...
PerLine		db 0			; ...
LeftOnPage	dw 0			; ...
FileCnt		dw 0			; ...
FileSiz		dd 0			; ...
FileCntTotal	dd 0			; ...
FileSizTotal	dd 0			; ...
CHARBUF		db 80 dup(0)		; ...
IDLEN		db 0			; ...
ID		db 8 dup(0)		; ...
COM		db 3 dup(0)
DEST		db 37 dup(0)		; ...
DESTNAME	db 11 dup(0)
DESTDIR		db 67 dup(0)		; ...
BWDBUF		dw 4 dup(0)		; ...
					; DIRBUF
DIRBUF_8	db 11 dup(0)		; ...
DIRBUF_8_DIR_ATTR dw 0			; ...
DIRBUF_find_buf_attr db	0		; ...
		db 8 dup(0)
DIRBUF_find_buf_pname db 13 dup(0)	; ...
		db 27 dup(0)
SDIRBUF		db 12 dup(0)		; ...
_Bits		dw 0			; ...
PathCnt		dw 0			; ...
PathPos		dw 0			; ...
PathSw		dw 0			; ...
AttrSpecified	db 0			; ...
AttrSelect	db 0			; ...
comma		db 0			; ...
plus_comma	db 0			; ...
DirFlag		db 0			; ...
parse_last	dw 0			; ...
system_cpage	dw 0			; ...
Arg_Buf		db 128 dup(0)		; ...
File_Size_Low	dw 0			; ...
File_Size_High	dw 0			; ...
string_ptr_2	dw 0			; ...
Copy_num	dw 0			; ...
cpyflag		db 0			; ...
Dir_Num		dw 0			; ...
Bytes_Free	dd 0			; ...
Major_Ver_Num	dw 0			; ...
Minor_Ver_Num	dw 0			; ...
One_Char_Val	db 0			; ...
		db 0
vol_drv		db 0			; ...
ROM_CALL	db 0			; ...
ROM_IP		dw 0			; ...
ROM_CS		dw 0			; ...
DestIsDir	db 0			; ...
DestSiz		db 0			; ...
DestTail	dw 0			; ...
DestInfo	db 0			; ...
DestBuf		db 87 dup(0)		; ...
EndDestBuf	dw 0			; ...
					; DESTHAND
DESTISDEV	db 0			; ...
FIRSTDEST	db 0			; ...
MELCOPY		db 0			; ...
MELSTART	dw 0			; ...
SrcIsDir	db 0			; ...
SrcSiz		db 0			; ...
SrcTail		dw 0			; ...
SrcInfo		db 0			; ...
SrcBuf		db 87 dup(0)		; ...
SRCHAND		dw 0			; ...
SRCISDEV	db 0			; ...
ScanBuf		db 87 dup(0)		; ...
SRCPT		dw 0			; ...
INEXACT		db 0			; ...
NOWRITE		db 0			; ...
BINARY		db 0			; ...
WRITTEN		dw 0			; ...
TERMREAD	db 0			; ...
ASCII		db 0			; ...
PLUS		db 0			; ...
objcnt		db 0			; ...
CPDATE		dw 0			; ...
CPTIME		dw 0			; ...
OFilePtr_Lo	dw 0			; ...
OFilePtr_Hi	dw 0			; ...
OCtrlZ		db 0			; ...
BATHAND		dw 0			; ...
STARTEL		dw 0			; ...
ELCNT		db 0			; ...
ELPOS		db 0			; ...
SKPDEL		db 0			; ...
SOURCE		db 11 dup(0)
ext_entered	db 0			; ...
Display_Ioctl	db 0			; ...
		db 0
		dw 14			; crt_ioctl_ln (length of data)
		dw 0
display_mode	db 0
		db 0
		dw 0
		dw 0
		dw 0
display_width	dw 0			; ...
LinPerPag	dw 25			; ...
vol_ioctl_buf	dw 0			; ...
vol_serial	db 4 dup(0)		; ...
vol_label	db 0Bh dup(20h)
		db 8 dup(20h)
expand_star	db 0			; ...
msg_flag	db 0			; ...
Msg_Numb	dw 0			; ...
append_exec	db 0			; ...
print_err_flag	dw 0			; ...
subst_buffer	db 22 dup(0)		; ...
KPARSE		db 0			; ...
ARG_ARGV	dw 0			; ...
					; ARGV[0]
ARGV0_ARG_FLAGS	db 0			; ...
ARGV0_ARGSTARTEL dw 0			; ...
ARGV0_ARGLEN	dw 0			; ...
ARGV0_ARGSW_WORD dw 0			; ...
ARGV0_OCOMPTR	dw 0			; ...
ARGV1_ARGPOINTER dw 0			; ...
					; ARGV[1]
		db 5 dup(0)
ARGV1_ARGSW_WORD dw 0			; ...
		dw 0
ARGV2_ARGPOINTER dw 0			; ...
					; ARGV[2]
		db 5 dup(0)
ARGV2_ARGSW_WORD dw 0			; ...
		dw 0
		db 671 dup(0)		; ARGV[3] to ARGV[63]
ARG_ARGVCNT	dw 0			; ...
ARG_ARGSWINFO	dw 0			; ...
ARG_ARGBUF	dw 256 dup(0)		; ...
					; times	ARGBLEN	dw 0
ARG_ARGFORCOMBUF db 128	dup(0)		; ...
					; times	COMBUFLEN db 0
ARGBUF_PTR	dw 0			; ...
TPBUF		db 128 dup(0)		; ...
LASTARG		dw 0			; ...
COMPTR		dw 0			; ...
FBUF		db 43 dup(0)		; ...
					; times	FINDBUFLEN db 0
pathinfo	dw 3 dup(0)		; ...
psep_char	db 0			; ...
search_best	db 0			; ...
search_best_buf	db 13 dup(0)		; ...
					; times	FNAME_MAX_LEN db 0
search_curdir_buf db 64	dup(0)		; ...
					; times	64 db 0
search_error	dw 0			; ...
IF_NOT_COUNT	dw 0			; ...
zflag		db 0			; ...
		dw 128 dup(0)
STACK		db 32 dup(0)		; ...
					; INTERNATVARS
CountryPtrInfo	db 0			; ...
CountryPtr	dd 0			; ...
OldCtrlCHandler	dd 0			; ...
BATBUFPOS	dw 0			; ...
BATBUF		db 32 dup(0)		; ...
BATBUFEND	dw 0			; ...
TypeFilSiz	dw 2 dup(0)		; ...
PARSE1_OUTPUT	db 0			; ...
					; PARSE1_TYPE
PARSE1_CODE	db 0			; ...
PARSE1_SYN	dw 0			; ...
PARSE1_ADDR	dd 0			; ...
DATE_OUTPUT	db 0			; ...
					; DATE_TYPE
		db 0			; return value
		dw 0			; offset of synonym
DATE_YEAR	dw 0			; ...
DATE_MONTH	db 0			; ...
DATE_DAY	db 0			; ...
TIME_OUTPUT	db 0			; ...
					; TIME_TYPE
		db 0			; return value
		dw 0			; offset
TIME_HOUR	db 0			; ...
TIME_MINUTES	db 0			; ...
TIME_SECONDS	db 0			; ...
TIME_FRACTION	db 0			; ...
DRIVE_OUTPUT	db 0			; ...
					; DRIVE_TYPE
DRIVE_VALUE	db 0			; return value
		dw 0			; offset
DRIVE_NUMBER	db 0
		db 3 dup(0)		; reserved
TRANGROUP	ends


		end StartCode
